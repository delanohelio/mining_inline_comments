{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg5NDg3MzQ4", "number": 1061, "reviewThreads": {"totalCount": 78, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMToyNjo1NFrOElHx4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQyMzo1NDozN1rOEnqNWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MzYwMjI2OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMToyNjo1NFrOHUcXoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMToyNjo1NFrOHUcXoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE5ODM2OQ==", "bodyText": "Ignore TokenBalanceSerializer, left over from a previous thought, will remove", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491198369", "createdAt": "2020-09-18T21:26:54Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),\n+        token_id            entity_id   not null,\n+        balance             bigint;\n+```\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Update `t_entities` table with token entity info, from the `TokenCreation.proto` object insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` class to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        consensus_timestamp bigint  primary key not null,\n+        symbol              character varying(96),\n+        token_id            entity_id,\n+        initial_supply      bigint,\n+        divisibility        bigint,\n+        treasury            entity_id,\n+        kyc_key             bytea,\n+        freeze_key          bytea,\n+        wipe_key            bytea,\n+        supply_key          bytea,\n+        freeze_default      boolean,\n+        kyc_default         boolean,\n+        freeze_default      boolean;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add `TokenBalanceSerializer` converter to handle object to JSON string serialization\n+```java\n+   @Named\n+   public class TokenBalanceSerializer extends JsonSerializer<List<TokenBalance>> {\n+       @Override\n+       public void serialize(List<TokenBalance> tokens, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+           if (value != null) {\n+               gen.writeStartArray();\n+               for (TokenBalance token: tokens) {\n+                   gen.writeStartObject();\n+                   gen.writeObjectField(\"token\", token);\n+                   gen.writeEndObject();\n+               }\n+               gen.writeEndArray();\n+           }\n+       }\n+   }\n+   ```\n+\n+or\n+\n+```java\n+    @Named\n+    public class TokenBalanceSerializer extends JsonSerializer<List<TokenBalance>> {\n+        @Override\n+        public void serialize(List<TokenBalance> tokens, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+            if (value != null) {\n+                gen.writeStartArray();\n+                for (TokenBalance token: tokens) {\n+                    gen.writeObject(token);\n+                }\n+                gen.writeEndArray();\n+            }\n+        }\n+    }\n+```", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 190}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MzYwODE4OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMToyOTozNVrOHUca9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMToyOTozNVrOHUca9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE5OTIyMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            -   Add `TokenBalance` with `tokens` private class member\n          \n          \n            \n            -   Add `TokenBalance`", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491199220", "createdAt": "2020-09-18T21:29:35Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),\n+        token_id            entity_id   not null,\n+        balance             bigint;\n+```\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Update `t_entities` table with token entity info, from the `TokenCreation.proto` object insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` class to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        consensus_timestamp bigint  primary key not null,\n+        symbol              character varying(96),\n+        token_id            entity_id,\n+        initial_supply      bigint,\n+        divisibility        bigint,\n+        treasury            entity_id,\n+        kyc_key             bytea,\n+        freeze_key          bytea,\n+        wipe_key            bytea,\n+        supply_key          bytea,\n+        freeze_default      boolean,\n+        kyc_default         boolean,\n+        freeze_default      boolean;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add `TokenBalanceSerializer` converter to handle object to JSON string serialization\n+```java\n+   @Named\n+   public class TokenBalanceSerializer extends JsonSerializer<List<TokenBalance>> {\n+       @Override\n+       public void serialize(List<TokenBalance> tokens, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+           if (value != null) {\n+               gen.writeStartArray();\n+               for (TokenBalance token: tokens) {\n+                   gen.writeStartObject();\n+                   gen.writeObjectField(\"token\", token);\n+                   gen.writeEndObject();\n+               }\n+               gen.writeEndArray();\n+           }\n+       }\n+   }\n+   ```\n+\n+or\n+\n+```java\n+    @Named\n+    public class TokenBalanceSerializer extends JsonSerializer<List<TokenBalance>> {\n+        @Override\n+        public void serialize(List<TokenBalance> tokens, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+            if (value != null) {\n+                gen.writeStartArray();\n+                for (TokenBalance token: tokens) {\n+                    gen.writeObject(token);\n+                }\n+                gen.writeEndArray();\n+            }\n+        }\n+    }\n+```\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public FileIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+-   Add `TokenBalance` with `tokens` private class member", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 206}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MzYyMjg0OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMTozNjo0MFrOHUcjpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMTozNjo0MFrOHUcjpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIwMTQ0Nw==", "bodyText": "replace serialVersionUID w unique one as this was copied", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491201447", "createdAt": "2020-09-18T21:36:40Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),\n+        token_id            entity_id   not null,\n+        balance             bigint;\n+```\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Update `t_entities` table with token entity info, from the `TokenCreation.proto` object insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` class to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        consensus_timestamp bigint  primary key not null,\n+        symbol              character varying(96),\n+        token_id            entity_id,\n+        initial_supply      bigint,\n+        divisibility        bigint,\n+        treasury            entity_id,\n+        kyc_key             bytea,\n+        freeze_key          bytea,\n+        wipe_key            bytea,\n+        supply_key          bytea,\n+        freeze_default      boolean,\n+        kyc_default         boolean,\n+        freeze_default      boolean;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add `TokenBalanceSerializer` converter to handle object to JSON string serialization\n+```java\n+   @Named\n+   public class TokenBalanceSerializer extends JsonSerializer<List<TokenBalance>> {\n+       @Override\n+       public void serialize(List<TokenBalance> tokens, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+           if (value != null) {\n+               gen.writeStartArray();\n+               for (TokenBalance token: tokens) {\n+                   gen.writeStartObject();\n+                   gen.writeObjectField(\"token\", token);\n+                   gen.writeEndObject();\n+               }\n+               gen.writeEndArray();\n+           }\n+       }\n+   }\n+   ```\n+\n+or\n+\n+```java\n+    @Named\n+    public class TokenBalanceSerializer extends JsonSerializer<List<TokenBalance>> {\n+        @Override\n+        public void serialize(List<TokenBalance> tokens, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+            if (value != null) {\n+                gen.writeStartArray();\n+                for (TokenBalance token: tokens) {\n+                    gen.writeObject(token);\n+                }\n+                gen.writeEndArray();\n+            }\n+        }\n+    }\n+```\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public FileIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+-   Add `TokenBalance` with `tokens` private class member\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        private String symbol;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = -2399552489266593375L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 229}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MzYyNjU3OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMTozODoxN1rOHUclxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMTozODoxN1rOHUclxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIwMTk5MA==", "bodyText": "remove repeated\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    freeze_default      boolean;\n          \n          \n            \n            ;", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491201990", "createdAt": "2020-09-18T21:38:17Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),\n+        token_id            entity_id   not null,\n+        balance             bigint;\n+```\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Update `t_entities` table with token entity info, from the `TokenCreation.proto` object insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` class to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        consensus_timestamp bigint  primary key not null,\n+        symbol              character varying(96),\n+        token_id            entity_id,\n+        initial_supply      bigint,\n+        divisibility        bigint,\n+        treasury            entity_id,\n+        kyc_key             bytea,\n+        freeze_key          bytea,\n+        wipe_key            bytea,\n+        supply_key          bytea,\n+        freeze_default      boolean,\n+        kyc_default         boolean,\n+        freeze_default      boolean;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MzYzMTYzOnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMTo0MDo0MFrOHUcouw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMTo0MDo0MFrOHUcouw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIwMjc0Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            -   Update `AccountBalanceLineParser.parse` to parse additional token columns representing `TokenRelationships`.\n          \n          \n            \n            -   Update `AccountBalanceLineParser.parse` to parse additional token column representing `TokenRelationships`.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491202747", "createdAt": "2020-09-18T21:40:40Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),\n+        token_id            entity_id   not null,\n+        balance             bigint;\n+```\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Update `t_entities` table with token entity info, from the `TokenCreation.proto` object insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` class to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        consensus_timestamp bigint  primary key not null,\n+        symbol              character varying(96),\n+        token_id            entity_id,\n+        initial_supply      bigint,\n+        divisibility        bigint,\n+        treasury            entity_id,\n+        kyc_key             bytea,\n+        freeze_key          bytea,\n+        wipe_key            bytea,\n+        supply_key          bytea,\n+        freeze_default      boolean,\n+        kyc_default         boolean,\n+        freeze_default      boolean;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add `TokenBalanceSerializer` converter to handle object to JSON string serialization\n+```java\n+   @Named\n+   public class TokenBalanceSerializer extends JsonSerializer<List<TokenBalance>> {\n+       @Override\n+       public void serialize(List<TokenBalance> tokens, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+           if (value != null) {\n+               gen.writeStartArray();\n+               for (TokenBalance token: tokens) {\n+                   gen.writeStartObject();\n+                   gen.writeObjectField(\"token\", token);\n+                   gen.writeEndObject();\n+               }\n+               gen.writeEndArray();\n+           }\n+       }\n+   }\n+   ```\n+\n+or\n+\n+```java\n+    @Named\n+    public class TokenBalanceSerializer extends JsonSerializer<List<TokenBalance>> {\n+        @Override\n+        public void serialize(List<TokenBalance> tokens, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+            if (value != null) {\n+                gen.writeStartArray();\n+                for (TokenBalance token: tokens) {\n+                    gen.writeObject(token);\n+                }\n+                gen.writeEndArray();\n+            }\n+        }\n+    }\n+```\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public FileIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+-   Add `TokenBalance` with `tokens` private class member\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        private String symbol;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = -2399552489266593375L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` and `symbol` class members, to allow it to represent both HBARs and Tokens\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String symbol;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasury;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+\n+\n+### Balance Persistence\n+\n+-   Update `AccountBalanceLineParser.parse` to parse additional token columns representing `TokenRelationships`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 282}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MzY0ODAzOnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMTo0Nzo0OVrOHUczEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMTo1NzoxNVrOHUdIfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIwNTM5Mw==", "bodyText": "Add TransactionHandlers\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n            ### Transaction Handlers", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491205393", "createdAt": "2020-09-18T21:47:49Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),\n+        token_id            entity_id   not null,\n+        balance             bigint;\n+```\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Update `t_entities` table with token entity info, from the `TokenCreation.proto` object insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` class to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        consensus_timestamp bigint  primary key not null,\n+        symbol              character varying(96),\n+        token_id            entity_id,\n+        initial_supply      bigint,\n+        divisibility        bigint,\n+        treasury            entity_id,\n+        kyc_key             bytea,\n+        freeze_key          bytea,\n+        wipe_key            bytea,\n+        supply_key          bytea,\n+        freeze_default      boolean,\n+        kyc_default         boolean,\n+        freeze_default      boolean;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add `TokenBalanceSerializer` converter to handle object to JSON string serialization\n+```java\n+   @Named\n+   public class TokenBalanceSerializer extends JsonSerializer<List<TokenBalance>> {\n+       @Override\n+       public void serialize(List<TokenBalance> tokens, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+           if (value != null) {\n+               gen.writeStartArray();\n+               for (TokenBalance token: tokens) {\n+                   gen.writeStartObject();\n+                   gen.writeObjectField(\"token\", token);\n+                   gen.writeEndObject();\n+               }\n+               gen.writeEndArray();\n+           }\n+       }\n+   }\n+   ```\n+\n+or\n+\n+```java\n+    @Named\n+    public class TokenBalanceSerializer extends JsonSerializer<List<TokenBalance>> {\n+        @Override\n+        public void serialize(List<TokenBalance> tokens, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+            if (value != null) {\n+                gen.writeStartArray();\n+                for (TokenBalance token: tokens) {\n+                    gen.writeObject(token);\n+                }\n+                gen.writeEndArray();\n+            }\n+        }\n+    }\n+```\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public FileIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+-   Add `TokenBalance` with `tokens` private class member\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        private String symbol;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = -2399552489266593375L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` and `symbol` class members, to allow it to represent both HBARs and Tokens\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String symbol;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasury;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+\n+\n+### Balance Persistence\n+\n+-   Update `AccountBalanceLineParser.parse` to parse additional token columns representing `TokenRelationships`.\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance, symbol) values (?, ?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Add `UPDATE_TOKEN_STATUS` in `AccountBalancesFileLoader` to update changes to `kycStatus` and `freezeStatus`\n+```java\n+    private static final String UPDATE_TOKEN_STATUS = \"update token_balance set kyc_status = ?, \" +\n+                \"freeze_status = ? where token_id = ?\";\n+```\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 294}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIxMDg3OQ==", "bodyText": "Working on this", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491210879", "createdAt": "2020-09-18T21:57:15Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),\n+        token_id            entity_id   not null,\n+        balance             bigint;\n+```\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Update `t_entities` table with token entity info, from the `TokenCreation.proto` object insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` class to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        consensus_timestamp bigint  primary key not null,\n+        symbol              character varying(96),\n+        token_id            entity_id,\n+        initial_supply      bigint,\n+        divisibility        bigint,\n+        treasury            entity_id,\n+        kyc_key             bytea,\n+        freeze_key          bytea,\n+        wipe_key            bytea,\n+        supply_key          bytea,\n+        freeze_default      boolean,\n+        kyc_default         boolean,\n+        freeze_default      boolean;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add `TokenBalanceSerializer` converter to handle object to JSON string serialization\n+```java\n+   @Named\n+   public class TokenBalanceSerializer extends JsonSerializer<List<TokenBalance>> {\n+       @Override\n+       public void serialize(List<TokenBalance> tokens, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+           if (value != null) {\n+               gen.writeStartArray();\n+               for (TokenBalance token: tokens) {\n+                   gen.writeStartObject();\n+                   gen.writeObjectField(\"token\", token);\n+                   gen.writeEndObject();\n+               }\n+               gen.writeEndArray();\n+           }\n+       }\n+   }\n+   ```\n+\n+or\n+\n+```java\n+    @Named\n+    public class TokenBalanceSerializer extends JsonSerializer<List<TokenBalance>> {\n+        @Override\n+        public void serialize(List<TokenBalance> tokens, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+            if (value != null) {\n+                gen.writeStartArray();\n+                for (TokenBalance token: tokens) {\n+                    gen.writeObject(token);\n+                }\n+                gen.writeEndArray();\n+            }\n+        }\n+    }\n+```\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public FileIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+-   Add `TokenBalance` with `tokens` private class member\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        private String symbol;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = -2399552489266593375L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` and `symbol` class members, to allow it to represent both HBARs and Tokens\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String symbol;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasury;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+\n+\n+### Balance Persistence\n+\n+-   Update `AccountBalanceLineParser.parse` to parse additional token columns representing `TokenRelationships`.\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance, symbol) values (?, ?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Add `UPDATE_TOKEN_STATUS` in `AccountBalancesFileLoader` to update changes to `kycStatus` and `freezeStatus`\n+```java\n+    private static final String UPDATE_TOKEN_STATUS = \"update token_balance set kyc_status = ?, \" +\n+                \"freeze_status = ? where token_id = ?\";\n+```\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIwNTM5Mw=="}, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 294}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MzY1ODUwOnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMTo1MDozOVrOHUc5sA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMTo1MDozOVrOHUc5sA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIwNzA4OA==", "bodyText": "Eventually we'll need a tokenInfo endpoint\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            5.  Add a Token Discovery REST API to show available tokens on the network\n          \n          \n            \n            6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<symbol>`", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491207088", "createdAt": "2020-09-18T21:50:39Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),\n+        token_id            entity_id   not null,\n+        balance             bigint;\n+```\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Update `t_entities` table with token entity info, from the `TokenCreation.proto` object insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` class to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        consensus_timestamp bigint  primary key not null,\n+        symbol              character varying(96),\n+        token_id            entity_id,\n+        initial_supply      bigint,\n+        divisibility        bigint,\n+        treasury            entity_id,\n+        kyc_key             bytea,\n+        freeze_key          bytea,\n+        wipe_key            bytea,\n+        supply_key          bytea,\n+        freeze_default      boolean,\n+        kyc_default         boolean,\n+        freeze_default      boolean;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add `TokenBalanceSerializer` converter to handle object to JSON string serialization\n+```java\n+   @Named\n+   public class TokenBalanceSerializer extends JsonSerializer<List<TokenBalance>> {\n+       @Override\n+       public void serialize(List<TokenBalance> tokens, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+           if (value != null) {\n+               gen.writeStartArray();\n+               for (TokenBalance token: tokens) {\n+                   gen.writeStartObject();\n+                   gen.writeObjectField(\"token\", token);\n+                   gen.writeEndObject();\n+               }\n+               gen.writeEndArray();\n+           }\n+       }\n+   }\n+   ```\n+\n+or\n+\n+```java\n+    @Named\n+    public class TokenBalanceSerializer extends JsonSerializer<List<TokenBalance>> {\n+        @Override\n+        public void serialize(List<TokenBalance> tokens, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+            if (value != null) {\n+                gen.writeStartArray();\n+                for (TokenBalance token: tokens) {\n+                    gen.writeObject(token);\n+                }\n+                gen.writeEndArray();\n+            }\n+        }\n+    }\n+```\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public FileIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+-   Add `TokenBalance` with `tokens` private class member\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        private String symbol;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = -2399552489266593375L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` and `symbol` class members, to allow it to represent both HBARs and Tokens\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String symbol;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasury;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+\n+\n+### Balance Persistence\n+\n+-   Update `AccountBalanceLineParser.parse` to parse additional token columns representing `TokenRelationships`.\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance, symbol) values (?, ?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Add `UPDATE_TOKEN_STATUS` in `AccountBalancesFileLoader` to update changes to `kycStatus` and `freezeStatus`\n+```java\n+    private static final String UPDATE_TOKEN_STATUS = \"update token_balance set kyc_status = ?, \" +\n+                \"freeze_status = ? where token_id = ?\";\n+```\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer`. Also pulling out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId token, String symbol) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId, symbol));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for tokenId and symbol\n+\n+> _Note 1:_ For improved API calls it would be valuable to insert the symbol for cryptoTransfers. This is only available on the tokenCreate transaction, so a caching mechanism can be explored ot make this available for transfers\n+\n+> _Note 2:_ There's an opportunity to refactor the `OnItem()` to focus better on different TransactionBody types but not necessarily within scope\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts\n+5.  Add a Token Discovery REST API to show available tokens on the network", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 321}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MzY2MzQxOnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMTo1MjoxN1rOHUc8yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMTo1MjoxN1rOHUc8yg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIwNzg4Mg==", "bodyText": "Add api url here for context", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491207882", "createdAt": "2020-09-18T21:52:17Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),\n+        token_id            entity_id   not null,\n+        balance             bigint;\n+```\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Update `t_entities` table with token entity info, from the `TokenCreation.proto` object insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` class to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        consensus_timestamp bigint  primary key not null,\n+        symbol              character varying(96),\n+        token_id            entity_id,\n+        initial_supply      bigint,\n+        divisibility        bigint,\n+        treasury            entity_id,\n+        kyc_key             bytea,\n+        freeze_key          bytea,\n+        wipe_key            bytea,\n+        supply_key          bytea,\n+        freeze_default      boolean,\n+        kyc_default         boolean,\n+        freeze_default      boolean;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add `TokenBalanceSerializer` converter to handle object to JSON string serialization\n+```java\n+   @Named\n+   public class TokenBalanceSerializer extends JsonSerializer<List<TokenBalance>> {\n+       @Override\n+       public void serialize(List<TokenBalance> tokens, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+           if (value != null) {\n+               gen.writeStartArray();\n+               for (TokenBalance token: tokens) {\n+                   gen.writeStartObject();\n+                   gen.writeObjectField(\"token\", token);\n+                   gen.writeEndObject();\n+               }\n+               gen.writeEndArray();\n+           }\n+       }\n+   }\n+   ```\n+\n+or\n+\n+```java\n+    @Named\n+    public class TokenBalanceSerializer extends JsonSerializer<List<TokenBalance>> {\n+        @Override\n+        public void serialize(List<TokenBalance> tokens, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+            if (value != null) {\n+                gen.writeStartArray();\n+                for (TokenBalance token: tokens) {\n+                    gen.writeObject(token);\n+                }\n+                gen.writeEndArray();\n+            }\n+        }\n+    }\n+```\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public FileIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+-   Add `TokenBalance` with `tokens` private class member\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        private String symbol;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = -2399552489266593375L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` and `symbol` class members, to allow it to represent both HBARs and Tokens\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String symbol;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasury;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+\n+\n+### Balance Persistence\n+\n+-   Update `AccountBalanceLineParser.parse` to parse additional token columns representing `TokenRelationships`.\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance, symbol) values (?, ?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Add `UPDATE_TOKEN_STATUS` in `AccountBalancesFileLoader` to update changes to `kycStatus` and `freezeStatus`\n+```java\n+    private static final String UPDATE_TOKEN_STATUS = \"update token_balance set kyc_status = ?, \" +\n+                \"freeze_status = ? where token_id = ?\";\n+```\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer`. Also pulling out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId token, String symbol) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId, symbol));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for tokenId and symbol\n+\n+> _Note 1:_ For improved API calls it would be valuable to insert the symbol for cryptoTransfers. This is only available on the tokenCreate transaction, so a caching mechanism can be explored ot make this available for transfers\n+\n+> _Note 2:_ There's an opportunity to refactor the `OnItem()` to focus better on different TransactionBody types but not necessarily within scope\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 320}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MzY2NzQwOnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMTo1MzoyOFrOHUc_cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMDo1Mzo0NlrOHXsP6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIwODU2Mg==", "bodyText": "Need to circle back, these were initial suggestions based on current API's", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491208562", "createdAt": "2020-09-18T21:53:28Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),\n+        token_id            entity_id   not null,\n+        balance             bigint;\n+```\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Update `t_entities` table with token entity info, from the `TokenCreation.proto` object insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` class to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        consensus_timestamp bigint  primary key not null,\n+        symbol              character varying(96),\n+        token_id            entity_id,\n+        initial_supply      bigint,\n+        divisibility        bigint,\n+        treasury            entity_id,\n+        kyc_key             bytea,\n+        freeze_key          bytea,\n+        wipe_key            bytea,\n+        supply_key          bytea,\n+        freeze_default      boolean,\n+        kyc_default         boolean,\n+        freeze_default      boolean;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add `TokenBalanceSerializer` converter to handle object to JSON string serialization\n+```java\n+   @Named\n+   public class TokenBalanceSerializer extends JsonSerializer<List<TokenBalance>> {\n+       @Override\n+       public void serialize(List<TokenBalance> tokens, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+           if (value != null) {\n+               gen.writeStartArray();\n+               for (TokenBalance token: tokens) {\n+                   gen.writeStartObject();\n+                   gen.writeObjectField(\"token\", token);\n+                   gen.writeEndObject();\n+               }\n+               gen.writeEndArray();\n+           }\n+       }\n+   }\n+   ```\n+\n+or\n+\n+```java\n+    @Named\n+    public class TokenBalanceSerializer extends JsonSerializer<List<TokenBalance>> {\n+        @Override\n+        public void serialize(List<TokenBalance> tokens, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+            if (value != null) {\n+                gen.writeStartArray();\n+                for (TokenBalance token: tokens) {\n+                    gen.writeObject(token);\n+                }\n+                gen.writeEndArray();\n+            }\n+        }\n+    }\n+```\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public FileIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+-   Add `TokenBalance` with `tokens` private class member\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        private String symbol;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = -2399552489266593375L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` and `symbol` class members, to allow it to represent both HBARs and Tokens\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String symbol;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasury;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+\n+\n+### Balance Persistence\n+\n+-   Update `AccountBalanceLineParser.parse` to parse additional token columns representing `TokenRelationships`.\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance, symbol) values (?, ?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Add `UPDATE_TOKEN_STATUS` in `AccountBalancesFileLoader` to update changes to `kycStatus` and `freezeStatus`\n+```java\n+    private static final String UPDATE_TOKEN_STATUS = \"update token_balance set kyc_status = ?, \" +\n+                \"freeze_status = ? where token_id = ?\";\n+```\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer`. Also pulling out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId token, String symbol) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId, symbol));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for tokenId and symbol\n+\n+> _Note 1:_ For improved API calls it would be valuable to insert the symbol for cryptoTransfers. This is only available on the tokenCreate transaction, so a caching mechanism can be explored ot make this available for transfers\n+\n+> _Note 2:_ There's an opportunity to refactor the `OnItem()` to focus better on different TransactionBody types but not necessarily within scope\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts\n+5.  Add a Token Discovery REST API to show available tokens on the network\n+\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"symbol\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"symbol\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` and `symbol` columns from `token_balance` where `token_balance.id` = <tokenId> and assign each row to an element of `tokenBalances`\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"symbol\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+To achieve this\n+-   Update `balances.js` `getBalances()` to pull the `balance` and `symbol` columns from `token_balance` where `token_balance.id` = <tokenId> and assign each row to an element of `tokenBalances`\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"tokenTransfers\": [\n+            {\n+              \"currency\":\"0.0.5555\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.1111\", \"amount\": -10},\n+                {\"account\": \"0.0.2222\", \"amount\": 10}\n+              ]\n+            },\n+            {\n+              \"currency\": \"0.0.6666\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.3333\", \"amount\": -10},\n+                {\"account\": \"0.0.4444\", \"amount\": 10}\n+               ]\n+            }\n+          ]\n+        }\n+      ]\n+    }\n+```\n+\n+To achieve this\n+-   Update `transactions.js` sql queries for `crypto_transfer` to pull the `token_id` and `symbol` columns\n+-   Update `createTransferLists()` in `transactions.js` to build a `tokenTransfers` list if `symbol` isn't HBAR or if `token_id` is empty\n+\n+\n+### Token Supply distribution\n+\n+`/api/v1/tokens/<symbol>/balances` this could be the equivalent of `/api/v1/balances?symbol=<symbol>` currently and would return a list of account and the token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokenBalances\": [\n+          {\n+            \"account\": \"0.15.10\",\n+            \"balance\": 100\n+          },\n+          {\n+            \"account\": \"0.15.9\",\n+            \"balance\": 90\n+          },\n+          {\n+            \"account\": \"0.15.8\",\n+            \"balance\": 80\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+To achieve this similar to balances\n+-   Create a `tokenBalance.js`\n+-   Add a `getTokenBalances()` which based on the time range provided (default to latest timestamp) and token `symbol` pulls out all the  `balance` and `symbol` values and returns them as an element in `tokenBalances` array\n+\n+```sql\n+    select account_id, balance from token_balance where symbol = ? and consensus_timestamp = (select max(consensus_timestamp) from token_balance);\n+```\n+\n+Query parameters should include", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 496}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYwNDI2NQ==", "bodyText": "Provide parity with /accounts and /balances APIs where applicable i.e. filtering on accountId, tokenId and publicKey", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494604265", "createdAt": "2020-09-24T20:53:46Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),\n+        token_id            entity_id   not null,\n+        balance             bigint;\n+```\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Update `t_entities` table with token entity info, from the `TokenCreation.proto` object insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` class to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        consensus_timestamp bigint  primary key not null,\n+        symbol              character varying(96),\n+        token_id            entity_id,\n+        initial_supply      bigint,\n+        divisibility        bigint,\n+        treasury            entity_id,\n+        kyc_key             bytea,\n+        freeze_key          bytea,\n+        wipe_key            bytea,\n+        supply_key          bytea,\n+        freeze_default      boolean,\n+        kyc_default         boolean,\n+        freeze_default      boolean;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add `TokenBalanceSerializer` converter to handle object to JSON string serialization\n+```java\n+   @Named\n+   public class TokenBalanceSerializer extends JsonSerializer<List<TokenBalance>> {\n+       @Override\n+       public void serialize(List<TokenBalance> tokens, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+           if (value != null) {\n+               gen.writeStartArray();\n+               for (TokenBalance token: tokens) {\n+                   gen.writeStartObject();\n+                   gen.writeObjectField(\"token\", token);\n+                   gen.writeEndObject();\n+               }\n+               gen.writeEndArray();\n+           }\n+       }\n+   }\n+   ```\n+\n+or\n+\n+```java\n+    @Named\n+    public class TokenBalanceSerializer extends JsonSerializer<List<TokenBalance>> {\n+        @Override\n+        public void serialize(List<TokenBalance> tokens, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+            if (value != null) {\n+                gen.writeStartArray();\n+                for (TokenBalance token: tokens) {\n+                    gen.writeObject(token);\n+                }\n+                gen.writeEndArray();\n+            }\n+        }\n+    }\n+```\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public FileIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+-   Add `TokenBalance` with `tokens` private class member\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        private String symbol;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = -2399552489266593375L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` and `symbol` class members, to allow it to represent both HBARs and Tokens\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String symbol;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasury;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+\n+\n+### Balance Persistence\n+\n+-   Update `AccountBalanceLineParser.parse` to parse additional token columns representing `TokenRelationships`.\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance, symbol) values (?, ?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Add `UPDATE_TOKEN_STATUS` in `AccountBalancesFileLoader` to update changes to `kycStatus` and `freezeStatus`\n+```java\n+    private static final String UPDATE_TOKEN_STATUS = \"update token_balance set kyc_status = ?, \" +\n+                \"freeze_status = ? where token_id = ?\";\n+```\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer`. Also pulling out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId token, String symbol) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId, symbol));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for tokenId and symbol\n+\n+> _Note 1:_ For improved API calls it would be valuable to insert the symbol for cryptoTransfers. This is only available on the tokenCreate transaction, so a caching mechanism can be explored ot make this available for transfers\n+\n+> _Note 2:_ There's an opportunity to refactor the `OnItem()` to focus better on different TransactionBody types but not necessarily within scope\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts\n+5.  Add a Token Discovery REST API to show available tokens on the network\n+\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"symbol\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"symbol\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` and `symbol` columns from `token_balance` where `token_balance.id` = <tokenId> and assign each row to an element of `tokenBalances`\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"symbol\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+To achieve this\n+-   Update `balances.js` `getBalances()` to pull the `balance` and `symbol` columns from `token_balance` where `token_balance.id` = <tokenId> and assign each row to an element of `tokenBalances`\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"tokenTransfers\": [\n+            {\n+              \"currency\":\"0.0.5555\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.1111\", \"amount\": -10},\n+                {\"account\": \"0.0.2222\", \"amount\": 10}\n+              ]\n+            },\n+            {\n+              \"currency\": \"0.0.6666\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.3333\", \"amount\": -10},\n+                {\"account\": \"0.0.4444\", \"amount\": 10}\n+               ]\n+            }\n+          ]\n+        }\n+      ]\n+    }\n+```\n+\n+To achieve this\n+-   Update `transactions.js` sql queries for `crypto_transfer` to pull the `token_id` and `symbol` columns\n+-   Update `createTransferLists()` in `transactions.js` to build a `tokenTransfers` list if `symbol` isn't HBAR or if `token_id` is empty\n+\n+\n+### Token Supply distribution\n+\n+`/api/v1/tokens/<symbol>/balances` this could be the equivalent of `/api/v1/balances?symbol=<symbol>` currently and would return a list of account and the token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokenBalances\": [\n+          {\n+            \"account\": \"0.15.10\",\n+            \"balance\": 100\n+          },\n+          {\n+            \"account\": \"0.15.9\",\n+            \"balance\": 90\n+          },\n+          {\n+            \"account\": \"0.15.8\",\n+            \"balance\": 80\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+To achieve this similar to balances\n+-   Create a `tokenBalance.js`\n+-   Add a `getTokenBalances()` which based on the time range provided (default to latest timestamp) and token `symbol` pulls out all the  `balance` and `symbol` values and returns them as an element in `tokenBalances` array\n+\n+```sql\n+    select account_id, balance from token_balance where symbol = ? and consensus_timestamp = (select max(consensus_timestamp) from token_balance);\n+```\n+\n+Query parameters should include", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIwODU2Mg=="}, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 496}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MzY3MTM4OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMTo1NDo0MlrOHUdCIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMTo1NDo0MlrOHUdCIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIwOTI0OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Query parameters should include\n          \n          \n            \n            Optional Filters", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491209248", "createdAt": "2020-09-18T21:54:42Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),\n+        token_id            entity_id   not null,\n+        balance             bigint;\n+```\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Update `t_entities` table with token entity info, from the `TokenCreation.proto` object insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` class to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        consensus_timestamp bigint  primary key not null,\n+        symbol              character varying(96),\n+        token_id            entity_id,\n+        initial_supply      bigint,\n+        divisibility        bigint,\n+        treasury            entity_id,\n+        kyc_key             bytea,\n+        freeze_key          bytea,\n+        wipe_key            bytea,\n+        supply_key          bytea,\n+        freeze_default      boolean,\n+        kyc_default         boolean,\n+        freeze_default      boolean;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add `TokenBalanceSerializer` converter to handle object to JSON string serialization\n+```java\n+   @Named\n+   public class TokenBalanceSerializer extends JsonSerializer<List<TokenBalance>> {\n+       @Override\n+       public void serialize(List<TokenBalance> tokens, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+           if (value != null) {\n+               gen.writeStartArray();\n+               for (TokenBalance token: tokens) {\n+                   gen.writeStartObject();\n+                   gen.writeObjectField(\"token\", token);\n+                   gen.writeEndObject();\n+               }\n+               gen.writeEndArray();\n+           }\n+       }\n+   }\n+   ```\n+\n+or\n+\n+```java\n+    @Named\n+    public class TokenBalanceSerializer extends JsonSerializer<List<TokenBalance>> {\n+        @Override\n+        public void serialize(List<TokenBalance> tokens, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+            if (value != null) {\n+                gen.writeStartArray();\n+                for (TokenBalance token: tokens) {\n+                    gen.writeObject(token);\n+                }\n+                gen.writeEndArray();\n+            }\n+        }\n+    }\n+```\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public FileIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+-   Add `TokenBalance` with `tokens` private class member\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        private String symbol;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = -2399552489266593375L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` and `symbol` class members, to allow it to represent both HBARs and Tokens\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String symbol;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasury;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+\n+\n+### Balance Persistence\n+\n+-   Update `AccountBalanceLineParser.parse` to parse additional token columns representing `TokenRelationships`.\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance, symbol) values (?, ?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Add `UPDATE_TOKEN_STATUS` in `AccountBalancesFileLoader` to update changes to `kycStatus` and `freezeStatus`\n+```java\n+    private static final String UPDATE_TOKEN_STATUS = \"update token_balance set kyc_status = ?, \" +\n+                \"freeze_status = ? where token_id = ?\";\n+```\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer`. Also pulling out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId token, String symbol) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId, symbol));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for tokenId and symbol\n+\n+> _Note 1:_ For improved API calls it would be valuable to insert the symbol for cryptoTransfers. This is only available on the tokenCreate transaction, so a caching mechanism can be explored ot make this available for transfers\n+\n+> _Note 2:_ There's an opportunity to refactor the `OnItem()` to focus better on different TransactionBody types but not necessarily within scope\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts\n+5.  Add a Token Discovery REST API to show available tokens on the network\n+\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"symbol\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"symbol\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` and `symbol` columns from `token_balance` where `token_balance.id` = <tokenId> and assign each row to an element of `tokenBalances`\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"symbol\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+To achieve this\n+-   Update `balances.js` `getBalances()` to pull the `balance` and `symbol` columns from `token_balance` where `token_balance.id` = <tokenId> and assign each row to an element of `tokenBalances`\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"tokenTransfers\": [\n+            {\n+              \"currency\":\"0.0.5555\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.1111\", \"amount\": -10},\n+                {\"account\": \"0.0.2222\", \"amount\": 10}\n+              ]\n+            },\n+            {\n+              \"currency\": \"0.0.6666\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.3333\", \"amount\": -10},\n+                {\"account\": \"0.0.4444\", \"amount\": 10}\n+               ]\n+            }\n+          ]\n+        }\n+      ]\n+    }\n+```\n+\n+To achieve this\n+-   Update `transactions.js` sql queries for `crypto_transfer` to pull the `token_id` and `symbol` columns\n+-   Update `createTransferLists()` in `transactions.js` to build a `tokenTransfers` list if `symbol` isn't HBAR or if `token_id` is empty\n+\n+\n+### Token Supply distribution\n+\n+`/api/v1/tokens/<symbol>/balances` this could be the equivalent of `/api/v1/balances?symbol=<symbol>` currently and would return a list of account and the token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokenBalances\": [\n+          {\n+            \"account\": \"0.15.10\",\n+            \"balance\": 100\n+          },\n+          {\n+            \"account\": \"0.15.9\",\n+            \"balance\": 90\n+          },\n+          {\n+            \"account\": \"0.15.8\",\n+            \"balance\": 80\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+To achieve this similar to balances\n+-   Create a `tokenBalance.js`\n+-   Add a `getTokenBalances()` which based on the time range provided (default to latest timestamp) and token `symbol` pulls out all the  `balance` and `symbol` values and returns them as an element in `tokenBalances` array\n+\n+```sql\n+    select account_id, balance from token_balance where symbol = ? and consensus_timestamp = (select max(consensus_timestamp) from token_balance);\n+```\n+\n+Query parameters should include", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 496}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MzY3MjA5OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMTo1NDo1MVrOHUdClQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMTo1NDo1MVrOHUdClQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIwOTM2NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Additions\n          \n          \n            \n            Optional Filters", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491209365", "createdAt": "2020-09-18T21:54:51Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),\n+        token_id            entity_id   not null,\n+        balance             bigint;\n+```\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Update `t_entities` table with token entity info, from the `TokenCreation.proto` object insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` class to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        consensus_timestamp bigint  primary key not null,\n+        symbol              character varying(96),\n+        token_id            entity_id,\n+        initial_supply      bigint,\n+        divisibility        bigint,\n+        treasury            entity_id,\n+        kyc_key             bytea,\n+        freeze_key          bytea,\n+        wipe_key            bytea,\n+        supply_key          bytea,\n+        freeze_default      boolean,\n+        kyc_default         boolean,\n+        freeze_default      boolean;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add `TokenBalanceSerializer` converter to handle object to JSON string serialization\n+```java\n+   @Named\n+   public class TokenBalanceSerializer extends JsonSerializer<List<TokenBalance>> {\n+       @Override\n+       public void serialize(List<TokenBalance> tokens, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+           if (value != null) {\n+               gen.writeStartArray();\n+               for (TokenBalance token: tokens) {\n+                   gen.writeStartObject();\n+                   gen.writeObjectField(\"token\", token);\n+                   gen.writeEndObject();\n+               }\n+               gen.writeEndArray();\n+           }\n+       }\n+   }\n+   ```\n+\n+or\n+\n+```java\n+    @Named\n+    public class TokenBalanceSerializer extends JsonSerializer<List<TokenBalance>> {\n+        @Override\n+        public void serialize(List<TokenBalance> tokens, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+            if (value != null) {\n+                gen.writeStartArray();\n+                for (TokenBalance token: tokens) {\n+                    gen.writeObject(token);\n+                }\n+                gen.writeEndArray();\n+            }\n+        }\n+    }\n+```\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public FileIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+-   Add `TokenBalance` with `tokens` private class member\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        private String symbol;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = -2399552489266593375L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` and `symbol` class members, to allow it to represent both HBARs and Tokens\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String symbol;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasury;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+\n+\n+### Balance Persistence\n+\n+-   Update `AccountBalanceLineParser.parse` to parse additional token columns representing `TokenRelationships`.\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance, symbol) values (?, ?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Add `UPDATE_TOKEN_STATUS` in `AccountBalancesFileLoader` to update changes to `kycStatus` and `freezeStatus`\n+```java\n+    private static final String UPDATE_TOKEN_STATUS = \"update token_balance set kyc_status = ?, \" +\n+                \"freeze_status = ? where token_id = ?\";\n+```\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer`. Also pulling out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId token, String symbol) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId, symbol));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for tokenId and symbol\n+\n+> _Note 1:_ For improved API calls it would be valuable to insert the symbol for cryptoTransfers. This is only available on the tokenCreate transaction, so a caching mechanism can be explored ot make this available for transfers\n+\n+> _Note 2:_ There's an opportunity to refactor the `OnItem()` to focus better on different TransactionBody types but not necessarily within scope\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts\n+5.  Add a Token Discovery REST API to show available tokens on the network\n+\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"symbol\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"symbol\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` and `symbol` columns from `token_balance` where `token_balance.id` = <tokenId> and assign each row to an element of `tokenBalances`\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"symbol\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+To achieve this\n+-   Update `balances.js` `getBalances()` to pull the `balance` and `symbol` columns from `token_balance` where `token_balance.id` = <tokenId> and assign each row to an element of `tokenBalances`\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"tokenTransfers\": [\n+            {\n+              \"currency\":\"0.0.5555\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.1111\", \"amount\": -10},\n+                {\"account\": \"0.0.2222\", \"amount\": 10}\n+              ]\n+            },\n+            {\n+              \"currency\": \"0.0.6666\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.3333\", \"amount\": -10},\n+                {\"account\": \"0.0.4444\", \"amount\": 10}\n+               ]\n+            }\n+          ]\n+        }\n+      ]\n+    }\n+```\n+\n+To achieve this\n+-   Update `transactions.js` sql queries for `crypto_transfer` to pull the `token_id` and `symbol` columns\n+-   Update `createTransferLists()` in `transactions.js` to build a `tokenTransfers` list if `symbol` isn't HBAR or if `token_id` is empty\n+\n+\n+### Token Supply distribution\n+\n+`/api/v1/tokens/<symbol>/balances` this could be the equivalent of `/api/v1/balances?symbol=<symbol>` currently and would return a list of account and the token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokenBalances\": [\n+          {\n+            \"account\": \"0.15.10\",\n+            \"balance\": 100\n+          },\n+          {\n+            \"account\": \"0.15.9\",\n+            \"balance\": 90\n+          },\n+          {\n+            \"account\": \"0.15.8\",\n+            \"balance\": 80\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+To achieve this similar to balances\n+-   Create a `tokenBalance.js`\n+-   Add a `getTokenBalances()` which based on the time range provided (default to latest timestamp) and token `symbol` pulls out all the  `balance` and `symbol` values and returns them as an element in `tokenBalances` array\n+\n+```sql\n+    select account_id, balance from token_balance where symbol = ? and consensus_timestamp = (select max(consensus_timestamp) from token_balance);\n+```\n+\n+Query parameters should include\n+-   `/api/v1/tokens/<symbol>/balances?id=0.0.1000`\n+-   `/api/v1/tokens/<symbol>/balances?balance=gt:1000`\n+-   `/api/v1/tokens/<symbol>/balances?timestamp=1566562500.040961001`\n+\n+### Token Discovery\n+`/api/v1/tokens` this would return all tokens present on the network\n+\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokens\": [\n+          {\n+            \"symbol\": \"FOOBAR\",\n+            \"tokenId\": \"0.15.10\",\n+            \"key\": {\n+              \"_type\": \"ProtobufEncoded\",\n+              \"key\": \"7b2233222c2233222c2233227d\"\n+            }\n+          },\n+          {\n+            \"symbol\": \"FOOCOIN\",\n+            \"tokenId\": \"0.15.10\",\n+            \"key\": {\n+              \"_type\": \"ProtobufEncoded\",\n+              \"key\": \"9c2233222c2233222c2233227d\"\n+            }\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+To achieve this\n+-   Add a `getTokens()` to `tokenBalance.js` which pull the unique `symbol`, `tokenId` from the `token` table and joins with the `t_entities` table for the matching admin_key\n+\n+```sql\n+    select symbol, tokenId e.key from token t\n+          join t_entities e on t.token_id = e.id and e.fk_entity_type_id = ${utils.ENTITY_TYPE_TOKEN};\n+```\n+\n+Additions", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 539}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MzcyNTQxOnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMjoxNzowNlrOHUdjGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMjoxNzowNlrOHUdjGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIxNzY5MA==", "bodyText": "Let's not mention specific versions as things can always change.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491217690", "createdAt": "2020-09-18T22:17:06Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MzcyNjAyOnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMjoxNzoyN1rOHUdjdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMjoxNzoyN1rOHUdjdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIxNzc4Mw==", "bodyText": "nit: through its APIs", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491217783", "createdAt": "2020-09-18T22:17:27Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MzczNTUxOnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMjoyMjo0M1rOHUdo7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQwMzo1NzowOVrOHU33KA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIxOTE4Mg==", "bodyText": "Shouldn't duplicate symbol. token_id is enough.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491219182", "createdAt": "2020-09-18T22:22:43Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzNzczNw==", "bodyText": "Accounts, Balance and the new Token API's will all require resolving the symbol to tokenId mapping.\nRepeating it here avoids a join with the token table on every one of those calls to find that mapping", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491237737", "createdAt": "2020-09-18T23:48:06Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIxOTE4Mg=="}, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI0NzcxOQ==", "bodyText": "Performance of the REST API's isn't an issue and if it becomes one we could explore caching the symbol-tokenId on the REST API side.\nThat's one other option if we feel strongly against the duplicate info here", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491247719", "createdAt": "2020-09-19T00:59:17Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIxOTE4Mg=="}, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTY0ODgwOA==", "bodyText": "Dropping symbol", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491648808", "createdAt": "2020-09-20T03:57:09Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIxOTE4Mg=="}, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MzczOTUxOnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMjoyNTowMlrOHUdrLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQwMzo1NzowMFrOHU33GA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIxOTc1OA==", "bodyText": "We shouldn't duplicate storage of the symbol especially in our biggest table. Also, I think token ID is immutable but token symbol is mutable. token_id should be enough.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491219758", "createdAt": "2020-09-18T22:25:02Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzODExNA==", "bodyText": "Fair point on the size of the table and mutability of the mentioned columns.\nLike above the hope was to avoid a join with another table on API queries.\nEspecially since eventually we'll be streaming updates from this table. Joins would be a performance hit on speed mores than the size of the table", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491238114", "createdAt": "2020-09-18T23:50:15Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIxOTc1OA=="}, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI0NzcwNQ==", "bodyText": "We could work out not having the symbol here.\nOn the /api/v1/transactions response the current proposed solution returns the tokenId, however there's a chance we actually want to return the symbol.\nThis would require a join with the token table if so.\nOn the gRPC API streaming side it's possible for us to make the mapping call once at the beginning for use so that's solvable.\nFor REST API we may have to explore caching the mapping to optimize on performance", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491247705", "createdAt": "2020-09-19T00:59:13Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIxOTc1OA=="}, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI0OTAyMA==", "bodyText": "We definitely can't have mutable data in an insert only table. I don't think the join is an issue since tokens will have thousands maybe hundreds of thousands while cryptotransfer has hundreds of millions. I'm way more concerned about the mutability and storage size of a varchar field than joining with a small table. Plus we can always cache the tokenid to symbol mapping", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491249020", "createdAt": "2020-09-19T01:11:33Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIxOTc1OA=="}, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTY0ODc5Mg==", "bodyText": "Seems like we're agreed on caching, dropping symbol for the mutability reasons you rightly pointed out", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491648792", "createdAt": "2020-09-20T03:57:00Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIxOTc1OA=="}, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3Mzc4MjA0OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMjo1MDowMFrOHUeDGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMzo1MDo1OFrOHUezPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyNTg4MA==", "bodyText": "Should token_id be the primary key? It depends on how queries will use it. Definitely token_id should have a unique index on it.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491225880", "createdAt": "2020-09-18T22:50:00Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),\n+        token_id            entity_id   not null,\n+        balance             bigint;\n+```\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Update `t_entities` table with token entity info, from the `TokenCreation.proto` object insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` class to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        consensus_timestamp bigint  primary key not null,\n+        symbol              character varying(96),\n+        token_id            entity_id,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzODIwNw==", "bodyText": "Correct, good catch. token_id should be the primary key. Will change", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491238207", "createdAt": "2020-09-18T23:50:58Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),\n+        token_id            entity_id   not null,\n+        balance             bigint;\n+```\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Update `t_entities` table with token entity info, from the `TokenCreation.proto` object insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` class to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        consensus_timestamp bigint  primary key not null,\n+        symbol              character varying(96),\n+        token_id            entity_id,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyNTg4MA=="}, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3Mzc4MjY3OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMjo1MDoxNFrOHUeDZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQwMzo1Njo0MFrOHU32_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyNTk1OQ==", "bodyText": "treasury_account or treasury_account_id", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491225959", "createdAt": "2020-09-18T22:50:14Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),\n+        token_id            entity_id   not null,\n+        balance             bigint;\n+```\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Update `t_entities` table with token entity info, from the `TokenCreation.proto` object insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` class to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        consensus_timestamp bigint  primary key not null,\n+        symbol              character varying(96),\n+        token_id            entity_id,\n+        initial_supply      bigint,\n+        divisibility        bigint,\n+        treasury            entity_id,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzODU5Ng==", "bodyText": "Yes had made the change to  treasury_account locally, will push on next comment", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491238596", "createdAt": "2020-09-18T23:53:24Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),\n+        token_id            entity_id   not null,\n+        balance             bigint;\n+```\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Update `t_entities` table with token entity info, from the `TokenCreation.proto` object insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` class to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        consensus_timestamp bigint  primary key not null,\n+        symbol              character varying(96),\n+        token_id            entity_id,\n+        initial_supply      bigint,\n+        divisibility        bigint,\n+        treasury            entity_id,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyNTk1OQ=="}, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTY0ODc2NA==", "bodyText": "Actually had it as treasury_id", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491648764", "createdAt": "2020-09-20T03:56:40Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),\n+        token_id            entity_id   not null,\n+        balance             bigint;\n+```\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Update `t_entities` table with token entity info, from the `TokenCreation.proto` object insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` class to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        consensus_timestamp bigint  primary key not null,\n+        symbol              character varying(96),\n+        token_id            entity_id,\n+        initial_supply      bigint,\n+        divisibility        bigint,\n+        treasury            entity_id,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyNTk1OQ=="}, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3Mzc4NDExOnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMjo1MToxM1rOHUeEOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxODoxNTowM1rOHWGngQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyNjE2OQ==", "bodyText": "Have we confirmed with services if there's any limit imposed on the symbol size? There probably should be a limit since it's stored in state.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491226169", "createdAt": "2020-09-18T22:51:13Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),\n+        token_id            entity_id   not null,\n+        balance             bigint;\n+```\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Update `t_entities` table with token entity info, from the `TokenCreation.proto` object insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` class to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        consensus_timestamp bigint  primary key not null,\n+        symbol              character varying(96),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzODg5NA==", "bodyText": "Noted in the Open Questions intending to circle back with services on this and others, thanks for highlighting", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491238894", "createdAt": "2020-09-18T23:55:05Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),\n+        token_id            entity_id   not null,\n+        balance             bigint;\n+```\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Update `t_entities` table with token entity info, from the `TokenCreation.proto` object insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` class to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        consensus_timestamp bigint  primary key not null,\n+        symbol              character varying(96),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyNjE2OQ=="}, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQxNTU1Nw==", "bodyText": "Current limit seems to be 32. But it's configurable so maybe we should add some padding incase of marginal increases over time", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492415557", "createdAt": "2020-09-22T00:19:01Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),\n+        token_id            entity_id   not null,\n+        balance             bigint;\n+```\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Update `t_entities` table with token entity info, from the `TokenCreation.proto` object insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` class to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        consensus_timestamp bigint  primary key not null,\n+        symbol              character varying(96),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyNjE2OQ=="}, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjkzOTEzNw==", "bodyText": "Actually the default limit for the tokens.maxTokenNameLength property is 100 UTF-8 characters. This matches the maximum length of a memo", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492939137", "createdAt": "2020-09-22T18:15:03Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),\n+        token_id            entity_id   not null,\n+        balance             bigint;\n+```\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Update `t_entities` table with token entity info, from the `TokenCreation.proto` object insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` class to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        consensus_timestamp bigint  primary key not null,\n+        symbol              character varying(96),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyNjE2OQ=="}, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3Mzc4NzM5OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMjo1MzoxNVrOHUeGIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQwMzo1NjoyN1rOHU328g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyNjY1OQ==", "bodyText": "Would prefer column names sorted since any other order would be arbitrary.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491226659", "createdAt": "2020-09-18T22:53:15Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),\n+        token_id            entity_id   not null,\n+        balance             bigint;\n+```\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Update `t_entities` table with token entity info, from the `TokenCreation.proto` object insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` class to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzODk0Nw==", "bodyText": "Can do", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491238947", "createdAt": "2020-09-18T23:55:18Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),\n+        token_id            entity_id   not null,\n+        balance             bigint;\n+```\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Update `t_entities` table with token entity info, from the `TokenCreation.proto` object insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` class to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyNjY1OQ=="}, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTY0ODc1NA==", "bodyText": "All columns after primary key are sorted a-z", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491648754", "createdAt": "2020-09-20T03:56:27Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),\n+        token_id            entity_id   not null,\n+        balance             bigint;\n+```\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Update `t_entities` table with token entity info, from the `TokenCreation.proto` object insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` class to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyNjY1OQ=="}, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3Mzc5MDQ1OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMjo1NTowN1rOHUeH3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOVQwMDo0ODowNVrOHUfTbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyNzEwMA==", "bodyText": "Are any of these keys equivalent to the submit_key that would make sense to reuse that field?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491227100", "createdAt": "2020-09-18T22:55:07Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),\n+        token_id            entity_id   not null,\n+        balance             bigint;\n+```\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Update `t_entities` table with token entity info, from the `TokenCreation.proto` object insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` class to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        consensus_timestamp bigint  primary key not null,\n+        symbol              character varying(96),\n+        token_id            entity_id,\n+        initial_supply      bigint,\n+        divisibility        bigint,\n+        treasury            entity_id,\n+        kyc_key             bytea,\n+        freeze_key          bytea,\n+        wipe_key            bytea,\n+        supply_key          bytea,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI0NjQ0Ng==", "bodyText": "Nope these are all different than the submit key.\nEach one allows a specific Token/Token-Account altering operation and not necessarily whether the account holder of the key can perform token transfers which I think would be the equivalent of submitKey (only those keys could submit messages to the topic entity).\nThey are similar in that one those keys can perform those operations", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491246446", "createdAt": "2020-09-19T00:48:05Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),\n+        token_id            entity_id   not null,\n+        balance             bigint;\n+```\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Update `t_entities` table with token entity info, from the `TokenCreation.proto` object insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` class to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        consensus_timestamp bigint  primary key not null,\n+        symbol              character varying(96),\n+        token_id            entity_id,\n+        initial_supply      bigint,\n+        divisibility        bigint,\n+        treasury            entity_id,\n+        kyc_key             bytea,\n+        freeze_key          bytea,\n+        wipe_key            bytea,\n+        supply_key          bytea,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyNzEwMA=="}, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDgwNzE3OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxOToyNzowOFrOHVfU1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMzo1Mjo0M1rOHWQNMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NTM4MQ==", "bodyText": "nit: need to fix sql format.\nShould be\ncreate table if not exists token_account_info\n(\n...\n);", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492295381", "createdAt": "2020-09-21T19:27:08Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA5NjI0Mg==", "bodyText": "Updated to just list", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r493096242", "createdAt": "2020-09-22T23:52:43Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NTM4MQ=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDgwODQ2OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxOToyNzozMlrOHVfVug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMzo1MzowMVrOHWQNhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NTYxMA==", "bodyText": "nit: need to fix sql format.\nShould be\ncreate table if not exists token_balance\n(\n...\n);", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492295610", "createdAt": "2020-09-21T19:27:32Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA5NjMyNg==", "bodyText": "Updated to just list out", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r493096326", "createdAt": "2020-09-22T23:53:01Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NTYxMA=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDgwOTQ5OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxOToyNzo0N1rOHVfWUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMzo1MjoxM1rOHWQMrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NTc2Mg==", "bodyText": "nit: need to fix sql format.\nShould be\ncreate table if not exists token\n(\n...\n);", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492295762", "createdAt": "2020-09-21T19:27:47Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA5NjEwOQ==", "bodyText": "Updated as listing", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r493096109", "createdAt": "2020-09-22T23:52:13Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NTc2Mg=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 165}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDgxNDg2OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxOToyOTozMVrOHVfZuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMzo1Mjo1NVrOHWQNcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NjYzMw==", "bodyText": "nit:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    consensus_timestamp bigint              primary key not null\n          \n          \n            \n                    consensus_timestamp bigint              primary key not null,", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492296633", "createdAt": "2020-09-21T19:29:31Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA5NjMwNA==", "bodyText": "Updated", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r493096304", "createdAt": "2020-09-22T23:52:55Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NjYzMw=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDgxNTc3OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxOToyOTo0N1rOHVfaQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMzo1Mjo1MFrOHWQNWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5Njc3MQ==", "bodyText": "nit:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    balance             bigint              not null\n          \n          \n            \n                    balance             bigint              not null,", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492296771", "createdAt": "2020-09-21T19:29:47Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA5NjI4Mw==", "bodyText": "Updated", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r493096283", "createdAt": "2020-09-22T23:52:50Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5Njc3MQ=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MTI5MDMzOnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMjowMzozNVrOHVj-Cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMzo1MzoyNVrOHWQN8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM3MTQ2Ng==", "bodyText": "nit: extra space after stream\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            -   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n          \n          \n            \n            -   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492371466", "createdAt": "2020-09-21T22:03:35Z", "author": {"login": "ijungmann"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA5NjQzNA==", "bodyText": "Updated", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r493096434", "createdAt": "2020-09-22T23:53:25Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM3MTQ2Ng=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MTI5NjE0OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMjowNToyN1rOHVkBRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMzo1MzozNlrOHWQOMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM3MjI5Mg==", "bodyText": "nit: apostrophe not needed.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n          \n          \n            \n            The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492372292", "createdAt": "2020-09-21T22:05:27Z", "author": {"login": "ijungmann"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA5NjQ5Ng==", "bodyText": "Updated", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r493096496", "createdAt": "2020-09-22T23:53:36Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM3MjI5Mg=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MTM3MDc5OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMjozMzoxNlrOHVkr2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMzo1MzoxNlrOHWQNzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM4MzE5Mw==", "bodyText": "Would be better to name this hts-architecture.png so it's clear it's related to hts.md and it's similar to how hcs is named.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492383193", "createdAt": "2020-09-21T22:33:16Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA5NjM5OA==", "bodyText": "Renamed", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r493096398", "createdAt": "2020-09-22T23:53:16Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM4MzE5Mw=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MTM3OTMxOnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMjozNjo0MVrOHVkw1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMzo1MzozMFrOHWQOGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM4NDQ2OQ==", "bodyText": "third party integration", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492384469", "createdAt": "2020-09-21T22:36:41Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA5NjQ3Mg==", "bodyText": "Updated", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r493096472", "createdAt": "2020-09-22T23:53:30Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM4NDQ2OQ=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MTUwNjc0OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMzozMjo0NVrOHVl5bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMzo1MzowOVrOHWQNsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQwMzA1NQ==", "bodyText": "Did you give any thought to separate token transfers and crypto transfers? If we want to stream token transfers or serve transfers via a standalone REST API, having them in separate tables would greatly improve the performance of those queries.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492403055", "createdAt": "2020-09-21T23:32:45Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ2MTkzNg==", "bodyText": "I think that would also get rid of the need to allow nullable for the token_id when dealing with hbar, which would be nice.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492461936", "createdAt": "2020-09-22T03:58:54Z", "author": {"login": "ijungmann"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQwMzA1NQ=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg0MTI3NQ==", "bodyText": "Yeah, agree that might be a better approach, especially for the streaming reasons as tokens bubble out in size and transfers.\nWill make this change", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492841275", "createdAt": "2020-09-22T15:42:18Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQwMzA1NQ=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA5NjM3MQ==", "bodyText": "Added token_transfer", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r493096371", "createdAt": "2020-09-22T23:53:09Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQwMzA1NQ=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MTUwODMxOnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMzozMzozOVrOHVl6aw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNTo0MzowN1rOHWArpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQwMzMwNw==", "bodyText": "As this will be done before token work and in a separate PR, it shouldn't be included here. Same thing for changes related to this. None of them are related to HTS specifically.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492403307", "createdAt": "2020-09-21T23:33:39Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg0MTg5Mg==", "bodyText": "Will remove from here as address already in #1070", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492841892", "createdAt": "2020-09-22T15:43:07Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQwMzMwNw=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MTU1MjU4OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMzo1NzozOVrOHVmUvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNzozOTo0M1rOHWFVpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQxMDA0Ng==", "bodyText": "I'm not sure how this data is different enough to warrant its own table separate from token. Freeze, kyc and wiped are all just flags that are associated with a token.\nThey can be updated at any time just like most other fields that are in the token table like the keys. I also don't see the distinction how these are considered metadata but the keys are not? Logically they belong with the token table, in my opinion. Do you see some retrieval use case that warrants it being separate for performance reasons?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492410046", "createdAt": "2020-09-21T23:57:39Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ1NTg5MQ==", "bodyText": "I agree, this is the only table I'm having some trouble following.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492455891", "createdAt": "2020-09-22T03:28:04Z", "author": {"login": "ijungmann"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQxMDA0Ng=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg2MDkzOA==", "bodyText": "I don't think that's correct.\nFreeze, KYC and Wipe are all operations that are performed on an account with respect to a particular account.\nHere's more context.\n\nYou have an existing account w HBAR's or create a new account and fund it HBARs. Said account has no tokens\nToken FOOBAR is created and supplied etc\n[NEW] There's will be an accept token flag set for an account to accept FOOBAR that needs to be set to receive that token\nAccount is sent FOOBAR tokens. This adds the account to the ledger for this token with a nonzero balance. The account will have a freeze status based on the freezeDefault value for the token. It will have a wipe value set to false at beginning.\n[NEW] KYC is likely needed for many tokens and may even be a precursor to receiving tokens. Need for KYC is now specified by the presence of a kycKey. If present then KYC must be performed on an account for a token before it can receive tokens. KYC for an account for a given token can be undone. In which case we need to be able to represent the toggling of the flag KYC\nSimilarly an account can be frozen and unfrozen in respect to a single token. i.e. You could have FOO tokens and BAR tokens and only have your account frozen for BAR tokens. If an account is frozen by default/toggled it needs to be unfrozen before tokens can be received.\n[NEW] Wipe may or may not be cut off, not clear yet. Assuming current design an account for a given token could be wiped. This would also burn the tokens the account held for that token. Again, this would be done for only a given token and not all tokens and may or may not affect your actual account with respect to HBARs.\n\nI've highlighted the new information I've received.\nUltimately the need for this table is to represent the different token->account properties that can change and are not related to HBAR.\nIf an account had 3 tokens they'd be represent by 3 rows here. Each row per token-account", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492860938", "createdAt": "2020-09-22T16:09:27Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQxMDA0Ng=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg5ODI4OQ==", "bodyText": "2 new transaction types to be added to cover number 3.\nThese will mark the onboarding of an account to accept a token or to stop accepting.\nAt the time of accepting the defaults would be set and an entry in token_account_info would be added.\nFuture TOKENFREEZE, TOKENUNFREEZE,  TOKENGRANTKYC, TOKENREVOKEKYC and TOKENWIPE transactions would modify a single row in the token_account_info table\nTOKENASSOCIATE & TOKENDISSOCIATE, yet to be added on service side", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492898289", "createdAt": "2020-09-22T17:07:00Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQxMDA0Ng=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjkxODE4Mg==", "bodyText": "This makes more sense to me now, with those being per-account per-token operations I see the need for this.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492918182", "createdAt": "2020-09-22T17:39:43Z", "author": {"login": "ijungmann"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQxMDA0Ng=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MTYyNTY2OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwMDo0MDo1M1rOHVm-mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwMDo0Nzo1MlrOHVnEyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQyMDc2Mg==", "bodyText": "Primary key should be Id instead as consensus_timestamp is not required here.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    consensus_timestamp bigint              primary key,\n          \n          \n            \n                   id                  serial              primary key,\n          \n      \n    \n    \n  \n\nAlso unique constraint of token_id, account_id", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492420762", "createdAt": "2020-09-22T00:40:53Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQyMjM0Ng==", "bodyText": "Unless the question of when was the last update made to the token-account metadata.\nCould add a last_update_timestamp e.g.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    consensus_timestamp bigint              primary key,\n          \n          \n            \n                    id                      serial              primary key,\n          \n          \n            \n                    last_update_timestamp   bigint              not null,", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492422346", "createdAt": "2020-09-22T00:47:52Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQyMDc2Mg=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MTg4Mjg0OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwMzozNjoxNVrOHVpN3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMzo1MzoyMVrOHWQN5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ1NzQzNw==", "bodyText": "nit: and/or\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            -   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n          \n          \n            \n            -   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492457437", "createdAt": "2020-09-22T03:36:15Z", "author": {"login": "ijungmann"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA5NjQyMw==", "bodyText": "Updated", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r493096423", "createdAt": "2020-09-22T23:53:21Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ1NzQzNw=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NDI0NDc3OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNToxNjowNFrOHV_YLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMToyMDozNVrOHWMz-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgyMDUyNA==", "bodyText": "can supply_key be null? It's not explicitly stated in the doc, so I believe it's a required field", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492820524", "createdAt": "2020-09-22T15:16:04Z", "author": {"login": "xin-hedera"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk5NDg5MQ==", "bodyText": "I think it can be null. IN the doc there's expected behavior for when it is null under the \"Key Types\" section", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492994891", "createdAt": "2020-09-22T19:53:15Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgyMDUyNA=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0MDYzNA==", "bodyText": "yes you are right", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r493040634", "createdAt": "2020-09-22T21:20:35Z", "author": {"login": "xin-hedera"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgyMDUyNA=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 174}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NDI3NzE2OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNToyMjoyN1rOHV_sMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMzozOTowM1rOHWP9Jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgyNTY1MA==", "bodyText": "filter", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492825650", "createdAt": "2020-09-22T15:22:27Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"token\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"token\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"token\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+To achieve this\n+-   Update `balances.js` `getBalances()` to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"token\":\"FOOBAR\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.1111\", \"amount\": -10},\n+                {\"account\": \"0.0.2222\", \"amount\": 10}\n+              ]\n+            },\n+            {\n+              \"token\":\"FOOCOIN\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.3333\", \"amount\": -10},\n+                {\"account\": \"0.0.4444\", \"amount\": 10}\n+               ]\n+            }\n+          ]\n+        }\n+      ]\n+    }\n+```\n+\n+To achieve this\n+-   Update `transactions.js` sql queries for `crypto_transfer` to pull the `token_id` and `token` columns\n+-   Update `createTransferLists()` in `transactions.js` to build a `tokenTransfers` list if `token` isn't HBAR or if `token_id` is empty\n+\n+\n+### Token Supply distribution\n+\n+`/api/v1/tokens/<token>/balances` this could be the equivalent of `/api/v1/balances?token=<token>` currently and would return a list of account and the token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokenBalances\": [\n+          {\n+            \"account\": \"0.15.10\",\n+            \"balance\": 100\n+          },\n+          {\n+            \"account\": \"0.15.9\",\n+            \"balance\": 90\n+          },\n+          {\n+            \"account\": \"0.15.8\",\n+            \"balance\": 80\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+To achieve this similar to balances\n+-   Create a `tokenBalance.js`\n+-   Add a `getTokenBalances()` which based on the time range provided (default to latest timestamp) and `tokenId` pulls out `account_id` and `balance` values from `token_balance` and returns them as an element in `tokenBalances` array.\n+\n+```sql\n+    select account_id, balance from token_balance where token_id = ? and consensus_timestamp = (select max(consensus_timestamp) from token_balance);\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens/<token>/balances?id=0.0.1000`\n+-   `/api/v1/tokens/<token>/balances?balance=gt:1000`\n+-   `/api/v1/tokens/<token>/balances?timestamp=1566562500.040961001`\n+\n+### Token Discovery\n+`/api/v1/tokens` this would return all tokens present on the network\n+\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokens\": [\n+          {\n+            \"token\": \"FOOBAR\",\n+            \"tokenId\": \"0.15.10\",\n+            \"key\": {\n+              \"_type\": \"ProtobufEncoded\",\n+              \"key\": \"7b2233222c2233222c2233227d\"\n+            }\n+          },\n+          {\n+            \"token\": \"FOOCOIN\",\n+            \"tokenId\": \"0.15.11\",\n+            \"key\": {\n+              \"_type\": \"ProtobufEncoded\",\n+              \"key\": \"9c2233222c2233222c2233227d\"\n+            }\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+To achieve this\n+-   Add a `getTokens()` to `tokenBalance.js` which pull the unique `token`, `tokenId` from the `token` table and joins with the `t_entities` table for the matching admin_key\n+\n+```sql\n+    select token, token_id from token t\n+          join t_entities e on t.token_id = e.id and e.fk_entity_type_id = ${utils.ENTITY_TYPE_TOKEN};\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens?adminkey=HJ^&8` - All tokens with matching admin key\n+-   `/api/v1/tokens?account.id=0.0.8` - All tokens for matching account\n+\n+### Token Info\n+-   Add a `getTokenInfo()` to `tokens.js` to retrieve token info from `token` table\n+```json\n+    {\n+      \"token\": \"FOOCOIN\",\n+      \"tokenId\": \"0.15.10\",\n+      \"treasury_account\": \"0.15.10\",\n+      \"adminKey\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"kycKey\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"freezeKey\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"wipeKey\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"supplyKey\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"freezeDefault\": false,\n+      \"kycDefault\": false,\n+      \"expiryTimestamp\": null,\n+      \"autoRenewAccount\": \"0.0.6\",\n+      \"autoRenewPeriod\": null\n+    }\n+```\n+\n+\n+## Protobuf\n+\n+```proto\n+    message TokenQuery {\n+        .proto.TokenID tokenID = 1; // The token ID to retrieve transfers for\n+        .proto.AccountID accountID = 2; // An account ID to retrieve transfers for. Required if no tokenID is specified\n+        .proto.Timestamp consensusStartTime = 3; // Include messages which reached consensus on or after this time. Defaults to current time if not set.\n+        .proto.Timestamp consensusEndTime = 4; // Include messages which reached consensus before this time. If not set it will receive indefinitely.\n+        uint64 limit = 5; // The maximum number of messages to receive before stopping. If not set or set to zero it will return messages indefinitely.\n+    }\n+\n+    message TokenResponse {\n+        .proto.Timestamp consensusTimestamp = 1; // The time at which the transaction reached consensus\n+        .proto.TokenTransfers transfer = 2; // Multiple list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)\n+    }\n+\n+    service TokenService {\n+        rpc subscribeTokenTransfers (TokenQuery) returns (stream TokenResponse);\n+    }\n+```\n+\n+## GRPC API\n+\n+### Controller\n+-   Add a `TokenController` that extends protobuf reactor stubs and implements `subscribeTokenTransfers`\n+```java\n+    package com.hedera.mirror.grpc.controller;\n+\n+    public class TokenController extends ReactorTokenServiceGrpc.TokenServiceImplBase {\n+            @Override\n+            public Flux<TokenResponse> subscribeTokenTransfers(Mono<TokenQuery> request) {\n+                ...\n+            }\n+    }\n+```\n+\n+### Domain\n+\n+-   Add `CryptoTransfer` class with class members `consensusTimestamp`, `entityId`, `amount`, `tokenId`. Also add necessary methods to support conversion from domain to protobuf TokenResponse\n+-   Add a `StreamItemFilter` base class that can be shared by `TopicMessageFilter` and `CryptoTransferFilter` with support for `startTime`, `endTime`, `limit` and `subscriberId`\n+```java\n+    package com.hedera.mirror.grpc.domain;\n+\n+    public class StreamItemFilter {\n+        private Instant endTime;\n+        private long limit;\n+        private int realmNum;\n+        private Instant startTime;\n+        private String subscriberId;\n+\n+        public boolean hasLimit() {\n+            return limit > 0;\n+        }\n+    }\n+```\n+-   Update `TopicMessageFilter` to extend `StreamItemFilter` and add `topicNum`\n+-   Add `CryptoTransferFilter` to extend `StreamItemFilter` and add `tokenNum`\n+```java\n+    package com.hedera.mirror.grpc.domain;\n+\n+    public class CryptoTransferFilter extends StreamItemFilter {\n+        @Min(0)\n+        private int tokenNum;\n+    }\n+```\n+\n+\n+-   Update `EntityType` with `TOKEN` option\n+```java\n+    package com.hedera.mirror.grpc.domain;\n+\n+    public enum EntityType {\n+\n+        UNKNOWN, // Filler value to offset next values by one to match database values\n+        ACCOUNT,\n+        CONTRACT,\n+        FILE,\n+        TOPIC,\n+        TOKEN\n+    }\n+```\n+\n+### Repository\n+-   Add a `StreamItemRepository`\n+```java\n+    package com.hedera.mirror.grpc.repository;\n+\n+    public interface StreamItemRepository extends CrudRepository<StreamItem, Long> {\n+        List<StreamItem> findLatest(long consensusTimestamp, Pageable pageable);\n+        List<StreamItem> findByFilter(StreamItemFilter filter);\n+    }\n+```\n+-   Add `CryptoTransferRepository` which implements `StreamItemRepository`\n+-   Update `TopicMessageRepository` to implement `StreamItemRepository`\n+\n+### Streaming : Listener & Retriever\n+The GRPC module currently supports listen and retrieval logic for incoming and historic topic messages respectively.\n+A lot of this logic can be shared for the equivalent `CryptoTransfer` listeners and retriever\n+\n+-   Add a `StreamItem` interface that stream-able domain objects can implement with get methods for `realm`, `entityNum` and `consensusTimestamp`\n+```java\n+    package com.hedera.mirror.grpc.domain;\n+\n+    public interface StreamItem {\n+        int getRealmNum();\n+        int getEntityNum();\n+        Long getConsensusTimestamp();\n+    }\n+```\n+\n+-   Update `TopicListener` to be `SharedListener`. Replace `TopicMessage` and `TopicMessageFilter` with generic type for StreamItem\n+```java\n+    package com.hedera.mirror.grpc.listener;\n+\n+    public interface SharedListener<T extends StreamItem> {\n+        Flux<T> listen(S filter);\n+    }\n+```\n+-   Update `CompositeTopicListener` to set generic types `T` and `S` as `TopicMessage` and `TopicMessageFilter` when creating `SharedListener` implementations.\n+-   Create `CompositeCryptoListener` similar to `CompositeTopicListener` that sets generic types of `T` and `S` as `CryptoTransfer` and `CryptoTransferFilter` when creating `Listener` implementations.\n+-   Update `NotifyTopicListener` to be `NotifyListener` and use generics `T` and `S` in place of `TopicMessage` and `TopicMessageFilter`\n+```java\n+    package com.hedera.mirror.grpc.listener;\n+\n+    public class NotifyingListener<T extends StreamItem, S extends StreamItemFilter> implements SharedListener<T, S> {\n+        ...\n+    }\n+```\n+-   Extract `PollingContext` from `SharedPollingTopicListener` and use `StreamItem` and `StreamItemFilter` in place of `TopicMessage` and `TopicMessageFilter`\n+```java\n+    package com.hedera.mirror.grpc.listener;\n+\n+    private class PollingContext {\n+        private final StreamItemFilter filter;\n+        private volatile StreamItem last;\n+        ...\n+    }\n+```\n+-   Update `PollingTopicListener` to `PollingListener` and use `StreamItem` and `StreamItemFilter` in place of `TopicMessage` and `TopicMessageFilter`. Also swap/add `streamItemRepository` private member.\n+```java\n+    package com.hedera.mirror.grpc.listener;\n+\n+    public class PollingListener implements SharedListener {\n+        ...\n+        private final StreamItemRepository streamItemRepository;\n+        ...\n+    }\n+```\n+-   Update `SharedPollingTopicListener` to `SharedPollingListener` and use `StreamItem` and `StreamItemFilter` in place of `TopicMessage` and `TopicMessageFilter`\n+```java\n+    package com.hedera.mirror.grpc.listener;\n+\n+    public class SharedPollingListener implements SharedListener {\n+        ...\n+        private final StreamItemRepository streamItemRepository;\n+        ...\n+    }\n+```\n+-   Update `TopicMessageRetriever` to be `Retriever` and use `StreamItem` and `StreamItemFilter` in place of `TopicMessage` and `TopicMessageFilter`\n+```java\n+    package com.hedera.mirror.grpc.retriever;\n+\n+    public interface Retriever {\n+        Flux<StreamItem> retrieve(StreamItemFilter filter);\n+    }\n+```\n+-   Update `PollingTopicMessageRetriever` to be `PollingRetriever` and use `StreamItem`, `StreamItemFilter` and `StreamItemRepository` in place of `TopicMessage`, `TopicMessageFilter` and `TopicMessageRepository`.\n+\n+### Service\n+> _Note:_ ***Sequence diagram to be added\n+\n+-   Add `CryptoTransferService` interface\n+```java\n+    package com.hedera.mirror.grpc.service;\n+\n+    public interface TokenService {\n+        Flux<StreamItem> subscribeTokenTransfers(@Valid StreamItemFilter filter);\n+    }\n+```\n+\n+-   Add `AbstractServiceImpl` that pulls out the common logic from `TopicMessageServiceImpl` `entityExists()`, `incomingMessages()` and `missingMessages()` and uses `StreamItem`, `StreamItemFilter` and `Retriever` in place of `TopicMessage`, `TopicMessageFilter` and `TopicRetriever`.\n+-   Update `TopicMessageServiceImpl` to extend `AbstractServiceImpl` and still implement `TopicMessageService`\n+-   Add `TokenServiceImpl` to extend `AbstractServiceImpl` and implement `TokenService`\n+```java\n+    package com.hedera.mirror.grpc.service;\n+\n+    public class TokenServiceImpl extends AbstractServiceImpl implements TokenService {\n+        ...\n+        private final Retriever retriever;\n+        Flux<StreamItem> subscribeTokenTransfers(@Valid StreamItemFilter filter){\n+            ...\n+        }\n+\n+        ...\n+    }\n+```\n+\n+## Non-Functional Requirements\n+\n+## Open Questions\n+-   [x] What's the maximum character size of the token `symbol` string\n+    -   A: Max length is currently 32 chars https://github.com/hashgraph/hedera-services/blob/master/hedera-node/src/main/resources/bootstrap.properties#L52\n+-   [x] Will a `token_id` and `token` be assigned a default value for HBARs across the network e.g. i.e. '1' and 'HBAR' respectively\n+    -   A: Currently no since hbar is not treated as an entity like tokens will be.\n+-   [ ] Should token only entity items exist in their own table or be added to `t_entities`?\n+-   [x] Should `account_balance` `accountNum` and `accountRealmNum` be migrated into `entityId` or should token_balance also use `accountNum` and `accountRealmNum` instead of `entityId`?\n+    -   A: Should be migrated to use `account_id` only\n+-   [ ] What filer options should be provided for new Token API's", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 818}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA5MjEzNA==", "bodyText": "Updated", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r493092134", "createdAt": "2020-09-22T23:39:03Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"token\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"token\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"token\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+To achieve this\n+-   Update `balances.js` `getBalances()` to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"token\":\"FOOBAR\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.1111\", \"amount\": -10},\n+                {\"account\": \"0.0.2222\", \"amount\": 10}\n+              ]\n+            },\n+            {\n+              \"token\":\"FOOCOIN\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.3333\", \"amount\": -10},\n+                {\"account\": \"0.0.4444\", \"amount\": 10}\n+               ]\n+            }\n+          ]\n+        }\n+      ]\n+    }\n+```\n+\n+To achieve this\n+-   Update `transactions.js` sql queries for `crypto_transfer` to pull the `token_id` and `token` columns\n+-   Update `createTransferLists()` in `transactions.js` to build a `tokenTransfers` list if `token` isn't HBAR or if `token_id` is empty\n+\n+\n+### Token Supply distribution\n+\n+`/api/v1/tokens/<token>/balances` this could be the equivalent of `/api/v1/balances?token=<token>` currently and would return a list of account and the token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokenBalances\": [\n+          {\n+            \"account\": \"0.15.10\",\n+            \"balance\": 100\n+          },\n+          {\n+            \"account\": \"0.15.9\",\n+            \"balance\": 90\n+          },\n+          {\n+            \"account\": \"0.15.8\",\n+            \"balance\": 80\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+To achieve this similar to balances\n+-   Create a `tokenBalance.js`\n+-   Add a `getTokenBalances()` which based on the time range provided (default to latest timestamp) and `tokenId` pulls out `account_id` and `balance` values from `token_balance` and returns them as an element in `tokenBalances` array.\n+\n+```sql\n+    select account_id, balance from token_balance where token_id = ? and consensus_timestamp = (select max(consensus_timestamp) from token_balance);\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens/<token>/balances?id=0.0.1000`\n+-   `/api/v1/tokens/<token>/balances?balance=gt:1000`\n+-   `/api/v1/tokens/<token>/balances?timestamp=1566562500.040961001`\n+\n+### Token Discovery\n+`/api/v1/tokens` this would return all tokens present on the network\n+\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokens\": [\n+          {\n+            \"token\": \"FOOBAR\",\n+            \"tokenId\": \"0.15.10\",\n+            \"key\": {\n+              \"_type\": \"ProtobufEncoded\",\n+              \"key\": \"7b2233222c2233222c2233227d\"\n+            }\n+          },\n+          {\n+            \"token\": \"FOOCOIN\",\n+            \"tokenId\": \"0.15.11\",\n+            \"key\": {\n+              \"_type\": \"ProtobufEncoded\",\n+              \"key\": \"9c2233222c2233222c2233227d\"\n+            }\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+To achieve this\n+-   Add a `getTokens()` to `tokenBalance.js` which pull the unique `token`, `tokenId` from the `token` table and joins with the `t_entities` table for the matching admin_key\n+\n+```sql\n+    select token, token_id from token t\n+          join t_entities e on t.token_id = e.id and e.fk_entity_type_id = ${utils.ENTITY_TYPE_TOKEN};\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens?adminkey=HJ^&8` - All tokens with matching admin key\n+-   `/api/v1/tokens?account.id=0.0.8` - All tokens for matching account\n+\n+### Token Info\n+-   Add a `getTokenInfo()` to `tokens.js` to retrieve token info from `token` table\n+```json\n+    {\n+      \"token\": \"FOOCOIN\",\n+      \"tokenId\": \"0.15.10\",\n+      \"treasury_account\": \"0.15.10\",\n+      \"adminKey\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"kycKey\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"freezeKey\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"wipeKey\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"supplyKey\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"freezeDefault\": false,\n+      \"kycDefault\": false,\n+      \"expiryTimestamp\": null,\n+      \"autoRenewAccount\": \"0.0.6\",\n+      \"autoRenewPeriod\": null\n+    }\n+```\n+\n+\n+## Protobuf\n+\n+```proto\n+    message TokenQuery {\n+        .proto.TokenID tokenID = 1; // The token ID to retrieve transfers for\n+        .proto.AccountID accountID = 2; // An account ID to retrieve transfers for. Required if no tokenID is specified\n+        .proto.Timestamp consensusStartTime = 3; // Include messages which reached consensus on or after this time. Defaults to current time if not set.\n+        .proto.Timestamp consensusEndTime = 4; // Include messages which reached consensus before this time. If not set it will receive indefinitely.\n+        uint64 limit = 5; // The maximum number of messages to receive before stopping. If not set or set to zero it will return messages indefinitely.\n+    }\n+\n+    message TokenResponse {\n+        .proto.Timestamp consensusTimestamp = 1; // The time at which the transaction reached consensus\n+        .proto.TokenTransfers transfer = 2; // Multiple list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)\n+    }\n+\n+    service TokenService {\n+        rpc subscribeTokenTransfers (TokenQuery) returns (stream TokenResponse);\n+    }\n+```\n+\n+## GRPC API\n+\n+### Controller\n+-   Add a `TokenController` that extends protobuf reactor stubs and implements `subscribeTokenTransfers`\n+```java\n+    package com.hedera.mirror.grpc.controller;\n+\n+    public class TokenController extends ReactorTokenServiceGrpc.TokenServiceImplBase {\n+            @Override\n+            public Flux<TokenResponse> subscribeTokenTransfers(Mono<TokenQuery> request) {\n+                ...\n+            }\n+    }\n+```\n+\n+### Domain\n+\n+-   Add `CryptoTransfer` class with class members `consensusTimestamp`, `entityId`, `amount`, `tokenId`. Also add necessary methods to support conversion from domain to protobuf TokenResponse\n+-   Add a `StreamItemFilter` base class that can be shared by `TopicMessageFilter` and `CryptoTransferFilter` with support for `startTime`, `endTime`, `limit` and `subscriberId`\n+```java\n+    package com.hedera.mirror.grpc.domain;\n+\n+    public class StreamItemFilter {\n+        private Instant endTime;\n+        private long limit;\n+        private int realmNum;\n+        private Instant startTime;\n+        private String subscriberId;\n+\n+        public boolean hasLimit() {\n+            return limit > 0;\n+        }\n+    }\n+```\n+-   Update `TopicMessageFilter` to extend `StreamItemFilter` and add `topicNum`\n+-   Add `CryptoTransferFilter` to extend `StreamItemFilter` and add `tokenNum`\n+```java\n+    package com.hedera.mirror.grpc.domain;\n+\n+    public class CryptoTransferFilter extends StreamItemFilter {\n+        @Min(0)\n+        private int tokenNum;\n+    }\n+```\n+\n+\n+-   Update `EntityType` with `TOKEN` option\n+```java\n+    package com.hedera.mirror.grpc.domain;\n+\n+    public enum EntityType {\n+\n+        UNKNOWN, // Filler value to offset next values by one to match database values\n+        ACCOUNT,\n+        CONTRACT,\n+        FILE,\n+        TOPIC,\n+        TOKEN\n+    }\n+```\n+\n+### Repository\n+-   Add a `StreamItemRepository`\n+```java\n+    package com.hedera.mirror.grpc.repository;\n+\n+    public interface StreamItemRepository extends CrudRepository<StreamItem, Long> {\n+        List<StreamItem> findLatest(long consensusTimestamp, Pageable pageable);\n+        List<StreamItem> findByFilter(StreamItemFilter filter);\n+    }\n+```\n+-   Add `CryptoTransferRepository` which implements `StreamItemRepository`\n+-   Update `TopicMessageRepository` to implement `StreamItemRepository`\n+\n+### Streaming : Listener & Retriever\n+The GRPC module currently supports listen and retrieval logic for incoming and historic topic messages respectively.\n+A lot of this logic can be shared for the equivalent `CryptoTransfer` listeners and retriever\n+\n+-   Add a `StreamItem` interface that stream-able domain objects can implement with get methods for `realm`, `entityNum` and `consensusTimestamp`\n+```java\n+    package com.hedera.mirror.grpc.domain;\n+\n+    public interface StreamItem {\n+        int getRealmNum();\n+        int getEntityNum();\n+        Long getConsensusTimestamp();\n+    }\n+```\n+\n+-   Update `TopicListener` to be `SharedListener`. Replace `TopicMessage` and `TopicMessageFilter` with generic type for StreamItem\n+```java\n+    package com.hedera.mirror.grpc.listener;\n+\n+    public interface SharedListener<T extends StreamItem> {\n+        Flux<T> listen(S filter);\n+    }\n+```\n+-   Update `CompositeTopicListener` to set generic types `T` and `S` as `TopicMessage` and `TopicMessageFilter` when creating `SharedListener` implementations.\n+-   Create `CompositeCryptoListener` similar to `CompositeTopicListener` that sets generic types of `T` and `S` as `CryptoTransfer` and `CryptoTransferFilter` when creating `Listener` implementations.\n+-   Update `NotifyTopicListener` to be `NotifyListener` and use generics `T` and `S` in place of `TopicMessage` and `TopicMessageFilter`\n+```java\n+    package com.hedera.mirror.grpc.listener;\n+\n+    public class NotifyingListener<T extends StreamItem, S extends StreamItemFilter> implements SharedListener<T, S> {\n+        ...\n+    }\n+```\n+-   Extract `PollingContext` from `SharedPollingTopicListener` and use `StreamItem` and `StreamItemFilter` in place of `TopicMessage` and `TopicMessageFilter`\n+```java\n+    package com.hedera.mirror.grpc.listener;\n+\n+    private class PollingContext {\n+        private final StreamItemFilter filter;\n+        private volatile StreamItem last;\n+        ...\n+    }\n+```\n+-   Update `PollingTopicListener` to `PollingListener` and use `StreamItem` and `StreamItemFilter` in place of `TopicMessage` and `TopicMessageFilter`. Also swap/add `streamItemRepository` private member.\n+```java\n+    package com.hedera.mirror.grpc.listener;\n+\n+    public class PollingListener implements SharedListener {\n+        ...\n+        private final StreamItemRepository streamItemRepository;\n+        ...\n+    }\n+```\n+-   Update `SharedPollingTopicListener` to `SharedPollingListener` and use `StreamItem` and `StreamItemFilter` in place of `TopicMessage` and `TopicMessageFilter`\n+```java\n+    package com.hedera.mirror.grpc.listener;\n+\n+    public class SharedPollingListener implements SharedListener {\n+        ...\n+        private final StreamItemRepository streamItemRepository;\n+        ...\n+    }\n+```\n+-   Update `TopicMessageRetriever` to be `Retriever` and use `StreamItem` and `StreamItemFilter` in place of `TopicMessage` and `TopicMessageFilter`\n+```java\n+    package com.hedera.mirror.grpc.retriever;\n+\n+    public interface Retriever {\n+        Flux<StreamItem> retrieve(StreamItemFilter filter);\n+    }\n+```\n+-   Update `PollingTopicMessageRetriever` to be `PollingRetriever` and use `StreamItem`, `StreamItemFilter` and `StreamItemRepository` in place of `TopicMessage`, `TopicMessageFilter` and `TopicMessageRepository`.\n+\n+### Service\n+> _Note:_ ***Sequence diagram to be added\n+\n+-   Add `CryptoTransferService` interface\n+```java\n+    package com.hedera.mirror.grpc.service;\n+\n+    public interface TokenService {\n+        Flux<StreamItem> subscribeTokenTransfers(@Valid StreamItemFilter filter);\n+    }\n+```\n+\n+-   Add `AbstractServiceImpl` that pulls out the common logic from `TopicMessageServiceImpl` `entityExists()`, `incomingMessages()` and `missingMessages()` and uses `StreamItem`, `StreamItemFilter` and `Retriever` in place of `TopicMessage`, `TopicMessageFilter` and `TopicRetriever`.\n+-   Update `TopicMessageServiceImpl` to extend `AbstractServiceImpl` and still implement `TopicMessageService`\n+-   Add `TokenServiceImpl` to extend `AbstractServiceImpl` and implement `TokenService`\n+```java\n+    package com.hedera.mirror.grpc.service;\n+\n+    public class TokenServiceImpl extends AbstractServiceImpl implements TokenService {\n+        ...\n+        private final Retriever retriever;\n+        Flux<StreamItem> subscribeTokenTransfers(@Valid StreamItemFilter filter){\n+            ...\n+        }\n+\n+        ...\n+    }\n+```\n+\n+## Non-Functional Requirements\n+\n+## Open Questions\n+-   [x] What's the maximum character size of the token `symbol` string\n+    -   A: Max length is currently 32 chars https://github.com/hashgraph/hedera-services/blob/master/hedera-node/src/main/resources/bootstrap.properties#L52\n+-   [x] Will a `token_id` and `token` be assigned a default value for HBARs across the network e.g. i.e. '1' and 'HBAR' respectively\n+    -   A: Currently no since hbar is not treated as an entity like tokens will be.\n+-   [ ] Should token only entity items exist in their own table or be added to `t_entities`?\n+-   [x] Should `account_balance` `accountNum` and `accountRealmNum` be migrated into `entityId` or should token_balance also use `accountNum` and `accountRealmNum` instead of `entityId`?\n+    -   A: Should be migrated to use `account_id` only\n+-   [ ] What filer options should be provided for new Token API's", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgyNTY1MA=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 818}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NDI4MTU5OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNToyMzoyNFrOHV_vFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxOTo1NDozOFrOHWKEBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgyNjM5MA==", "bodyText": "better rename it to symbol to be consistent with the design doc the HAPI protobuf.\nThere are Name and Symbol string fields in the design doc, we should ask for clarification since Name is also missing in HAPI protobuf", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492826390", "createdAt": "2020-09-22T15:23:24Z", "author": {"login": "xin-hedera"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg0OTI2Mg==", "bodyText": "token symbol is unique, we also need an index", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492849262", "createdAt": "2020-09-22T15:53:11Z", "author": {"login": "xin-hedera"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgyNjM5MA=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk5NTU5MA==", "bodyText": "Yes will revert back to symbol and I'm adding a serial primary key.\nThere will be 2 indexes added\ncreate unique index if not exists token_account__token_account on token_account(token_id, account_id);\n\ncreate index if not exists token_account__token_account_timestamp\n     on token_account (token_id desc, account_id desc, create_timestamp desc);", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492995590", "createdAt": "2020-09-22T19:54:38Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgyNjM5MA=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 175}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NDMzNDEwOnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNTozMzozNVrOHWAPLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMzo1MTo0MVrOHWQMDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgzNDYwNw==", "bodyText": "There's no need to read two lines. Just read the first and if version:2 send to v2. Else if contains words TimeStamp send to v1. Else throw an unsupported exception. Everything after the first line is specific to that version and we should encapsulate that inside its versioned reader.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492834607", "createdAt": "2020-09-22T15:33:35Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 299}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA5NTk1MQ==", "bodyText": "Updated", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r493095951", "createdAt": "2020-09-22T23:51:41Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgzNDYwNw=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 299}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NDMzODUwOnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNTozNDozMlrOHWAR8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNDoyMToxNVrOHWV0Ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgzNTMxMg==", "bodyText": "In protobuf, float (same as initialSupply) is uint64 and divisibility is uint32", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492835312", "createdAt": "2020-09-22T15:34:32Z", "author": {"login": "xin-hedera"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 280}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE4ODEzMA==", "bodyText": "Ended up removing class member details so as not to be over descriptive.\nHowever intiialSupply should be fine as a long no? Then divisibility can be reduced to an int", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r493188130", "createdAt": "2020-09-23T04:21:15Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgzNTMxMg=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 280}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NDM1NjYzOnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNTozODowNVrOHWAcow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMzo1MTo0NlrOHWQMJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgzODA1MQ==", "bodyText": "should mention base64 encoding", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492838051", "createdAt": "2020-09-22T15:38:05Z", "author": {"login": "xin-hedera"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 293}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA5NTk3NQ==", "bodyText": "Updated", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r493095975", "createdAt": "2020-09-22T23:51:46Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgzODA1MQ=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 293}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NDM5MzQ3OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNTo0NTo0NVrOHWAzRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMzo1MTozN1rOHWQL8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg0Mzg0Ng==", "bodyText": "This sort of granularity is too specific to the implementation. Design documents should focus on higher level architecture and leave the specifics to the implementers. It should mention domain classes, new classes and changed interfaces, but it doesn't need to mention every class that needs updating and what to update within them. Just FYI for future.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492843846", "createdAt": "2020-09-22T15:45:45Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 303}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA5NTkyMQ==", "bodyText": "Removed", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r493095921", "createdAt": "2020-09-22T23:51:37Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg0Mzg0Ng=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 303}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NDQwOTkwOnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNTo0OToxN1rOHWA9oQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMzo1MTozMVrOHWQL2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg0NjQ5Nw==", "bodyText": "Again, too specific. The first line Modify EntityRecordItemListener to handle parsing HTS transactions was enough.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492846497", "createdAt": "2020-09-22T15:49:17Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 334}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA5NTg5Ng==", "bodyText": "Simplified", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r493095896", "createdAt": "2020-09-22T23:51:31Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg0NjQ5Nw=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 334}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NDQxMTg1OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNTo0OTo0NlrOHWA-6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMzo1MToxMlrOHWQLfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg0NjgyNw==", "bodyText": "Unnecessary implementation details", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492846827", "createdAt": "2020-09-22T15:49:46Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"token\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"token\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 388}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA5NTgwNw==", "bodyText": "Removed", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r493095807", "createdAt": "2020-09-22T23:51:12Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"token\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"token\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg0NjgyNw=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 388}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NDQyMTI3OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNTo1MTo0OFrOHWBEuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMzo1MToyMlrOHWQLqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg0ODMxMw==", "bodyText": "We agreed that the order should be transactions, balances, accounts, etc", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492848313", "createdAt": "2020-09-22T15:51:48Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 348}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA5NTg1MA==", "bodyText": "Updated", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r493095850", "createdAt": "2020-09-22T23:51:22Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg0ODMxMw=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 348}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NDQyMTQ0OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNTo1MTo1MVrOHWBE0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMDo1MzowN1rOHXsOnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg0ODMzNw==", "bodyText": "should clarify the value of token can be either the tokenId or symbol", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492848337", "createdAt": "2020-09-22T15:51:51Z", "author": {"login": "xin-hedera"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"token\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"token\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"token\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+To achieve this\n+-   Update `balances.js` `getBalances()` to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"token\":\"FOOBAR\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 470}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc5MzQ0Mw==", "bodyText": "Yeah looks like symbol for now and then the /api/v1/tokens can be where we return symbol and/or tokenId", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r493793443", "createdAt": "2020-09-23T18:14:22Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"token\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"token\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"token\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+To achieve this\n+-   Update `balances.js` `getBalances()` to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"token\":\"FOOBAR\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg0ODMzNw=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 470}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg4MDgwMw==", "bodyText": "Actually looks like there's still some discussion on this, will circle back", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r493880803", "createdAt": "2020-09-23T20:38:58Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"token\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"token\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"token\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+To achieve this\n+-   Update `balances.js` `getBalances()` to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"token\":\"FOOBAR\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg0ODMzNw=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 470}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYwMzkzMw==", "bodyText": "Final call is tokenId everywhere", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494603933", "createdAt": "2020-09-24T20:53:07Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"token\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"token\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"token\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+To achieve this\n+-   Update `balances.js` `getBalances()` to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"token\":\"FOOBAR\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg0ODMzNw=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 470}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NDQzMjMzOnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNTo1NDowOVrOHWBLYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwMzoyNDo0MVrOHXzqsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg1MDAxOA==", "bodyText": "Prefer tokens as mentioned in #1047. Unnecessary to mention balances again since we're within the balances object.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492850018", "createdAt": "2020-09-22T15:54:09Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"token\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"token\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 401}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA5NTc3NA==", "bodyText": "Updated", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r493095774", "createdAt": "2020-09-22T23:51:05Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"token\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"token\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg1MDAxOA=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 401}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU0OTk3NQ==", "bodyText": "This doesn't seem to have changed.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494549975", "createdAt": "2020-09-24T19:08:28Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"token\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"token\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg1MDAxOA=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 401}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDcyNTgwOQ==", "bodyText": "Updated", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494725809", "createdAt": "2020-09-25T03:24:41Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"token\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"token\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg1MDAxOA=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 401}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NDQ0MDM2OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNTo1NTo1MVrOHWBQXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNDozNTo0OFrOHWWCag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg1MTI5Mg==", "bodyText": "This would be way more succinct as mentioned in #1047\n            \"tokens\": {\n              \"foobars\": 1000,\n              \"foocoins\": 50\n            }", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492851292", "createdAt": "2020-09-22T15:55:51Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"token\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"token\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 408}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5MTc4Ng==", "bodyText": "This is certainly more succinct.\nHowever, this would be the first section in all of our current REST API responses where there's no label for a value.\nSo it breaks the format in that sense.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r493191786", "createdAt": "2020-09-23T04:35:48Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"token\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"token\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg1MTI5Mg=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 408}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NDQ3NTc1OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNjowMzo1MVrOHWBnPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNDozODozNlrOHWWFEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg1NzE0OQ==", "bodyText": "Should we have this as the format mentioned in #1047? Even though it duplicates the token per transfer it is simpler and matches the structure in the TransactionRecord and in the database:\n            \"token_transfers\": [\n                {\n                    \"account\": \"0.0.1000\",\n                    \"amount\": 297,\n                    \"token\": \"foobars\"\n                }\n            ]", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492857149", "createdAt": "2020-09-22T16:03:51Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"token\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"token\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"token\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+To achieve this\n+-   Update `balances.js` `getBalances()` to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"token\":\"FOOBAR\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 470}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5MjQ2NQ==", "bodyText": "Yeah, I'm okay with managing duplication if we get more simplicity and matching db structure.\nWill update", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r493192465", "createdAt": "2020-09-23T04:38:36Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"token\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"token\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"token\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+To achieve this\n+-   Update `balances.js` `getBalances()` to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"token\":\"FOOBAR\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg1NzE0OQ=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 470}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NDQ4MjEyOnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNjowNToxNlrOHWBrEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxNjoyNTozN1rOHW2s9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg1ODEyOQ==", "bodyText": "should this be adminKey?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492858129", "createdAt": "2020-09-22T16:05:16Z", "author": {"login": "xin-hedera"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"token\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"token\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"token\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+To achieve this\n+-   Update `balances.js` `getBalances()` to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"token\":\"FOOBAR\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.1111\", \"amount\": -10},\n+                {\"account\": \"0.0.2222\", \"amount\": 10}\n+              ]\n+            },\n+            {\n+              \"token\":\"FOOCOIN\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.3333\", \"amount\": -10},\n+                {\"account\": \"0.0.4444\", \"amount\": 10}\n+               ]\n+            }\n+          ]\n+        }\n+      ]\n+    }\n+```\n+\n+To achieve this\n+-   Update `transactions.js` sql queries for `crypto_transfer` to pull the `token_id` and `token` columns\n+-   Update `createTransferLists()` in `transactions.js` to build a `tokenTransfers` list if `token` isn't HBAR or if `token_id` is empty\n+\n+\n+### Token Supply distribution\n+\n+`/api/v1/tokens/<token>/balances` this could be the equivalent of `/api/v1/balances?token=<token>` currently and would return a list of account and the token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokenBalances\": [\n+          {\n+            \"account\": \"0.15.10\",\n+            \"balance\": 100\n+          },\n+          {\n+            \"account\": \"0.15.9\",\n+            \"balance\": 90\n+          },\n+          {\n+            \"account\": \"0.15.8\",\n+            \"balance\": 80\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+To achieve this similar to balances\n+-   Create a `tokenBalance.js`\n+-   Add a `getTokenBalances()` which based on the time range provided (default to latest timestamp) and `tokenId` pulls out `account_id` and `balance` values from `token_balance` and returns them as an element in `tokenBalances` array.\n+\n+```sql\n+    select account_id, balance from token_balance where token_id = ? and consensus_timestamp = (select max(consensus_timestamp) from token_balance);\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens/<token>/balances?id=0.0.1000`\n+-   `/api/v1/tokens/<token>/balances?balance=gt:1000`\n+-   `/api/v1/tokens/<token>/balances?timestamp=1566562500.040961001`\n+\n+### Token Discovery\n+`/api/v1/tokens` this would return all tokens present on the network\n+\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokens\": [\n+          {\n+            \"token\": \"FOOBAR\",\n+            \"tokenId\": \"0.15.10\",\n+            \"key\": {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 543}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA5MDU0NQ==", "bodyText": "Yes, but I believe other REST APIs were using just key so I tried to match. Will confirm", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r493090545", "createdAt": "2020-09-22T23:34:20Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"token\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"token\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"token\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+To achieve this\n+-   Update `balances.js` `getBalances()` to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"token\":\"FOOBAR\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.1111\", \"amount\": -10},\n+                {\"account\": \"0.0.2222\", \"amount\": 10}\n+              ]\n+            },\n+            {\n+              \"token\":\"FOOCOIN\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.3333\", \"amount\": -10},\n+                {\"account\": \"0.0.4444\", \"amount\": 10}\n+               ]\n+            }\n+          ]\n+        }\n+      ]\n+    }\n+```\n+\n+To achieve this\n+-   Update `transactions.js` sql queries for `crypto_transfer` to pull the `token_id` and `token` columns\n+-   Update `createTransferLists()` in `transactions.js` to build a `tokenTransfers` list if `token` isn't HBAR or if `token_id` is empty\n+\n+\n+### Token Supply distribution\n+\n+`/api/v1/tokens/<token>/balances` this could be the equivalent of `/api/v1/balances?token=<token>` currently and would return a list of account and the token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokenBalances\": [\n+          {\n+            \"account\": \"0.15.10\",\n+            \"balance\": 100\n+          },\n+          {\n+            \"account\": \"0.15.9\",\n+            \"balance\": 90\n+          },\n+          {\n+            \"account\": \"0.15.8\",\n+            \"balance\": 80\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+To achieve this similar to balances\n+-   Create a `tokenBalance.js`\n+-   Add a `getTokenBalances()` which based on the time range provided (default to latest timestamp) and `tokenId` pulls out `account_id` and `balance` values from `token_balance` and returns them as an element in `tokenBalances` array.\n+\n+```sql\n+    select account_id, balance from token_balance where token_id = ? and consensus_timestamp = (select max(consensus_timestamp) from token_balance);\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens/<token>/balances?id=0.0.1000`\n+-   `/api/v1/tokens/<token>/balances?balance=gt:1000`\n+-   `/api/v1/tokens/<token>/balances?timestamp=1566562500.040961001`\n+\n+### Token Discovery\n+`/api/v1/tokens` this would return all tokens present on the network\n+\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokens\": [\n+          {\n+            \"token\": \"FOOBAR\",\n+            \"tokenId\": \"0.15.10\",\n+            \"key\": {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg1ODEyOQ=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 543}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzcyNjk2NQ==", "bodyText": "I can change it to be clear though since tokens do have many keys", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r493726965", "createdAt": "2020-09-23T16:25:37Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"token\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"token\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"token\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+To achieve this\n+-   Update `balances.js` `getBalances()` to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"token\":\"FOOBAR\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.1111\", \"amount\": -10},\n+                {\"account\": \"0.0.2222\", \"amount\": 10}\n+              ]\n+            },\n+            {\n+              \"token\":\"FOOCOIN\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.3333\", \"amount\": -10},\n+                {\"account\": \"0.0.4444\", \"amount\": 10}\n+               ]\n+            }\n+          ]\n+        }\n+      ]\n+    }\n+```\n+\n+To achieve this\n+-   Update `transactions.js` sql queries for `crypto_transfer` to pull the `token_id` and `token` columns\n+-   Update `createTransferLists()` in `transactions.js` to build a `tokenTransfers` list if `token` isn't HBAR or if `token_id` is empty\n+\n+\n+### Token Supply distribution\n+\n+`/api/v1/tokens/<token>/balances` this could be the equivalent of `/api/v1/balances?token=<token>` currently and would return a list of account and the token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokenBalances\": [\n+          {\n+            \"account\": \"0.15.10\",\n+            \"balance\": 100\n+          },\n+          {\n+            \"account\": \"0.15.9\",\n+            \"balance\": 90\n+          },\n+          {\n+            \"account\": \"0.15.8\",\n+            \"balance\": 80\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+To achieve this similar to balances\n+-   Create a `tokenBalance.js`\n+-   Add a `getTokenBalances()` which based on the time range provided (default to latest timestamp) and `tokenId` pulls out `account_id` and `balance` values from `token_balance` and returns them as an element in `tokenBalances` array.\n+\n+```sql\n+    select account_id, balance from token_balance where token_id = ? and consensus_timestamp = (select max(consensus_timestamp) from token_balance);\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens/<token>/balances?id=0.0.1000`\n+-   `/api/v1/tokens/<token>/balances?balance=gt:1000`\n+-   `/api/v1/tokens/<token>/balances?timestamp=1566562500.040961001`\n+\n+### Token Discovery\n+`/api/v1/tokens` this would return all tokens present on the network\n+\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokens\": [\n+          {\n+            \"token\": \"FOOBAR\",\n+            \"tokenId\": \"0.15.10\",\n+            \"key\": {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg1ODEyOQ=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 543}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NDUwMjY5OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNjoxMDowOVrOHWB4Cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxOTowNjozMFrOHW9Dmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg2MTQ1MA==", "bodyText": "protobuf Key is a complicated structure, it can be a single key of different algorithms, it can be a threshold key with a threshold then recursively includes Key, or a KeyList recursively includes a list of Keys\nin order to support such a filter, we need more clarity on how it works", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492861450", "createdAt": "2020-09-22T16:10:09Z", "author": {"login": "xin-hedera"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"token\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"token\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"token\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+To achieve this\n+-   Update `balances.js` `getBalances()` to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"token\":\"FOOBAR\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.1111\", \"amount\": -10},\n+                {\"account\": \"0.0.2222\", \"amount\": 10}\n+              ]\n+            },\n+            {\n+              \"token\":\"FOOCOIN\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.3333\", \"amount\": -10},\n+                {\"account\": \"0.0.4444\", \"amount\": 10}\n+               ]\n+            }\n+          ]\n+        }\n+      ]\n+    }\n+```\n+\n+To achieve this\n+-   Update `transactions.js` sql queries for `crypto_transfer` to pull the `token_id` and `token` columns\n+-   Update `createTransferLists()` in `transactions.js` to build a `tokenTransfers` list if `token` isn't HBAR or if `token_id` is empty\n+\n+\n+### Token Supply distribution\n+\n+`/api/v1/tokens/<token>/balances` this could be the equivalent of `/api/v1/balances?token=<token>` currently and would return a list of account and the token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokenBalances\": [\n+          {\n+            \"account\": \"0.15.10\",\n+            \"balance\": 100\n+          },\n+          {\n+            \"account\": \"0.15.9\",\n+            \"balance\": 90\n+          },\n+          {\n+            \"account\": \"0.15.8\",\n+            \"balance\": 80\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+To achieve this similar to balances\n+-   Create a `tokenBalance.js`\n+-   Add a `getTokenBalances()` which based on the time range provided (default to latest timestamp) and `tokenId` pulls out `account_id` and `balance` values from `token_balance` and returns them as an element in `tokenBalances` array.\n+\n+```sql\n+    select account_id, balance from token_balance where token_id = ? and consensus_timestamp = (select max(consensus_timestamp) from token_balance);\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens/<token>/balances?id=0.0.1000`\n+-   `/api/v1/tokens/<token>/balances?balance=gt:1000`\n+-   `/api/v1/tokens/<token>/balances?timestamp=1566562500.040961001`\n+\n+### Token Discovery\n+`/api/v1/tokens` this would return all tokens present on the network\n+\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokens\": [\n+          {\n+            \"token\": \"FOOBAR\",\n+            \"tokenId\": \"0.15.10\",\n+            \"key\": {\n+              \"_type\": \"ProtobufEncoded\",\n+              \"key\": \"7b2233222c2233222c2233227d\"\n+            }\n+          },\n+          {\n+            \"token\": \"FOOCOIN\",\n+            \"tokenId\": \"0.15.11\",\n+            \"key\": {\n+              \"_type\": \"ProtobufEncoded\",\n+              \"key\": \"9c2233222c2233222c2233227d\"\n+            }\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+To achieve this\n+-   Add a `getTokens()` to `tokenBalance.js` which pull the unique `token`, `tokenId` from the `token` table and joins with the `t_entities` table for the matching admin_key\n+\n+```sql\n+    select token, token_id from token t\n+          join t_entities e on t.token_id = e.id and e.fk_entity_type_id = ${utils.ENTITY_TYPE_TOKEN};\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens?adminkey=HJ^&8` - All tokens with matching admin key", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 572}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE4OTQ0MA==", "bodyText": "The example was a placeholder.\nMore realistic query is exactly what we have in /api/v1/accounts\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            -   `/api/v1/tokens?adminkey=HJ^&8` - All tokens with matching admin key\n          \n          \n            \n            -   `/api/v1/tokens?publickey=3c3d546321ff6f63d701d2ec5c277095874e19f4a235bee1e6bb19258bf362be` - All tokens with matching admin key", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r493189440", "createdAt": "2020-09-23T04:26:24Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"token\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"token\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"token\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+To achieve this\n+-   Update `balances.js` `getBalances()` to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"token\":\"FOOBAR\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.1111\", \"amount\": -10},\n+                {\"account\": \"0.0.2222\", \"amount\": 10}\n+              ]\n+            },\n+            {\n+              \"token\":\"FOOCOIN\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.3333\", \"amount\": -10},\n+                {\"account\": \"0.0.4444\", \"amount\": 10}\n+               ]\n+            }\n+          ]\n+        }\n+      ]\n+    }\n+```\n+\n+To achieve this\n+-   Update `transactions.js` sql queries for `crypto_transfer` to pull the `token_id` and `token` columns\n+-   Update `createTransferLists()` in `transactions.js` to build a `tokenTransfers` list if `token` isn't HBAR or if `token_id` is empty\n+\n+\n+### Token Supply distribution\n+\n+`/api/v1/tokens/<token>/balances` this could be the equivalent of `/api/v1/balances?token=<token>` currently and would return a list of account and the token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokenBalances\": [\n+          {\n+            \"account\": \"0.15.10\",\n+            \"balance\": 100\n+          },\n+          {\n+            \"account\": \"0.15.9\",\n+            \"balance\": 90\n+          },\n+          {\n+            \"account\": \"0.15.8\",\n+            \"balance\": 80\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+To achieve this similar to balances\n+-   Create a `tokenBalance.js`\n+-   Add a `getTokenBalances()` which based on the time range provided (default to latest timestamp) and `tokenId` pulls out `account_id` and `balance` values from `token_balance` and returns them as an element in `tokenBalances` array.\n+\n+```sql\n+    select account_id, balance from token_balance where token_id = ? and consensus_timestamp = (select max(consensus_timestamp) from token_balance);\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens/<token>/balances?id=0.0.1000`\n+-   `/api/v1/tokens/<token>/balances?balance=gt:1000`\n+-   `/api/v1/tokens/<token>/balances?timestamp=1566562500.040961001`\n+\n+### Token Discovery\n+`/api/v1/tokens` this would return all tokens present on the network\n+\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokens\": [\n+          {\n+            \"token\": \"FOOBAR\",\n+            \"tokenId\": \"0.15.10\",\n+            \"key\": {\n+              \"_type\": \"ProtobufEncoded\",\n+              \"key\": \"7b2233222c2233222c2233227d\"\n+            }\n+          },\n+          {\n+            \"token\": \"FOOCOIN\",\n+            \"tokenId\": \"0.15.11\",\n+            \"key\": {\n+              \"_type\": \"ProtobufEncoded\",\n+              \"key\": \"9c2233222c2233222c2233227d\"\n+            }\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+To achieve this\n+-   Add a `getTokens()` to `tokenBalance.js` which pull the unique `token`, `tokenId` from the `token` table and joins with the `t_entities` table for the matching admin_key\n+\n+```sql\n+    select token, token_id from token t\n+          join t_entities e on t.token_id = e.id and e.fk_entity_type_id = ${utils.ENTITY_TYPE_TOKEN};\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens?adminkey=HJ^&8` - All tokens with matching admin key", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg2MTQ1MA=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 572}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgzMTA2Ng==", "bodyText": "The t_entities.key is also from the protobuf key, we're currently able to filter on that for the /api/v1/accounts?account.publickey=<key>.\nSo I believe it's not as complex as we think. It's also the exact same key so the sql query logic is the same and should be doable", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r493831066", "createdAt": "2020-09-23T19:06:30Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"token\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"token\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"token\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+To achieve this\n+-   Update `balances.js` `getBalances()` to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"token\":\"FOOBAR\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.1111\", \"amount\": -10},\n+                {\"account\": \"0.0.2222\", \"amount\": 10}\n+              ]\n+            },\n+            {\n+              \"token\":\"FOOCOIN\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.3333\", \"amount\": -10},\n+                {\"account\": \"0.0.4444\", \"amount\": 10}\n+               ]\n+            }\n+          ]\n+        }\n+      ]\n+    }\n+```\n+\n+To achieve this\n+-   Update `transactions.js` sql queries for `crypto_transfer` to pull the `token_id` and `token` columns\n+-   Update `createTransferLists()` in `transactions.js` to build a `tokenTransfers` list if `token` isn't HBAR or if `token_id` is empty\n+\n+\n+### Token Supply distribution\n+\n+`/api/v1/tokens/<token>/balances` this could be the equivalent of `/api/v1/balances?token=<token>` currently and would return a list of account and the token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokenBalances\": [\n+          {\n+            \"account\": \"0.15.10\",\n+            \"balance\": 100\n+          },\n+          {\n+            \"account\": \"0.15.9\",\n+            \"balance\": 90\n+          },\n+          {\n+            \"account\": \"0.15.8\",\n+            \"balance\": 80\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+To achieve this similar to balances\n+-   Create a `tokenBalance.js`\n+-   Add a `getTokenBalances()` which based on the time range provided (default to latest timestamp) and `tokenId` pulls out `account_id` and `balance` values from `token_balance` and returns them as an element in `tokenBalances` array.\n+\n+```sql\n+    select account_id, balance from token_balance where token_id = ? and consensus_timestamp = (select max(consensus_timestamp) from token_balance);\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens/<token>/balances?id=0.0.1000`\n+-   `/api/v1/tokens/<token>/balances?balance=gt:1000`\n+-   `/api/v1/tokens/<token>/balances?timestamp=1566562500.040961001`\n+\n+### Token Discovery\n+`/api/v1/tokens` this would return all tokens present on the network\n+\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokens\": [\n+          {\n+            \"token\": \"FOOBAR\",\n+            \"tokenId\": \"0.15.10\",\n+            \"key\": {\n+              \"_type\": \"ProtobufEncoded\",\n+              \"key\": \"7b2233222c2233222c2233227d\"\n+            }\n+          },\n+          {\n+            \"token\": \"FOOCOIN\",\n+            \"tokenId\": \"0.15.11\",\n+            \"key\": {\n+              \"_type\": \"ProtobufEncoded\",\n+              \"key\": \"9c2233222c2233222c2233227d\"\n+            }\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+To achieve this\n+-   Add a `getTokens()` to `tokenBalance.js` which pull the unique `token`, `tokenId` from the `token` table and joins with the `t_entities` table for the matching admin_key\n+\n+```sql\n+    select token, token_id from token t\n+          join t_entities e on t.token_id = e.id and e.fk_entity_type_id = ${utils.ENTITY_TYPE_TOKEN};\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens?adminkey=HJ^&8` - All tokens with matching admin key", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg2MTQ1MA=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 572}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NDUwNzc0OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNjoxMToxMFrOHWB7Dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNToxMjowMFrOHWWnCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg2MjIyMg==", "bodyText": "snake_case is used for all fields in REST API response. Please adjust everywhere.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492862222", "createdAt": "2020-09-22T16:11:10Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"token\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"token\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"token\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+To achieve this\n+-   Update `balances.js` `getBalances()` to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"token\":\"FOOBAR\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.1111\", \"amount\": -10},\n+                {\"account\": \"0.0.2222\", \"amount\": 10}\n+              ]\n+            },\n+            {\n+              \"token\":\"FOOCOIN\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.3333\", \"amount\": -10},\n+                {\"account\": \"0.0.4444\", \"amount\": 10}\n+               ]\n+            }\n+          ]\n+        }\n+      ]\n+    }\n+```\n+\n+To achieve this\n+-   Update `transactions.js` sql queries for `crypto_transfer` to pull the `token_id` and `token` columns\n+-   Update `createTransferLists()` in `transactions.js` to build a `tokenTransfers` list if `token` isn't HBAR or if `token_id` is empty\n+\n+\n+### Token Supply distribution\n+\n+`/api/v1/tokens/<token>/balances` this could be the equivalent of `/api/v1/balances?token=<token>` currently and would return a list of account and the token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokenBalances\": [\n+          {\n+            \"account\": \"0.15.10\",\n+            \"balance\": 100\n+          },\n+          {\n+            \"account\": \"0.15.9\",\n+            \"balance\": 90\n+          },\n+          {\n+            \"account\": \"0.15.8\",\n+            \"balance\": 80\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+To achieve this similar to balances\n+-   Create a `tokenBalance.js`\n+-   Add a `getTokenBalances()` which based on the time range provided (default to latest timestamp) and `tokenId` pulls out `account_id` and `balance` values from `token_balance` and returns them as an element in `tokenBalances` array.\n+\n+```sql\n+    select account_id, balance from token_balance where token_id = ? and consensus_timestamp = (select max(consensus_timestamp) from token_balance);\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens/<token>/balances?id=0.0.1000`\n+-   `/api/v1/tokens/<token>/balances?balance=gt:1000`\n+-   `/api/v1/tokens/<token>/balances?timestamp=1566562500.040961001`\n+\n+### Token Discovery\n+`/api/v1/tokens` this would return all tokens present on the network\n+\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokens\": [\n+          {\n+            \"token\": \"FOOBAR\",\n+            \"tokenId\": \"0.15.10\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 542}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzIwMTE2MA==", "bodyText": "Updated", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r493201160", "createdAt": "2020-09-23T05:12:00Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"token\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"token\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"token\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+To achieve this\n+-   Update `balances.js` `getBalances()` to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"token\":\"FOOBAR\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.1111\", \"amount\": -10},\n+                {\"account\": \"0.0.2222\", \"amount\": 10}\n+              ]\n+            },\n+            {\n+              \"token\":\"FOOCOIN\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.3333\", \"amount\": -10},\n+                {\"account\": \"0.0.4444\", \"amount\": 10}\n+               ]\n+            }\n+          ]\n+        }\n+      ]\n+    }\n+```\n+\n+To achieve this\n+-   Update `transactions.js` sql queries for `crypto_transfer` to pull the `token_id` and `token` columns\n+-   Update `createTransferLists()` in `transactions.js` to build a `tokenTransfers` list if `token` isn't HBAR or if `token_id` is empty\n+\n+\n+### Token Supply distribution\n+\n+`/api/v1/tokens/<token>/balances` this could be the equivalent of `/api/v1/balances?token=<token>` currently and would return a list of account and the token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokenBalances\": [\n+          {\n+            \"account\": \"0.15.10\",\n+            \"balance\": 100\n+          },\n+          {\n+            \"account\": \"0.15.9\",\n+            \"balance\": 90\n+          },\n+          {\n+            \"account\": \"0.15.8\",\n+            \"balance\": 80\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+To achieve this similar to balances\n+-   Create a `tokenBalance.js`\n+-   Add a `getTokenBalances()` which based on the time range provided (default to latest timestamp) and `tokenId` pulls out `account_id` and `balance` values from `token_balance` and returns them as an element in `tokenBalances` array.\n+\n+```sql\n+    select account_id, balance from token_balance where token_id = ? and consensus_timestamp = (select max(consensus_timestamp) from token_balance);\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens/<token>/balances?id=0.0.1000`\n+-   `/api/v1/tokens/<token>/balances?balance=gt:1000`\n+-   `/api/v1/tokens/<token>/balances?timestamp=1566562500.040961001`\n+\n+### Token Discovery\n+`/api/v1/tokens` this would return all tokens present on the network\n+\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokens\": [\n+          {\n+            \"token\": \"FOOBAR\",\n+            \"tokenId\": \"0.15.10\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg2MjIyMg=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 542}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NDUxMTA1OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNjoxMjowM1rOHWB9Mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNDoyNjo1NlrOHWV5wA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg2Mjc3MA==", "bodyText": "may want to support TokenRef instead of just TokenID", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492862770", "createdAt": "2020-09-22T16:12:03Z", "author": {"login": "xin-hedera"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"token\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"token\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"token\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+To achieve this\n+-   Update `balances.js` `getBalances()` to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"token\":\"FOOBAR\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.1111\", \"amount\": -10},\n+                {\"account\": \"0.0.2222\", \"amount\": 10}\n+              ]\n+            },\n+            {\n+              \"token\":\"FOOCOIN\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.3333\", \"amount\": -10},\n+                {\"account\": \"0.0.4444\", \"amount\": 10}\n+               ]\n+            }\n+          ]\n+        }\n+      ]\n+    }\n+```\n+\n+To achieve this\n+-   Update `transactions.js` sql queries for `crypto_transfer` to pull the `token_id` and `token` columns\n+-   Update `createTransferLists()` in `transactions.js` to build a `tokenTransfers` list if `token` isn't HBAR or if `token_id` is empty\n+\n+\n+### Token Supply distribution\n+\n+`/api/v1/tokens/<token>/balances` this could be the equivalent of `/api/v1/balances?token=<token>` currently and would return a list of account and the token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokenBalances\": [\n+          {\n+            \"account\": \"0.15.10\",\n+            \"balance\": 100\n+          },\n+          {\n+            \"account\": \"0.15.9\",\n+            \"balance\": 90\n+          },\n+          {\n+            \"account\": \"0.15.8\",\n+            \"balance\": 80\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+To achieve this similar to balances\n+-   Create a `tokenBalance.js`\n+-   Add a `getTokenBalances()` which based on the time range provided (default to latest timestamp) and `tokenId` pulls out `account_id` and `balance` values from `token_balance` and returns them as an element in `tokenBalances` array.\n+\n+```sql\n+    select account_id, balance from token_balance where token_id = ? and consensus_timestamp = (select max(consensus_timestamp) from token_balance);\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens/<token>/balances?id=0.0.1000`\n+-   `/api/v1/tokens/<token>/balances?balance=gt:1000`\n+-   `/api/v1/tokens/<token>/balances?timestamp=1566562500.040961001`\n+\n+### Token Discovery\n+`/api/v1/tokens` this would return all tokens present on the network\n+\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokens\": [\n+          {\n+            \"token\": \"FOOBAR\",\n+            \"tokenId\": \"0.15.10\",\n+            \"key\": {\n+              \"_type\": \"ProtobufEncoded\",\n+              \"key\": \"7b2233222c2233222c2233227d\"\n+            }\n+          },\n+          {\n+            \"token\": \"FOOCOIN\",\n+            \"tokenId\": \"0.15.11\",\n+            \"key\": {\n+              \"_type\": \"ProtobufEncoded\",\n+              \"key\": \"9c2233222c2233222c2233227d\"\n+            }\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+To achieve this\n+-   Add a `getTokens()` to `tokenBalance.js` which pull the unique `token`, `tokenId` from the `token` table and joins with the `t_entities` table for the matching admin_key\n+\n+```sql\n+    select token, token_id from token t\n+          join t_entities e on t.token_id = e.id and e.fk_entity_type_id = ${utils.ENTITY_TYPE_TOKEN};\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens?adminkey=HJ^&8` - All tokens with matching admin key\n+-   `/api/v1/tokens?account.id=0.0.8` - All tokens for matching account\n+\n+### Token Info\n+-   Add a `getTokenInfo()` to `tokens.js` to retrieve token info from `token` table\n+```json\n+    {\n+      \"token\": \"FOOCOIN\",\n+      \"tokenId\": \"0.15.10\",\n+      \"treasury_account\": \"0.15.10\",\n+      \"adminKey\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"kycKey\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"freezeKey\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"wipeKey\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"supplyKey\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"freezeDefault\": false,\n+      \"kycDefault\": false,\n+      \"expiryTimestamp\": null,\n+      \"autoRenewAccount\": \"0.0.6\",\n+      \"autoRenewPeriod\": null\n+    }\n+```\n+\n+\n+## Protobuf\n+\n+```proto\n+    message TokenQuery {\n+        .proto.TokenID tokenID = 1; // The token ID to retrieve transfers for", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 615}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA5MDY4OA==", "bodyText": "Yes good idea", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r493090688", "createdAt": "2020-09-22T23:34:48Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"token\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"token\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"token\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+To achieve this\n+-   Update `balances.js` `getBalances()` to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"token\":\"FOOBAR\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.1111\", \"amount\": -10},\n+                {\"account\": \"0.0.2222\", \"amount\": 10}\n+              ]\n+            },\n+            {\n+              \"token\":\"FOOCOIN\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.3333\", \"amount\": -10},\n+                {\"account\": \"0.0.4444\", \"amount\": 10}\n+               ]\n+            }\n+          ]\n+        }\n+      ]\n+    }\n+```\n+\n+To achieve this\n+-   Update `transactions.js` sql queries for `crypto_transfer` to pull the `token_id` and `token` columns\n+-   Update `createTransferLists()` in `transactions.js` to build a `tokenTransfers` list if `token` isn't HBAR or if `token_id` is empty\n+\n+\n+### Token Supply distribution\n+\n+`/api/v1/tokens/<token>/balances` this could be the equivalent of `/api/v1/balances?token=<token>` currently and would return a list of account and the token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokenBalances\": [\n+          {\n+            \"account\": \"0.15.10\",\n+            \"balance\": 100\n+          },\n+          {\n+            \"account\": \"0.15.9\",\n+            \"balance\": 90\n+          },\n+          {\n+            \"account\": \"0.15.8\",\n+            \"balance\": 80\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+To achieve this similar to balances\n+-   Create a `tokenBalance.js`\n+-   Add a `getTokenBalances()` which based on the time range provided (default to latest timestamp) and `tokenId` pulls out `account_id` and `balance` values from `token_balance` and returns them as an element in `tokenBalances` array.\n+\n+```sql\n+    select account_id, balance from token_balance where token_id = ? and consensus_timestamp = (select max(consensus_timestamp) from token_balance);\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens/<token>/balances?id=0.0.1000`\n+-   `/api/v1/tokens/<token>/balances?balance=gt:1000`\n+-   `/api/v1/tokens/<token>/balances?timestamp=1566562500.040961001`\n+\n+### Token Discovery\n+`/api/v1/tokens` this would return all tokens present on the network\n+\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokens\": [\n+          {\n+            \"token\": \"FOOBAR\",\n+            \"tokenId\": \"0.15.10\",\n+            \"key\": {\n+              \"_type\": \"ProtobufEncoded\",\n+              \"key\": \"7b2233222c2233222c2233227d\"\n+            }\n+          },\n+          {\n+            \"token\": \"FOOCOIN\",\n+            \"tokenId\": \"0.15.11\",\n+            \"key\": {\n+              \"_type\": \"ProtobufEncoded\",\n+              \"key\": \"9c2233222c2233222c2233227d\"\n+            }\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+To achieve this\n+-   Add a `getTokens()` to `tokenBalance.js` which pull the unique `token`, `tokenId` from the `token` table and joins with the `t_entities` table for the matching admin_key\n+\n+```sql\n+    select token, token_id from token t\n+          join t_entities e on t.token_id = e.id and e.fk_entity_type_id = ${utils.ENTITY_TYPE_TOKEN};\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens?adminkey=HJ^&8` - All tokens with matching admin key\n+-   `/api/v1/tokens?account.id=0.0.8` - All tokens for matching account\n+\n+### Token Info\n+-   Add a `getTokenInfo()` to `tokens.js` to retrieve token info from `token` table\n+```json\n+    {\n+      \"token\": \"FOOCOIN\",\n+      \"tokenId\": \"0.15.10\",\n+      \"treasury_account\": \"0.15.10\",\n+      \"adminKey\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"kycKey\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"freezeKey\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"wipeKey\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"supplyKey\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"freezeDefault\": false,\n+      \"kycDefault\": false,\n+      \"expiryTimestamp\": null,\n+      \"autoRenewAccount\": \"0.0.6\",\n+      \"autoRenewPeriod\": null\n+    }\n+```\n+\n+\n+## Protobuf\n+\n+```proto\n+    message TokenQuery {\n+        .proto.TokenID tokenID = 1; // The token ID to retrieve transfers for", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg2Mjc3MA=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 615}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE4OTU2OA==", "bodyText": "Noted locally but removed those details in the section", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r493189568", "createdAt": "2020-09-23T04:26:56Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"token\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"token\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"token\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+To achieve this\n+-   Update `balances.js` `getBalances()` to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"token\":\"FOOBAR\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.1111\", \"amount\": -10},\n+                {\"account\": \"0.0.2222\", \"amount\": 10}\n+              ]\n+            },\n+            {\n+              \"token\":\"FOOCOIN\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.3333\", \"amount\": -10},\n+                {\"account\": \"0.0.4444\", \"amount\": 10}\n+               ]\n+            }\n+          ]\n+        }\n+      ]\n+    }\n+```\n+\n+To achieve this\n+-   Update `transactions.js` sql queries for `crypto_transfer` to pull the `token_id` and `token` columns\n+-   Update `createTransferLists()` in `transactions.js` to build a `tokenTransfers` list if `token` isn't HBAR or if `token_id` is empty\n+\n+\n+### Token Supply distribution\n+\n+`/api/v1/tokens/<token>/balances` this could be the equivalent of `/api/v1/balances?token=<token>` currently and would return a list of account and the token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokenBalances\": [\n+          {\n+            \"account\": \"0.15.10\",\n+            \"balance\": 100\n+          },\n+          {\n+            \"account\": \"0.15.9\",\n+            \"balance\": 90\n+          },\n+          {\n+            \"account\": \"0.15.8\",\n+            \"balance\": 80\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+To achieve this similar to balances\n+-   Create a `tokenBalance.js`\n+-   Add a `getTokenBalances()` which based on the time range provided (default to latest timestamp) and `tokenId` pulls out `account_id` and `balance` values from `token_balance` and returns them as an element in `tokenBalances` array.\n+\n+```sql\n+    select account_id, balance from token_balance where token_id = ? and consensus_timestamp = (select max(consensus_timestamp) from token_balance);\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens/<token>/balances?id=0.0.1000`\n+-   `/api/v1/tokens/<token>/balances?balance=gt:1000`\n+-   `/api/v1/tokens/<token>/balances?timestamp=1566562500.040961001`\n+\n+### Token Discovery\n+`/api/v1/tokens` this would return all tokens present on the network\n+\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokens\": [\n+          {\n+            \"token\": \"FOOBAR\",\n+            \"tokenId\": \"0.15.10\",\n+            \"key\": {\n+              \"_type\": \"ProtobufEncoded\",\n+              \"key\": \"7b2233222c2233222c2233227d\"\n+            }\n+          },\n+          {\n+            \"token\": \"FOOCOIN\",\n+            \"tokenId\": \"0.15.11\",\n+            \"key\": {\n+              \"_type\": \"ProtobufEncoded\",\n+              \"key\": \"9c2233222c2233222c2233227d\"\n+            }\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+To achieve this\n+-   Add a `getTokens()` to `tokenBalance.js` which pull the unique `token`, `tokenId` from the `token` table and joins with the `t_entities` table for the matching admin_key\n+\n+```sql\n+    select token, token_id from token t\n+          join t_entities e on t.token_id = e.id and e.fk_entity_type_id = ${utils.ENTITY_TYPE_TOKEN};\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens?adminkey=HJ^&8` - All tokens with matching admin key\n+-   `/api/v1/tokens?account.id=0.0.8` - All tokens for matching account\n+\n+### Token Info\n+-   Add a `getTokenInfo()` to `tokens.js` to retrieve token info from `token` table\n+```json\n+    {\n+      \"token\": \"FOOCOIN\",\n+      \"tokenId\": \"0.15.10\",\n+      \"treasury_account\": \"0.15.10\",\n+      \"adminKey\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"kycKey\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"freezeKey\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"wipeKey\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"supplyKey\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"freezeDefault\": false,\n+      \"kycDefault\": false,\n+      \"expiryTimestamp\": null,\n+      \"autoRenewAccount\": \"0.0.6\",\n+      \"autoRenewPeriod\": null\n+    }\n+```\n+\n+\n+## Protobuf\n+\n+```proto\n+    message TokenQuery {\n+        .proto.TokenID tokenID = 1; // The token ID to retrieve transfers for", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg2Mjc3MA=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 615}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NDUxNDM1OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNjoxMjo1MFrOHWB_TA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxNjoyNzo0NVrOHW2ykQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg2MzMwOA==", "bodyText": "Why are we returning the key here instead of the detailed list? The other keys are returned in the detailed response.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492863308", "createdAt": "2020-09-22T16:12:50Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"token\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"token\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"token\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+To achieve this\n+-   Update `balances.js` `getBalances()` to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"token\":\"FOOBAR\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.1111\", \"amount\": -10},\n+                {\"account\": \"0.0.2222\", \"amount\": 10}\n+              ]\n+            },\n+            {\n+              \"token\":\"FOOCOIN\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.3333\", \"amount\": -10},\n+                {\"account\": \"0.0.4444\", \"amount\": 10}\n+               ]\n+            }\n+          ]\n+        }\n+      ]\n+    }\n+```\n+\n+To achieve this\n+-   Update `transactions.js` sql queries for `crypto_transfer` to pull the `token_id` and `token` columns\n+-   Update `createTransferLists()` in `transactions.js` to build a `tokenTransfers` list if `token` isn't HBAR or if `token_id` is empty\n+\n+\n+### Token Supply distribution\n+\n+`/api/v1/tokens/<token>/balances` this could be the equivalent of `/api/v1/balances?token=<token>` currently and would return a list of account and the token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokenBalances\": [\n+          {\n+            \"account\": \"0.15.10\",\n+            \"balance\": 100\n+          },\n+          {\n+            \"account\": \"0.15.9\",\n+            \"balance\": 90\n+          },\n+          {\n+            \"account\": \"0.15.8\",\n+            \"balance\": 80\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+To achieve this similar to balances\n+-   Create a `tokenBalance.js`\n+-   Add a `getTokenBalances()` which based on the time range provided (default to latest timestamp) and `tokenId` pulls out `account_id` and `balance` values from `token_balance` and returns them as an element in `tokenBalances` array.\n+\n+```sql\n+    select account_id, balance from token_balance where token_id = ? and consensus_timestamp = (select max(consensus_timestamp) from token_balance);\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens/<token>/balances?id=0.0.1000`\n+-   `/api/v1/tokens/<token>/balances?balance=gt:1000`\n+-   `/api/v1/tokens/<token>/balances?timestamp=1566562500.040961001`\n+\n+### Token Discovery\n+`/api/v1/tokens` this would return all tokens present on the network\n+\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokens\": [\n+          {\n+            \"token\": \"FOOBAR\",\n+            \"tokenId\": \"0.15.10\",\n+            \"key\": {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 543}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA5MDQxOA==", "bodyText": "Design request seemed to want admin key as part of discoverability, can circle back", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r493090418", "createdAt": "2020-09-22T23:33:52Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"token\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"token\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"token\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+To achieve this\n+-   Update `balances.js` `getBalances()` to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"token\":\"FOOBAR\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.1111\", \"amount\": -10},\n+                {\"account\": \"0.0.2222\", \"amount\": 10}\n+              ]\n+            },\n+            {\n+              \"token\":\"FOOCOIN\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.3333\", \"amount\": -10},\n+                {\"account\": \"0.0.4444\", \"amount\": 10}\n+               ]\n+            }\n+          ]\n+        }\n+      ]\n+    }\n+```\n+\n+To achieve this\n+-   Update `transactions.js` sql queries for `crypto_transfer` to pull the `token_id` and `token` columns\n+-   Update `createTransferLists()` in `transactions.js` to build a `tokenTransfers` list if `token` isn't HBAR or if `token_id` is empty\n+\n+\n+### Token Supply distribution\n+\n+`/api/v1/tokens/<token>/balances` this could be the equivalent of `/api/v1/balances?token=<token>` currently and would return a list of account and the token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokenBalances\": [\n+          {\n+            \"account\": \"0.15.10\",\n+            \"balance\": 100\n+          },\n+          {\n+            \"account\": \"0.15.9\",\n+            \"balance\": 90\n+          },\n+          {\n+            \"account\": \"0.15.8\",\n+            \"balance\": 80\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+To achieve this similar to balances\n+-   Create a `tokenBalance.js`\n+-   Add a `getTokenBalances()` which based on the time range provided (default to latest timestamp) and `tokenId` pulls out `account_id` and `balance` values from `token_balance` and returns them as an element in `tokenBalances` array.\n+\n+```sql\n+    select account_id, balance from token_balance where token_id = ? and consensus_timestamp = (select max(consensus_timestamp) from token_balance);\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens/<token>/balances?id=0.0.1000`\n+-   `/api/v1/tokens/<token>/balances?balance=gt:1000`\n+-   `/api/v1/tokens/<token>/balances?timestamp=1566562500.040961001`\n+\n+### Token Discovery\n+`/api/v1/tokens` this would return all tokens present on the network\n+\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokens\": [\n+          {\n+            \"token\": \"FOOBAR\",\n+            \"tokenId\": \"0.15.10\",\n+            \"key\": {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg2MzMwOA=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 543}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzcyODQwMQ==", "bodyText": "Yep per design request\n\nA client application can call an API to return all tokens issued\nReturns token name, symbol, and admin key\nCan also be specified by admin key(s)", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r493728401", "createdAt": "2020-09-23T16:27:45Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"token\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"token\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"token\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+To achieve this\n+-   Update `balances.js` `getBalances()` to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"token\":\"FOOBAR\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.1111\", \"amount\": -10},\n+                {\"account\": \"0.0.2222\", \"amount\": 10}\n+              ]\n+            },\n+            {\n+              \"token\":\"FOOCOIN\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.3333\", \"amount\": -10},\n+                {\"account\": \"0.0.4444\", \"amount\": 10}\n+               ]\n+            }\n+          ]\n+        }\n+      ]\n+    }\n+```\n+\n+To achieve this\n+-   Update `transactions.js` sql queries for `crypto_transfer` to pull the `token_id` and `token` columns\n+-   Update `createTransferLists()` in `transactions.js` to build a `tokenTransfers` list if `token` isn't HBAR or if `token_id` is empty\n+\n+\n+### Token Supply distribution\n+\n+`/api/v1/tokens/<token>/balances` this could be the equivalent of `/api/v1/balances?token=<token>` currently and would return a list of account and the token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokenBalances\": [\n+          {\n+            \"account\": \"0.15.10\",\n+            \"balance\": 100\n+          },\n+          {\n+            \"account\": \"0.15.9\",\n+            \"balance\": 90\n+          },\n+          {\n+            \"account\": \"0.15.8\",\n+            \"balance\": 80\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+To achieve this similar to balances\n+-   Create a `tokenBalance.js`\n+-   Add a `getTokenBalances()` which based on the time range provided (default to latest timestamp) and `tokenId` pulls out `account_id` and `balance` values from `token_balance` and returns them as an element in `tokenBalances` array.\n+\n+```sql\n+    select account_id, balance from token_balance where token_id = ? and consensus_timestamp = (select max(consensus_timestamp) from token_balance);\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens/<token>/balances?id=0.0.1000`\n+-   `/api/v1/tokens/<token>/balances?balance=gt:1000`\n+-   `/api/v1/tokens/<token>/balances?timestamp=1566562500.040961001`\n+\n+### Token Discovery\n+`/api/v1/tokens` this would return all tokens present on the network\n+\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokens\": [\n+          {\n+            \"token\": \"FOOBAR\",\n+            \"tokenId\": \"0.15.10\",\n+            \"key\": {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg2MzMwOA=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 543}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NDY5MTgzOnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNjo1NjoxOFrOHWDt-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMzo1MjoyOFrOHWQM7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg5MTY0Mg==", "bodyText": "Start proto_id is wrong. Should start from 28 and increment\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    (56, 'TOKENCREATE'),\n          \n          \n            \n                   (28, `UNCHECKEDSUBMIT'),\n          \n          \n            \n                    (29, 'TOKENCREATE'),", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492891642", "createdAt": "2020-09-22T16:56:18Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA5NjE3Mg==", "bodyText": "Updated", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r493096172", "createdAt": "2020-09-22T23:52:28Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg5MTY0Mg=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NDY5NDU1OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNjo1NzowMVrOHWDvrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMzo1MjoyNFrOHWQM2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg5MjA3Nw==", "bodyText": "Remove\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    (58, 'TOKENGETINFO'),", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492892077", "createdAt": "2020-09-22T16:57:01Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA5NjE1Mg==", "bodyText": "Updated", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r493096152", "createdAt": "2020-09-22T23:52:24Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg5MjA3Nw=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NDY5NTYxOnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNjo1NzoxOFrOHWDwYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMzo1MjoxOVrOHWQMww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg5MjI1OA==", "bodyText": "Remove ACCOUNT from names\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    (59, 'TOKENFREEZEACCOUNT'),\n          \n          \n            \n                    (31, 'TOKENFREEZE'),", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492892258", "createdAt": "2020-09-22T16:57:18Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA5NjEzMQ==", "bodyText": "Updated", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r493096131", "createdAt": "2020-09-22T23:52:19Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg5MjI1OA=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NDkwMTA4OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNzo1MDoxOFrOHWFuQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwMzoyNDoyNFrOHXzqXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjkyNDQ4Mw==", "bodyText": "tokens", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492924483", "createdAt": "2020-09-22T17:50:18Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 364}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA5NTgyNg==", "bodyText": "Updated", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r493095826", "createdAt": "2020-09-22T23:51:17Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjkyNDQ4Mw=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 364}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU1MDI5MQ==", "bodyText": "This doesn't seem to have changed.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494550291", "createdAt": "2020-09-24T19:09:07Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjkyNDQ4Mw=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 364}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDcyNTcyNg==", "bodyText": "Updated", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494725726", "createdAt": "2020-09-25T03:24:24Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjkyNDQ4Mw=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 364}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NTA1NzI1OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxODoyODo0M1rOHXndjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxODoyODo0M1rOHXndjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUyNTgzNg==", "bodyText": "Was changed to\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                -   `create_timestamp`\n          \n          \n            \n                -   `created_timestamp`", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494525836", "createdAt": "2020-09-24T18:28:43Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,631 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members\n+    -   `account_id`\n+    -   `amount`\n+    -   `consensus_timestamp`\n+    -   `token_id`\n+-   Add a `token_transfer__token_account_timestamp` index with `desc` order on columns\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances with the following columns\n+    -   `consensus_timestamp`\n+    -   `account_id`\n+    -   `balance`\n+    -   `token_id`\n+-   Create primary key as combination of `consensus_timestamp`, `token_id` and `account_id`\n+\n+### Token Account Info\n+-   Create `token_account` table to distinctly capture token account metadata changes with the following columns\n+    -   `id` (primary key)\n+    -   `account_id`\n+    -   `create_timestamp`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NTA1ODk4OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxODoyOTowMFrOHXnesg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxODoyOTowMFrOHXnesg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUyNjEzMA==", "bodyText": "Was changed to\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                -   `modify_timestamp`\n          \n          \n            \n                -   `modified_timestamp`", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494526130", "createdAt": "2020-09-24T18:29:00Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,631 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members\n+    -   `account_id`\n+    -   `amount`\n+    -   `consensus_timestamp`\n+    -   `token_id`\n+-   Add a `token_transfer__token_account_timestamp` index with `desc` order on columns\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances with the following columns\n+    -   `consensus_timestamp`\n+    -   `account_id`\n+    -   `balance`\n+    -   `token_id`\n+-   Create primary key as combination of `consensus_timestamp`, `token_id` and `account_id`\n+\n+### Token Account Info\n+-   Create `token_account` table to distinctly capture token account metadata changes with the following columns\n+    -   `id` (primary key)\n+    -   `account_id`\n+    -   `create_timestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modify_timestamp`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NTA2MzgxOnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxODoyOTo1MVrOHXnhsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxODoyOTo1MVrOHXnhsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUyNjg5OQ==", "bodyText": "Was changed to\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                -   `create_timestamp`\n          \n          \n            \n                -   `created_timestamp`", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494526899", "createdAt": "2020-09-24T18:29:51Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,631 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members\n+    -   `account_id`\n+    -   `amount`\n+    -   `consensus_timestamp`\n+    -   `token_id`\n+-   Add a `token_transfer__token_account_timestamp` index with `desc` order on columns\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances with the following columns\n+    -   `consensus_timestamp`\n+    -   `account_id`\n+    -   `balance`\n+    -   `token_id`\n+-   Create primary key as combination of `consensus_timestamp`, `token_id` and `account_id`\n+\n+### Token Account Info\n+-   Create `token_account` table to distinctly capture token account metadata changes with the following columns\n+    -   `id` (primary key)\n+    -   `account_id`\n+    -   `create_timestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modify_timestamp`\n+    -   `token_id`\n+    -   `wiped`\n+-   Create unique index `token_account__token_account`\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with `id` value of 5 and `name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+         (28, 'UNCHECKEDSUBMIT'),\n+         (29, 'TOKENCREATE'),\n+         (30, 'TOKENTRANSFER'),\n+         (31, 'TOKENFREEZE'),\n+         (32, 'TOKENUNFREEZE'),\n+         (33, 'TOKENGRANTKYC'),\n+         (34, 'TOKENREVOKEKYC'),\n+         (35, 'TOKENDELETE'),\n+         (36, 'TOKENUPDATE'),\n+         (37, 'TOKENMINT'),\n+         (38, 'TOKENBURN'),\n+         (39, 'TOKENWIPE'),\n+         (40, 'TOKENASSOCIATE'),\n+         (41, 'TOKENDISSOCIATE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP'),\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT'),\n+        (188, 'INVALID_KYC_KEY'),\n+        (189, 'INVALID_WIPE_KEY'),\n+        (190, 'INVALID_FREEZE_KEY'),\n+        (191, 'INVALID_SUPPLY_KEY'),\n+        (192, 'TOKEN_NAME_ALREADY_IN_USE'),\n+        (193, 'MISSING_TOKEN_NAME'),\n+        (194, 'TOKEN_NAME_TOO_LONG'),\n+        (195, 'INVALID_WIPING_AMOUNT'),\n+        (196, 'TOKEN_IS_IMMUTABlE'),\n+        (197, 'TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table with the following columns. Table will capture non shared `entity` items, most API calls may not require this information and therefore additional sql joins may be avoided.\n+    -   `token_id` (primary key)\n+    -   `create_timestamp`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NTA2NjMxOnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxODozMDoxNFrOHXnjFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxODozMDoxNFrOHXnjFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUyNzI1Mg==", "bodyText": "Was changed to\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                -   `modify_timestamp`\n          \n          \n            \n                -   `modified_timestamp`", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494527252", "createdAt": "2020-09-24T18:30:14Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,631 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members\n+    -   `account_id`\n+    -   `amount`\n+    -   `consensus_timestamp`\n+    -   `token_id`\n+-   Add a `token_transfer__token_account_timestamp` index with `desc` order on columns\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances with the following columns\n+    -   `consensus_timestamp`\n+    -   `account_id`\n+    -   `balance`\n+    -   `token_id`\n+-   Create primary key as combination of `consensus_timestamp`, `token_id` and `account_id`\n+\n+### Token Account Info\n+-   Create `token_account` table to distinctly capture token account metadata changes with the following columns\n+    -   `id` (primary key)\n+    -   `account_id`\n+    -   `create_timestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modify_timestamp`\n+    -   `token_id`\n+    -   `wiped`\n+-   Create unique index `token_account__token_account`\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with `id` value of 5 and `name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+         (28, 'UNCHECKEDSUBMIT'),\n+         (29, 'TOKENCREATE'),\n+         (30, 'TOKENTRANSFER'),\n+         (31, 'TOKENFREEZE'),\n+         (32, 'TOKENUNFREEZE'),\n+         (33, 'TOKENGRANTKYC'),\n+         (34, 'TOKENREVOKEKYC'),\n+         (35, 'TOKENDELETE'),\n+         (36, 'TOKENUPDATE'),\n+         (37, 'TOKENMINT'),\n+         (38, 'TOKENBURN'),\n+         (39, 'TOKENWIPE'),\n+         (40, 'TOKENASSOCIATE'),\n+         (41, 'TOKENDISSOCIATE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP'),\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT'),\n+        (188, 'INVALID_KYC_KEY'),\n+        (189, 'INVALID_WIPE_KEY'),\n+        (190, 'INVALID_FREEZE_KEY'),\n+        (191, 'INVALID_SUPPLY_KEY'),\n+        (192, 'TOKEN_NAME_ALREADY_IN_USE'),\n+        (193, 'MISSING_TOKEN_NAME'),\n+        (194, 'TOKEN_NAME_TOO_LONG'),\n+        (195, 'INVALID_WIPING_AMOUNT'),\n+        (196, 'TOKEN_IS_IMMUTABlE'),\n+        (197, 'TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table with the following columns. Table will capture non shared `entity` items, most API calls may not require this information and therefore additional sql joins may be avoided.\n+    -   `token_id` (primary key)\n+    -   `create_timestamp`\n+    -   `divisibility`\n+    -   `freeze_default`\n+    -   `freeze_key`\n+    -   `initial_supply`\n+    -   `kyc_default`\n+    -   `kyc_key`\n+    -   `modify_timestamp`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NTA2OTcwOnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxODozMDo0MlrOHXnlFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxODozMDo0MlrOHXnlFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUyNzc2NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                -   `modifyTimestamp`\n          \n          \n            \n                -   `modifiedTimestamp`", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494527764", "createdAt": "2020-09-24T18:30:42Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,631 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members\n+    -   `account_id`\n+    -   `amount`\n+    -   `consensus_timestamp`\n+    -   `token_id`\n+-   Add a `token_transfer__token_account_timestamp` index with `desc` order on columns\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances with the following columns\n+    -   `consensus_timestamp`\n+    -   `account_id`\n+    -   `balance`\n+    -   `token_id`\n+-   Create primary key as combination of `consensus_timestamp`, `token_id` and `account_id`\n+\n+### Token Account Info\n+-   Create `token_account` table to distinctly capture token account metadata changes with the following columns\n+    -   `id` (primary key)\n+    -   `account_id`\n+    -   `create_timestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modify_timestamp`\n+    -   `token_id`\n+    -   `wiped`\n+-   Create unique index `token_account__token_account`\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with `id` value of 5 and `name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+         (28, 'UNCHECKEDSUBMIT'),\n+         (29, 'TOKENCREATE'),\n+         (30, 'TOKENTRANSFER'),\n+         (31, 'TOKENFREEZE'),\n+         (32, 'TOKENUNFREEZE'),\n+         (33, 'TOKENGRANTKYC'),\n+         (34, 'TOKENREVOKEKYC'),\n+         (35, 'TOKENDELETE'),\n+         (36, 'TOKENUPDATE'),\n+         (37, 'TOKENMINT'),\n+         (38, 'TOKENBURN'),\n+         (39, 'TOKENWIPE'),\n+         (40, 'TOKENASSOCIATE'),\n+         (41, 'TOKENDISSOCIATE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP'),\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT'),\n+        (188, 'INVALID_KYC_KEY'),\n+        (189, 'INVALID_WIPE_KEY'),\n+        (190, 'INVALID_FREEZE_KEY'),\n+        (191, 'INVALID_SUPPLY_KEY'),\n+        (192, 'TOKEN_NAME_ALREADY_IN_USE'),\n+        (193, 'MISSING_TOKEN_NAME'),\n+        (194, 'TOKEN_NAME_TOO_LONG'),\n+        (195, 'INVALID_WIPING_AMOUNT'),\n+        (196, 'TOKEN_IS_IMMUTABlE'),\n+        (197, 'TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table with the following columns. Table will capture non shared `entity` items, most API calls may not require this information and therefore additional sql joins may be avoided.\n+    -   `token_id` (primary key)\n+    -   `create_timestamp`\n+    -   `divisibility`\n+    -   `freeze_default`\n+    -   `freeze_key`\n+    -   `initial_supply`\n+    -   `kyc_default`\n+    -   `kyc_key`\n+    -   `modify_timestamp`\n+    -   `supply_key`\n+    -   `symbol`\n+    -   `treasury_account_id`\n+    -   `wipe_key`\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+#### AccountBalance\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+#### TokenTransfer\n+-   Create new `TokenTransfer` with the following class members\n+    -   `accountId`\n+    -   `amount`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+#### EntityTypeEnum\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+        ...\n+        TOKEN(5);\n+        ...\n+    }\n+```\n+\n+#### Token\n+-   Add `Token` class to hold Token specific metadata outside of the base entity class with the following class members\n+    -   `createTimestamp`\n+    -   `divisibility`\n+    -   `freezeDefault`\n+    -   `freezeKey`\n+    -   `initialSupply`\n+    -   `kycDefault`\n+    -   `kycKey`\n+    -   `modifyTimestamp`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "originalPosition": 219}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NTA3MDYyOnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxODozMDo1MlrOHXnlyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxODozMDo1MlrOHXnlyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUyNzk0Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                -   `createTimestamp`\n          \n          \n            \n                -   `createdTimestamp`", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494527946", "createdAt": "2020-09-24T18:30:52Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,631 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members\n+    -   `account_id`\n+    -   `amount`\n+    -   `consensus_timestamp`\n+    -   `token_id`\n+-   Add a `token_transfer__token_account_timestamp` index with `desc` order on columns\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances with the following columns\n+    -   `consensus_timestamp`\n+    -   `account_id`\n+    -   `balance`\n+    -   `token_id`\n+-   Create primary key as combination of `consensus_timestamp`, `token_id` and `account_id`\n+\n+### Token Account Info\n+-   Create `token_account` table to distinctly capture token account metadata changes with the following columns\n+    -   `id` (primary key)\n+    -   `account_id`\n+    -   `create_timestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modify_timestamp`\n+    -   `token_id`\n+    -   `wiped`\n+-   Create unique index `token_account__token_account`\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with `id` value of 5 and `name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+         (28, 'UNCHECKEDSUBMIT'),\n+         (29, 'TOKENCREATE'),\n+         (30, 'TOKENTRANSFER'),\n+         (31, 'TOKENFREEZE'),\n+         (32, 'TOKENUNFREEZE'),\n+         (33, 'TOKENGRANTKYC'),\n+         (34, 'TOKENREVOKEKYC'),\n+         (35, 'TOKENDELETE'),\n+         (36, 'TOKENUPDATE'),\n+         (37, 'TOKENMINT'),\n+         (38, 'TOKENBURN'),\n+         (39, 'TOKENWIPE'),\n+         (40, 'TOKENASSOCIATE'),\n+         (41, 'TOKENDISSOCIATE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP'),\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT'),\n+        (188, 'INVALID_KYC_KEY'),\n+        (189, 'INVALID_WIPE_KEY'),\n+        (190, 'INVALID_FREEZE_KEY'),\n+        (191, 'INVALID_SUPPLY_KEY'),\n+        (192, 'TOKEN_NAME_ALREADY_IN_USE'),\n+        (193, 'MISSING_TOKEN_NAME'),\n+        (194, 'TOKEN_NAME_TOO_LONG'),\n+        (195, 'INVALID_WIPING_AMOUNT'),\n+        (196, 'TOKEN_IS_IMMUTABlE'),\n+        (197, 'TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table with the following columns. Table will capture non shared `entity` items, most API calls may not require this information and therefore additional sql joins may be avoided.\n+    -   `token_id` (primary key)\n+    -   `create_timestamp`\n+    -   `divisibility`\n+    -   `freeze_default`\n+    -   `freeze_key`\n+    -   `initial_supply`\n+    -   `kyc_default`\n+    -   `kyc_key`\n+    -   `modify_timestamp`\n+    -   `supply_key`\n+    -   `symbol`\n+    -   `treasury_account_id`\n+    -   `wipe_key`\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+#### AccountBalance\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+#### TokenTransfer\n+-   Create new `TokenTransfer` with the following class members\n+    -   `accountId`\n+    -   `amount`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+#### EntityTypeEnum\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+        ...\n+        TOKEN(5);\n+        ...\n+    }\n+```\n+\n+#### Token\n+-   Add `Token` class to hold Token specific metadata outside of the base entity class with the following class members\n+    -   `createTimestamp`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "originalPosition": 212}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NTA3MTMyOnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxODozMDo1OVrOHXnmUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxODozMDo1OVrOHXnmUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUyODA4Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                -   `createTimestamp`\n          \n          \n            \n                -   `createdTimestamp`", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494528083", "createdAt": "2020-09-24T18:30:59Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,631 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members\n+    -   `account_id`\n+    -   `amount`\n+    -   `consensus_timestamp`\n+    -   `token_id`\n+-   Add a `token_transfer__token_account_timestamp` index with `desc` order on columns\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances with the following columns\n+    -   `consensus_timestamp`\n+    -   `account_id`\n+    -   `balance`\n+    -   `token_id`\n+-   Create primary key as combination of `consensus_timestamp`, `token_id` and `account_id`\n+\n+### Token Account Info\n+-   Create `token_account` table to distinctly capture token account metadata changes with the following columns\n+    -   `id` (primary key)\n+    -   `account_id`\n+    -   `create_timestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modify_timestamp`\n+    -   `token_id`\n+    -   `wiped`\n+-   Create unique index `token_account__token_account`\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with `id` value of 5 and `name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+         (28, 'UNCHECKEDSUBMIT'),\n+         (29, 'TOKENCREATE'),\n+         (30, 'TOKENTRANSFER'),\n+         (31, 'TOKENFREEZE'),\n+         (32, 'TOKENUNFREEZE'),\n+         (33, 'TOKENGRANTKYC'),\n+         (34, 'TOKENREVOKEKYC'),\n+         (35, 'TOKENDELETE'),\n+         (36, 'TOKENUPDATE'),\n+         (37, 'TOKENMINT'),\n+         (38, 'TOKENBURN'),\n+         (39, 'TOKENWIPE'),\n+         (40, 'TOKENASSOCIATE'),\n+         (41, 'TOKENDISSOCIATE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP'),\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT'),\n+        (188, 'INVALID_KYC_KEY'),\n+        (189, 'INVALID_WIPE_KEY'),\n+        (190, 'INVALID_FREEZE_KEY'),\n+        (191, 'INVALID_SUPPLY_KEY'),\n+        (192, 'TOKEN_NAME_ALREADY_IN_USE'),\n+        (193, 'MISSING_TOKEN_NAME'),\n+        (194, 'TOKEN_NAME_TOO_LONG'),\n+        (195, 'INVALID_WIPING_AMOUNT'),\n+        (196, 'TOKEN_IS_IMMUTABlE'),\n+        (197, 'TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table with the following columns. Table will capture non shared `entity` items, most API calls may not require this information and therefore additional sql joins may be avoided.\n+    -   `token_id` (primary key)\n+    -   `create_timestamp`\n+    -   `divisibility`\n+    -   `freeze_default`\n+    -   `freeze_key`\n+    -   `initial_supply`\n+    -   `kyc_default`\n+    -   `kyc_key`\n+    -   `modify_timestamp`\n+    -   `supply_key`\n+    -   `symbol`\n+    -   `treasury_account_id`\n+    -   `wipe_key`\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+#### AccountBalance\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+#### TokenTransfer\n+-   Create new `TokenTransfer` with the following class members\n+    -   `accountId`\n+    -   `amount`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+#### EntityTypeEnum\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+        ...\n+        TOKEN(5);\n+        ...\n+    }\n+```\n+\n+#### Token\n+-   Add `Token` class to hold Token specific metadata outside of the base entity class with the following class members\n+    -   `createTimestamp`\n+    -   `divisibility`\n+    -   `freezeDefault`\n+    -   `freezeKey`\n+    -   `initialSupply`\n+    -   `kycDefault`\n+    -   `kycKey`\n+    -   `modifyTimestamp`\n+    -   `supplyKey`\n+    -   `symbol`\n+    -   `tokenId`\n+    -   `treasuryAccountId`\n+    -   `wipeKey`\n+\n+#### TokenAccount\n+-   Add `TokenAccount` class with the following class members\n+    -   `id`\n+    -   `accountId`\n+    -   `createTimestamp`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "originalPosition": 230}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NTA3MjM3OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxODozMTowOFrOHXnm9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxODozMTowOFrOHXnm9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUyODI0NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                -   `modifyTimestamp`\n          \n          \n            \n                -   `modifiedTimestamp`", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494528244", "createdAt": "2020-09-24T18:31:08Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,631 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members\n+    -   `account_id`\n+    -   `amount`\n+    -   `consensus_timestamp`\n+    -   `token_id`\n+-   Add a `token_transfer__token_account_timestamp` index with `desc` order on columns\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances with the following columns\n+    -   `consensus_timestamp`\n+    -   `account_id`\n+    -   `balance`\n+    -   `token_id`\n+-   Create primary key as combination of `consensus_timestamp`, `token_id` and `account_id`\n+\n+### Token Account Info\n+-   Create `token_account` table to distinctly capture token account metadata changes with the following columns\n+    -   `id` (primary key)\n+    -   `account_id`\n+    -   `create_timestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modify_timestamp`\n+    -   `token_id`\n+    -   `wiped`\n+-   Create unique index `token_account__token_account`\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with `id` value of 5 and `name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+         (28, 'UNCHECKEDSUBMIT'),\n+         (29, 'TOKENCREATE'),\n+         (30, 'TOKENTRANSFER'),\n+         (31, 'TOKENFREEZE'),\n+         (32, 'TOKENUNFREEZE'),\n+         (33, 'TOKENGRANTKYC'),\n+         (34, 'TOKENREVOKEKYC'),\n+         (35, 'TOKENDELETE'),\n+         (36, 'TOKENUPDATE'),\n+         (37, 'TOKENMINT'),\n+         (38, 'TOKENBURN'),\n+         (39, 'TOKENWIPE'),\n+         (40, 'TOKENASSOCIATE'),\n+         (41, 'TOKENDISSOCIATE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP'),\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT'),\n+        (188, 'INVALID_KYC_KEY'),\n+        (189, 'INVALID_WIPE_KEY'),\n+        (190, 'INVALID_FREEZE_KEY'),\n+        (191, 'INVALID_SUPPLY_KEY'),\n+        (192, 'TOKEN_NAME_ALREADY_IN_USE'),\n+        (193, 'MISSING_TOKEN_NAME'),\n+        (194, 'TOKEN_NAME_TOO_LONG'),\n+        (195, 'INVALID_WIPING_AMOUNT'),\n+        (196, 'TOKEN_IS_IMMUTABlE'),\n+        (197, 'TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table with the following columns. Table will capture non shared `entity` items, most API calls may not require this information and therefore additional sql joins may be avoided.\n+    -   `token_id` (primary key)\n+    -   `create_timestamp`\n+    -   `divisibility`\n+    -   `freeze_default`\n+    -   `freeze_key`\n+    -   `initial_supply`\n+    -   `kyc_default`\n+    -   `kyc_key`\n+    -   `modify_timestamp`\n+    -   `supply_key`\n+    -   `symbol`\n+    -   `treasury_account_id`\n+    -   `wipe_key`\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+#### AccountBalance\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+#### TokenTransfer\n+-   Create new `TokenTransfer` with the following class members\n+    -   `accountId`\n+    -   `amount`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+#### EntityTypeEnum\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+        ...\n+        TOKEN(5);\n+        ...\n+    }\n+```\n+\n+#### Token\n+-   Add `Token` class to hold Token specific metadata outside of the base entity class with the following class members\n+    -   `createTimestamp`\n+    -   `divisibility`\n+    -   `freezeDefault`\n+    -   `freezeKey`\n+    -   `initialSupply`\n+    -   `kycDefault`\n+    -   `kycKey`\n+    -   `modifyTimestamp`\n+    -   `supplyKey`\n+    -   `symbol`\n+    -   `tokenId`\n+    -   `treasuryAccountId`\n+    -   `wipeKey`\n+\n+#### TokenAccount\n+-   Add `TokenAccount` class with the following class members\n+    -   `id`\n+    -   `accountId`\n+    -   `createTimestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modifyTimestamp`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "originalPosition": 233}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NTA3NDAxOnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxODozMToyNVrOHXnoBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxODozMToyNVrOHXnoBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUyODUxOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            2. Comments out the Timestamp e.g. `TimeStamp:2020-09-22T04:25:00.083212003Z`\n          \n          \n            \n            2. Comments out the Timestamp e.g. `# TimeStamp:2020-09-22T04:25:00.083212003Z`", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494528518", "createdAt": "2020-09-24T18:31:25Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,631 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members\n+    -   `account_id`\n+    -   `amount`\n+    -   `consensus_timestamp`\n+    -   `token_id`\n+-   Add a `token_transfer__token_account_timestamp` index with `desc` order on columns\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances with the following columns\n+    -   `consensus_timestamp`\n+    -   `account_id`\n+    -   `balance`\n+    -   `token_id`\n+-   Create primary key as combination of `consensus_timestamp`, `token_id` and `account_id`\n+\n+### Token Account Info\n+-   Create `token_account` table to distinctly capture token account metadata changes with the following columns\n+    -   `id` (primary key)\n+    -   `account_id`\n+    -   `create_timestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modify_timestamp`\n+    -   `token_id`\n+    -   `wiped`\n+-   Create unique index `token_account__token_account`\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with `id` value of 5 and `name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+         (28, 'UNCHECKEDSUBMIT'),\n+         (29, 'TOKENCREATE'),\n+         (30, 'TOKENTRANSFER'),\n+         (31, 'TOKENFREEZE'),\n+         (32, 'TOKENUNFREEZE'),\n+         (33, 'TOKENGRANTKYC'),\n+         (34, 'TOKENREVOKEKYC'),\n+         (35, 'TOKENDELETE'),\n+         (36, 'TOKENUPDATE'),\n+         (37, 'TOKENMINT'),\n+         (38, 'TOKENBURN'),\n+         (39, 'TOKENWIPE'),\n+         (40, 'TOKENASSOCIATE'),\n+         (41, 'TOKENDISSOCIATE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP'),\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT'),\n+        (188, 'INVALID_KYC_KEY'),\n+        (189, 'INVALID_WIPE_KEY'),\n+        (190, 'INVALID_FREEZE_KEY'),\n+        (191, 'INVALID_SUPPLY_KEY'),\n+        (192, 'TOKEN_NAME_ALREADY_IN_USE'),\n+        (193, 'MISSING_TOKEN_NAME'),\n+        (194, 'TOKEN_NAME_TOO_LONG'),\n+        (195, 'INVALID_WIPING_AMOUNT'),\n+        (196, 'TOKEN_IS_IMMUTABlE'),\n+        (197, 'TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table with the following columns. Table will capture non shared `entity` items, most API calls may not require this information and therefore additional sql joins may be avoided.\n+    -   `token_id` (primary key)\n+    -   `create_timestamp`\n+    -   `divisibility`\n+    -   `freeze_default`\n+    -   `freeze_key`\n+    -   `initial_supply`\n+    -   `kyc_default`\n+    -   `kyc_key`\n+    -   `modify_timestamp`\n+    -   `supply_key`\n+    -   `symbol`\n+    -   `treasury_account_id`\n+    -   `wipe_key`\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+#### AccountBalance\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+#### TokenTransfer\n+-   Create new `TokenTransfer` with the following class members\n+    -   `accountId`\n+    -   `amount`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+#### EntityTypeEnum\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+        ...\n+        TOKEN(5);\n+        ...\n+    }\n+```\n+\n+#### Token\n+-   Add `Token` class to hold Token specific metadata outside of the base entity class with the following class members\n+    -   `createTimestamp`\n+    -   `divisibility`\n+    -   `freezeDefault`\n+    -   `freezeKey`\n+    -   `initialSupply`\n+    -   `kycDefault`\n+    -   `kycKey`\n+    -   `modifyTimestamp`\n+    -   `supplyKey`\n+    -   `symbol`\n+    -   `tokenId`\n+    -   `treasuryAccountId`\n+    -   `wipeKey`\n+\n+#### TokenAccount\n+-   Add `TokenAccount` class with the following class members\n+    -   `id`\n+    -   `accountId`\n+    -   `createTimestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modifyTimestamp`\n+    -   `tokenId`\n+    -   `wiped`\n+\n+#### TokenBalance\n+-   Add `TokenBalance` class with the following class members\n+    -   `accountId`\n+    -   `balance`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+### Balance Parsing\n+To support HTS the balance CSV\n+1. Adds a version comment as the first line of the file i.e. `# version:2`\n+2. Comments out the Timestamp e.g. `TimeStamp:2020-09-22T04:25:00.083212003Z`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "originalPosition": 247}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NTA4MDY0OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxODozMjoyNFrOHXnsSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxODozMjoyNFrOHXnsSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUyOTYxMQ==", "bodyText": "Will be changed to tokenId\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                          \"symbol\": \"FOOBAR\",\n          \n          \n            \n                          \"token_id\": \"0.1.2\",", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494529611", "createdAt": "2020-09-24T18:32:24Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,631 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members\n+    -   `account_id`\n+    -   `amount`\n+    -   `consensus_timestamp`\n+    -   `token_id`\n+-   Add a `token_transfer__token_account_timestamp` index with `desc` order on columns\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances with the following columns\n+    -   `consensus_timestamp`\n+    -   `account_id`\n+    -   `balance`\n+    -   `token_id`\n+-   Create primary key as combination of `consensus_timestamp`, `token_id` and `account_id`\n+\n+### Token Account Info\n+-   Create `token_account` table to distinctly capture token account metadata changes with the following columns\n+    -   `id` (primary key)\n+    -   `account_id`\n+    -   `create_timestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modify_timestamp`\n+    -   `token_id`\n+    -   `wiped`\n+-   Create unique index `token_account__token_account`\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with `id` value of 5 and `name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+         (28, 'UNCHECKEDSUBMIT'),\n+         (29, 'TOKENCREATE'),\n+         (30, 'TOKENTRANSFER'),\n+         (31, 'TOKENFREEZE'),\n+         (32, 'TOKENUNFREEZE'),\n+         (33, 'TOKENGRANTKYC'),\n+         (34, 'TOKENREVOKEKYC'),\n+         (35, 'TOKENDELETE'),\n+         (36, 'TOKENUPDATE'),\n+         (37, 'TOKENMINT'),\n+         (38, 'TOKENBURN'),\n+         (39, 'TOKENWIPE'),\n+         (40, 'TOKENASSOCIATE'),\n+         (41, 'TOKENDISSOCIATE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP'),\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT'),\n+        (188, 'INVALID_KYC_KEY'),\n+        (189, 'INVALID_WIPE_KEY'),\n+        (190, 'INVALID_FREEZE_KEY'),\n+        (191, 'INVALID_SUPPLY_KEY'),\n+        (192, 'TOKEN_NAME_ALREADY_IN_USE'),\n+        (193, 'MISSING_TOKEN_NAME'),\n+        (194, 'TOKEN_NAME_TOO_LONG'),\n+        (195, 'INVALID_WIPING_AMOUNT'),\n+        (196, 'TOKEN_IS_IMMUTABlE'),\n+        (197, 'TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table with the following columns. Table will capture non shared `entity` items, most API calls may not require this information and therefore additional sql joins may be avoided.\n+    -   `token_id` (primary key)\n+    -   `create_timestamp`\n+    -   `divisibility`\n+    -   `freeze_default`\n+    -   `freeze_key`\n+    -   `initial_supply`\n+    -   `kyc_default`\n+    -   `kyc_key`\n+    -   `modify_timestamp`\n+    -   `supply_key`\n+    -   `symbol`\n+    -   `treasury_account_id`\n+    -   `wipe_key`\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+#### AccountBalance\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+#### TokenTransfer\n+-   Create new `TokenTransfer` with the following class members\n+    -   `accountId`\n+    -   `amount`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+#### EntityTypeEnum\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+        ...\n+        TOKEN(5);\n+        ...\n+    }\n+```\n+\n+#### Token\n+-   Add `Token` class to hold Token specific metadata outside of the base entity class with the following class members\n+    -   `createTimestamp`\n+    -   `divisibility`\n+    -   `freezeDefault`\n+    -   `freezeKey`\n+    -   `initialSupply`\n+    -   `kycDefault`\n+    -   `kycKey`\n+    -   `modifyTimestamp`\n+    -   `supplyKey`\n+    -   `symbol`\n+    -   `tokenId`\n+    -   `treasuryAccountId`\n+    -   `wipeKey`\n+\n+#### TokenAccount\n+-   Add `TokenAccount` class with the following class members\n+    -   `id`\n+    -   `accountId`\n+    -   `createTimestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modifyTimestamp`\n+    -   `tokenId`\n+    -   `wiped`\n+\n+#### TokenBalance\n+-   Add `TokenBalance` class with the following class members\n+    -   `accountId`\n+    -   `balance`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+### Balance Parsing\n+To support HTS the balance CSV\n+1. Adds a version comment as the first line of the file i.e. `# version:2`\n+2. Comments out the Timestamp e.g. `TimeStamp:2020-09-22T04:25:00.083212003Z`\n+3. Adds a `tokenBalances` column which is the Base64 encoding of the serialized bytes of `TokenBalances` proto.\n+\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,tokenBalances`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first line of the CSV\n+    -   If `TimeStamp` is matched use `BalanceFileReaderImplV1` as the reader\n+    -   If `# version:2` is matched use `BalanceFileReaderImplV2` as the reader\n+    -   If no `# version:2` or `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenBalance` in the `TokenBalances`\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to set Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenTransferTransactionsHandler`\n+-   Add `TokenFreezeTransactionsHandler`\n+-   Add `TokenUnfreezeTransactionsHandler`\n+-   Add `TokenGrantKycTransactionsHandler`\n+-   Add `TokenRevokeKycTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to update Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenWipeTransactionsHandler`\n+-   Add `TokenAssociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenDissociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+\n+\n+### Token Transfer Parsing\n+\n+#### EntityListener\n+-   Add a `onToken()` to handle create and updates on the `token` table\n+```java\n+    default void onToken(Token token) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenAccount()` to handle inserts and updates on the `token_account` table\n+```java\n+    default void onTokenAccount(TokenAccount tokenAccount) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenTransfer()` to handle a `token_transfer` table\n+```java\n+    default void onTokenTransfer(TokenTransfer tokenTransfer) throws ImporterException {\n+    }\n+```\n+\n+#### EntityRecordItemListener\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+Add logic to check for\n+-   `TransactionBody.hasTokenCreation()` and parse `TokenCreateTransactionBody` out from the record. Create a new `Token` object and pass it to `entityListener.onToken()`.\n+-   `TransactionBody.hasTokenTransfers()` and parse `TokenTransferLists` out from the record. Create a new `TokenTransfer` object for each `AccountAmount` in the `TokenTransferList` object and pass it to `entityListener.onTokenTransfer()`.\n+-   `TransactionBody.hasTokenAssociate()` and parse `TokenAssociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenDissociate()` and parse `TokenDissociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenFreeze()` and parse `TokenFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUnfreeze()` and parse `TokenUnFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenGrantKyc()` and parse `TokenGrantKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenRevokeKyc()` and parse `TokenRevokeKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenWipe()` and parse `TokenWipeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `wipe` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUpdate()` and parse `TokenUpdateTransactionBody` out from the record. Retrieve an existing `Token` db entry, update the appropriate columns and pass it to `entityListener.onToken()`.\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `transactions` REST API must be updated to support `tokenTransfers`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `accounts` REST API must be updated to support `tokenBalances`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<symbol>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<symbol>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"token_balances\": [\n+            {\n+              \"symbol\": \"FOOBAR\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "originalPosition": 341}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NTA4NDI3OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxODozMjo1NFrOHXnusg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxODozMjo1NFrOHXnusg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUzMDIyNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                          \"symbol\": \"FOOCOIN\",\n          \n          \n            \n                          \"token_id\": \"0.3.4\",", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494530226", "createdAt": "2020-09-24T18:32:54Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,631 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members\n+    -   `account_id`\n+    -   `amount`\n+    -   `consensus_timestamp`\n+    -   `token_id`\n+-   Add a `token_transfer__token_account_timestamp` index with `desc` order on columns\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances with the following columns\n+    -   `consensus_timestamp`\n+    -   `account_id`\n+    -   `balance`\n+    -   `token_id`\n+-   Create primary key as combination of `consensus_timestamp`, `token_id` and `account_id`\n+\n+### Token Account Info\n+-   Create `token_account` table to distinctly capture token account metadata changes with the following columns\n+    -   `id` (primary key)\n+    -   `account_id`\n+    -   `create_timestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modify_timestamp`\n+    -   `token_id`\n+    -   `wiped`\n+-   Create unique index `token_account__token_account`\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with `id` value of 5 and `name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+         (28, 'UNCHECKEDSUBMIT'),\n+         (29, 'TOKENCREATE'),\n+         (30, 'TOKENTRANSFER'),\n+         (31, 'TOKENFREEZE'),\n+         (32, 'TOKENUNFREEZE'),\n+         (33, 'TOKENGRANTKYC'),\n+         (34, 'TOKENREVOKEKYC'),\n+         (35, 'TOKENDELETE'),\n+         (36, 'TOKENUPDATE'),\n+         (37, 'TOKENMINT'),\n+         (38, 'TOKENBURN'),\n+         (39, 'TOKENWIPE'),\n+         (40, 'TOKENASSOCIATE'),\n+         (41, 'TOKENDISSOCIATE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP'),\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT'),\n+        (188, 'INVALID_KYC_KEY'),\n+        (189, 'INVALID_WIPE_KEY'),\n+        (190, 'INVALID_FREEZE_KEY'),\n+        (191, 'INVALID_SUPPLY_KEY'),\n+        (192, 'TOKEN_NAME_ALREADY_IN_USE'),\n+        (193, 'MISSING_TOKEN_NAME'),\n+        (194, 'TOKEN_NAME_TOO_LONG'),\n+        (195, 'INVALID_WIPING_AMOUNT'),\n+        (196, 'TOKEN_IS_IMMUTABlE'),\n+        (197, 'TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table with the following columns. Table will capture non shared `entity` items, most API calls may not require this information and therefore additional sql joins may be avoided.\n+    -   `token_id` (primary key)\n+    -   `create_timestamp`\n+    -   `divisibility`\n+    -   `freeze_default`\n+    -   `freeze_key`\n+    -   `initial_supply`\n+    -   `kyc_default`\n+    -   `kyc_key`\n+    -   `modify_timestamp`\n+    -   `supply_key`\n+    -   `symbol`\n+    -   `treasury_account_id`\n+    -   `wipe_key`\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+#### AccountBalance\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+#### TokenTransfer\n+-   Create new `TokenTransfer` with the following class members\n+    -   `accountId`\n+    -   `amount`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+#### EntityTypeEnum\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+        ...\n+        TOKEN(5);\n+        ...\n+    }\n+```\n+\n+#### Token\n+-   Add `Token` class to hold Token specific metadata outside of the base entity class with the following class members\n+    -   `createTimestamp`\n+    -   `divisibility`\n+    -   `freezeDefault`\n+    -   `freezeKey`\n+    -   `initialSupply`\n+    -   `kycDefault`\n+    -   `kycKey`\n+    -   `modifyTimestamp`\n+    -   `supplyKey`\n+    -   `symbol`\n+    -   `tokenId`\n+    -   `treasuryAccountId`\n+    -   `wipeKey`\n+\n+#### TokenAccount\n+-   Add `TokenAccount` class with the following class members\n+    -   `id`\n+    -   `accountId`\n+    -   `createTimestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modifyTimestamp`\n+    -   `tokenId`\n+    -   `wiped`\n+\n+#### TokenBalance\n+-   Add `TokenBalance` class with the following class members\n+    -   `accountId`\n+    -   `balance`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+### Balance Parsing\n+To support HTS the balance CSV\n+1. Adds a version comment as the first line of the file i.e. `# version:2`\n+2. Comments out the Timestamp e.g. `TimeStamp:2020-09-22T04:25:00.083212003Z`\n+3. Adds a `tokenBalances` column which is the Base64 encoding of the serialized bytes of `TokenBalances` proto.\n+\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,tokenBalances`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first line of the CSV\n+    -   If `TimeStamp` is matched use `BalanceFileReaderImplV1` as the reader\n+    -   If `# version:2` is matched use `BalanceFileReaderImplV2` as the reader\n+    -   If no `# version:2` or `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenBalance` in the `TokenBalances`\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to set Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenTransferTransactionsHandler`\n+-   Add `TokenFreezeTransactionsHandler`\n+-   Add `TokenUnfreezeTransactionsHandler`\n+-   Add `TokenGrantKycTransactionsHandler`\n+-   Add `TokenRevokeKycTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to update Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenWipeTransactionsHandler`\n+-   Add `TokenAssociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenDissociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+\n+\n+### Token Transfer Parsing\n+\n+#### EntityListener\n+-   Add a `onToken()` to handle create and updates on the `token` table\n+```java\n+    default void onToken(Token token) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenAccount()` to handle inserts and updates on the `token_account` table\n+```java\n+    default void onTokenAccount(TokenAccount tokenAccount) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenTransfer()` to handle a `token_transfer` table\n+```java\n+    default void onTokenTransfer(TokenTransfer tokenTransfer) throws ImporterException {\n+    }\n+```\n+\n+#### EntityRecordItemListener\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+Add logic to check for\n+-   `TransactionBody.hasTokenCreation()` and parse `TokenCreateTransactionBody` out from the record. Create a new `Token` object and pass it to `entityListener.onToken()`.\n+-   `TransactionBody.hasTokenTransfers()` and parse `TokenTransferLists` out from the record. Create a new `TokenTransfer` object for each `AccountAmount` in the `TokenTransferList` object and pass it to `entityListener.onTokenTransfer()`.\n+-   `TransactionBody.hasTokenAssociate()` and parse `TokenAssociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenDissociate()` and parse `TokenDissociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenFreeze()` and parse `TokenFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUnfreeze()` and parse `TokenUnFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenGrantKyc()` and parse `TokenGrantKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenRevokeKyc()` and parse `TokenRevokeKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenWipe()` and parse `TokenWipeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `wipe` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUpdate()` and parse `TokenUpdateTransactionBody` out from the record. Retrieve an existing `Token` db entry, update the appropriate columns and pass it to `entityListener.onToken()`.\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `transactions` REST API must be updated to support `tokenTransfers`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `accounts` REST API must be updated to support `tokenBalances`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<symbol>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<symbol>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"token_balances\": [\n+            {\n+              \"symbol\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"symbol\": \"FOOCOIN\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "originalPosition": 345}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NTA5NzgwOnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxODozNjo0NVrOHXn2vQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxODozNjo0NVrOHXn2vQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUzMjI4NQ==", "bodyText": "Additionally add publickey to match token adminKey\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            -   `/api/v1/tokens/<symbol>/balances?timestamp=1566562500.040961001`\n          \n          \n            \n            -   `/api/v1/tokens/<tokenId>/balances?timestamp=1566562500.040961001`\n          \n          \n            \n            -   `/api/v1/tokens/< tokenId >/balances?publicKey=2b60955bcbf0cf5e9ea880b52e5b63f664b08edf6ed 15e301049517438d61864`\n          \n      \n    \n    \n  \n\nBasically we want similar parity with https://docs.hedera.com/guides/docs/mirror-node-api/cryptocurrency-api#additional-examples", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494532285", "createdAt": "2020-09-24T18:36:45Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,631 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members\n+    -   `account_id`\n+    -   `amount`\n+    -   `consensus_timestamp`\n+    -   `token_id`\n+-   Add a `token_transfer__token_account_timestamp` index with `desc` order on columns\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances with the following columns\n+    -   `consensus_timestamp`\n+    -   `account_id`\n+    -   `balance`\n+    -   `token_id`\n+-   Create primary key as combination of `consensus_timestamp`, `token_id` and `account_id`\n+\n+### Token Account Info\n+-   Create `token_account` table to distinctly capture token account metadata changes with the following columns\n+    -   `id` (primary key)\n+    -   `account_id`\n+    -   `create_timestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modify_timestamp`\n+    -   `token_id`\n+    -   `wiped`\n+-   Create unique index `token_account__token_account`\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with `id` value of 5 and `name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+         (28, 'UNCHECKEDSUBMIT'),\n+         (29, 'TOKENCREATE'),\n+         (30, 'TOKENTRANSFER'),\n+         (31, 'TOKENFREEZE'),\n+         (32, 'TOKENUNFREEZE'),\n+         (33, 'TOKENGRANTKYC'),\n+         (34, 'TOKENREVOKEKYC'),\n+         (35, 'TOKENDELETE'),\n+         (36, 'TOKENUPDATE'),\n+         (37, 'TOKENMINT'),\n+         (38, 'TOKENBURN'),\n+         (39, 'TOKENWIPE'),\n+         (40, 'TOKENASSOCIATE'),\n+         (41, 'TOKENDISSOCIATE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP'),\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT'),\n+        (188, 'INVALID_KYC_KEY'),\n+        (189, 'INVALID_WIPE_KEY'),\n+        (190, 'INVALID_FREEZE_KEY'),\n+        (191, 'INVALID_SUPPLY_KEY'),\n+        (192, 'TOKEN_NAME_ALREADY_IN_USE'),\n+        (193, 'MISSING_TOKEN_NAME'),\n+        (194, 'TOKEN_NAME_TOO_LONG'),\n+        (195, 'INVALID_WIPING_AMOUNT'),\n+        (196, 'TOKEN_IS_IMMUTABlE'),\n+        (197, 'TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table with the following columns. Table will capture non shared `entity` items, most API calls may not require this information and therefore additional sql joins may be avoided.\n+    -   `token_id` (primary key)\n+    -   `create_timestamp`\n+    -   `divisibility`\n+    -   `freeze_default`\n+    -   `freeze_key`\n+    -   `initial_supply`\n+    -   `kyc_default`\n+    -   `kyc_key`\n+    -   `modify_timestamp`\n+    -   `supply_key`\n+    -   `symbol`\n+    -   `treasury_account_id`\n+    -   `wipe_key`\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+#### AccountBalance\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+#### TokenTransfer\n+-   Create new `TokenTransfer` with the following class members\n+    -   `accountId`\n+    -   `amount`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+#### EntityTypeEnum\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+        ...\n+        TOKEN(5);\n+        ...\n+    }\n+```\n+\n+#### Token\n+-   Add `Token` class to hold Token specific metadata outside of the base entity class with the following class members\n+    -   `createTimestamp`\n+    -   `divisibility`\n+    -   `freezeDefault`\n+    -   `freezeKey`\n+    -   `initialSupply`\n+    -   `kycDefault`\n+    -   `kycKey`\n+    -   `modifyTimestamp`\n+    -   `supplyKey`\n+    -   `symbol`\n+    -   `tokenId`\n+    -   `treasuryAccountId`\n+    -   `wipeKey`\n+\n+#### TokenAccount\n+-   Add `TokenAccount` class with the following class members\n+    -   `id`\n+    -   `accountId`\n+    -   `createTimestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modifyTimestamp`\n+    -   `tokenId`\n+    -   `wiped`\n+\n+#### TokenBalance\n+-   Add `TokenBalance` class with the following class members\n+    -   `accountId`\n+    -   `balance`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+### Balance Parsing\n+To support HTS the balance CSV\n+1. Adds a version comment as the first line of the file i.e. `# version:2`\n+2. Comments out the Timestamp e.g. `TimeStamp:2020-09-22T04:25:00.083212003Z`\n+3. Adds a `tokenBalances` column which is the Base64 encoding of the serialized bytes of `TokenBalances` proto.\n+\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,tokenBalances`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first line of the CSV\n+    -   If `TimeStamp` is matched use `BalanceFileReaderImplV1` as the reader\n+    -   If `# version:2` is matched use `BalanceFileReaderImplV2` as the reader\n+    -   If no `# version:2` or `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenBalance` in the `TokenBalances`\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to set Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenTransferTransactionsHandler`\n+-   Add `TokenFreezeTransactionsHandler`\n+-   Add `TokenUnfreezeTransactionsHandler`\n+-   Add `TokenGrantKycTransactionsHandler`\n+-   Add `TokenRevokeKycTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to update Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenWipeTransactionsHandler`\n+-   Add `TokenAssociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenDissociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+\n+\n+### Token Transfer Parsing\n+\n+#### EntityListener\n+-   Add a `onToken()` to handle create and updates on the `token` table\n+```java\n+    default void onToken(Token token) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenAccount()` to handle inserts and updates on the `token_account` table\n+```java\n+    default void onTokenAccount(TokenAccount tokenAccount) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenTransfer()` to handle a `token_transfer` table\n+```java\n+    default void onTokenTransfer(TokenTransfer tokenTransfer) throws ImporterException {\n+    }\n+```\n+\n+#### EntityRecordItemListener\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+Add logic to check for\n+-   `TransactionBody.hasTokenCreation()` and parse `TokenCreateTransactionBody` out from the record. Create a new `Token` object and pass it to `entityListener.onToken()`.\n+-   `TransactionBody.hasTokenTransfers()` and parse `TokenTransferLists` out from the record. Create a new `TokenTransfer` object for each `AccountAmount` in the `TokenTransferList` object and pass it to `entityListener.onTokenTransfer()`.\n+-   `TransactionBody.hasTokenAssociate()` and parse `TokenAssociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenDissociate()` and parse `TokenDissociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenFreeze()` and parse `TokenFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUnfreeze()` and parse `TokenUnFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenGrantKyc()` and parse `TokenGrantKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenRevokeKyc()` and parse `TokenRevokeKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenWipe()` and parse `TokenWipeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `wipe` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUpdate()` and parse `TokenUpdateTransactionBody` out from the record. Retrieve an existing `Token` db entry, update the appropriate columns and pass it to `entityListener.onToken()`.\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `transactions` REST API must be updated to support `tokenTransfers`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `accounts` REST API must be updated to support `tokenBalances`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<symbol>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<symbol>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"token_balances\": [\n+            {\n+              \"symbol\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"symbol\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"token_balances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"token_balances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"token_balances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"symbol\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"transfers\": [\n+                {\n+                  \"account\": \"0.0.1111\",\n+                  \"amount\": -10,\n+                  \"symbol\": \"FOOBAR\"\n+                },\n+                {\n+                  \"account\": \"0.0.2222\",\n+                  \"amount\": 10,\n+                  \"symbol\": \"FOOBAR\"\n+                }\n+              ]\n+            },\n+            {\n+              \"transfers\": [\n+                {\n+                  \"account\": \"0.0.3333\",\n+                  \"amount\": -10,\n+                  \"symbol\":\"FOOCOIN\"\n+                },\n+                {\n+                  \"account\": \"0.0.4444\",\n+                  \"amount\": 10,\n+                  \"symbol\":\"FOOCOIN\"\n+                }\n+               ]\n+            }\n+          ]\n+        }\n+      ]\n+    }\n+```\n+\n+### Token Supply distribution\n+\n+`/api/v1/tokens/<symbol>/balances` this could be the equivalent of `/api/v1/balances?symbol=<symbol>` currently and would return a list of account and the token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.15.10\",\n+            \"balance\": 100\n+          },\n+          {\n+            \"account\": \"0.15.9\",\n+            \"balance\": 90\n+          },\n+          {\n+            \"account\": \"0.15.8\",\n+            \"balance\": 80\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens/<symbol>/balances?id=0.0.1000`\n+-   `/api/v1/tokens/<symbol>/balances?balance=gt:1000`\n+-   `/api/v1/tokens/<symbol>/balances?timestamp=1566562500.040961001`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "originalPosition": 500}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NTE0NjQ5OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxODo0OTo1NlrOHXoUGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxODo0OTo1NlrOHXoUGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUzOTgwMg==", "bodyText": "Add tokenId range\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            -   `/api/v1/tokens?account.id=0.0.8` - All tokens for matching account\n          \n          \n            \n            -   `/api/v1/tokens?token.id=0.0.8` - All tokens for matching account\n          \n          \n            \n            -   `/api/v1/tokens?token.id=gt:0.0.1001`", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494539802", "createdAt": "2020-09-24T18:49:56Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,631 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members\n+    -   `account_id`\n+    -   `amount`\n+    -   `consensus_timestamp`\n+    -   `token_id`\n+-   Add a `token_transfer__token_account_timestamp` index with `desc` order on columns\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances with the following columns\n+    -   `consensus_timestamp`\n+    -   `account_id`\n+    -   `balance`\n+    -   `token_id`\n+-   Create primary key as combination of `consensus_timestamp`, `token_id` and `account_id`\n+\n+### Token Account Info\n+-   Create `token_account` table to distinctly capture token account metadata changes with the following columns\n+    -   `id` (primary key)\n+    -   `account_id`\n+    -   `create_timestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modify_timestamp`\n+    -   `token_id`\n+    -   `wiped`\n+-   Create unique index `token_account__token_account`\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with `id` value of 5 and `name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+         (28, 'UNCHECKEDSUBMIT'),\n+         (29, 'TOKENCREATE'),\n+         (30, 'TOKENTRANSFER'),\n+         (31, 'TOKENFREEZE'),\n+         (32, 'TOKENUNFREEZE'),\n+         (33, 'TOKENGRANTKYC'),\n+         (34, 'TOKENREVOKEKYC'),\n+         (35, 'TOKENDELETE'),\n+         (36, 'TOKENUPDATE'),\n+         (37, 'TOKENMINT'),\n+         (38, 'TOKENBURN'),\n+         (39, 'TOKENWIPE'),\n+         (40, 'TOKENASSOCIATE'),\n+         (41, 'TOKENDISSOCIATE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP'),\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT'),\n+        (188, 'INVALID_KYC_KEY'),\n+        (189, 'INVALID_WIPE_KEY'),\n+        (190, 'INVALID_FREEZE_KEY'),\n+        (191, 'INVALID_SUPPLY_KEY'),\n+        (192, 'TOKEN_NAME_ALREADY_IN_USE'),\n+        (193, 'MISSING_TOKEN_NAME'),\n+        (194, 'TOKEN_NAME_TOO_LONG'),\n+        (195, 'INVALID_WIPING_AMOUNT'),\n+        (196, 'TOKEN_IS_IMMUTABlE'),\n+        (197, 'TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table with the following columns. Table will capture non shared `entity` items, most API calls may not require this information and therefore additional sql joins may be avoided.\n+    -   `token_id` (primary key)\n+    -   `create_timestamp`\n+    -   `divisibility`\n+    -   `freeze_default`\n+    -   `freeze_key`\n+    -   `initial_supply`\n+    -   `kyc_default`\n+    -   `kyc_key`\n+    -   `modify_timestamp`\n+    -   `supply_key`\n+    -   `symbol`\n+    -   `treasury_account_id`\n+    -   `wipe_key`\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+#### AccountBalance\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+#### TokenTransfer\n+-   Create new `TokenTransfer` with the following class members\n+    -   `accountId`\n+    -   `amount`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+#### EntityTypeEnum\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+        ...\n+        TOKEN(5);\n+        ...\n+    }\n+```\n+\n+#### Token\n+-   Add `Token` class to hold Token specific metadata outside of the base entity class with the following class members\n+    -   `createTimestamp`\n+    -   `divisibility`\n+    -   `freezeDefault`\n+    -   `freezeKey`\n+    -   `initialSupply`\n+    -   `kycDefault`\n+    -   `kycKey`\n+    -   `modifyTimestamp`\n+    -   `supplyKey`\n+    -   `symbol`\n+    -   `tokenId`\n+    -   `treasuryAccountId`\n+    -   `wipeKey`\n+\n+#### TokenAccount\n+-   Add `TokenAccount` class with the following class members\n+    -   `id`\n+    -   `accountId`\n+    -   `createTimestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modifyTimestamp`\n+    -   `tokenId`\n+    -   `wiped`\n+\n+#### TokenBalance\n+-   Add `TokenBalance` class with the following class members\n+    -   `accountId`\n+    -   `balance`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+### Balance Parsing\n+To support HTS the balance CSV\n+1. Adds a version comment as the first line of the file i.e. `# version:2`\n+2. Comments out the Timestamp e.g. `TimeStamp:2020-09-22T04:25:00.083212003Z`\n+3. Adds a `tokenBalances` column which is the Base64 encoding of the serialized bytes of `TokenBalances` proto.\n+\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,tokenBalances`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first line of the CSV\n+    -   If `TimeStamp` is matched use `BalanceFileReaderImplV1` as the reader\n+    -   If `# version:2` is matched use `BalanceFileReaderImplV2` as the reader\n+    -   If no `# version:2` or `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenBalance` in the `TokenBalances`\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to set Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenTransferTransactionsHandler`\n+-   Add `TokenFreezeTransactionsHandler`\n+-   Add `TokenUnfreezeTransactionsHandler`\n+-   Add `TokenGrantKycTransactionsHandler`\n+-   Add `TokenRevokeKycTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to update Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenWipeTransactionsHandler`\n+-   Add `TokenAssociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenDissociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+\n+\n+### Token Transfer Parsing\n+\n+#### EntityListener\n+-   Add a `onToken()` to handle create and updates on the `token` table\n+```java\n+    default void onToken(Token token) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenAccount()` to handle inserts and updates on the `token_account` table\n+```java\n+    default void onTokenAccount(TokenAccount tokenAccount) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenTransfer()` to handle a `token_transfer` table\n+```java\n+    default void onTokenTransfer(TokenTransfer tokenTransfer) throws ImporterException {\n+    }\n+```\n+\n+#### EntityRecordItemListener\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+Add logic to check for\n+-   `TransactionBody.hasTokenCreation()` and parse `TokenCreateTransactionBody` out from the record. Create a new `Token` object and pass it to `entityListener.onToken()`.\n+-   `TransactionBody.hasTokenTransfers()` and parse `TokenTransferLists` out from the record. Create a new `TokenTransfer` object for each `AccountAmount` in the `TokenTransferList` object and pass it to `entityListener.onTokenTransfer()`.\n+-   `TransactionBody.hasTokenAssociate()` and parse `TokenAssociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenDissociate()` and parse `TokenDissociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenFreeze()` and parse `TokenFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUnfreeze()` and parse `TokenUnFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenGrantKyc()` and parse `TokenGrantKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenRevokeKyc()` and parse `TokenRevokeKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenWipe()` and parse `TokenWipeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `wipe` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUpdate()` and parse `TokenUpdateTransactionBody` out from the record. Retrieve an existing `Token` db entry, update the appropriate columns and pass it to `entityListener.onToken()`.\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `transactions` REST API must be updated to support `tokenTransfers`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `accounts` REST API must be updated to support `tokenBalances`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<symbol>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<symbol>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"token_balances\": [\n+            {\n+              \"symbol\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"symbol\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"token_balances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"token_balances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"token_balances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"symbol\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"transfers\": [\n+                {\n+                  \"account\": \"0.0.1111\",\n+                  \"amount\": -10,\n+                  \"symbol\": \"FOOBAR\"\n+                },\n+                {\n+                  \"account\": \"0.0.2222\",\n+                  \"amount\": 10,\n+                  \"symbol\": \"FOOBAR\"\n+                }\n+              ]\n+            },\n+            {\n+              \"transfers\": [\n+                {\n+                  \"account\": \"0.0.3333\",\n+                  \"amount\": -10,\n+                  \"symbol\":\"FOOCOIN\"\n+                },\n+                {\n+                  \"account\": \"0.0.4444\",\n+                  \"amount\": 10,\n+                  \"symbol\":\"FOOCOIN\"\n+                }\n+               ]\n+            }\n+          ]\n+        }\n+      ]\n+    }\n+```\n+\n+### Token Supply distribution\n+\n+`/api/v1/tokens/<symbol>/balances` this could be the equivalent of `/api/v1/balances?symbol=<symbol>` currently and would return a list of account and the token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.15.10\",\n+            \"balance\": 100\n+          },\n+          {\n+            \"account\": \"0.15.9\",\n+            \"balance\": 90\n+          },\n+          {\n+            \"account\": \"0.15.8\",\n+            \"balance\": 80\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens/<symbol>/balances?id=0.0.1000`\n+-   `/api/v1/tokens/<symbol>/balances?balance=gt:1000`\n+-   `/api/v1/tokens/<symbol>/balances?timestamp=1566562500.040961001`\n+\n+### Token Discovery\n+`/api/v1/tokens` this would return all tokens present on the network\n+\n+```json\n+    {\n+        \"tokens\": [\n+          {\n+            \"symbol\": \"FOOBAR\",\n+            \"token_id\": \"0.15.10\",\n+            \"admin_key\": {\n+              \"_type\": \"ProtobufEncoded\",\n+              \"key\": \"7b2233222c2233222c2233227d\"\n+            }\n+          },\n+          {\n+            \"symbol\": \"FOOCOIN\",\n+            \"tokenId\": \"0.15.11\",\n+            \"admin_key\": {\n+              \"_type\": \"ProtobufEncoded\",\n+              \"key\": \"9c2233222c2233222c2233227d\"\n+            }\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens?publickey=3c3d546321ff6f63d701d2ec5c277095874e19f4a235bee1e6bb19258bf362be` - All tokens with matching admin key\n+-   `/api/v1/tokens?account.id=0.0.8` - All tokens for matching account", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "originalPosition": 533}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NTE1NDQ1OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxODo1MjoxMVrOHXoZBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxODo1MjoxMVrOHXoZBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU0MTA2Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            `/api/v1/tokens/<symbol>/balances` this could be the equivalent of `/api/v1/balances?symbol=<symbol>` currently and would return a list of account and the token balances\n          \n          \n            \n            `/api/v1/tokens/<tokenId>/balances` this could be the equivalent of `/api/v1/balances?account.id=<account.id>` currently and would return a list of account and the token balances", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494541062", "createdAt": "2020-09-24T18:52:11Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,631 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members\n+    -   `account_id`\n+    -   `amount`\n+    -   `consensus_timestamp`\n+    -   `token_id`\n+-   Add a `token_transfer__token_account_timestamp` index with `desc` order on columns\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances with the following columns\n+    -   `consensus_timestamp`\n+    -   `account_id`\n+    -   `balance`\n+    -   `token_id`\n+-   Create primary key as combination of `consensus_timestamp`, `token_id` and `account_id`\n+\n+### Token Account Info\n+-   Create `token_account` table to distinctly capture token account metadata changes with the following columns\n+    -   `id` (primary key)\n+    -   `account_id`\n+    -   `create_timestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modify_timestamp`\n+    -   `token_id`\n+    -   `wiped`\n+-   Create unique index `token_account__token_account`\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with `id` value of 5 and `name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+         (28, 'UNCHECKEDSUBMIT'),\n+         (29, 'TOKENCREATE'),\n+         (30, 'TOKENTRANSFER'),\n+         (31, 'TOKENFREEZE'),\n+         (32, 'TOKENUNFREEZE'),\n+         (33, 'TOKENGRANTKYC'),\n+         (34, 'TOKENREVOKEKYC'),\n+         (35, 'TOKENDELETE'),\n+         (36, 'TOKENUPDATE'),\n+         (37, 'TOKENMINT'),\n+         (38, 'TOKENBURN'),\n+         (39, 'TOKENWIPE'),\n+         (40, 'TOKENASSOCIATE'),\n+         (41, 'TOKENDISSOCIATE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP'),\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT'),\n+        (188, 'INVALID_KYC_KEY'),\n+        (189, 'INVALID_WIPE_KEY'),\n+        (190, 'INVALID_FREEZE_KEY'),\n+        (191, 'INVALID_SUPPLY_KEY'),\n+        (192, 'TOKEN_NAME_ALREADY_IN_USE'),\n+        (193, 'MISSING_TOKEN_NAME'),\n+        (194, 'TOKEN_NAME_TOO_LONG'),\n+        (195, 'INVALID_WIPING_AMOUNT'),\n+        (196, 'TOKEN_IS_IMMUTABlE'),\n+        (197, 'TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table with the following columns. Table will capture non shared `entity` items, most API calls may not require this information and therefore additional sql joins may be avoided.\n+    -   `token_id` (primary key)\n+    -   `create_timestamp`\n+    -   `divisibility`\n+    -   `freeze_default`\n+    -   `freeze_key`\n+    -   `initial_supply`\n+    -   `kyc_default`\n+    -   `kyc_key`\n+    -   `modify_timestamp`\n+    -   `supply_key`\n+    -   `symbol`\n+    -   `treasury_account_id`\n+    -   `wipe_key`\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+#### AccountBalance\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+#### TokenTransfer\n+-   Create new `TokenTransfer` with the following class members\n+    -   `accountId`\n+    -   `amount`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+#### EntityTypeEnum\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+        ...\n+        TOKEN(5);\n+        ...\n+    }\n+```\n+\n+#### Token\n+-   Add `Token` class to hold Token specific metadata outside of the base entity class with the following class members\n+    -   `createTimestamp`\n+    -   `divisibility`\n+    -   `freezeDefault`\n+    -   `freezeKey`\n+    -   `initialSupply`\n+    -   `kycDefault`\n+    -   `kycKey`\n+    -   `modifyTimestamp`\n+    -   `supplyKey`\n+    -   `symbol`\n+    -   `tokenId`\n+    -   `treasuryAccountId`\n+    -   `wipeKey`\n+\n+#### TokenAccount\n+-   Add `TokenAccount` class with the following class members\n+    -   `id`\n+    -   `accountId`\n+    -   `createTimestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modifyTimestamp`\n+    -   `tokenId`\n+    -   `wiped`\n+\n+#### TokenBalance\n+-   Add `TokenBalance` class with the following class members\n+    -   `accountId`\n+    -   `balance`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+### Balance Parsing\n+To support HTS the balance CSV\n+1. Adds a version comment as the first line of the file i.e. `# version:2`\n+2. Comments out the Timestamp e.g. `TimeStamp:2020-09-22T04:25:00.083212003Z`\n+3. Adds a `tokenBalances` column which is the Base64 encoding of the serialized bytes of `TokenBalances` proto.\n+\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,tokenBalances`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first line of the CSV\n+    -   If `TimeStamp` is matched use `BalanceFileReaderImplV1` as the reader\n+    -   If `# version:2` is matched use `BalanceFileReaderImplV2` as the reader\n+    -   If no `# version:2` or `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenBalance` in the `TokenBalances`\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to set Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenTransferTransactionsHandler`\n+-   Add `TokenFreezeTransactionsHandler`\n+-   Add `TokenUnfreezeTransactionsHandler`\n+-   Add `TokenGrantKycTransactionsHandler`\n+-   Add `TokenRevokeKycTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to update Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenWipeTransactionsHandler`\n+-   Add `TokenAssociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenDissociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+\n+\n+### Token Transfer Parsing\n+\n+#### EntityListener\n+-   Add a `onToken()` to handle create and updates on the `token` table\n+```java\n+    default void onToken(Token token) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenAccount()` to handle inserts and updates on the `token_account` table\n+```java\n+    default void onTokenAccount(TokenAccount tokenAccount) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenTransfer()` to handle a `token_transfer` table\n+```java\n+    default void onTokenTransfer(TokenTransfer tokenTransfer) throws ImporterException {\n+    }\n+```\n+\n+#### EntityRecordItemListener\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+Add logic to check for\n+-   `TransactionBody.hasTokenCreation()` and parse `TokenCreateTransactionBody` out from the record. Create a new `Token` object and pass it to `entityListener.onToken()`.\n+-   `TransactionBody.hasTokenTransfers()` and parse `TokenTransferLists` out from the record. Create a new `TokenTransfer` object for each `AccountAmount` in the `TokenTransferList` object and pass it to `entityListener.onTokenTransfer()`.\n+-   `TransactionBody.hasTokenAssociate()` and parse `TokenAssociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenDissociate()` and parse `TokenDissociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenFreeze()` and parse `TokenFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUnfreeze()` and parse `TokenUnFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenGrantKyc()` and parse `TokenGrantKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenRevokeKyc()` and parse `TokenRevokeKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenWipe()` and parse `TokenWipeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `wipe` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUpdate()` and parse `TokenUpdateTransactionBody` out from the record. Retrieve an existing `Token` db entry, update the appropriate columns and pass it to `entityListener.onToken()`.\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `transactions` REST API must be updated to support `tokenTransfers`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `accounts` REST API must be updated to support `tokenBalances`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<symbol>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<symbol>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"token_balances\": [\n+            {\n+              \"symbol\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"symbol\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"token_balances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"token_balances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"token_balances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"symbol\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"transfers\": [\n+                {\n+                  \"account\": \"0.0.1111\",\n+                  \"amount\": -10,\n+                  \"symbol\": \"FOOBAR\"\n+                },\n+                {\n+                  \"account\": \"0.0.2222\",\n+                  \"amount\": 10,\n+                  \"symbol\": \"FOOBAR\"\n+                }\n+              ]\n+            },\n+            {\n+              \"transfers\": [\n+                {\n+                  \"account\": \"0.0.3333\",\n+                  \"amount\": -10,\n+                  \"symbol\":\"FOOCOIN\"\n+                },\n+                {\n+                  \"account\": \"0.0.4444\",\n+                  \"amount\": 10,\n+                  \"symbol\":\"FOOCOIN\"\n+                }\n+               ]\n+            }\n+          ]\n+        }\n+      ]\n+    }\n+```\n+\n+### Token Supply distribution\n+\n+`/api/v1/tokens/<symbol>/balances` this could be the equivalent of `/api/v1/balances?symbol=<symbol>` currently and would return a list of account and the token balances", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "originalPosition": 473}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NTIwODIzOnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxOTowNzozNFrOHXo6Hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQyMzoxNjo0OVrOHYXYpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU0OTUzNQ==", "bodyText": "Spurious transfers key and extra array", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494549535", "createdAt": "2020-09-24T19:07:34Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,631 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members\n+    -   `account_id`\n+    -   `amount`\n+    -   `consensus_timestamp`\n+    -   `token_id`\n+-   Add a `token_transfer__token_account_timestamp` index with `desc` order on columns\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances with the following columns\n+    -   `consensus_timestamp`\n+    -   `account_id`\n+    -   `balance`\n+    -   `token_id`\n+-   Create primary key as combination of `consensus_timestamp`, `token_id` and `account_id`\n+\n+### Token Account Info\n+-   Create `token_account` table to distinctly capture token account metadata changes with the following columns\n+    -   `id` (primary key)\n+    -   `account_id`\n+    -   `create_timestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modify_timestamp`\n+    -   `token_id`\n+    -   `wiped`\n+-   Create unique index `token_account__token_account`\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with `id` value of 5 and `name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+         (28, 'UNCHECKEDSUBMIT'),\n+         (29, 'TOKENCREATE'),\n+         (30, 'TOKENTRANSFER'),\n+         (31, 'TOKENFREEZE'),\n+         (32, 'TOKENUNFREEZE'),\n+         (33, 'TOKENGRANTKYC'),\n+         (34, 'TOKENREVOKEKYC'),\n+         (35, 'TOKENDELETE'),\n+         (36, 'TOKENUPDATE'),\n+         (37, 'TOKENMINT'),\n+         (38, 'TOKENBURN'),\n+         (39, 'TOKENWIPE'),\n+         (40, 'TOKENASSOCIATE'),\n+         (41, 'TOKENDISSOCIATE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP'),\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT'),\n+        (188, 'INVALID_KYC_KEY'),\n+        (189, 'INVALID_WIPE_KEY'),\n+        (190, 'INVALID_FREEZE_KEY'),\n+        (191, 'INVALID_SUPPLY_KEY'),\n+        (192, 'TOKEN_NAME_ALREADY_IN_USE'),\n+        (193, 'MISSING_TOKEN_NAME'),\n+        (194, 'TOKEN_NAME_TOO_LONG'),\n+        (195, 'INVALID_WIPING_AMOUNT'),\n+        (196, 'TOKEN_IS_IMMUTABlE'),\n+        (197, 'TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table with the following columns. Table will capture non shared `entity` items, most API calls may not require this information and therefore additional sql joins may be avoided.\n+    -   `token_id` (primary key)\n+    -   `create_timestamp`\n+    -   `divisibility`\n+    -   `freeze_default`\n+    -   `freeze_key`\n+    -   `initial_supply`\n+    -   `kyc_default`\n+    -   `kyc_key`\n+    -   `modify_timestamp`\n+    -   `supply_key`\n+    -   `symbol`\n+    -   `treasury_account_id`\n+    -   `wipe_key`\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+#### AccountBalance\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+#### TokenTransfer\n+-   Create new `TokenTransfer` with the following class members\n+    -   `accountId`\n+    -   `amount`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+#### EntityTypeEnum\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+        ...\n+        TOKEN(5);\n+        ...\n+    }\n+```\n+\n+#### Token\n+-   Add `Token` class to hold Token specific metadata outside of the base entity class with the following class members\n+    -   `createTimestamp`\n+    -   `divisibility`\n+    -   `freezeDefault`\n+    -   `freezeKey`\n+    -   `initialSupply`\n+    -   `kycDefault`\n+    -   `kycKey`\n+    -   `modifyTimestamp`\n+    -   `supplyKey`\n+    -   `symbol`\n+    -   `tokenId`\n+    -   `treasuryAccountId`\n+    -   `wipeKey`\n+\n+#### TokenAccount\n+-   Add `TokenAccount` class with the following class members\n+    -   `id`\n+    -   `accountId`\n+    -   `createTimestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modifyTimestamp`\n+    -   `tokenId`\n+    -   `wiped`\n+\n+#### TokenBalance\n+-   Add `TokenBalance` class with the following class members\n+    -   `accountId`\n+    -   `balance`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+### Balance Parsing\n+To support HTS the balance CSV\n+1. Adds a version comment as the first line of the file i.e. `# version:2`\n+2. Comments out the Timestamp e.g. `TimeStamp:2020-09-22T04:25:00.083212003Z`\n+3. Adds a `tokenBalances` column which is the Base64 encoding of the serialized bytes of `TokenBalances` proto.\n+\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,tokenBalances`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first line of the CSV\n+    -   If `TimeStamp` is matched use `BalanceFileReaderImplV1` as the reader\n+    -   If `# version:2` is matched use `BalanceFileReaderImplV2` as the reader\n+    -   If no `# version:2` or `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenBalance` in the `TokenBalances`\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to set Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenTransferTransactionsHandler`\n+-   Add `TokenFreezeTransactionsHandler`\n+-   Add `TokenUnfreezeTransactionsHandler`\n+-   Add `TokenGrantKycTransactionsHandler`\n+-   Add `TokenRevokeKycTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to update Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenWipeTransactionsHandler`\n+-   Add `TokenAssociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenDissociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+\n+\n+### Token Transfer Parsing\n+\n+#### EntityListener\n+-   Add a `onToken()` to handle create and updates on the `token` table\n+```java\n+    default void onToken(Token token) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenAccount()` to handle inserts and updates on the `token_account` table\n+```java\n+    default void onTokenAccount(TokenAccount tokenAccount) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenTransfer()` to handle a `token_transfer` table\n+```java\n+    default void onTokenTransfer(TokenTransfer tokenTransfer) throws ImporterException {\n+    }\n+```\n+\n+#### EntityRecordItemListener\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+Add logic to check for\n+-   `TransactionBody.hasTokenCreation()` and parse `TokenCreateTransactionBody` out from the record. Create a new `Token` object and pass it to `entityListener.onToken()`.\n+-   `TransactionBody.hasTokenTransfers()` and parse `TokenTransferLists` out from the record. Create a new `TokenTransfer` object for each `AccountAmount` in the `TokenTransferList` object and pass it to `entityListener.onTokenTransfer()`.\n+-   `TransactionBody.hasTokenAssociate()` and parse `TokenAssociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenDissociate()` and parse `TokenDissociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenFreeze()` and parse `TokenFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUnfreeze()` and parse `TokenUnFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenGrantKyc()` and parse `TokenGrantKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenRevokeKyc()` and parse `TokenRevokeKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenWipe()` and parse `TokenWipeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `wipe` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUpdate()` and parse `TokenUpdateTransactionBody` out from the record. Retrieve an existing `Token` db entry, update the appropriate columns and pass it to `entityListener.onToken()`.\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `transactions` REST API must be updated to support `tokenTransfers`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `accounts` REST API must be updated to support `tokenBalances`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<symbol>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<symbol>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"token_balances\": [\n+            {\n+              \"symbol\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"symbol\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"token_balances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"token_balances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"token_balances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"symbol\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"transfers\": [", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "originalPosition": 438}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDcyMDY1OA==", "bodyText": "The idea was to have it similar to what was noted in the design doc copied below\n{\n    \"transfers\": [ \n        {\"account\": \"0.0.1234\", \"amount\": -1000},  \n        {\"account\": \"0.0.98\", \"amount\": 1000} \n    ], \n    \"tokenTransfers\": [ \n        {\n            \"token\": \"0.0.1234\", \n            \"transfers\": [ \n                {\"account\": \"0.0.1234\", \"amount\": -1000},  \n                {\"account\": \"0.0.98\", \"amount\": 1000} \n            ]\n        }\n    ] \n}\nHowever I left out the aggregation of the token. Corrected the token_transfers object should look like this\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                          \"transfers\": [\n          \n          \n            \n                          {\n          \n          \n            \n                \"token_id\": \"0.15.3\",\n          \n          \n            \n                \"transfers\": [\n          \n          \n            \n                    {\n          \n          \n            \n                        \"account\": \"0.0.1111\",\n          \n          \n            \n                        \"amount\": -10,        \n          \n          \n            \n                    },\n          \n          \n            \n                    {\n          \n          \n            \n                        \"account\": \"0.0.2222\",\n          \n          \n            \n                        \"amount\": 10\n          \n          \n            \n                    }\n          \n          \n            \n                ]\n          \n          \n            \n            },\n          \n          \n            \n            {\n          \n          \n            \n                \"token_id\":\"0.2.4\"\n          \n          \n            \n                \"transfers\": [\n          \n          \n            \n                    {\n          \n          \n            \n                        \"account\": \"0.0.3333\",\n          \n          \n            \n                        \"amount\": -10\n          \n          \n            \n                    },\n          \n          \n            \n                    {\n          \n          \n            \n                        \"account\": \"0.0.4444\",\n          \n          \n            \n                        \"amount\": 10\n          \n          \n            \n                    }\n          \n          \n            \n                ]\n          \n          \n            \n            }", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494720658", "createdAt": "2020-09-25T03:03:13Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,631 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members\n+    -   `account_id`\n+    -   `amount`\n+    -   `consensus_timestamp`\n+    -   `token_id`\n+-   Add a `token_transfer__token_account_timestamp` index with `desc` order on columns\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances with the following columns\n+    -   `consensus_timestamp`\n+    -   `account_id`\n+    -   `balance`\n+    -   `token_id`\n+-   Create primary key as combination of `consensus_timestamp`, `token_id` and `account_id`\n+\n+### Token Account Info\n+-   Create `token_account` table to distinctly capture token account metadata changes with the following columns\n+    -   `id` (primary key)\n+    -   `account_id`\n+    -   `create_timestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modify_timestamp`\n+    -   `token_id`\n+    -   `wiped`\n+-   Create unique index `token_account__token_account`\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with `id` value of 5 and `name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+         (28, 'UNCHECKEDSUBMIT'),\n+         (29, 'TOKENCREATE'),\n+         (30, 'TOKENTRANSFER'),\n+         (31, 'TOKENFREEZE'),\n+         (32, 'TOKENUNFREEZE'),\n+         (33, 'TOKENGRANTKYC'),\n+         (34, 'TOKENREVOKEKYC'),\n+         (35, 'TOKENDELETE'),\n+         (36, 'TOKENUPDATE'),\n+         (37, 'TOKENMINT'),\n+         (38, 'TOKENBURN'),\n+         (39, 'TOKENWIPE'),\n+         (40, 'TOKENASSOCIATE'),\n+         (41, 'TOKENDISSOCIATE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP'),\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT'),\n+        (188, 'INVALID_KYC_KEY'),\n+        (189, 'INVALID_WIPE_KEY'),\n+        (190, 'INVALID_FREEZE_KEY'),\n+        (191, 'INVALID_SUPPLY_KEY'),\n+        (192, 'TOKEN_NAME_ALREADY_IN_USE'),\n+        (193, 'MISSING_TOKEN_NAME'),\n+        (194, 'TOKEN_NAME_TOO_LONG'),\n+        (195, 'INVALID_WIPING_AMOUNT'),\n+        (196, 'TOKEN_IS_IMMUTABlE'),\n+        (197, 'TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table with the following columns. Table will capture non shared `entity` items, most API calls may not require this information and therefore additional sql joins may be avoided.\n+    -   `token_id` (primary key)\n+    -   `create_timestamp`\n+    -   `divisibility`\n+    -   `freeze_default`\n+    -   `freeze_key`\n+    -   `initial_supply`\n+    -   `kyc_default`\n+    -   `kyc_key`\n+    -   `modify_timestamp`\n+    -   `supply_key`\n+    -   `symbol`\n+    -   `treasury_account_id`\n+    -   `wipe_key`\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+#### AccountBalance\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+#### TokenTransfer\n+-   Create new `TokenTransfer` with the following class members\n+    -   `accountId`\n+    -   `amount`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+#### EntityTypeEnum\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+        ...\n+        TOKEN(5);\n+        ...\n+    }\n+```\n+\n+#### Token\n+-   Add `Token` class to hold Token specific metadata outside of the base entity class with the following class members\n+    -   `createTimestamp`\n+    -   `divisibility`\n+    -   `freezeDefault`\n+    -   `freezeKey`\n+    -   `initialSupply`\n+    -   `kycDefault`\n+    -   `kycKey`\n+    -   `modifyTimestamp`\n+    -   `supplyKey`\n+    -   `symbol`\n+    -   `tokenId`\n+    -   `treasuryAccountId`\n+    -   `wipeKey`\n+\n+#### TokenAccount\n+-   Add `TokenAccount` class with the following class members\n+    -   `id`\n+    -   `accountId`\n+    -   `createTimestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modifyTimestamp`\n+    -   `tokenId`\n+    -   `wiped`\n+\n+#### TokenBalance\n+-   Add `TokenBalance` class with the following class members\n+    -   `accountId`\n+    -   `balance`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+### Balance Parsing\n+To support HTS the balance CSV\n+1. Adds a version comment as the first line of the file i.e. `# version:2`\n+2. Comments out the Timestamp e.g. `TimeStamp:2020-09-22T04:25:00.083212003Z`\n+3. Adds a `tokenBalances` column which is the Base64 encoding of the serialized bytes of `TokenBalances` proto.\n+\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,tokenBalances`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first line of the CSV\n+    -   If `TimeStamp` is matched use `BalanceFileReaderImplV1` as the reader\n+    -   If `# version:2` is matched use `BalanceFileReaderImplV2` as the reader\n+    -   If no `# version:2` or `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenBalance` in the `TokenBalances`\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to set Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenTransferTransactionsHandler`\n+-   Add `TokenFreezeTransactionsHandler`\n+-   Add `TokenUnfreezeTransactionsHandler`\n+-   Add `TokenGrantKycTransactionsHandler`\n+-   Add `TokenRevokeKycTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to update Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenWipeTransactionsHandler`\n+-   Add `TokenAssociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenDissociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+\n+\n+### Token Transfer Parsing\n+\n+#### EntityListener\n+-   Add a `onToken()` to handle create and updates on the `token` table\n+```java\n+    default void onToken(Token token) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenAccount()` to handle inserts and updates on the `token_account` table\n+```java\n+    default void onTokenAccount(TokenAccount tokenAccount) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenTransfer()` to handle a `token_transfer` table\n+```java\n+    default void onTokenTransfer(TokenTransfer tokenTransfer) throws ImporterException {\n+    }\n+```\n+\n+#### EntityRecordItemListener\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+Add logic to check for\n+-   `TransactionBody.hasTokenCreation()` and parse `TokenCreateTransactionBody` out from the record. Create a new `Token` object and pass it to `entityListener.onToken()`.\n+-   `TransactionBody.hasTokenTransfers()` and parse `TokenTransferLists` out from the record. Create a new `TokenTransfer` object for each `AccountAmount` in the `TokenTransferList` object and pass it to `entityListener.onTokenTransfer()`.\n+-   `TransactionBody.hasTokenAssociate()` and parse `TokenAssociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenDissociate()` and parse `TokenDissociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenFreeze()` and parse `TokenFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUnfreeze()` and parse `TokenUnFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenGrantKyc()` and parse `TokenGrantKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenRevokeKyc()` and parse `TokenRevokeKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenWipe()` and parse `TokenWipeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `wipe` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUpdate()` and parse `TokenUpdateTransactionBody` out from the record. Retrieve an existing `Token` db entry, update the appropriate columns and pass it to `entityListener.onToken()`.\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `transactions` REST API must be updated to support `tokenTransfers`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `accounts` REST API must be updated to support `tokenBalances`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<symbol>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<symbol>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"token_balances\": [\n+            {\n+              \"symbol\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"symbol\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"token_balances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"token_balances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"token_balances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"symbol\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"transfers\": [", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU0OTUzNQ=="}, "originalCommit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "originalPosition": 438}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDcyNDY5NA==", "bodyText": "Looks like it is possible to transfers span multiple tokens in a transaction, so grouping on a token would be useful", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494724694", "createdAt": "2020-09-25T03:20:00Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,631 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members\n+    -   `account_id`\n+    -   `amount`\n+    -   `consensus_timestamp`\n+    -   `token_id`\n+-   Add a `token_transfer__token_account_timestamp` index with `desc` order on columns\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances with the following columns\n+    -   `consensus_timestamp`\n+    -   `account_id`\n+    -   `balance`\n+    -   `token_id`\n+-   Create primary key as combination of `consensus_timestamp`, `token_id` and `account_id`\n+\n+### Token Account Info\n+-   Create `token_account` table to distinctly capture token account metadata changes with the following columns\n+    -   `id` (primary key)\n+    -   `account_id`\n+    -   `create_timestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modify_timestamp`\n+    -   `token_id`\n+    -   `wiped`\n+-   Create unique index `token_account__token_account`\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with `id` value of 5 and `name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+         (28, 'UNCHECKEDSUBMIT'),\n+         (29, 'TOKENCREATE'),\n+         (30, 'TOKENTRANSFER'),\n+         (31, 'TOKENFREEZE'),\n+         (32, 'TOKENUNFREEZE'),\n+         (33, 'TOKENGRANTKYC'),\n+         (34, 'TOKENREVOKEKYC'),\n+         (35, 'TOKENDELETE'),\n+         (36, 'TOKENUPDATE'),\n+         (37, 'TOKENMINT'),\n+         (38, 'TOKENBURN'),\n+         (39, 'TOKENWIPE'),\n+         (40, 'TOKENASSOCIATE'),\n+         (41, 'TOKENDISSOCIATE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP'),\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT'),\n+        (188, 'INVALID_KYC_KEY'),\n+        (189, 'INVALID_WIPE_KEY'),\n+        (190, 'INVALID_FREEZE_KEY'),\n+        (191, 'INVALID_SUPPLY_KEY'),\n+        (192, 'TOKEN_NAME_ALREADY_IN_USE'),\n+        (193, 'MISSING_TOKEN_NAME'),\n+        (194, 'TOKEN_NAME_TOO_LONG'),\n+        (195, 'INVALID_WIPING_AMOUNT'),\n+        (196, 'TOKEN_IS_IMMUTABlE'),\n+        (197, 'TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table with the following columns. Table will capture non shared `entity` items, most API calls may not require this information and therefore additional sql joins may be avoided.\n+    -   `token_id` (primary key)\n+    -   `create_timestamp`\n+    -   `divisibility`\n+    -   `freeze_default`\n+    -   `freeze_key`\n+    -   `initial_supply`\n+    -   `kyc_default`\n+    -   `kyc_key`\n+    -   `modify_timestamp`\n+    -   `supply_key`\n+    -   `symbol`\n+    -   `treasury_account_id`\n+    -   `wipe_key`\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+#### AccountBalance\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+#### TokenTransfer\n+-   Create new `TokenTransfer` with the following class members\n+    -   `accountId`\n+    -   `amount`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+#### EntityTypeEnum\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+        ...\n+        TOKEN(5);\n+        ...\n+    }\n+```\n+\n+#### Token\n+-   Add `Token` class to hold Token specific metadata outside of the base entity class with the following class members\n+    -   `createTimestamp`\n+    -   `divisibility`\n+    -   `freezeDefault`\n+    -   `freezeKey`\n+    -   `initialSupply`\n+    -   `kycDefault`\n+    -   `kycKey`\n+    -   `modifyTimestamp`\n+    -   `supplyKey`\n+    -   `symbol`\n+    -   `tokenId`\n+    -   `treasuryAccountId`\n+    -   `wipeKey`\n+\n+#### TokenAccount\n+-   Add `TokenAccount` class with the following class members\n+    -   `id`\n+    -   `accountId`\n+    -   `createTimestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modifyTimestamp`\n+    -   `tokenId`\n+    -   `wiped`\n+\n+#### TokenBalance\n+-   Add `TokenBalance` class with the following class members\n+    -   `accountId`\n+    -   `balance`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+### Balance Parsing\n+To support HTS the balance CSV\n+1. Adds a version comment as the first line of the file i.e. `# version:2`\n+2. Comments out the Timestamp e.g. `TimeStamp:2020-09-22T04:25:00.083212003Z`\n+3. Adds a `tokenBalances` column which is the Base64 encoding of the serialized bytes of `TokenBalances` proto.\n+\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,tokenBalances`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first line of the CSV\n+    -   If `TimeStamp` is matched use `BalanceFileReaderImplV1` as the reader\n+    -   If `# version:2` is matched use `BalanceFileReaderImplV2` as the reader\n+    -   If no `# version:2` or `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenBalance` in the `TokenBalances`\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to set Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenTransferTransactionsHandler`\n+-   Add `TokenFreezeTransactionsHandler`\n+-   Add `TokenUnfreezeTransactionsHandler`\n+-   Add `TokenGrantKycTransactionsHandler`\n+-   Add `TokenRevokeKycTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to update Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenWipeTransactionsHandler`\n+-   Add `TokenAssociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenDissociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+\n+\n+### Token Transfer Parsing\n+\n+#### EntityListener\n+-   Add a `onToken()` to handle create and updates on the `token` table\n+```java\n+    default void onToken(Token token) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenAccount()` to handle inserts and updates on the `token_account` table\n+```java\n+    default void onTokenAccount(TokenAccount tokenAccount) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenTransfer()` to handle a `token_transfer` table\n+```java\n+    default void onTokenTransfer(TokenTransfer tokenTransfer) throws ImporterException {\n+    }\n+```\n+\n+#### EntityRecordItemListener\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+Add logic to check for\n+-   `TransactionBody.hasTokenCreation()` and parse `TokenCreateTransactionBody` out from the record. Create a new `Token` object and pass it to `entityListener.onToken()`.\n+-   `TransactionBody.hasTokenTransfers()` and parse `TokenTransferLists` out from the record. Create a new `TokenTransfer` object for each `AccountAmount` in the `TokenTransferList` object and pass it to `entityListener.onTokenTransfer()`.\n+-   `TransactionBody.hasTokenAssociate()` and parse `TokenAssociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenDissociate()` and parse `TokenDissociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenFreeze()` and parse `TokenFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUnfreeze()` and parse `TokenUnFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenGrantKyc()` and parse `TokenGrantKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenRevokeKyc()` and parse `TokenRevokeKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenWipe()` and parse `TokenWipeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `wipe` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUpdate()` and parse `TokenUpdateTransactionBody` out from the record. Retrieve an existing `Token` db entry, update the appropriate columns and pass it to `entityListener.onToken()`.\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `transactions` REST API must be updated to support `tokenTransfers`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `accounts` REST API must be updated to support `tokenBalances`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<symbol>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<symbol>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"token_balances\": [\n+            {\n+              \"symbol\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"symbol\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"token_balances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"token_balances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"token_balances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"symbol\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"transfers\": [", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU0OTUzNQ=="}, "originalCommit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "originalPosition": 438}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTIwODk3MA==", "bodyText": "We had said before in a previous comment that we were okay with the duplication since it matches the database and proto structure more.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r495208970", "createdAt": "2020-09-25T20:12:25Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,631 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members\n+    -   `account_id`\n+    -   `amount`\n+    -   `consensus_timestamp`\n+    -   `token_id`\n+-   Add a `token_transfer__token_account_timestamp` index with `desc` order on columns\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances with the following columns\n+    -   `consensus_timestamp`\n+    -   `account_id`\n+    -   `balance`\n+    -   `token_id`\n+-   Create primary key as combination of `consensus_timestamp`, `token_id` and `account_id`\n+\n+### Token Account Info\n+-   Create `token_account` table to distinctly capture token account metadata changes with the following columns\n+    -   `id` (primary key)\n+    -   `account_id`\n+    -   `create_timestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modify_timestamp`\n+    -   `token_id`\n+    -   `wiped`\n+-   Create unique index `token_account__token_account`\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with `id` value of 5 and `name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+         (28, 'UNCHECKEDSUBMIT'),\n+         (29, 'TOKENCREATE'),\n+         (30, 'TOKENTRANSFER'),\n+         (31, 'TOKENFREEZE'),\n+         (32, 'TOKENUNFREEZE'),\n+         (33, 'TOKENGRANTKYC'),\n+         (34, 'TOKENREVOKEKYC'),\n+         (35, 'TOKENDELETE'),\n+         (36, 'TOKENUPDATE'),\n+         (37, 'TOKENMINT'),\n+         (38, 'TOKENBURN'),\n+         (39, 'TOKENWIPE'),\n+         (40, 'TOKENASSOCIATE'),\n+         (41, 'TOKENDISSOCIATE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP'),\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT'),\n+        (188, 'INVALID_KYC_KEY'),\n+        (189, 'INVALID_WIPE_KEY'),\n+        (190, 'INVALID_FREEZE_KEY'),\n+        (191, 'INVALID_SUPPLY_KEY'),\n+        (192, 'TOKEN_NAME_ALREADY_IN_USE'),\n+        (193, 'MISSING_TOKEN_NAME'),\n+        (194, 'TOKEN_NAME_TOO_LONG'),\n+        (195, 'INVALID_WIPING_AMOUNT'),\n+        (196, 'TOKEN_IS_IMMUTABlE'),\n+        (197, 'TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table with the following columns. Table will capture non shared `entity` items, most API calls may not require this information and therefore additional sql joins may be avoided.\n+    -   `token_id` (primary key)\n+    -   `create_timestamp`\n+    -   `divisibility`\n+    -   `freeze_default`\n+    -   `freeze_key`\n+    -   `initial_supply`\n+    -   `kyc_default`\n+    -   `kyc_key`\n+    -   `modify_timestamp`\n+    -   `supply_key`\n+    -   `symbol`\n+    -   `treasury_account_id`\n+    -   `wipe_key`\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+#### AccountBalance\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+#### TokenTransfer\n+-   Create new `TokenTransfer` with the following class members\n+    -   `accountId`\n+    -   `amount`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+#### EntityTypeEnum\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+        ...\n+        TOKEN(5);\n+        ...\n+    }\n+```\n+\n+#### Token\n+-   Add `Token` class to hold Token specific metadata outside of the base entity class with the following class members\n+    -   `createTimestamp`\n+    -   `divisibility`\n+    -   `freezeDefault`\n+    -   `freezeKey`\n+    -   `initialSupply`\n+    -   `kycDefault`\n+    -   `kycKey`\n+    -   `modifyTimestamp`\n+    -   `supplyKey`\n+    -   `symbol`\n+    -   `tokenId`\n+    -   `treasuryAccountId`\n+    -   `wipeKey`\n+\n+#### TokenAccount\n+-   Add `TokenAccount` class with the following class members\n+    -   `id`\n+    -   `accountId`\n+    -   `createTimestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modifyTimestamp`\n+    -   `tokenId`\n+    -   `wiped`\n+\n+#### TokenBalance\n+-   Add `TokenBalance` class with the following class members\n+    -   `accountId`\n+    -   `balance`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+### Balance Parsing\n+To support HTS the balance CSV\n+1. Adds a version comment as the first line of the file i.e. `# version:2`\n+2. Comments out the Timestamp e.g. `TimeStamp:2020-09-22T04:25:00.083212003Z`\n+3. Adds a `tokenBalances` column which is the Base64 encoding of the serialized bytes of `TokenBalances` proto.\n+\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,tokenBalances`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first line of the CSV\n+    -   If `TimeStamp` is matched use `BalanceFileReaderImplV1` as the reader\n+    -   If `# version:2` is matched use `BalanceFileReaderImplV2` as the reader\n+    -   If no `# version:2` or `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenBalance` in the `TokenBalances`\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to set Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenTransferTransactionsHandler`\n+-   Add `TokenFreezeTransactionsHandler`\n+-   Add `TokenUnfreezeTransactionsHandler`\n+-   Add `TokenGrantKycTransactionsHandler`\n+-   Add `TokenRevokeKycTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to update Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenWipeTransactionsHandler`\n+-   Add `TokenAssociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenDissociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+\n+\n+### Token Transfer Parsing\n+\n+#### EntityListener\n+-   Add a `onToken()` to handle create and updates on the `token` table\n+```java\n+    default void onToken(Token token) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenAccount()` to handle inserts and updates on the `token_account` table\n+```java\n+    default void onTokenAccount(TokenAccount tokenAccount) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenTransfer()` to handle a `token_transfer` table\n+```java\n+    default void onTokenTransfer(TokenTransfer tokenTransfer) throws ImporterException {\n+    }\n+```\n+\n+#### EntityRecordItemListener\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+Add logic to check for\n+-   `TransactionBody.hasTokenCreation()` and parse `TokenCreateTransactionBody` out from the record. Create a new `Token` object and pass it to `entityListener.onToken()`.\n+-   `TransactionBody.hasTokenTransfers()` and parse `TokenTransferLists` out from the record. Create a new `TokenTransfer` object for each `AccountAmount` in the `TokenTransferList` object and pass it to `entityListener.onTokenTransfer()`.\n+-   `TransactionBody.hasTokenAssociate()` and parse `TokenAssociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenDissociate()` and parse `TokenDissociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenFreeze()` and parse `TokenFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUnfreeze()` and parse `TokenUnFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenGrantKyc()` and parse `TokenGrantKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenRevokeKyc()` and parse `TokenRevokeKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenWipe()` and parse `TokenWipeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `wipe` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUpdate()` and parse `TokenUpdateTransactionBody` out from the record. Retrieve an existing `Token` db entry, update the appropriate columns and pass it to `entityListener.onToken()`.\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `transactions` REST API must be updated to support `tokenTransfers`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `accounts` REST API must be updated to support `tokenBalances`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<symbol>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<symbol>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"token_balances\": [\n+            {\n+              \"symbol\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"symbol\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"token_balances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"token_balances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"token_balances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"symbol\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"transfers\": [", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU0OTUzNQ=="}, "originalCommit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "originalPosition": 438}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMxMTAxNA==", "bodyText": "Yep, thanks for circling back. Will change to\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                          \"transfers\": [\n          \n          \n            \n                          \"token_transfers\": [\n          \n          \n            \n                {\n          \n          \n            \n                    \"token_id\": \"0.15.3\",\n          \n          \n            \n                    \"account\": \"0.0.1111\",\n          \n          \n            \n                    \"amount\": -10\n          \n          \n            \n                },\n          \n          \n            \n                {\n          \n          \n            \n                    \"token_id\": \"0.15.3\",\n          \n          \n            \n                    \"account\": \"0.0.2222\",\n          \n          \n            \n                    \"amount\": -10\n          \n          \n            \n                },\n          \n          \n            \n                {\n          \n          \n            \n                    \"token_id\": \"0.2.4\",\n          \n          \n            \n                    \"account\": \"0.0.3333\",\n          \n          \n            \n                    \"amount\": -10\n          \n          \n            \n                },\n          \n          \n            \n                {\n          \n          \n            \n                    \"token_id\": \"0.2.4\",\n          \n          \n            \n                    \"account\": \"0.0.4444\",\n          \n          \n            \n                    \"amount\": -10\n          \n          \n            \n                }\n          \n          \n            \n            ]", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r495311014", "createdAt": "2020-09-25T23:16:49Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,631 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members\n+    -   `account_id`\n+    -   `amount`\n+    -   `consensus_timestamp`\n+    -   `token_id`\n+-   Add a `token_transfer__token_account_timestamp` index with `desc` order on columns\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances with the following columns\n+    -   `consensus_timestamp`\n+    -   `account_id`\n+    -   `balance`\n+    -   `token_id`\n+-   Create primary key as combination of `consensus_timestamp`, `token_id` and `account_id`\n+\n+### Token Account Info\n+-   Create `token_account` table to distinctly capture token account metadata changes with the following columns\n+    -   `id` (primary key)\n+    -   `account_id`\n+    -   `create_timestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modify_timestamp`\n+    -   `token_id`\n+    -   `wiped`\n+-   Create unique index `token_account__token_account`\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with `id` value of 5 and `name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+         (28, 'UNCHECKEDSUBMIT'),\n+         (29, 'TOKENCREATE'),\n+         (30, 'TOKENTRANSFER'),\n+         (31, 'TOKENFREEZE'),\n+         (32, 'TOKENUNFREEZE'),\n+         (33, 'TOKENGRANTKYC'),\n+         (34, 'TOKENREVOKEKYC'),\n+         (35, 'TOKENDELETE'),\n+         (36, 'TOKENUPDATE'),\n+         (37, 'TOKENMINT'),\n+         (38, 'TOKENBURN'),\n+         (39, 'TOKENWIPE'),\n+         (40, 'TOKENASSOCIATE'),\n+         (41, 'TOKENDISSOCIATE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP'),\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT'),\n+        (188, 'INVALID_KYC_KEY'),\n+        (189, 'INVALID_WIPE_KEY'),\n+        (190, 'INVALID_FREEZE_KEY'),\n+        (191, 'INVALID_SUPPLY_KEY'),\n+        (192, 'TOKEN_NAME_ALREADY_IN_USE'),\n+        (193, 'MISSING_TOKEN_NAME'),\n+        (194, 'TOKEN_NAME_TOO_LONG'),\n+        (195, 'INVALID_WIPING_AMOUNT'),\n+        (196, 'TOKEN_IS_IMMUTABlE'),\n+        (197, 'TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table with the following columns. Table will capture non shared `entity` items, most API calls may not require this information and therefore additional sql joins may be avoided.\n+    -   `token_id` (primary key)\n+    -   `create_timestamp`\n+    -   `divisibility`\n+    -   `freeze_default`\n+    -   `freeze_key`\n+    -   `initial_supply`\n+    -   `kyc_default`\n+    -   `kyc_key`\n+    -   `modify_timestamp`\n+    -   `supply_key`\n+    -   `symbol`\n+    -   `treasury_account_id`\n+    -   `wipe_key`\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+#### AccountBalance\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+#### TokenTransfer\n+-   Create new `TokenTransfer` with the following class members\n+    -   `accountId`\n+    -   `amount`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+#### EntityTypeEnum\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+        ...\n+        TOKEN(5);\n+        ...\n+    }\n+```\n+\n+#### Token\n+-   Add `Token` class to hold Token specific metadata outside of the base entity class with the following class members\n+    -   `createTimestamp`\n+    -   `divisibility`\n+    -   `freezeDefault`\n+    -   `freezeKey`\n+    -   `initialSupply`\n+    -   `kycDefault`\n+    -   `kycKey`\n+    -   `modifyTimestamp`\n+    -   `supplyKey`\n+    -   `symbol`\n+    -   `tokenId`\n+    -   `treasuryAccountId`\n+    -   `wipeKey`\n+\n+#### TokenAccount\n+-   Add `TokenAccount` class with the following class members\n+    -   `id`\n+    -   `accountId`\n+    -   `createTimestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modifyTimestamp`\n+    -   `tokenId`\n+    -   `wiped`\n+\n+#### TokenBalance\n+-   Add `TokenBalance` class with the following class members\n+    -   `accountId`\n+    -   `balance`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+### Balance Parsing\n+To support HTS the balance CSV\n+1. Adds a version comment as the first line of the file i.e. `# version:2`\n+2. Comments out the Timestamp e.g. `TimeStamp:2020-09-22T04:25:00.083212003Z`\n+3. Adds a `tokenBalances` column which is the Base64 encoding of the serialized bytes of `TokenBalances` proto.\n+\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,tokenBalances`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first line of the CSV\n+    -   If `TimeStamp` is matched use `BalanceFileReaderImplV1` as the reader\n+    -   If `# version:2` is matched use `BalanceFileReaderImplV2` as the reader\n+    -   If no `# version:2` or `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenBalance` in the `TokenBalances`\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to set Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenTransferTransactionsHandler`\n+-   Add `TokenFreezeTransactionsHandler`\n+-   Add `TokenUnfreezeTransactionsHandler`\n+-   Add `TokenGrantKycTransactionsHandler`\n+-   Add `TokenRevokeKycTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to update Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenWipeTransactionsHandler`\n+-   Add `TokenAssociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenDissociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+\n+\n+### Token Transfer Parsing\n+\n+#### EntityListener\n+-   Add a `onToken()` to handle create and updates on the `token` table\n+```java\n+    default void onToken(Token token) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenAccount()` to handle inserts and updates on the `token_account` table\n+```java\n+    default void onTokenAccount(TokenAccount tokenAccount) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenTransfer()` to handle a `token_transfer` table\n+```java\n+    default void onTokenTransfer(TokenTransfer tokenTransfer) throws ImporterException {\n+    }\n+```\n+\n+#### EntityRecordItemListener\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+Add logic to check for\n+-   `TransactionBody.hasTokenCreation()` and parse `TokenCreateTransactionBody` out from the record. Create a new `Token` object and pass it to `entityListener.onToken()`.\n+-   `TransactionBody.hasTokenTransfers()` and parse `TokenTransferLists` out from the record. Create a new `TokenTransfer` object for each `AccountAmount` in the `TokenTransferList` object and pass it to `entityListener.onTokenTransfer()`.\n+-   `TransactionBody.hasTokenAssociate()` and parse `TokenAssociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenDissociate()` and parse `TokenDissociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenFreeze()` and parse `TokenFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUnfreeze()` and parse `TokenUnFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenGrantKyc()` and parse `TokenGrantKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenRevokeKyc()` and parse `TokenRevokeKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenWipe()` and parse `TokenWipeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `wipe` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUpdate()` and parse `TokenUpdateTransactionBody` out from the record. Retrieve an existing `Token` db entry, update the appropriate columns and pass it to `entityListener.onToken()`.\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `transactions` REST API must be updated to support `tokenTransfers`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `accounts` REST API must be updated to support `tokenBalances`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<symbol>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<symbol>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"token_balances\": [\n+            {\n+              \"symbol\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"symbol\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"token_balances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"token_balances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"token_balances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"symbol\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"transfers\": [", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU0OTUzNQ=="}, "originalCommit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "originalPosition": 438}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NTUxMzAyOnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMDozOTozM1rOHXr0Dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwMzoyMTozMVrOHXzn5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU5NzEzNQ==", "bodyText": "Missing URL format. Can probably remove this code related line.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494597135", "createdAt": "2020-09-24T20:39:33Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,631 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members\n+    -   `account_id`\n+    -   `amount`\n+    -   `consensus_timestamp`\n+    -   `token_id`\n+-   Add a `token_transfer__token_account_timestamp` index with `desc` order on columns\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances with the following columns\n+    -   `consensus_timestamp`\n+    -   `account_id`\n+    -   `balance`\n+    -   `token_id`\n+-   Create primary key as combination of `consensus_timestamp`, `token_id` and `account_id`\n+\n+### Token Account Info\n+-   Create `token_account` table to distinctly capture token account metadata changes with the following columns\n+    -   `id` (primary key)\n+    -   `account_id`\n+    -   `create_timestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modify_timestamp`\n+    -   `token_id`\n+    -   `wiped`\n+-   Create unique index `token_account__token_account`\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with `id` value of 5 and `name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+         (28, 'UNCHECKEDSUBMIT'),\n+         (29, 'TOKENCREATE'),\n+         (30, 'TOKENTRANSFER'),\n+         (31, 'TOKENFREEZE'),\n+         (32, 'TOKENUNFREEZE'),\n+         (33, 'TOKENGRANTKYC'),\n+         (34, 'TOKENREVOKEKYC'),\n+         (35, 'TOKENDELETE'),\n+         (36, 'TOKENUPDATE'),\n+         (37, 'TOKENMINT'),\n+         (38, 'TOKENBURN'),\n+         (39, 'TOKENWIPE'),\n+         (40, 'TOKENASSOCIATE'),\n+         (41, 'TOKENDISSOCIATE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP'),\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT'),\n+        (188, 'INVALID_KYC_KEY'),\n+        (189, 'INVALID_WIPE_KEY'),\n+        (190, 'INVALID_FREEZE_KEY'),\n+        (191, 'INVALID_SUPPLY_KEY'),\n+        (192, 'TOKEN_NAME_ALREADY_IN_USE'),\n+        (193, 'MISSING_TOKEN_NAME'),\n+        (194, 'TOKEN_NAME_TOO_LONG'),\n+        (195, 'INVALID_WIPING_AMOUNT'),\n+        (196, 'TOKEN_IS_IMMUTABlE'),\n+        (197, 'TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table with the following columns. Table will capture non shared `entity` items, most API calls may not require this information and therefore additional sql joins may be avoided.\n+    -   `token_id` (primary key)\n+    -   `create_timestamp`\n+    -   `divisibility`\n+    -   `freeze_default`\n+    -   `freeze_key`\n+    -   `initial_supply`\n+    -   `kyc_default`\n+    -   `kyc_key`\n+    -   `modify_timestamp`\n+    -   `supply_key`\n+    -   `symbol`\n+    -   `treasury_account_id`\n+    -   `wipe_key`\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+#### AccountBalance\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+#### TokenTransfer\n+-   Create new `TokenTransfer` with the following class members\n+    -   `accountId`\n+    -   `amount`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+#### EntityTypeEnum\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+        ...\n+        TOKEN(5);\n+        ...\n+    }\n+```\n+\n+#### Token\n+-   Add `Token` class to hold Token specific metadata outside of the base entity class with the following class members\n+    -   `createTimestamp`\n+    -   `divisibility`\n+    -   `freezeDefault`\n+    -   `freezeKey`\n+    -   `initialSupply`\n+    -   `kycDefault`\n+    -   `kycKey`\n+    -   `modifyTimestamp`\n+    -   `supplyKey`\n+    -   `symbol`\n+    -   `tokenId`\n+    -   `treasuryAccountId`\n+    -   `wipeKey`\n+\n+#### TokenAccount\n+-   Add `TokenAccount` class with the following class members\n+    -   `id`\n+    -   `accountId`\n+    -   `createTimestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modifyTimestamp`\n+    -   `tokenId`\n+    -   `wiped`\n+\n+#### TokenBalance\n+-   Add `TokenBalance` class with the following class members\n+    -   `accountId`\n+    -   `balance`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+### Balance Parsing\n+To support HTS the balance CSV\n+1. Adds a version comment as the first line of the file i.e. `# version:2`\n+2. Comments out the Timestamp e.g. `TimeStamp:2020-09-22T04:25:00.083212003Z`\n+3. Adds a `tokenBalances` column which is the Base64 encoding of the serialized bytes of `TokenBalances` proto.\n+\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,tokenBalances`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first line of the CSV\n+    -   If `TimeStamp` is matched use `BalanceFileReaderImplV1` as the reader\n+    -   If `# version:2` is matched use `BalanceFileReaderImplV2` as the reader\n+    -   If no `# version:2` or `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenBalance` in the `TokenBalances`\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to set Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenTransferTransactionsHandler`\n+-   Add `TokenFreezeTransactionsHandler`\n+-   Add `TokenUnfreezeTransactionsHandler`\n+-   Add `TokenGrantKycTransactionsHandler`\n+-   Add `TokenRevokeKycTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to update Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenWipeTransactionsHandler`\n+-   Add `TokenAssociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenDissociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+\n+\n+### Token Transfer Parsing\n+\n+#### EntityListener\n+-   Add a `onToken()` to handle create and updates on the `token` table\n+```java\n+    default void onToken(Token token) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenAccount()` to handle inserts and updates on the `token_account` table\n+```java\n+    default void onTokenAccount(TokenAccount tokenAccount) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenTransfer()` to handle a `token_transfer` table\n+```java\n+    default void onTokenTransfer(TokenTransfer tokenTransfer) throws ImporterException {\n+    }\n+```\n+\n+#### EntityRecordItemListener\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+Add logic to check for\n+-   `TransactionBody.hasTokenCreation()` and parse `TokenCreateTransactionBody` out from the record. Create a new `Token` object and pass it to `entityListener.onToken()`.\n+-   `TransactionBody.hasTokenTransfers()` and parse `TokenTransferLists` out from the record. Create a new `TokenTransfer` object for each `AccountAmount` in the `TokenTransferList` object and pass it to `entityListener.onTokenTransfer()`.\n+-   `TransactionBody.hasTokenAssociate()` and parse `TokenAssociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenDissociate()` and parse `TokenDissociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenFreeze()` and parse `TokenFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUnfreeze()` and parse `TokenUnFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenGrantKyc()` and parse `TokenGrantKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenRevokeKyc()` and parse `TokenRevokeKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenWipe()` and parse `TokenWipeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `wipe` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUpdate()` and parse `TokenUpdateTransactionBody` out from the record. Retrieve an existing `Token` db entry, update the appropriate columns and pass it to `entityListener.onToken()`.\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `transactions` REST API must be updated to support `tokenTransfers`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `accounts` REST API must be updated to support `tokenBalances`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<symbol>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<symbol>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"token_balances\": [\n+            {\n+              \"symbol\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"symbol\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"token_balances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"token_balances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"token_balances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"symbol\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"transfers\": [\n+                {\n+                  \"account\": \"0.0.1111\",\n+                  \"amount\": -10,\n+                  \"symbol\": \"FOOBAR\"\n+                },\n+                {\n+                  \"account\": \"0.0.2222\",\n+                  \"amount\": 10,\n+                  \"symbol\": \"FOOBAR\"\n+                }\n+              ]\n+            },\n+            {\n+              \"transfers\": [\n+                {\n+                  \"account\": \"0.0.3333\",\n+                  \"amount\": -10,\n+                  \"symbol\":\"FOOCOIN\"\n+                },\n+                {\n+                  \"account\": \"0.0.4444\",\n+                  \"amount\": 10,\n+                  \"symbol\":\"FOOCOIN\"\n+                }\n+               ]\n+            }\n+          ]\n+        }\n+      ]\n+    }\n+```\n+\n+### Token Supply distribution\n+\n+`/api/v1/tokens/<symbol>/balances` this could be the equivalent of `/api/v1/balances?symbol=<symbol>` currently and would return a list of account and the token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.15.10\",\n+            \"balance\": 100\n+          },\n+          {\n+            \"account\": \"0.15.9\",\n+            \"balance\": 90\n+          },\n+          {\n+            \"account\": \"0.15.8\",\n+            \"balance\": 80\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens/<symbol>/balances?id=0.0.1000`\n+-   `/api/v1/tokens/<symbol>/balances?balance=gt:1000`\n+-   `/api/v1/tokens/<symbol>/balances?timestamp=1566562500.040961001`\n+\n+### Token Discovery\n+`/api/v1/tokens` this would return all tokens present on the network\n+\n+```json\n+    {\n+        \"tokens\": [\n+          {\n+            \"symbol\": \"FOOBAR\",\n+            \"token_id\": \"0.15.10\",\n+            \"admin_key\": {\n+              \"_type\": \"ProtobufEncoded\",\n+              \"key\": \"7b2233222c2233222c2233227d\"\n+            }\n+          },\n+          {\n+            \"symbol\": \"FOOCOIN\",\n+            \"tokenId\": \"0.15.11\",\n+            \"admin_key\": {\n+              \"_type\": \"ProtobufEncoded\",\n+              \"key\": \"9c2233222c2233222c2233227d\"\n+            }\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens?publickey=3c3d546321ff6f63d701d2ec5c277095874e19f4a235bee1e6bb19258bf362be` - All tokens with matching admin key\n+-   `/api/v1/tokens?account.id=0.0.8` - All tokens for matching account\n+\n+### Token Info\n+-   Add a `getTokenInfo()` to `tokens.js` to retrieve token info from `token` table", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "originalPosition": 536}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDcyNTA5NA==", "bodyText": "Added and removed", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494725094", "createdAt": "2020-09-25T03:21:31Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,631 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members\n+    -   `account_id`\n+    -   `amount`\n+    -   `consensus_timestamp`\n+    -   `token_id`\n+-   Add a `token_transfer__token_account_timestamp` index with `desc` order on columns\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances with the following columns\n+    -   `consensus_timestamp`\n+    -   `account_id`\n+    -   `balance`\n+    -   `token_id`\n+-   Create primary key as combination of `consensus_timestamp`, `token_id` and `account_id`\n+\n+### Token Account Info\n+-   Create `token_account` table to distinctly capture token account metadata changes with the following columns\n+    -   `id` (primary key)\n+    -   `account_id`\n+    -   `create_timestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modify_timestamp`\n+    -   `token_id`\n+    -   `wiped`\n+-   Create unique index `token_account__token_account`\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with `id` value of 5 and `name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+         (28, 'UNCHECKEDSUBMIT'),\n+         (29, 'TOKENCREATE'),\n+         (30, 'TOKENTRANSFER'),\n+         (31, 'TOKENFREEZE'),\n+         (32, 'TOKENUNFREEZE'),\n+         (33, 'TOKENGRANTKYC'),\n+         (34, 'TOKENREVOKEKYC'),\n+         (35, 'TOKENDELETE'),\n+         (36, 'TOKENUPDATE'),\n+         (37, 'TOKENMINT'),\n+         (38, 'TOKENBURN'),\n+         (39, 'TOKENWIPE'),\n+         (40, 'TOKENASSOCIATE'),\n+         (41, 'TOKENDISSOCIATE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP'),\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT'),\n+        (188, 'INVALID_KYC_KEY'),\n+        (189, 'INVALID_WIPE_KEY'),\n+        (190, 'INVALID_FREEZE_KEY'),\n+        (191, 'INVALID_SUPPLY_KEY'),\n+        (192, 'TOKEN_NAME_ALREADY_IN_USE'),\n+        (193, 'MISSING_TOKEN_NAME'),\n+        (194, 'TOKEN_NAME_TOO_LONG'),\n+        (195, 'INVALID_WIPING_AMOUNT'),\n+        (196, 'TOKEN_IS_IMMUTABlE'),\n+        (197, 'TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table with the following columns. Table will capture non shared `entity` items, most API calls may not require this information and therefore additional sql joins may be avoided.\n+    -   `token_id` (primary key)\n+    -   `create_timestamp`\n+    -   `divisibility`\n+    -   `freeze_default`\n+    -   `freeze_key`\n+    -   `initial_supply`\n+    -   `kyc_default`\n+    -   `kyc_key`\n+    -   `modify_timestamp`\n+    -   `supply_key`\n+    -   `symbol`\n+    -   `treasury_account_id`\n+    -   `wipe_key`\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+#### AccountBalance\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+#### TokenTransfer\n+-   Create new `TokenTransfer` with the following class members\n+    -   `accountId`\n+    -   `amount`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+#### EntityTypeEnum\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+        ...\n+        TOKEN(5);\n+        ...\n+    }\n+```\n+\n+#### Token\n+-   Add `Token` class to hold Token specific metadata outside of the base entity class with the following class members\n+    -   `createTimestamp`\n+    -   `divisibility`\n+    -   `freezeDefault`\n+    -   `freezeKey`\n+    -   `initialSupply`\n+    -   `kycDefault`\n+    -   `kycKey`\n+    -   `modifyTimestamp`\n+    -   `supplyKey`\n+    -   `symbol`\n+    -   `tokenId`\n+    -   `treasuryAccountId`\n+    -   `wipeKey`\n+\n+#### TokenAccount\n+-   Add `TokenAccount` class with the following class members\n+    -   `id`\n+    -   `accountId`\n+    -   `createTimestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modifyTimestamp`\n+    -   `tokenId`\n+    -   `wiped`\n+\n+#### TokenBalance\n+-   Add `TokenBalance` class with the following class members\n+    -   `accountId`\n+    -   `balance`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+### Balance Parsing\n+To support HTS the balance CSV\n+1. Adds a version comment as the first line of the file i.e. `# version:2`\n+2. Comments out the Timestamp e.g. `TimeStamp:2020-09-22T04:25:00.083212003Z`\n+3. Adds a `tokenBalances` column which is the Base64 encoding of the serialized bytes of `TokenBalances` proto.\n+\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,tokenBalances`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first line of the CSV\n+    -   If `TimeStamp` is matched use `BalanceFileReaderImplV1` as the reader\n+    -   If `# version:2` is matched use `BalanceFileReaderImplV2` as the reader\n+    -   If no `# version:2` or `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenBalance` in the `TokenBalances`\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to set Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenTransferTransactionsHandler`\n+-   Add `TokenFreezeTransactionsHandler`\n+-   Add `TokenUnfreezeTransactionsHandler`\n+-   Add `TokenGrantKycTransactionsHandler`\n+-   Add `TokenRevokeKycTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to update Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenWipeTransactionsHandler`\n+-   Add `TokenAssociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenDissociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+\n+\n+### Token Transfer Parsing\n+\n+#### EntityListener\n+-   Add a `onToken()` to handle create and updates on the `token` table\n+```java\n+    default void onToken(Token token) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenAccount()` to handle inserts and updates on the `token_account` table\n+```java\n+    default void onTokenAccount(TokenAccount tokenAccount) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenTransfer()` to handle a `token_transfer` table\n+```java\n+    default void onTokenTransfer(TokenTransfer tokenTransfer) throws ImporterException {\n+    }\n+```\n+\n+#### EntityRecordItemListener\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+Add logic to check for\n+-   `TransactionBody.hasTokenCreation()` and parse `TokenCreateTransactionBody` out from the record. Create a new `Token` object and pass it to `entityListener.onToken()`.\n+-   `TransactionBody.hasTokenTransfers()` and parse `TokenTransferLists` out from the record. Create a new `TokenTransfer` object for each `AccountAmount` in the `TokenTransferList` object and pass it to `entityListener.onTokenTransfer()`.\n+-   `TransactionBody.hasTokenAssociate()` and parse `TokenAssociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenDissociate()` and parse `TokenDissociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenFreeze()` and parse `TokenFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUnfreeze()` and parse `TokenUnFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenGrantKyc()` and parse `TokenGrantKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenRevokeKyc()` and parse `TokenRevokeKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenWipe()` and parse `TokenWipeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `wipe` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUpdate()` and parse `TokenUpdateTransactionBody` out from the record. Retrieve an existing `Token` db entry, update the appropriate columns and pass it to `entityListener.onToken()`.\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `transactions` REST API must be updated to support `tokenTransfers`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `accounts` REST API must be updated to support `tokenBalances`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<symbol>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<symbol>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"token_balances\": [\n+            {\n+              \"symbol\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"symbol\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"token_balances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"token_balances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"token_balances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"symbol\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"transfers\": [\n+                {\n+                  \"account\": \"0.0.1111\",\n+                  \"amount\": -10,\n+                  \"symbol\": \"FOOBAR\"\n+                },\n+                {\n+                  \"account\": \"0.0.2222\",\n+                  \"amount\": 10,\n+                  \"symbol\": \"FOOBAR\"\n+                }\n+              ]\n+            },\n+            {\n+              \"transfers\": [\n+                {\n+                  \"account\": \"0.0.3333\",\n+                  \"amount\": -10,\n+                  \"symbol\":\"FOOCOIN\"\n+                },\n+                {\n+                  \"account\": \"0.0.4444\",\n+                  \"amount\": 10,\n+                  \"symbol\":\"FOOCOIN\"\n+                }\n+               ]\n+            }\n+          ]\n+        }\n+      ]\n+    }\n+```\n+\n+### Token Supply distribution\n+\n+`/api/v1/tokens/<symbol>/balances` this could be the equivalent of `/api/v1/balances?symbol=<symbol>` currently and would return a list of account and the token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.15.10\",\n+            \"balance\": 100\n+          },\n+          {\n+            \"account\": \"0.15.9\",\n+            \"balance\": 90\n+          },\n+          {\n+            \"account\": \"0.15.8\",\n+            \"balance\": 80\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens/<symbol>/balances?id=0.0.1000`\n+-   `/api/v1/tokens/<symbol>/balances?balance=gt:1000`\n+-   `/api/v1/tokens/<symbol>/balances?timestamp=1566562500.040961001`\n+\n+### Token Discovery\n+`/api/v1/tokens` this would return all tokens present on the network\n+\n+```json\n+    {\n+        \"tokens\": [\n+          {\n+            \"symbol\": \"FOOBAR\",\n+            \"token_id\": \"0.15.10\",\n+            \"admin_key\": {\n+              \"_type\": \"ProtobufEncoded\",\n+              \"key\": \"7b2233222c2233222c2233227d\"\n+            }\n+          },\n+          {\n+            \"symbol\": \"FOOCOIN\",\n+            \"tokenId\": \"0.15.11\",\n+            \"admin_key\": {\n+              \"_type\": \"ProtobufEncoded\",\n+              \"key\": \"9c2233222c2233222c2233227d\"\n+            }\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens?publickey=3c3d546321ff6f63d701d2ec5c277095874e19f4a235bee1e6bb19258bf362be` - All tokens with matching admin key\n+-   `/api/v1/tokens?account.id=0.0.8` - All tokens for matching account\n+\n+### Token Info\n+-   Add a `getTokenInfo()` to `tokens.js` to retrieve token info from `token` table", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU5NzEzNQ=="}, "originalCommit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "originalPosition": 536}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NTU0NzM1OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMDo1MDowN1rOHXsI6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMDo1MDowN1rOHXsI6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYwMjQ3Mw==", "bodyText": "Returns should be tokenId.\nToken API would be the place where both can be returned", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494602473", "createdAt": "2020-09-24T20:50:07Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,631 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members\n+    -   `account_id`\n+    -   `amount`\n+    -   `consensus_timestamp`\n+    -   `token_id`\n+-   Add a `token_transfer__token_account_timestamp` index with `desc` order on columns\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances with the following columns\n+    -   `consensus_timestamp`\n+    -   `account_id`\n+    -   `balance`\n+    -   `token_id`\n+-   Create primary key as combination of `consensus_timestamp`, `token_id` and `account_id`\n+\n+### Token Account Info\n+-   Create `token_account` table to distinctly capture token account metadata changes with the following columns\n+    -   `id` (primary key)\n+    -   `account_id`\n+    -   `create_timestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modify_timestamp`\n+    -   `token_id`\n+    -   `wiped`\n+-   Create unique index `token_account__token_account`\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with `id` value of 5 and `name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+         (28, 'UNCHECKEDSUBMIT'),\n+         (29, 'TOKENCREATE'),\n+         (30, 'TOKENTRANSFER'),\n+         (31, 'TOKENFREEZE'),\n+         (32, 'TOKENUNFREEZE'),\n+         (33, 'TOKENGRANTKYC'),\n+         (34, 'TOKENREVOKEKYC'),\n+         (35, 'TOKENDELETE'),\n+         (36, 'TOKENUPDATE'),\n+         (37, 'TOKENMINT'),\n+         (38, 'TOKENBURN'),\n+         (39, 'TOKENWIPE'),\n+         (40, 'TOKENASSOCIATE'),\n+         (41, 'TOKENDISSOCIATE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP'),\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT'),\n+        (188, 'INVALID_KYC_KEY'),\n+        (189, 'INVALID_WIPE_KEY'),\n+        (190, 'INVALID_FREEZE_KEY'),\n+        (191, 'INVALID_SUPPLY_KEY'),\n+        (192, 'TOKEN_NAME_ALREADY_IN_USE'),\n+        (193, 'MISSING_TOKEN_NAME'),\n+        (194, 'TOKEN_NAME_TOO_LONG'),\n+        (195, 'INVALID_WIPING_AMOUNT'),\n+        (196, 'TOKEN_IS_IMMUTABlE'),\n+        (197, 'TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table with the following columns. Table will capture non shared `entity` items, most API calls may not require this information and therefore additional sql joins may be avoided.\n+    -   `token_id` (primary key)\n+    -   `create_timestamp`\n+    -   `divisibility`\n+    -   `freeze_default`\n+    -   `freeze_key`\n+    -   `initial_supply`\n+    -   `kyc_default`\n+    -   `kyc_key`\n+    -   `modify_timestamp`\n+    -   `supply_key`\n+    -   `symbol`\n+    -   `treasury_account_id`\n+    -   `wipe_key`\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+#### AccountBalance\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+#### TokenTransfer\n+-   Create new `TokenTransfer` with the following class members\n+    -   `accountId`\n+    -   `amount`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+#### EntityTypeEnum\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+        ...\n+        TOKEN(5);\n+        ...\n+    }\n+```\n+\n+#### Token\n+-   Add `Token` class to hold Token specific metadata outside of the base entity class with the following class members\n+    -   `createTimestamp`\n+    -   `divisibility`\n+    -   `freezeDefault`\n+    -   `freezeKey`\n+    -   `initialSupply`\n+    -   `kycDefault`\n+    -   `kycKey`\n+    -   `modifyTimestamp`\n+    -   `supplyKey`\n+    -   `symbol`\n+    -   `tokenId`\n+    -   `treasuryAccountId`\n+    -   `wipeKey`\n+\n+#### TokenAccount\n+-   Add `TokenAccount` class with the following class members\n+    -   `id`\n+    -   `accountId`\n+    -   `createTimestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modifyTimestamp`\n+    -   `tokenId`\n+    -   `wiped`\n+\n+#### TokenBalance\n+-   Add `TokenBalance` class with the following class members\n+    -   `accountId`\n+    -   `balance`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+### Balance Parsing\n+To support HTS the balance CSV\n+1. Adds a version comment as the first line of the file i.e. `# version:2`\n+2. Comments out the Timestamp e.g. `TimeStamp:2020-09-22T04:25:00.083212003Z`\n+3. Adds a `tokenBalances` column which is the Base64 encoding of the serialized bytes of `TokenBalances` proto.\n+\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,tokenBalances`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first line of the CSV\n+    -   If `TimeStamp` is matched use `BalanceFileReaderImplV1` as the reader\n+    -   If `# version:2` is matched use `BalanceFileReaderImplV2` as the reader\n+    -   If no `# version:2` or `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenBalance` in the `TokenBalances`\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to set Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenTransferTransactionsHandler`\n+-   Add `TokenFreezeTransactionsHandler`\n+-   Add `TokenUnfreezeTransactionsHandler`\n+-   Add `TokenGrantKycTransactionsHandler`\n+-   Add `TokenRevokeKycTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to update Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenWipeTransactionsHandler`\n+-   Add `TokenAssociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenDissociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+\n+\n+### Token Transfer Parsing\n+\n+#### EntityListener\n+-   Add a `onToken()` to handle create and updates on the `token` table\n+```java\n+    default void onToken(Token token) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenAccount()` to handle inserts and updates on the `token_account` table\n+```java\n+    default void onTokenAccount(TokenAccount tokenAccount) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenTransfer()` to handle a `token_transfer` table\n+```java\n+    default void onTokenTransfer(TokenTransfer tokenTransfer) throws ImporterException {\n+    }\n+```\n+\n+#### EntityRecordItemListener\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+Add logic to check for\n+-   `TransactionBody.hasTokenCreation()` and parse `TokenCreateTransactionBody` out from the record. Create a new `Token` object and pass it to `entityListener.onToken()`.\n+-   `TransactionBody.hasTokenTransfers()` and parse `TokenTransferLists` out from the record. Create a new `TokenTransfer` object for each `AccountAmount` in the `TokenTransferList` object and pass it to `entityListener.onTokenTransfer()`.\n+-   `TransactionBody.hasTokenAssociate()` and parse `TokenAssociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenDissociate()` and parse `TokenDissociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenFreeze()` and parse `TokenFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUnfreeze()` and parse `TokenUnFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenGrantKyc()` and parse `TokenGrantKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenRevokeKyc()` and parse `TokenRevokeKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenWipe()` and parse `TokenWipeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `wipe` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUpdate()` and parse `TokenUpdateTransactionBody` out from the record. Retrieve an existing `Token` db entry, update the appropriate columns and pass it to `entityListener.onToken()`.\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `transactions` REST API must be updated to support `tokenTransfers`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `accounts` REST API must be updated to support `tokenBalances`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<symbol>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<symbol>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"token_balances\": [\n+            {\n+              \"symbol\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"symbol\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"token_balances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"token_balances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"token_balances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"symbol\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"transfers\": [\n+                {\n+                  \"account\": \"0.0.1111\",\n+                  \"amount\": -10,\n+                  \"symbol\": \"FOOBAR\"\n+                },\n+                {\n+                  \"account\": \"0.0.2222\",\n+                  \"amount\": 10,\n+                  \"symbol\": \"FOOBAR\"\n+                }\n+              ]\n+            },\n+            {\n+              \"transfers\": [\n+                {\n+                  \"account\": \"0.0.3333\",\n+                  \"amount\": -10,\n+                  \"symbol\":\"FOOCOIN\"\n+                },\n+                {\n+                  \"account\": \"0.0.4444\",\n+                  \"amount\": 10,\n+                  \"symbol\":\"FOOCOIN\"\n+                }\n+               ]\n+            }\n+          ]\n+        }\n+      ]\n+    }\n+```\n+\n+### Token Supply distribution\n+\n+`/api/v1/tokens/<symbol>/balances` this could be the equivalent of `/api/v1/balances?symbol=<symbol>` currently and would return a list of account and the token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.15.10\",\n+            \"balance\": 100\n+          },\n+          {\n+            \"account\": \"0.15.9\",\n+            \"balance\": 90\n+          },\n+          {\n+            \"account\": \"0.15.8\",\n+            \"balance\": 80\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens/<symbol>/balances?id=0.0.1000`\n+-   `/api/v1/tokens/<symbol>/balances?balance=gt:1000`\n+-   `/api/v1/tokens/<symbol>/balances?timestamp=1566562500.040961001`\n+\n+### Token Discovery\n+`/api/v1/tokens` this would return all tokens present on the network\n+\n+```json\n+    {\n+        \"tokens\": [\n+          {\n+            \"symbol\": \"FOOBAR\",\n+            \"token_id\": \"0.15.10\",\n+            \"admin_key\": {\n+              \"_type\": \"ProtobufEncoded\",\n+              \"key\": \"7b2233222c2233222c2233227d\"\n+            }\n+          },\n+          {\n+            \"symbol\": \"FOOCOIN\",\n+            \"tokenId\": \"0.15.11\",\n+            \"admin_key\": {\n+              \"_type\": \"ProtobufEncoded\",\n+              \"key\": \"9c2233222c2233222c2233227d\"\n+            }\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens?publickey=3c3d546321ff6f63d701d2ec5c277095874e19f4a235bee1e6bb19258bf362be` - All tokens with matching admin key\n+-   `/api/v1/tokens?account.id=0.0.8` - All tokens for matching account\n+\n+### Token Info\n+-   Add a `getTokenInfo()` to `tokens.js` to retrieve token info from `token` table\n+```json\n+    {\n+      \"symbol\": \"FOOCOIN\",\n+      \"token_id\": \"0.15.10\",\n+      \"treasury_account\": \"0.15.10\",\n+      \"admin_key\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"kyc_key\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"freeze_key\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"wipe_key\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"supply_key\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"freeze_default\": false,\n+      \"kyc_default\": false,\n+      \"expiry_timestamp\": null,\n+      \"auto_renew_account\": \"0.0.6\",\n+      \"auto_renew_period\": null\n+    }\n+```\n+\n+\n+## Protobuf\n+- Add a `TokenQuery` proto message to describe query format\n+- Add a `TokenResponse` proto message to describe response\n+- Add `TokenService` rpc endpoints as needed based on desired `tokenId` and `accountId` combinations\n+\n+\n+## GRPC API\n+\n+### Controller\n+-   Add a `TokenController` class that extends protobuf reactor stubs and implements service rpc endpoints\n+\n+### Domain\n+\n+-   Add `TokenTransfer` class as defined in Importer\n+-   Add `TokenTransferFilter` with similar design to `TopicMessageFilter`\n+-   Update `EntityType` with `TOKEN` option\n+```java\n+    package com.hedera.mirror.grpc.domain;\n+\n+    public enum EntityType {\n+\n+        UNKNOWN, // Filler value to offset next values by one to match database values\n+        ACCOUNT,\n+        CONTRACT,\n+        FILE,\n+        TOPIC,\n+        TOKEN\n+    }\n+```\n+\n+### Streaming : Listener & Retriever\n+The GRPC module currently supports listen and retrieval logic for incoming and historic topic messages respectively.\n+A lot of this logic can be shared for the equivalent `TokenTransfer` listeners and retriever\n+\n+TBD\n+\n+### Token Transfer Service\n+TBD\n+> _Note:_ ***Sequence diagram to be added\n+\n+\n+## Non-Functional Requirements\n+\n+## Open Questions\n+-   [x] What's the maximum character size of the token `symbol` string\n+    -   A: Max length is currently 100 chars to match memo, https://github.com/hashgraph/hedera-services/blob/separate-tokenrels-fcm/hedera-node/src/main/resources/bootstrap.properties#L56\n+-   [x] Will a `token_id` and `token` be assigned a default value for HBARs across the network e.g. i.e. '1' and 'HBAR' respectively\n+    -   A: Currently no since hbar is not treated as an entity like tokens will be.\n+-   [x] Should token only entity items exist in their own table or be added to `t_entities`?\n+    -   A: Will split out into `token` table\n+-   [x] Should `account_balance` `accountNum` and `accountRealmNum` be migrated into `entityId` or should token_balance also use `accountNum` and `accountRealmNum` instead of `entityId`?\n+    -   A: Should be migrated to use `account_id` only\n+-   [ ] What filter options should be provided for new Token API's\n+-   [x] How should frozen account and kyc'd account for a token be represented?\n+    -   A: As columns in `token` table\n+-   [ ] Should balance returns for `accounts`, `balances` and `transactions` contain `token` or `tokenId` or both?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "originalPosition": 626}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NTU1MTQzOnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMDo1MToyNlrOHXsLdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMDo1MToyNlrOHXsLdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYwMzEyNA==", "bodyText": "Provide parity with /accounts and /balances APIs where applicable i.e. filtering on accountId, tokenId and publicKey", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494603124", "createdAt": "2020-09-24T20:51:26Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,631 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members\n+    -   `account_id`\n+    -   `amount`\n+    -   `consensus_timestamp`\n+    -   `token_id`\n+-   Add a `token_transfer__token_account_timestamp` index with `desc` order on columns\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances with the following columns\n+    -   `consensus_timestamp`\n+    -   `account_id`\n+    -   `balance`\n+    -   `token_id`\n+-   Create primary key as combination of `consensus_timestamp`, `token_id` and `account_id`\n+\n+### Token Account Info\n+-   Create `token_account` table to distinctly capture token account metadata changes with the following columns\n+    -   `id` (primary key)\n+    -   `account_id`\n+    -   `create_timestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modify_timestamp`\n+    -   `token_id`\n+    -   `wiped`\n+-   Create unique index `token_account__token_account`\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with `id` value of 5 and `name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+         (28, 'UNCHECKEDSUBMIT'),\n+         (29, 'TOKENCREATE'),\n+         (30, 'TOKENTRANSFER'),\n+         (31, 'TOKENFREEZE'),\n+         (32, 'TOKENUNFREEZE'),\n+         (33, 'TOKENGRANTKYC'),\n+         (34, 'TOKENREVOKEKYC'),\n+         (35, 'TOKENDELETE'),\n+         (36, 'TOKENUPDATE'),\n+         (37, 'TOKENMINT'),\n+         (38, 'TOKENBURN'),\n+         (39, 'TOKENWIPE'),\n+         (40, 'TOKENASSOCIATE'),\n+         (41, 'TOKENDISSOCIATE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP'),\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT'),\n+        (188, 'INVALID_KYC_KEY'),\n+        (189, 'INVALID_WIPE_KEY'),\n+        (190, 'INVALID_FREEZE_KEY'),\n+        (191, 'INVALID_SUPPLY_KEY'),\n+        (192, 'TOKEN_NAME_ALREADY_IN_USE'),\n+        (193, 'MISSING_TOKEN_NAME'),\n+        (194, 'TOKEN_NAME_TOO_LONG'),\n+        (195, 'INVALID_WIPING_AMOUNT'),\n+        (196, 'TOKEN_IS_IMMUTABlE'),\n+        (197, 'TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table with the following columns. Table will capture non shared `entity` items, most API calls may not require this information and therefore additional sql joins may be avoided.\n+    -   `token_id` (primary key)\n+    -   `create_timestamp`\n+    -   `divisibility`\n+    -   `freeze_default`\n+    -   `freeze_key`\n+    -   `initial_supply`\n+    -   `kyc_default`\n+    -   `kyc_key`\n+    -   `modify_timestamp`\n+    -   `supply_key`\n+    -   `symbol`\n+    -   `treasury_account_id`\n+    -   `wipe_key`\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+#### AccountBalance\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+#### TokenTransfer\n+-   Create new `TokenTransfer` with the following class members\n+    -   `accountId`\n+    -   `amount`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+#### EntityTypeEnum\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+        ...\n+        TOKEN(5);\n+        ...\n+    }\n+```\n+\n+#### Token\n+-   Add `Token` class to hold Token specific metadata outside of the base entity class with the following class members\n+    -   `createTimestamp`\n+    -   `divisibility`\n+    -   `freezeDefault`\n+    -   `freezeKey`\n+    -   `initialSupply`\n+    -   `kycDefault`\n+    -   `kycKey`\n+    -   `modifyTimestamp`\n+    -   `supplyKey`\n+    -   `symbol`\n+    -   `tokenId`\n+    -   `treasuryAccountId`\n+    -   `wipeKey`\n+\n+#### TokenAccount\n+-   Add `TokenAccount` class with the following class members\n+    -   `id`\n+    -   `accountId`\n+    -   `createTimestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modifyTimestamp`\n+    -   `tokenId`\n+    -   `wiped`\n+\n+#### TokenBalance\n+-   Add `TokenBalance` class with the following class members\n+    -   `accountId`\n+    -   `balance`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+### Balance Parsing\n+To support HTS the balance CSV\n+1. Adds a version comment as the first line of the file i.e. `# version:2`\n+2. Comments out the Timestamp e.g. `TimeStamp:2020-09-22T04:25:00.083212003Z`\n+3. Adds a `tokenBalances` column which is the Base64 encoding of the serialized bytes of `TokenBalances` proto.\n+\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,tokenBalances`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first line of the CSV\n+    -   If `TimeStamp` is matched use `BalanceFileReaderImplV1` as the reader\n+    -   If `# version:2` is matched use `BalanceFileReaderImplV2` as the reader\n+    -   If no `# version:2` or `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenBalance` in the `TokenBalances`\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to set Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenTransferTransactionsHandler`\n+-   Add `TokenFreezeTransactionsHandler`\n+-   Add `TokenUnfreezeTransactionsHandler`\n+-   Add `TokenGrantKycTransactionsHandler`\n+-   Add `TokenRevokeKycTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to update Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenWipeTransactionsHandler`\n+-   Add `TokenAssociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenDissociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+\n+\n+### Token Transfer Parsing\n+\n+#### EntityListener\n+-   Add a `onToken()` to handle create and updates on the `token` table\n+```java\n+    default void onToken(Token token) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenAccount()` to handle inserts and updates on the `token_account` table\n+```java\n+    default void onTokenAccount(TokenAccount tokenAccount) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenTransfer()` to handle a `token_transfer` table\n+```java\n+    default void onTokenTransfer(TokenTransfer tokenTransfer) throws ImporterException {\n+    }\n+```\n+\n+#### EntityRecordItemListener\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+Add logic to check for\n+-   `TransactionBody.hasTokenCreation()` and parse `TokenCreateTransactionBody` out from the record. Create a new `Token` object and pass it to `entityListener.onToken()`.\n+-   `TransactionBody.hasTokenTransfers()` and parse `TokenTransferLists` out from the record. Create a new `TokenTransfer` object for each `AccountAmount` in the `TokenTransferList` object and pass it to `entityListener.onTokenTransfer()`.\n+-   `TransactionBody.hasTokenAssociate()` and parse `TokenAssociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenDissociate()` and parse `TokenDissociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenFreeze()` and parse `TokenFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUnfreeze()` and parse `TokenUnFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenGrantKyc()` and parse `TokenGrantKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenRevokeKyc()` and parse `TokenRevokeKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenWipe()` and parse `TokenWipeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `wipe` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUpdate()` and parse `TokenUpdateTransactionBody` out from the record. Retrieve an existing `Token` db entry, update the appropriate columns and pass it to `entityListener.onToken()`.\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `transactions` REST API must be updated to support `tokenTransfers`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `accounts` REST API must be updated to support `tokenBalances`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<symbol>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<symbol>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"token_balances\": [\n+            {\n+              \"symbol\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"symbol\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"token_balances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"token_balances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"token_balances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"symbol\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"transfers\": [\n+                {\n+                  \"account\": \"0.0.1111\",\n+                  \"amount\": -10,\n+                  \"symbol\": \"FOOBAR\"\n+                },\n+                {\n+                  \"account\": \"0.0.2222\",\n+                  \"amount\": 10,\n+                  \"symbol\": \"FOOBAR\"\n+                }\n+              ]\n+            },\n+            {\n+              \"transfers\": [\n+                {\n+                  \"account\": \"0.0.3333\",\n+                  \"amount\": -10,\n+                  \"symbol\":\"FOOCOIN\"\n+                },\n+                {\n+                  \"account\": \"0.0.4444\",\n+                  \"amount\": 10,\n+                  \"symbol\":\"FOOCOIN\"\n+                }\n+               ]\n+            }\n+          ]\n+        }\n+      ]\n+    }\n+```\n+\n+### Token Supply distribution\n+\n+`/api/v1/tokens/<symbol>/balances` this could be the equivalent of `/api/v1/balances?symbol=<symbol>` currently and would return a list of account and the token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.15.10\",\n+            \"balance\": 100\n+          },\n+          {\n+            \"account\": \"0.15.9\",\n+            \"balance\": 90\n+          },\n+          {\n+            \"account\": \"0.15.8\",\n+            \"balance\": 80\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens/<symbol>/balances?id=0.0.1000`\n+-   `/api/v1/tokens/<symbol>/balances?balance=gt:1000`\n+-   `/api/v1/tokens/<symbol>/balances?timestamp=1566562500.040961001`\n+\n+### Token Discovery\n+`/api/v1/tokens` this would return all tokens present on the network\n+\n+```json\n+    {\n+        \"tokens\": [\n+          {\n+            \"symbol\": \"FOOBAR\",\n+            \"token_id\": \"0.15.10\",\n+            \"admin_key\": {\n+              \"_type\": \"ProtobufEncoded\",\n+              \"key\": \"7b2233222c2233222c2233227d\"\n+            }\n+          },\n+          {\n+            \"symbol\": \"FOOCOIN\",\n+            \"tokenId\": \"0.15.11\",\n+            \"admin_key\": {\n+              \"_type\": \"ProtobufEncoded\",\n+              \"key\": \"9c2233222c2233222c2233227d\"\n+            }\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens?publickey=3c3d546321ff6f63d701d2ec5c277095874e19f4a235bee1e6bb19258bf362be` - All tokens with matching admin key\n+-   `/api/v1/tokens?account.id=0.0.8` - All tokens for matching account\n+\n+### Token Info\n+-   Add a `getTokenInfo()` to `tokens.js` to retrieve token info from `token` table\n+```json\n+    {\n+      \"symbol\": \"FOOCOIN\",\n+      \"token_id\": \"0.15.10\",\n+      \"treasury_account\": \"0.15.10\",\n+      \"admin_key\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"kyc_key\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"freeze_key\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"wipe_key\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"supply_key\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"freeze_default\": false,\n+      \"kyc_default\": false,\n+      \"expiry_timestamp\": null,\n+      \"auto_renew_account\": \"0.0.6\",\n+      \"auto_renew_period\": null\n+    }\n+```\n+\n+\n+## Protobuf\n+- Add a `TokenQuery` proto message to describe query format\n+- Add a `TokenResponse` proto message to describe response\n+- Add `TokenService` rpc endpoints as needed based on desired `tokenId` and `accountId` combinations\n+\n+\n+## GRPC API\n+\n+### Controller\n+-   Add a `TokenController` class that extends protobuf reactor stubs and implements service rpc endpoints\n+\n+### Domain\n+\n+-   Add `TokenTransfer` class as defined in Importer\n+-   Add `TokenTransferFilter` with similar design to `TopicMessageFilter`\n+-   Update `EntityType` with `TOKEN` option\n+```java\n+    package com.hedera.mirror.grpc.domain;\n+\n+    public enum EntityType {\n+\n+        UNKNOWN, // Filler value to offset next values by one to match database values\n+        ACCOUNT,\n+        CONTRACT,\n+        FILE,\n+        TOPIC,\n+        TOKEN\n+    }\n+```\n+\n+### Streaming : Listener & Retriever\n+The GRPC module currently supports listen and retrieval logic for incoming and historic topic messages respectively.\n+A lot of this logic can be shared for the equivalent `TokenTransfer` listeners and retriever\n+\n+TBD\n+\n+### Token Transfer Service\n+TBD\n+> _Note:_ ***Sequence diagram to be added\n+\n+\n+## Non-Functional Requirements\n+\n+## Open Questions\n+-   [x] What's the maximum character size of the token `symbol` string\n+    -   A: Max length is currently 100 chars to match memo, https://github.com/hashgraph/hedera-services/blob/separate-tokenrels-fcm/hedera-node/src/main/resources/bootstrap.properties#L56\n+-   [x] Will a `token_id` and `token` be assigned a default value for HBARs across the network e.g. i.e. '1' and 'HBAR' respectively\n+    -   A: Currently no since hbar is not treated as an entity like tokens will be.\n+-   [x] Should token only entity items exist in their own table or be added to `t_entities`?\n+    -   A: Will split out into `token` table\n+-   [x] Should `account_balance` `accountNum` and `accountRealmNum` be migrated into `entityId` or should token_balance also use `accountNum` and `accountRealmNum` instead of `entityId`?\n+    -   A: Should be migrated to use `account_id` only\n+-   [ ] What filter options should be provided for new Token API's", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "originalPosition": 623}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NTU2NDg2OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMDo1NToyMFrOHXsTRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwMzoxNzo1NlrOHXzkQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYwNTEyNw==", "bodyText": "Do we still want the parser to be lenient on the number of lines before the timestamp/version number?  Looks like right now allow the timestamp to be up to 10 lines deep, so long as the column headers don't come up first.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494605127", "createdAt": "2020-09-24T20:55:20Z", "author": {"login": "ijungmann"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,631 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members\n+    -   `account_id`\n+    -   `amount`\n+    -   `consensus_timestamp`\n+    -   `token_id`\n+-   Add a `token_transfer__token_account_timestamp` index with `desc` order on columns\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances with the following columns\n+    -   `consensus_timestamp`\n+    -   `account_id`\n+    -   `balance`\n+    -   `token_id`\n+-   Create primary key as combination of `consensus_timestamp`, `token_id` and `account_id`\n+\n+### Token Account Info\n+-   Create `token_account` table to distinctly capture token account metadata changes with the following columns\n+    -   `id` (primary key)\n+    -   `account_id`\n+    -   `create_timestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modify_timestamp`\n+    -   `token_id`\n+    -   `wiped`\n+-   Create unique index `token_account__token_account`\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with `id` value of 5 and `name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+         (28, 'UNCHECKEDSUBMIT'),\n+         (29, 'TOKENCREATE'),\n+         (30, 'TOKENTRANSFER'),\n+         (31, 'TOKENFREEZE'),\n+         (32, 'TOKENUNFREEZE'),\n+         (33, 'TOKENGRANTKYC'),\n+         (34, 'TOKENREVOKEKYC'),\n+         (35, 'TOKENDELETE'),\n+         (36, 'TOKENUPDATE'),\n+         (37, 'TOKENMINT'),\n+         (38, 'TOKENBURN'),\n+         (39, 'TOKENWIPE'),\n+         (40, 'TOKENASSOCIATE'),\n+         (41, 'TOKENDISSOCIATE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP'),\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT'),\n+        (188, 'INVALID_KYC_KEY'),\n+        (189, 'INVALID_WIPE_KEY'),\n+        (190, 'INVALID_FREEZE_KEY'),\n+        (191, 'INVALID_SUPPLY_KEY'),\n+        (192, 'TOKEN_NAME_ALREADY_IN_USE'),\n+        (193, 'MISSING_TOKEN_NAME'),\n+        (194, 'TOKEN_NAME_TOO_LONG'),\n+        (195, 'INVALID_WIPING_AMOUNT'),\n+        (196, 'TOKEN_IS_IMMUTABlE'),\n+        (197, 'TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table with the following columns. Table will capture non shared `entity` items, most API calls may not require this information and therefore additional sql joins may be avoided.\n+    -   `token_id` (primary key)\n+    -   `create_timestamp`\n+    -   `divisibility`\n+    -   `freeze_default`\n+    -   `freeze_key`\n+    -   `initial_supply`\n+    -   `kyc_default`\n+    -   `kyc_key`\n+    -   `modify_timestamp`\n+    -   `supply_key`\n+    -   `symbol`\n+    -   `treasury_account_id`\n+    -   `wipe_key`\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+#### AccountBalance\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+#### TokenTransfer\n+-   Create new `TokenTransfer` with the following class members\n+    -   `accountId`\n+    -   `amount`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+#### EntityTypeEnum\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+        ...\n+        TOKEN(5);\n+        ...\n+    }\n+```\n+\n+#### Token\n+-   Add `Token` class to hold Token specific metadata outside of the base entity class with the following class members\n+    -   `createTimestamp`\n+    -   `divisibility`\n+    -   `freezeDefault`\n+    -   `freezeKey`\n+    -   `initialSupply`\n+    -   `kycDefault`\n+    -   `kycKey`\n+    -   `modifyTimestamp`\n+    -   `supplyKey`\n+    -   `symbol`\n+    -   `tokenId`\n+    -   `treasuryAccountId`\n+    -   `wipeKey`\n+\n+#### TokenAccount\n+-   Add `TokenAccount` class with the following class members\n+    -   `id`\n+    -   `accountId`\n+    -   `createTimestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modifyTimestamp`\n+    -   `tokenId`\n+    -   `wiped`\n+\n+#### TokenBalance\n+-   Add `TokenBalance` class with the following class members\n+    -   `accountId`\n+    -   `balance`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+### Balance Parsing\n+To support HTS the balance CSV\n+1. Adds a version comment as the first line of the file i.e. `# version:2`\n+2. Comments out the Timestamp e.g. `TimeStamp:2020-09-22T04:25:00.083212003Z`\n+3. Adds a `tokenBalances` column which is the Base64 encoding of the serialized bytes of `TokenBalances` proto.\n+\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,tokenBalances`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first line of the CSV", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "originalPosition": 253}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDcyNDE2MA==", "bodyText": "Yeah I'd say leave that lenience for V1. I'm presuming it's there for padded cases?\nWe should verify why.\nGiven the file is now versioned it would be the best time to dump that logic for V2 if it's no longer needed.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494724160", "createdAt": "2020-09-25T03:17:56Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,631 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members\n+    -   `account_id`\n+    -   `amount`\n+    -   `consensus_timestamp`\n+    -   `token_id`\n+-   Add a `token_transfer__token_account_timestamp` index with `desc` order on columns\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances with the following columns\n+    -   `consensus_timestamp`\n+    -   `account_id`\n+    -   `balance`\n+    -   `token_id`\n+-   Create primary key as combination of `consensus_timestamp`, `token_id` and `account_id`\n+\n+### Token Account Info\n+-   Create `token_account` table to distinctly capture token account metadata changes with the following columns\n+    -   `id` (primary key)\n+    -   `account_id`\n+    -   `create_timestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modify_timestamp`\n+    -   `token_id`\n+    -   `wiped`\n+-   Create unique index `token_account__token_account`\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with `id` value of 5 and `name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+         (28, 'UNCHECKEDSUBMIT'),\n+         (29, 'TOKENCREATE'),\n+         (30, 'TOKENTRANSFER'),\n+         (31, 'TOKENFREEZE'),\n+         (32, 'TOKENUNFREEZE'),\n+         (33, 'TOKENGRANTKYC'),\n+         (34, 'TOKENREVOKEKYC'),\n+         (35, 'TOKENDELETE'),\n+         (36, 'TOKENUPDATE'),\n+         (37, 'TOKENMINT'),\n+         (38, 'TOKENBURN'),\n+         (39, 'TOKENWIPE'),\n+         (40, 'TOKENASSOCIATE'),\n+         (41, 'TOKENDISSOCIATE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP'),\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT'),\n+        (188, 'INVALID_KYC_KEY'),\n+        (189, 'INVALID_WIPE_KEY'),\n+        (190, 'INVALID_FREEZE_KEY'),\n+        (191, 'INVALID_SUPPLY_KEY'),\n+        (192, 'TOKEN_NAME_ALREADY_IN_USE'),\n+        (193, 'MISSING_TOKEN_NAME'),\n+        (194, 'TOKEN_NAME_TOO_LONG'),\n+        (195, 'INVALID_WIPING_AMOUNT'),\n+        (196, 'TOKEN_IS_IMMUTABlE'),\n+        (197, 'TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table with the following columns. Table will capture non shared `entity` items, most API calls may not require this information and therefore additional sql joins may be avoided.\n+    -   `token_id` (primary key)\n+    -   `create_timestamp`\n+    -   `divisibility`\n+    -   `freeze_default`\n+    -   `freeze_key`\n+    -   `initial_supply`\n+    -   `kyc_default`\n+    -   `kyc_key`\n+    -   `modify_timestamp`\n+    -   `supply_key`\n+    -   `symbol`\n+    -   `treasury_account_id`\n+    -   `wipe_key`\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+#### AccountBalance\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+#### TokenTransfer\n+-   Create new `TokenTransfer` with the following class members\n+    -   `accountId`\n+    -   `amount`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+#### EntityTypeEnum\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+        ...\n+        TOKEN(5);\n+        ...\n+    }\n+```\n+\n+#### Token\n+-   Add `Token` class to hold Token specific metadata outside of the base entity class with the following class members\n+    -   `createTimestamp`\n+    -   `divisibility`\n+    -   `freezeDefault`\n+    -   `freezeKey`\n+    -   `initialSupply`\n+    -   `kycDefault`\n+    -   `kycKey`\n+    -   `modifyTimestamp`\n+    -   `supplyKey`\n+    -   `symbol`\n+    -   `tokenId`\n+    -   `treasuryAccountId`\n+    -   `wipeKey`\n+\n+#### TokenAccount\n+-   Add `TokenAccount` class with the following class members\n+    -   `id`\n+    -   `accountId`\n+    -   `createTimestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modifyTimestamp`\n+    -   `tokenId`\n+    -   `wiped`\n+\n+#### TokenBalance\n+-   Add `TokenBalance` class with the following class members\n+    -   `accountId`\n+    -   `balance`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+### Balance Parsing\n+To support HTS the balance CSV\n+1. Adds a version comment as the first line of the file i.e. `# version:2`\n+2. Comments out the Timestamp e.g. `TimeStamp:2020-09-22T04:25:00.083212003Z`\n+3. Adds a `tokenBalances` column which is the Base64 encoding of the serialized bytes of `TokenBalances` proto.\n+\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,tokenBalances`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first line of the CSV", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYwNTEyNw=="}, "originalCommit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "originalPosition": 253}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMDIxMzAzOnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQyMzo1Mzo1N1rOHYYYBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQwMToxNDo0N1rOHYaZdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMyNzIzOQ==", "bodyText": "nit: in the following order", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r495327239", "createdAt": "2020-09-25T23:53:57Z", "author": {"login": "xin-hedera"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,630 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f16fc0a511b59e0d6e3d7bff7e3022fe53605cd"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM2MDM3Mw==", "bodyText": "Fixed", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r495360373", "createdAt": "2020-09-26T01:14:47Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,630 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMyNzIzOQ=="}, "originalCommit": {"oid": "0f16fc0a511b59e0d6e3d7bff7e3022fe53605cd"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMDIxNDY1OnYy", "diffSide": "RIGHT", "path": "docs/design/hts.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQyMzo1NDozN1rOHYYZFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQwMToxNDo1NFrOHYaZmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMyNzUwOQ==", "bodyText": "nit:\nAdd token_transfer table with the following columns", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r495327509", "createdAt": "2020-09-25T23:54:37Z", "author": {"login": "xin-hedera"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,630 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f16fc0a511b59e0d6e3d7bff7e3022fe53605cd"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM2MDQwOQ==", "bodyText": "Fixed", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r495360409", "createdAt": "2020-09-26T01:14:54Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,630 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMyNzUwOQ=="}, "originalCommit": {"oid": "0f16fc0a511b59e0d6e3d7bff7e3022fe53605cd"}, "originalPosition": 53}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1480, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}