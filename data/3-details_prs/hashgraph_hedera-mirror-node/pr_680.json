{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAxNzgxMzM1", "number": 680, "title": "Add updateEntity() and updateTransaction() to TransactionHandler", "bodyText": "Detailed description:\n\nMoved functionality from RecordItemParser to respective implementations of\nTransactionHandler.updateEntity() and updateTransaction()\nBefore recent cleanups, RIP.onItem() used to be 300+ lines. Now it's ~75.\nEntityRepository:\n\nMoved lookupOrCreateId(EntityId) to EntityRepository\nRemoved saveAndCacheEntityId(), not needed anymore after recent cleanups\nBig cache is needed only to lookup db id for an entity because of FKs.\nNo need of entity type in cache. Going forward, we want to removing FKs, and hence the cache.\nSo changed findEntityIdByNativeIds() to return just Long. Simplifies the query too.\n\n\nFix bad tests in RecordItemParserContractTest and RecordItemParserCryptoTest\n\nSigned-off-by: Apekshit Sharma apekshit.sharma@hedera.com\nWhich issue(s) this PR fixes:\nPart of #571\nSpecial notes for your reviewer:\n90% of the code was in an old branch from last sprint. This was after we discussed the design in one of the stand-ups. I think better to get it in than stale out.\nExtensive RecordItemParser integration tests ensure no regression.\nLater, the followups would be:\n\nAdd TransactionHandler unit tests.\nmove RIP.insert*() fns to TransactionHandler\n\nChecklist\n\n Documentation added\n Tests updated", "createdAt": "2020-04-10T06:45:01Z", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680", "merged": true, "mergeCommit": {"oid": "f1c32c7ac1269651f6bdfd3890e2e2955534cf2a"}, "closed": true, "closedAt": "2020-04-13T22:16:06Z", "author": {"login": "apeksharma"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcWWZdQAH2gAyNDAxNzgxMzM1Ojg2ODZmMWQ0OTU5NDg4NDRmZjM2MzM0NGNhZDdmYjlkNDEyNGE0YzY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcXWX6LAFqTM5MjQ3NDUyMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "8686f1d495948844ff363344cad7fb9d4124a4c6", "author": {"user": {"login": "apeksharma", "name": "Apekshit Sharma"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/8686f1d495948844ff363344cad7fb9d4124a4c6", "committedDate": "2020-04-10T19:38:08Z", "message": "Add updateEntity() and updateTransaction() to TransactionHandler\n\n- Moved functionality from RecordItemParser to respective implementations of\n  TransactionHandler.updateEntity() and updateTransaction()\n- Before recent cleanups, RIP.onItem() used to be 300+ lines. Now it's ~75.\n- EntityRepository:\n  - Moved lookupOrCreateId(EntityId) to EntityRepository\n  - Removed saveAndCacheEntityId(), not needed anymore after recent cleanups\n  - Big cache is needed only to lookup db id for an entity because of FKs.\n    No need of entity type in cache. Going forward, we want to removing FKs, and hence the cache.\n    So changed findEntityIdByNativeIds() to return just Long. Simplifies the query too.\n- Fix bad tests in RecordItemParserContractTest and RecordItemParserCryptoTest\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5baa1bde66ad0b122ddbdb25f6d9725b1ff3d146", "author": {"user": {"login": "apeksharma", "name": "Apekshit Sharma"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/5baa1bde66ad0b122ddbdb25f6d9725b1ff3d146", "committedDate": "2020-04-10T06:34:28Z", "message": "Add updateEntity() and updateTransaction() to TransactionHandler\n\n- Moved functionality from RecordItemParser to respective implementations of\n  TransactionHandler.updateEntity() and updateTransaction()\n- Before recent cleanups, RIP.onItem() used to be 300+ lines. Now it's ~75.\n- EntityRepository:\n  - Moved lookupOrCreateId(EntityId) to EntityRepository\n  - Removed saveAndCacheEntityId(), not needed anymore after recent cleanups\n  - Big cache is needed only to lookup db id for an entity because of FKs.\n    No need of entity type in cache. Going forward, we want to removing FKs, and hence the cache.\n    So changed findEntityIdByNativeIds() to return just Long. Simplifies the query too.\n- Fix bad tests in RecordItemParserContractTest and RecordItemParserCryptoTest\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>"}, "afterCommit": {"oid": "8686f1d495948844ff363344cad7fb9d4124a4c6", "author": {"user": {"login": "apeksharma", "name": "Apekshit Sharma"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/8686f1d495948844ff363344cad7fb9d4124a4c6", "committedDate": "2020-04-10T19:38:08Z", "message": "Add updateEntity() and updateTransaction() to TransactionHandler\n\n- Moved functionality from RecordItemParser to respective implementations of\n  TransactionHandler.updateEntity() and updateTransaction()\n- Before recent cleanups, RIP.onItem() used to be 300+ lines. Now it's ~75.\n- EntityRepository:\n  - Moved lookupOrCreateId(EntityId) to EntityRepository\n  - Removed saveAndCacheEntityId(), not needed anymore after recent cleanups\n  - Big cache is needed only to lookup db id for an entity because of FKs.\n    No need of entity type in cache. Going forward, we want to removing FKs, and hence the cache.\n    So changed findEntityIdByNativeIds() to return just Long. Simplifies the query too.\n- Fix bad tests in RecordItemParserContractTest and RecordItemParserCryptoTest\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyMTcyMDAz", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#pullrequestreview-392172003", "createdAt": "2020-04-13T14:17:39Z", "commit": {"oid": "8686f1d495948844ff363344cad7fb9d4124a4c6"}, "state": "DISMISSED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNDoxNzozOVrOGEn4mQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNDoyNDoxN1rOGEoGwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUwMDk1Mw==", "bodyText": "nit: isn't this duplicate code with ContractCreateTransactionHandler.updateEntity()\nIf so shouldn't the AutoRenew, Key and proxy account logic from the TransactionBody be shared and the differences be called?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407500953", "createdAt": "2020-04-13T14:17:39Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/CryptoCreateTransactionHandler.java", "diffHunk": "@@ -39,4 +44,26 @@ public EntityId getEntityId(RecordItem recordItem) {\n     public boolean updatesEntity() {\n         return true;\n     }\n+\n+    @Override\n+    public void updateTransaction(Transaction transaction, RecordItem recordItem) {\n+        transaction.setInitialBalance(recordItem.getTransactionBody().getCryptoCreateAccount().getInitialBalance());\n+    }\n+\n+    @Override\n+    public void updateEntity(Entities entity, RecordItem recordItem) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8686f1d495948844ff363344cad7fb9d4124a4c6"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUwMTMwMw==", "bodyText": "Same comments. Good amount of duplicate logic shared with ContractUpdateTransactionHandler.updateEntity()", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407501303", "createdAt": "2020-04-13T14:18:21Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/CryptoUpdateTransactionHandler.java", "diffHunk": "@@ -39,4 +44,24 @@ public EntityId getEntityId(RecordItem recordItem) {\n     public boolean updatesEntity() {\n         return true;\n     }\n+\n+    @Override\n+    public void updateEntity(Entities entity, RecordItem recordItem) {\n+        CryptoUpdateTransactionBody txMessage = recordItem.getTransactionBody().getCryptoUpdateAccount();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8686f1d495948844ff363344cad7fb9d4124a4c6"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUwMjE0NQ==", "bodyText": "Duplicate code with FileCreateTransactionHandler. updateEntity()", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407502145", "createdAt": "2020-04-13T14:19:50Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/FileUpdateTransactionHandler.java", "diffHunk": "@@ -39,4 +42,15 @@ public EntityId getEntityId(RecordItem recordItem) {\n     public boolean updatesEntity() {\n         return true;\n     }\n+\n+    @Override\n+    public void updateEntity(Entities entity, RecordItem recordItem) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8686f1d495948844ff363344cad7fb9d4124a4c6"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUwNDU3Ng==", "bodyText": "nit: you call entityId.getId() 3 times. Might as well just get it once and use it 3 times.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407504576", "createdAt": "2020-04-13T14:24:17Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/repository/EntityRepositoryCustomImpl.java", "diffHunk": "@@ -49,8 +49,21 @@\n         return results;\n     }\n \n-    public <S extends Entities> EntityId saveAndCacheEntityId(S entity) {\n-        var saved = entityRepository.save(entity);\n-        return entityRepository.cache(saved.toEntityId());\n+    /**\n+     * @param entityId for which the id needs to be looked up (from cache/repo). If no id is found, the the entity is\n+     *                 inserted into the repo and the newly minted id is returned.\n+     * @return looked up/newly minted id of the given entityId.\n+     */\n+    public long lookupOrCreateId(EntityId entityId) {\n+        if (entityId.getId() != null && entityId.getId() != 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8686f1d495948844ff363344cad7fb9d4124a4c6"}, "originalPosition": 13}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ed0e7a27b9ea801bfa58d6aea6ffbf2e7106660f", "author": {"user": {"login": "apeksharma", "name": "Apekshit Sharma"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/ed0e7a27b9ea801bfa58d6aea6ffbf2e7106660f", "committedDate": "2020-04-13T18:44:57Z", "message": "address NPE in autoRenewAccount\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "617acd2c6adcc310c45ba6841827f8808b7e265d", "author": {"user": {"login": "apeksharma", "name": "Apekshit Sharma"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/617acd2c6adcc310c45ba6841827f8808b7e265d", "committedDate": "2020-04-13T18:52:53Z", "message": "Merge branch 'master' into parser_03"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyMzQ0MjE1", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#pullrequestreview-392344215", "createdAt": "2020-04-13T18:37:53Z", "commit": {"oid": "8686f1d495948844ff363344cad7fb9d4124a4c6"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxODozNzo1M1rOGEwg3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxOToyMDozMlrOGEx8EA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY0MjMzNQ==", "bodyText": "Would prefer not storing these as variables as they're not immutable. Hibernate may or may not populate id on object passed to save. Would prefer helper method entityId()", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407642335", "createdAt": "2020-04-13T18:37:53Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/repository/EntityRepositoryTest.java", "diffHunk": "@@ -21,13 +21,16 @@\n  */\n \n import static org.assertj.core.api.Assertions.assertThat;\n-import static org.junit.jupiter.api.Assertions.*;\n \n import org.junit.jupiter.api.Test;\n \n import com.hedera.mirror.importer.domain.Entities;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n \n public class EntityRepositoryTest extends AbstractRepositoryTest {\n+    private static final EntityId ENTITY_ID = new EntityId(null, 1L, 2L, 3L, EntityTypeEnum.ACCOUNT.getId());\n+    private static final Entities ENTITY = ENTITY_ID.toEntity();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8686f1d495948844ff363344cad7fb9d4124a4c6"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY0NDMxNw==", "bodyText": "Would prefer transactionBody and transactionRecord not be stored as it's confusing for sub-classes if they should use getDefaultTransactionBody()/getDefaultTransactionRecord() or use default stored in parent. It also couples the two unnecessarily.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407644317", "createdAt": "2020-04-13T18:41:36Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/transactionhandler/AbstractTransactionHandlerTest.java", "diffHunk": "@@ -28,14 +28,19 @@\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n import org.junit.jupiter.api.TestInfo;\n+import org.mockito.Mock;\n \n import com.hedera.mirror.importer.domain.EntityId;\n import com.hedera.mirror.importer.domain.EntityTypeEnum;\n import com.hedera.mirror.importer.parser.domain.RecordItem;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n \n public abstract class AbstractTransactionHandlerTest {\n     protected static final Long DEFAULT_ENTITY_NUM = 100L;\n-\n+    @Mock\n+    protected EntityRepository entityRepository;\n+    protected TransactionBody transactionBody;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8686f1d495948844ff363344cad7fb9d4124a4c6"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY2NTY4MA==", "bodyText": "Should do tx.setEntity(entityRepository.save(entity)); as Hibernate can return a proxied object. Can move this logic into getEntity() so that it either retrieves or create and saves the entity.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407665680", "createdAt": "2020-04-13T19:20:32Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordItemParser.java", "diffHunk": "@@ -115,185 +110,33 @@ public void onItem(RecordItem recordItem) throws ImporterException {\n             return;\n         }\n \n-        // TODO: updatesEntity() is true for all and only the transaction types which are in body.has*() if-else\n-        //   conditions below. This is temporary to keep scope of changes in single PR limited and will be fixed in\n-        //   followup PR quickly. All if-else conditions will be replaced by:\n-        //     transactionHandler.updateEntity(entity, recordItem).\n-        Entities entity = null; // Entity used when t_entities row must be updated.\n-        if (transactionHandler.updatesEntity()) {\n-            entity = getEntity(entityId);\n-        }\n-\n-        // Only when transaction is successful:\n-        // - Fields of 'entity' will be updated. Fields are not updated for failed transactions since 'entity' may be an\n-        //   instance from cache and reused in future.\n-        // - proxyAccountId/autoRenewAccountId: If present, the account's id will be looked up (from big cache)\n-        //   or created immediately.\n+        boolean isSuccessful = isSuccessful(txRecord);\n+        Transaction tx = buildTransaction(consensusNs, recordItem);\n+        transactionHandler.updateTransaction(tx, recordItem);\n \n-        // For all transactions:\n-        // - 'entity' (may have been updated or not) is always inserted into repo since\n+        // Irrespective of transaction failure/success, if entityId is not null, it will be inserted into repo since:\n         //   (1) it is guaranteed to be valid entity on network (validated to exist in pre-consensus checks)\n         //   (2) fk_cud_entity_id is foreign key in t_transactions\n-        boolean doUpdateEntity = isSuccessful(txRecord);\n-        long initialBalance = 0;\n-\n-        if (entity == null) {\n-            // Do nothing. This can be true if transaction is of type that doesn't update the entity. Or, if the\n-            // transaction doesn't contain non-zero entity id (i.e. with entityNum != 0).\n-        } else if (body.hasContractCreateInstance()) {\n-            if (txRecord.getReceipt().hasContractID()) { // implies SUCCESS\n-                ContractCreateTransactionBody txMessage = body.getContractCreateInstance();\n-                setProxyAccountID(txMessage.getProxyAccountID(), entity);\n-                if (txMessage.hasAutoRenewPeriod()) {\n-                    entity.setAutoRenewPeriod(txMessage.getAutoRenewPeriod().getSeconds());\n-                }\n-                // Can't clear memo on contracts. 0 length indicates no change\n-                if (txMessage.getMemo() != null && txMessage.getMemo().length() > 0) {\n-                    entity.setMemo(txMessage.getMemo());\n-                }\n-\n-                if (txMessage.hasAdminKey()) {\n-                    entity.setKey(txMessage.getAdminKey().toByteArray());\n-                }\n-            }\n-\n-            initialBalance = body.getContractCreateInstance().getInitialBalance();\n-        } else if (body.hasContractDeleteInstance()) {\n-            if (body.getContractDeleteInstance().hasContractID()) {\n-                if (doUpdateEntity) {\n-                    entity.setDeleted(true);\n-                }\n-            }\n-        } else if (body.hasContractUpdateInstance()) {\n-            ContractUpdateTransactionBody txMessage = body.getContractUpdateInstance();\n-            if (doUpdateEntity) {\n-                setProxyAccountID(txMessage.getProxyAccountID(), entity);\n-                if (txMessage.hasExpirationTime()) {\n-                    entity.setExpiryTimeNs(Utility.timestampInNanosMax(txMessage.getExpirationTime()));\n-                }\n-                if (txMessage.hasAutoRenewPeriod()) {\n-                    entity.setAutoRenewPeriod(txMessage.getAutoRenewPeriod().getSeconds());\n-                }\n-                if (txMessage.hasAdminKey()) {\n-                    entity.setKey(txMessage.getAdminKey().toByteArray());\n-                }\n-                // Can't clear memo on contracts. 0 length indicates no change\n-                if (txMessage.getMemo() != null && txMessage.getMemo().length() > 0) {\n-                    entity.setMemo(txMessage.getMemo());\n-                }\n-            }\n-        } else if (body.hasCryptoCreateAccount()) {\n-            if (txRecord.getReceipt().hasAccountID()) { // Implies SUCCESS\n-                CryptoCreateTransactionBody txMessage = body.getCryptoCreateAccount();\n-                setProxyAccountID(txMessage.getProxyAccountID(), entity);\n-                if (txMessage.hasAutoRenewPeriod()) {\n-                    entity.setAutoRenewPeriod(txMessage.getAutoRenewPeriod().getSeconds());\n-                }\n-                if (txMessage.hasKey()) {\n-                    entity.setKey(txMessage.getKey().toByteArray());\n-                }\n-            }\n-\n-            initialBalance = body.getCryptoCreateAccount().getInitialBalance();\n-        } else if (body.hasCryptoDelete()) {\n-            if (body.getCryptoDelete().hasDeleteAccountID()) {\n-                if (doUpdateEntity) {\n-                    entity.setDeleted(true);\n-                }\n-            }\n-        } else if (body.hasCryptoUpdateAccount()) {\n-            CryptoUpdateTransactionBody txMessage = body.getCryptoUpdateAccount();\n-            if (doUpdateEntity) {\n-                setProxyAccountID(txMessage.getProxyAccountID(), entity);\n-                if (txMessage.hasExpirationTime()) {\n-                    entity.setExpiryTimeNs(Utility.timestampInNanosMax(txMessage.getExpirationTime()));\n-                }\n-                if (txMessage.hasAutoRenewPeriod()) {\n-                    entity.setAutoRenewPeriod(txMessage.getAutoRenewPeriod().getSeconds());\n-                }\n-                if (txMessage.hasKey()) {\n-                    entity.setKey(txMessage.getKey().toByteArray());\n-                }\n-            }\n-        } else if (body.hasFileCreate()) {\n-            if (txRecord.getReceipt().hasFileID()) { // Implies SUCCESS\n-                FileCreateTransactionBody txMessage = body.getFileCreate();\n-                if (txMessage.hasExpirationTime()) {\n-                    entity.setExpiryTimeNs(Utility.timestampInNanosMax(txMessage.getExpirationTime()));\n-                }\n-\n-                if (txMessage.hasKeys()) {\n-                    entity.setKey(txMessage.getKeys().toByteArray());\n-                }\n-            }\n-        } else if (body.hasFileDelete()) {\n-            if (body.getFileDelete().hasFileID()) {\n-                if (doUpdateEntity) {\n-                    entity.setDeleted(true);\n-                }\n-            }\n-        } else if (body.hasFileUpdate()) {\n-            FileUpdateTransactionBody txMessage = body.getFileUpdate();\n-            if (doUpdateEntity) {\n-                if (txMessage.hasExpirationTime()) {\n-                    entity.setExpiryTimeNs(Utility.timestampInNanosMax(txMessage.getExpirationTime()));\n-                }\n-\n-                if (txMessage.hasKeys()) {\n-                    entity.setKey(txMessage.getKeys().toByteArray());\n-                }\n-            }\n-        } else if (body.hasSystemDelete()) {\n-            if (doUpdateEntity) {\n-                entity.setDeleted(true);\n-            }\n-        } else if (body.hasSystemUndelete()) {\n-            if (doUpdateEntity) {\n-                entity.setDeleted(false);\n-            }\n-        } else if (body.hasConsensusCreateTopic()) {\n-            consensusCreateTopicUpdateEntity(entity, body, txRecord);\n-        } else if (body.hasConsensusUpdateTopic()) {\n-            consensusUpdateTopicUpdateEntity(entity, body, txRecord);\n-        } else if (body.hasConsensusDeleteTopic()) {\n-            consensusDeleteTopicUpdateEntity(entity, body, txRecord);\n-        }\n-\n-        TransactionID transactionID = body.getTransactionID();\n-        long validDurationSeconds = body.hasTransactionValidDuration() ? body.getTransactionValidDuration()\n-                .getSeconds() : null;\n-        long validStartNs = Utility.timeStampInNanos(transactionID.getTransactionValidStart());\n-        AccountID payerAccountId = transactionID.getAccountID();\n-\n-        com.hedera.mirror.importer.domain.Transaction tx = new com.hedera.mirror.importer.domain.Transaction();\n-        tx.setChargedTxFee(txRecord.getTransactionFee());\n-        tx.setConsensusNs(consensusNs);\n-        tx.setInitialBalance(initialBalance);\n-        tx.setMemo(body.getMemo().getBytes());\n-        tx.setMaxFee(body.getTransactionFee());\n-        tx.setResult(txRecord.getReceipt().getStatusValue());\n-        tx.setType(transactionType);\n-        tx.setTransactionBytes(parserProperties.getPersist().isTransactionBytes() ?\n-                recordItem.getTransactionBytes() : null);\n-        tx.setTransactionHash(txRecord.getTransactionHash().toByteArray());\n-        tx.setValidDurationSeconds(validDurationSeconds);\n-        tx.setValidStartNs(validStartNs);\n-        if (entity != null) {\n+        //\n+        // Additionally, if transaction is successful:\n+        // - Fields of 'entity' will be updated.\n+        // - proxyAccountId/autoRenewAccountId: If present, the account's id are looked up (from big cache) or created\n+        //   immediately in TransactionHandler.updateEntity(..).\n+        if (transactionHandler.updatesEntity() && isSuccessful && entityId != null) {\n+            Entities entity = getEntity(entityId);\n+            transactionHandler.updateEntity(entity, recordItem);\n             tx.setEntity(entity);\n             entityRepository.save(entity);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "617acd2c6adcc310c45ba6841827f8808b7e265d"}, "originalPosition": 208}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "598d071e29b84f1a1f5a40e6889ef682330d344f", "author": {"user": {"login": "apeksharma", "name": "Apekshit Sharma"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/598d071e29b84f1a1f5a40e6889ef682330d344f", "committedDate": "2020-04-13T21:09:08Z", "message": "address review comments\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ba519e649f59f1a33dc17192c3f3f03666726445", "author": {"user": {"login": "apeksharma", "name": "Apekshit Sharma"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/ba519e649f59f1a33dc17192c3f3f03666726445", "committedDate": "2020-04-13T21:07:35Z", "message": "address review comments\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>"}, "afterCommit": {"oid": "598d071e29b84f1a1f5a40e6889ef682330d344f", "author": {"user": {"login": "apeksharma", "name": "Apekshit Sharma"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/598d071e29b84f1a1f5a40e6889ef682330d344f", "committedDate": "2020-04-13T21:09:08Z", "message": "address review comments\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNDY0OTk5", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#pullrequestreview-392464999", "createdAt": "2020-04-13T21:50:53Z", "commit": {"oid": "598d071e29b84f1a1f5a40e6889ef682330d344f"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "39ebf2f316b2df6b3db5367dc90174e9cd2584bb", "author": {"user": {"login": "apeksharma", "name": "Apekshit Sharma"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/39ebf2f316b2df6b3db5367dc90174e9cd2584bb", "committedDate": "2020-04-13T21:58:06Z", "message": "fix @Cacheable\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f4ded5344bbbb1645e518c01550aff315a5a4518", "author": {"user": {"login": "apeksharma", "name": "Apekshit Sharma"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/f4ded5344bbbb1645e518c01550aff315a5a4518", "committedDate": "2020-04-13T22:09:28Z", "message": "minor fix\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNDc0NTIy", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#pullrequestreview-392474522", "createdAt": "2020-04-13T22:10:22Z", "commit": {"oid": "f4ded5344bbbb1645e518c01550aff315a5a4518"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3065, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}