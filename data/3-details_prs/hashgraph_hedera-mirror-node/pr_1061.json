{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg5NDg3MzQ4", "number": 1061, "title": "HTS: Design document", "bodyText": "Detailed description:\nMain nodes are adding a TokenService to HAP, the Mirror Node needs to add support for this.\nThis change adds an HTS design doc with a design to support the changes\n\nSpecifies goals of Mirror HTS support\nSpecifies Database Schema updates needed to support tokens. Specifically adds new token and token_balance tables as well as updates transaction and response types\nSpecifies GRPC changes to support streaming of token transfers.\nSpecifies Importer changes. Specifically updates to balance CSV parsing and ingestion of new Token transaction bodies - - Specifies  REST API updates. Specifically updates to accounts and balances endpoints, swell as addition of Token REST APIs\n\nWhich issue(s) this PR fixes:\nFixes #1043\nSpecial notes for your reviewer:\nReviews should be done in the order of\n\nDatabase Schema Updates\nImporter Updates for Ingestion\nExisting REST API Updates\nAdditional Token REST API additions\nProtobuf updates to TokenService\nGRPC Token Service\n\n\nSome refactoring can and should be done especially on GRPC side. Feel free to note out of scope or overly invasive changes that aren't needed.\n\nTo-do's\n\n Revisit Balance ingestion to potentially support versions of CSV\n Revisit compatibility of account_balance accountNum and accountRealmNum with tables that use entity_id. Can queries be simplified\n Sequence diagram for GRPC Token Service\n\nChecklist\n\n Documentation added\n Tests updated", "createdAt": "2020-09-18T18:57:55Z", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061", "merged": true, "mergeCommit": {"oid": "0728965a26000f4709e9d556e282f75611a9f413"}, "closed": true, "closedAt": "2020-09-28T03:13:38Z", "author": {"login": "Nana-EC"}, "timelineItems": {"totalCount": 35, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdJpC19AH2gAyNDg5NDg3MzQ4OmE5ZmU0Y2EzNmEwZjk2N2I3MjdmNDc3Zjk0NDg3N2JkMTMxMDFiYTU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdMg4WJAFqTQ5NjkzMjM5NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "a9fe4ca36a0f967b727f477f944877bd13101ba5", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/a9fe4ca36a0f967b727f477f944877bd13101ba5", "committedDate": "2020-09-17T04:11:46Z", "message": "Added hts.md layout with initial thoughts\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2de885fdace0bad2ae5fed374ecaeb9d087364f6", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/2de885fdace0bad2ae5fed374ecaeb9d087364f6", "committedDate": "2020-09-18T04:22:10Z", "message": "Expanded on GRPC streaming and update token and token_balance tables\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d8117a3d920346e205ad977a511627275545e24", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/9d8117a3d920346e205ad977a511627275545e24", "committedDate": "2020-09-18T18:45:47Z", "message": "Added arch diagram and accounts API update\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/c0d10afc916502a8d590f05fb66be75ee4bb0830", "committedDate": "2020-09-18T21:13:32Z", "message": "Reordered layout for easier review\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dfd347bb2c8d946fc000f27f8c1b86576260a8e4", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/dfd347bb2c8d946fc000f27f8c1b86576260a8e4", "committedDate": "2020-09-18T21:55:32Z", "message": "Quick fixes and removed stale section\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxNzkwNDA3", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#pullrequestreview-491790407", "createdAt": "2020-09-18T21:26:54Z", "commit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMToyNjo1NFrOHUcXoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMTo1NDo1MVrOHUdClQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE5ODM2OQ==", "bodyText": "Ignore TokenBalanceSerializer, left over from a previous thought, will remove", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491198369", "createdAt": "2020-09-18T21:26:54Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),\n+        token_id            entity_id   not null,\n+        balance             bigint;\n+```\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Update `t_entities` table with token entity info, from the `TokenCreation.proto` object insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` class to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        consensus_timestamp bigint  primary key not null,\n+        symbol              character varying(96),\n+        token_id            entity_id,\n+        initial_supply      bigint,\n+        divisibility        bigint,\n+        treasury            entity_id,\n+        kyc_key             bytea,\n+        freeze_key          bytea,\n+        wipe_key            bytea,\n+        supply_key          bytea,\n+        freeze_default      boolean,\n+        kyc_default         boolean,\n+        freeze_default      boolean;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add `TokenBalanceSerializer` converter to handle object to JSON string serialization\n+```java\n+   @Named\n+   public class TokenBalanceSerializer extends JsonSerializer<List<TokenBalance>> {\n+       @Override\n+       public void serialize(List<TokenBalance> tokens, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+           if (value != null) {\n+               gen.writeStartArray();\n+               for (TokenBalance token: tokens) {\n+                   gen.writeStartObject();\n+                   gen.writeObjectField(\"token\", token);\n+                   gen.writeEndObject();\n+               }\n+               gen.writeEndArray();\n+           }\n+       }\n+   }\n+   ```\n+\n+or\n+\n+```java\n+    @Named\n+    public class TokenBalanceSerializer extends JsonSerializer<List<TokenBalance>> {\n+        @Override\n+        public void serialize(List<TokenBalance> tokens, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+            if (value != null) {\n+                gen.writeStartArray();\n+                for (TokenBalance token: tokens) {\n+                    gen.writeObject(token);\n+                }\n+                gen.writeEndArray();\n+            }\n+        }\n+    }\n+```", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE5OTIyMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            -   Add `TokenBalance` with `tokens` private class member\n          \n          \n            \n            -   Add `TokenBalance`", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491199220", "createdAt": "2020-09-18T21:29:35Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),\n+        token_id            entity_id   not null,\n+        balance             bigint;\n+```\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Update `t_entities` table with token entity info, from the `TokenCreation.proto` object insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` class to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        consensus_timestamp bigint  primary key not null,\n+        symbol              character varying(96),\n+        token_id            entity_id,\n+        initial_supply      bigint,\n+        divisibility        bigint,\n+        treasury            entity_id,\n+        kyc_key             bytea,\n+        freeze_key          bytea,\n+        wipe_key            bytea,\n+        supply_key          bytea,\n+        freeze_default      boolean,\n+        kyc_default         boolean,\n+        freeze_default      boolean;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add `TokenBalanceSerializer` converter to handle object to JSON string serialization\n+```java\n+   @Named\n+   public class TokenBalanceSerializer extends JsonSerializer<List<TokenBalance>> {\n+       @Override\n+       public void serialize(List<TokenBalance> tokens, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+           if (value != null) {\n+               gen.writeStartArray();\n+               for (TokenBalance token: tokens) {\n+                   gen.writeStartObject();\n+                   gen.writeObjectField(\"token\", token);\n+                   gen.writeEndObject();\n+               }\n+               gen.writeEndArray();\n+           }\n+       }\n+   }\n+   ```\n+\n+or\n+\n+```java\n+    @Named\n+    public class TokenBalanceSerializer extends JsonSerializer<List<TokenBalance>> {\n+        @Override\n+        public void serialize(List<TokenBalance> tokens, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+            if (value != null) {\n+                gen.writeStartArray();\n+                for (TokenBalance token: tokens) {\n+                    gen.writeObject(token);\n+                }\n+                gen.writeEndArray();\n+            }\n+        }\n+    }\n+```\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public FileIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+-   Add `TokenBalance` with `tokens` private class member", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIwMTQ0Nw==", "bodyText": "replace serialVersionUID w unique one as this was copied", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491201447", "createdAt": "2020-09-18T21:36:40Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),\n+        token_id            entity_id   not null,\n+        balance             bigint;\n+```\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Update `t_entities` table with token entity info, from the `TokenCreation.proto` object insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` class to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        consensus_timestamp bigint  primary key not null,\n+        symbol              character varying(96),\n+        token_id            entity_id,\n+        initial_supply      bigint,\n+        divisibility        bigint,\n+        treasury            entity_id,\n+        kyc_key             bytea,\n+        freeze_key          bytea,\n+        wipe_key            bytea,\n+        supply_key          bytea,\n+        freeze_default      boolean,\n+        kyc_default         boolean,\n+        freeze_default      boolean;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add `TokenBalanceSerializer` converter to handle object to JSON string serialization\n+```java\n+   @Named\n+   public class TokenBalanceSerializer extends JsonSerializer<List<TokenBalance>> {\n+       @Override\n+       public void serialize(List<TokenBalance> tokens, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+           if (value != null) {\n+               gen.writeStartArray();\n+               for (TokenBalance token: tokens) {\n+                   gen.writeStartObject();\n+                   gen.writeObjectField(\"token\", token);\n+                   gen.writeEndObject();\n+               }\n+               gen.writeEndArray();\n+           }\n+       }\n+   }\n+   ```\n+\n+or\n+\n+```java\n+    @Named\n+    public class TokenBalanceSerializer extends JsonSerializer<List<TokenBalance>> {\n+        @Override\n+        public void serialize(List<TokenBalance> tokens, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+            if (value != null) {\n+                gen.writeStartArray();\n+                for (TokenBalance token: tokens) {\n+                    gen.writeObject(token);\n+                }\n+                gen.writeEndArray();\n+            }\n+        }\n+    }\n+```\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public FileIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+-   Add `TokenBalance` with `tokens` private class member\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        private String symbol;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = -2399552489266593375L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIwMTk5MA==", "bodyText": "remove repeated\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    freeze_default      boolean;\n          \n          \n            \n            ;", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491201990", "createdAt": "2020-09-18T21:38:17Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),\n+        token_id            entity_id   not null,\n+        balance             bigint;\n+```\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Update `t_entities` table with token entity info, from the `TokenCreation.proto` object insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` class to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        consensus_timestamp bigint  primary key not null,\n+        symbol              character varying(96),\n+        token_id            entity_id,\n+        initial_supply      bigint,\n+        divisibility        bigint,\n+        treasury            entity_id,\n+        kyc_key             bytea,\n+        freeze_key          bytea,\n+        wipe_key            bytea,\n+        supply_key          bytea,\n+        freeze_default      boolean,\n+        kyc_default         boolean,\n+        freeze_default      boolean;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIwMjc0Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            -   Update `AccountBalanceLineParser.parse` to parse additional token columns representing `TokenRelationships`.\n          \n          \n            \n            -   Update `AccountBalanceLineParser.parse` to parse additional token column representing `TokenRelationships`.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491202747", "createdAt": "2020-09-18T21:40:40Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),\n+        token_id            entity_id   not null,\n+        balance             bigint;\n+```\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Update `t_entities` table with token entity info, from the `TokenCreation.proto` object insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` class to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        consensus_timestamp bigint  primary key not null,\n+        symbol              character varying(96),\n+        token_id            entity_id,\n+        initial_supply      bigint,\n+        divisibility        bigint,\n+        treasury            entity_id,\n+        kyc_key             bytea,\n+        freeze_key          bytea,\n+        wipe_key            bytea,\n+        supply_key          bytea,\n+        freeze_default      boolean,\n+        kyc_default         boolean,\n+        freeze_default      boolean;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add `TokenBalanceSerializer` converter to handle object to JSON string serialization\n+```java\n+   @Named\n+   public class TokenBalanceSerializer extends JsonSerializer<List<TokenBalance>> {\n+       @Override\n+       public void serialize(List<TokenBalance> tokens, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+           if (value != null) {\n+               gen.writeStartArray();\n+               for (TokenBalance token: tokens) {\n+                   gen.writeStartObject();\n+                   gen.writeObjectField(\"token\", token);\n+                   gen.writeEndObject();\n+               }\n+               gen.writeEndArray();\n+           }\n+       }\n+   }\n+   ```\n+\n+or\n+\n+```java\n+    @Named\n+    public class TokenBalanceSerializer extends JsonSerializer<List<TokenBalance>> {\n+        @Override\n+        public void serialize(List<TokenBalance> tokens, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+            if (value != null) {\n+                gen.writeStartArray();\n+                for (TokenBalance token: tokens) {\n+                    gen.writeObject(token);\n+                }\n+                gen.writeEndArray();\n+            }\n+        }\n+    }\n+```\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public FileIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+-   Add `TokenBalance` with `tokens` private class member\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        private String symbol;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = -2399552489266593375L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` and `symbol` class members, to allow it to represent both HBARs and Tokens\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String symbol;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasury;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+\n+\n+### Balance Persistence\n+\n+-   Update `AccountBalanceLineParser.parse` to parse additional token columns representing `TokenRelationships`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 282}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIwNTM5Mw==", "bodyText": "Add TransactionHandlers\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n            ### Transaction Handlers", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491205393", "createdAt": "2020-09-18T21:47:49Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),\n+        token_id            entity_id   not null,\n+        balance             bigint;\n+```\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Update `t_entities` table with token entity info, from the `TokenCreation.proto` object insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` class to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        consensus_timestamp bigint  primary key not null,\n+        symbol              character varying(96),\n+        token_id            entity_id,\n+        initial_supply      bigint,\n+        divisibility        bigint,\n+        treasury            entity_id,\n+        kyc_key             bytea,\n+        freeze_key          bytea,\n+        wipe_key            bytea,\n+        supply_key          bytea,\n+        freeze_default      boolean,\n+        kyc_default         boolean,\n+        freeze_default      boolean;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add `TokenBalanceSerializer` converter to handle object to JSON string serialization\n+```java\n+   @Named\n+   public class TokenBalanceSerializer extends JsonSerializer<List<TokenBalance>> {\n+       @Override\n+       public void serialize(List<TokenBalance> tokens, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+           if (value != null) {\n+               gen.writeStartArray();\n+               for (TokenBalance token: tokens) {\n+                   gen.writeStartObject();\n+                   gen.writeObjectField(\"token\", token);\n+                   gen.writeEndObject();\n+               }\n+               gen.writeEndArray();\n+           }\n+       }\n+   }\n+   ```\n+\n+or\n+\n+```java\n+    @Named\n+    public class TokenBalanceSerializer extends JsonSerializer<List<TokenBalance>> {\n+        @Override\n+        public void serialize(List<TokenBalance> tokens, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+            if (value != null) {\n+                gen.writeStartArray();\n+                for (TokenBalance token: tokens) {\n+                    gen.writeObject(token);\n+                }\n+                gen.writeEndArray();\n+            }\n+        }\n+    }\n+```\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public FileIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+-   Add `TokenBalance` with `tokens` private class member\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        private String symbol;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = -2399552489266593375L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` and `symbol` class members, to allow it to represent both HBARs and Tokens\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String symbol;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasury;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+\n+\n+### Balance Persistence\n+\n+-   Update `AccountBalanceLineParser.parse` to parse additional token columns representing `TokenRelationships`.\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance, symbol) values (?, ?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Add `UPDATE_TOKEN_STATUS` in `AccountBalancesFileLoader` to update changes to `kycStatus` and `freezeStatus`\n+```java\n+    private static final String UPDATE_TOKEN_STATUS = \"update token_balance set kyc_status = ?, \" +\n+                \"freeze_status = ? where token_id = ?\";\n+```\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 294}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIwNzA4OA==", "bodyText": "Eventually we'll need a tokenInfo endpoint\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            5.  Add a Token Discovery REST API to show available tokens on the network\n          \n          \n            \n            6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<symbol>`", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491207088", "createdAt": "2020-09-18T21:50:39Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),\n+        token_id            entity_id   not null,\n+        balance             bigint;\n+```\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Update `t_entities` table with token entity info, from the `TokenCreation.proto` object insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` class to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        consensus_timestamp bigint  primary key not null,\n+        symbol              character varying(96),\n+        token_id            entity_id,\n+        initial_supply      bigint,\n+        divisibility        bigint,\n+        treasury            entity_id,\n+        kyc_key             bytea,\n+        freeze_key          bytea,\n+        wipe_key            bytea,\n+        supply_key          bytea,\n+        freeze_default      boolean,\n+        kyc_default         boolean,\n+        freeze_default      boolean;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add `TokenBalanceSerializer` converter to handle object to JSON string serialization\n+```java\n+   @Named\n+   public class TokenBalanceSerializer extends JsonSerializer<List<TokenBalance>> {\n+       @Override\n+       public void serialize(List<TokenBalance> tokens, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+           if (value != null) {\n+               gen.writeStartArray();\n+               for (TokenBalance token: tokens) {\n+                   gen.writeStartObject();\n+                   gen.writeObjectField(\"token\", token);\n+                   gen.writeEndObject();\n+               }\n+               gen.writeEndArray();\n+           }\n+       }\n+   }\n+   ```\n+\n+or\n+\n+```java\n+    @Named\n+    public class TokenBalanceSerializer extends JsonSerializer<List<TokenBalance>> {\n+        @Override\n+        public void serialize(List<TokenBalance> tokens, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+            if (value != null) {\n+                gen.writeStartArray();\n+                for (TokenBalance token: tokens) {\n+                    gen.writeObject(token);\n+                }\n+                gen.writeEndArray();\n+            }\n+        }\n+    }\n+```\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public FileIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+-   Add `TokenBalance` with `tokens` private class member\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        private String symbol;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = -2399552489266593375L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` and `symbol` class members, to allow it to represent both HBARs and Tokens\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String symbol;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasury;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+\n+\n+### Balance Persistence\n+\n+-   Update `AccountBalanceLineParser.parse` to parse additional token columns representing `TokenRelationships`.\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance, symbol) values (?, ?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Add `UPDATE_TOKEN_STATUS` in `AccountBalancesFileLoader` to update changes to `kycStatus` and `freezeStatus`\n+```java\n+    private static final String UPDATE_TOKEN_STATUS = \"update token_balance set kyc_status = ?, \" +\n+                \"freeze_status = ? where token_id = ?\";\n+```\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer`. Also pulling out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId token, String symbol) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId, symbol));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for tokenId and symbol\n+\n+> _Note 1:_ For improved API calls it would be valuable to insert the symbol for cryptoTransfers. This is only available on the tokenCreate transaction, so a caching mechanism can be explored ot make this available for transfers\n+\n+> _Note 2:_ There's an opportunity to refactor the `OnItem()` to focus better on different TransactionBody types but not necessarily within scope\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts\n+5.  Add a Token Discovery REST API to show available tokens on the network", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 321}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIwNzg4Mg==", "bodyText": "Add api url here for context", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491207882", "createdAt": "2020-09-18T21:52:17Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),\n+        token_id            entity_id   not null,\n+        balance             bigint;\n+```\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Update `t_entities` table with token entity info, from the `TokenCreation.proto` object insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` class to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        consensus_timestamp bigint  primary key not null,\n+        symbol              character varying(96),\n+        token_id            entity_id,\n+        initial_supply      bigint,\n+        divisibility        bigint,\n+        treasury            entity_id,\n+        kyc_key             bytea,\n+        freeze_key          bytea,\n+        wipe_key            bytea,\n+        supply_key          bytea,\n+        freeze_default      boolean,\n+        kyc_default         boolean,\n+        freeze_default      boolean;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add `TokenBalanceSerializer` converter to handle object to JSON string serialization\n+```java\n+   @Named\n+   public class TokenBalanceSerializer extends JsonSerializer<List<TokenBalance>> {\n+       @Override\n+       public void serialize(List<TokenBalance> tokens, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+           if (value != null) {\n+               gen.writeStartArray();\n+               for (TokenBalance token: tokens) {\n+                   gen.writeStartObject();\n+                   gen.writeObjectField(\"token\", token);\n+                   gen.writeEndObject();\n+               }\n+               gen.writeEndArray();\n+           }\n+       }\n+   }\n+   ```\n+\n+or\n+\n+```java\n+    @Named\n+    public class TokenBalanceSerializer extends JsonSerializer<List<TokenBalance>> {\n+        @Override\n+        public void serialize(List<TokenBalance> tokens, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+            if (value != null) {\n+                gen.writeStartArray();\n+                for (TokenBalance token: tokens) {\n+                    gen.writeObject(token);\n+                }\n+                gen.writeEndArray();\n+            }\n+        }\n+    }\n+```\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public FileIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+-   Add `TokenBalance` with `tokens` private class member\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        private String symbol;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = -2399552489266593375L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` and `symbol` class members, to allow it to represent both HBARs and Tokens\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String symbol;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasury;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+\n+\n+### Balance Persistence\n+\n+-   Update `AccountBalanceLineParser.parse` to parse additional token columns representing `TokenRelationships`.\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance, symbol) values (?, ?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Add `UPDATE_TOKEN_STATUS` in `AccountBalancesFileLoader` to update changes to `kycStatus` and `freezeStatus`\n+```java\n+    private static final String UPDATE_TOKEN_STATUS = \"update token_balance set kyc_status = ?, \" +\n+                \"freeze_status = ? where token_id = ?\";\n+```\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer`. Also pulling out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId token, String symbol) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId, symbol));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for tokenId and symbol\n+\n+> _Note 1:_ For improved API calls it would be valuable to insert the symbol for cryptoTransfers. This is only available on the tokenCreate transaction, so a caching mechanism can be explored ot make this available for transfers\n+\n+> _Note 2:_ There's an opportunity to refactor the `OnItem()` to focus better on different TransactionBody types but not necessarily within scope\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 320}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIwODU2Mg==", "bodyText": "Need to circle back, these were initial suggestions based on current API's", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491208562", "createdAt": "2020-09-18T21:53:28Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),\n+        token_id            entity_id   not null,\n+        balance             bigint;\n+```\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Update `t_entities` table with token entity info, from the `TokenCreation.proto` object insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` class to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        consensus_timestamp bigint  primary key not null,\n+        symbol              character varying(96),\n+        token_id            entity_id,\n+        initial_supply      bigint,\n+        divisibility        bigint,\n+        treasury            entity_id,\n+        kyc_key             bytea,\n+        freeze_key          bytea,\n+        wipe_key            bytea,\n+        supply_key          bytea,\n+        freeze_default      boolean,\n+        kyc_default         boolean,\n+        freeze_default      boolean;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add `TokenBalanceSerializer` converter to handle object to JSON string serialization\n+```java\n+   @Named\n+   public class TokenBalanceSerializer extends JsonSerializer<List<TokenBalance>> {\n+       @Override\n+       public void serialize(List<TokenBalance> tokens, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+           if (value != null) {\n+               gen.writeStartArray();\n+               for (TokenBalance token: tokens) {\n+                   gen.writeStartObject();\n+                   gen.writeObjectField(\"token\", token);\n+                   gen.writeEndObject();\n+               }\n+               gen.writeEndArray();\n+           }\n+       }\n+   }\n+   ```\n+\n+or\n+\n+```java\n+    @Named\n+    public class TokenBalanceSerializer extends JsonSerializer<List<TokenBalance>> {\n+        @Override\n+        public void serialize(List<TokenBalance> tokens, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+            if (value != null) {\n+                gen.writeStartArray();\n+                for (TokenBalance token: tokens) {\n+                    gen.writeObject(token);\n+                }\n+                gen.writeEndArray();\n+            }\n+        }\n+    }\n+```\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public FileIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+-   Add `TokenBalance` with `tokens` private class member\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        private String symbol;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = -2399552489266593375L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` and `symbol` class members, to allow it to represent both HBARs and Tokens\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String symbol;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasury;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+\n+\n+### Balance Persistence\n+\n+-   Update `AccountBalanceLineParser.parse` to parse additional token columns representing `TokenRelationships`.\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance, symbol) values (?, ?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Add `UPDATE_TOKEN_STATUS` in `AccountBalancesFileLoader` to update changes to `kycStatus` and `freezeStatus`\n+```java\n+    private static final String UPDATE_TOKEN_STATUS = \"update token_balance set kyc_status = ?, \" +\n+                \"freeze_status = ? where token_id = ?\";\n+```\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer`. Also pulling out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId token, String symbol) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId, symbol));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for tokenId and symbol\n+\n+> _Note 1:_ For improved API calls it would be valuable to insert the symbol for cryptoTransfers. This is only available on the tokenCreate transaction, so a caching mechanism can be explored ot make this available for transfers\n+\n+> _Note 2:_ There's an opportunity to refactor the `OnItem()` to focus better on different TransactionBody types but not necessarily within scope\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts\n+5.  Add a Token Discovery REST API to show available tokens on the network\n+\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"symbol\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"symbol\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` and `symbol` columns from `token_balance` where `token_balance.id` = <tokenId> and assign each row to an element of `tokenBalances`\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"symbol\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+To achieve this\n+-   Update `balances.js` `getBalances()` to pull the `balance` and `symbol` columns from `token_balance` where `token_balance.id` = <tokenId> and assign each row to an element of `tokenBalances`\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"tokenTransfers\": [\n+            {\n+              \"currency\":\"0.0.5555\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.1111\", \"amount\": -10},\n+                {\"account\": \"0.0.2222\", \"amount\": 10}\n+              ]\n+            },\n+            {\n+              \"currency\": \"0.0.6666\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.3333\", \"amount\": -10},\n+                {\"account\": \"0.0.4444\", \"amount\": 10}\n+               ]\n+            }\n+          ]\n+        }\n+      ]\n+    }\n+```\n+\n+To achieve this\n+-   Update `transactions.js` sql queries for `crypto_transfer` to pull the `token_id` and `symbol` columns\n+-   Update `createTransferLists()` in `transactions.js` to build a `tokenTransfers` list if `symbol` isn't HBAR or if `token_id` is empty\n+\n+\n+### Token Supply distribution\n+\n+`/api/v1/tokens/<symbol>/balances` this could be the equivalent of `/api/v1/balances?symbol=<symbol>` currently and would return a list of account and the token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokenBalances\": [\n+          {\n+            \"account\": \"0.15.10\",\n+            \"balance\": 100\n+          },\n+          {\n+            \"account\": \"0.15.9\",\n+            \"balance\": 90\n+          },\n+          {\n+            \"account\": \"0.15.8\",\n+            \"balance\": 80\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+To achieve this similar to balances\n+-   Create a `tokenBalance.js`\n+-   Add a `getTokenBalances()` which based on the time range provided (default to latest timestamp) and token `symbol` pulls out all the  `balance` and `symbol` values and returns them as an element in `tokenBalances` array\n+\n+```sql\n+    select account_id, balance from token_balance where symbol = ? and consensus_timestamp = (select max(consensus_timestamp) from token_balance);\n+```\n+\n+Query parameters should include", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 496}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIwOTI0OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Query parameters should include\n          \n          \n            \n            Optional Filters", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491209248", "createdAt": "2020-09-18T21:54:42Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),\n+        token_id            entity_id   not null,\n+        balance             bigint;\n+```\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Update `t_entities` table with token entity info, from the `TokenCreation.proto` object insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` class to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        consensus_timestamp bigint  primary key not null,\n+        symbol              character varying(96),\n+        token_id            entity_id,\n+        initial_supply      bigint,\n+        divisibility        bigint,\n+        treasury            entity_id,\n+        kyc_key             bytea,\n+        freeze_key          bytea,\n+        wipe_key            bytea,\n+        supply_key          bytea,\n+        freeze_default      boolean,\n+        kyc_default         boolean,\n+        freeze_default      boolean;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add `TokenBalanceSerializer` converter to handle object to JSON string serialization\n+```java\n+   @Named\n+   public class TokenBalanceSerializer extends JsonSerializer<List<TokenBalance>> {\n+       @Override\n+       public void serialize(List<TokenBalance> tokens, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+           if (value != null) {\n+               gen.writeStartArray();\n+               for (TokenBalance token: tokens) {\n+                   gen.writeStartObject();\n+                   gen.writeObjectField(\"token\", token);\n+                   gen.writeEndObject();\n+               }\n+               gen.writeEndArray();\n+           }\n+       }\n+   }\n+   ```\n+\n+or\n+\n+```java\n+    @Named\n+    public class TokenBalanceSerializer extends JsonSerializer<List<TokenBalance>> {\n+        @Override\n+        public void serialize(List<TokenBalance> tokens, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+            if (value != null) {\n+                gen.writeStartArray();\n+                for (TokenBalance token: tokens) {\n+                    gen.writeObject(token);\n+                }\n+                gen.writeEndArray();\n+            }\n+        }\n+    }\n+```\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public FileIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+-   Add `TokenBalance` with `tokens` private class member\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        private String symbol;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = -2399552489266593375L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` and `symbol` class members, to allow it to represent both HBARs and Tokens\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String symbol;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasury;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+\n+\n+### Balance Persistence\n+\n+-   Update `AccountBalanceLineParser.parse` to parse additional token columns representing `TokenRelationships`.\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance, symbol) values (?, ?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Add `UPDATE_TOKEN_STATUS` in `AccountBalancesFileLoader` to update changes to `kycStatus` and `freezeStatus`\n+```java\n+    private static final String UPDATE_TOKEN_STATUS = \"update token_balance set kyc_status = ?, \" +\n+                \"freeze_status = ? where token_id = ?\";\n+```\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer`. Also pulling out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId token, String symbol) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId, symbol));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for tokenId and symbol\n+\n+> _Note 1:_ For improved API calls it would be valuable to insert the symbol for cryptoTransfers. This is only available on the tokenCreate transaction, so a caching mechanism can be explored ot make this available for transfers\n+\n+> _Note 2:_ There's an opportunity to refactor the `OnItem()` to focus better on different TransactionBody types but not necessarily within scope\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts\n+5.  Add a Token Discovery REST API to show available tokens on the network\n+\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"symbol\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"symbol\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` and `symbol` columns from `token_balance` where `token_balance.id` = <tokenId> and assign each row to an element of `tokenBalances`\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"symbol\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+To achieve this\n+-   Update `balances.js` `getBalances()` to pull the `balance` and `symbol` columns from `token_balance` where `token_balance.id` = <tokenId> and assign each row to an element of `tokenBalances`\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"tokenTransfers\": [\n+            {\n+              \"currency\":\"0.0.5555\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.1111\", \"amount\": -10},\n+                {\"account\": \"0.0.2222\", \"amount\": 10}\n+              ]\n+            },\n+            {\n+              \"currency\": \"0.0.6666\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.3333\", \"amount\": -10},\n+                {\"account\": \"0.0.4444\", \"amount\": 10}\n+               ]\n+            }\n+          ]\n+        }\n+      ]\n+    }\n+```\n+\n+To achieve this\n+-   Update `transactions.js` sql queries for `crypto_transfer` to pull the `token_id` and `symbol` columns\n+-   Update `createTransferLists()` in `transactions.js` to build a `tokenTransfers` list if `symbol` isn't HBAR or if `token_id` is empty\n+\n+\n+### Token Supply distribution\n+\n+`/api/v1/tokens/<symbol>/balances` this could be the equivalent of `/api/v1/balances?symbol=<symbol>` currently and would return a list of account and the token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokenBalances\": [\n+          {\n+            \"account\": \"0.15.10\",\n+            \"balance\": 100\n+          },\n+          {\n+            \"account\": \"0.15.9\",\n+            \"balance\": 90\n+          },\n+          {\n+            \"account\": \"0.15.8\",\n+            \"balance\": 80\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+To achieve this similar to balances\n+-   Create a `tokenBalance.js`\n+-   Add a `getTokenBalances()` which based on the time range provided (default to latest timestamp) and token `symbol` pulls out all the  `balance` and `symbol` values and returns them as an element in `tokenBalances` array\n+\n+```sql\n+    select account_id, balance from token_balance where symbol = ? and consensus_timestamp = (select max(consensus_timestamp) from token_balance);\n+```\n+\n+Query parameters should include", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 496}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIwOTM2NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Additions\n          \n          \n            \n            Optional Filters", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491209365", "createdAt": "2020-09-18T21:54:51Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),\n+        token_id            entity_id   not null,\n+        balance             bigint;\n+```\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Update `t_entities` table with token entity info, from the `TokenCreation.proto` object insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` class to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        consensus_timestamp bigint  primary key not null,\n+        symbol              character varying(96),\n+        token_id            entity_id,\n+        initial_supply      bigint,\n+        divisibility        bigint,\n+        treasury            entity_id,\n+        kyc_key             bytea,\n+        freeze_key          bytea,\n+        wipe_key            bytea,\n+        supply_key          bytea,\n+        freeze_default      boolean,\n+        kyc_default         boolean,\n+        freeze_default      boolean;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add `TokenBalanceSerializer` converter to handle object to JSON string serialization\n+```java\n+   @Named\n+   public class TokenBalanceSerializer extends JsonSerializer<List<TokenBalance>> {\n+       @Override\n+       public void serialize(List<TokenBalance> tokens, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+           if (value != null) {\n+               gen.writeStartArray();\n+               for (TokenBalance token: tokens) {\n+                   gen.writeStartObject();\n+                   gen.writeObjectField(\"token\", token);\n+                   gen.writeEndObject();\n+               }\n+               gen.writeEndArray();\n+           }\n+       }\n+   }\n+   ```\n+\n+or\n+\n+```java\n+    @Named\n+    public class TokenBalanceSerializer extends JsonSerializer<List<TokenBalance>> {\n+        @Override\n+        public void serialize(List<TokenBalance> tokens, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+            if (value != null) {\n+                gen.writeStartArray();\n+                for (TokenBalance token: tokens) {\n+                    gen.writeObject(token);\n+                }\n+                gen.writeEndArray();\n+            }\n+        }\n+    }\n+```\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public FileIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+-   Add `TokenBalance` with `tokens` private class member\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        private String symbol;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = -2399552489266593375L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` and `symbol` class members, to allow it to represent both HBARs and Tokens\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String symbol;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasury;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+\n+\n+### Balance Persistence\n+\n+-   Update `AccountBalanceLineParser.parse` to parse additional token columns representing `TokenRelationships`.\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance, symbol) values (?, ?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Add `UPDATE_TOKEN_STATUS` in `AccountBalancesFileLoader` to update changes to `kycStatus` and `freezeStatus`\n+```java\n+    private static final String UPDATE_TOKEN_STATUS = \"update token_balance set kyc_status = ?, \" +\n+                \"freeze_status = ? where token_id = ?\";\n+```\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer`. Also pulling out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId token, String symbol) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId, symbol));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for tokenId and symbol\n+\n+> _Note 1:_ For improved API calls it would be valuable to insert the symbol for cryptoTransfers. This is only available on the tokenCreate transaction, so a caching mechanism can be explored ot make this available for transfers\n+\n+> _Note 2:_ There's an opportunity to refactor the `OnItem()` to focus better on different TransactionBody types but not necessarily within scope\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts\n+5.  Add a Token Discovery REST API to show available tokens on the network\n+\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"symbol\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"symbol\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` and `symbol` columns from `token_balance` where `token_balance.id` = <tokenId> and assign each row to an element of `tokenBalances`\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"symbol\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+To achieve this\n+-   Update `balances.js` `getBalances()` to pull the `balance` and `symbol` columns from `token_balance` where `token_balance.id` = <tokenId> and assign each row to an element of `tokenBalances`\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"tokenTransfers\": [\n+            {\n+              \"currency\":\"0.0.5555\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.1111\", \"amount\": -10},\n+                {\"account\": \"0.0.2222\", \"amount\": 10}\n+              ]\n+            },\n+            {\n+              \"currency\": \"0.0.6666\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.3333\", \"amount\": -10},\n+                {\"account\": \"0.0.4444\", \"amount\": 10}\n+               ]\n+            }\n+          ]\n+        }\n+      ]\n+    }\n+```\n+\n+To achieve this\n+-   Update `transactions.js` sql queries for `crypto_transfer` to pull the `token_id` and `symbol` columns\n+-   Update `createTransferLists()` in `transactions.js` to build a `tokenTransfers` list if `symbol` isn't HBAR or if `token_id` is empty\n+\n+\n+### Token Supply distribution\n+\n+`/api/v1/tokens/<symbol>/balances` this could be the equivalent of `/api/v1/balances?symbol=<symbol>` currently and would return a list of account and the token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokenBalances\": [\n+          {\n+            \"account\": \"0.15.10\",\n+            \"balance\": 100\n+          },\n+          {\n+            \"account\": \"0.15.9\",\n+            \"balance\": 90\n+          },\n+          {\n+            \"account\": \"0.15.8\",\n+            \"balance\": 80\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+To achieve this similar to balances\n+-   Create a `tokenBalance.js`\n+-   Add a `getTokenBalances()` which based on the time range provided (default to latest timestamp) and token `symbol` pulls out all the  `balance` and `symbol` values and returns them as an element in `tokenBalances` array\n+\n+```sql\n+    select account_id, balance from token_balance where symbol = ? and consensus_timestamp = (select max(consensus_timestamp) from token_balance);\n+```\n+\n+Query parameters should include\n+-   `/api/v1/tokens/<symbol>/balances?id=0.0.1000`\n+-   `/api/v1/tokens/<symbol>/balances?balance=gt:1000`\n+-   `/api/v1/tokens/<symbol>/balances?timestamp=1566562500.040961001`\n+\n+### Token Discovery\n+`/api/v1/tokens` this would return all tokens present on the network\n+\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokens\": [\n+          {\n+            \"symbol\": \"FOOBAR\",\n+            \"tokenId\": \"0.15.10\",\n+            \"key\": {\n+              \"_type\": \"ProtobufEncoded\",\n+              \"key\": \"7b2233222c2233222c2233227d\"\n+            }\n+          },\n+          {\n+            \"symbol\": \"FOOCOIN\",\n+            \"tokenId\": \"0.15.10\",\n+            \"key\": {\n+              \"_type\": \"ProtobufEncoded\",\n+              \"key\": \"9c2233222c2233222c2233227d\"\n+            }\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+To achieve this\n+-   Add a `getTokens()` to `tokenBalance.js` which pull the unique `symbol`, `tokenId` from the `token` table and joins with the `t_entities` table for the matching admin_key\n+\n+```sql\n+    select symbol, tokenId e.key from token t\n+          join t_entities e on t.token_id = e.id and e.fk_entity_type_id = ${utils.ENTITY_TYPE_TOKEN};\n+```\n+\n+Additions", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 539}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxODEyMzEx", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#pullrequestreview-491812311", "createdAt": "2020-09-18T22:17:05Z", "commit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMjoxNzowNlrOHUdjGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMjo1NTowN1rOHUeH3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIxNzY5MA==", "bodyText": "Let's not mention specific versions as things can always change.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491217690", "createdAt": "2020-09-18T22:17:06Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIxNzc4Mw==", "bodyText": "nit: through its APIs", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491217783", "createdAt": "2020-09-18T22:17:27Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIxOTE4Mg==", "bodyText": "Shouldn't duplicate symbol. token_id is enough.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491219182", "createdAt": "2020-09-18T22:22:43Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIxOTc1OA==", "bodyText": "We shouldn't duplicate storage of the symbol especially in our biggest table. Also, I think token ID is immutable but token symbol is mutable. token_id should be enough.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491219758", "createdAt": "2020-09-18T22:25:02Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyNTg4MA==", "bodyText": "Should token_id be the primary key? It depends on how queries will use it. Definitely token_id should have a unique index on it.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491225880", "createdAt": "2020-09-18T22:50:00Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),\n+        token_id            entity_id   not null,\n+        balance             bigint;\n+```\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Update `t_entities` table with token entity info, from the `TokenCreation.proto` object insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` class to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        consensus_timestamp bigint  primary key not null,\n+        symbol              character varying(96),\n+        token_id            entity_id,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyNTk1OQ==", "bodyText": "treasury_account or treasury_account_id", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491225959", "createdAt": "2020-09-18T22:50:14Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),\n+        token_id            entity_id   not null,\n+        balance             bigint;\n+```\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Update `t_entities` table with token entity info, from the `TokenCreation.proto` object insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` class to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        consensus_timestamp bigint  primary key not null,\n+        symbol              character varying(96),\n+        token_id            entity_id,\n+        initial_supply      bigint,\n+        divisibility        bigint,\n+        treasury            entity_id,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyNjE2OQ==", "bodyText": "Have we confirmed with services if there's any limit imposed on the symbol size? There probably should be a limit since it's stored in state.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491226169", "createdAt": "2020-09-18T22:51:13Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),\n+        token_id            entity_id   not null,\n+        balance             bigint;\n+```\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Update `t_entities` table with token entity info, from the `TokenCreation.proto` object insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` class to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        consensus_timestamp bigint  primary key not null,\n+        symbol              character varying(96),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyNjY1OQ==", "bodyText": "Would prefer column names sorted since any other order would be arbitrary.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491226659", "createdAt": "2020-09-18T22:53:15Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),\n+        token_id            entity_id   not null,\n+        balance             bigint;\n+```\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Update `t_entities` table with token entity info, from the `TokenCreation.proto` object insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` class to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyNzEwMA==", "bodyText": "Are any of these keys equivalent to the submit_key that would make sense to reuse that field?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r491227100", "createdAt": "2020-09-18T22:55:07Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,748 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through the API's.\n+\n+This document highlights the architecture and design changes to be made on top of v0.19.0 code to support HTS.\n+Changes should be applied in order of\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion\n+3.  Existing REST API Updates\n+4.  Additional Token REST API additions\n+5.  Protobuf updates to TokenService\n+6.  GRPC Token Service\n+\n+## Goals\n+-   Ingest HTS related transactions from record streams from the mainnet and persist information to the database\n+-   Ingest token balances from balances streams from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following schema changes should be made\n+1. `t_entities` and ` t_entity_types` need to be update to represent new TOKEN entity\n+2. New `token_balance` table is added to persist token only balances\n+3. New `token` table is added to capture token specific entity items\n+4. `crypto_transfer` table should be updated to persist token transfers and also distinguish between HBAR and other token transfers\n+5. Update transaction types and results to handle token transactions from network.\n+\n+### Crypto Transfer\n+-   Add columns to `crypto_transfer` table. Symbol can be pulled from a `TransactionReceipt#tokenId` of transaction\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id\n+        add column symbol   character varying(96) not null;\n+```\n+-   Add migration logic to insert default \"HBAR\" for `symbol` column in `crypto_transfer` for historic data\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    create table if not exists token_balance\n+        consensus_timestamp bigint      primary key not null,\n+        symbol              character   varying(96),\n+        token_id            entity_id   not null,\n+        balance             bigint;\n+```\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Update `t_entities` table with token entity info, from the `TokenCreation.proto` object insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` class to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        consensus_timestamp bigint  primary key not null,\n+        symbol              character varying(96),\n+        token_id            entity_id,\n+        initial_supply      bigint,\n+        divisibility        bigint,\n+        treasury            entity_id,\n+        kyc_key             bytea,\n+        freeze_key          bytea,\n+        wipe_key            bytea,\n+        supply_key          bytea,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0d10afc916502a8d590f05fb66be75ee4bb0830"}, "originalPosition": 146}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c09e9378dc1c0499434b7261590b984421f2e3c3", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/c09e9378dc1c0499434b7261590b984421f2e3c3", "committedDate": "2020-09-20T03:56:13Z", "message": "Removed mutable symbol from tables other than token and added token_account_info tables\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86c125d459179a1725063143136544fe6ec7c347", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/86c125d459179a1725063143136544fe6ec7c347", "committedDate": "2020-09-21T03:51:56Z", "message": "Fixed some stale references\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3fb7b07d5be4abbb4a6e54575b23ba8405bf045d", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/3fb7b07d5be4abbb4a6e54575b23ba8405bf045d", "committedDate": "2020-09-21T16:34:03Z", "message": "Added account_balance migration and used token instead of symbol\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/50c3cd0fcb93eb78476f370e089704ee734118b3", "committedDate": "2020-09-21T17:17:04Z", "message": "Update schmea update lines for token_balance and crypto_transfer\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyOTE1MzYy", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#pullrequestreview-492915362", "createdAt": "2020-09-21T19:27:08Z", "commit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxOToyNzowOFrOHVfU1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxOToyOTo0N1rOHVfaQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NTM4MQ==", "bodyText": "nit: need to fix sql format.\nShould be\ncreate table if not exists token_account_info\n(\n...\n);", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492295381", "createdAt": "2020-09-21T19:27:08Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NTYxMA==", "bodyText": "nit: need to fix sql format.\nShould be\ncreate table if not exists token_balance\n(\n...\n);", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492295610", "createdAt": "2020-09-21T19:27:32Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NTc2Mg==", "bodyText": "nit: need to fix sql format.\nShould be\ncreate table if not exists token\n(\n...\n);", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492295762", "createdAt": "2020-09-21T19:27:47Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NjYzMw==", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    consensus_timestamp bigint              primary key not null\n          \n          \n            \n                    consensus_timestamp bigint              primary key not null,", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492296633", "createdAt": "2020-09-21T19:29:31Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5Njc3MQ==", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    balance             bigint              not null\n          \n          \n            \n                    balance             bigint              not null,", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492296771", "createdAt": "2020-09-21T19:29:47Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 79}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzMDEyMDE3", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#pullrequestreview-493012017", "createdAt": "2020-09-21T22:03:35Z", "commit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMjowMzozNVrOHVj-Cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMjowMzozNVrOHVj-Cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM3MTQ2Ng==", "bodyText": "nit: extra space after stream\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            -   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n          \n          \n            \n            -   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492371466", "createdAt": "2020-09-21T22:03:35Z", "author": {"login": "ijungmann"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 19}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzMDEzMDYz", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#pullrequestreview-493013063", "createdAt": "2020-09-21T22:05:27Z", "commit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMjowNToyN1rOHVkBRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMjowNToyN1rOHVkBRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM3MjI5Mg==", "bodyText": "nit: apostrophe not needed.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n          \n          \n            \n            The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492372292", "createdAt": "2020-09-21T22:05:27Z", "author": {"login": "ijungmann"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 6}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzMDI2MTMy", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#pullrequestreview-493026132", "createdAt": "2020-09-21T22:33:16Z", "commit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMjozMzoxNlrOHVkr2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMzo1NzozOVrOHVmUvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM4MzE5Mw==", "bodyText": "Would be better to name this hts-architecture.png so it's clear it's related to hts.md and it's similar to how hcs is named.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492383193", "createdAt": "2020-09-21T22:33:16Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM4NDQ2OQ==", "bodyText": "third party integration", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492384469", "createdAt": "2020-09-21T22:36:41Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQwMzA1NQ==", "bodyText": "Did you give any thought to separate token transfers and crypto transfers? If we want to stream token transfers or serve transfers via a standalone REST API, having them in separate tables would greatly improve the performance of those queries.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492403055", "createdAt": "2020-09-21T23:32:45Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQwMzMwNw==", "bodyText": "As this will be done before token work and in a separate PR, it shouldn't be included here. Same thing for changes related to this. None of them are related to HTS specifically.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492403307", "createdAt": "2020-09-21T23:33:39Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQxMDA0Ng==", "bodyText": "I'm not sure how this data is different enough to warrant its own table separate from token. Freeze, kyc and wiped are all just flags that are associated with a token.\nThey can be updated at any time just like most other fields that are in the token table like the keys. I also don't see the distinction how these are considered metadata but the keys are not? Logically they belong with the token table, in my opinion. Do you see some retrieval use case that warrants it being separate for performance reasons?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492410046", "createdAt": "2020-09-21T23:57:39Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 88}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzMTA4Mjg1", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#pullrequestreview-493108285", "createdAt": "2020-09-22T03:36:15Z", "commit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwMzozNjoxNVrOHVpN3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwMzozNjoxNVrOHVpN3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ1NzQzNw==", "bodyText": "nit: and/or\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            -   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n          \n          \n            \n            -   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492457437", "createdAt": "2020-09-22T03:36:15Z", "author": {"login": "ijungmann"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzMDY4Mjc4", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#pullrequestreview-493068278", "createdAt": "2020-09-22T00:40:53Z", "commit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwMDo0MDo1M1rOHVm-mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwMDo0Nzo1MlrOHVnEyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQyMDc2Mg==", "bodyText": "Primary key should be Id instead as consensus_timestamp is not required here.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    consensus_timestamp bigint              primary key,\n          \n          \n            \n                   id                  serial              primary key,\n          \n      \n    \n    \n  \n\nAlso unique constraint of token_id, account_id", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492420762", "createdAt": "2020-09-22T00:40:53Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQyMjM0Ng==", "bodyText": "Unless the question of when was the last update made to the token-account metadata.\nCould add a last_update_timestamp e.g.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    consensus_timestamp bigint              primary key,\n          \n          \n            \n                    id                      serial              primary key,\n          \n          \n            \n                    last_update_timestamp   bigint              not null,", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492422346", "createdAt": "2020-09-22T00:47:52Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQyMDc2Mg=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 89}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTc0NzEw", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#pullrequestreview-493574710", "createdAt": "2020-09-22T15:16:03Z", "commit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNToxNjowNFrOHV_YLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNjoxMjowM1rOHWB9Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgyMDUyNA==", "bodyText": "can supply_key be null? It's not explicitly stated in the doc, so I believe it's a required field", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492820524", "createdAt": "2020-09-22T15:16:04Z", "author": {"login": "xin-hedera"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgyNjM5MA==", "bodyText": "better rename it to symbol to be consistent with the design doc the HAPI protobuf.\nThere are Name and Symbol string fields in the design doc, we should ask for clarification since Name is also missing in HAPI protobuf", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492826390", "createdAt": "2020-09-22T15:23:24Z", "author": {"login": "xin-hedera"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgzNTMxMg==", "bodyText": "In protobuf, float (same as initialSupply) is uint64 and divisibility is uint32", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492835312", "createdAt": "2020-09-22T15:34:32Z", "author": {"login": "xin-hedera"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 280}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgzODA1MQ==", "bodyText": "should mention base64 encoding", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492838051", "createdAt": "2020-09-22T15:38:05Z", "author": {"login": "xin-hedera"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 293}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg0ODMzNw==", "bodyText": "should clarify the value of token can be either the tokenId or symbol", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492848337", "createdAt": "2020-09-22T15:51:51Z", "author": {"login": "xin-hedera"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"token\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"token\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"token\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+To achieve this\n+-   Update `balances.js` `getBalances()` to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"token\":\"FOOBAR\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 470}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg0OTI2Mg==", "bodyText": "token symbol is unique, we also need an index", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492849262", "createdAt": "2020-09-22T15:53:11Z", "author": {"login": "xin-hedera"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgyNjM5MA=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg1ODEyOQ==", "bodyText": "should this be adminKey?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492858129", "createdAt": "2020-09-22T16:05:16Z", "author": {"login": "xin-hedera"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"token\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"token\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"token\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+To achieve this\n+-   Update `balances.js` `getBalances()` to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"token\":\"FOOBAR\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.1111\", \"amount\": -10},\n+                {\"account\": \"0.0.2222\", \"amount\": 10}\n+              ]\n+            },\n+            {\n+              \"token\":\"FOOCOIN\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.3333\", \"amount\": -10},\n+                {\"account\": \"0.0.4444\", \"amount\": 10}\n+               ]\n+            }\n+          ]\n+        }\n+      ]\n+    }\n+```\n+\n+To achieve this\n+-   Update `transactions.js` sql queries for `crypto_transfer` to pull the `token_id` and `token` columns\n+-   Update `createTransferLists()` in `transactions.js` to build a `tokenTransfers` list if `token` isn't HBAR or if `token_id` is empty\n+\n+\n+### Token Supply distribution\n+\n+`/api/v1/tokens/<token>/balances` this could be the equivalent of `/api/v1/balances?token=<token>` currently and would return a list of account and the token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokenBalances\": [\n+          {\n+            \"account\": \"0.15.10\",\n+            \"balance\": 100\n+          },\n+          {\n+            \"account\": \"0.15.9\",\n+            \"balance\": 90\n+          },\n+          {\n+            \"account\": \"0.15.8\",\n+            \"balance\": 80\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+To achieve this similar to balances\n+-   Create a `tokenBalance.js`\n+-   Add a `getTokenBalances()` which based on the time range provided (default to latest timestamp) and `tokenId` pulls out `account_id` and `balance` values from `token_balance` and returns them as an element in `tokenBalances` array.\n+\n+```sql\n+    select account_id, balance from token_balance where token_id = ? and consensus_timestamp = (select max(consensus_timestamp) from token_balance);\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens/<token>/balances?id=0.0.1000`\n+-   `/api/v1/tokens/<token>/balances?balance=gt:1000`\n+-   `/api/v1/tokens/<token>/balances?timestamp=1566562500.040961001`\n+\n+### Token Discovery\n+`/api/v1/tokens` this would return all tokens present on the network\n+\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokens\": [\n+          {\n+            \"token\": \"FOOBAR\",\n+            \"tokenId\": \"0.15.10\",\n+            \"key\": {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 543}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg2MTQ1MA==", "bodyText": "protobuf Key is a complicated structure, it can be a single key of different algorithms, it can be a threshold key with a threshold then recursively includes Key, or a KeyList recursively includes a list of Keys\nin order to support such a filter, we need more clarity on how it works", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492861450", "createdAt": "2020-09-22T16:10:09Z", "author": {"login": "xin-hedera"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"token\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"token\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"token\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+To achieve this\n+-   Update `balances.js` `getBalances()` to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"token\":\"FOOBAR\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.1111\", \"amount\": -10},\n+                {\"account\": \"0.0.2222\", \"amount\": 10}\n+              ]\n+            },\n+            {\n+              \"token\":\"FOOCOIN\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.3333\", \"amount\": -10},\n+                {\"account\": \"0.0.4444\", \"amount\": 10}\n+               ]\n+            }\n+          ]\n+        }\n+      ]\n+    }\n+```\n+\n+To achieve this\n+-   Update `transactions.js` sql queries for `crypto_transfer` to pull the `token_id` and `token` columns\n+-   Update `createTransferLists()` in `transactions.js` to build a `tokenTransfers` list if `token` isn't HBAR or if `token_id` is empty\n+\n+\n+### Token Supply distribution\n+\n+`/api/v1/tokens/<token>/balances` this could be the equivalent of `/api/v1/balances?token=<token>` currently and would return a list of account and the token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokenBalances\": [\n+          {\n+            \"account\": \"0.15.10\",\n+            \"balance\": 100\n+          },\n+          {\n+            \"account\": \"0.15.9\",\n+            \"balance\": 90\n+          },\n+          {\n+            \"account\": \"0.15.8\",\n+            \"balance\": 80\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+To achieve this similar to balances\n+-   Create a `tokenBalance.js`\n+-   Add a `getTokenBalances()` which based on the time range provided (default to latest timestamp) and `tokenId` pulls out `account_id` and `balance` values from `token_balance` and returns them as an element in `tokenBalances` array.\n+\n+```sql\n+    select account_id, balance from token_balance where token_id = ? and consensus_timestamp = (select max(consensus_timestamp) from token_balance);\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens/<token>/balances?id=0.0.1000`\n+-   `/api/v1/tokens/<token>/balances?balance=gt:1000`\n+-   `/api/v1/tokens/<token>/balances?timestamp=1566562500.040961001`\n+\n+### Token Discovery\n+`/api/v1/tokens` this would return all tokens present on the network\n+\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokens\": [\n+          {\n+            \"token\": \"FOOBAR\",\n+            \"tokenId\": \"0.15.10\",\n+            \"key\": {\n+              \"_type\": \"ProtobufEncoded\",\n+              \"key\": \"7b2233222c2233222c2233227d\"\n+            }\n+          },\n+          {\n+            \"token\": \"FOOCOIN\",\n+            \"tokenId\": \"0.15.11\",\n+            \"key\": {\n+              \"_type\": \"ProtobufEncoded\",\n+              \"key\": \"9c2233222c2233222c2233227d\"\n+            }\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+To achieve this\n+-   Add a `getTokens()` to `tokenBalance.js` which pull the unique `token`, `tokenId` from the `token` table and joins with the `t_entities` table for the matching admin_key\n+\n+```sql\n+    select token, token_id from token t\n+          join t_entities e on t.token_id = e.id and e.fk_entity_type_id = ${utils.ENTITY_TYPE_TOKEN};\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens?adminkey=HJ^&8` - All tokens with matching admin key", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 572}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg2Mjc3MA==", "bodyText": "may want to support TokenRef instead of just TokenID", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492862770", "createdAt": "2020-09-22T16:12:03Z", "author": {"login": "xin-hedera"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"token\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"token\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"token\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+To achieve this\n+-   Update `balances.js` `getBalances()` to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"token\":\"FOOBAR\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.1111\", \"amount\": -10},\n+                {\"account\": \"0.0.2222\", \"amount\": 10}\n+              ]\n+            },\n+            {\n+              \"token\":\"FOOCOIN\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.3333\", \"amount\": -10},\n+                {\"account\": \"0.0.4444\", \"amount\": 10}\n+               ]\n+            }\n+          ]\n+        }\n+      ]\n+    }\n+```\n+\n+To achieve this\n+-   Update `transactions.js` sql queries for `crypto_transfer` to pull the `token_id` and `token` columns\n+-   Update `createTransferLists()` in `transactions.js` to build a `tokenTransfers` list if `token` isn't HBAR or if `token_id` is empty\n+\n+\n+### Token Supply distribution\n+\n+`/api/v1/tokens/<token>/balances` this could be the equivalent of `/api/v1/balances?token=<token>` currently and would return a list of account and the token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokenBalances\": [\n+          {\n+            \"account\": \"0.15.10\",\n+            \"balance\": 100\n+          },\n+          {\n+            \"account\": \"0.15.9\",\n+            \"balance\": 90\n+          },\n+          {\n+            \"account\": \"0.15.8\",\n+            \"balance\": 80\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+To achieve this similar to balances\n+-   Create a `tokenBalance.js`\n+-   Add a `getTokenBalances()` which based on the time range provided (default to latest timestamp) and `tokenId` pulls out `account_id` and `balance` values from `token_balance` and returns them as an element in `tokenBalances` array.\n+\n+```sql\n+    select account_id, balance from token_balance where token_id = ? and consensus_timestamp = (select max(consensus_timestamp) from token_balance);\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens/<token>/balances?id=0.0.1000`\n+-   `/api/v1/tokens/<token>/balances?balance=gt:1000`\n+-   `/api/v1/tokens/<token>/balances?timestamp=1566562500.040961001`\n+\n+### Token Discovery\n+`/api/v1/tokens` this would return all tokens present on the network\n+\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokens\": [\n+          {\n+            \"token\": \"FOOBAR\",\n+            \"tokenId\": \"0.15.10\",\n+            \"key\": {\n+              \"_type\": \"ProtobufEncoded\",\n+              \"key\": \"7b2233222c2233222c2233227d\"\n+            }\n+          },\n+          {\n+            \"token\": \"FOOCOIN\",\n+            \"tokenId\": \"0.15.11\",\n+            \"key\": {\n+              \"_type\": \"ProtobufEncoded\",\n+              \"key\": \"9c2233222c2233222c2233227d\"\n+            }\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+To achieve this\n+-   Add a `getTokens()` to `tokenBalance.js` which pull the unique `token`, `tokenId` from the `token` table and joins with the `t_entities` table for the matching admin_key\n+\n+```sql\n+    select token, token_id from token t\n+          join t_entities e on t.token_id = e.id and e.fk_entity_type_id = ${utils.ENTITY_TYPE_TOKEN};\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens?adminkey=HJ^&8` - All tokens with matching admin key\n+-   `/api/v1/tokens?account.id=0.0.8` - All tokens for matching account\n+\n+### Token Info\n+-   Add a `getTokenInfo()` to `tokens.js` to retrieve token info from `token` table\n+```json\n+    {\n+      \"token\": \"FOOCOIN\",\n+      \"tokenId\": \"0.15.10\",\n+      \"treasury_account\": \"0.15.10\",\n+      \"adminKey\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"kycKey\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"freezeKey\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"wipeKey\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"supplyKey\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"freezeDefault\": false,\n+      \"kycDefault\": false,\n+      \"expiryTimestamp\": null,\n+      \"autoRenewAccount\": \"0.0.6\",\n+      \"autoRenewPeriod\": null\n+    }\n+```\n+\n+\n+## Protobuf\n+\n+```proto\n+    message TokenQuery {\n+        .proto.TokenID tokenID = 1; // The token ID to retrieve transfers for", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 615}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNjY2MTEx", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#pullrequestreview-493666111", "createdAt": "2020-09-22T16:56:18Z", "commit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNjo1NjoxOFrOHWDt-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNjo1NzoxOFrOHWDwYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg5MTY0Mg==", "bodyText": "Start proto_id is wrong. Should start from 28 and increment\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    (56, 'TOKENCREATE'),\n          \n          \n            \n                   (28, `UNCHECKEDSUBMIT'),\n          \n          \n            \n                    (29, 'TOKENCREATE'),", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492891642", "createdAt": "2020-09-22T16:56:18Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg5MjA3Nw==", "bodyText": "Remove\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    (58, 'TOKENGETINFO'),", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492892077", "createdAt": "2020-09-22T16:57:01Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg5MjI1OA==", "bodyText": "Remove ACCOUNT from names\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    (59, 'TOKENFREEZEACCOUNT'),\n          \n          \n            \n                    (31, 'TOKENFREEZE'),", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492892258", "createdAt": "2020-09-22T16:57:18Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 112}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTgxMjc4", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#pullrequestreview-493581278", "createdAt": "2020-09-22T15:22:27Z", "commit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNToyMjoyN1rOHV_sMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNzo1MDoxOFrOHWFuQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgyNTY1MA==", "bodyText": "filter", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492825650", "createdAt": "2020-09-22T15:22:27Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"token\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"token\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"token\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+To achieve this\n+-   Update `balances.js` `getBalances()` to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"token\":\"FOOBAR\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.1111\", \"amount\": -10},\n+                {\"account\": \"0.0.2222\", \"amount\": 10}\n+              ]\n+            },\n+            {\n+              \"token\":\"FOOCOIN\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.3333\", \"amount\": -10},\n+                {\"account\": \"0.0.4444\", \"amount\": 10}\n+               ]\n+            }\n+          ]\n+        }\n+      ]\n+    }\n+```\n+\n+To achieve this\n+-   Update `transactions.js` sql queries for `crypto_transfer` to pull the `token_id` and `token` columns\n+-   Update `createTransferLists()` in `transactions.js` to build a `tokenTransfers` list if `token` isn't HBAR or if `token_id` is empty\n+\n+\n+### Token Supply distribution\n+\n+`/api/v1/tokens/<token>/balances` this could be the equivalent of `/api/v1/balances?token=<token>` currently and would return a list of account and the token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokenBalances\": [\n+          {\n+            \"account\": \"0.15.10\",\n+            \"balance\": 100\n+          },\n+          {\n+            \"account\": \"0.15.9\",\n+            \"balance\": 90\n+          },\n+          {\n+            \"account\": \"0.15.8\",\n+            \"balance\": 80\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+To achieve this similar to balances\n+-   Create a `tokenBalance.js`\n+-   Add a `getTokenBalances()` which based on the time range provided (default to latest timestamp) and `tokenId` pulls out `account_id` and `balance` values from `token_balance` and returns them as an element in `tokenBalances` array.\n+\n+```sql\n+    select account_id, balance from token_balance where token_id = ? and consensus_timestamp = (select max(consensus_timestamp) from token_balance);\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens/<token>/balances?id=0.0.1000`\n+-   `/api/v1/tokens/<token>/balances?balance=gt:1000`\n+-   `/api/v1/tokens/<token>/balances?timestamp=1566562500.040961001`\n+\n+### Token Discovery\n+`/api/v1/tokens` this would return all tokens present on the network\n+\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokens\": [\n+          {\n+            \"token\": \"FOOBAR\",\n+            \"tokenId\": \"0.15.10\",\n+            \"key\": {\n+              \"_type\": \"ProtobufEncoded\",\n+              \"key\": \"7b2233222c2233222c2233227d\"\n+            }\n+          },\n+          {\n+            \"token\": \"FOOCOIN\",\n+            \"tokenId\": \"0.15.11\",\n+            \"key\": {\n+              \"_type\": \"ProtobufEncoded\",\n+              \"key\": \"9c2233222c2233222c2233227d\"\n+            }\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+To achieve this\n+-   Add a `getTokens()` to `tokenBalance.js` which pull the unique `token`, `tokenId` from the `token` table and joins with the `t_entities` table for the matching admin_key\n+\n+```sql\n+    select token, token_id from token t\n+          join t_entities e on t.token_id = e.id and e.fk_entity_type_id = ${utils.ENTITY_TYPE_TOKEN};\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens?adminkey=HJ^&8` - All tokens with matching admin key\n+-   `/api/v1/tokens?account.id=0.0.8` - All tokens for matching account\n+\n+### Token Info\n+-   Add a `getTokenInfo()` to `tokens.js` to retrieve token info from `token` table\n+```json\n+    {\n+      \"token\": \"FOOCOIN\",\n+      \"tokenId\": \"0.15.10\",\n+      \"treasury_account\": \"0.15.10\",\n+      \"adminKey\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"kycKey\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"freezeKey\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"wipeKey\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"supplyKey\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"freezeDefault\": false,\n+      \"kycDefault\": false,\n+      \"expiryTimestamp\": null,\n+      \"autoRenewAccount\": \"0.0.6\",\n+      \"autoRenewPeriod\": null\n+    }\n+```\n+\n+\n+## Protobuf\n+\n+```proto\n+    message TokenQuery {\n+        .proto.TokenID tokenID = 1; // The token ID to retrieve transfers for\n+        .proto.AccountID accountID = 2; // An account ID to retrieve transfers for. Required if no tokenID is specified\n+        .proto.Timestamp consensusStartTime = 3; // Include messages which reached consensus on or after this time. Defaults to current time if not set.\n+        .proto.Timestamp consensusEndTime = 4; // Include messages which reached consensus before this time. If not set it will receive indefinitely.\n+        uint64 limit = 5; // The maximum number of messages to receive before stopping. If not set or set to zero it will return messages indefinitely.\n+    }\n+\n+    message TokenResponse {\n+        .proto.Timestamp consensusTimestamp = 1; // The time at which the transaction reached consensus\n+        .proto.TokenTransfers transfer = 2; // Multiple list of AccountAmount pairs, each of which has an account and an amount to transfer into it (positive) or out of it (negative)\n+    }\n+\n+    service TokenService {\n+        rpc subscribeTokenTransfers (TokenQuery) returns (stream TokenResponse);\n+    }\n+```\n+\n+## GRPC API\n+\n+### Controller\n+-   Add a `TokenController` that extends protobuf reactor stubs and implements `subscribeTokenTransfers`\n+```java\n+    package com.hedera.mirror.grpc.controller;\n+\n+    public class TokenController extends ReactorTokenServiceGrpc.TokenServiceImplBase {\n+            @Override\n+            public Flux<TokenResponse> subscribeTokenTransfers(Mono<TokenQuery> request) {\n+                ...\n+            }\n+    }\n+```\n+\n+### Domain\n+\n+-   Add `CryptoTransfer` class with class members `consensusTimestamp`, `entityId`, `amount`, `tokenId`. Also add necessary methods to support conversion from domain to protobuf TokenResponse\n+-   Add a `StreamItemFilter` base class that can be shared by `TopicMessageFilter` and `CryptoTransferFilter` with support for `startTime`, `endTime`, `limit` and `subscriberId`\n+```java\n+    package com.hedera.mirror.grpc.domain;\n+\n+    public class StreamItemFilter {\n+        private Instant endTime;\n+        private long limit;\n+        private int realmNum;\n+        private Instant startTime;\n+        private String subscriberId;\n+\n+        public boolean hasLimit() {\n+            return limit > 0;\n+        }\n+    }\n+```\n+-   Update `TopicMessageFilter` to extend `StreamItemFilter` and add `topicNum`\n+-   Add `CryptoTransferFilter` to extend `StreamItemFilter` and add `tokenNum`\n+```java\n+    package com.hedera.mirror.grpc.domain;\n+\n+    public class CryptoTransferFilter extends StreamItemFilter {\n+        @Min(0)\n+        private int tokenNum;\n+    }\n+```\n+\n+\n+-   Update `EntityType` with `TOKEN` option\n+```java\n+    package com.hedera.mirror.grpc.domain;\n+\n+    public enum EntityType {\n+\n+        UNKNOWN, // Filler value to offset next values by one to match database values\n+        ACCOUNT,\n+        CONTRACT,\n+        FILE,\n+        TOPIC,\n+        TOKEN\n+    }\n+```\n+\n+### Repository\n+-   Add a `StreamItemRepository`\n+```java\n+    package com.hedera.mirror.grpc.repository;\n+\n+    public interface StreamItemRepository extends CrudRepository<StreamItem, Long> {\n+        List<StreamItem> findLatest(long consensusTimestamp, Pageable pageable);\n+        List<StreamItem> findByFilter(StreamItemFilter filter);\n+    }\n+```\n+-   Add `CryptoTransferRepository` which implements `StreamItemRepository`\n+-   Update `TopicMessageRepository` to implement `StreamItemRepository`\n+\n+### Streaming : Listener & Retriever\n+The GRPC module currently supports listen and retrieval logic for incoming and historic topic messages respectively.\n+A lot of this logic can be shared for the equivalent `CryptoTransfer` listeners and retriever\n+\n+-   Add a `StreamItem` interface that stream-able domain objects can implement with get methods for `realm`, `entityNum` and `consensusTimestamp`\n+```java\n+    package com.hedera.mirror.grpc.domain;\n+\n+    public interface StreamItem {\n+        int getRealmNum();\n+        int getEntityNum();\n+        Long getConsensusTimestamp();\n+    }\n+```\n+\n+-   Update `TopicListener` to be `SharedListener`. Replace `TopicMessage` and `TopicMessageFilter` with generic type for StreamItem\n+```java\n+    package com.hedera.mirror.grpc.listener;\n+\n+    public interface SharedListener<T extends StreamItem> {\n+        Flux<T> listen(S filter);\n+    }\n+```\n+-   Update `CompositeTopicListener` to set generic types `T` and `S` as `TopicMessage` and `TopicMessageFilter` when creating `SharedListener` implementations.\n+-   Create `CompositeCryptoListener` similar to `CompositeTopicListener` that sets generic types of `T` and `S` as `CryptoTransfer` and `CryptoTransferFilter` when creating `Listener` implementations.\n+-   Update `NotifyTopicListener` to be `NotifyListener` and use generics `T` and `S` in place of `TopicMessage` and `TopicMessageFilter`\n+```java\n+    package com.hedera.mirror.grpc.listener;\n+\n+    public class NotifyingListener<T extends StreamItem, S extends StreamItemFilter> implements SharedListener<T, S> {\n+        ...\n+    }\n+```\n+-   Extract `PollingContext` from `SharedPollingTopicListener` and use `StreamItem` and `StreamItemFilter` in place of `TopicMessage` and `TopicMessageFilter`\n+```java\n+    package com.hedera.mirror.grpc.listener;\n+\n+    private class PollingContext {\n+        private final StreamItemFilter filter;\n+        private volatile StreamItem last;\n+        ...\n+    }\n+```\n+-   Update `PollingTopicListener` to `PollingListener` and use `StreamItem` and `StreamItemFilter` in place of `TopicMessage` and `TopicMessageFilter`. Also swap/add `streamItemRepository` private member.\n+```java\n+    package com.hedera.mirror.grpc.listener;\n+\n+    public class PollingListener implements SharedListener {\n+        ...\n+        private final StreamItemRepository streamItemRepository;\n+        ...\n+    }\n+```\n+-   Update `SharedPollingTopicListener` to `SharedPollingListener` and use `StreamItem` and `StreamItemFilter` in place of `TopicMessage` and `TopicMessageFilter`\n+```java\n+    package com.hedera.mirror.grpc.listener;\n+\n+    public class SharedPollingListener implements SharedListener {\n+        ...\n+        private final StreamItemRepository streamItemRepository;\n+        ...\n+    }\n+```\n+-   Update `TopicMessageRetriever` to be `Retriever` and use `StreamItem` and `StreamItemFilter` in place of `TopicMessage` and `TopicMessageFilter`\n+```java\n+    package com.hedera.mirror.grpc.retriever;\n+\n+    public interface Retriever {\n+        Flux<StreamItem> retrieve(StreamItemFilter filter);\n+    }\n+```\n+-   Update `PollingTopicMessageRetriever` to be `PollingRetriever` and use `StreamItem`, `StreamItemFilter` and `StreamItemRepository` in place of `TopicMessage`, `TopicMessageFilter` and `TopicMessageRepository`.\n+\n+### Service\n+> _Note:_ ***Sequence diagram to be added\n+\n+-   Add `CryptoTransferService` interface\n+```java\n+    package com.hedera.mirror.grpc.service;\n+\n+    public interface TokenService {\n+        Flux<StreamItem> subscribeTokenTransfers(@Valid StreamItemFilter filter);\n+    }\n+```\n+\n+-   Add `AbstractServiceImpl` that pulls out the common logic from `TopicMessageServiceImpl` `entityExists()`, `incomingMessages()` and `missingMessages()` and uses `StreamItem`, `StreamItemFilter` and `Retriever` in place of `TopicMessage`, `TopicMessageFilter` and `TopicRetriever`.\n+-   Update `TopicMessageServiceImpl` to extend `AbstractServiceImpl` and still implement `TopicMessageService`\n+-   Add `TokenServiceImpl` to extend `AbstractServiceImpl` and implement `TokenService`\n+```java\n+    package com.hedera.mirror.grpc.service;\n+\n+    public class TokenServiceImpl extends AbstractServiceImpl implements TokenService {\n+        ...\n+        private final Retriever retriever;\n+        Flux<StreamItem> subscribeTokenTransfers(@Valid StreamItemFilter filter){\n+            ...\n+        }\n+\n+        ...\n+    }\n+```\n+\n+## Non-Functional Requirements\n+\n+## Open Questions\n+-   [x] What's the maximum character size of the token `symbol` string\n+    -   A: Max length is currently 32 chars https://github.com/hashgraph/hedera-services/blob/master/hedera-node/src/main/resources/bootstrap.properties#L52\n+-   [x] Will a `token_id` and `token` be assigned a default value for HBARs across the network e.g. i.e. '1' and 'HBAR' respectively\n+    -   A: Currently no since hbar is not treated as an entity like tokens will be.\n+-   [ ] Should token only entity items exist in their own table or be added to `t_entities`?\n+-   [x] Should `account_balance` `accountNum` and `accountRealmNum` be migrated into `entityId` or should token_balance also use `accountNum` and `accountRealmNum` instead of `entityId`?\n+    -   A: Should be migrated to use `account_id` only\n+-   [ ] What filer options should be provided for new Token API's", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 818}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgzNDYwNw==", "bodyText": "There's no need to read two lines. Just read the first and if version:2 send to v2. Else if contains words TimeStamp send to v1. Else throw an unsupported exception. Everything after the first line is specific to that version and we should encapsulate that inside its versioned reader.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492834607", "createdAt": "2020-09-22T15:33:35Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 299}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg0Mzg0Ng==", "bodyText": "This sort of granularity is too specific to the implementation. Design documents should focus on higher level architecture and leave the specifics to the implementers. It should mention domain classes, new classes and changed interfaces, but it doesn't need to mention every class that needs updating and what to update within them. Just FYI for future.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492843846", "createdAt": "2020-09-22T15:45:45Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 303}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg0NjQ5Nw==", "bodyText": "Again, too specific. The first line Modify EntityRecordItemListener to handle parsing HTS transactions was enough.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492846497", "createdAt": "2020-09-22T15:49:17Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 334}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg0NjgyNw==", "bodyText": "Unnecessary implementation details", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492846827", "createdAt": "2020-09-22T15:49:46Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"token\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"token\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 388}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg0ODMxMw==", "bodyText": "We agreed that the order should be transactions, balances, accounts, etc", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492848313", "createdAt": "2020-09-22T15:51:48Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 348}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg1MDAxOA==", "bodyText": "Prefer tokens as mentioned in #1047. Unnecessary to mention balances again since we're within the balances object.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492850018", "createdAt": "2020-09-22T15:54:09Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"token\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"token\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 401}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg1MTI5Mg==", "bodyText": "This would be way more succinct as mentioned in #1047\n            \"tokens\": {\n              \"foobars\": 1000,\n              \"foocoins\": 50\n            }", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492851292", "createdAt": "2020-09-22T15:55:51Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"token\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"token\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 408}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg1NzE0OQ==", "bodyText": "Should we have this as the format mentioned in #1047? Even though it duplicates the token per transfer it is simpler and matches the structure in the TransactionRecord and in the database:\n            \"token_transfers\": [\n                {\n                    \"account\": \"0.0.1000\",\n                    \"amount\": 297,\n                    \"token\": \"foobars\"\n                }\n            ]", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492857149", "createdAt": "2020-09-22T16:03:51Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"token\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"token\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"token\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+To achieve this\n+-   Update `balances.js` `getBalances()` to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"token\":\"FOOBAR\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 470}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg2MjIyMg==", "bodyText": "snake_case is used for all fields in REST API response. Please adjust everywhere.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492862222", "createdAt": "2020-09-22T16:11:10Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"token\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"token\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"token\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+To achieve this\n+-   Update `balances.js` `getBalances()` to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"token\":\"FOOBAR\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.1111\", \"amount\": -10},\n+                {\"account\": \"0.0.2222\", \"amount\": 10}\n+              ]\n+            },\n+            {\n+              \"token\":\"FOOCOIN\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.3333\", \"amount\": -10},\n+                {\"account\": \"0.0.4444\", \"amount\": 10}\n+               ]\n+            }\n+          ]\n+        }\n+      ]\n+    }\n+```\n+\n+To achieve this\n+-   Update `transactions.js` sql queries for `crypto_transfer` to pull the `token_id` and `token` columns\n+-   Update `createTransferLists()` in `transactions.js` to build a `tokenTransfers` list if `token` isn't HBAR or if `token_id` is empty\n+\n+\n+### Token Supply distribution\n+\n+`/api/v1/tokens/<token>/balances` this could be the equivalent of `/api/v1/balances?token=<token>` currently and would return a list of account and the token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokenBalances\": [\n+          {\n+            \"account\": \"0.15.10\",\n+            \"balance\": 100\n+          },\n+          {\n+            \"account\": \"0.15.9\",\n+            \"balance\": 90\n+          },\n+          {\n+            \"account\": \"0.15.8\",\n+            \"balance\": 80\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+To achieve this similar to balances\n+-   Create a `tokenBalance.js`\n+-   Add a `getTokenBalances()` which based on the time range provided (default to latest timestamp) and `tokenId` pulls out `account_id` and `balance` values from `token_balance` and returns them as an element in `tokenBalances` array.\n+\n+```sql\n+    select account_id, balance from token_balance where token_id = ? and consensus_timestamp = (select max(consensus_timestamp) from token_balance);\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens/<token>/balances?id=0.0.1000`\n+-   `/api/v1/tokens/<token>/balances?balance=gt:1000`\n+-   `/api/v1/tokens/<token>/balances?timestamp=1566562500.040961001`\n+\n+### Token Discovery\n+`/api/v1/tokens` this would return all tokens present on the network\n+\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokens\": [\n+          {\n+            \"token\": \"FOOBAR\",\n+            \"tokenId\": \"0.15.10\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 542}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg2MzMwOA==", "bodyText": "Why are we returning the key here instead of the detailed list? The other keys are returned in the detailed response.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492863308", "createdAt": "2020-09-22T16:12:50Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"token\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"token\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"tokenBalances\": [\n+              {\n+                \"token\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"token\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+To achieve this\n+-   Update `balances.js` `getBalances()` to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"token\":\"FOOBAR\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.1111\", \"amount\": -10},\n+                {\"account\": \"0.0.2222\", \"amount\": 10}\n+              ]\n+            },\n+            {\n+              \"token\":\"FOOCOIN\",\n+              \"transfers\": [\n+                {\"account\": \"0.0.3333\", \"amount\": -10},\n+                {\"account\": \"0.0.4444\", \"amount\": 10}\n+               ]\n+            }\n+          ]\n+        }\n+      ]\n+    }\n+```\n+\n+To achieve this\n+-   Update `transactions.js` sql queries for `crypto_transfer` to pull the `token_id` and `token` columns\n+-   Update `createTransferLists()` in `transactions.js` to build a `tokenTransfers` list if `token` isn't HBAR or if `token_id` is empty\n+\n+\n+### Token Supply distribution\n+\n+`/api/v1/tokens/<token>/balances` this could be the equivalent of `/api/v1/balances?token=<token>` currently and would return a list of account and the token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokenBalances\": [\n+          {\n+            \"account\": \"0.15.10\",\n+            \"balance\": 100\n+          },\n+          {\n+            \"account\": \"0.15.9\",\n+            \"balance\": 90\n+          },\n+          {\n+            \"account\": \"0.15.8\",\n+            \"balance\": 80\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+To achieve this similar to balances\n+-   Create a `tokenBalance.js`\n+-   Add a `getTokenBalances()` which based on the time range provided (default to latest timestamp) and `tokenId` pulls out `account_id` and `balance` values from `token_balance` and returns them as an element in `tokenBalances` array.\n+\n+```sql\n+    select account_id, balance from token_balance where token_id = ? and consensus_timestamp = (select max(consensus_timestamp) from token_balance);\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens/<token>/balances?id=0.0.1000`\n+-   `/api/v1/tokens/<token>/balances?balance=gt:1000`\n+-   `/api/v1/tokens/<token>/balances?timestamp=1566562500.040961001`\n+\n+### Token Discovery\n+`/api/v1/tokens` this would return all tokens present on the network\n+\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"tokens\": [\n+          {\n+            \"token\": \"FOOBAR\",\n+            \"tokenId\": \"0.15.10\",\n+            \"key\": {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 543}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjkyNDQ4Mw==", "bodyText": "tokens", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r492924483", "createdAt": "2020-09-22T17:50:18Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 364}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9923fa7925b20d0d7598c4118e252da799711b5b", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/9923fa7925b20d0d7598c4118e252da799711b5b", "committedDate": "2020-09-22T23:38:43Z", "message": "Expanded out EntityRecordItemListener and removed some grpc details\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "583fd0cfb8ffad89e4761f80af65379580297010", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/583fd0cfb8ffad89e4761f80af65379580297010", "committedDate": "2020-09-22T23:47:02Z", "message": "Fix accidental file removal and addition\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "88e15eda90f8c27951e2da43a6696e099d1883c1", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/88e15eda90f8c27951e2da43a6696e099d1883c1", "committedDate": "2020-09-23T05:10:58Z", "message": "Cleaned up and addressed some feedback\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/120032b165d4c9b8cb29bd1546ec791ff4d728e9", "committedDate": "2020-09-23T22:31:05Z", "message": "Cleaned up a bit\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1ODQ2MjE2", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#pullrequestreview-495846216", "createdAt": "2020-09-24T18:28:43Z", "commit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "state": "COMMENTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxODoyODo0M1rOHXndjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxODo1MjoxMVrOHXoZBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUyNTgzNg==", "bodyText": "Was changed to\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                -   `create_timestamp`\n          \n          \n            \n                -   `created_timestamp`", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494525836", "createdAt": "2020-09-24T18:28:43Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,631 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members\n+    -   `account_id`\n+    -   `amount`\n+    -   `consensus_timestamp`\n+    -   `token_id`\n+-   Add a `token_transfer__token_account_timestamp` index with `desc` order on columns\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances with the following columns\n+    -   `consensus_timestamp`\n+    -   `account_id`\n+    -   `balance`\n+    -   `token_id`\n+-   Create primary key as combination of `consensus_timestamp`, `token_id` and `account_id`\n+\n+### Token Account Info\n+-   Create `token_account` table to distinctly capture token account metadata changes with the following columns\n+    -   `id` (primary key)\n+    -   `account_id`\n+    -   `create_timestamp`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUyNjEzMA==", "bodyText": "Was changed to\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                -   `modify_timestamp`\n          \n          \n            \n                -   `modified_timestamp`", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494526130", "createdAt": "2020-09-24T18:29:00Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,631 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members\n+    -   `account_id`\n+    -   `amount`\n+    -   `consensus_timestamp`\n+    -   `token_id`\n+-   Add a `token_transfer__token_account_timestamp` index with `desc` order on columns\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances with the following columns\n+    -   `consensus_timestamp`\n+    -   `account_id`\n+    -   `balance`\n+    -   `token_id`\n+-   Create primary key as combination of `consensus_timestamp`, `token_id` and `account_id`\n+\n+### Token Account Info\n+-   Create `token_account` table to distinctly capture token account metadata changes with the following columns\n+    -   `id` (primary key)\n+    -   `account_id`\n+    -   `create_timestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modify_timestamp`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUyNjg5OQ==", "bodyText": "Was changed to\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                -   `create_timestamp`\n          \n          \n            \n                -   `created_timestamp`", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494526899", "createdAt": "2020-09-24T18:29:51Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,631 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members\n+    -   `account_id`\n+    -   `amount`\n+    -   `consensus_timestamp`\n+    -   `token_id`\n+-   Add a `token_transfer__token_account_timestamp` index with `desc` order on columns\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances with the following columns\n+    -   `consensus_timestamp`\n+    -   `account_id`\n+    -   `balance`\n+    -   `token_id`\n+-   Create primary key as combination of `consensus_timestamp`, `token_id` and `account_id`\n+\n+### Token Account Info\n+-   Create `token_account` table to distinctly capture token account metadata changes with the following columns\n+    -   `id` (primary key)\n+    -   `account_id`\n+    -   `create_timestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modify_timestamp`\n+    -   `token_id`\n+    -   `wiped`\n+-   Create unique index `token_account__token_account`\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with `id` value of 5 and `name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+         (28, 'UNCHECKEDSUBMIT'),\n+         (29, 'TOKENCREATE'),\n+         (30, 'TOKENTRANSFER'),\n+         (31, 'TOKENFREEZE'),\n+         (32, 'TOKENUNFREEZE'),\n+         (33, 'TOKENGRANTKYC'),\n+         (34, 'TOKENREVOKEKYC'),\n+         (35, 'TOKENDELETE'),\n+         (36, 'TOKENUPDATE'),\n+         (37, 'TOKENMINT'),\n+         (38, 'TOKENBURN'),\n+         (39, 'TOKENWIPE'),\n+         (40, 'TOKENASSOCIATE'),\n+         (41, 'TOKENDISSOCIATE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP'),\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT'),\n+        (188, 'INVALID_KYC_KEY'),\n+        (189, 'INVALID_WIPE_KEY'),\n+        (190, 'INVALID_FREEZE_KEY'),\n+        (191, 'INVALID_SUPPLY_KEY'),\n+        (192, 'TOKEN_NAME_ALREADY_IN_USE'),\n+        (193, 'MISSING_TOKEN_NAME'),\n+        (194, 'TOKEN_NAME_TOO_LONG'),\n+        (195, 'INVALID_WIPING_AMOUNT'),\n+        (196, 'TOKEN_IS_IMMUTABlE'),\n+        (197, 'TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table with the following columns. Table will capture non shared `entity` items, most API calls may not require this information and therefore additional sql joins may be avoided.\n+    -   `token_id` (primary key)\n+    -   `create_timestamp`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUyNzI1Mg==", "bodyText": "Was changed to\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                -   `modify_timestamp`\n          \n          \n            \n                -   `modified_timestamp`", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494527252", "createdAt": "2020-09-24T18:30:14Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,631 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members\n+    -   `account_id`\n+    -   `amount`\n+    -   `consensus_timestamp`\n+    -   `token_id`\n+-   Add a `token_transfer__token_account_timestamp` index with `desc` order on columns\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances with the following columns\n+    -   `consensus_timestamp`\n+    -   `account_id`\n+    -   `balance`\n+    -   `token_id`\n+-   Create primary key as combination of `consensus_timestamp`, `token_id` and `account_id`\n+\n+### Token Account Info\n+-   Create `token_account` table to distinctly capture token account metadata changes with the following columns\n+    -   `id` (primary key)\n+    -   `account_id`\n+    -   `create_timestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modify_timestamp`\n+    -   `token_id`\n+    -   `wiped`\n+-   Create unique index `token_account__token_account`\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with `id` value of 5 and `name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+         (28, 'UNCHECKEDSUBMIT'),\n+         (29, 'TOKENCREATE'),\n+         (30, 'TOKENTRANSFER'),\n+         (31, 'TOKENFREEZE'),\n+         (32, 'TOKENUNFREEZE'),\n+         (33, 'TOKENGRANTKYC'),\n+         (34, 'TOKENREVOKEKYC'),\n+         (35, 'TOKENDELETE'),\n+         (36, 'TOKENUPDATE'),\n+         (37, 'TOKENMINT'),\n+         (38, 'TOKENBURN'),\n+         (39, 'TOKENWIPE'),\n+         (40, 'TOKENASSOCIATE'),\n+         (41, 'TOKENDISSOCIATE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP'),\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT'),\n+        (188, 'INVALID_KYC_KEY'),\n+        (189, 'INVALID_WIPE_KEY'),\n+        (190, 'INVALID_FREEZE_KEY'),\n+        (191, 'INVALID_SUPPLY_KEY'),\n+        (192, 'TOKEN_NAME_ALREADY_IN_USE'),\n+        (193, 'MISSING_TOKEN_NAME'),\n+        (194, 'TOKEN_NAME_TOO_LONG'),\n+        (195, 'INVALID_WIPING_AMOUNT'),\n+        (196, 'TOKEN_IS_IMMUTABlE'),\n+        (197, 'TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table with the following columns. Table will capture non shared `entity` items, most API calls may not require this information and therefore additional sql joins may be avoided.\n+    -   `token_id` (primary key)\n+    -   `create_timestamp`\n+    -   `divisibility`\n+    -   `freeze_default`\n+    -   `freeze_key`\n+    -   `initial_supply`\n+    -   `kyc_default`\n+    -   `kyc_key`\n+    -   `modify_timestamp`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUyNzc2NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                -   `modifyTimestamp`\n          \n          \n            \n                -   `modifiedTimestamp`", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494527764", "createdAt": "2020-09-24T18:30:42Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,631 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members\n+    -   `account_id`\n+    -   `amount`\n+    -   `consensus_timestamp`\n+    -   `token_id`\n+-   Add a `token_transfer__token_account_timestamp` index with `desc` order on columns\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances with the following columns\n+    -   `consensus_timestamp`\n+    -   `account_id`\n+    -   `balance`\n+    -   `token_id`\n+-   Create primary key as combination of `consensus_timestamp`, `token_id` and `account_id`\n+\n+### Token Account Info\n+-   Create `token_account` table to distinctly capture token account metadata changes with the following columns\n+    -   `id` (primary key)\n+    -   `account_id`\n+    -   `create_timestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modify_timestamp`\n+    -   `token_id`\n+    -   `wiped`\n+-   Create unique index `token_account__token_account`\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with `id` value of 5 and `name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+         (28, 'UNCHECKEDSUBMIT'),\n+         (29, 'TOKENCREATE'),\n+         (30, 'TOKENTRANSFER'),\n+         (31, 'TOKENFREEZE'),\n+         (32, 'TOKENUNFREEZE'),\n+         (33, 'TOKENGRANTKYC'),\n+         (34, 'TOKENREVOKEKYC'),\n+         (35, 'TOKENDELETE'),\n+         (36, 'TOKENUPDATE'),\n+         (37, 'TOKENMINT'),\n+         (38, 'TOKENBURN'),\n+         (39, 'TOKENWIPE'),\n+         (40, 'TOKENASSOCIATE'),\n+         (41, 'TOKENDISSOCIATE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP'),\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT'),\n+        (188, 'INVALID_KYC_KEY'),\n+        (189, 'INVALID_WIPE_KEY'),\n+        (190, 'INVALID_FREEZE_KEY'),\n+        (191, 'INVALID_SUPPLY_KEY'),\n+        (192, 'TOKEN_NAME_ALREADY_IN_USE'),\n+        (193, 'MISSING_TOKEN_NAME'),\n+        (194, 'TOKEN_NAME_TOO_LONG'),\n+        (195, 'INVALID_WIPING_AMOUNT'),\n+        (196, 'TOKEN_IS_IMMUTABlE'),\n+        (197, 'TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table with the following columns. Table will capture non shared `entity` items, most API calls may not require this information and therefore additional sql joins may be avoided.\n+    -   `token_id` (primary key)\n+    -   `create_timestamp`\n+    -   `divisibility`\n+    -   `freeze_default`\n+    -   `freeze_key`\n+    -   `initial_supply`\n+    -   `kyc_default`\n+    -   `kyc_key`\n+    -   `modify_timestamp`\n+    -   `supply_key`\n+    -   `symbol`\n+    -   `treasury_account_id`\n+    -   `wipe_key`\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+#### AccountBalance\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+#### TokenTransfer\n+-   Create new `TokenTransfer` with the following class members\n+    -   `accountId`\n+    -   `amount`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+#### EntityTypeEnum\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+        ...\n+        TOKEN(5);\n+        ...\n+    }\n+```\n+\n+#### Token\n+-   Add `Token` class to hold Token specific metadata outside of the base entity class with the following class members\n+    -   `createTimestamp`\n+    -   `divisibility`\n+    -   `freezeDefault`\n+    -   `freezeKey`\n+    -   `initialSupply`\n+    -   `kycDefault`\n+    -   `kycKey`\n+    -   `modifyTimestamp`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "originalPosition": 219}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUyNzk0Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                -   `createTimestamp`\n          \n          \n            \n                -   `createdTimestamp`", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494527946", "createdAt": "2020-09-24T18:30:52Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,631 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members\n+    -   `account_id`\n+    -   `amount`\n+    -   `consensus_timestamp`\n+    -   `token_id`\n+-   Add a `token_transfer__token_account_timestamp` index with `desc` order on columns\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances with the following columns\n+    -   `consensus_timestamp`\n+    -   `account_id`\n+    -   `balance`\n+    -   `token_id`\n+-   Create primary key as combination of `consensus_timestamp`, `token_id` and `account_id`\n+\n+### Token Account Info\n+-   Create `token_account` table to distinctly capture token account metadata changes with the following columns\n+    -   `id` (primary key)\n+    -   `account_id`\n+    -   `create_timestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modify_timestamp`\n+    -   `token_id`\n+    -   `wiped`\n+-   Create unique index `token_account__token_account`\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with `id` value of 5 and `name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+         (28, 'UNCHECKEDSUBMIT'),\n+         (29, 'TOKENCREATE'),\n+         (30, 'TOKENTRANSFER'),\n+         (31, 'TOKENFREEZE'),\n+         (32, 'TOKENUNFREEZE'),\n+         (33, 'TOKENGRANTKYC'),\n+         (34, 'TOKENREVOKEKYC'),\n+         (35, 'TOKENDELETE'),\n+         (36, 'TOKENUPDATE'),\n+         (37, 'TOKENMINT'),\n+         (38, 'TOKENBURN'),\n+         (39, 'TOKENWIPE'),\n+         (40, 'TOKENASSOCIATE'),\n+         (41, 'TOKENDISSOCIATE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP'),\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT'),\n+        (188, 'INVALID_KYC_KEY'),\n+        (189, 'INVALID_WIPE_KEY'),\n+        (190, 'INVALID_FREEZE_KEY'),\n+        (191, 'INVALID_SUPPLY_KEY'),\n+        (192, 'TOKEN_NAME_ALREADY_IN_USE'),\n+        (193, 'MISSING_TOKEN_NAME'),\n+        (194, 'TOKEN_NAME_TOO_LONG'),\n+        (195, 'INVALID_WIPING_AMOUNT'),\n+        (196, 'TOKEN_IS_IMMUTABlE'),\n+        (197, 'TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table with the following columns. Table will capture non shared `entity` items, most API calls may not require this information and therefore additional sql joins may be avoided.\n+    -   `token_id` (primary key)\n+    -   `create_timestamp`\n+    -   `divisibility`\n+    -   `freeze_default`\n+    -   `freeze_key`\n+    -   `initial_supply`\n+    -   `kyc_default`\n+    -   `kyc_key`\n+    -   `modify_timestamp`\n+    -   `supply_key`\n+    -   `symbol`\n+    -   `treasury_account_id`\n+    -   `wipe_key`\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+#### AccountBalance\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+#### TokenTransfer\n+-   Create new `TokenTransfer` with the following class members\n+    -   `accountId`\n+    -   `amount`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+#### EntityTypeEnum\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+        ...\n+        TOKEN(5);\n+        ...\n+    }\n+```\n+\n+#### Token\n+-   Add `Token` class to hold Token specific metadata outside of the base entity class with the following class members\n+    -   `createTimestamp`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUyODA4Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                -   `createTimestamp`\n          \n          \n            \n                -   `createdTimestamp`", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494528083", "createdAt": "2020-09-24T18:30:59Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,631 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members\n+    -   `account_id`\n+    -   `amount`\n+    -   `consensus_timestamp`\n+    -   `token_id`\n+-   Add a `token_transfer__token_account_timestamp` index with `desc` order on columns\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances with the following columns\n+    -   `consensus_timestamp`\n+    -   `account_id`\n+    -   `balance`\n+    -   `token_id`\n+-   Create primary key as combination of `consensus_timestamp`, `token_id` and `account_id`\n+\n+### Token Account Info\n+-   Create `token_account` table to distinctly capture token account metadata changes with the following columns\n+    -   `id` (primary key)\n+    -   `account_id`\n+    -   `create_timestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modify_timestamp`\n+    -   `token_id`\n+    -   `wiped`\n+-   Create unique index `token_account__token_account`\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with `id` value of 5 and `name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+         (28, 'UNCHECKEDSUBMIT'),\n+         (29, 'TOKENCREATE'),\n+         (30, 'TOKENTRANSFER'),\n+         (31, 'TOKENFREEZE'),\n+         (32, 'TOKENUNFREEZE'),\n+         (33, 'TOKENGRANTKYC'),\n+         (34, 'TOKENREVOKEKYC'),\n+         (35, 'TOKENDELETE'),\n+         (36, 'TOKENUPDATE'),\n+         (37, 'TOKENMINT'),\n+         (38, 'TOKENBURN'),\n+         (39, 'TOKENWIPE'),\n+         (40, 'TOKENASSOCIATE'),\n+         (41, 'TOKENDISSOCIATE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP'),\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT'),\n+        (188, 'INVALID_KYC_KEY'),\n+        (189, 'INVALID_WIPE_KEY'),\n+        (190, 'INVALID_FREEZE_KEY'),\n+        (191, 'INVALID_SUPPLY_KEY'),\n+        (192, 'TOKEN_NAME_ALREADY_IN_USE'),\n+        (193, 'MISSING_TOKEN_NAME'),\n+        (194, 'TOKEN_NAME_TOO_LONG'),\n+        (195, 'INVALID_WIPING_AMOUNT'),\n+        (196, 'TOKEN_IS_IMMUTABlE'),\n+        (197, 'TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table with the following columns. Table will capture non shared `entity` items, most API calls may not require this information and therefore additional sql joins may be avoided.\n+    -   `token_id` (primary key)\n+    -   `create_timestamp`\n+    -   `divisibility`\n+    -   `freeze_default`\n+    -   `freeze_key`\n+    -   `initial_supply`\n+    -   `kyc_default`\n+    -   `kyc_key`\n+    -   `modify_timestamp`\n+    -   `supply_key`\n+    -   `symbol`\n+    -   `treasury_account_id`\n+    -   `wipe_key`\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+#### AccountBalance\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+#### TokenTransfer\n+-   Create new `TokenTransfer` with the following class members\n+    -   `accountId`\n+    -   `amount`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+#### EntityTypeEnum\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+        ...\n+        TOKEN(5);\n+        ...\n+    }\n+```\n+\n+#### Token\n+-   Add `Token` class to hold Token specific metadata outside of the base entity class with the following class members\n+    -   `createTimestamp`\n+    -   `divisibility`\n+    -   `freezeDefault`\n+    -   `freezeKey`\n+    -   `initialSupply`\n+    -   `kycDefault`\n+    -   `kycKey`\n+    -   `modifyTimestamp`\n+    -   `supplyKey`\n+    -   `symbol`\n+    -   `tokenId`\n+    -   `treasuryAccountId`\n+    -   `wipeKey`\n+\n+#### TokenAccount\n+-   Add `TokenAccount` class with the following class members\n+    -   `id`\n+    -   `accountId`\n+    -   `createTimestamp`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "originalPosition": 230}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUyODI0NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                -   `modifyTimestamp`\n          \n          \n            \n                -   `modifiedTimestamp`", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494528244", "createdAt": "2020-09-24T18:31:08Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,631 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members\n+    -   `account_id`\n+    -   `amount`\n+    -   `consensus_timestamp`\n+    -   `token_id`\n+-   Add a `token_transfer__token_account_timestamp` index with `desc` order on columns\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances with the following columns\n+    -   `consensus_timestamp`\n+    -   `account_id`\n+    -   `balance`\n+    -   `token_id`\n+-   Create primary key as combination of `consensus_timestamp`, `token_id` and `account_id`\n+\n+### Token Account Info\n+-   Create `token_account` table to distinctly capture token account metadata changes with the following columns\n+    -   `id` (primary key)\n+    -   `account_id`\n+    -   `create_timestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modify_timestamp`\n+    -   `token_id`\n+    -   `wiped`\n+-   Create unique index `token_account__token_account`\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with `id` value of 5 and `name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+         (28, 'UNCHECKEDSUBMIT'),\n+         (29, 'TOKENCREATE'),\n+         (30, 'TOKENTRANSFER'),\n+         (31, 'TOKENFREEZE'),\n+         (32, 'TOKENUNFREEZE'),\n+         (33, 'TOKENGRANTKYC'),\n+         (34, 'TOKENREVOKEKYC'),\n+         (35, 'TOKENDELETE'),\n+         (36, 'TOKENUPDATE'),\n+         (37, 'TOKENMINT'),\n+         (38, 'TOKENBURN'),\n+         (39, 'TOKENWIPE'),\n+         (40, 'TOKENASSOCIATE'),\n+         (41, 'TOKENDISSOCIATE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP'),\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT'),\n+        (188, 'INVALID_KYC_KEY'),\n+        (189, 'INVALID_WIPE_KEY'),\n+        (190, 'INVALID_FREEZE_KEY'),\n+        (191, 'INVALID_SUPPLY_KEY'),\n+        (192, 'TOKEN_NAME_ALREADY_IN_USE'),\n+        (193, 'MISSING_TOKEN_NAME'),\n+        (194, 'TOKEN_NAME_TOO_LONG'),\n+        (195, 'INVALID_WIPING_AMOUNT'),\n+        (196, 'TOKEN_IS_IMMUTABlE'),\n+        (197, 'TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table with the following columns. Table will capture non shared `entity` items, most API calls may not require this information and therefore additional sql joins may be avoided.\n+    -   `token_id` (primary key)\n+    -   `create_timestamp`\n+    -   `divisibility`\n+    -   `freeze_default`\n+    -   `freeze_key`\n+    -   `initial_supply`\n+    -   `kyc_default`\n+    -   `kyc_key`\n+    -   `modify_timestamp`\n+    -   `supply_key`\n+    -   `symbol`\n+    -   `treasury_account_id`\n+    -   `wipe_key`\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+#### AccountBalance\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+#### TokenTransfer\n+-   Create new `TokenTransfer` with the following class members\n+    -   `accountId`\n+    -   `amount`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+#### EntityTypeEnum\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+        ...\n+        TOKEN(5);\n+        ...\n+    }\n+```\n+\n+#### Token\n+-   Add `Token` class to hold Token specific metadata outside of the base entity class with the following class members\n+    -   `createTimestamp`\n+    -   `divisibility`\n+    -   `freezeDefault`\n+    -   `freezeKey`\n+    -   `initialSupply`\n+    -   `kycDefault`\n+    -   `kycKey`\n+    -   `modifyTimestamp`\n+    -   `supplyKey`\n+    -   `symbol`\n+    -   `tokenId`\n+    -   `treasuryAccountId`\n+    -   `wipeKey`\n+\n+#### TokenAccount\n+-   Add `TokenAccount` class with the following class members\n+    -   `id`\n+    -   `accountId`\n+    -   `createTimestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modifyTimestamp`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUyODUxOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            2. Comments out the Timestamp e.g. `TimeStamp:2020-09-22T04:25:00.083212003Z`\n          \n          \n            \n            2. Comments out the Timestamp e.g. `# TimeStamp:2020-09-22T04:25:00.083212003Z`", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494528518", "createdAt": "2020-09-24T18:31:25Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,631 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members\n+    -   `account_id`\n+    -   `amount`\n+    -   `consensus_timestamp`\n+    -   `token_id`\n+-   Add a `token_transfer__token_account_timestamp` index with `desc` order on columns\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances with the following columns\n+    -   `consensus_timestamp`\n+    -   `account_id`\n+    -   `balance`\n+    -   `token_id`\n+-   Create primary key as combination of `consensus_timestamp`, `token_id` and `account_id`\n+\n+### Token Account Info\n+-   Create `token_account` table to distinctly capture token account metadata changes with the following columns\n+    -   `id` (primary key)\n+    -   `account_id`\n+    -   `create_timestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modify_timestamp`\n+    -   `token_id`\n+    -   `wiped`\n+-   Create unique index `token_account__token_account`\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with `id` value of 5 and `name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+         (28, 'UNCHECKEDSUBMIT'),\n+         (29, 'TOKENCREATE'),\n+         (30, 'TOKENTRANSFER'),\n+         (31, 'TOKENFREEZE'),\n+         (32, 'TOKENUNFREEZE'),\n+         (33, 'TOKENGRANTKYC'),\n+         (34, 'TOKENREVOKEKYC'),\n+         (35, 'TOKENDELETE'),\n+         (36, 'TOKENUPDATE'),\n+         (37, 'TOKENMINT'),\n+         (38, 'TOKENBURN'),\n+         (39, 'TOKENWIPE'),\n+         (40, 'TOKENASSOCIATE'),\n+         (41, 'TOKENDISSOCIATE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP'),\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT'),\n+        (188, 'INVALID_KYC_KEY'),\n+        (189, 'INVALID_WIPE_KEY'),\n+        (190, 'INVALID_FREEZE_KEY'),\n+        (191, 'INVALID_SUPPLY_KEY'),\n+        (192, 'TOKEN_NAME_ALREADY_IN_USE'),\n+        (193, 'MISSING_TOKEN_NAME'),\n+        (194, 'TOKEN_NAME_TOO_LONG'),\n+        (195, 'INVALID_WIPING_AMOUNT'),\n+        (196, 'TOKEN_IS_IMMUTABlE'),\n+        (197, 'TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table with the following columns. Table will capture non shared `entity` items, most API calls may not require this information and therefore additional sql joins may be avoided.\n+    -   `token_id` (primary key)\n+    -   `create_timestamp`\n+    -   `divisibility`\n+    -   `freeze_default`\n+    -   `freeze_key`\n+    -   `initial_supply`\n+    -   `kyc_default`\n+    -   `kyc_key`\n+    -   `modify_timestamp`\n+    -   `supply_key`\n+    -   `symbol`\n+    -   `treasury_account_id`\n+    -   `wipe_key`\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+#### AccountBalance\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+#### TokenTransfer\n+-   Create new `TokenTransfer` with the following class members\n+    -   `accountId`\n+    -   `amount`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+#### EntityTypeEnum\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+        ...\n+        TOKEN(5);\n+        ...\n+    }\n+```\n+\n+#### Token\n+-   Add `Token` class to hold Token specific metadata outside of the base entity class with the following class members\n+    -   `createTimestamp`\n+    -   `divisibility`\n+    -   `freezeDefault`\n+    -   `freezeKey`\n+    -   `initialSupply`\n+    -   `kycDefault`\n+    -   `kycKey`\n+    -   `modifyTimestamp`\n+    -   `supplyKey`\n+    -   `symbol`\n+    -   `tokenId`\n+    -   `treasuryAccountId`\n+    -   `wipeKey`\n+\n+#### TokenAccount\n+-   Add `TokenAccount` class with the following class members\n+    -   `id`\n+    -   `accountId`\n+    -   `createTimestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modifyTimestamp`\n+    -   `tokenId`\n+    -   `wiped`\n+\n+#### TokenBalance\n+-   Add `TokenBalance` class with the following class members\n+    -   `accountId`\n+    -   `balance`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+### Balance Parsing\n+To support HTS the balance CSV\n+1. Adds a version comment as the first line of the file i.e. `# version:2`\n+2. Comments out the Timestamp e.g. `TimeStamp:2020-09-22T04:25:00.083212003Z`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "originalPosition": 247}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUyOTYxMQ==", "bodyText": "Will be changed to tokenId\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                          \"symbol\": \"FOOBAR\",\n          \n          \n            \n                          \"token_id\": \"0.1.2\",", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494529611", "createdAt": "2020-09-24T18:32:24Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,631 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members\n+    -   `account_id`\n+    -   `amount`\n+    -   `consensus_timestamp`\n+    -   `token_id`\n+-   Add a `token_transfer__token_account_timestamp` index with `desc` order on columns\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances with the following columns\n+    -   `consensus_timestamp`\n+    -   `account_id`\n+    -   `balance`\n+    -   `token_id`\n+-   Create primary key as combination of `consensus_timestamp`, `token_id` and `account_id`\n+\n+### Token Account Info\n+-   Create `token_account` table to distinctly capture token account metadata changes with the following columns\n+    -   `id` (primary key)\n+    -   `account_id`\n+    -   `create_timestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modify_timestamp`\n+    -   `token_id`\n+    -   `wiped`\n+-   Create unique index `token_account__token_account`\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with `id` value of 5 and `name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+         (28, 'UNCHECKEDSUBMIT'),\n+         (29, 'TOKENCREATE'),\n+         (30, 'TOKENTRANSFER'),\n+         (31, 'TOKENFREEZE'),\n+         (32, 'TOKENUNFREEZE'),\n+         (33, 'TOKENGRANTKYC'),\n+         (34, 'TOKENREVOKEKYC'),\n+         (35, 'TOKENDELETE'),\n+         (36, 'TOKENUPDATE'),\n+         (37, 'TOKENMINT'),\n+         (38, 'TOKENBURN'),\n+         (39, 'TOKENWIPE'),\n+         (40, 'TOKENASSOCIATE'),\n+         (41, 'TOKENDISSOCIATE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP'),\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT'),\n+        (188, 'INVALID_KYC_KEY'),\n+        (189, 'INVALID_WIPE_KEY'),\n+        (190, 'INVALID_FREEZE_KEY'),\n+        (191, 'INVALID_SUPPLY_KEY'),\n+        (192, 'TOKEN_NAME_ALREADY_IN_USE'),\n+        (193, 'MISSING_TOKEN_NAME'),\n+        (194, 'TOKEN_NAME_TOO_LONG'),\n+        (195, 'INVALID_WIPING_AMOUNT'),\n+        (196, 'TOKEN_IS_IMMUTABlE'),\n+        (197, 'TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table with the following columns. Table will capture non shared `entity` items, most API calls may not require this information and therefore additional sql joins may be avoided.\n+    -   `token_id` (primary key)\n+    -   `create_timestamp`\n+    -   `divisibility`\n+    -   `freeze_default`\n+    -   `freeze_key`\n+    -   `initial_supply`\n+    -   `kyc_default`\n+    -   `kyc_key`\n+    -   `modify_timestamp`\n+    -   `supply_key`\n+    -   `symbol`\n+    -   `treasury_account_id`\n+    -   `wipe_key`\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+#### AccountBalance\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+#### TokenTransfer\n+-   Create new `TokenTransfer` with the following class members\n+    -   `accountId`\n+    -   `amount`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+#### EntityTypeEnum\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+        ...\n+        TOKEN(5);\n+        ...\n+    }\n+```\n+\n+#### Token\n+-   Add `Token` class to hold Token specific metadata outside of the base entity class with the following class members\n+    -   `createTimestamp`\n+    -   `divisibility`\n+    -   `freezeDefault`\n+    -   `freezeKey`\n+    -   `initialSupply`\n+    -   `kycDefault`\n+    -   `kycKey`\n+    -   `modifyTimestamp`\n+    -   `supplyKey`\n+    -   `symbol`\n+    -   `tokenId`\n+    -   `treasuryAccountId`\n+    -   `wipeKey`\n+\n+#### TokenAccount\n+-   Add `TokenAccount` class with the following class members\n+    -   `id`\n+    -   `accountId`\n+    -   `createTimestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modifyTimestamp`\n+    -   `tokenId`\n+    -   `wiped`\n+\n+#### TokenBalance\n+-   Add `TokenBalance` class with the following class members\n+    -   `accountId`\n+    -   `balance`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+### Balance Parsing\n+To support HTS the balance CSV\n+1. Adds a version comment as the first line of the file i.e. `# version:2`\n+2. Comments out the Timestamp e.g. `TimeStamp:2020-09-22T04:25:00.083212003Z`\n+3. Adds a `tokenBalances` column which is the Base64 encoding of the serialized bytes of `TokenBalances` proto.\n+\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,tokenBalances`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first line of the CSV\n+    -   If `TimeStamp` is matched use `BalanceFileReaderImplV1` as the reader\n+    -   If `# version:2` is matched use `BalanceFileReaderImplV2` as the reader\n+    -   If no `# version:2` or `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenBalance` in the `TokenBalances`\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to set Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenTransferTransactionsHandler`\n+-   Add `TokenFreezeTransactionsHandler`\n+-   Add `TokenUnfreezeTransactionsHandler`\n+-   Add `TokenGrantKycTransactionsHandler`\n+-   Add `TokenRevokeKycTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to update Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenWipeTransactionsHandler`\n+-   Add `TokenAssociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenDissociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+\n+\n+### Token Transfer Parsing\n+\n+#### EntityListener\n+-   Add a `onToken()` to handle create and updates on the `token` table\n+```java\n+    default void onToken(Token token) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenAccount()` to handle inserts and updates on the `token_account` table\n+```java\n+    default void onTokenAccount(TokenAccount tokenAccount) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenTransfer()` to handle a `token_transfer` table\n+```java\n+    default void onTokenTransfer(TokenTransfer tokenTransfer) throws ImporterException {\n+    }\n+```\n+\n+#### EntityRecordItemListener\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+Add logic to check for\n+-   `TransactionBody.hasTokenCreation()` and parse `TokenCreateTransactionBody` out from the record. Create a new `Token` object and pass it to `entityListener.onToken()`.\n+-   `TransactionBody.hasTokenTransfers()` and parse `TokenTransferLists` out from the record. Create a new `TokenTransfer` object for each `AccountAmount` in the `TokenTransferList` object and pass it to `entityListener.onTokenTransfer()`.\n+-   `TransactionBody.hasTokenAssociate()` and parse `TokenAssociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenDissociate()` and parse `TokenDissociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenFreeze()` and parse `TokenFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUnfreeze()` and parse `TokenUnFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenGrantKyc()` and parse `TokenGrantKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenRevokeKyc()` and parse `TokenRevokeKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenWipe()` and parse `TokenWipeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `wipe` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUpdate()` and parse `TokenUpdateTransactionBody` out from the record. Retrieve an existing `Token` db entry, update the appropriate columns and pass it to `entityListener.onToken()`.\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `transactions` REST API must be updated to support `tokenTransfers`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `accounts` REST API must be updated to support `tokenBalances`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<symbol>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<symbol>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"token_balances\": [\n+            {\n+              \"symbol\": \"FOOBAR\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "originalPosition": 341}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUzMDIyNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                          \"symbol\": \"FOOCOIN\",\n          \n          \n            \n                          \"token_id\": \"0.3.4\",", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494530226", "createdAt": "2020-09-24T18:32:54Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,631 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members\n+    -   `account_id`\n+    -   `amount`\n+    -   `consensus_timestamp`\n+    -   `token_id`\n+-   Add a `token_transfer__token_account_timestamp` index with `desc` order on columns\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances with the following columns\n+    -   `consensus_timestamp`\n+    -   `account_id`\n+    -   `balance`\n+    -   `token_id`\n+-   Create primary key as combination of `consensus_timestamp`, `token_id` and `account_id`\n+\n+### Token Account Info\n+-   Create `token_account` table to distinctly capture token account metadata changes with the following columns\n+    -   `id` (primary key)\n+    -   `account_id`\n+    -   `create_timestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modify_timestamp`\n+    -   `token_id`\n+    -   `wiped`\n+-   Create unique index `token_account__token_account`\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with `id` value of 5 and `name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+         (28, 'UNCHECKEDSUBMIT'),\n+         (29, 'TOKENCREATE'),\n+         (30, 'TOKENTRANSFER'),\n+         (31, 'TOKENFREEZE'),\n+         (32, 'TOKENUNFREEZE'),\n+         (33, 'TOKENGRANTKYC'),\n+         (34, 'TOKENREVOKEKYC'),\n+         (35, 'TOKENDELETE'),\n+         (36, 'TOKENUPDATE'),\n+         (37, 'TOKENMINT'),\n+         (38, 'TOKENBURN'),\n+         (39, 'TOKENWIPE'),\n+         (40, 'TOKENASSOCIATE'),\n+         (41, 'TOKENDISSOCIATE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP'),\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT'),\n+        (188, 'INVALID_KYC_KEY'),\n+        (189, 'INVALID_WIPE_KEY'),\n+        (190, 'INVALID_FREEZE_KEY'),\n+        (191, 'INVALID_SUPPLY_KEY'),\n+        (192, 'TOKEN_NAME_ALREADY_IN_USE'),\n+        (193, 'MISSING_TOKEN_NAME'),\n+        (194, 'TOKEN_NAME_TOO_LONG'),\n+        (195, 'INVALID_WIPING_AMOUNT'),\n+        (196, 'TOKEN_IS_IMMUTABlE'),\n+        (197, 'TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table with the following columns. Table will capture non shared `entity` items, most API calls may not require this information and therefore additional sql joins may be avoided.\n+    -   `token_id` (primary key)\n+    -   `create_timestamp`\n+    -   `divisibility`\n+    -   `freeze_default`\n+    -   `freeze_key`\n+    -   `initial_supply`\n+    -   `kyc_default`\n+    -   `kyc_key`\n+    -   `modify_timestamp`\n+    -   `supply_key`\n+    -   `symbol`\n+    -   `treasury_account_id`\n+    -   `wipe_key`\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+#### AccountBalance\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+#### TokenTransfer\n+-   Create new `TokenTransfer` with the following class members\n+    -   `accountId`\n+    -   `amount`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+#### EntityTypeEnum\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+        ...\n+        TOKEN(5);\n+        ...\n+    }\n+```\n+\n+#### Token\n+-   Add `Token` class to hold Token specific metadata outside of the base entity class with the following class members\n+    -   `createTimestamp`\n+    -   `divisibility`\n+    -   `freezeDefault`\n+    -   `freezeKey`\n+    -   `initialSupply`\n+    -   `kycDefault`\n+    -   `kycKey`\n+    -   `modifyTimestamp`\n+    -   `supplyKey`\n+    -   `symbol`\n+    -   `tokenId`\n+    -   `treasuryAccountId`\n+    -   `wipeKey`\n+\n+#### TokenAccount\n+-   Add `TokenAccount` class with the following class members\n+    -   `id`\n+    -   `accountId`\n+    -   `createTimestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modifyTimestamp`\n+    -   `tokenId`\n+    -   `wiped`\n+\n+#### TokenBalance\n+-   Add `TokenBalance` class with the following class members\n+    -   `accountId`\n+    -   `balance`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+### Balance Parsing\n+To support HTS the balance CSV\n+1. Adds a version comment as the first line of the file i.e. `# version:2`\n+2. Comments out the Timestamp e.g. `TimeStamp:2020-09-22T04:25:00.083212003Z`\n+3. Adds a `tokenBalances` column which is the Base64 encoding of the serialized bytes of `TokenBalances` proto.\n+\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,tokenBalances`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first line of the CSV\n+    -   If `TimeStamp` is matched use `BalanceFileReaderImplV1` as the reader\n+    -   If `# version:2` is matched use `BalanceFileReaderImplV2` as the reader\n+    -   If no `# version:2` or `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenBalance` in the `TokenBalances`\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to set Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenTransferTransactionsHandler`\n+-   Add `TokenFreezeTransactionsHandler`\n+-   Add `TokenUnfreezeTransactionsHandler`\n+-   Add `TokenGrantKycTransactionsHandler`\n+-   Add `TokenRevokeKycTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to update Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenWipeTransactionsHandler`\n+-   Add `TokenAssociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenDissociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+\n+\n+### Token Transfer Parsing\n+\n+#### EntityListener\n+-   Add a `onToken()` to handle create and updates on the `token` table\n+```java\n+    default void onToken(Token token) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenAccount()` to handle inserts and updates on the `token_account` table\n+```java\n+    default void onTokenAccount(TokenAccount tokenAccount) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenTransfer()` to handle a `token_transfer` table\n+```java\n+    default void onTokenTransfer(TokenTransfer tokenTransfer) throws ImporterException {\n+    }\n+```\n+\n+#### EntityRecordItemListener\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+Add logic to check for\n+-   `TransactionBody.hasTokenCreation()` and parse `TokenCreateTransactionBody` out from the record. Create a new `Token` object and pass it to `entityListener.onToken()`.\n+-   `TransactionBody.hasTokenTransfers()` and parse `TokenTransferLists` out from the record. Create a new `TokenTransfer` object for each `AccountAmount` in the `TokenTransferList` object and pass it to `entityListener.onTokenTransfer()`.\n+-   `TransactionBody.hasTokenAssociate()` and parse `TokenAssociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenDissociate()` and parse `TokenDissociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenFreeze()` and parse `TokenFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUnfreeze()` and parse `TokenUnFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenGrantKyc()` and parse `TokenGrantKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenRevokeKyc()` and parse `TokenRevokeKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenWipe()` and parse `TokenWipeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `wipe` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUpdate()` and parse `TokenUpdateTransactionBody` out from the record. Retrieve an existing `Token` db entry, update the appropriate columns and pass it to `entityListener.onToken()`.\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `transactions` REST API must be updated to support `tokenTransfers`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `accounts` REST API must be updated to support `tokenBalances`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<symbol>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<symbol>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"token_balances\": [\n+            {\n+              \"symbol\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"symbol\": \"FOOCOIN\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "originalPosition": 345}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUzMjI4NQ==", "bodyText": "Additionally add publickey to match token adminKey\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            -   `/api/v1/tokens/<symbol>/balances?timestamp=1566562500.040961001`\n          \n          \n            \n            -   `/api/v1/tokens/<tokenId>/balances?timestamp=1566562500.040961001`\n          \n          \n            \n            -   `/api/v1/tokens/< tokenId >/balances?publicKey=2b60955bcbf0cf5e9ea880b52e5b63f664b08edf6ed 15e301049517438d61864`\n          \n      \n    \n    \n  \n\nBasically we want similar parity with https://docs.hedera.com/guides/docs/mirror-node-api/cryptocurrency-api#additional-examples", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494532285", "createdAt": "2020-09-24T18:36:45Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,631 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members\n+    -   `account_id`\n+    -   `amount`\n+    -   `consensus_timestamp`\n+    -   `token_id`\n+-   Add a `token_transfer__token_account_timestamp` index with `desc` order on columns\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances with the following columns\n+    -   `consensus_timestamp`\n+    -   `account_id`\n+    -   `balance`\n+    -   `token_id`\n+-   Create primary key as combination of `consensus_timestamp`, `token_id` and `account_id`\n+\n+### Token Account Info\n+-   Create `token_account` table to distinctly capture token account metadata changes with the following columns\n+    -   `id` (primary key)\n+    -   `account_id`\n+    -   `create_timestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modify_timestamp`\n+    -   `token_id`\n+    -   `wiped`\n+-   Create unique index `token_account__token_account`\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with `id` value of 5 and `name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+         (28, 'UNCHECKEDSUBMIT'),\n+         (29, 'TOKENCREATE'),\n+         (30, 'TOKENTRANSFER'),\n+         (31, 'TOKENFREEZE'),\n+         (32, 'TOKENUNFREEZE'),\n+         (33, 'TOKENGRANTKYC'),\n+         (34, 'TOKENREVOKEKYC'),\n+         (35, 'TOKENDELETE'),\n+         (36, 'TOKENUPDATE'),\n+         (37, 'TOKENMINT'),\n+         (38, 'TOKENBURN'),\n+         (39, 'TOKENWIPE'),\n+         (40, 'TOKENASSOCIATE'),\n+         (41, 'TOKENDISSOCIATE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP'),\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT'),\n+        (188, 'INVALID_KYC_KEY'),\n+        (189, 'INVALID_WIPE_KEY'),\n+        (190, 'INVALID_FREEZE_KEY'),\n+        (191, 'INVALID_SUPPLY_KEY'),\n+        (192, 'TOKEN_NAME_ALREADY_IN_USE'),\n+        (193, 'MISSING_TOKEN_NAME'),\n+        (194, 'TOKEN_NAME_TOO_LONG'),\n+        (195, 'INVALID_WIPING_AMOUNT'),\n+        (196, 'TOKEN_IS_IMMUTABlE'),\n+        (197, 'TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table with the following columns. Table will capture non shared `entity` items, most API calls may not require this information and therefore additional sql joins may be avoided.\n+    -   `token_id` (primary key)\n+    -   `create_timestamp`\n+    -   `divisibility`\n+    -   `freeze_default`\n+    -   `freeze_key`\n+    -   `initial_supply`\n+    -   `kyc_default`\n+    -   `kyc_key`\n+    -   `modify_timestamp`\n+    -   `supply_key`\n+    -   `symbol`\n+    -   `treasury_account_id`\n+    -   `wipe_key`\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+#### AccountBalance\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+#### TokenTransfer\n+-   Create new `TokenTransfer` with the following class members\n+    -   `accountId`\n+    -   `amount`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+#### EntityTypeEnum\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+        ...\n+        TOKEN(5);\n+        ...\n+    }\n+```\n+\n+#### Token\n+-   Add `Token` class to hold Token specific metadata outside of the base entity class with the following class members\n+    -   `createTimestamp`\n+    -   `divisibility`\n+    -   `freezeDefault`\n+    -   `freezeKey`\n+    -   `initialSupply`\n+    -   `kycDefault`\n+    -   `kycKey`\n+    -   `modifyTimestamp`\n+    -   `supplyKey`\n+    -   `symbol`\n+    -   `tokenId`\n+    -   `treasuryAccountId`\n+    -   `wipeKey`\n+\n+#### TokenAccount\n+-   Add `TokenAccount` class with the following class members\n+    -   `id`\n+    -   `accountId`\n+    -   `createTimestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modifyTimestamp`\n+    -   `tokenId`\n+    -   `wiped`\n+\n+#### TokenBalance\n+-   Add `TokenBalance` class with the following class members\n+    -   `accountId`\n+    -   `balance`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+### Balance Parsing\n+To support HTS the balance CSV\n+1. Adds a version comment as the first line of the file i.e. `# version:2`\n+2. Comments out the Timestamp e.g. `TimeStamp:2020-09-22T04:25:00.083212003Z`\n+3. Adds a `tokenBalances` column which is the Base64 encoding of the serialized bytes of `TokenBalances` proto.\n+\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,tokenBalances`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first line of the CSV\n+    -   If `TimeStamp` is matched use `BalanceFileReaderImplV1` as the reader\n+    -   If `# version:2` is matched use `BalanceFileReaderImplV2` as the reader\n+    -   If no `# version:2` or `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenBalance` in the `TokenBalances`\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to set Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenTransferTransactionsHandler`\n+-   Add `TokenFreezeTransactionsHandler`\n+-   Add `TokenUnfreezeTransactionsHandler`\n+-   Add `TokenGrantKycTransactionsHandler`\n+-   Add `TokenRevokeKycTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to update Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenWipeTransactionsHandler`\n+-   Add `TokenAssociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenDissociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+\n+\n+### Token Transfer Parsing\n+\n+#### EntityListener\n+-   Add a `onToken()` to handle create and updates on the `token` table\n+```java\n+    default void onToken(Token token) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenAccount()` to handle inserts and updates on the `token_account` table\n+```java\n+    default void onTokenAccount(TokenAccount tokenAccount) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenTransfer()` to handle a `token_transfer` table\n+```java\n+    default void onTokenTransfer(TokenTransfer tokenTransfer) throws ImporterException {\n+    }\n+```\n+\n+#### EntityRecordItemListener\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+Add logic to check for\n+-   `TransactionBody.hasTokenCreation()` and parse `TokenCreateTransactionBody` out from the record. Create a new `Token` object and pass it to `entityListener.onToken()`.\n+-   `TransactionBody.hasTokenTransfers()` and parse `TokenTransferLists` out from the record. Create a new `TokenTransfer` object for each `AccountAmount` in the `TokenTransferList` object and pass it to `entityListener.onTokenTransfer()`.\n+-   `TransactionBody.hasTokenAssociate()` and parse `TokenAssociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenDissociate()` and parse `TokenDissociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenFreeze()` and parse `TokenFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUnfreeze()` and parse `TokenUnFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenGrantKyc()` and parse `TokenGrantKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenRevokeKyc()` and parse `TokenRevokeKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenWipe()` and parse `TokenWipeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `wipe` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUpdate()` and parse `TokenUpdateTransactionBody` out from the record. Retrieve an existing `Token` db entry, update the appropriate columns and pass it to `entityListener.onToken()`.\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `transactions` REST API must be updated to support `tokenTransfers`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `accounts` REST API must be updated to support `tokenBalances`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<symbol>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<symbol>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"token_balances\": [\n+            {\n+              \"symbol\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"symbol\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"token_balances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"token_balances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"token_balances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"symbol\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"transfers\": [\n+                {\n+                  \"account\": \"0.0.1111\",\n+                  \"amount\": -10,\n+                  \"symbol\": \"FOOBAR\"\n+                },\n+                {\n+                  \"account\": \"0.0.2222\",\n+                  \"amount\": 10,\n+                  \"symbol\": \"FOOBAR\"\n+                }\n+              ]\n+            },\n+            {\n+              \"transfers\": [\n+                {\n+                  \"account\": \"0.0.3333\",\n+                  \"amount\": -10,\n+                  \"symbol\":\"FOOCOIN\"\n+                },\n+                {\n+                  \"account\": \"0.0.4444\",\n+                  \"amount\": 10,\n+                  \"symbol\":\"FOOCOIN\"\n+                }\n+               ]\n+            }\n+          ]\n+        }\n+      ]\n+    }\n+```\n+\n+### Token Supply distribution\n+\n+`/api/v1/tokens/<symbol>/balances` this could be the equivalent of `/api/v1/balances?symbol=<symbol>` currently and would return a list of account and the token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.15.10\",\n+            \"balance\": 100\n+          },\n+          {\n+            \"account\": \"0.15.9\",\n+            \"balance\": 90\n+          },\n+          {\n+            \"account\": \"0.15.8\",\n+            \"balance\": 80\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens/<symbol>/balances?id=0.0.1000`\n+-   `/api/v1/tokens/<symbol>/balances?balance=gt:1000`\n+-   `/api/v1/tokens/<symbol>/balances?timestamp=1566562500.040961001`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "originalPosition": 500}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUzOTgwMg==", "bodyText": "Add tokenId range\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            -   `/api/v1/tokens?account.id=0.0.8` - All tokens for matching account\n          \n          \n            \n            -   `/api/v1/tokens?token.id=0.0.8` - All tokens for matching account\n          \n          \n            \n            -   `/api/v1/tokens?token.id=gt:0.0.1001`", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494539802", "createdAt": "2020-09-24T18:49:56Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,631 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members\n+    -   `account_id`\n+    -   `amount`\n+    -   `consensus_timestamp`\n+    -   `token_id`\n+-   Add a `token_transfer__token_account_timestamp` index with `desc` order on columns\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances with the following columns\n+    -   `consensus_timestamp`\n+    -   `account_id`\n+    -   `balance`\n+    -   `token_id`\n+-   Create primary key as combination of `consensus_timestamp`, `token_id` and `account_id`\n+\n+### Token Account Info\n+-   Create `token_account` table to distinctly capture token account metadata changes with the following columns\n+    -   `id` (primary key)\n+    -   `account_id`\n+    -   `create_timestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modify_timestamp`\n+    -   `token_id`\n+    -   `wiped`\n+-   Create unique index `token_account__token_account`\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with `id` value of 5 and `name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+         (28, 'UNCHECKEDSUBMIT'),\n+         (29, 'TOKENCREATE'),\n+         (30, 'TOKENTRANSFER'),\n+         (31, 'TOKENFREEZE'),\n+         (32, 'TOKENUNFREEZE'),\n+         (33, 'TOKENGRANTKYC'),\n+         (34, 'TOKENREVOKEKYC'),\n+         (35, 'TOKENDELETE'),\n+         (36, 'TOKENUPDATE'),\n+         (37, 'TOKENMINT'),\n+         (38, 'TOKENBURN'),\n+         (39, 'TOKENWIPE'),\n+         (40, 'TOKENASSOCIATE'),\n+         (41, 'TOKENDISSOCIATE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP'),\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT'),\n+        (188, 'INVALID_KYC_KEY'),\n+        (189, 'INVALID_WIPE_KEY'),\n+        (190, 'INVALID_FREEZE_KEY'),\n+        (191, 'INVALID_SUPPLY_KEY'),\n+        (192, 'TOKEN_NAME_ALREADY_IN_USE'),\n+        (193, 'MISSING_TOKEN_NAME'),\n+        (194, 'TOKEN_NAME_TOO_LONG'),\n+        (195, 'INVALID_WIPING_AMOUNT'),\n+        (196, 'TOKEN_IS_IMMUTABlE'),\n+        (197, 'TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table with the following columns. Table will capture non shared `entity` items, most API calls may not require this information and therefore additional sql joins may be avoided.\n+    -   `token_id` (primary key)\n+    -   `create_timestamp`\n+    -   `divisibility`\n+    -   `freeze_default`\n+    -   `freeze_key`\n+    -   `initial_supply`\n+    -   `kyc_default`\n+    -   `kyc_key`\n+    -   `modify_timestamp`\n+    -   `supply_key`\n+    -   `symbol`\n+    -   `treasury_account_id`\n+    -   `wipe_key`\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+#### AccountBalance\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+#### TokenTransfer\n+-   Create new `TokenTransfer` with the following class members\n+    -   `accountId`\n+    -   `amount`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+#### EntityTypeEnum\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+        ...\n+        TOKEN(5);\n+        ...\n+    }\n+```\n+\n+#### Token\n+-   Add `Token` class to hold Token specific metadata outside of the base entity class with the following class members\n+    -   `createTimestamp`\n+    -   `divisibility`\n+    -   `freezeDefault`\n+    -   `freezeKey`\n+    -   `initialSupply`\n+    -   `kycDefault`\n+    -   `kycKey`\n+    -   `modifyTimestamp`\n+    -   `supplyKey`\n+    -   `symbol`\n+    -   `tokenId`\n+    -   `treasuryAccountId`\n+    -   `wipeKey`\n+\n+#### TokenAccount\n+-   Add `TokenAccount` class with the following class members\n+    -   `id`\n+    -   `accountId`\n+    -   `createTimestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modifyTimestamp`\n+    -   `tokenId`\n+    -   `wiped`\n+\n+#### TokenBalance\n+-   Add `TokenBalance` class with the following class members\n+    -   `accountId`\n+    -   `balance`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+### Balance Parsing\n+To support HTS the balance CSV\n+1. Adds a version comment as the first line of the file i.e. `# version:2`\n+2. Comments out the Timestamp e.g. `TimeStamp:2020-09-22T04:25:00.083212003Z`\n+3. Adds a `tokenBalances` column which is the Base64 encoding of the serialized bytes of `TokenBalances` proto.\n+\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,tokenBalances`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first line of the CSV\n+    -   If `TimeStamp` is matched use `BalanceFileReaderImplV1` as the reader\n+    -   If `# version:2` is matched use `BalanceFileReaderImplV2` as the reader\n+    -   If no `# version:2` or `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenBalance` in the `TokenBalances`\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to set Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenTransferTransactionsHandler`\n+-   Add `TokenFreezeTransactionsHandler`\n+-   Add `TokenUnfreezeTransactionsHandler`\n+-   Add `TokenGrantKycTransactionsHandler`\n+-   Add `TokenRevokeKycTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to update Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenWipeTransactionsHandler`\n+-   Add `TokenAssociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenDissociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+\n+\n+### Token Transfer Parsing\n+\n+#### EntityListener\n+-   Add a `onToken()` to handle create and updates on the `token` table\n+```java\n+    default void onToken(Token token) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenAccount()` to handle inserts and updates on the `token_account` table\n+```java\n+    default void onTokenAccount(TokenAccount tokenAccount) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenTransfer()` to handle a `token_transfer` table\n+```java\n+    default void onTokenTransfer(TokenTransfer tokenTransfer) throws ImporterException {\n+    }\n+```\n+\n+#### EntityRecordItemListener\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+Add logic to check for\n+-   `TransactionBody.hasTokenCreation()` and parse `TokenCreateTransactionBody` out from the record. Create a new `Token` object and pass it to `entityListener.onToken()`.\n+-   `TransactionBody.hasTokenTransfers()` and parse `TokenTransferLists` out from the record. Create a new `TokenTransfer` object for each `AccountAmount` in the `TokenTransferList` object and pass it to `entityListener.onTokenTransfer()`.\n+-   `TransactionBody.hasTokenAssociate()` and parse `TokenAssociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenDissociate()` and parse `TokenDissociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenFreeze()` and parse `TokenFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUnfreeze()` and parse `TokenUnFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenGrantKyc()` and parse `TokenGrantKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenRevokeKyc()` and parse `TokenRevokeKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenWipe()` and parse `TokenWipeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `wipe` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUpdate()` and parse `TokenUpdateTransactionBody` out from the record. Retrieve an existing `Token` db entry, update the appropriate columns and pass it to `entityListener.onToken()`.\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `transactions` REST API must be updated to support `tokenTransfers`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `accounts` REST API must be updated to support `tokenBalances`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<symbol>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<symbol>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"token_balances\": [\n+            {\n+              \"symbol\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"symbol\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"token_balances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"token_balances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"token_balances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"symbol\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"transfers\": [\n+                {\n+                  \"account\": \"0.0.1111\",\n+                  \"amount\": -10,\n+                  \"symbol\": \"FOOBAR\"\n+                },\n+                {\n+                  \"account\": \"0.0.2222\",\n+                  \"amount\": 10,\n+                  \"symbol\": \"FOOBAR\"\n+                }\n+              ]\n+            },\n+            {\n+              \"transfers\": [\n+                {\n+                  \"account\": \"0.0.3333\",\n+                  \"amount\": -10,\n+                  \"symbol\":\"FOOCOIN\"\n+                },\n+                {\n+                  \"account\": \"0.0.4444\",\n+                  \"amount\": 10,\n+                  \"symbol\":\"FOOCOIN\"\n+                }\n+               ]\n+            }\n+          ]\n+        }\n+      ]\n+    }\n+```\n+\n+### Token Supply distribution\n+\n+`/api/v1/tokens/<symbol>/balances` this could be the equivalent of `/api/v1/balances?symbol=<symbol>` currently and would return a list of account and the token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.15.10\",\n+            \"balance\": 100\n+          },\n+          {\n+            \"account\": \"0.15.9\",\n+            \"balance\": 90\n+          },\n+          {\n+            \"account\": \"0.15.8\",\n+            \"balance\": 80\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens/<symbol>/balances?id=0.0.1000`\n+-   `/api/v1/tokens/<symbol>/balances?balance=gt:1000`\n+-   `/api/v1/tokens/<symbol>/balances?timestamp=1566562500.040961001`\n+\n+### Token Discovery\n+`/api/v1/tokens` this would return all tokens present on the network\n+\n+```json\n+    {\n+        \"tokens\": [\n+          {\n+            \"symbol\": \"FOOBAR\",\n+            \"token_id\": \"0.15.10\",\n+            \"admin_key\": {\n+              \"_type\": \"ProtobufEncoded\",\n+              \"key\": \"7b2233222c2233222c2233227d\"\n+            }\n+          },\n+          {\n+            \"symbol\": \"FOOCOIN\",\n+            \"tokenId\": \"0.15.11\",\n+            \"admin_key\": {\n+              \"_type\": \"ProtobufEncoded\",\n+              \"key\": \"9c2233222c2233222c2233227d\"\n+            }\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens?publickey=3c3d546321ff6f63d701d2ec5c277095874e19f4a235bee1e6bb19258bf362be` - All tokens with matching admin key\n+-   `/api/v1/tokens?account.id=0.0.8` - All tokens for matching account", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "originalPosition": 533}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU0MTA2Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            `/api/v1/tokens/<symbol>/balances` this could be the equivalent of `/api/v1/balances?symbol=<symbol>` currently and would return a list of account and the token balances\n          \n          \n            \n            `/api/v1/tokens/<tokenId>/balances` this could be the equivalent of `/api/v1/balances?account.id=<account.id>` currently and would return a list of account and the token balances", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494541062", "createdAt": "2020-09-24T18:52:11Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,631 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members\n+    -   `account_id`\n+    -   `amount`\n+    -   `consensus_timestamp`\n+    -   `token_id`\n+-   Add a `token_transfer__token_account_timestamp` index with `desc` order on columns\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances with the following columns\n+    -   `consensus_timestamp`\n+    -   `account_id`\n+    -   `balance`\n+    -   `token_id`\n+-   Create primary key as combination of `consensus_timestamp`, `token_id` and `account_id`\n+\n+### Token Account Info\n+-   Create `token_account` table to distinctly capture token account metadata changes with the following columns\n+    -   `id` (primary key)\n+    -   `account_id`\n+    -   `create_timestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modify_timestamp`\n+    -   `token_id`\n+    -   `wiped`\n+-   Create unique index `token_account__token_account`\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with `id` value of 5 and `name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+         (28, 'UNCHECKEDSUBMIT'),\n+         (29, 'TOKENCREATE'),\n+         (30, 'TOKENTRANSFER'),\n+         (31, 'TOKENFREEZE'),\n+         (32, 'TOKENUNFREEZE'),\n+         (33, 'TOKENGRANTKYC'),\n+         (34, 'TOKENREVOKEKYC'),\n+         (35, 'TOKENDELETE'),\n+         (36, 'TOKENUPDATE'),\n+         (37, 'TOKENMINT'),\n+         (38, 'TOKENBURN'),\n+         (39, 'TOKENWIPE'),\n+         (40, 'TOKENASSOCIATE'),\n+         (41, 'TOKENDISSOCIATE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP'),\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT'),\n+        (188, 'INVALID_KYC_KEY'),\n+        (189, 'INVALID_WIPE_KEY'),\n+        (190, 'INVALID_FREEZE_KEY'),\n+        (191, 'INVALID_SUPPLY_KEY'),\n+        (192, 'TOKEN_NAME_ALREADY_IN_USE'),\n+        (193, 'MISSING_TOKEN_NAME'),\n+        (194, 'TOKEN_NAME_TOO_LONG'),\n+        (195, 'INVALID_WIPING_AMOUNT'),\n+        (196, 'TOKEN_IS_IMMUTABlE'),\n+        (197, 'TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table with the following columns. Table will capture non shared `entity` items, most API calls may not require this information and therefore additional sql joins may be avoided.\n+    -   `token_id` (primary key)\n+    -   `create_timestamp`\n+    -   `divisibility`\n+    -   `freeze_default`\n+    -   `freeze_key`\n+    -   `initial_supply`\n+    -   `kyc_default`\n+    -   `kyc_key`\n+    -   `modify_timestamp`\n+    -   `supply_key`\n+    -   `symbol`\n+    -   `treasury_account_id`\n+    -   `wipe_key`\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+#### AccountBalance\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+#### TokenTransfer\n+-   Create new `TokenTransfer` with the following class members\n+    -   `accountId`\n+    -   `amount`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+#### EntityTypeEnum\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+        ...\n+        TOKEN(5);\n+        ...\n+    }\n+```\n+\n+#### Token\n+-   Add `Token` class to hold Token specific metadata outside of the base entity class with the following class members\n+    -   `createTimestamp`\n+    -   `divisibility`\n+    -   `freezeDefault`\n+    -   `freezeKey`\n+    -   `initialSupply`\n+    -   `kycDefault`\n+    -   `kycKey`\n+    -   `modifyTimestamp`\n+    -   `supplyKey`\n+    -   `symbol`\n+    -   `tokenId`\n+    -   `treasuryAccountId`\n+    -   `wipeKey`\n+\n+#### TokenAccount\n+-   Add `TokenAccount` class with the following class members\n+    -   `id`\n+    -   `accountId`\n+    -   `createTimestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modifyTimestamp`\n+    -   `tokenId`\n+    -   `wiped`\n+\n+#### TokenBalance\n+-   Add `TokenBalance` class with the following class members\n+    -   `accountId`\n+    -   `balance`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+### Balance Parsing\n+To support HTS the balance CSV\n+1. Adds a version comment as the first line of the file i.e. `# version:2`\n+2. Comments out the Timestamp e.g. `TimeStamp:2020-09-22T04:25:00.083212003Z`\n+3. Adds a `tokenBalances` column which is the Base64 encoding of the serialized bytes of `TokenBalances` proto.\n+\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,tokenBalances`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first line of the CSV\n+    -   If `TimeStamp` is matched use `BalanceFileReaderImplV1` as the reader\n+    -   If `# version:2` is matched use `BalanceFileReaderImplV2` as the reader\n+    -   If no `# version:2` or `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenBalance` in the `TokenBalances`\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to set Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenTransferTransactionsHandler`\n+-   Add `TokenFreezeTransactionsHandler`\n+-   Add `TokenUnfreezeTransactionsHandler`\n+-   Add `TokenGrantKycTransactionsHandler`\n+-   Add `TokenRevokeKycTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to update Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenWipeTransactionsHandler`\n+-   Add `TokenAssociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenDissociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+\n+\n+### Token Transfer Parsing\n+\n+#### EntityListener\n+-   Add a `onToken()` to handle create and updates on the `token` table\n+```java\n+    default void onToken(Token token) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenAccount()` to handle inserts and updates on the `token_account` table\n+```java\n+    default void onTokenAccount(TokenAccount tokenAccount) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenTransfer()` to handle a `token_transfer` table\n+```java\n+    default void onTokenTransfer(TokenTransfer tokenTransfer) throws ImporterException {\n+    }\n+```\n+\n+#### EntityRecordItemListener\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+Add logic to check for\n+-   `TransactionBody.hasTokenCreation()` and parse `TokenCreateTransactionBody` out from the record. Create a new `Token` object and pass it to `entityListener.onToken()`.\n+-   `TransactionBody.hasTokenTransfers()` and parse `TokenTransferLists` out from the record. Create a new `TokenTransfer` object for each `AccountAmount` in the `TokenTransferList` object and pass it to `entityListener.onTokenTransfer()`.\n+-   `TransactionBody.hasTokenAssociate()` and parse `TokenAssociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenDissociate()` and parse `TokenDissociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenFreeze()` and parse `TokenFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUnfreeze()` and parse `TokenUnFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenGrantKyc()` and parse `TokenGrantKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenRevokeKyc()` and parse `TokenRevokeKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenWipe()` and parse `TokenWipeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `wipe` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUpdate()` and parse `TokenUpdateTransactionBody` out from the record. Retrieve an existing `Token` db entry, update the appropriate columns and pass it to `entityListener.onToken()`.\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `transactions` REST API must be updated to support `tokenTransfers`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `accounts` REST API must be updated to support `tokenBalances`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<symbol>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<symbol>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"token_balances\": [\n+            {\n+              \"symbol\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"symbol\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"token_balances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"token_balances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"token_balances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"symbol\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"transfers\": [\n+                {\n+                  \"account\": \"0.0.1111\",\n+                  \"amount\": -10,\n+                  \"symbol\": \"FOOBAR\"\n+                },\n+                {\n+                  \"account\": \"0.0.2222\",\n+                  \"amount\": 10,\n+                  \"symbol\": \"FOOBAR\"\n+                }\n+              ]\n+            },\n+            {\n+              \"transfers\": [\n+                {\n+                  \"account\": \"0.0.3333\",\n+                  \"amount\": -10,\n+                  \"symbol\":\"FOOCOIN\"\n+                },\n+                {\n+                  \"account\": \"0.0.4444\",\n+                  \"amount\": 10,\n+                  \"symbol\":\"FOOCOIN\"\n+                }\n+               ]\n+            }\n+          ]\n+        }\n+      ]\n+    }\n+```\n+\n+### Token Supply distribution\n+\n+`/api/v1/tokens/<symbol>/balances` this could be the equivalent of `/api/v1/balances?symbol=<symbol>` currently and would return a list of account and the token balances", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "originalPosition": 473}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1ODczODgx", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#pullrequestreview-495873881", "createdAt": "2020-09-24T19:07:34Z", "commit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxOTowNzozNFrOHXo6Hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxOTowODoyOFrOHXo71w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU0OTUzNQ==", "bodyText": "Spurious transfers key and extra array", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494549535", "createdAt": "2020-09-24T19:07:34Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,631 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members\n+    -   `account_id`\n+    -   `amount`\n+    -   `consensus_timestamp`\n+    -   `token_id`\n+-   Add a `token_transfer__token_account_timestamp` index with `desc` order on columns\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances with the following columns\n+    -   `consensus_timestamp`\n+    -   `account_id`\n+    -   `balance`\n+    -   `token_id`\n+-   Create primary key as combination of `consensus_timestamp`, `token_id` and `account_id`\n+\n+### Token Account Info\n+-   Create `token_account` table to distinctly capture token account metadata changes with the following columns\n+    -   `id` (primary key)\n+    -   `account_id`\n+    -   `create_timestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modify_timestamp`\n+    -   `token_id`\n+    -   `wiped`\n+-   Create unique index `token_account__token_account`\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with `id` value of 5 and `name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+         (28, 'UNCHECKEDSUBMIT'),\n+         (29, 'TOKENCREATE'),\n+         (30, 'TOKENTRANSFER'),\n+         (31, 'TOKENFREEZE'),\n+         (32, 'TOKENUNFREEZE'),\n+         (33, 'TOKENGRANTKYC'),\n+         (34, 'TOKENREVOKEKYC'),\n+         (35, 'TOKENDELETE'),\n+         (36, 'TOKENUPDATE'),\n+         (37, 'TOKENMINT'),\n+         (38, 'TOKENBURN'),\n+         (39, 'TOKENWIPE'),\n+         (40, 'TOKENASSOCIATE'),\n+         (41, 'TOKENDISSOCIATE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP'),\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT'),\n+        (188, 'INVALID_KYC_KEY'),\n+        (189, 'INVALID_WIPE_KEY'),\n+        (190, 'INVALID_FREEZE_KEY'),\n+        (191, 'INVALID_SUPPLY_KEY'),\n+        (192, 'TOKEN_NAME_ALREADY_IN_USE'),\n+        (193, 'MISSING_TOKEN_NAME'),\n+        (194, 'TOKEN_NAME_TOO_LONG'),\n+        (195, 'INVALID_WIPING_AMOUNT'),\n+        (196, 'TOKEN_IS_IMMUTABlE'),\n+        (197, 'TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table with the following columns. Table will capture non shared `entity` items, most API calls may not require this information and therefore additional sql joins may be avoided.\n+    -   `token_id` (primary key)\n+    -   `create_timestamp`\n+    -   `divisibility`\n+    -   `freeze_default`\n+    -   `freeze_key`\n+    -   `initial_supply`\n+    -   `kyc_default`\n+    -   `kyc_key`\n+    -   `modify_timestamp`\n+    -   `supply_key`\n+    -   `symbol`\n+    -   `treasury_account_id`\n+    -   `wipe_key`\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+#### AccountBalance\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+#### TokenTransfer\n+-   Create new `TokenTransfer` with the following class members\n+    -   `accountId`\n+    -   `amount`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+#### EntityTypeEnum\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+        ...\n+        TOKEN(5);\n+        ...\n+    }\n+```\n+\n+#### Token\n+-   Add `Token` class to hold Token specific metadata outside of the base entity class with the following class members\n+    -   `createTimestamp`\n+    -   `divisibility`\n+    -   `freezeDefault`\n+    -   `freezeKey`\n+    -   `initialSupply`\n+    -   `kycDefault`\n+    -   `kycKey`\n+    -   `modifyTimestamp`\n+    -   `supplyKey`\n+    -   `symbol`\n+    -   `tokenId`\n+    -   `treasuryAccountId`\n+    -   `wipeKey`\n+\n+#### TokenAccount\n+-   Add `TokenAccount` class with the following class members\n+    -   `id`\n+    -   `accountId`\n+    -   `createTimestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modifyTimestamp`\n+    -   `tokenId`\n+    -   `wiped`\n+\n+#### TokenBalance\n+-   Add `TokenBalance` class with the following class members\n+    -   `accountId`\n+    -   `balance`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+### Balance Parsing\n+To support HTS the balance CSV\n+1. Adds a version comment as the first line of the file i.e. `# version:2`\n+2. Comments out the Timestamp e.g. `TimeStamp:2020-09-22T04:25:00.083212003Z`\n+3. Adds a `tokenBalances` column which is the Base64 encoding of the serialized bytes of `TokenBalances` proto.\n+\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,tokenBalances`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first line of the CSV\n+    -   If `TimeStamp` is matched use `BalanceFileReaderImplV1` as the reader\n+    -   If `# version:2` is matched use `BalanceFileReaderImplV2` as the reader\n+    -   If no `# version:2` or `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenBalance` in the `TokenBalances`\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to set Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenTransferTransactionsHandler`\n+-   Add `TokenFreezeTransactionsHandler`\n+-   Add `TokenUnfreezeTransactionsHandler`\n+-   Add `TokenGrantKycTransactionsHandler`\n+-   Add `TokenRevokeKycTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to update Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenWipeTransactionsHandler`\n+-   Add `TokenAssociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenDissociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+\n+\n+### Token Transfer Parsing\n+\n+#### EntityListener\n+-   Add a `onToken()` to handle create and updates on the `token` table\n+```java\n+    default void onToken(Token token) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenAccount()` to handle inserts and updates on the `token_account` table\n+```java\n+    default void onTokenAccount(TokenAccount tokenAccount) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenTransfer()` to handle a `token_transfer` table\n+```java\n+    default void onTokenTransfer(TokenTransfer tokenTransfer) throws ImporterException {\n+    }\n+```\n+\n+#### EntityRecordItemListener\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+Add logic to check for\n+-   `TransactionBody.hasTokenCreation()` and parse `TokenCreateTransactionBody` out from the record. Create a new `Token` object and pass it to `entityListener.onToken()`.\n+-   `TransactionBody.hasTokenTransfers()` and parse `TokenTransferLists` out from the record. Create a new `TokenTransfer` object for each `AccountAmount` in the `TokenTransferList` object and pass it to `entityListener.onTokenTransfer()`.\n+-   `TransactionBody.hasTokenAssociate()` and parse `TokenAssociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenDissociate()` and parse `TokenDissociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenFreeze()` and parse `TokenFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUnfreeze()` and parse `TokenUnFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenGrantKyc()` and parse `TokenGrantKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenRevokeKyc()` and parse `TokenRevokeKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenWipe()` and parse `TokenWipeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `wipe` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUpdate()` and parse `TokenUpdateTransactionBody` out from the record. Retrieve an existing `Token` db entry, update the appropriate columns and pass it to `entityListener.onToken()`.\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `transactions` REST API must be updated to support `tokenTransfers`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `accounts` REST API must be updated to support `tokenBalances`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<symbol>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<symbol>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"token_balances\": [\n+            {\n+              \"symbol\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"symbol\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"token_balances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"token_balances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"token_balances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"symbol\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"transfers\": [", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "originalPosition": 438}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU0OTk3NQ==", "bodyText": "This doesn't seem to have changed.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494549975", "createdAt": "2020-09-24T19:08:28Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,824 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its API's.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy 3rd integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream  CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and or all tokens\n+\n+## Architecture\n+\n+![Architecture](./images/mirror-arch.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `account_balance` table updated to use `account_id` of `entityId` type instead of `account_realm_num` and `account_num`\n+2. `t_entities` and ` t_entity_types` updated to represent new `TOKEN` entity\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. `crypto_transfer` table updated to persist token transfers and also distinguish between HBAR and other token transfers\n+6. `t_transaction_types` and `t_transaction_results` updated to handle token transactions from network.\n+7.  New `token_account_info` table added to persist token specific account state\n+\n+### Account Balance\n+```sql\n+    alter table if exists account_balance\n+        add column account_id entity_id null;\n+\n+    update account_balance\n+        set account_id = encodeEntityId(0, account_realm_num, account_num);\n+\n+    alter table if exists account_balance\n+        alter column account_id set not null;\n+```\n+\n+### Crypto Transfer\n+-   Add `token_id` column to `crypto_transfer` table and allow nullable for hbar case which is not an entity\n+```sql\n+    alter table if exists crypto_transfer\n+        add column token_id entity_id null;\n+```\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances vs HBAR balances\n+\n+```sql\n+    --- Add token_balance table to capture token account balances\n+    create table if not exists token_balance\n+        consensus_timestamp bigint              primary key not null\n+        account_id          entity_id           not null,\n+        balance             bigint              not null\n+        token_id            entity_id           not null;\n+```\n+\n+### Token Account Info\n+-   Create `token_account_info` table to distinctly capture token account metadata changes\n+\n+```sql\n+    --- Add token_account_info table to capture token-account info such as frozen, kyc and wipe status\n+    create table if not exists token_account_info\n+        consensus_timestamp bigint              primary key,\n+        account_id          entity_id           not null,\n+        frozen              boolean             not null,\n+        kyc                 boolean             not null,\n+        token_id            entity_id           not null,\n+        wiped               boolean             not null default false;\n+```\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+        (56, 'TOKENCREATE'),\n+        (57, 'TOKENTRANSACT'),\n+        (58, 'TOKENGETINFO'),\n+        (59, 'TOKENFREEZEACCOUNT'),\n+        (60, 'TOKENUNFREEZEACCOUNT'),\n+        (61, 'TOKENGRANTKYCTOACCOUNT'),\n+        (62, 'TOKENREVOKEKYCFROMACCOUNT'),\n+        (63, 'TOKENDELETE'),\n+        (64, 'TOKENUPDATE'),\n+        (65, 'TOKENMINT'),\n+        (66, 'TOKENBURN'),\n+        (67, 'TOKENACCOUNTWIPE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP')\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT')\n+        (188, 'INVALID_KYC_KEY')\n+        (189, 'INVALID_WIPE_KEY')\n+        (190, 'INVALID_FREEZE_KEY')\n+        (191, 'INVALID_SUPPLY_KEY')\n+        (192, 'INVALID_TOKEN_EXPIRY')\n+        (193, 'TOKEN_HAS_EXPIRED')\n+        (194, 'TOKEN_IS_IMMUTABlE');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table to split out the non shared entity items into a new table. Most API calls may not require this information and therefore additional sql joins may be avoided.\n+```sql\n+    create table if not exists token\n+        token_id            entity_id               primary key,\n+        consensus_timestamp bigint                  not null,\n+        divisibility        bigint                  not null,\n+        freeze_default      boolean                 not null,\n+        freeze_key          bytea,\n+        initial_supply      bigint                  not null,\n+        kyc_default         boolean                 not null,\n+        kyc_key             bytea,\n+        supply_key          bytea,\n+        token               character varying(96)   not null,\n+        treasury_id         entity_id               not null,\n+        wipe_key            bytea;\n+```\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+-   Update `AccountBalance` to use `accountId` class member, instead of `accountRealmNum` and `accountNum`\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    public static class Id implements Serializable {\n+        ...\n+\n+        private EntityId accountId;\n+    }\n+}\n+```\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumns({\n+        @JoinColumn(name=\"tokenBalance_consensusTimestamp\", referencedColumnName=\"consensusTimestamp\"),\n+        @JoinColumn(name=\"tokenBalance_accountId\", referencedColumnName=\"accountId\")\n+    })\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+-   Update `CryptoTransfer` to have a `token_id` class member, to allow it to represent both HBAR and Token transfers\n+\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+\n+        ACCOUNT(1),\n+        CONTRACT(2),\n+        FILE(3),\n+        TOPIC(4),\n+        TOKEN(5);\n+\n+        private final int id;\n+    }\n+```\n+\n+-   Add `TokenBalance`\n+```java\n+    public class TokenBalance implements Persistable<TokenBalance.Id> {\n+\n+        private long balance;\n+\n+        @EmbeddedId\n+        @JsonUnwrapped\n+        private Id id;\n+\n+        @Override\n+        public boolean isNew() {\n+            return true; // Since we never update balances and use a natural ID, avoid Hibernate querying before insert\n+        }\n+\n+        @Data\n+        @AllArgsConstructor\n+        @NoArgsConstructor\n+        @Embeddable\n+        public static class Id implements Serializable {\n+\n+            private static final long serialVersionUID = 1416544357338674260L;\n+\n+            private long consensusTimestamp;\n+\n+            @Convert(converter = TokenIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId tokenId;\n+\n+            @Convert(converter = AccountIdConverter.class)\n+            @JsonSerialize(using = EntityIdSerializer.class)\n+            private EntityId accountId;\n+        }\n+    }\n+```\n+\n+\n+-   Add `Token` class to hold Token specific metadata outside of the base entity\n+```java\n+    public class Token {\n+        private EntityId tokenId;\n+        private String token;\n+        private Long initialSupply;\n+        private Long  divisibility;\n+        @Convert(converter = AccountIdConverter.class)\n+        private EntityId treasuryId;\n+        private byte[] kycKey;\n+        private byte[] freezeKey;\n+        private byte[] wipeKey;\n+        private byte[] supplyKey;\n+        private boolean freezeDefault;\n+        private boolean kycDefault;\n+    }\n+```\n+\n+### Balance Parsing\n+To support HTS the balance CSV adds a version comment to the file, comments the Timestamp and adds a `accountMetadata` column which is a binary representation of `TokenRelationship`.\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,accountMetadata`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first few headers lines of the CSV\n+    -   If the first line is TimeStamp use `BalanceFileReaderImplV1` as the reader\n+    -   If the first line is `# version:2`, and 2nd line is `# TimeStamp` then use `BalanceFileReaderImplV2` as the reader\n+    -   If no `version` and `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenRelationship`\n+```java\n+    private static final String INSERT_TOKEN_BALANCE_STATEMENT = \"insert into token_balance \" +\n+                \"(consensus_timestamp, account_id, token_id, balance) values (?, ?, ?, ?) on conflict do \" +\n+                \"nothing;\";\n+```\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenTransactTransactionsHandler`\n+-   Add `TokenFreezeAccountTransactionsHandler`\n+-   Add `TokenUnfreezeAccountTransactionsHandler`\n+-   Add `TokenGrantKycToAccountTransactionsHandler`\n+-   Add `TokenRevokeKycFromAccountTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenAccountWipeTransactionsHandler`\n+\n+\n+### Token Transfer Parsing\n+\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+\n+-   Modify `OnItem()` to check for `TransactionBody.hasTokenCreation()`\n+-   Add `insertTokenCreateTransferList()` and `insertTokenTransferList()` to parse out `txRecord.getTokenTransferListsList()`. Create a new CryptoTransfer object for each `TokenTransferList` item and pass it to `entityListener.onCryptoTransfer()`. Also, pull out `tokenID` from `TokenTransferList.token`\n+-   Add `insertTransfer()` that can be shared for `TransferList` and `TokenTransferList`\n+```java\n+    private void insertTransfer(long consensusTimestamp, AccountAmount aa, EntityId account, EntityId tokenId) {\n+        entityListener.onEntityId(account);\n+        entityListener.onCryptoTransfer(new CryptoTransfer(consensusTimestamp, aa.getAmount(), account, tokenId));\n+    }\n+```\n+-   Add `insertTokenTransferList()` to handle `TokenTransferList` returned by `txRecord.getTokenTransferListsList()`\n+-   Update `insertTransferList(...)` to utilize `insertTransfer` and set defaults for `tokenId` and `token`\n+\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `accounts` REST API must be updated to support `tokenBalances`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `transactions` REST API must be updated to support `tokenTransfers`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<token>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<token>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"tokenBalances\": [\n+            {\n+              \"token\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"token\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+To achieve this\n+-   Update `accounts.js` `getAccountss()` to add an additional join to pull the `balance` column where `account_id` matches between tables `token_balance` and `t_entities`, assign each row to an element of `tokenBalances`. `token` can be retrieved with additional join from `token` table or by a caching mechanism for `tokenId` -> `token` mapping\n+\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"tokenBalances\": []", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg1MDAxOA=="}, "originalCommit": {"oid": "50c3cd0fcb93eb78476f370e089704ee734118b3"}, "originalPosition": 401}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1OTMzOTc3", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#pullrequestreview-495933977", "createdAt": "2020-09-24T20:39:33Z", "commit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMDozOTozM1rOHXr0Dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMDozOTozM1rOHXr0Dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU5NzEzNQ==", "bodyText": "Missing URL format. Can probably remove this code related line.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494597135", "createdAt": "2020-09-24T20:39:33Z", "author": {"login": "steven-sheehy"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,631 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members\n+    -   `account_id`\n+    -   `amount`\n+    -   `consensus_timestamp`\n+    -   `token_id`\n+-   Add a `token_transfer__token_account_timestamp` index with `desc` order on columns\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances with the following columns\n+    -   `consensus_timestamp`\n+    -   `account_id`\n+    -   `balance`\n+    -   `token_id`\n+-   Create primary key as combination of `consensus_timestamp`, `token_id` and `account_id`\n+\n+### Token Account Info\n+-   Create `token_account` table to distinctly capture token account metadata changes with the following columns\n+    -   `id` (primary key)\n+    -   `account_id`\n+    -   `create_timestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modify_timestamp`\n+    -   `token_id`\n+    -   `wiped`\n+-   Create unique index `token_account__token_account`\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with `id` value of 5 and `name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+         (28, 'UNCHECKEDSUBMIT'),\n+         (29, 'TOKENCREATE'),\n+         (30, 'TOKENTRANSFER'),\n+         (31, 'TOKENFREEZE'),\n+         (32, 'TOKENUNFREEZE'),\n+         (33, 'TOKENGRANTKYC'),\n+         (34, 'TOKENREVOKEKYC'),\n+         (35, 'TOKENDELETE'),\n+         (36, 'TOKENUPDATE'),\n+         (37, 'TOKENMINT'),\n+         (38, 'TOKENBURN'),\n+         (39, 'TOKENWIPE'),\n+         (40, 'TOKENASSOCIATE'),\n+         (41, 'TOKENDISSOCIATE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP'),\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT'),\n+        (188, 'INVALID_KYC_KEY'),\n+        (189, 'INVALID_WIPE_KEY'),\n+        (190, 'INVALID_FREEZE_KEY'),\n+        (191, 'INVALID_SUPPLY_KEY'),\n+        (192, 'TOKEN_NAME_ALREADY_IN_USE'),\n+        (193, 'MISSING_TOKEN_NAME'),\n+        (194, 'TOKEN_NAME_TOO_LONG'),\n+        (195, 'INVALID_WIPING_AMOUNT'),\n+        (196, 'TOKEN_IS_IMMUTABlE'),\n+        (197, 'TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table with the following columns. Table will capture non shared `entity` items, most API calls may not require this information and therefore additional sql joins may be avoided.\n+    -   `token_id` (primary key)\n+    -   `create_timestamp`\n+    -   `divisibility`\n+    -   `freeze_default`\n+    -   `freeze_key`\n+    -   `initial_supply`\n+    -   `kyc_default`\n+    -   `kyc_key`\n+    -   `modify_timestamp`\n+    -   `supply_key`\n+    -   `symbol`\n+    -   `treasury_account_id`\n+    -   `wipe_key`\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+#### AccountBalance\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+#### TokenTransfer\n+-   Create new `TokenTransfer` with the following class members\n+    -   `accountId`\n+    -   `amount`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+#### EntityTypeEnum\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+        ...\n+        TOKEN(5);\n+        ...\n+    }\n+```\n+\n+#### Token\n+-   Add `Token` class to hold Token specific metadata outside of the base entity class with the following class members\n+    -   `createTimestamp`\n+    -   `divisibility`\n+    -   `freezeDefault`\n+    -   `freezeKey`\n+    -   `initialSupply`\n+    -   `kycDefault`\n+    -   `kycKey`\n+    -   `modifyTimestamp`\n+    -   `supplyKey`\n+    -   `symbol`\n+    -   `tokenId`\n+    -   `treasuryAccountId`\n+    -   `wipeKey`\n+\n+#### TokenAccount\n+-   Add `TokenAccount` class with the following class members\n+    -   `id`\n+    -   `accountId`\n+    -   `createTimestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modifyTimestamp`\n+    -   `tokenId`\n+    -   `wiped`\n+\n+#### TokenBalance\n+-   Add `TokenBalance` class with the following class members\n+    -   `accountId`\n+    -   `balance`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+### Balance Parsing\n+To support HTS the balance CSV\n+1. Adds a version comment as the first line of the file i.e. `# version:2`\n+2. Comments out the Timestamp e.g. `TimeStamp:2020-09-22T04:25:00.083212003Z`\n+3. Adds a `tokenBalances` column which is the Base64 encoding of the serialized bytes of `TokenBalances` proto.\n+\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,tokenBalances`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first line of the CSV\n+    -   If `TimeStamp` is matched use `BalanceFileReaderImplV1` as the reader\n+    -   If `# version:2` is matched use `BalanceFileReaderImplV2` as the reader\n+    -   If no `# version:2` or `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenBalance` in the `TokenBalances`\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to set Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenTransferTransactionsHandler`\n+-   Add `TokenFreezeTransactionsHandler`\n+-   Add `TokenUnfreezeTransactionsHandler`\n+-   Add `TokenGrantKycTransactionsHandler`\n+-   Add `TokenRevokeKycTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to update Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenWipeTransactionsHandler`\n+-   Add `TokenAssociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenDissociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+\n+\n+### Token Transfer Parsing\n+\n+#### EntityListener\n+-   Add a `onToken()` to handle create and updates on the `token` table\n+```java\n+    default void onToken(Token token) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenAccount()` to handle inserts and updates on the `token_account` table\n+```java\n+    default void onTokenAccount(TokenAccount tokenAccount) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenTransfer()` to handle a `token_transfer` table\n+```java\n+    default void onTokenTransfer(TokenTransfer tokenTransfer) throws ImporterException {\n+    }\n+```\n+\n+#### EntityRecordItemListener\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+Add logic to check for\n+-   `TransactionBody.hasTokenCreation()` and parse `TokenCreateTransactionBody` out from the record. Create a new `Token` object and pass it to `entityListener.onToken()`.\n+-   `TransactionBody.hasTokenTransfers()` and parse `TokenTransferLists` out from the record. Create a new `TokenTransfer` object for each `AccountAmount` in the `TokenTransferList` object and pass it to `entityListener.onTokenTransfer()`.\n+-   `TransactionBody.hasTokenAssociate()` and parse `TokenAssociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenDissociate()` and parse `TokenDissociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenFreeze()` and parse `TokenFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUnfreeze()` and parse `TokenUnFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenGrantKyc()` and parse `TokenGrantKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenRevokeKyc()` and parse `TokenRevokeKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenWipe()` and parse `TokenWipeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `wipe` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUpdate()` and parse `TokenUpdateTransactionBody` out from the record. Retrieve an existing `Token` db entry, update the appropriate columns and pass it to `entityListener.onToken()`.\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `transactions` REST API must be updated to support `tokenTransfers`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `accounts` REST API must be updated to support `tokenBalances`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<symbol>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<symbol>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"token_balances\": [\n+            {\n+              \"symbol\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"symbol\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"token_balances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"token_balances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"token_balances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"symbol\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"transfers\": [\n+                {\n+                  \"account\": \"0.0.1111\",\n+                  \"amount\": -10,\n+                  \"symbol\": \"FOOBAR\"\n+                },\n+                {\n+                  \"account\": \"0.0.2222\",\n+                  \"amount\": 10,\n+                  \"symbol\": \"FOOBAR\"\n+                }\n+              ]\n+            },\n+            {\n+              \"transfers\": [\n+                {\n+                  \"account\": \"0.0.3333\",\n+                  \"amount\": -10,\n+                  \"symbol\":\"FOOCOIN\"\n+                },\n+                {\n+                  \"account\": \"0.0.4444\",\n+                  \"amount\": 10,\n+                  \"symbol\":\"FOOCOIN\"\n+                }\n+               ]\n+            }\n+          ]\n+        }\n+      ]\n+    }\n+```\n+\n+### Token Supply distribution\n+\n+`/api/v1/tokens/<symbol>/balances` this could be the equivalent of `/api/v1/balances?symbol=<symbol>` currently and would return a list of account and the token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.15.10\",\n+            \"balance\": 100\n+          },\n+          {\n+            \"account\": \"0.15.9\",\n+            \"balance\": 90\n+          },\n+          {\n+            \"account\": \"0.15.8\",\n+            \"balance\": 80\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens/<symbol>/balances?id=0.0.1000`\n+-   `/api/v1/tokens/<symbol>/balances?balance=gt:1000`\n+-   `/api/v1/tokens/<symbol>/balances?timestamp=1566562500.040961001`\n+\n+### Token Discovery\n+`/api/v1/tokens` this would return all tokens present on the network\n+\n+```json\n+    {\n+        \"tokens\": [\n+          {\n+            \"symbol\": \"FOOBAR\",\n+            \"token_id\": \"0.15.10\",\n+            \"admin_key\": {\n+              \"_type\": \"ProtobufEncoded\",\n+              \"key\": \"7b2233222c2233222c2233227d\"\n+            }\n+          },\n+          {\n+            \"symbol\": \"FOOCOIN\",\n+            \"tokenId\": \"0.15.11\",\n+            \"admin_key\": {\n+              \"_type\": \"ProtobufEncoded\",\n+              \"key\": \"9c2233222c2233222c2233227d\"\n+            }\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens?publickey=3c3d546321ff6f63d701d2ec5c277095874e19f4a235bee1e6bb19258bf362be` - All tokens with matching admin key\n+-   `/api/v1/tokens?account.id=0.0.8` - All tokens for matching account\n+\n+### Token Info\n+-   Add a `getTokenInfo()` to `tokens.js` to retrieve token info from `token` table", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "originalPosition": 536}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1OTQwNzAw", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#pullrequestreview-495940700", "createdAt": "2020-09-24T20:50:07Z", "commit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMDo1MDowN1rOHXsI6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMDo1MToyNlrOHXsLdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYwMjQ3Mw==", "bodyText": "Returns should be tokenId.\nToken API would be the place where both can be returned", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494602473", "createdAt": "2020-09-24T20:50:07Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,631 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members\n+    -   `account_id`\n+    -   `amount`\n+    -   `consensus_timestamp`\n+    -   `token_id`\n+-   Add a `token_transfer__token_account_timestamp` index with `desc` order on columns\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances with the following columns\n+    -   `consensus_timestamp`\n+    -   `account_id`\n+    -   `balance`\n+    -   `token_id`\n+-   Create primary key as combination of `consensus_timestamp`, `token_id` and `account_id`\n+\n+### Token Account Info\n+-   Create `token_account` table to distinctly capture token account metadata changes with the following columns\n+    -   `id` (primary key)\n+    -   `account_id`\n+    -   `create_timestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modify_timestamp`\n+    -   `token_id`\n+    -   `wiped`\n+-   Create unique index `token_account__token_account`\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with `id` value of 5 and `name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+         (28, 'UNCHECKEDSUBMIT'),\n+         (29, 'TOKENCREATE'),\n+         (30, 'TOKENTRANSFER'),\n+         (31, 'TOKENFREEZE'),\n+         (32, 'TOKENUNFREEZE'),\n+         (33, 'TOKENGRANTKYC'),\n+         (34, 'TOKENREVOKEKYC'),\n+         (35, 'TOKENDELETE'),\n+         (36, 'TOKENUPDATE'),\n+         (37, 'TOKENMINT'),\n+         (38, 'TOKENBURN'),\n+         (39, 'TOKENWIPE'),\n+         (40, 'TOKENASSOCIATE'),\n+         (41, 'TOKENDISSOCIATE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP'),\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT'),\n+        (188, 'INVALID_KYC_KEY'),\n+        (189, 'INVALID_WIPE_KEY'),\n+        (190, 'INVALID_FREEZE_KEY'),\n+        (191, 'INVALID_SUPPLY_KEY'),\n+        (192, 'TOKEN_NAME_ALREADY_IN_USE'),\n+        (193, 'MISSING_TOKEN_NAME'),\n+        (194, 'TOKEN_NAME_TOO_LONG'),\n+        (195, 'INVALID_WIPING_AMOUNT'),\n+        (196, 'TOKEN_IS_IMMUTABlE'),\n+        (197, 'TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table with the following columns. Table will capture non shared `entity` items, most API calls may not require this information and therefore additional sql joins may be avoided.\n+    -   `token_id` (primary key)\n+    -   `create_timestamp`\n+    -   `divisibility`\n+    -   `freeze_default`\n+    -   `freeze_key`\n+    -   `initial_supply`\n+    -   `kyc_default`\n+    -   `kyc_key`\n+    -   `modify_timestamp`\n+    -   `supply_key`\n+    -   `symbol`\n+    -   `treasury_account_id`\n+    -   `wipe_key`\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+#### AccountBalance\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+#### TokenTransfer\n+-   Create new `TokenTransfer` with the following class members\n+    -   `accountId`\n+    -   `amount`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+#### EntityTypeEnum\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+        ...\n+        TOKEN(5);\n+        ...\n+    }\n+```\n+\n+#### Token\n+-   Add `Token` class to hold Token specific metadata outside of the base entity class with the following class members\n+    -   `createTimestamp`\n+    -   `divisibility`\n+    -   `freezeDefault`\n+    -   `freezeKey`\n+    -   `initialSupply`\n+    -   `kycDefault`\n+    -   `kycKey`\n+    -   `modifyTimestamp`\n+    -   `supplyKey`\n+    -   `symbol`\n+    -   `tokenId`\n+    -   `treasuryAccountId`\n+    -   `wipeKey`\n+\n+#### TokenAccount\n+-   Add `TokenAccount` class with the following class members\n+    -   `id`\n+    -   `accountId`\n+    -   `createTimestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modifyTimestamp`\n+    -   `tokenId`\n+    -   `wiped`\n+\n+#### TokenBalance\n+-   Add `TokenBalance` class with the following class members\n+    -   `accountId`\n+    -   `balance`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+### Balance Parsing\n+To support HTS the balance CSV\n+1. Adds a version comment as the first line of the file i.e. `# version:2`\n+2. Comments out the Timestamp e.g. `TimeStamp:2020-09-22T04:25:00.083212003Z`\n+3. Adds a `tokenBalances` column which is the Base64 encoding of the serialized bytes of `TokenBalances` proto.\n+\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,tokenBalances`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first line of the CSV\n+    -   If `TimeStamp` is matched use `BalanceFileReaderImplV1` as the reader\n+    -   If `# version:2` is matched use `BalanceFileReaderImplV2` as the reader\n+    -   If no `# version:2` or `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenBalance` in the `TokenBalances`\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to set Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenTransferTransactionsHandler`\n+-   Add `TokenFreezeTransactionsHandler`\n+-   Add `TokenUnfreezeTransactionsHandler`\n+-   Add `TokenGrantKycTransactionsHandler`\n+-   Add `TokenRevokeKycTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to update Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenWipeTransactionsHandler`\n+-   Add `TokenAssociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenDissociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+\n+\n+### Token Transfer Parsing\n+\n+#### EntityListener\n+-   Add a `onToken()` to handle create and updates on the `token` table\n+```java\n+    default void onToken(Token token) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenAccount()` to handle inserts and updates on the `token_account` table\n+```java\n+    default void onTokenAccount(TokenAccount tokenAccount) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenTransfer()` to handle a `token_transfer` table\n+```java\n+    default void onTokenTransfer(TokenTransfer tokenTransfer) throws ImporterException {\n+    }\n+```\n+\n+#### EntityRecordItemListener\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+Add logic to check for\n+-   `TransactionBody.hasTokenCreation()` and parse `TokenCreateTransactionBody` out from the record. Create a new `Token` object and pass it to `entityListener.onToken()`.\n+-   `TransactionBody.hasTokenTransfers()` and parse `TokenTransferLists` out from the record. Create a new `TokenTransfer` object for each `AccountAmount` in the `TokenTransferList` object and pass it to `entityListener.onTokenTransfer()`.\n+-   `TransactionBody.hasTokenAssociate()` and parse `TokenAssociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenDissociate()` and parse `TokenDissociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenFreeze()` and parse `TokenFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUnfreeze()` and parse `TokenUnFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenGrantKyc()` and parse `TokenGrantKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenRevokeKyc()` and parse `TokenRevokeKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenWipe()` and parse `TokenWipeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `wipe` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUpdate()` and parse `TokenUpdateTransactionBody` out from the record. Retrieve an existing `Token` db entry, update the appropriate columns and pass it to `entityListener.onToken()`.\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `transactions` REST API must be updated to support `tokenTransfers`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `accounts` REST API must be updated to support `tokenBalances`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<symbol>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<symbol>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"token_balances\": [\n+            {\n+              \"symbol\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"symbol\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"token_balances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"token_balances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"token_balances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"symbol\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"transfers\": [\n+                {\n+                  \"account\": \"0.0.1111\",\n+                  \"amount\": -10,\n+                  \"symbol\": \"FOOBAR\"\n+                },\n+                {\n+                  \"account\": \"0.0.2222\",\n+                  \"amount\": 10,\n+                  \"symbol\": \"FOOBAR\"\n+                }\n+              ]\n+            },\n+            {\n+              \"transfers\": [\n+                {\n+                  \"account\": \"0.0.3333\",\n+                  \"amount\": -10,\n+                  \"symbol\":\"FOOCOIN\"\n+                },\n+                {\n+                  \"account\": \"0.0.4444\",\n+                  \"amount\": 10,\n+                  \"symbol\":\"FOOCOIN\"\n+                }\n+               ]\n+            }\n+          ]\n+        }\n+      ]\n+    }\n+```\n+\n+### Token Supply distribution\n+\n+`/api/v1/tokens/<symbol>/balances` this could be the equivalent of `/api/v1/balances?symbol=<symbol>` currently and would return a list of account and the token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.15.10\",\n+            \"balance\": 100\n+          },\n+          {\n+            \"account\": \"0.15.9\",\n+            \"balance\": 90\n+          },\n+          {\n+            \"account\": \"0.15.8\",\n+            \"balance\": 80\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens/<symbol>/balances?id=0.0.1000`\n+-   `/api/v1/tokens/<symbol>/balances?balance=gt:1000`\n+-   `/api/v1/tokens/<symbol>/balances?timestamp=1566562500.040961001`\n+\n+### Token Discovery\n+`/api/v1/tokens` this would return all tokens present on the network\n+\n+```json\n+    {\n+        \"tokens\": [\n+          {\n+            \"symbol\": \"FOOBAR\",\n+            \"token_id\": \"0.15.10\",\n+            \"admin_key\": {\n+              \"_type\": \"ProtobufEncoded\",\n+              \"key\": \"7b2233222c2233222c2233227d\"\n+            }\n+          },\n+          {\n+            \"symbol\": \"FOOCOIN\",\n+            \"tokenId\": \"0.15.11\",\n+            \"admin_key\": {\n+              \"_type\": \"ProtobufEncoded\",\n+              \"key\": \"9c2233222c2233222c2233227d\"\n+            }\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens?publickey=3c3d546321ff6f63d701d2ec5c277095874e19f4a235bee1e6bb19258bf362be` - All tokens with matching admin key\n+-   `/api/v1/tokens?account.id=0.0.8` - All tokens for matching account\n+\n+### Token Info\n+-   Add a `getTokenInfo()` to `tokens.js` to retrieve token info from `token` table\n+```json\n+    {\n+      \"symbol\": \"FOOCOIN\",\n+      \"token_id\": \"0.15.10\",\n+      \"treasury_account\": \"0.15.10\",\n+      \"admin_key\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"kyc_key\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"freeze_key\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"wipe_key\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"supply_key\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"freeze_default\": false,\n+      \"kyc_default\": false,\n+      \"expiry_timestamp\": null,\n+      \"auto_renew_account\": \"0.0.6\",\n+      \"auto_renew_period\": null\n+    }\n+```\n+\n+\n+## Protobuf\n+- Add a `TokenQuery` proto message to describe query format\n+- Add a `TokenResponse` proto message to describe response\n+- Add `TokenService` rpc endpoints as needed based on desired `tokenId` and `accountId` combinations\n+\n+\n+## GRPC API\n+\n+### Controller\n+-   Add a `TokenController` class that extends protobuf reactor stubs and implements service rpc endpoints\n+\n+### Domain\n+\n+-   Add `TokenTransfer` class as defined in Importer\n+-   Add `TokenTransferFilter` with similar design to `TopicMessageFilter`\n+-   Update `EntityType` with `TOKEN` option\n+```java\n+    package com.hedera.mirror.grpc.domain;\n+\n+    public enum EntityType {\n+\n+        UNKNOWN, // Filler value to offset next values by one to match database values\n+        ACCOUNT,\n+        CONTRACT,\n+        FILE,\n+        TOPIC,\n+        TOKEN\n+    }\n+```\n+\n+### Streaming : Listener & Retriever\n+The GRPC module currently supports listen and retrieval logic for incoming and historic topic messages respectively.\n+A lot of this logic can be shared for the equivalent `TokenTransfer` listeners and retriever\n+\n+TBD\n+\n+### Token Transfer Service\n+TBD\n+> _Note:_ ***Sequence diagram to be added\n+\n+\n+## Non-Functional Requirements\n+\n+## Open Questions\n+-   [x] What's the maximum character size of the token `symbol` string\n+    -   A: Max length is currently 100 chars to match memo, https://github.com/hashgraph/hedera-services/blob/separate-tokenrels-fcm/hedera-node/src/main/resources/bootstrap.properties#L56\n+-   [x] Will a `token_id` and `token` be assigned a default value for HBARs across the network e.g. i.e. '1' and 'HBAR' respectively\n+    -   A: Currently no since hbar is not treated as an entity like tokens will be.\n+-   [x] Should token only entity items exist in their own table or be added to `t_entities`?\n+    -   A: Will split out into `token` table\n+-   [x] Should `account_balance` `accountNum` and `accountRealmNum` be migrated into `entityId` or should token_balance also use `accountNum` and `accountRealmNum` instead of `entityId`?\n+    -   A: Should be migrated to use `account_id` only\n+-   [ ] What filter options should be provided for new Token API's\n+-   [x] How should frozen account and kyc'd account for a token be represented?\n+    -   A: As columns in `token` table\n+-   [ ] Should balance returns for `accounts`, `balances` and `transactions` contain `token` or `tokenId` or both?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "originalPosition": 626}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYwMzEyNA==", "bodyText": "Provide parity with /accounts and /balances APIs where applicable i.e. filtering on accountId, tokenId and publicKey", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494603124", "createdAt": "2020-09-24T20:51:26Z", "author": {"login": "Nana-EC"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,631 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members\n+    -   `account_id`\n+    -   `amount`\n+    -   `consensus_timestamp`\n+    -   `token_id`\n+-   Add a `token_transfer__token_account_timestamp` index with `desc` order on columns\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances with the following columns\n+    -   `consensus_timestamp`\n+    -   `account_id`\n+    -   `balance`\n+    -   `token_id`\n+-   Create primary key as combination of `consensus_timestamp`, `token_id` and `account_id`\n+\n+### Token Account Info\n+-   Create `token_account` table to distinctly capture token account metadata changes with the following columns\n+    -   `id` (primary key)\n+    -   `account_id`\n+    -   `create_timestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modify_timestamp`\n+    -   `token_id`\n+    -   `wiped`\n+-   Create unique index `token_account__token_account`\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with `id` value of 5 and `name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+         (28, 'UNCHECKEDSUBMIT'),\n+         (29, 'TOKENCREATE'),\n+         (30, 'TOKENTRANSFER'),\n+         (31, 'TOKENFREEZE'),\n+         (32, 'TOKENUNFREEZE'),\n+         (33, 'TOKENGRANTKYC'),\n+         (34, 'TOKENREVOKEKYC'),\n+         (35, 'TOKENDELETE'),\n+         (36, 'TOKENUPDATE'),\n+         (37, 'TOKENMINT'),\n+         (38, 'TOKENBURN'),\n+         (39, 'TOKENWIPE'),\n+         (40, 'TOKENASSOCIATE'),\n+         (41, 'TOKENDISSOCIATE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP'),\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT'),\n+        (188, 'INVALID_KYC_KEY'),\n+        (189, 'INVALID_WIPE_KEY'),\n+        (190, 'INVALID_FREEZE_KEY'),\n+        (191, 'INVALID_SUPPLY_KEY'),\n+        (192, 'TOKEN_NAME_ALREADY_IN_USE'),\n+        (193, 'MISSING_TOKEN_NAME'),\n+        (194, 'TOKEN_NAME_TOO_LONG'),\n+        (195, 'INVALID_WIPING_AMOUNT'),\n+        (196, 'TOKEN_IS_IMMUTABlE'),\n+        (197, 'TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table with the following columns. Table will capture non shared `entity` items, most API calls may not require this information and therefore additional sql joins may be avoided.\n+    -   `token_id` (primary key)\n+    -   `create_timestamp`\n+    -   `divisibility`\n+    -   `freeze_default`\n+    -   `freeze_key`\n+    -   `initial_supply`\n+    -   `kyc_default`\n+    -   `kyc_key`\n+    -   `modify_timestamp`\n+    -   `supply_key`\n+    -   `symbol`\n+    -   `treasury_account_id`\n+    -   `wipe_key`\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+#### AccountBalance\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+#### TokenTransfer\n+-   Create new `TokenTransfer` with the following class members\n+    -   `accountId`\n+    -   `amount`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+#### EntityTypeEnum\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+        ...\n+        TOKEN(5);\n+        ...\n+    }\n+```\n+\n+#### Token\n+-   Add `Token` class to hold Token specific metadata outside of the base entity class with the following class members\n+    -   `createTimestamp`\n+    -   `divisibility`\n+    -   `freezeDefault`\n+    -   `freezeKey`\n+    -   `initialSupply`\n+    -   `kycDefault`\n+    -   `kycKey`\n+    -   `modifyTimestamp`\n+    -   `supplyKey`\n+    -   `symbol`\n+    -   `tokenId`\n+    -   `treasuryAccountId`\n+    -   `wipeKey`\n+\n+#### TokenAccount\n+-   Add `TokenAccount` class with the following class members\n+    -   `id`\n+    -   `accountId`\n+    -   `createTimestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modifyTimestamp`\n+    -   `tokenId`\n+    -   `wiped`\n+\n+#### TokenBalance\n+-   Add `TokenBalance` class with the following class members\n+    -   `accountId`\n+    -   `balance`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+### Balance Parsing\n+To support HTS the balance CSV\n+1. Adds a version comment as the first line of the file i.e. `# version:2`\n+2. Comments out the Timestamp e.g. `TimeStamp:2020-09-22T04:25:00.083212003Z`\n+3. Adds a `tokenBalances` column which is the Base64 encoding of the serialized bytes of `TokenBalances` proto.\n+\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,tokenBalances`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first line of the CSV\n+    -   If `TimeStamp` is matched use `BalanceFileReaderImplV1` as the reader\n+    -   If `# version:2` is matched use `BalanceFileReaderImplV2` as the reader\n+    -   If no `# version:2` or `Timestamp` found throw an `InvalidDatasetException`\n+-   Add `INSERT_TOKEN_BALANCE_STATEMENT` in `AccountBalancesFileLoader` to persist each `TokenBalance` in the `TokenBalances`\n+-   Update `AccountBalancesFileLoader.loadAccountBalances()` to handle new `tokenBalances` member in `AccountBalance` returned by stream. Add logic to use `INSERT_TOKEN_BALANCE_STATEMENT` for every `tokenBalance` if not null;\n+\n+### Transaction Handlers\n+Additional handlers will be needed to support the added Token transaction types.\n+In all cases override `getEntity()`, pulling entity info from appropriate transactionBody\n+\n+-   Add `TokenCreateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to set Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenTransferTransactionsHandler`\n+-   Add `TokenFreezeTransactionsHandler`\n+-   Add `TokenUnfreezeTransactionsHandler`\n+-   Add `TokenGrantKycTransactionsHandler`\n+-   Add `TokenRevokeKycTransactionsHandler`\n+-   Add `TokenDeleteTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenUpdateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+    -   override `updateEntity()` to update Entities `key`, `expiryTimeNs` and `AutoRenewPeriod` if applicable\n+-   Add `TokenMintTransactionsHandler`\n+-   Add `TokenBurnTransactionsHandler`\n+-   Add `TokenWipeTransactionsHandler`\n+-   Add `TokenAssociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+-   Add `TokenDissociateTransactionsHandler`\n+    -   override `updatesEntity()` to return true\n+\n+\n+### Token Transfer Parsing\n+\n+#### EntityListener\n+-   Add a `onToken()` to handle create and updates on the `token` table\n+```java\n+    default void onToken(Token token) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenAccount()` to handle inserts and updates on the `token_account` table\n+```java\n+    default void onTokenAccount(TokenAccount tokenAccount) throws ImporterException {\n+    }\n+```\n+\n+-   Add a `onTokenTransfer()` to handle a `token_transfer` table\n+```java\n+    default void onTokenTransfer(TokenTransfer tokenTransfer) throws ImporterException {\n+    }\n+```\n+\n+#### EntityRecordItemListener\n+Modify `EntityRecordItemListener` to handle parsing HTS transactions\n+Add logic to check for\n+-   `TransactionBody.hasTokenCreation()` and parse `TokenCreateTransactionBody` out from the record. Create a new `Token` object and pass it to `entityListener.onToken()`.\n+-   `TransactionBody.hasTokenTransfers()` and parse `TokenTransferLists` out from the record. Create a new `TokenTransfer` object for each `AccountAmount` in the `TokenTransferList` object and pass it to `entityListener.onTokenTransfer()`.\n+-   `TransactionBody.hasTokenAssociate()` and parse `TokenAssociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenDissociate()` and parse `TokenDissociateBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `associate` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenFreeze()` and parse `TokenFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUnfreeze()` and parse `TokenUnFreezeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `frozen` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenGrantKyc()` and parse `TokenGrantKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenRevokeKyc()` and parse `TokenRevokeKycTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `kyc` column to false and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenWipe()` and parse `TokenWipeAccountTransactionBody` out from the record. Retrieve an existing `TokenAccount` db entry, set the `wipe` column to true and pass it to `entityListener.onTokenAccount()`.\n+-   `TransactionBody.hasTokenUpdate()` and parse `TokenUpdateTransactionBody` out from the record. Retrieve an existing `Token` db entry, update the appropriate columns and pass it to `entityListener.onToken()`.\n+\n+## REST API\n+To achieve the goals and for easy integration with existing users the REST API should be updated in the following order\n+1.  The `transactions` REST API must be updated to support `tokenTransfers`\n+2.  The `balances` REST API must be updated to support `tokenBalances`\n+3.  The `accounts` REST API must be updated to support `tokenBalances`\n+4.  Add a Token Supply distribution REST API to show token distribution across accounts - `/api/v1/tokens/<symbol>/balances`\n+5.  Add a Token Discovery REST API to show available tokens on the network - `/api/v1/tokens`\n+6.  Add a Token Info REST API to show details for a token on the network - `/api/v1/tokens/<symbol>`\n+\n+### Accounts Endpoint\n+-   Update `/api/v1/accounts` response to add token balances\n+```json\n+{\n+    \"accounts\": [\n+      {\n+        \"balance\": {\n+          \"timestamp\": \"0.000002345\",\n+          \"balance\": 80,\n+          \"token_balances\": [\n+            {\n+              \"symbol\": \"FOOBAR\",\n+              \"balance\": 80\n+            },\n+            {\n+              \"symbol\": \"FOOCOIN\",\n+              \"balance\": 50\n+            }\n+          ]\n+        },\n+        \"account\": \"0.0.8\",\n+        \"expiry_timestamp\": null,\n+        \"auto_renew_period\": null,\n+        \"key\": null,\n+        \"deleted\": false\n+      }\n+    ],\n+    \"links\": {\n+      \"next\": null\n+    }\n+  }\n+```\n+\n+### Balances Endpoint\n+-   Update `/api/v1/balances` response to add token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.0.8\",\n+            \"balance\": 100,\n+            \"token_balances\": []\n+          },\n+          {\n+            \"account\": \"0.0.10\",\n+            \"balance\": 100,\n+            \"token_balances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              }\n+            ]\n+          },\n+          {\n+            \"account\": \"0.0.13\",\n+            \"balance\": 100,\n+            \"token_balances\": [\n+              {\n+                \"symbol\": \"FOOBAR\",\n+                \"balance\": 80\n+              },\n+              {\n+                \"symbol\": \"FOOCOIN\",\n+                \"balance\": 50\n+              }\n+            ]\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+### Transactions Endpoint\n+-   Update `/api/v1/transactions` response to add token transfers\n+```json\n+    {\n+      \"transactions\": [\n+        {\n+          \"consensus_timestamp\": \"1234567890.000000001\",\n+          \"valid_start_timestamp\": \"1234567890.000000000\",\n+          \"charged_tx_fee\": 7,\n+          \"memo_base64\": null,\n+          \"result\": \"SUCCESS\",\n+          \"transaction_hash\": \"aGFzaA==\",\n+          \"name\": \"CRYPTOTRANSFER\",\n+          \"node\": \"0.0.3\",\n+          \"transaction_id\": \"0.0.10-1234567890-000000000\",\n+          \"valid_duration_seconds\": \"11\",\n+          \"max_fee\": \"33\",\n+          \"transfers\": [\n+            {\n+              \"account\": \"0.0.9\",\n+              \"amount\": 10\n+            },\n+            {\n+              \"account\": \"0.0.10\",\n+              \"amount\": -11\n+            },\n+            {\n+              \"account\": \"0.0.98\",\n+              \"amount\": 1\n+            }\n+          ],\n+          \"token_transfers\": [\n+            {\n+              \"transfers\": [\n+                {\n+                  \"account\": \"0.0.1111\",\n+                  \"amount\": -10,\n+                  \"symbol\": \"FOOBAR\"\n+                },\n+                {\n+                  \"account\": \"0.0.2222\",\n+                  \"amount\": 10,\n+                  \"symbol\": \"FOOBAR\"\n+                }\n+              ]\n+            },\n+            {\n+              \"transfers\": [\n+                {\n+                  \"account\": \"0.0.3333\",\n+                  \"amount\": -10,\n+                  \"symbol\":\"FOOCOIN\"\n+                },\n+                {\n+                  \"account\": \"0.0.4444\",\n+                  \"amount\": 10,\n+                  \"symbol\":\"FOOCOIN\"\n+                }\n+               ]\n+            }\n+          ]\n+        }\n+      ]\n+    }\n+```\n+\n+### Token Supply distribution\n+\n+`/api/v1/tokens/<symbol>/balances` this could be the equivalent of `/api/v1/balances?symbol=<symbol>` currently and would return a list of account and the token balances\n+```json\n+    {\n+        \"timestamp\": \"0.000002345\",\n+        \"balances\": [\n+          {\n+            \"account\": \"0.15.10\",\n+            \"balance\": 100\n+          },\n+          {\n+            \"account\": \"0.15.9\",\n+            \"balance\": 90\n+          },\n+          {\n+            \"account\": \"0.15.8\",\n+            \"balance\": 80\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens/<symbol>/balances?id=0.0.1000`\n+-   `/api/v1/tokens/<symbol>/balances?balance=gt:1000`\n+-   `/api/v1/tokens/<symbol>/balances?timestamp=1566562500.040961001`\n+\n+### Token Discovery\n+`/api/v1/tokens` this would return all tokens present on the network\n+\n+```json\n+    {\n+        \"tokens\": [\n+          {\n+            \"symbol\": \"FOOBAR\",\n+            \"token_id\": \"0.15.10\",\n+            \"admin_key\": {\n+              \"_type\": \"ProtobufEncoded\",\n+              \"key\": \"7b2233222c2233222c2233227d\"\n+            }\n+          },\n+          {\n+            \"symbol\": \"FOOCOIN\",\n+            \"tokenId\": \"0.15.11\",\n+            \"admin_key\": {\n+              \"_type\": \"ProtobufEncoded\",\n+              \"key\": \"9c2233222c2233222c2233227d\"\n+            }\n+          }\n+        ],\n+        \"links\": {\n+          \"next\": null\n+        }\n+    }\n+```\n+\n+Optional Filters\n+-   `/api/v1/tokens?publickey=3c3d546321ff6f63d701d2ec5c277095874e19f4a235bee1e6bb19258bf362be` - All tokens with matching admin key\n+-   `/api/v1/tokens?account.id=0.0.8` - All tokens for matching account\n+\n+### Token Info\n+-   Add a `getTokenInfo()` to `tokens.js` to retrieve token info from `token` table\n+```json\n+    {\n+      \"symbol\": \"FOOCOIN\",\n+      \"token_id\": \"0.15.10\",\n+      \"treasury_account\": \"0.15.10\",\n+      \"admin_key\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"kyc_key\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"freeze_key\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"wipe_key\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"supply_key\": {\n+        \"_type\": \"ProtobufEncoded\",\n+        \"key\": \"9c2233222c2233222c2233227d\"\n+      },\n+      \"freeze_default\": false,\n+      \"kyc_default\": false,\n+      \"expiry_timestamp\": null,\n+      \"auto_renew_account\": \"0.0.6\",\n+      \"auto_renew_period\": null\n+    }\n+```\n+\n+\n+## Protobuf\n+- Add a `TokenQuery` proto message to describe query format\n+- Add a `TokenResponse` proto message to describe response\n+- Add `TokenService` rpc endpoints as needed based on desired `tokenId` and `accountId` combinations\n+\n+\n+## GRPC API\n+\n+### Controller\n+-   Add a `TokenController` class that extends protobuf reactor stubs and implements service rpc endpoints\n+\n+### Domain\n+\n+-   Add `TokenTransfer` class as defined in Importer\n+-   Add `TokenTransferFilter` with similar design to `TopicMessageFilter`\n+-   Update `EntityType` with `TOKEN` option\n+```java\n+    package com.hedera.mirror.grpc.domain;\n+\n+    public enum EntityType {\n+\n+        UNKNOWN, // Filler value to offset next values by one to match database values\n+        ACCOUNT,\n+        CONTRACT,\n+        FILE,\n+        TOPIC,\n+        TOKEN\n+    }\n+```\n+\n+### Streaming : Listener & Retriever\n+The GRPC module currently supports listen and retrieval logic for incoming and historic topic messages respectively.\n+A lot of this logic can be shared for the equivalent `TokenTransfer` listeners and retriever\n+\n+TBD\n+\n+### Token Transfer Service\n+TBD\n+> _Note:_ ***Sequence diagram to be added\n+\n+\n+## Non-Functional Requirements\n+\n+## Open Questions\n+-   [x] What's the maximum character size of the token `symbol` string\n+    -   A: Max length is currently 100 chars to match memo, https://github.com/hashgraph/hedera-services/blob/separate-tokenrels-fcm/hedera-node/src/main/resources/bootstrap.properties#L56\n+-   [x] Will a `token_id` and `token` be assigned a default value for HBARs across the network e.g. i.e. '1' and 'HBAR' respectively\n+    -   A: Currently no since hbar is not treated as an entity like tokens will be.\n+-   [x] Should token only entity items exist in their own table or be added to `t_entities`?\n+    -   A: Will split out into `token` table\n+-   [x] Should `account_balance` `accountNum` and `accountRealmNum` be migrated into `entityId` or should token_balance also use `accountNum` and `accountRealmNum` instead of `entityId`?\n+    -   A: Should be migrated to use `account_id` only\n+-   [ ] What filter options should be provided for new Token API's", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "originalPosition": 623}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1OTQ0MDI4", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#pullrequestreview-495944028", "createdAt": "2020-09-24T20:55:20Z", "commit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMDo1NToyMFrOHXsTRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMDo1NToyMFrOHXsTRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYwNTEyNw==", "bodyText": "Do we still want the parser to be lenient on the number of lines before the timestamp/version number?  Looks like right now allow the timestamp to be up to 10 lines deep, so long as the column headers don't come up first.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r494605127", "createdAt": "2020-09-24T20:55:20Z", "author": {"login": "ijungmann"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,631 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members\n+    -   `account_id`\n+    -   `amount`\n+    -   `consensus_timestamp`\n+    -   `token_id`\n+-   Add a `token_transfer__token_account_timestamp` index with `desc` order on columns\n+\n+### Token Balance\n+-   Create `token_balance` table to distinctly capture token balances with the following columns\n+    -   `consensus_timestamp`\n+    -   `account_id`\n+    -   `balance`\n+    -   `token_id`\n+-   Create primary key as combination of `consensus_timestamp`, `token_id` and `account_id`\n+\n+### Token Account Info\n+-   Create `token_account` table to distinctly capture token account metadata changes with the following columns\n+    -   `id` (primary key)\n+    -   `account_id`\n+    -   `create_timestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modify_timestamp`\n+    -   `token_id`\n+    -   `wiped`\n+-   Create unique index `token_account__token_account`\n+\n+> _Note:_  `frozen` and `kyc` are set by `TokenCreation.freezeDefault` and `TokenCreation.kycDefault` respectively\n+\n+### Entity Types\n+-   Add new `t_entity_types` row with `id` value of 5 and `name `token`\n+```sql\n+    insert into t_entity_types (id, name) values (5, 'token');\n+```\n+\n+### Transaction Types\n+-   Add new `t_transaction_types`:\n+```sql\n+    insert into t_transaction_types (proto_id, name) values\n+         (28, 'UNCHECKEDSUBMIT'),\n+         (29, 'TOKENCREATE'),\n+         (30, 'TOKENTRANSFER'),\n+         (31, 'TOKENFREEZE'),\n+         (32, 'TOKENUNFREEZE'),\n+         (33, 'TOKENGRANTKYC'),\n+         (34, 'TOKENREVOKEKYC'),\n+         (35, 'TOKENDELETE'),\n+         (36, 'TOKENUPDATE'),\n+         (37, 'TOKENMINT'),\n+         (38, 'TOKENBURN'),\n+         (39, 'TOKENWIPE'),\n+         (40, 'TOKENASSOCIATE'),\n+         (41, 'TOKENDISSOCIATE');\n+```\n+\n+### Transaction Results\n+-   Add new `t_transaction_result`:\n+```sql\n+    insert into t_transaction_results (proto_id, result) values\n+        (165, 'ACCOUNT_FROZEN_FOR_TOKEN'),\n+        (166, 'TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED'),\n+        (167, 'INVALID_TOKEN_ID'),\n+        (168, 'INVALID_TOKEN_DIVISIBILITY'),\n+        (169, 'INVALID_TOKEN_FLOAT'),\n+        (170, 'INVALID_TREASURY_ACCOUNT_FOR_TOKEN'),\n+        (171, 'INVALID_TOKEN_SYMBOL'),\n+        (172, 'TOKEN_HAS_NO_FREEZE_KEY'),\n+        (173, 'TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN'),\n+        (174, 'MISSING_TOKEN_SYMBOL'),\n+        (175, 'TOKEN_SYMBOL_TOO_LONG'),\n+        (176, 'TOKEN_SYMBOL_ALREADY_IN_USE'),\n+        (177, 'INVALID_TOKEN_REF'),\n+        (178, 'ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN'),\n+        (179, 'TOKEN_HAS_NO_KYC_KEY'),\n+        (180, 'INSUFFICIENT_TOKEN_BALANCE'),\n+        (181, 'TOKEN_WAS_DELETED'),\n+        (182, 'TOKEN_HAS_NO_SUPPLY_KEY'),\n+        (183, 'TOKEN_HAS_NO_WIPE_KEY'),\n+        (184, 'INVALID_TOKEN_MINT_AMOUNT'),\n+        (185, 'INVALID_TOKEN_BURN_AMOUNT'),\n+        (186, 'ACCOUNT_HAS_NO_TOKEN_RELATIONSHIP'),\n+        (187, 'CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT'),\n+        (188, 'INVALID_KYC_KEY'),\n+        (189, 'INVALID_WIPE_KEY'),\n+        (190, 'INVALID_FREEZE_KEY'),\n+        (191, 'INVALID_SUPPLY_KEY'),\n+        (192, 'TOKEN_NAME_ALREADY_IN_USE'),\n+        (193, 'MISSING_TOKEN_NAME'),\n+        (194, 'TOKEN_NAME_TOO_LONG'),\n+        (195, 'INVALID_WIPING_AMOUNT'),\n+        (196, 'TOKEN_IS_IMMUTABlE'),\n+        (197, 'TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT');\n+```\n+\n+### Entities\n+-   Insert token entity info into `t_entities` table from `TokenCreation.proto` transaction object. Insert `adminKey` as `key`, `expiry` as `exp_time_ns`, `autoRenewAccount` as `auto_renew_account_id` and `autoRenewPeriod` as `auto_renew_period`.\n+\n+### Token\n+-   Create `token` table with the following columns. Table will capture non shared `entity` items, most API calls may not require this information and therefore additional sql joins may be avoided.\n+    -   `token_id` (primary key)\n+    -   `create_timestamp`\n+    -   `divisibility`\n+    -   `freeze_default`\n+    -   `freeze_key`\n+    -   `initial_supply`\n+    -   `kyc_default`\n+    -   `kyc_key`\n+    -   `modify_timestamp`\n+    -   `supply_key`\n+    -   `symbol`\n+    -   `treasury_account_id`\n+    -   `wipe_key`\n+\n+## Importer\n+\n+### Converter\n+-   Add a `TokenIdConverter`\n+```java\n+    package com.hedera.mirror.importer.converter;\n+    ...\n+    public class TokenIdConverter extends AbstractEntityIdConverter {\n+\n+        public TokenIdConverter() {\n+            super(EntityTypeEnum.TOKEN);\n+        }\n+    }\n+```\n+\n+### Domain\n+\n+#### AccountBalance\n+-   Update `AccountBalance` to have a `tokenBalances` class member, to represent all the token balances of the account\n+```java\n+public class AccountBalance implements Persistable<AccountBalance.Id> {\n+    ...\n+    private List<TokenBalance> tokenBalances;\n+    ...\n+}\n+```\n+\n+#### TokenTransfer\n+-   Create new `TokenTransfer` with the following class members\n+    -   `accountId`\n+    -   `amount`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+#### EntityTypeEnum\n+-   Update `EntityTypeEnum` with `Token` type\n+```java\n+    public enum EntityTypeEnum {\n+        ...\n+        TOKEN(5);\n+        ...\n+    }\n+```\n+\n+#### Token\n+-   Add `Token` class to hold Token specific metadata outside of the base entity class with the following class members\n+    -   `createTimestamp`\n+    -   `divisibility`\n+    -   `freezeDefault`\n+    -   `freezeKey`\n+    -   `initialSupply`\n+    -   `kycDefault`\n+    -   `kycKey`\n+    -   `modifyTimestamp`\n+    -   `supplyKey`\n+    -   `symbol`\n+    -   `tokenId`\n+    -   `treasuryAccountId`\n+    -   `wipeKey`\n+\n+#### TokenAccount\n+-   Add `TokenAccount` class with the following class members\n+    -   `id`\n+    -   `accountId`\n+    -   `createTimestamp`\n+    -   `frozen`\n+    -   `kyc`\n+    -   `modifyTimestamp`\n+    -   `tokenId`\n+    -   `wiped`\n+\n+#### TokenBalance\n+-   Add `TokenBalance` class with the following class members\n+    -   `accountId`\n+    -   `balance`\n+    -   `consensusTimestamp`\n+    -   `tokenId`\n+\n+### Balance Parsing\n+To support HTS the balance CSV\n+1. Adds a version comment as the first line of the file i.e. `# version:2`\n+2. Comments out the Timestamp e.g. `TimeStamp:2020-09-22T04:25:00.083212003Z`\n+3. Adds a `tokenBalances` column which is the Base64 encoding of the serialized bytes of `TokenBalances` proto.\n+\n+To allow the mirror node to support both V1 and V2 balance files\n+-   Rename `BalanceFileReaderImpl` to `BalanceFileReaderImplV1`\n+-   Add a `BalanceFileReaderImplV2` class to parse `shardNum,realmNum,accountNum,balance,tokenBalances`.  Reader should set `tokenBalances` in `AccountBalance`.\n+-   Add a `CompositeBalanceFileReader` that implements `BalanceFileReader` and reads the first line of the CSV", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "120032b165d4c9b8cb29bd1546ec791ff4d728e9"}, "originalPosition": 253}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9daa0d28ac57abfd7789d80aeaf5621d2dcb5f4d", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/9daa0d28ac57abfd7789d80aeaf5621d2dcb5f4d", "committedDate": "2020-09-25T03:20:29Z", "message": "Cleaned up and made some corrections\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f16fc0a511b59e0d6e3d7bff7e3022fe53605cd", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/0f16fc0a511b59e0d6e3d7bff7e3022fe53605cd", "committedDate": "2020-09-25T23:25:40Z", "message": "Fixed transaction rest api response\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2OTExNDk5", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#pullrequestreview-496911499", "createdAt": "2020-09-25T23:27:16Z", "commit": {"oid": "0f16fc0a511b59e0d6e3d7bff7e3022fe53605cd"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2OTE2NjQy", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#pullrequestreview-496916642", "createdAt": "2020-09-25T23:53:57Z", "commit": {"oid": "0f16fc0a511b59e0d6e3d7bff7e3022fe53605cd"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQyMzo1Mzo1N1rOHYYYBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQyMzo1NDozN1rOHYYZFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMyNzIzOQ==", "bodyText": "nit: in the following order", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r495327239", "createdAt": "2020-09-25T23:53:57Z", "author": {"login": "xin-hedera"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,630 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f16fc0a511b59e0d6e3d7bff7e3022fe53605cd"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMyNzUwOQ==", "bodyText": "nit:\nAdd token_transfer table with the following columns", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#discussion_r495327509", "createdAt": "2020-09-25T23:54:37Z", "author": {"login": "xin-hedera"}, "path": "docs/design/hts.md", "diffHunk": "@@ -0,0 +1,630 @@\n+# Hedera Token Service Design\n+\n+## Purpose\n+\n+The Hedera Token Service (HTS) builds upon the Cryptocurrency Service to provide decentralized issuance of custom tokens on the Hedera Network.\n+The behavior will be similar to that of the native HBAR token and as such the Mirror Node will persist token balances and transfer lists and support the retrieval of information through its APIs.\n+\n+This document highlights the architecture and design changes to be made to support HTS.\n+Changes should be applied in order of the following order to support easy third party integration.\n+1.  Database Schema Updates\n+2.  Importer Updates for Ingestion - Token balance and token transactions\n+3.  Existing REST API Updates - Accounts, Balances and Transactions\n+4.  Token REST API additions\n+5.  Protobuf update for TokenService\n+6.  GRPC Token Service addition\n+\n+## Goals\n+-   Ingest HTS Token transactions from record stream rcd files from the mainnet and persist information to the database\n+-   Ingest account token balances from balance stream CSV files from the mainnet and persist to the database\n+-   Expose token balance of accounts in existing REST APIs that show balance\n+-   Provide a HTS REST API to return all tokens (Token Discovery)\n+-   Provide a HTS REST API to return all accounts holding a specific token (Token Supply Distribution)\n+-   Provide a streaming GRPC API to subscribe to token transfers for an account\n+\n+## Non Goals\n+-   Provide a streaming GRPC API to subscribe to HTS transfers for all accounts and/or all tokens\n+\n+## Architecture\n+\n+![Architecture](images/hts-architecture.png)\n+\n+1. Downloader retrieves transactions and balances (HBAR & Tokens) from stream files in cloud bucket and validates them\n+2. Parser persists to database\n+3. Client queries balance or token APIs for details\n+4. REST API retrieves token details and balances from database\n+5. Client subscribes to GRPC API for token transfers\n+6. GRPC API retrieves token transfers from database and returns to client\n+7. GRPC API is notified of new token transfers via database streaming logic\n+\n+## Alternatives\n+\n+## Database\n+To support the goals the following database schema changes should be made\n+1. `t_entity_types` updated to represent new `TOKEN` entity\n+2. `t_transaction_types` updated to handle token transactions from network.\n+3. New `token_balance` table added to persist token only balances\n+4. New `token` table added to capture token specific entity properties\n+5. New `token_transfer` table to persist token transfers\n+6. `t_transaction_results` updated to handle token transactions results from network.\n+7.  New `token_account` table added to persist token specific account state\n+\n+### Token Transfer\n+-   Add `token_transfer` table table. with the following class members", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f16fc0a511b59e0d6e3d7bff7e3022fe53605cd"}, "originalPosition": 53}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fcb3bf700276b012fa19b2d39c13abd4d1dfd732", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/fcb3bf700276b012fa19b2d39c13abd4d1dfd732", "committedDate": "2020-09-26T01:14:21Z", "message": "Final cleanup\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2OTMyMzk1", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1061#pullrequestreview-496932395", "createdAt": "2020-09-26T02:22:50Z", "commit": {"oid": "fcb3bf700276b012fa19b2d39c13abd4d1dfd732"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3539, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}