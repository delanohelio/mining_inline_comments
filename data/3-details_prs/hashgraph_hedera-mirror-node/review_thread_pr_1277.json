{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIyNTQ5NDI1", "number": 1277, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxNzowMDo0MFrOE6HsUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNzowMToyN1rOE7JsIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5Mzc4ODk3OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/domain/TopicMessage.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxNzowMDo0MFrOH0_Y1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMjowODo1M1rOH1NfGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMyNjU0OQ==", "bodyText": "Fix issue that TopicMessage.toResponse does not properly cache the protobuf response\n\nBoth the old and new approach properly cache the response. Both the old and the new approach can potentially call consensusTopicResponseBuilder.build() multiple times for the same object. Only difference is that now only one thread will win the transition from null to populated. I don't think that really buys us anything as it's still doing the same amount of work.\nWe should consider switching to @Getter(lazy=true) as it uses double checked locking and may be more what you're looking for while at the same time being cleaner than using AtomicReference.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1277#discussion_r525326549", "createdAt": "2020-11-17T17:00:40Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/domain/TopicMessage.java", "diffHunk": "@@ -110,7 +110,11 @@\n \n     // Cache this to avoid paying the conversion penalty for multiple subscribers to the same topic\n     public ConsensusTopicResponse toResponse() {\n-        if (response.get() == null) {\n+        return response.updateAndGet(response -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae24d1350cee7dac7490ea507b34c92dc649b0eb"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1NTY4NA==", "bodyText": "yes you are right, thought AtomicReference.updateAndGet performs locking.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1277#discussion_r525555684", "createdAt": "2020-11-17T22:05:14Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/domain/TopicMessage.java", "diffHunk": "@@ -110,7 +110,11 @@\n \n     // Cache this to avoid paying the conversion penalty for multiple subscribers to the same topic\n     public ConsensusTopicResponse toResponse() {\n-        if (response.get() == null) {\n+        return response.updateAndGet(response -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMyNjU0OQ=="}, "originalCommit": {"oid": "ae24d1350cee7dac7490ea507b34c92dc649b0eb"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1NzUzMQ==", "bodyText": "It doesn't lock, it just does a compare and set in a loop", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1277#discussion_r525557531", "createdAt": "2020-11-17T22:08:53Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/domain/TopicMessage.java", "diffHunk": "@@ -110,7 +110,11 @@\n \n     // Cache this to avoid paying the conversion penalty for multiple subscribers to the same topic\n     public ConsensusTopicResponse toResponse() {\n-        if (response.get() == null) {\n+        return response.updateAndGet(response -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMyNjU0OQ=="}, "originalCommit": {"oid": "ae24d1350cee7dac7490ea507b34c92dc649b0eb"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MzgwNTk2OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/controller/ConsensusController.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxNzowNDoxMFrOH0_jjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMjowNToyOVrOH1NYaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMyOTI5NA==", "bodyText": "unknownError() can probably be subsumed into this method and its instanceof check removed since that was only needed due to the semantics of the generic onErrorMap().", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1277#discussion_r525329294", "createdAt": "2020-11-17T17:04:10Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/controller/ConsensusController.java", "diffHunk": "@@ -105,6 +97,28 @@ private TopicMessageFilter toFilter(ConsensusTopicQuery query) {\n         return builder.build();\n     }\n \n+    private Throwable mapError(Throwable t) {\n+        if (t instanceof ConstraintViolationException) {\n+            return error(t, Status.INVALID_ARGUMENT);\n+        } else if (t instanceof IllegalArgumentException) {\n+            return error(t, Status.INVALID_ARGUMENT);\n+        } else if (t instanceof NonTransientDataAccessResourceException) {\n+            return error(t, Status.UNAVAILABLE, DB_ERROR);\n+        } else if (t instanceof TimeoutException) {\n+            return error(t, Status.RESOURCE_EXHAUSTED);\n+        } else if (t instanceof TopicNotFoundException) {\n+            return error(t, Status.NOT_FOUND);\n+        } else if (t instanceof TransientDataAccessException) {\n+            return error(t, Status.RESOURCE_EXHAUSTED);\n+        } else if (Exceptions.isOverflow(t)) {\n+            return error(t, Status.DEADLINE_EXCEEDED, OVERFLOW_ERROR);\n+        } else if (t instanceof ClientTimeoutException) {\n+            return error(t, Status.DEADLINE_EXCEEDED, OVERFLOW_ERROR);\n+        }\n+\n+        return unknownError(t);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae24d1350cee7dac7490ea507b34c92dc649b0eb"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1NTgxNg==", "bodyText": "sure, will update it", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1277#discussion_r525555816", "createdAt": "2020-11-17T22:05:29Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/controller/ConsensusController.java", "diffHunk": "@@ -105,6 +97,28 @@ private TopicMessageFilter toFilter(ConsensusTopicQuery query) {\n         return builder.build();\n     }\n \n+    private Throwable mapError(Throwable t) {\n+        if (t instanceof ConstraintViolationException) {\n+            return error(t, Status.INVALID_ARGUMENT);\n+        } else if (t instanceof IllegalArgumentException) {\n+            return error(t, Status.INVALID_ARGUMENT);\n+        } else if (t instanceof NonTransientDataAccessResourceException) {\n+            return error(t, Status.UNAVAILABLE, DB_ERROR);\n+        } else if (t instanceof TimeoutException) {\n+            return error(t, Status.RESOURCE_EXHAUSTED);\n+        } else if (t instanceof TopicNotFoundException) {\n+            return error(t, Status.NOT_FOUND);\n+        } else if (t instanceof TransientDataAccessException) {\n+            return error(t, Status.RESOURCE_EXHAUSTED);\n+        } else if (Exceptions.isOverflow(t)) {\n+            return error(t, Status.DEADLINE_EXCEEDED, OVERFLOW_ERROR);\n+        } else if (t instanceof ClientTimeoutException) {\n+            return error(t, Status.DEADLINE_EXCEEDED, OVERFLOW_ERROR);\n+        }\n+\n+        return unknownError(t);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMyOTI5NA=="}, "originalCommit": {"oid": "ae24d1350cee7dac7490ea507b34c92dc649b0eb"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5Mzg1NTMzOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/controller/ConsensusController.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxNzoxMjozNFrOH1AC_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMjowNTo0MFrOH1NY0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMzNzM0Mw==", "bodyText": "Should probably take advantage of the new format and combine these two since they return the same value. Same for deadline exceeded below.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1277#discussion_r525337343", "createdAt": "2020-11-17T17:12:34Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/controller/ConsensusController.java", "diffHunk": "@@ -105,6 +97,28 @@ private TopicMessageFilter toFilter(ConsensusTopicQuery query) {\n         return builder.build();\n     }\n \n+    private Throwable mapError(Throwable t) {\n+        if (t instanceof ConstraintViolationException) {\n+            return error(t, Status.INVALID_ARGUMENT);\n+        } else if (t instanceof IllegalArgumentException) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5dc58cf600420ccbc36cf69a5ebd6d5b85218e32"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1NTkyMg==", "bodyText": "sure", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1277#discussion_r525555922", "createdAt": "2020-11-17T22:05:40Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/controller/ConsensusController.java", "diffHunk": "@@ -105,6 +97,28 @@ private TopicMessageFilter toFilter(ConsensusTopicQuery query) {\n         return builder.build();\n     }\n \n+    private Throwable mapError(Throwable t) {\n+        if (t instanceof ConstraintViolationException) {\n+            return error(t, Status.INVALID_ARGUMENT);\n+        } else if (t instanceof IllegalArgumentException) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMzNzM0Mw=="}, "originalCommit": {"oid": "5dc58cf600420ccbc36cf69a5ebd6d5b85218e32"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5Mzg2MjA1OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/listener/ListenerProperties.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxNzoxMzo1OFrOH1AHGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxNzoxMzo1OFrOH1AHGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMzODM5Mg==", "bodyText": "Please update the docs with any changes.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1277#discussion_r525338392", "createdAt": "2020-11-17T17:13:58Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/listener/ListenerProperties.java", "diffHunk": "@@ -35,24 +35,28 @@\n @ConfigurationProperties(\"hedera.mirror.grpc.listener\")\n public class ListenerProperties {\n \n-    private boolean enabled = true;\n+    @DurationMin(seconds = 2)\n+    @DurationMax(seconds = 10)\n+    @NotNull\n+    private Duration bufferTimeout = Duration.ofSeconds(4);\n \n-    @Min(32)\n-    private int maxPageSize = 5000;\n+    private boolean enabled = true;\n \n     @Min(8192)\n     @Max(65536)\n     private int maxBufferSize = 16384;\n \n-    @DurationMin(seconds = 2)\n-    @DurationMax(seconds = 10)\n-    @NotNull\n-    private Duration bufferTimeout = Duration.ofSeconds(4);\n+    @Min(32)\n+    private int maxPageSize = 5000;\n \n     @DurationMin(millis = 50)\n     @NotNull\n     private Duration frequency = Duration.ofMillis(500L);\n \n+    @Min(1)\n+    @Max(256)\n+    private int prefetch = 48;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5dc58cf600420ccbc36cf69a5ebd6d5b85218e32"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MzkwMTQxOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-monitor/src/test/java/com/hedera/mirror/monitor/generator/CompositeTransactionGeneratorTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxNzoyMjoxN1rOH1AfTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwMTo0Mjo0NVrOH2JQFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM0NDU5MA==", "bodyText": "While this provides a more accurate sampling, this might be slow to generate. Have you timed this change?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1277#discussion_r525344590", "createdAt": "2020-11-17T17:22:17Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-monitor/src/test/java/com/hedera/mirror/monitor/generator/CompositeTransactionGeneratorTest.java", "diffHunk": "@@ -69,7 +69,7 @@ void distribution() {\n                 .containsExactly(0.75, 0.25);\n \n         Multiset<TransactionType> types = HashMultiset.create();\n-        for (int i = 0; i < 100; ++i) {\n+        for (int i = 0; i < 10000; ++i) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b36e2afb86dc469a81a61667b1f32bbc6dae31fe"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1NjcwMQ==", "bodyText": "the time cost is roughly the same, around 1 sec, since I also bumped the tps for the two scenarios to 7500.0 and 2500.0", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1277#discussion_r525556701", "createdAt": "2020-11-17T22:07:08Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-monitor/src/test/java/com/hedera/mirror/monitor/generator/CompositeTransactionGeneratorTest.java", "diffHunk": "@@ -69,7 +69,7 @@ void distribution() {\n                 .containsExactly(0.75, 0.25);\n \n         Multiset<TransactionType> types = HashMultiset.create();\n-        for (int i = 0; i < 100; ++i) {\n+        for (int i = 0; i < 10000; ++i) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM0NDU5MA=="}, "originalCommit": {"oid": "b36e2afb86dc469a81a61667b1f32bbc6dae31fe"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUzNjcyNg==", "bodyText": "Got it", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1277#discussion_r526536726", "createdAt": "2020-11-19T01:42:45Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-monitor/src/test/java/com/hedera/mirror/monitor/generator/CompositeTransactionGeneratorTest.java", "diffHunk": "@@ -69,7 +69,7 @@ void distribution() {\n                 .containsExactly(0.75, 0.25);\n \n         Multiset<TransactionType> types = HashMultiset.create();\n-        for (int i = 0; i < 100; ++i) {\n+        for (int i = 0; i < 10000; ++i) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM0NDU5MA=="}, "originalCommit": {"oid": "b36e2afb86dc469a81a61667b1f32bbc6dae31fe"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MzkzODIxOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/listener/SharedTopicListener.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxNzozMDo1MVrOH1A1lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxNzozMDo1MVrOH1A1lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM1MDI5NQ==", "bodyText": "Replace the 3 calls with doFinally().", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1277#discussion_r525350295", "createdAt": "2020-11-17T17:30:51Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/listener/SharedTopicListener.java", "diffHunk": "@@ -40,19 +48,71 @@\n \n     @Override\n     public Flux<TopicMessage> listen(TopicMessageFilter filter) {\n-        UnicastProcessor<String> processor = UnicastProcessor.create();\n-        Flux<String> timeoutFlux = processor.delayElements(listenerProperties.getBufferTimeout())\n-                .replay(1)\n-                .autoConnect();\n+        TimeoutContext timeoutContext = new TimeoutContext(Schedulers.parallel(),\n+                listenerProperties.getBufferTimeout());\n+        Mono<TopicMessage> timeoutMono = Mono.create(timeoutContext);\n \n-        return getSharedListener(filter)\n-                .publishOn(Schedulers.boundedElastic())\n+        Flux<TopicMessage> topicMessageFlux = getSharedListener(filter)\n                 .doOnSubscribe(s -> log.info(\"Subscribing: {}\", filter))\n-                .doOnCancel(() -> processor.onNext(\"timeout\"))\n+                .doOnCancel(timeoutContext::onCancel)\n                 .onBackpressureBuffer(listenerProperties.getMaxBufferSize())\n-                .timeout(timeoutFlux, message -> timeoutFlux, Mono.error(\n-                        new ClientTimeoutException(\"Client timed out while consuming the buffered messages\")));\n+                .doOnCancel(timeoutContext::onComplete)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b36e2afb86dc469a81a61667b1f32bbc6dae31fe"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5Mzk4ODY3OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/listener/SharedTopicListener.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxNzo0MjoyOVrOH1BURg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMjowMjo1NFrOH1NTGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM1ODE1MA==", "bodyText": "nit: You've noted before that the flux operation chaining can be unclear and is also the locations where most optimizations happen.\nMight be useful to add some comments overall on the topicMessageFlux to help manage the overhead costs in the future.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1277#discussion_r525358150", "createdAt": "2020-11-17T17:42:29Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/listener/SharedTopicListener.java", "diffHunk": "@@ -40,19 +48,71 @@\n \n     @Override\n     public Flux<TopicMessage> listen(TopicMessageFilter filter) {\n-        UnicastProcessor<String> processor = UnicastProcessor.create();\n-        Flux<String> timeoutFlux = processor.delayElements(listenerProperties.getBufferTimeout())\n-                .replay(1)\n-                .autoConnect();\n+        TimeoutContext timeoutContext = new TimeoutContext(Schedulers.parallel(),\n+                listenerProperties.getBufferTimeout());\n+        Mono<TopicMessage> timeoutMono = Mono.create(timeoutContext);\n \n-        return getSharedListener(filter)\n-                .publishOn(Schedulers.boundedElastic())\n+        Flux<TopicMessage> topicMessageFlux = getSharedListener(filter)\n                 .doOnSubscribe(s -> log.info(\"Subscribing: {}\", filter))\n-                .doOnCancel(() -> processor.onNext(\"timeout\"))\n+                .doOnCancel(timeoutContext::onCancel)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b36e2afb86dc469a81a61667b1f32bbc6dae31fe"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1NDQ1Ng==", "bodyText": "sure, I'll add some appropriate comment", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1277#discussion_r525554456", "createdAt": "2020-11-17T22:02:54Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/listener/SharedTopicListener.java", "diffHunk": "@@ -40,19 +48,71 @@\n \n     @Override\n     public Flux<TopicMessage> listen(TopicMessageFilter filter) {\n-        UnicastProcessor<String> processor = UnicastProcessor.create();\n-        Flux<String> timeoutFlux = processor.delayElements(listenerProperties.getBufferTimeout())\n-                .replay(1)\n-                .autoConnect();\n+        TimeoutContext timeoutContext = new TimeoutContext(Schedulers.parallel(),\n+                listenerProperties.getBufferTimeout());\n+        Mono<TopicMessage> timeoutMono = Mono.create(timeoutContext);\n \n-        return getSharedListener(filter)\n-                .publishOn(Schedulers.boundedElastic())\n+        Flux<TopicMessage> topicMessageFlux = getSharedListener(filter)\n                 .doOnSubscribe(s -> log.info(\"Subscribing: {}\", filter))\n-                .doOnCancel(() -> processor.onNext(\"timeout\"))\n+                .doOnCancel(timeoutContext::onCancel)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM1ODE1MA=="}, "originalCommit": {"oid": "b36e2afb86dc469a81a61667b1f32bbc6dae31fe"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NDk0OTE5OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/listener/SharedTopicListener.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDo1MzowNlrOH1LBxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMjoyMTozMFrOH1N3lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUxNzI1NQ==", "bodyText": "This is quite a complicated solution for not much gain in functionality. Why do we even care about letting them consume the buffer after they overflow? There's no recovery logic here so we should just fail fast and let the client retry.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1277#discussion_r525517255", "createdAt": "2020-11-17T20:53:06Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/listener/SharedTopicListener.java", "diffHunk": "@@ -40,19 +48,71 @@\n \n     @Override\n     public Flux<TopicMessage> listen(TopicMessageFilter filter) {\n-        UnicastProcessor<String> processor = UnicastProcessor.create();\n-        Flux<String> timeoutFlux = processor.delayElements(listenerProperties.getBufferTimeout())\n-                .replay(1)\n-                .autoConnect();\n+        TimeoutContext timeoutContext = new TimeoutContext(Schedulers.parallel(),\n+                listenerProperties.getBufferTimeout());\n+        Mono<TopicMessage> timeoutMono = Mono.create(timeoutContext);\n \n-        return getSharedListener(filter)\n-                .publishOn(Schedulers.boundedElastic())\n+        Flux<TopicMessage> topicMessageFlux = getSharedListener(filter)\n                 .doOnSubscribe(s -> log.info(\"Subscribing: {}\", filter))\n-                .doOnCancel(() -> processor.onNext(\"timeout\"))\n+                .doOnCancel(timeoutContext::onCancel)\n                 .onBackpressureBuffer(listenerProperties.getMaxBufferSize())\n-                .timeout(timeoutFlux, message -> timeoutFlux, Mono.error(\n-                        new ClientTimeoutException(\"Client timed out while consuming the buffered messages\")));\n+                .doOnCancel(timeoutContext::onComplete)\n+                .doOnError(t -> timeoutContext.onComplete())\n+                .doOnComplete(timeoutContext::onComplete);\n+        return Flux.merge(listenerProperties.getPrefetch(), topicMessageFlux, timeoutMono)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b36e2afb86dc469a81a61667b1f32bbc6dae31fe"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1OTQ1Nw==", "bodyText": "it's for the case that the topic TPS is high, the client is slow and can't catch up, since the backpressure buffer is big, letting the client consume the remaining data then terminating it with either the OverflowException or the ClientTimeoutException would end in a rate higher than 500 the client can get by retry.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1277#discussion_r525559457", "createdAt": "2020-11-17T22:12:38Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/listener/SharedTopicListener.java", "diffHunk": "@@ -40,19 +48,71 @@\n \n     @Override\n     public Flux<TopicMessage> listen(TopicMessageFilter filter) {\n-        UnicastProcessor<String> processor = UnicastProcessor.create();\n-        Flux<String> timeoutFlux = processor.delayElements(listenerProperties.getBufferTimeout())\n-                .replay(1)\n-                .autoConnect();\n+        TimeoutContext timeoutContext = new TimeoutContext(Schedulers.parallel(),\n+                listenerProperties.getBufferTimeout());\n+        Mono<TopicMessage> timeoutMono = Mono.create(timeoutContext);\n \n-        return getSharedListener(filter)\n-                .publishOn(Schedulers.boundedElastic())\n+        Flux<TopicMessage> topicMessageFlux = getSharedListener(filter)\n                 .doOnSubscribe(s -> log.info(\"Subscribing: {}\", filter))\n-                .doOnCancel(() -> processor.onNext(\"timeout\"))\n+                .doOnCancel(timeoutContext::onCancel)\n                 .onBackpressureBuffer(listenerProperties.getMaxBufferSize())\n-                .timeout(timeoutFlux, message -> timeoutFlux, Mono.error(\n-                        new ClientTimeoutException(\"Client timed out while consuming the buffered messages\")));\n+                .doOnCancel(timeoutContext::onComplete)\n+                .doOnError(t -> timeoutContext.onComplete())\n+                .doOnComplete(timeoutContext::onComplete);\n+        return Flux.merge(listenerProperties.getPrefetch(), topicMessageFlux, timeoutMono)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUxNzI1NQ=="}, "originalCommit": {"oid": "b36e2afb86dc469a81a61667b1f32bbc6dae31fe"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU2Mzc5OQ==", "bodyText": "Regardless if we have a buffer timeout or not, the client has to retry right? They can't keep up and the TPS is high. All we're doing is delaying it slightly and give them a little bit higher TPS on the first run but then still slow on the retry anyway. I don't think an extra 2s window provides any value.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1277#discussion_r525563799", "createdAt": "2020-11-17T22:21:30Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/listener/SharedTopicListener.java", "diffHunk": "@@ -40,19 +48,71 @@\n \n     @Override\n     public Flux<TopicMessage> listen(TopicMessageFilter filter) {\n-        UnicastProcessor<String> processor = UnicastProcessor.create();\n-        Flux<String> timeoutFlux = processor.delayElements(listenerProperties.getBufferTimeout())\n-                .replay(1)\n-                .autoConnect();\n+        TimeoutContext timeoutContext = new TimeoutContext(Schedulers.parallel(),\n+                listenerProperties.getBufferTimeout());\n+        Mono<TopicMessage> timeoutMono = Mono.create(timeoutContext);\n \n-        return getSharedListener(filter)\n-                .publishOn(Schedulers.boundedElastic())\n+        Flux<TopicMessage> topicMessageFlux = getSharedListener(filter)\n                 .doOnSubscribe(s -> log.info(\"Subscribing: {}\", filter))\n-                .doOnCancel(() -> processor.onNext(\"timeout\"))\n+                .doOnCancel(timeoutContext::onCancel)\n                 .onBackpressureBuffer(listenerProperties.getMaxBufferSize())\n-                .timeout(timeoutFlux, message -> timeoutFlux, Mono.error(\n-                        new ClientTimeoutException(\"Client timed out while consuming the buffered messages\")));\n+                .doOnCancel(timeoutContext::onComplete)\n+                .doOnError(t -> timeoutContext.onComplete())\n+                .doOnComplete(timeoutContext::onComplete);\n+        return Flux.merge(listenerProperties.getPrefetch(), topicMessageFlux, timeoutMono)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUxNzI1NQ=="}, "originalCommit": {"oid": "b36e2afb86dc469a81a61667b1f32bbc6dae31fe"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NDk2MzkxOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/listener/SharedTopicListener.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMDo1NzoxNVrOH1LKng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNTo1NTowOFrOH2laQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUxOTUxOA==", "bodyText": "Assuming we keep the timeout logic, have you considered using onBackpressureBuffer(int maxSize, Consumer<?> onOverflow) and use the consumer to trigger the wait before error?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1277#discussion_r525519518", "createdAt": "2020-11-17T20:57:15Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/listener/SharedTopicListener.java", "diffHunk": "@@ -40,19 +48,71 @@\n \n     @Override\n     public Flux<TopicMessage> listen(TopicMessageFilter filter) {\n-        UnicastProcessor<String> processor = UnicastProcessor.create();\n-        Flux<String> timeoutFlux = processor.delayElements(listenerProperties.getBufferTimeout())\n-                .replay(1)\n-                .autoConnect();\n+        TimeoutContext timeoutContext = new TimeoutContext(Schedulers.parallel(),\n+                listenerProperties.getBufferTimeout());\n+        Mono<TopicMessage> timeoutMono = Mono.create(timeoutContext);\n \n-        return getSharedListener(filter)\n-                .publishOn(Schedulers.boundedElastic())\n+        Flux<TopicMessage> topicMessageFlux = getSharedListener(filter)\n                 .doOnSubscribe(s -> log.info(\"Subscribing: {}\", filter))\n-                .doOnCancel(() -> processor.onNext(\"timeout\"))\n+                .doOnCancel(timeoutContext::onCancel)\n                 .onBackpressureBuffer(listenerProperties.getMaxBufferSize())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b36e2afb86dc469a81a61667b1f32bbc6dae31fe"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk5ODA4Mw==", "bodyText": "yes this simplifies the logic, thanks", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1277#discussion_r526998083", "createdAt": "2020-11-19T15:55:08Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/listener/SharedTopicListener.java", "diffHunk": "@@ -40,19 +48,71 @@\n \n     @Override\n     public Flux<TopicMessage> listen(TopicMessageFilter filter) {\n-        UnicastProcessor<String> processor = UnicastProcessor.create();\n-        Flux<String> timeoutFlux = processor.delayElements(listenerProperties.getBufferTimeout())\n-                .replay(1)\n-                .autoConnect();\n+        TimeoutContext timeoutContext = new TimeoutContext(Schedulers.parallel(),\n+                listenerProperties.getBufferTimeout());\n+        Mono<TopicMessage> timeoutMono = Mono.create(timeoutContext);\n \n-        return getSharedListener(filter)\n-                .publishOn(Schedulers.boundedElastic())\n+        Flux<TopicMessage> topicMessageFlux = getSharedListener(filter)\n                 .doOnSubscribe(s -> log.info(\"Subscribing: {}\", filter))\n-                .doOnCancel(() -> processor.onNext(\"timeout\"))\n+                .doOnCancel(timeoutContext::onCancel)\n                 .onBackpressureBuffer(listenerProperties.getMaxBufferSize())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUxOTUxOA=="}, "originalCommit": {"oid": "b36e2afb86dc469a81a61667b1f32bbc6dae31fe"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNDMwMTYzOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/controller/ConsensusController.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNTo1NzoyNVrOH2lhvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNzoxMToxMFrOH2o-Vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk5OTk5Nw==", "bodyText": "Technically I don't think we can get this here as everything before this is non-gRPC. It was only there before to catch re-throws from specific exception onErrorMap().", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1277#discussion_r526999997", "createdAt": "2020-11-19T15:57:25Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/controller/ConsensusController.java", "diffHunk": "@@ -105,6 +97,28 @@ private TopicMessageFilter toFilter(ConsensusTopicQuery query) {\n         return builder.build();\n     }\n \n+    private Throwable mapError(Throwable t) {\n+        if (t instanceof ConstraintViolationException || t instanceof IllegalArgumentException) {\n+            return error(t, Status.INVALID_ARGUMENT);\n+        } else if (t instanceof NonTransientDataAccessResourceException) {\n+            return error(t, Status.UNAVAILABLE, DB_ERROR);\n+        } else if (t instanceof TimeoutException) {\n+            return error(t, Status.RESOURCE_EXHAUSTED);\n+        } else if (t instanceof TopicNotFoundException) {\n+            return error(t, Status.NOT_FOUND);\n+        } else if (t instanceof TransientDataAccessException) {\n+            return error(t, Status.RESOURCE_EXHAUSTED);\n+        } else if (Exceptions.isOverflow(t) || t instanceof ClientTimeoutException) {\n+            return error(t, Status.DEADLINE_EXCEEDED, OVERFLOW_ERROR);\n+        } else if (t instanceof StatusRuntimeException) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1dbf35252202021577f574f7ce5cf5e8dfc32875"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA0MzI5Ng==", "bodyText": "yes, will remove it", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1277#discussion_r527043296", "createdAt": "2020-11-19T16:54:37Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/controller/ConsensusController.java", "diffHunk": "@@ -105,6 +97,28 @@ private TopicMessageFilter toFilter(ConsensusTopicQuery query) {\n         return builder.build();\n     }\n \n+    private Throwable mapError(Throwable t) {\n+        if (t instanceof ConstraintViolationException || t instanceof IllegalArgumentException) {\n+            return error(t, Status.INVALID_ARGUMENT);\n+        } else if (t instanceof NonTransientDataAccessResourceException) {\n+            return error(t, Status.UNAVAILABLE, DB_ERROR);\n+        } else if (t instanceof TimeoutException) {\n+            return error(t, Status.RESOURCE_EXHAUSTED);\n+        } else if (t instanceof TopicNotFoundException) {\n+            return error(t, Status.NOT_FOUND);\n+        } else if (t instanceof TransientDataAccessException) {\n+            return error(t, Status.RESOURCE_EXHAUSTED);\n+        } else if (Exceptions.isOverflow(t) || t instanceof ClientTimeoutException) {\n+            return error(t, Status.DEADLINE_EXCEEDED, OVERFLOW_ERROR);\n+        } else if (t instanceof StatusRuntimeException) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk5OTk5Nw=="}, "originalCommit": {"oid": "1dbf35252202021577f574f7ce5cf5e8dfc32875"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA1NjQ3MA==", "bodyText": "have to revert it, since toFilter which is called at the previous step may throw StatusRuntimeException. removing the above code causes test failure", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1277#discussion_r527056470", "createdAt": "2020-11-19T17:11:10Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/controller/ConsensusController.java", "diffHunk": "@@ -105,6 +97,28 @@ private TopicMessageFilter toFilter(ConsensusTopicQuery query) {\n         return builder.build();\n     }\n \n+    private Throwable mapError(Throwable t) {\n+        if (t instanceof ConstraintViolationException || t instanceof IllegalArgumentException) {\n+            return error(t, Status.INVALID_ARGUMENT);\n+        } else if (t instanceof NonTransientDataAccessResourceException) {\n+            return error(t, Status.UNAVAILABLE, DB_ERROR);\n+        } else if (t instanceof TimeoutException) {\n+            return error(t, Status.RESOURCE_EXHAUSTED);\n+        } else if (t instanceof TopicNotFoundException) {\n+            return error(t, Status.NOT_FOUND);\n+        } else if (t instanceof TransientDataAccessException) {\n+            return error(t, Status.RESOURCE_EXHAUSTED);\n+        } else if (Exceptions.isOverflow(t) || t instanceof ClientTimeoutException) {\n+            return error(t, Status.DEADLINE_EXCEEDED, OVERFLOW_ERROR);\n+        } else if (t instanceof StatusRuntimeException) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk5OTk5Nw=="}, "originalCommit": {"oid": "1dbf35252202021577f574f7ce5cf5e8dfc32875"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNDMxNTU2OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/domain/TopicMessage.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNjowMDowOFrOH2lqLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNzoxMToyOVrOH2o_Uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAwMjE1OQ==", "bodyText": "Why do we need this on a @Value object which has no setters by default?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1277#discussion_r527002159", "createdAt": "2020-11-19T16:00:08Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/domain/TopicMessage.java", "diffHunk": "@@ -103,52 +104,48 @@\n     @Transient\n     private Instant validStartInstant = LongToInstantConverter.INSTANCE.convert(validStartTimestamp);\n \n+    // Cache this to avoid paying the conversion penalty for multiple subscribers to the same topic\n     @EqualsAndHashCode.Exclude\n+    @Getter(lazy = true)\n+    @Setter(value = AccessLevel.NONE)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1dbf35252202021577f574f7ce5cf5e8dfc32875"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA0NDY1MA==", "bodyText": "the response is created lazily by a private method, disable the setter can prevent accidental value change.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1277#discussion_r527044650", "createdAt": "2020-11-19T16:56:20Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/domain/TopicMessage.java", "diffHunk": "@@ -103,52 +104,48 @@\n     @Transient\n     private Instant validStartInstant = LongToInstantConverter.INSTANCE.convert(validStartTimestamp);\n \n+    // Cache this to avoid paying the conversion penalty for multiple subscribers to the same topic\n     @EqualsAndHashCode.Exclude\n+    @Getter(lazy = true)\n+    @Setter(value = AccessLevel.NONE)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAwMjE1OQ=="}, "originalCommit": {"oid": "1dbf35252202021577f574f7ce5cf5e8dfc32875"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA1NDA4MA==", "bodyText": "I tested this locally just to confirm. There is no setter with or without the annotation because this is a @Value class. You can confirm what's methods are generated in the IDE structure view.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1277#discussion_r527054080", "createdAt": "2020-11-19T17:07:47Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/domain/TopicMessage.java", "diffHunk": "@@ -103,52 +104,48 @@\n     @Transient\n     private Instant validStartInstant = LongToInstantConverter.INSTANCE.convert(validStartTimestamp);\n \n+    // Cache this to avoid paying the conversion penalty for multiple subscribers to the same topic\n     @EqualsAndHashCode.Exclude\n+    @Getter(lazy = true)\n+    @Setter(value = AccessLevel.NONE)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAwMjE1OQ=="}, "originalCommit": {"oid": "1dbf35252202021577f574f7ce5cf5e8dfc32875"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA1NjcyMw==", "bodyText": "thanks, will remove it then", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1277#discussion_r527056723", "createdAt": "2020-11-19T17:11:29Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/domain/TopicMessage.java", "diffHunk": "@@ -103,52 +104,48 @@\n     @Transient\n     private Instant validStartInstant = LongToInstantConverter.INSTANCE.convert(validStartTimestamp);\n \n+    // Cache this to avoid paying the conversion penalty for multiple subscribers to the same topic\n     @EqualsAndHashCode.Exclude\n+    @Getter(lazy = true)\n+    @Setter(value = AccessLevel.NONE)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAwMjE1OQ=="}, "originalCommit": {"oid": "1dbf35252202021577f574f7ce5cf5e8dfc32875"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNDQ4Mjg0OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/listener/SharedTopicListener.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNjozNjoxOFrOH2nUvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNjo1NjozMVrOH2oQrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAyOTQzOQ==", "bodyText": "As discussed offline, I think we can remove the buffer timeout and just fail fast. This will simplify the logic.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1277#discussion_r527029439", "createdAt": "2020-11-19T16:36:18Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/listener/SharedTopicListener.java", "diffHunk": "@@ -40,19 +47,61 @@\n \n     @Override\n     public Flux<TopicMessage> listen(TopicMessageFilter filter) {\n-        UnicastProcessor<String> processor = UnicastProcessor.create();\n-        Flux<String> timeoutFlux = processor.delayElements(listenerProperties.getBufferTimeout())\n-                .replay(1)\n-                .autoConnect();\n+        TimeoutContext timeoutContext = new TimeoutContext(Schedulers.parallel(),\n+                listenerProperties.getBufferTimeout());\n+        Mono<TopicMessage> timeoutMono = Mono.create(timeoutContext);\n \n-        return getSharedListener(filter)\n-                .publishOn(Schedulers.boundedElastic())\n+        // moving publishOn from after onBackpressureBuffer to after Flux.merge reduces CPU usage by up to 40%\n+        Flux<TopicMessage> topicMessageFlux = getSharedListener(filter)\n                 .doOnSubscribe(s -> log.info(\"Subscribing: {}\", filter))\n-                .doOnCancel(() -> processor.onNext(\"timeout\"))\n-                .onBackpressureBuffer(listenerProperties.getMaxBufferSize())\n-                .timeout(timeoutFlux, message -> timeoutFlux, Mono.error(\n-                        new ClientTimeoutException(\"Client timed out while consuming the buffered messages\")));\n+                .onBackpressureBuffer(listenerProperties.getMaxBufferSize(), t -> timeoutContext.onOverflow())\n+                .doFinally(r -> timeoutContext.onComplete());\n+        return Flux.merge(listenerProperties.getPrefetch(), topicMessageFlux, timeoutMono)\n+                .publishOn(Schedulers.boundedElastic(), false, listenerProperties.getPrefetch());\n     }\n \n     protected abstract Flux<TopicMessage> getSharedListener(TopicMessageFilter filter);\n+\n+    @RequiredArgsConstructor\n+    private class TimeoutContext implements Consumer<MonoSink<TopicMessage>> {\n+\n+        private final Scheduler scheduler;\n+        private final Duration timeout;\n+\n+        private MonoSink<TopicMessage> sink;\n+        private final AtomicBoolean completed = new AtomicBoolean(false);\n+        private volatile Disposable taskDisposer;\n+\n+        @Override\n+        public void accept(MonoSink<TopicMessage> sink) {\n+            this.sink = sink;\n+        }\n+\n+        public void onComplete() {\n+            if (!completed.compareAndSet(false, true)) {\n+                return;\n+            }\n+\n+            if (taskDisposer != null) {\n+                taskDisposer.dispose();\n+                taskDisposer = null;\n+            }\n+\n+            sink.success();\n+        }\n+\n+        public void onOverflow() {\n+            if (completed.get()) {\n+                return;\n+            }\n+\n+            try {\n+                taskDisposer = scheduler.schedule(() -> sink.error(new ClientTimeoutException(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac8c71b47cb5a04315d85c743e0b5fd11e976fda"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA0NDc4Mw==", "bodyText": "removed, now will fail fast", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1277#discussion_r527044783", "createdAt": "2020-11-19T16:56:31Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/listener/SharedTopicListener.java", "diffHunk": "@@ -40,19 +47,61 @@\n \n     @Override\n     public Flux<TopicMessage> listen(TopicMessageFilter filter) {\n-        UnicastProcessor<String> processor = UnicastProcessor.create();\n-        Flux<String> timeoutFlux = processor.delayElements(listenerProperties.getBufferTimeout())\n-                .replay(1)\n-                .autoConnect();\n+        TimeoutContext timeoutContext = new TimeoutContext(Schedulers.parallel(),\n+                listenerProperties.getBufferTimeout());\n+        Mono<TopicMessage> timeoutMono = Mono.create(timeoutContext);\n \n-        return getSharedListener(filter)\n-                .publishOn(Schedulers.boundedElastic())\n+        // moving publishOn from after onBackpressureBuffer to after Flux.merge reduces CPU usage by up to 40%\n+        Flux<TopicMessage> topicMessageFlux = getSharedListener(filter)\n                 .doOnSubscribe(s -> log.info(\"Subscribing: {}\", filter))\n-                .doOnCancel(() -> processor.onNext(\"timeout\"))\n-                .onBackpressureBuffer(listenerProperties.getMaxBufferSize())\n-                .timeout(timeoutFlux, message -> timeoutFlux, Mono.error(\n-                        new ClientTimeoutException(\"Client timed out while consuming the buffered messages\")));\n+                .onBackpressureBuffer(listenerProperties.getMaxBufferSize(), t -> timeoutContext.onOverflow())\n+                .doFinally(r -> timeoutContext.onComplete());\n+        return Flux.merge(listenerProperties.getPrefetch(), topicMessageFlux, timeoutMono)\n+                .publishOn(Schedulers.boundedElastic(), false, listenerProperties.getPrefetch());\n     }\n \n     protected abstract Flux<TopicMessage> getSharedListener(TopicMessageFilter filter);\n+\n+    @RequiredArgsConstructor\n+    private class TimeoutContext implements Consumer<MonoSink<TopicMessage>> {\n+\n+        private final Scheduler scheduler;\n+        private final Duration timeout;\n+\n+        private MonoSink<TopicMessage> sink;\n+        private final AtomicBoolean completed = new AtomicBoolean(false);\n+        private volatile Disposable taskDisposer;\n+\n+        @Override\n+        public void accept(MonoSink<TopicMessage> sink) {\n+            this.sink = sink;\n+        }\n+\n+        public void onComplete() {\n+            if (!completed.compareAndSet(false, true)) {\n+                return;\n+            }\n+\n+            if (taskDisposer != null) {\n+                taskDisposer.dispose();\n+                taskDisposer = null;\n+            }\n+\n+            sink.success();\n+        }\n+\n+        public void onOverflow() {\n+            if (completed.get()) {\n+                return;\n+            }\n+\n+            try {\n+                taskDisposer = scheduler.schedule(() -> sink.error(new ClientTimeoutException(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAyOTQzOQ=="}, "originalCommit": {"oid": "ac8c71b47cb5a04315d85c743e0b5fd11e976fda"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNDYwMTk1OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/controller/ConsensusController.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNzowMToyN1rOH2ofbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNzowMToyN1rOH2ofbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA0ODU1OQ==", "bodyText": "change return type to StatusRuntimeException", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1277#discussion_r527048559", "createdAt": "2020-11-19T17:01:27Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/controller/ConsensusController.java", "diffHunk": "@@ -105,22 +96,32 @@ private TopicMessageFilter toFilter(ConsensusTopicQuery query) {\n         return builder.build();\n     }\n \n-    private Throwable error(Throwable t, Status status) {\n-        return error(t, status, t.getMessage());\n-    }\n-\n-    private Throwable error(Throwable t, Status status, String message) {\n-        log.warn(\"Received {} subscribing to topic: {}\", t.getClass().getSimpleName(), t.getMessage());\n-        return status.augmentDescription(message).asRuntimeException();\n-    }\n-\n-    private Throwable unknownError(Throwable t) {\n-        if (t instanceof StatusRuntimeException) {\n-            return t;\n+    private StatusRuntimeException mapError(Throwable t) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83ea77fcca36d88f35c24a00d08ff35e1600641f"}, "originalPosition": 43}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1436, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}