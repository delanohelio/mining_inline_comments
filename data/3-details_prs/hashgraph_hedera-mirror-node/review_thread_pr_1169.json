{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA4MDkxNjgw", "number": 1169, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMTo1ODo1NFrOExAUdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxODo0NTo0OFrOEyCjdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5ODIwOTE4OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMTo1ODo1NFrOHm5q3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMTo1ODo1NFrOHm5q3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1Mjc5Ng==", "bodyText": "unmarshableTxHash is confusing since:\n\nit should be un-unmarshable\nit's not hash, it's the hex encoded marshaled transaction bytes\n\nsomething like corruptedTxHexStr provides better clarity\nalso have to rename exampleInvalidTxHashConstructionCombineRequest as it looks like copied from the previous test case.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1169#discussion_r510552796", "createdAt": "2020-10-23T01:58:54Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "diffHunk": "@@ -0,0 +1,461 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package construction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"testing\"\n+)\n+\n+var (\n+\tvalidUnsignedTxHash = \"0x1a00223d0a140a0c0891d0fef905109688f3a701120418d8c307120218061880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tvalidSignedTxHash   = \"0x1a660a640a20d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade1a40967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tinvalidTxHash       = \"InvalidTxHash\"\n+\tunmarshableTxHash   = \"0x6767\"\n+\tpublicKeyBytes      = \"d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade\"\n+)\n+\n+func dummyConstructionCombineRequest() *types.ConstructionCombineRequest {\n+\tunsignedTxHash := \"0x1a00223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tsigningPayloadBytes := \"967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507\"\n+\tsignatureBytes := \"0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\n+\treturn dummyConstructionCombineRequestWith(\n+\t\tunsignedTxHash,\n+\t\tsigningPayloadBytes,\n+\t\tpublicKeyBytes,\n+\t\tsignatureBytes,\n+\t)\n+}\n+\n+func dummyConstructionPreprocessRequest(valid bool) *types.ConstructionPreprocessRequest {\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\tif !valid {\n+\t\toperations = append(\n+\t\t\toperations,\n+\t\t\tdummyOperation(3, \"CRYPTOTRANSFER\", \"123532\", \"-5000\"),\n+\t\t)\n+\t}\n+\n+\treturn &types.ConstructionPreprocessRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tOperations:        operations,\n+\t}\n+}\n+\n+func dummyConstructionCombineRequestWith(unsignedTxHash, signingPayloadBytes, publicKeyBytes, signatureBytes string) *types.ConstructionCombineRequest {\n+\tdecodedSigningPayloadBytes, e1 := hex.DecodeString(signingPayloadBytes)\n+\tdecodedPublicKeyBytes, e2 := hex.DecodeString(publicKeyBytes)\n+\tdecodedSignatureBytes, e3 := hex.DecodeString(signatureBytes)\n+\n+\tif e1 != nil || e2 != nil || e3 != nil {\n+\t\treturn nil\n+\t}\n+\n+\treturn &types.ConstructionCombineRequest{\n+\t\tNetworkIdentifier:   networkIdentifier(),\n+\t\tUnsignedTransaction: unsignedTxHash,\n+\t\tSignatures: []*types.Signature{\n+\t\t\t{\n+\t\t\t\tSigningPayload: &types.SigningPayload{\n+\t\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\t\tAddress:  \"0.0.123352\",\n+\t\t\t\t\t\tMetadata: nil,\n+\t\t\t\t\t},\n+\t\t\t\t\tBytes:         decodedSigningPayloadBytes,\n+\t\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\t},\n+\t\t\t\tPublicKey: &types.PublicKey{\n+\t\t\t\t\tBytes:     decodedPublicKeyBytes,\n+\t\t\t\t\tCurveType: \"edwards25519\",\n+\t\t\t\t},\n+\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\tBytes:         decodedSignatureBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func dummyOperation(index int64, transferType, account, amount string) *types.Operation {\n+\treturn &types.Operation{\n+\t\tOperationIdentifier: &types.OperationIdentifier{\n+\t\t\tIndex: index,\n+\t\t},\n+\t\tType: transferType,\n+\t\tAccount: &types.AccountIdentifier{\n+\t\t\tAddress: account,\n+\t\t},\n+\t\tAmount: &types.Amount{\n+\t\t\tValue: amount,\n+\t\t\tCurrency: &types.Currency{\n+\t\t\t\tSymbol:   \"HBAR\",\n+\t\t\t\tDecimals: 8,\n+\t\t\t\tMetadata: map[string]interface{}{\n+\t\t\t\t\t\"issuer\": \"Hedera\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func networkIdentifier() *types.NetworkIdentifier {\n+\treturn &types.NetworkIdentifier{\n+\t\tBlockchain: \"SomeBlockchain\",\n+\t\tNetwork:    \"SomeNetwork\",\n+\t\tSubNetworkIdentifier: &types.SubNetworkIdentifier{\n+\t\t\tNetwork: \"SomeSubNetwork\",\n+\t\t},\n+\t}\n+}\n+\n+func dummyConstructionHashRequest(txHash string) *types.ConstructionHashRequest {\n+\treturn &types.ConstructionHashRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSignedTransaction: txHash,\n+\t}\n+}\n+\n+func dummyConstructionParseRequest(txHash string, signed bool) *types.ConstructionParseRequest {\n+\treturn &types.ConstructionParseRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSigned:            signed,\n+\t\tTransaction:       txHash,\n+\t}\n+}\n+\n+func dummyPayloadsRequest(operations []*types.Operation) *types.ConstructionPayloadsRequest {\n+\treturn &types.ConstructionPayloadsRequest{\n+\t\tOperations: operations,\n+\t}\n+}\n+\n+func TestNewConstructionAPIService(t *testing.T) {\n+\tassert.IsType(t, &ConstructionAPIService{}, NewConstructionAPIService())\n+}\n+\n+func TestConstructionCombine(t *testing.T) {\n+\t// given:\n+\texpectedConstructionCombineResponse := &types.ConstructionCombineResponse{\n+\t\tSignedTransaction: validSignedTxHash,\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, dummyConstructionCombineRequest())\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionCombineResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionCombineThrowsWithMultipleSignatures(t *testing.T) {\n+\t// given:\n+\texampleConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleConstructionCombineRequest.Signatures = []*types.Signature{\n+\t\t{}, {},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.MultipleSignaturesPresent], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = invalidTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenUnmarshallFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = unmarshableTxHash", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86dc63ba21f1d0722be1b0b26b53222445f34dc2"}, "originalPosition": 205}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5ODIxMzQzOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMjowMTozNFrOHm5tTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMjowMTozNFrOHm5tTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1MzQyMQ==", "bodyText": "it shouldn't be named invalidTxHash since it's not a hash. rename exampleInvalidTxHashConstructionCombineRequest as well.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1169#discussion_r510553421", "createdAt": "2020-10-23T02:01:34Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "diffHunk": "@@ -0,0 +1,461 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package construction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"testing\"\n+)\n+\n+var (\n+\tvalidUnsignedTxHash = \"0x1a00223d0a140a0c0891d0fef905109688f3a701120418d8c307120218061880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tvalidSignedTxHash   = \"0x1a660a640a20d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade1a40967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tinvalidTxHash       = \"InvalidTxHash\"\n+\tunmarshableTxHash   = \"0x6767\"\n+\tpublicKeyBytes      = \"d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade\"\n+)\n+\n+func dummyConstructionCombineRequest() *types.ConstructionCombineRequest {\n+\tunsignedTxHash := \"0x1a00223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tsigningPayloadBytes := \"967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507\"\n+\tsignatureBytes := \"0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\n+\treturn dummyConstructionCombineRequestWith(\n+\t\tunsignedTxHash,\n+\t\tsigningPayloadBytes,\n+\t\tpublicKeyBytes,\n+\t\tsignatureBytes,\n+\t)\n+}\n+\n+func dummyConstructionPreprocessRequest(valid bool) *types.ConstructionPreprocessRequest {\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\tif !valid {\n+\t\toperations = append(\n+\t\t\toperations,\n+\t\t\tdummyOperation(3, \"CRYPTOTRANSFER\", \"123532\", \"-5000\"),\n+\t\t)\n+\t}\n+\n+\treturn &types.ConstructionPreprocessRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tOperations:        operations,\n+\t}\n+}\n+\n+func dummyConstructionCombineRequestWith(unsignedTxHash, signingPayloadBytes, publicKeyBytes, signatureBytes string) *types.ConstructionCombineRequest {\n+\tdecodedSigningPayloadBytes, e1 := hex.DecodeString(signingPayloadBytes)\n+\tdecodedPublicKeyBytes, e2 := hex.DecodeString(publicKeyBytes)\n+\tdecodedSignatureBytes, e3 := hex.DecodeString(signatureBytes)\n+\n+\tif e1 != nil || e2 != nil || e3 != nil {\n+\t\treturn nil\n+\t}\n+\n+\treturn &types.ConstructionCombineRequest{\n+\t\tNetworkIdentifier:   networkIdentifier(),\n+\t\tUnsignedTransaction: unsignedTxHash,\n+\t\tSignatures: []*types.Signature{\n+\t\t\t{\n+\t\t\t\tSigningPayload: &types.SigningPayload{\n+\t\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\t\tAddress:  \"0.0.123352\",\n+\t\t\t\t\t\tMetadata: nil,\n+\t\t\t\t\t},\n+\t\t\t\t\tBytes:         decodedSigningPayloadBytes,\n+\t\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\t},\n+\t\t\t\tPublicKey: &types.PublicKey{\n+\t\t\t\t\tBytes:     decodedPublicKeyBytes,\n+\t\t\t\t\tCurveType: \"edwards25519\",\n+\t\t\t\t},\n+\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\tBytes:         decodedSignatureBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func dummyOperation(index int64, transferType, account, amount string) *types.Operation {\n+\treturn &types.Operation{\n+\t\tOperationIdentifier: &types.OperationIdentifier{\n+\t\t\tIndex: index,\n+\t\t},\n+\t\tType: transferType,\n+\t\tAccount: &types.AccountIdentifier{\n+\t\t\tAddress: account,\n+\t\t},\n+\t\tAmount: &types.Amount{\n+\t\t\tValue: amount,\n+\t\t\tCurrency: &types.Currency{\n+\t\t\t\tSymbol:   \"HBAR\",\n+\t\t\t\tDecimals: 8,\n+\t\t\t\tMetadata: map[string]interface{}{\n+\t\t\t\t\t\"issuer\": \"Hedera\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func networkIdentifier() *types.NetworkIdentifier {\n+\treturn &types.NetworkIdentifier{\n+\t\tBlockchain: \"SomeBlockchain\",\n+\t\tNetwork:    \"SomeNetwork\",\n+\t\tSubNetworkIdentifier: &types.SubNetworkIdentifier{\n+\t\t\tNetwork: \"SomeSubNetwork\",\n+\t\t},\n+\t}\n+}\n+\n+func dummyConstructionHashRequest(txHash string) *types.ConstructionHashRequest {\n+\treturn &types.ConstructionHashRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSignedTransaction: txHash,\n+\t}\n+}\n+\n+func dummyConstructionParseRequest(txHash string, signed bool) *types.ConstructionParseRequest {\n+\treturn &types.ConstructionParseRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSigned:            signed,\n+\t\tTransaction:       txHash,\n+\t}\n+}\n+\n+func dummyPayloadsRequest(operations []*types.Operation) *types.ConstructionPayloadsRequest {\n+\treturn &types.ConstructionPayloadsRequest{\n+\t\tOperations: operations,\n+\t}\n+}\n+\n+func TestNewConstructionAPIService(t *testing.T) {\n+\tassert.IsType(t, &ConstructionAPIService{}, NewConstructionAPIService())\n+}\n+\n+func TestConstructionCombine(t *testing.T) {\n+\t// given:\n+\texpectedConstructionCombineResponse := &types.ConstructionCombineResponse{\n+\t\tSignedTransaction: validSignedTxHash,\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, dummyConstructionCombineRequest())\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionCombineResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionCombineThrowsWithMultipleSignatures(t *testing.T) {\n+\t// given:\n+\texampleConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleConstructionCombineRequest.Signatures = []*types.Signature{\n+\t\t{}, {},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.MultipleSignaturesPresent], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = invalidTxHash", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86dc63ba21f1d0722be1b0b26b53222445f34dc2"}, "originalPosition": 192}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5ODIyNTA2OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMjowOToxMVrOHm50AQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMjowOToxMVrOHm50AQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1NTEzNw==", "bodyText": "the arg name txHash is misleading, should be signedTx or signedTransaction", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1169#discussion_r510555137", "createdAt": "2020-10-23T02:09:11Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "diffHunk": "@@ -0,0 +1,461 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package construction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"testing\"\n+)\n+\n+var (\n+\tvalidUnsignedTxHash = \"0x1a00223d0a140a0c0891d0fef905109688f3a701120418d8c307120218061880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tvalidSignedTxHash   = \"0x1a660a640a20d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade1a40967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tinvalidTxHash       = \"InvalidTxHash\"\n+\tunmarshableTxHash   = \"0x6767\"\n+\tpublicKeyBytes      = \"d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade\"\n+)\n+\n+func dummyConstructionCombineRequest() *types.ConstructionCombineRequest {\n+\tunsignedTxHash := \"0x1a00223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tsigningPayloadBytes := \"967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507\"\n+\tsignatureBytes := \"0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\n+\treturn dummyConstructionCombineRequestWith(\n+\t\tunsignedTxHash,\n+\t\tsigningPayloadBytes,\n+\t\tpublicKeyBytes,\n+\t\tsignatureBytes,\n+\t)\n+}\n+\n+func dummyConstructionPreprocessRequest(valid bool) *types.ConstructionPreprocessRequest {\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\tif !valid {\n+\t\toperations = append(\n+\t\t\toperations,\n+\t\t\tdummyOperation(3, \"CRYPTOTRANSFER\", \"123532\", \"-5000\"),\n+\t\t)\n+\t}\n+\n+\treturn &types.ConstructionPreprocessRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tOperations:        operations,\n+\t}\n+}\n+\n+func dummyConstructionCombineRequestWith(unsignedTxHash, signingPayloadBytes, publicKeyBytes, signatureBytes string) *types.ConstructionCombineRequest {\n+\tdecodedSigningPayloadBytes, e1 := hex.DecodeString(signingPayloadBytes)\n+\tdecodedPublicKeyBytes, e2 := hex.DecodeString(publicKeyBytes)\n+\tdecodedSignatureBytes, e3 := hex.DecodeString(signatureBytes)\n+\n+\tif e1 != nil || e2 != nil || e3 != nil {\n+\t\treturn nil\n+\t}\n+\n+\treturn &types.ConstructionCombineRequest{\n+\t\tNetworkIdentifier:   networkIdentifier(),\n+\t\tUnsignedTransaction: unsignedTxHash,\n+\t\tSignatures: []*types.Signature{\n+\t\t\t{\n+\t\t\t\tSigningPayload: &types.SigningPayload{\n+\t\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\t\tAddress:  \"0.0.123352\",\n+\t\t\t\t\t\tMetadata: nil,\n+\t\t\t\t\t},\n+\t\t\t\t\tBytes:         decodedSigningPayloadBytes,\n+\t\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\t},\n+\t\t\t\tPublicKey: &types.PublicKey{\n+\t\t\t\t\tBytes:     decodedPublicKeyBytes,\n+\t\t\t\t\tCurveType: \"edwards25519\",\n+\t\t\t\t},\n+\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\tBytes:         decodedSignatureBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func dummyOperation(index int64, transferType, account, amount string) *types.Operation {\n+\treturn &types.Operation{\n+\t\tOperationIdentifier: &types.OperationIdentifier{\n+\t\t\tIndex: index,\n+\t\t},\n+\t\tType: transferType,\n+\t\tAccount: &types.AccountIdentifier{\n+\t\t\tAddress: account,\n+\t\t},\n+\t\tAmount: &types.Amount{\n+\t\t\tValue: amount,\n+\t\t\tCurrency: &types.Currency{\n+\t\t\t\tSymbol:   \"HBAR\",\n+\t\t\t\tDecimals: 8,\n+\t\t\t\tMetadata: map[string]interface{}{\n+\t\t\t\t\t\"issuer\": \"Hedera\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func networkIdentifier() *types.NetworkIdentifier {\n+\treturn &types.NetworkIdentifier{\n+\t\tBlockchain: \"SomeBlockchain\",\n+\t\tNetwork:    \"SomeNetwork\",\n+\t\tSubNetworkIdentifier: &types.SubNetworkIdentifier{\n+\t\t\tNetwork: \"SomeSubNetwork\",\n+\t\t},\n+\t}\n+}\n+\n+func dummyConstructionHashRequest(txHash string) *types.ConstructionHashRequest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86dc63ba21f1d0722be1b0b26b53222445f34dc2"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5ODIyNjk1OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMjoxMDoyNlrOHm51GQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMjoxMDoyNlrOHm51GQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1NTQxNw==", "bodyText": "as in the previous comment, validSignedTxHash is misleading, should be named sth like validSignedTransaction", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1169#discussion_r510555417", "createdAt": "2020-10-23T02:10:26Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "diffHunk": "@@ -0,0 +1,461 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package construction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"testing\"\n+)\n+\n+var (\n+\tvalidUnsignedTxHash = \"0x1a00223d0a140a0c0891d0fef905109688f3a701120418d8c307120218061880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tvalidSignedTxHash   = \"0x1a660a640a20d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade1a40967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tinvalidTxHash       = \"InvalidTxHash\"\n+\tunmarshableTxHash   = \"0x6767\"\n+\tpublicKeyBytes      = \"d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade\"\n+)\n+\n+func dummyConstructionCombineRequest() *types.ConstructionCombineRequest {\n+\tunsignedTxHash := \"0x1a00223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tsigningPayloadBytes := \"967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507\"\n+\tsignatureBytes := \"0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\n+\treturn dummyConstructionCombineRequestWith(\n+\t\tunsignedTxHash,\n+\t\tsigningPayloadBytes,\n+\t\tpublicKeyBytes,\n+\t\tsignatureBytes,\n+\t)\n+}\n+\n+func dummyConstructionPreprocessRequest(valid bool) *types.ConstructionPreprocessRequest {\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\tif !valid {\n+\t\toperations = append(\n+\t\t\toperations,\n+\t\t\tdummyOperation(3, \"CRYPTOTRANSFER\", \"123532\", \"-5000\"),\n+\t\t)\n+\t}\n+\n+\treturn &types.ConstructionPreprocessRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tOperations:        operations,\n+\t}\n+}\n+\n+func dummyConstructionCombineRequestWith(unsignedTxHash, signingPayloadBytes, publicKeyBytes, signatureBytes string) *types.ConstructionCombineRequest {\n+\tdecodedSigningPayloadBytes, e1 := hex.DecodeString(signingPayloadBytes)\n+\tdecodedPublicKeyBytes, e2 := hex.DecodeString(publicKeyBytes)\n+\tdecodedSignatureBytes, e3 := hex.DecodeString(signatureBytes)\n+\n+\tif e1 != nil || e2 != nil || e3 != nil {\n+\t\treturn nil\n+\t}\n+\n+\treturn &types.ConstructionCombineRequest{\n+\t\tNetworkIdentifier:   networkIdentifier(),\n+\t\tUnsignedTransaction: unsignedTxHash,\n+\t\tSignatures: []*types.Signature{\n+\t\t\t{\n+\t\t\t\tSigningPayload: &types.SigningPayload{\n+\t\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\t\tAddress:  \"0.0.123352\",\n+\t\t\t\t\t\tMetadata: nil,\n+\t\t\t\t\t},\n+\t\t\t\t\tBytes:         decodedSigningPayloadBytes,\n+\t\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\t},\n+\t\t\t\tPublicKey: &types.PublicKey{\n+\t\t\t\t\tBytes:     decodedPublicKeyBytes,\n+\t\t\t\t\tCurveType: \"edwards25519\",\n+\t\t\t\t},\n+\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\tBytes:         decodedSignatureBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func dummyOperation(index int64, transferType, account, amount string) *types.Operation {\n+\treturn &types.Operation{\n+\t\tOperationIdentifier: &types.OperationIdentifier{\n+\t\t\tIndex: index,\n+\t\t},\n+\t\tType: transferType,\n+\t\tAccount: &types.AccountIdentifier{\n+\t\t\tAddress: account,\n+\t\t},\n+\t\tAmount: &types.Amount{\n+\t\t\tValue: amount,\n+\t\t\tCurrency: &types.Currency{\n+\t\t\t\tSymbol:   \"HBAR\",\n+\t\t\t\tDecimals: 8,\n+\t\t\t\tMetadata: map[string]interface{}{\n+\t\t\t\t\t\"issuer\": \"Hedera\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func networkIdentifier() *types.NetworkIdentifier {\n+\treturn &types.NetworkIdentifier{\n+\t\tBlockchain: \"SomeBlockchain\",\n+\t\tNetwork:    \"SomeNetwork\",\n+\t\tSubNetworkIdentifier: &types.SubNetworkIdentifier{\n+\t\t\tNetwork: \"SomeSubNetwork\",\n+\t\t},\n+\t}\n+}\n+\n+func dummyConstructionHashRequest(txHash string) *types.ConstructionHashRequest {\n+\treturn &types.ConstructionHashRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSignedTransaction: txHash,\n+\t}\n+}\n+\n+func dummyConstructionParseRequest(txHash string, signed bool) *types.ConstructionParseRequest {\n+\treturn &types.ConstructionParseRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSigned:            signed,\n+\t\tTransaction:       txHash,\n+\t}\n+}\n+\n+func dummyPayloadsRequest(operations []*types.Operation) *types.ConstructionPayloadsRequest {\n+\treturn &types.ConstructionPayloadsRequest{\n+\t\tOperations: operations,\n+\t}\n+}\n+\n+func TestNewConstructionAPIService(t *testing.T) {\n+\tassert.IsType(t, &ConstructionAPIService{}, NewConstructionAPIService())\n+}\n+\n+func TestConstructionCombine(t *testing.T) {\n+\t// given:\n+\texpectedConstructionCombineResponse := &types.ConstructionCombineResponse{\n+\t\tSignedTransaction: validSignedTxHash,\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, dummyConstructionCombineRequest())\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionCombineResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionCombineThrowsWithMultipleSignatures(t *testing.T) {\n+\t// given:\n+\texampleConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleConstructionCombineRequest.Signatures = []*types.Signature{\n+\t\t{}, {},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.MultipleSignaturesPresent], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = invalidTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenUnmarshallFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = unmarshableTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionUnmarshallingFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWithInvalidPublicKey(t *testing.T) {\n+\t// given:\n+\texampleInvalidPublicKeyConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidPublicKeyConstructionCombineRequest.Signatures[0].PublicKey = &types.PublicKey{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidPublicKeyConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidPublicKey], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenSignatureIsNotVerified(t *testing.T) {\n+\t// given:\n+\texampleInvalidSigningPayloadConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidSigningPayloadConstructionCombineRequest.Signatures[0].SigningPayload = &types.SigningPayload{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidSigningPayloadConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidSignatureVerification], e)\n+}\n+\n+func TestConstructionDerive(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionDerive(nil, nil)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.NotImplemented], e)\n+}\n+\n+func TestConstructionHash(t *testing.T) {\n+\t// given:\n+\ttxIdentifierHash := \"0x9768d458c755befcda5c6fca07e9f7693b94c429f9c414b0cea07163c402ddd44d1108f89b190d0dcabc423a3d45696d\"\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(validSignedTxHash)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86dc63ba21f1d0722be1b0b26b53222445f34dc2"}, "originalPosition": 253}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5ODIyOTEyOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMjoxMTo0MVrOHm52XQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMjoxMTo0MVrOHm52XQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1NTc0MQ==", "bodyText": "similar as above, invalidTxHash should be renamed", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1169#discussion_r510555741", "createdAt": "2020-10-23T02:11:41Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "diffHunk": "@@ -0,0 +1,461 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package construction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"testing\"\n+)\n+\n+var (\n+\tvalidUnsignedTxHash = \"0x1a00223d0a140a0c0891d0fef905109688f3a701120418d8c307120218061880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tvalidSignedTxHash   = \"0x1a660a640a20d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade1a40967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tinvalidTxHash       = \"InvalidTxHash\"\n+\tunmarshableTxHash   = \"0x6767\"\n+\tpublicKeyBytes      = \"d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade\"\n+)\n+\n+func dummyConstructionCombineRequest() *types.ConstructionCombineRequest {\n+\tunsignedTxHash := \"0x1a00223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tsigningPayloadBytes := \"967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507\"\n+\tsignatureBytes := \"0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\n+\treturn dummyConstructionCombineRequestWith(\n+\t\tunsignedTxHash,\n+\t\tsigningPayloadBytes,\n+\t\tpublicKeyBytes,\n+\t\tsignatureBytes,\n+\t)\n+}\n+\n+func dummyConstructionPreprocessRequest(valid bool) *types.ConstructionPreprocessRequest {\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\tif !valid {\n+\t\toperations = append(\n+\t\t\toperations,\n+\t\t\tdummyOperation(3, \"CRYPTOTRANSFER\", \"123532\", \"-5000\"),\n+\t\t)\n+\t}\n+\n+\treturn &types.ConstructionPreprocessRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tOperations:        operations,\n+\t}\n+}\n+\n+func dummyConstructionCombineRequestWith(unsignedTxHash, signingPayloadBytes, publicKeyBytes, signatureBytes string) *types.ConstructionCombineRequest {\n+\tdecodedSigningPayloadBytes, e1 := hex.DecodeString(signingPayloadBytes)\n+\tdecodedPublicKeyBytes, e2 := hex.DecodeString(publicKeyBytes)\n+\tdecodedSignatureBytes, e3 := hex.DecodeString(signatureBytes)\n+\n+\tif e1 != nil || e2 != nil || e3 != nil {\n+\t\treturn nil\n+\t}\n+\n+\treturn &types.ConstructionCombineRequest{\n+\t\tNetworkIdentifier:   networkIdentifier(),\n+\t\tUnsignedTransaction: unsignedTxHash,\n+\t\tSignatures: []*types.Signature{\n+\t\t\t{\n+\t\t\t\tSigningPayload: &types.SigningPayload{\n+\t\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\t\tAddress:  \"0.0.123352\",\n+\t\t\t\t\t\tMetadata: nil,\n+\t\t\t\t\t},\n+\t\t\t\t\tBytes:         decodedSigningPayloadBytes,\n+\t\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\t},\n+\t\t\t\tPublicKey: &types.PublicKey{\n+\t\t\t\t\tBytes:     decodedPublicKeyBytes,\n+\t\t\t\t\tCurveType: \"edwards25519\",\n+\t\t\t\t},\n+\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\tBytes:         decodedSignatureBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func dummyOperation(index int64, transferType, account, amount string) *types.Operation {\n+\treturn &types.Operation{\n+\t\tOperationIdentifier: &types.OperationIdentifier{\n+\t\t\tIndex: index,\n+\t\t},\n+\t\tType: transferType,\n+\t\tAccount: &types.AccountIdentifier{\n+\t\t\tAddress: account,\n+\t\t},\n+\t\tAmount: &types.Amount{\n+\t\t\tValue: amount,\n+\t\t\tCurrency: &types.Currency{\n+\t\t\t\tSymbol:   \"HBAR\",\n+\t\t\t\tDecimals: 8,\n+\t\t\t\tMetadata: map[string]interface{}{\n+\t\t\t\t\t\"issuer\": \"Hedera\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func networkIdentifier() *types.NetworkIdentifier {\n+\treturn &types.NetworkIdentifier{\n+\t\tBlockchain: \"SomeBlockchain\",\n+\t\tNetwork:    \"SomeNetwork\",\n+\t\tSubNetworkIdentifier: &types.SubNetworkIdentifier{\n+\t\t\tNetwork: \"SomeSubNetwork\",\n+\t\t},\n+\t}\n+}\n+\n+func dummyConstructionHashRequest(txHash string) *types.ConstructionHashRequest {\n+\treturn &types.ConstructionHashRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSignedTransaction: txHash,\n+\t}\n+}\n+\n+func dummyConstructionParseRequest(txHash string, signed bool) *types.ConstructionParseRequest {\n+\treturn &types.ConstructionParseRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSigned:            signed,\n+\t\tTransaction:       txHash,\n+\t}\n+}\n+\n+func dummyPayloadsRequest(operations []*types.Operation) *types.ConstructionPayloadsRequest {\n+\treturn &types.ConstructionPayloadsRequest{\n+\t\tOperations: operations,\n+\t}\n+}\n+\n+func TestNewConstructionAPIService(t *testing.T) {\n+\tassert.IsType(t, &ConstructionAPIService{}, NewConstructionAPIService())\n+}\n+\n+func TestConstructionCombine(t *testing.T) {\n+\t// given:\n+\texpectedConstructionCombineResponse := &types.ConstructionCombineResponse{\n+\t\tSignedTransaction: validSignedTxHash,\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, dummyConstructionCombineRequest())\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionCombineResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionCombineThrowsWithMultipleSignatures(t *testing.T) {\n+\t// given:\n+\texampleConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleConstructionCombineRequest.Signatures = []*types.Signature{\n+\t\t{}, {},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.MultipleSignaturesPresent], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = invalidTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenUnmarshallFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = unmarshableTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionUnmarshallingFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWithInvalidPublicKey(t *testing.T) {\n+\t// given:\n+\texampleInvalidPublicKeyConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidPublicKeyConstructionCombineRequest.Signatures[0].PublicKey = &types.PublicKey{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidPublicKeyConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidPublicKey], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenSignatureIsNotVerified(t *testing.T) {\n+\t// given:\n+\texampleInvalidSigningPayloadConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidSigningPayloadConstructionCombineRequest.Signatures[0].SigningPayload = &types.SigningPayload{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidSigningPayloadConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidSignatureVerification], e)\n+}\n+\n+func TestConstructionDerive(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionDerive(nil, nil)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.NotImplemented], e)\n+}\n+\n+func TestConstructionHash(t *testing.T) {\n+\t// given:\n+\ttxIdentifierHash := \"0x9768d458c755befcda5c6fca07e9f7693b94c429f9c414b0cea07163c402ddd44d1108f89b190d0dcabc423a3d45696d\"\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(validSignedTxHash)\n+\texpectedConstructHashResponse := &types.TransactionIdentifierResponse{\n+\t\tTransactionIdentifier: &types.TransactionIdentifier{Hash: txIdentifierHash},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructHashResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionHashThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(invalidTxHash)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86dc63ba21f1d0722be1b0b26b53222445f34dc2"}, "originalPosition": 268}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5ODIzNDkyOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMjoxNToyMlrOHm55lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMjoxNToyMlrOHm55lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1NjU2Ng==", "bodyText": "validUnsignedTxHash should be named sth like validTxHexStr since it's the hex encoded string of the marshalled transaction bytes", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1169#discussion_r510556566", "createdAt": "2020-10-23T02:15:22Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "diffHunk": "@@ -0,0 +1,461 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package construction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"testing\"\n+)\n+\n+var (\n+\tvalidUnsignedTxHash = \"0x1a00223d0a140a0c0891d0fef905109688f3a701120418d8c307120218061880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tvalidSignedTxHash   = \"0x1a660a640a20d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade1a40967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tinvalidTxHash       = \"InvalidTxHash\"\n+\tunmarshableTxHash   = \"0x6767\"\n+\tpublicKeyBytes      = \"d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade\"\n+)\n+\n+func dummyConstructionCombineRequest() *types.ConstructionCombineRequest {\n+\tunsignedTxHash := \"0x1a00223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tsigningPayloadBytes := \"967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507\"\n+\tsignatureBytes := \"0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\n+\treturn dummyConstructionCombineRequestWith(\n+\t\tunsignedTxHash,\n+\t\tsigningPayloadBytes,\n+\t\tpublicKeyBytes,\n+\t\tsignatureBytes,\n+\t)\n+}\n+\n+func dummyConstructionPreprocessRequest(valid bool) *types.ConstructionPreprocessRequest {\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\tif !valid {\n+\t\toperations = append(\n+\t\t\toperations,\n+\t\t\tdummyOperation(3, \"CRYPTOTRANSFER\", \"123532\", \"-5000\"),\n+\t\t)\n+\t}\n+\n+\treturn &types.ConstructionPreprocessRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tOperations:        operations,\n+\t}\n+}\n+\n+func dummyConstructionCombineRequestWith(unsignedTxHash, signingPayloadBytes, publicKeyBytes, signatureBytes string) *types.ConstructionCombineRequest {\n+\tdecodedSigningPayloadBytes, e1 := hex.DecodeString(signingPayloadBytes)\n+\tdecodedPublicKeyBytes, e2 := hex.DecodeString(publicKeyBytes)\n+\tdecodedSignatureBytes, e3 := hex.DecodeString(signatureBytes)\n+\n+\tif e1 != nil || e2 != nil || e3 != nil {\n+\t\treturn nil\n+\t}\n+\n+\treturn &types.ConstructionCombineRequest{\n+\t\tNetworkIdentifier:   networkIdentifier(),\n+\t\tUnsignedTransaction: unsignedTxHash,\n+\t\tSignatures: []*types.Signature{\n+\t\t\t{\n+\t\t\t\tSigningPayload: &types.SigningPayload{\n+\t\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\t\tAddress:  \"0.0.123352\",\n+\t\t\t\t\t\tMetadata: nil,\n+\t\t\t\t\t},\n+\t\t\t\t\tBytes:         decodedSigningPayloadBytes,\n+\t\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\t},\n+\t\t\t\tPublicKey: &types.PublicKey{\n+\t\t\t\t\tBytes:     decodedPublicKeyBytes,\n+\t\t\t\t\tCurveType: \"edwards25519\",\n+\t\t\t\t},\n+\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\tBytes:         decodedSignatureBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func dummyOperation(index int64, transferType, account, amount string) *types.Operation {\n+\treturn &types.Operation{\n+\t\tOperationIdentifier: &types.OperationIdentifier{\n+\t\t\tIndex: index,\n+\t\t},\n+\t\tType: transferType,\n+\t\tAccount: &types.AccountIdentifier{\n+\t\t\tAddress: account,\n+\t\t},\n+\t\tAmount: &types.Amount{\n+\t\t\tValue: amount,\n+\t\t\tCurrency: &types.Currency{\n+\t\t\t\tSymbol:   \"HBAR\",\n+\t\t\t\tDecimals: 8,\n+\t\t\t\tMetadata: map[string]interface{}{\n+\t\t\t\t\t\"issuer\": \"Hedera\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func networkIdentifier() *types.NetworkIdentifier {\n+\treturn &types.NetworkIdentifier{\n+\t\tBlockchain: \"SomeBlockchain\",\n+\t\tNetwork:    \"SomeNetwork\",\n+\t\tSubNetworkIdentifier: &types.SubNetworkIdentifier{\n+\t\t\tNetwork: \"SomeSubNetwork\",\n+\t\t},\n+\t}\n+}\n+\n+func dummyConstructionHashRequest(txHash string) *types.ConstructionHashRequest {\n+\treturn &types.ConstructionHashRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSignedTransaction: txHash,\n+\t}\n+}\n+\n+func dummyConstructionParseRequest(txHash string, signed bool) *types.ConstructionParseRequest {\n+\treturn &types.ConstructionParseRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSigned:            signed,\n+\t\tTransaction:       txHash,\n+\t}\n+}\n+\n+func dummyPayloadsRequest(operations []*types.Operation) *types.ConstructionPayloadsRequest {\n+\treturn &types.ConstructionPayloadsRequest{\n+\t\tOperations: operations,\n+\t}\n+}\n+\n+func TestNewConstructionAPIService(t *testing.T) {\n+\tassert.IsType(t, &ConstructionAPIService{}, NewConstructionAPIService())\n+}\n+\n+func TestConstructionCombine(t *testing.T) {\n+\t// given:\n+\texpectedConstructionCombineResponse := &types.ConstructionCombineResponse{\n+\t\tSignedTransaction: validSignedTxHash,\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, dummyConstructionCombineRequest())\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionCombineResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionCombineThrowsWithMultipleSignatures(t *testing.T) {\n+\t// given:\n+\texampleConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleConstructionCombineRequest.Signatures = []*types.Signature{\n+\t\t{}, {},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.MultipleSignaturesPresent], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = invalidTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenUnmarshallFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = unmarshableTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionUnmarshallingFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWithInvalidPublicKey(t *testing.T) {\n+\t// given:\n+\texampleInvalidPublicKeyConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidPublicKeyConstructionCombineRequest.Signatures[0].PublicKey = &types.PublicKey{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidPublicKeyConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidPublicKey], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenSignatureIsNotVerified(t *testing.T) {\n+\t// given:\n+\texampleInvalidSigningPayloadConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidSigningPayloadConstructionCombineRequest.Signatures[0].SigningPayload = &types.SigningPayload{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidSigningPayloadConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidSignatureVerification], e)\n+}\n+\n+func TestConstructionDerive(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionDerive(nil, nil)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.NotImplemented], e)\n+}\n+\n+func TestConstructionHash(t *testing.T) {\n+\t// given:\n+\ttxIdentifierHash := \"0x9768d458c755befcda5c6fca07e9f7693b94c429f9c414b0cea07163c402ddd44d1108f89b190d0dcabc423a3d45696d\"\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(validSignedTxHash)\n+\texpectedConstructHashResponse := &types.TransactionIdentifierResponse{\n+\t\tTransactionIdentifier: &types.TransactionIdentifier{Hash: txIdentifierHash},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructHashResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionHashThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(invalidTxHash)\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionMetadata(t *testing.T) {\n+\t// given:\n+\texpectedResponse := &types.ConstructionMetadataResponse{\n+\t\tMetadata: make(map[string]interface{}),\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionMetadata(nil, nil)\n+\n+\t// then:\n+\tassert.Equal(t, expectedResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParse(t *testing.T) {\n+\t// given:\n+\texampleConstructionParseRequest := dummyConstructionParseRequest(validUnsignedTxHash, false)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86dc63ba21f1d0722be1b0b26b53222445f34dc2"}, "originalPosition": 294}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5ODIzODExOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMjoxNzozMVrOHm57YQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMjoxNzozMVrOHm57YQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1NzAyNQ==", "bodyText": "validSignedTx", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1169#discussion_r510557025", "createdAt": "2020-10-23T02:17:31Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "diffHunk": "@@ -0,0 +1,461 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package construction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"testing\"\n+)\n+\n+var (\n+\tvalidUnsignedTxHash = \"0x1a00223d0a140a0c0891d0fef905109688f3a701120418d8c307120218061880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tvalidSignedTxHash   = \"0x1a660a640a20d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade1a40967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tinvalidTxHash       = \"InvalidTxHash\"\n+\tunmarshableTxHash   = \"0x6767\"\n+\tpublicKeyBytes      = \"d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade\"\n+)\n+\n+func dummyConstructionCombineRequest() *types.ConstructionCombineRequest {\n+\tunsignedTxHash := \"0x1a00223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tsigningPayloadBytes := \"967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507\"\n+\tsignatureBytes := \"0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\n+\treturn dummyConstructionCombineRequestWith(\n+\t\tunsignedTxHash,\n+\t\tsigningPayloadBytes,\n+\t\tpublicKeyBytes,\n+\t\tsignatureBytes,\n+\t)\n+}\n+\n+func dummyConstructionPreprocessRequest(valid bool) *types.ConstructionPreprocessRequest {\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\tif !valid {\n+\t\toperations = append(\n+\t\t\toperations,\n+\t\t\tdummyOperation(3, \"CRYPTOTRANSFER\", \"123532\", \"-5000\"),\n+\t\t)\n+\t}\n+\n+\treturn &types.ConstructionPreprocessRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tOperations:        operations,\n+\t}\n+}\n+\n+func dummyConstructionCombineRequestWith(unsignedTxHash, signingPayloadBytes, publicKeyBytes, signatureBytes string) *types.ConstructionCombineRequest {\n+\tdecodedSigningPayloadBytes, e1 := hex.DecodeString(signingPayloadBytes)\n+\tdecodedPublicKeyBytes, e2 := hex.DecodeString(publicKeyBytes)\n+\tdecodedSignatureBytes, e3 := hex.DecodeString(signatureBytes)\n+\n+\tif e1 != nil || e2 != nil || e3 != nil {\n+\t\treturn nil\n+\t}\n+\n+\treturn &types.ConstructionCombineRequest{\n+\t\tNetworkIdentifier:   networkIdentifier(),\n+\t\tUnsignedTransaction: unsignedTxHash,\n+\t\tSignatures: []*types.Signature{\n+\t\t\t{\n+\t\t\t\tSigningPayload: &types.SigningPayload{\n+\t\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\t\tAddress:  \"0.0.123352\",\n+\t\t\t\t\t\tMetadata: nil,\n+\t\t\t\t\t},\n+\t\t\t\t\tBytes:         decodedSigningPayloadBytes,\n+\t\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\t},\n+\t\t\t\tPublicKey: &types.PublicKey{\n+\t\t\t\t\tBytes:     decodedPublicKeyBytes,\n+\t\t\t\t\tCurveType: \"edwards25519\",\n+\t\t\t\t},\n+\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\tBytes:         decodedSignatureBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func dummyOperation(index int64, transferType, account, amount string) *types.Operation {\n+\treturn &types.Operation{\n+\t\tOperationIdentifier: &types.OperationIdentifier{\n+\t\t\tIndex: index,\n+\t\t},\n+\t\tType: transferType,\n+\t\tAccount: &types.AccountIdentifier{\n+\t\t\tAddress: account,\n+\t\t},\n+\t\tAmount: &types.Amount{\n+\t\t\tValue: amount,\n+\t\t\tCurrency: &types.Currency{\n+\t\t\t\tSymbol:   \"HBAR\",\n+\t\t\t\tDecimals: 8,\n+\t\t\t\tMetadata: map[string]interface{}{\n+\t\t\t\t\t\"issuer\": \"Hedera\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func networkIdentifier() *types.NetworkIdentifier {\n+\treturn &types.NetworkIdentifier{\n+\t\tBlockchain: \"SomeBlockchain\",\n+\t\tNetwork:    \"SomeNetwork\",\n+\t\tSubNetworkIdentifier: &types.SubNetworkIdentifier{\n+\t\t\tNetwork: \"SomeSubNetwork\",\n+\t\t},\n+\t}\n+}\n+\n+func dummyConstructionHashRequest(txHash string) *types.ConstructionHashRequest {\n+\treturn &types.ConstructionHashRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSignedTransaction: txHash,\n+\t}\n+}\n+\n+func dummyConstructionParseRequest(txHash string, signed bool) *types.ConstructionParseRequest {\n+\treturn &types.ConstructionParseRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSigned:            signed,\n+\t\tTransaction:       txHash,\n+\t}\n+}\n+\n+func dummyPayloadsRequest(operations []*types.Operation) *types.ConstructionPayloadsRequest {\n+\treturn &types.ConstructionPayloadsRequest{\n+\t\tOperations: operations,\n+\t}\n+}\n+\n+func TestNewConstructionAPIService(t *testing.T) {\n+\tassert.IsType(t, &ConstructionAPIService{}, NewConstructionAPIService())\n+}\n+\n+func TestConstructionCombine(t *testing.T) {\n+\t// given:\n+\texpectedConstructionCombineResponse := &types.ConstructionCombineResponse{\n+\t\tSignedTransaction: validSignedTxHash,\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, dummyConstructionCombineRequest())\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionCombineResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionCombineThrowsWithMultipleSignatures(t *testing.T) {\n+\t// given:\n+\texampleConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleConstructionCombineRequest.Signatures = []*types.Signature{\n+\t\t{}, {},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.MultipleSignaturesPresent], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = invalidTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenUnmarshallFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = unmarshableTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionUnmarshallingFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWithInvalidPublicKey(t *testing.T) {\n+\t// given:\n+\texampleInvalidPublicKeyConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidPublicKeyConstructionCombineRequest.Signatures[0].PublicKey = &types.PublicKey{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidPublicKeyConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidPublicKey], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenSignatureIsNotVerified(t *testing.T) {\n+\t// given:\n+\texampleInvalidSigningPayloadConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidSigningPayloadConstructionCombineRequest.Signatures[0].SigningPayload = &types.SigningPayload{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidSigningPayloadConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidSignatureVerification], e)\n+}\n+\n+func TestConstructionDerive(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionDerive(nil, nil)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.NotImplemented], e)\n+}\n+\n+func TestConstructionHash(t *testing.T) {\n+\t// given:\n+\ttxIdentifierHash := \"0x9768d458c755befcda5c6fca07e9f7693b94c429f9c414b0cea07163c402ddd44d1108f89b190d0dcabc423a3d45696d\"\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(validSignedTxHash)\n+\texpectedConstructHashResponse := &types.TransactionIdentifierResponse{\n+\t\tTransactionIdentifier: &types.TransactionIdentifier{Hash: txIdentifierHash},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructHashResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionHashThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(invalidTxHash)\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionMetadata(t *testing.T) {\n+\t// given:\n+\texpectedResponse := &types.ConstructionMetadataResponse{\n+\t\tMetadata: make(map[string]interface{}),\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionMetadata(nil, nil)\n+\n+\t// then:\n+\tassert.Equal(t, expectedResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParse(t *testing.T) {\n+\t// given:\n+\texampleConstructionParseRequest := dummyConstructionParseRequest(validUnsignedTxHash, false)\n+\texpectedConstructionParseResponse := &types.ConstructionParseResponse{\n+\t\tOperations: []*types.Operation{\n+\t\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t\t},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, exampleConstructionParseRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionParseResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParseSigned(t *testing.T) {\n+\t// given:\n+\texampleConstructionParseRequest := dummyConstructionParseRequest(validSignedTxHash, true)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86dc63ba21f1d0722be1b0b26b53222445f34dc2"}, "originalPosition": 312}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5ODI2OTQyOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMjozNzoxNlrOHm6NWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMjozNzoxNlrOHm6NWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU2MTYyNA==", "bodyText": "it's not a hash", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1169#discussion_r510561624", "createdAt": "2020-10-23T02:37:16Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "diffHunk": "@@ -0,0 +1,461 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package construction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"testing\"\n+)\n+\n+var (\n+\tvalidUnsignedTxHash = \"0x1a00223d0a140a0c0891d0fef905109688f3a701120418d8c307120218061880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tvalidSignedTxHash   = \"0x1a660a640a20d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade1a40967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tinvalidTxHash       = \"InvalidTxHash\"\n+\tunmarshableTxHash   = \"0x6767\"\n+\tpublicKeyBytes      = \"d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade\"\n+)\n+\n+func dummyConstructionCombineRequest() *types.ConstructionCombineRequest {\n+\tunsignedTxHash := \"0x1a00223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tsigningPayloadBytes := \"967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507\"\n+\tsignatureBytes := \"0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\n+\treturn dummyConstructionCombineRequestWith(\n+\t\tunsignedTxHash,\n+\t\tsigningPayloadBytes,\n+\t\tpublicKeyBytes,\n+\t\tsignatureBytes,\n+\t)\n+}\n+\n+func dummyConstructionPreprocessRequest(valid bool) *types.ConstructionPreprocessRequest {\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\tif !valid {\n+\t\toperations = append(\n+\t\t\toperations,\n+\t\t\tdummyOperation(3, \"CRYPTOTRANSFER\", \"123532\", \"-5000\"),\n+\t\t)\n+\t}\n+\n+\treturn &types.ConstructionPreprocessRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tOperations:        operations,\n+\t}\n+}\n+\n+func dummyConstructionCombineRequestWith(unsignedTxHash, signingPayloadBytes, publicKeyBytes, signatureBytes string) *types.ConstructionCombineRequest {\n+\tdecodedSigningPayloadBytes, e1 := hex.DecodeString(signingPayloadBytes)\n+\tdecodedPublicKeyBytes, e2 := hex.DecodeString(publicKeyBytes)\n+\tdecodedSignatureBytes, e3 := hex.DecodeString(signatureBytes)\n+\n+\tif e1 != nil || e2 != nil || e3 != nil {\n+\t\treturn nil\n+\t}\n+\n+\treturn &types.ConstructionCombineRequest{\n+\t\tNetworkIdentifier:   networkIdentifier(),\n+\t\tUnsignedTransaction: unsignedTxHash,\n+\t\tSignatures: []*types.Signature{\n+\t\t\t{\n+\t\t\t\tSigningPayload: &types.SigningPayload{\n+\t\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\t\tAddress:  \"0.0.123352\",\n+\t\t\t\t\t\tMetadata: nil,\n+\t\t\t\t\t},\n+\t\t\t\t\tBytes:         decodedSigningPayloadBytes,\n+\t\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\t},\n+\t\t\t\tPublicKey: &types.PublicKey{\n+\t\t\t\t\tBytes:     decodedPublicKeyBytes,\n+\t\t\t\t\tCurveType: \"edwards25519\",\n+\t\t\t\t},\n+\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\tBytes:         decodedSignatureBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func dummyOperation(index int64, transferType, account, amount string) *types.Operation {\n+\treturn &types.Operation{\n+\t\tOperationIdentifier: &types.OperationIdentifier{\n+\t\t\tIndex: index,\n+\t\t},\n+\t\tType: transferType,\n+\t\tAccount: &types.AccountIdentifier{\n+\t\t\tAddress: account,\n+\t\t},\n+\t\tAmount: &types.Amount{\n+\t\t\tValue: amount,\n+\t\t\tCurrency: &types.Currency{\n+\t\t\t\tSymbol:   \"HBAR\",\n+\t\t\t\tDecimals: 8,\n+\t\t\t\tMetadata: map[string]interface{}{\n+\t\t\t\t\t\"issuer\": \"Hedera\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func networkIdentifier() *types.NetworkIdentifier {\n+\treturn &types.NetworkIdentifier{\n+\t\tBlockchain: \"SomeBlockchain\",\n+\t\tNetwork:    \"SomeNetwork\",\n+\t\tSubNetworkIdentifier: &types.SubNetworkIdentifier{\n+\t\t\tNetwork: \"SomeSubNetwork\",\n+\t\t},\n+\t}\n+}\n+\n+func dummyConstructionHashRequest(txHash string) *types.ConstructionHashRequest {\n+\treturn &types.ConstructionHashRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSignedTransaction: txHash,\n+\t}\n+}\n+\n+func dummyConstructionParseRequest(txHash string, signed bool) *types.ConstructionParseRequest {\n+\treturn &types.ConstructionParseRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSigned:            signed,\n+\t\tTransaction:       txHash,\n+\t}\n+}\n+\n+func dummyPayloadsRequest(operations []*types.Operation) *types.ConstructionPayloadsRequest {\n+\treturn &types.ConstructionPayloadsRequest{\n+\t\tOperations: operations,\n+\t}\n+}\n+\n+func TestNewConstructionAPIService(t *testing.T) {\n+\tassert.IsType(t, &ConstructionAPIService{}, NewConstructionAPIService())\n+}\n+\n+func TestConstructionCombine(t *testing.T) {\n+\t// given:\n+\texpectedConstructionCombineResponse := &types.ConstructionCombineResponse{\n+\t\tSignedTransaction: validSignedTxHash,\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, dummyConstructionCombineRequest())\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionCombineResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionCombineThrowsWithMultipleSignatures(t *testing.T) {\n+\t// given:\n+\texampleConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleConstructionCombineRequest.Signatures = []*types.Signature{\n+\t\t{}, {},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.MultipleSignaturesPresent], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = invalidTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenUnmarshallFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = unmarshableTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionUnmarshallingFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWithInvalidPublicKey(t *testing.T) {\n+\t// given:\n+\texampleInvalidPublicKeyConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidPublicKeyConstructionCombineRequest.Signatures[0].PublicKey = &types.PublicKey{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidPublicKeyConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidPublicKey], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenSignatureIsNotVerified(t *testing.T) {\n+\t// given:\n+\texampleInvalidSigningPayloadConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidSigningPayloadConstructionCombineRequest.Signatures[0].SigningPayload = &types.SigningPayload{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidSigningPayloadConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidSignatureVerification], e)\n+}\n+\n+func TestConstructionDerive(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionDerive(nil, nil)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.NotImplemented], e)\n+}\n+\n+func TestConstructionHash(t *testing.T) {\n+\t// given:\n+\ttxIdentifierHash := \"0x9768d458c755befcda5c6fca07e9f7693b94c429f9c414b0cea07163c402ddd44d1108f89b190d0dcabc423a3d45696d\"\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(validSignedTxHash)\n+\texpectedConstructHashResponse := &types.TransactionIdentifierResponse{\n+\t\tTransactionIdentifier: &types.TransactionIdentifier{Hash: txIdentifierHash},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructHashResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionHashThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(invalidTxHash)\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionMetadata(t *testing.T) {\n+\t// given:\n+\texpectedResponse := &types.ConstructionMetadataResponse{\n+\t\tMetadata: make(map[string]interface{}),\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionMetadata(nil, nil)\n+\n+\t// then:\n+\tassert.Equal(t, expectedResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParse(t *testing.T) {\n+\t// given:\n+\texampleConstructionParseRequest := dummyConstructionParseRequest(validUnsignedTxHash, false)\n+\texpectedConstructionParseResponse := &types.ConstructionParseResponse{\n+\t\tOperations: []*types.Operation{\n+\t\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t\t},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, exampleConstructionParseRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionParseResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParseSigned(t *testing.T) {\n+\t// given:\n+\texampleConstructionParseRequest := dummyConstructionParseRequest(validSignedTxHash, true)\n+\texpectedConstructionParseResponse := &types.ConstructionParseResponse{\n+\t\tOperations: []*types.Operation{\n+\t\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t\t},\n+\t\tAccountIdentifierSigners: []*types.AccountIdentifier{\n+\t\t\t{\n+\t\t\t\tAddress: publicKeyBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, exampleConstructionParseRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionParseResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParseThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, dummyConstructionParseRequest(invalidTxHash, false))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86dc63ba21f1d0722be1b0b26b53222445f34dc2"}, "originalPosition": 335}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5ODI3OTAzOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMjo0MzozN1rOHm6S2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMjo0MzozN1rOHm6S2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU2MzAzMg==", "bodyText": "hex.DecodeString returns err, so expectedDecodedBytes is an empty slice", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1169#discussion_r510563032", "createdAt": "2020-10-23T02:43:37Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "diffHunk": "@@ -0,0 +1,461 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package construction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"testing\"\n+)\n+\n+var (\n+\tvalidUnsignedTxHash = \"0x1a00223d0a140a0c0891d0fef905109688f3a701120418d8c307120218061880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tvalidSignedTxHash   = \"0x1a660a640a20d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade1a40967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tinvalidTxHash       = \"InvalidTxHash\"\n+\tunmarshableTxHash   = \"0x6767\"\n+\tpublicKeyBytes      = \"d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade\"\n+)\n+\n+func dummyConstructionCombineRequest() *types.ConstructionCombineRequest {\n+\tunsignedTxHash := \"0x1a00223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tsigningPayloadBytes := \"967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507\"\n+\tsignatureBytes := \"0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\n+\treturn dummyConstructionCombineRequestWith(\n+\t\tunsignedTxHash,\n+\t\tsigningPayloadBytes,\n+\t\tpublicKeyBytes,\n+\t\tsignatureBytes,\n+\t)\n+}\n+\n+func dummyConstructionPreprocessRequest(valid bool) *types.ConstructionPreprocessRequest {\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\tif !valid {\n+\t\toperations = append(\n+\t\t\toperations,\n+\t\t\tdummyOperation(3, \"CRYPTOTRANSFER\", \"123532\", \"-5000\"),\n+\t\t)\n+\t}\n+\n+\treturn &types.ConstructionPreprocessRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tOperations:        operations,\n+\t}\n+}\n+\n+func dummyConstructionCombineRequestWith(unsignedTxHash, signingPayloadBytes, publicKeyBytes, signatureBytes string) *types.ConstructionCombineRequest {\n+\tdecodedSigningPayloadBytes, e1 := hex.DecodeString(signingPayloadBytes)\n+\tdecodedPublicKeyBytes, e2 := hex.DecodeString(publicKeyBytes)\n+\tdecodedSignatureBytes, e3 := hex.DecodeString(signatureBytes)\n+\n+\tif e1 != nil || e2 != nil || e3 != nil {\n+\t\treturn nil\n+\t}\n+\n+\treturn &types.ConstructionCombineRequest{\n+\t\tNetworkIdentifier:   networkIdentifier(),\n+\t\tUnsignedTransaction: unsignedTxHash,\n+\t\tSignatures: []*types.Signature{\n+\t\t\t{\n+\t\t\t\tSigningPayload: &types.SigningPayload{\n+\t\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\t\tAddress:  \"0.0.123352\",\n+\t\t\t\t\t\tMetadata: nil,\n+\t\t\t\t\t},\n+\t\t\t\t\tBytes:         decodedSigningPayloadBytes,\n+\t\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\t},\n+\t\t\t\tPublicKey: &types.PublicKey{\n+\t\t\t\t\tBytes:     decodedPublicKeyBytes,\n+\t\t\t\t\tCurveType: \"edwards25519\",\n+\t\t\t\t},\n+\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\tBytes:         decodedSignatureBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func dummyOperation(index int64, transferType, account, amount string) *types.Operation {\n+\treturn &types.Operation{\n+\t\tOperationIdentifier: &types.OperationIdentifier{\n+\t\t\tIndex: index,\n+\t\t},\n+\t\tType: transferType,\n+\t\tAccount: &types.AccountIdentifier{\n+\t\t\tAddress: account,\n+\t\t},\n+\t\tAmount: &types.Amount{\n+\t\t\tValue: amount,\n+\t\t\tCurrency: &types.Currency{\n+\t\t\t\tSymbol:   \"HBAR\",\n+\t\t\t\tDecimals: 8,\n+\t\t\t\tMetadata: map[string]interface{}{\n+\t\t\t\t\t\"issuer\": \"Hedera\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func networkIdentifier() *types.NetworkIdentifier {\n+\treturn &types.NetworkIdentifier{\n+\t\tBlockchain: \"SomeBlockchain\",\n+\t\tNetwork:    \"SomeNetwork\",\n+\t\tSubNetworkIdentifier: &types.SubNetworkIdentifier{\n+\t\t\tNetwork: \"SomeSubNetwork\",\n+\t\t},\n+\t}\n+}\n+\n+func dummyConstructionHashRequest(txHash string) *types.ConstructionHashRequest {\n+\treturn &types.ConstructionHashRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSignedTransaction: txHash,\n+\t}\n+}\n+\n+func dummyConstructionParseRequest(txHash string, signed bool) *types.ConstructionParseRequest {\n+\treturn &types.ConstructionParseRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSigned:            signed,\n+\t\tTransaction:       txHash,\n+\t}\n+}\n+\n+func dummyPayloadsRequest(operations []*types.Operation) *types.ConstructionPayloadsRequest {\n+\treturn &types.ConstructionPayloadsRequest{\n+\t\tOperations: operations,\n+\t}\n+}\n+\n+func TestNewConstructionAPIService(t *testing.T) {\n+\tassert.IsType(t, &ConstructionAPIService{}, NewConstructionAPIService())\n+}\n+\n+func TestConstructionCombine(t *testing.T) {\n+\t// given:\n+\texpectedConstructionCombineResponse := &types.ConstructionCombineResponse{\n+\t\tSignedTransaction: validSignedTxHash,\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, dummyConstructionCombineRequest())\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionCombineResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionCombineThrowsWithMultipleSignatures(t *testing.T) {\n+\t// given:\n+\texampleConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleConstructionCombineRequest.Signatures = []*types.Signature{\n+\t\t{}, {},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.MultipleSignaturesPresent], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = invalidTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenUnmarshallFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = unmarshableTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionUnmarshallingFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWithInvalidPublicKey(t *testing.T) {\n+\t// given:\n+\texampleInvalidPublicKeyConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidPublicKeyConstructionCombineRequest.Signatures[0].PublicKey = &types.PublicKey{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidPublicKeyConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidPublicKey], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenSignatureIsNotVerified(t *testing.T) {\n+\t// given:\n+\texampleInvalidSigningPayloadConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidSigningPayloadConstructionCombineRequest.Signatures[0].SigningPayload = &types.SigningPayload{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidSigningPayloadConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidSignatureVerification], e)\n+}\n+\n+func TestConstructionDerive(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionDerive(nil, nil)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.NotImplemented], e)\n+}\n+\n+func TestConstructionHash(t *testing.T) {\n+\t// given:\n+\ttxIdentifierHash := \"0x9768d458c755befcda5c6fca07e9f7693b94c429f9c414b0cea07163c402ddd44d1108f89b190d0dcabc423a3d45696d\"\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(validSignedTxHash)\n+\texpectedConstructHashResponse := &types.TransactionIdentifierResponse{\n+\t\tTransactionIdentifier: &types.TransactionIdentifier{Hash: txIdentifierHash},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructHashResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionHashThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(invalidTxHash)\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionMetadata(t *testing.T) {\n+\t// given:\n+\texpectedResponse := &types.ConstructionMetadataResponse{\n+\t\tMetadata: make(map[string]interface{}),\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionMetadata(nil, nil)\n+\n+\t// then:\n+\tassert.Equal(t, expectedResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParse(t *testing.T) {\n+\t// given:\n+\texampleConstructionParseRequest := dummyConstructionParseRequest(validUnsignedTxHash, false)\n+\texpectedConstructionParseResponse := &types.ConstructionParseResponse{\n+\t\tOperations: []*types.Operation{\n+\t\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t\t},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, exampleConstructionParseRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionParseResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParseSigned(t *testing.T) {\n+\t// given:\n+\texampleConstructionParseRequest := dummyConstructionParseRequest(validSignedTxHash, true)\n+\texpectedConstructionParseResponse := &types.ConstructionParseResponse{\n+\t\tOperations: []*types.Operation{\n+\t\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t\t},\n+\t\tAccountIdentifierSigners: []*types.AccountIdentifier{\n+\t\t\t{\n+\t\t\t\tAddress: publicKeyBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, exampleConstructionParseRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionParseResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParseThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, dummyConstructionParseRequest(invalidTxHash, false))\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionParseThrowsWhenUnmarshallFails(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, dummyConstructionParseRequest(unmarshableTxHash, false))\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionUnmarshallingFailed], e)\n+}\n+\n+func TestConstructionPayloads(t *testing.T) {\n+\t// given:\n+\texpectedDecodedBytes, _ := hex.DecodeString(unmarshableTxHash)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86dc63ba21f1d0722be1b0b26b53222445f34dc2"}, "originalPosition": 353}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5ODI4NjExOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMjo0NzoyMFrOHm6WnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMjo0NzoyMFrOHm6WnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU2Mzk5Ng==", "bodyText": "should check Payloads not just Payloads[0]. AccountIdentifier.Address", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1169#discussion_r510563996", "createdAt": "2020-10-23T02:47:20Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "diffHunk": "@@ -0,0 +1,461 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package construction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"testing\"\n+)\n+\n+var (\n+\tvalidUnsignedTxHash = \"0x1a00223d0a140a0c0891d0fef905109688f3a701120418d8c307120218061880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tvalidSignedTxHash   = \"0x1a660a640a20d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade1a40967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tinvalidTxHash       = \"InvalidTxHash\"\n+\tunmarshableTxHash   = \"0x6767\"\n+\tpublicKeyBytes      = \"d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade\"\n+)\n+\n+func dummyConstructionCombineRequest() *types.ConstructionCombineRequest {\n+\tunsignedTxHash := \"0x1a00223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tsigningPayloadBytes := \"967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507\"\n+\tsignatureBytes := \"0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\n+\treturn dummyConstructionCombineRequestWith(\n+\t\tunsignedTxHash,\n+\t\tsigningPayloadBytes,\n+\t\tpublicKeyBytes,\n+\t\tsignatureBytes,\n+\t)\n+}\n+\n+func dummyConstructionPreprocessRequest(valid bool) *types.ConstructionPreprocessRequest {\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\tif !valid {\n+\t\toperations = append(\n+\t\t\toperations,\n+\t\t\tdummyOperation(3, \"CRYPTOTRANSFER\", \"123532\", \"-5000\"),\n+\t\t)\n+\t}\n+\n+\treturn &types.ConstructionPreprocessRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tOperations:        operations,\n+\t}\n+}\n+\n+func dummyConstructionCombineRequestWith(unsignedTxHash, signingPayloadBytes, publicKeyBytes, signatureBytes string) *types.ConstructionCombineRequest {\n+\tdecodedSigningPayloadBytes, e1 := hex.DecodeString(signingPayloadBytes)\n+\tdecodedPublicKeyBytes, e2 := hex.DecodeString(publicKeyBytes)\n+\tdecodedSignatureBytes, e3 := hex.DecodeString(signatureBytes)\n+\n+\tif e1 != nil || e2 != nil || e3 != nil {\n+\t\treturn nil\n+\t}\n+\n+\treturn &types.ConstructionCombineRequest{\n+\t\tNetworkIdentifier:   networkIdentifier(),\n+\t\tUnsignedTransaction: unsignedTxHash,\n+\t\tSignatures: []*types.Signature{\n+\t\t\t{\n+\t\t\t\tSigningPayload: &types.SigningPayload{\n+\t\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\t\tAddress:  \"0.0.123352\",\n+\t\t\t\t\t\tMetadata: nil,\n+\t\t\t\t\t},\n+\t\t\t\t\tBytes:         decodedSigningPayloadBytes,\n+\t\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\t},\n+\t\t\t\tPublicKey: &types.PublicKey{\n+\t\t\t\t\tBytes:     decodedPublicKeyBytes,\n+\t\t\t\t\tCurveType: \"edwards25519\",\n+\t\t\t\t},\n+\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\tBytes:         decodedSignatureBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func dummyOperation(index int64, transferType, account, amount string) *types.Operation {\n+\treturn &types.Operation{\n+\t\tOperationIdentifier: &types.OperationIdentifier{\n+\t\t\tIndex: index,\n+\t\t},\n+\t\tType: transferType,\n+\t\tAccount: &types.AccountIdentifier{\n+\t\t\tAddress: account,\n+\t\t},\n+\t\tAmount: &types.Amount{\n+\t\t\tValue: amount,\n+\t\t\tCurrency: &types.Currency{\n+\t\t\t\tSymbol:   \"HBAR\",\n+\t\t\t\tDecimals: 8,\n+\t\t\t\tMetadata: map[string]interface{}{\n+\t\t\t\t\t\"issuer\": \"Hedera\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func networkIdentifier() *types.NetworkIdentifier {\n+\treturn &types.NetworkIdentifier{\n+\t\tBlockchain: \"SomeBlockchain\",\n+\t\tNetwork:    \"SomeNetwork\",\n+\t\tSubNetworkIdentifier: &types.SubNetworkIdentifier{\n+\t\t\tNetwork: \"SomeSubNetwork\",\n+\t\t},\n+\t}\n+}\n+\n+func dummyConstructionHashRequest(txHash string) *types.ConstructionHashRequest {\n+\treturn &types.ConstructionHashRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSignedTransaction: txHash,\n+\t}\n+}\n+\n+func dummyConstructionParseRequest(txHash string, signed bool) *types.ConstructionParseRequest {\n+\treturn &types.ConstructionParseRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSigned:            signed,\n+\t\tTransaction:       txHash,\n+\t}\n+}\n+\n+func dummyPayloadsRequest(operations []*types.Operation) *types.ConstructionPayloadsRequest {\n+\treturn &types.ConstructionPayloadsRequest{\n+\t\tOperations: operations,\n+\t}\n+}\n+\n+func TestNewConstructionAPIService(t *testing.T) {\n+\tassert.IsType(t, &ConstructionAPIService{}, NewConstructionAPIService())\n+}\n+\n+func TestConstructionCombine(t *testing.T) {\n+\t// given:\n+\texpectedConstructionCombineResponse := &types.ConstructionCombineResponse{\n+\t\tSignedTransaction: validSignedTxHash,\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, dummyConstructionCombineRequest())\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionCombineResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionCombineThrowsWithMultipleSignatures(t *testing.T) {\n+\t// given:\n+\texampleConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleConstructionCombineRequest.Signatures = []*types.Signature{\n+\t\t{}, {},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.MultipleSignaturesPresent], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = invalidTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenUnmarshallFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = unmarshableTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionUnmarshallingFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWithInvalidPublicKey(t *testing.T) {\n+\t// given:\n+\texampleInvalidPublicKeyConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidPublicKeyConstructionCombineRequest.Signatures[0].PublicKey = &types.PublicKey{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidPublicKeyConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidPublicKey], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenSignatureIsNotVerified(t *testing.T) {\n+\t// given:\n+\texampleInvalidSigningPayloadConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidSigningPayloadConstructionCombineRequest.Signatures[0].SigningPayload = &types.SigningPayload{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidSigningPayloadConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidSignatureVerification], e)\n+}\n+\n+func TestConstructionDerive(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionDerive(nil, nil)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.NotImplemented], e)\n+}\n+\n+func TestConstructionHash(t *testing.T) {\n+\t// given:\n+\ttxIdentifierHash := \"0x9768d458c755befcda5c6fca07e9f7693b94c429f9c414b0cea07163c402ddd44d1108f89b190d0dcabc423a3d45696d\"\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(validSignedTxHash)\n+\texpectedConstructHashResponse := &types.TransactionIdentifierResponse{\n+\t\tTransactionIdentifier: &types.TransactionIdentifier{Hash: txIdentifierHash},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructHashResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionHashThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(invalidTxHash)\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionMetadata(t *testing.T) {\n+\t// given:\n+\texpectedResponse := &types.ConstructionMetadataResponse{\n+\t\tMetadata: make(map[string]interface{}),\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionMetadata(nil, nil)\n+\n+\t// then:\n+\tassert.Equal(t, expectedResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParse(t *testing.T) {\n+\t// given:\n+\texampleConstructionParseRequest := dummyConstructionParseRequest(validUnsignedTxHash, false)\n+\texpectedConstructionParseResponse := &types.ConstructionParseResponse{\n+\t\tOperations: []*types.Operation{\n+\t\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t\t},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, exampleConstructionParseRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionParseResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParseSigned(t *testing.T) {\n+\t// given:\n+\texampleConstructionParseRequest := dummyConstructionParseRequest(validSignedTxHash, true)\n+\texpectedConstructionParseResponse := &types.ConstructionParseResponse{\n+\t\tOperations: []*types.Operation{\n+\t\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t\t},\n+\t\tAccountIdentifierSigners: []*types.AccountIdentifier{\n+\t\t\t{\n+\t\t\t\tAddress: publicKeyBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, exampleConstructionParseRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionParseResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParseThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, dummyConstructionParseRequest(invalidTxHash, false))\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionParseThrowsWhenUnmarshallFails(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, dummyConstructionParseRequest(unmarshableTxHash, false))\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionUnmarshallingFailed], e)\n+}\n+\n+func TestConstructionPayloads(t *testing.T) {\n+\t// given:\n+\texpectedDecodedBytes, _ := hex.DecodeString(unmarshableTxHash)\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\texpectedPayloadsResponse := &types.ConstructionPayloadsResponse{\n+\t\tUnsignedTransaction: \"0x1a00223d0a140a0c08faf3b5fc0510c681d7d303120418e3cc13120218061880c2d72f2202087872180a160a090a0418b9c30710c8010a090a0418e3cc1310c701\",\n+\t\tPayloads: []*types.SigningPayload{\n+\t\t\t{\n+\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\tAddress: \"0.0.123352\",\n+\t\t\t\t},\n+\t\t\t\tBytes: expectedDecodedBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionPayloads(nil, dummyPayloadsRequest(operations))\n+\n+\t// then:\n+\t// here we do not assert the whole response object to equal the expected one, because invocation of this method appends a unique timestamp to the result, thus making the signed TX and Bytes unique and non-assertable.\n+\tassert.Equal(t, expectedPayloadsResponse.Payloads[0].AccountIdentifier.Address, res.Payloads[0].AccountIdentifier.Address)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86dc63ba21f1d0722be1b0b26b53222445f34dc2"}, "originalPosition": 375}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5ODI5NzcwOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMjo1NDoyM1rOHm6dLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMjo1NDoyM1rOHm6dLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU2NTY3OA==", "bodyText": "constructionSubmitSignedTransaction", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1169#discussion_r510565678", "createdAt": "2020-10-23T02:54:23Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "diffHunk": "@@ -0,0 +1,461 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package construction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"testing\"\n+)\n+\n+var (\n+\tvalidUnsignedTxHash = \"0x1a00223d0a140a0c0891d0fef905109688f3a701120418d8c307120218061880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tvalidSignedTxHash   = \"0x1a660a640a20d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade1a40967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tinvalidTxHash       = \"InvalidTxHash\"\n+\tunmarshableTxHash   = \"0x6767\"\n+\tpublicKeyBytes      = \"d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade\"\n+)\n+\n+func dummyConstructionCombineRequest() *types.ConstructionCombineRequest {\n+\tunsignedTxHash := \"0x1a00223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tsigningPayloadBytes := \"967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507\"\n+\tsignatureBytes := \"0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\n+\treturn dummyConstructionCombineRequestWith(\n+\t\tunsignedTxHash,\n+\t\tsigningPayloadBytes,\n+\t\tpublicKeyBytes,\n+\t\tsignatureBytes,\n+\t)\n+}\n+\n+func dummyConstructionPreprocessRequest(valid bool) *types.ConstructionPreprocessRequest {\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\tif !valid {\n+\t\toperations = append(\n+\t\t\toperations,\n+\t\t\tdummyOperation(3, \"CRYPTOTRANSFER\", \"123532\", \"-5000\"),\n+\t\t)\n+\t}\n+\n+\treturn &types.ConstructionPreprocessRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tOperations:        operations,\n+\t}\n+}\n+\n+func dummyConstructionCombineRequestWith(unsignedTxHash, signingPayloadBytes, publicKeyBytes, signatureBytes string) *types.ConstructionCombineRequest {\n+\tdecodedSigningPayloadBytes, e1 := hex.DecodeString(signingPayloadBytes)\n+\tdecodedPublicKeyBytes, e2 := hex.DecodeString(publicKeyBytes)\n+\tdecodedSignatureBytes, e3 := hex.DecodeString(signatureBytes)\n+\n+\tif e1 != nil || e2 != nil || e3 != nil {\n+\t\treturn nil\n+\t}\n+\n+\treturn &types.ConstructionCombineRequest{\n+\t\tNetworkIdentifier:   networkIdentifier(),\n+\t\tUnsignedTransaction: unsignedTxHash,\n+\t\tSignatures: []*types.Signature{\n+\t\t\t{\n+\t\t\t\tSigningPayload: &types.SigningPayload{\n+\t\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\t\tAddress:  \"0.0.123352\",\n+\t\t\t\t\t\tMetadata: nil,\n+\t\t\t\t\t},\n+\t\t\t\t\tBytes:         decodedSigningPayloadBytes,\n+\t\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\t},\n+\t\t\t\tPublicKey: &types.PublicKey{\n+\t\t\t\t\tBytes:     decodedPublicKeyBytes,\n+\t\t\t\t\tCurveType: \"edwards25519\",\n+\t\t\t\t},\n+\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\tBytes:         decodedSignatureBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func dummyOperation(index int64, transferType, account, amount string) *types.Operation {\n+\treturn &types.Operation{\n+\t\tOperationIdentifier: &types.OperationIdentifier{\n+\t\t\tIndex: index,\n+\t\t},\n+\t\tType: transferType,\n+\t\tAccount: &types.AccountIdentifier{\n+\t\t\tAddress: account,\n+\t\t},\n+\t\tAmount: &types.Amount{\n+\t\t\tValue: amount,\n+\t\t\tCurrency: &types.Currency{\n+\t\t\t\tSymbol:   \"HBAR\",\n+\t\t\t\tDecimals: 8,\n+\t\t\t\tMetadata: map[string]interface{}{\n+\t\t\t\t\t\"issuer\": \"Hedera\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func networkIdentifier() *types.NetworkIdentifier {\n+\treturn &types.NetworkIdentifier{\n+\t\tBlockchain: \"SomeBlockchain\",\n+\t\tNetwork:    \"SomeNetwork\",\n+\t\tSubNetworkIdentifier: &types.SubNetworkIdentifier{\n+\t\t\tNetwork: \"SomeSubNetwork\",\n+\t\t},\n+\t}\n+}\n+\n+func dummyConstructionHashRequest(txHash string) *types.ConstructionHashRequest {\n+\treturn &types.ConstructionHashRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSignedTransaction: txHash,\n+\t}\n+}\n+\n+func dummyConstructionParseRequest(txHash string, signed bool) *types.ConstructionParseRequest {\n+\treturn &types.ConstructionParseRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSigned:            signed,\n+\t\tTransaction:       txHash,\n+\t}\n+}\n+\n+func dummyPayloadsRequest(operations []*types.Operation) *types.ConstructionPayloadsRequest {\n+\treturn &types.ConstructionPayloadsRequest{\n+\t\tOperations: operations,\n+\t}\n+}\n+\n+func TestNewConstructionAPIService(t *testing.T) {\n+\tassert.IsType(t, &ConstructionAPIService{}, NewConstructionAPIService())\n+}\n+\n+func TestConstructionCombine(t *testing.T) {\n+\t// given:\n+\texpectedConstructionCombineResponse := &types.ConstructionCombineResponse{\n+\t\tSignedTransaction: validSignedTxHash,\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, dummyConstructionCombineRequest())\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionCombineResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionCombineThrowsWithMultipleSignatures(t *testing.T) {\n+\t// given:\n+\texampleConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleConstructionCombineRequest.Signatures = []*types.Signature{\n+\t\t{}, {},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.MultipleSignaturesPresent], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = invalidTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenUnmarshallFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = unmarshableTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionUnmarshallingFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWithInvalidPublicKey(t *testing.T) {\n+\t// given:\n+\texampleInvalidPublicKeyConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidPublicKeyConstructionCombineRequest.Signatures[0].PublicKey = &types.PublicKey{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidPublicKeyConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidPublicKey], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenSignatureIsNotVerified(t *testing.T) {\n+\t// given:\n+\texampleInvalidSigningPayloadConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidSigningPayloadConstructionCombineRequest.Signatures[0].SigningPayload = &types.SigningPayload{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidSigningPayloadConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidSignatureVerification], e)\n+}\n+\n+func TestConstructionDerive(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionDerive(nil, nil)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.NotImplemented], e)\n+}\n+\n+func TestConstructionHash(t *testing.T) {\n+\t// given:\n+\ttxIdentifierHash := \"0x9768d458c755befcda5c6fca07e9f7693b94c429f9c414b0cea07163c402ddd44d1108f89b190d0dcabc423a3d45696d\"\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(validSignedTxHash)\n+\texpectedConstructHashResponse := &types.TransactionIdentifierResponse{\n+\t\tTransactionIdentifier: &types.TransactionIdentifier{Hash: txIdentifierHash},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructHashResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionHashThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(invalidTxHash)\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionMetadata(t *testing.T) {\n+\t// given:\n+\texpectedResponse := &types.ConstructionMetadataResponse{\n+\t\tMetadata: make(map[string]interface{}),\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionMetadata(nil, nil)\n+\n+\t// then:\n+\tassert.Equal(t, expectedResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParse(t *testing.T) {\n+\t// given:\n+\texampleConstructionParseRequest := dummyConstructionParseRequest(validUnsignedTxHash, false)\n+\texpectedConstructionParseResponse := &types.ConstructionParseResponse{\n+\t\tOperations: []*types.Operation{\n+\t\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t\t},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, exampleConstructionParseRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionParseResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParseSigned(t *testing.T) {\n+\t// given:\n+\texampleConstructionParseRequest := dummyConstructionParseRequest(validSignedTxHash, true)\n+\texpectedConstructionParseResponse := &types.ConstructionParseResponse{\n+\t\tOperations: []*types.Operation{\n+\t\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t\t},\n+\t\tAccountIdentifierSigners: []*types.AccountIdentifier{\n+\t\t\t{\n+\t\t\t\tAddress: publicKeyBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, exampleConstructionParseRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionParseResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParseThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, dummyConstructionParseRequest(invalidTxHash, false))\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionParseThrowsWhenUnmarshallFails(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, dummyConstructionParseRequest(unmarshableTxHash, false))\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionUnmarshallingFailed], e)\n+}\n+\n+func TestConstructionPayloads(t *testing.T) {\n+\t// given:\n+\texpectedDecodedBytes, _ := hex.DecodeString(unmarshableTxHash)\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\texpectedPayloadsResponse := &types.ConstructionPayloadsResponse{\n+\t\tUnsignedTransaction: \"0x1a00223d0a140a0c08faf3b5fc0510c681d7d303120418e3cc13120218061880c2d72f2202087872180a160a090a0418b9c30710c8010a090a0418e3cc1310c701\",\n+\t\tPayloads: []*types.SigningPayload{\n+\t\t\t{\n+\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\tAddress: \"0.0.123352\",\n+\t\t\t\t},\n+\t\t\t\tBytes: expectedDecodedBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionPayloads(nil, dummyPayloadsRequest(operations))\n+\n+\t// then:\n+\t// here we do not assert the whole response object to equal the expected one, because invocation of this method appends a unique timestamp to the result, thus making the signed TX and Bytes unique and non-assertable.\n+\tassert.Equal(t, expectedPayloadsResponse.Payloads[0].AccountIdentifier.Address, res.Payloads[0].AccountIdentifier.Address)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionPayloadsThrowsWhenInvalidOperationsSum(t *testing.T) {\n+\t// given:\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123321\", \"1000\"),\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionPayloads(nil, dummyPayloadsRequest(operations))\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.IsType(t, &types.Error{}, e)\n+}\n+\n+func TestConstructionPayloadsThrowsWhenInvalidAccount(t *testing.T) {\n+\t// given:\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"23321\", \"1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"23321\", \"-1000\"),\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionPayloads(nil, dummyPayloadsRequest(operations))\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidAccount], e)\n+}\n+\n+func TestConstructionSubmitThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleConstructionSubmitRequest := &types.ConstructionSubmitRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSignedTransaction: invalidTxHash,\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionSubmit(nil, exampleConstructionSubmitRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionSubmitThrowsWhenUnmarshalBinaryFails(t *testing.T) {\n+\tconstructionSubmitTxHash := \"0xfc2267c53ef8a27e2ab65f0a6b5e5607ba33b9c8c8f7304d8cb4a77aee19107d\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86dc63ba21f1d0722be1b0b26b53222445f34dc2"}, "originalPosition": 424}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwOTA2MTAxOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxODo0NTo0OFrOHodn9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxODo0NTo0OFrOHodn9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE5MDQ1NQ==", "bodyText": "it's about the implementation of ConstructionPayloads not the test case:\nshould ConstructionPayloads fail early when supplied with an empty Operations slice?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1169#discussion_r512190455", "createdAt": "2020-10-26T18:45:48Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "diffHunk": "@@ -0,0 +1,461 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package construction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"testing\"\n+)\n+\n+var (\n+\tvalidUnsignedTx   = \"0x1a00223d0a140a0c0891d0fef905109688f3a701120418d8c307120218061880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tvalidSignedTx     = \"0x1a660a640a20d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade1a40967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tinvalidTxHexStr   = \"InvalidTxHexString\"\n+\tcorruptedTxHexStr = \"0x6767\"\n+\tpublicKeyBytes    = \"d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade\"\n+)\n+\n+func dummyConstructionCombineRequest() *types.ConstructionCombineRequest {\n+\tunsignedTxHash := \"0x1a00223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tsigningPayloadBytes := \"967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507\"\n+\tsignatureBytes := \"0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\n+\treturn dummyConstructionCombineRequestWith(\n+\t\tunsignedTxHash,\n+\t\tsigningPayloadBytes,\n+\t\tpublicKeyBytes,\n+\t\tsignatureBytes,\n+\t)\n+}\n+\n+func dummyConstructionPreprocessRequest(valid bool) *types.ConstructionPreprocessRequest {\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\tif !valid {\n+\t\toperations = append(\n+\t\t\toperations,\n+\t\t\tdummyOperation(3, \"CRYPTOTRANSFER\", \"123532\", \"-5000\"),\n+\t\t)\n+\t}\n+\n+\treturn &types.ConstructionPreprocessRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tOperations:        operations,\n+\t}\n+}\n+\n+func dummyConstructionCombineRequestWith(unsignedTxHash, signingPayloadBytes, publicKeyBytes, signatureBytes string) *types.ConstructionCombineRequest {\n+\tdecodedSigningPayloadBytes, e1 := hex.DecodeString(signingPayloadBytes)\n+\tdecodedPublicKeyBytes, e2 := hex.DecodeString(publicKeyBytes)\n+\tdecodedSignatureBytes, e3 := hex.DecodeString(signatureBytes)\n+\n+\tif e1 != nil || e2 != nil || e3 != nil {\n+\t\treturn nil\n+\t}\n+\n+\treturn &types.ConstructionCombineRequest{\n+\t\tNetworkIdentifier:   networkIdentifier(),\n+\t\tUnsignedTransaction: unsignedTxHash,\n+\t\tSignatures: []*types.Signature{\n+\t\t\t{\n+\t\t\t\tSigningPayload: &types.SigningPayload{\n+\t\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\t\tAddress:  \"0.0.123352\",\n+\t\t\t\t\t\tMetadata: nil,\n+\t\t\t\t\t},\n+\t\t\t\t\tBytes:         decodedSigningPayloadBytes,\n+\t\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\t},\n+\t\t\t\tPublicKey: &types.PublicKey{\n+\t\t\t\t\tBytes:     decodedPublicKeyBytes,\n+\t\t\t\t\tCurveType: \"edwards25519\",\n+\t\t\t\t},\n+\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\tBytes:         decodedSignatureBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func dummyOperation(index int64, transferType, account, amount string) *types.Operation {\n+\treturn &types.Operation{\n+\t\tOperationIdentifier: &types.OperationIdentifier{\n+\t\t\tIndex: index,\n+\t\t},\n+\t\tType: transferType,\n+\t\tAccount: &types.AccountIdentifier{\n+\t\t\tAddress: account,\n+\t\t},\n+\t\tAmount: &types.Amount{\n+\t\t\tValue: amount,\n+\t\t\tCurrency: &types.Currency{\n+\t\t\t\tSymbol:   \"HBAR\",\n+\t\t\t\tDecimals: 8,\n+\t\t\t\tMetadata: map[string]interface{}{\n+\t\t\t\t\t\"issuer\": \"Hedera\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func networkIdentifier() *types.NetworkIdentifier {\n+\treturn &types.NetworkIdentifier{\n+\t\tBlockchain: \"SomeBlockchain\",\n+\t\tNetwork:    \"SomeNetwork\",\n+\t\tSubNetworkIdentifier: &types.SubNetworkIdentifier{\n+\t\t\tNetwork: \"SomeSubNetwork\",\n+\t\t},\n+\t}\n+}\n+\n+func dummyConstructionHashRequest(signedTx string) *types.ConstructionHashRequest {\n+\treturn &types.ConstructionHashRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSignedTransaction: signedTx,\n+\t}\n+}\n+\n+func dummyConstructionParseRequest(txHash string, signed bool) *types.ConstructionParseRequest {\n+\treturn &types.ConstructionParseRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSigned:            signed,\n+\t\tTransaction:       txHash,\n+\t}\n+}\n+\n+func dummyPayloadsRequest(operations []*types.Operation) *types.ConstructionPayloadsRequest {\n+\treturn &types.ConstructionPayloadsRequest{\n+\t\tOperations: operations,\n+\t}\n+}\n+\n+func TestNewConstructionAPIService(t *testing.T) {\n+\tassert.IsType(t, &ConstructionAPIService{}, NewConstructionAPIService())\n+}\n+\n+func TestConstructionCombine(t *testing.T) {\n+\t// given:\n+\texpectedConstructionCombineResponse := &types.ConstructionCombineResponse{\n+\t\tSignedTransaction: validSignedTx,\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, dummyConstructionCombineRequest())\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionCombineResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionCombineThrowsWithMultipleSignatures(t *testing.T) {\n+\t// given:\n+\texampleConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleConstructionCombineRequest.Signatures = []*types.Signature{\n+\t\t{}, {},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.MultipleSignaturesPresent], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleCorruptedTxHexStrConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleCorruptedTxHexStrConstructionCombineRequest.UnsignedTransaction = invalidTxHexStr\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleCorruptedTxHexStrConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenUnmarshallFails(t *testing.T) {\n+\t// given:\n+\texampleCorruptedTxHexStrConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleCorruptedTxHexStrConstructionCombineRequest.UnsignedTransaction = corruptedTxHexStr\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleCorruptedTxHexStrConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionUnmarshallingFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWithInvalidPublicKey(t *testing.T) {\n+\t// given:\n+\texampleInvalidPublicKeyConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidPublicKeyConstructionCombineRequest.Signatures[0].PublicKey = &types.PublicKey{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidPublicKeyConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidPublicKey], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenSignatureIsNotVerified(t *testing.T) {\n+\t// given:\n+\texampleInvalidSigningPayloadConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidSigningPayloadConstructionCombineRequest.Signatures[0].SigningPayload = &types.SigningPayload{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidSigningPayloadConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidSignatureVerification], e)\n+}\n+\n+func TestConstructionDerive(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionDerive(nil, nil)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.NotImplemented], e)\n+}\n+\n+func TestConstructionHash(t *testing.T) {\n+\t// given:\n+\tvalidSignedTransaction := \"0x9768d458c755befcda5c6fca07e9f7693b94c429f9c414b0cea07163c402ddd44d1108f89b190d0dcabc423a3d45696d\"\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(validSignedTx)\n+\texpectedConstructHashResponse := &types.TransactionIdentifierResponse{\n+\t\tTransactionIdentifier: &types.TransactionIdentifier{Hash: validSignedTransaction},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructHashResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionHashThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(invalidTxHexStr)\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionMetadata(t *testing.T) {\n+\t// given:\n+\texpectedResponse := &types.ConstructionMetadataResponse{\n+\t\tMetadata: make(map[string]interface{}),\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionMetadata(nil, nil)\n+\n+\t// then:\n+\tassert.Equal(t, expectedResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParse(t *testing.T) {\n+\t// given:\n+\texampleConstructionParseRequest := dummyConstructionParseRequest(validUnsignedTx, false)\n+\texpectedConstructionParseResponse := &types.ConstructionParseResponse{\n+\t\tOperations: []*types.Operation{\n+\t\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t\t},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, exampleConstructionParseRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionParseResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParseSigned(t *testing.T) {\n+\t// given:\n+\texampleConstructionParseRequest := dummyConstructionParseRequest(validSignedTx, true)\n+\texpectedConstructionParseResponse := &types.ConstructionParseResponse{\n+\t\tOperations: []*types.Operation{\n+\t\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t\t},\n+\t\tAccountIdentifierSigners: []*types.AccountIdentifier{\n+\t\t\t{\n+\t\t\t\tAddress: publicKeyBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, exampleConstructionParseRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionParseResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParseThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, dummyConstructionParseRequest(invalidTxHexStr, false))\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionParseThrowsWhenUnmarshallFails(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, dummyConstructionParseRequest(corruptedTxHexStr, false))\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionUnmarshallingFailed], e)\n+}\n+\n+func TestConstructionPayloads(t *testing.T) {\n+\t// given:\n+\tvar expectedNilBytes []byte\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\texpectedPayloadsResponse := &types.ConstructionPayloadsResponse{\n+\t\tUnsignedTransaction: \"0x1a00223d0a140a0c08faf3b5fc0510c681d7d303120418e3cc13120218061880c2d72f2202087872180a160a090a0418b9c30710c8010a090a0418e3cc1310c701\",\n+\t\tPayloads: []*types.SigningPayload{\n+\t\t\t{\n+\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\tAddress: \"0.0.123352\",\n+\t\t\t\t},\n+\t\t\t\tBytes: expectedNilBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionPayloads(nil, dummyPayloadsRequest(operations))\n+\n+\t// then:\n+\t// here we do not assert the whole response object to equal the expected one, because invocation of this method appends a unique timestamp to the result, thus making the signed TX and Bytes unique and non-assertable.\n+\tassert.Equal(t, expectedPayloadsResponse.Payloads[0].AccountIdentifier.Address, res.Payloads[0].AccountIdentifier.Address)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionPayloadsThrowsWhenInvalidOperationsSum(t *testing.T) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ec6babb5be3914b3f04699b85390beacd0635b8"}, "originalPosition": 379}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1591, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}