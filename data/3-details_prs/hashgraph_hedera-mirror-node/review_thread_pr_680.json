{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAxNzgxMzM1", "number": 680, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNDoxNzozOVrODxQYlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxOToyMDozMlrODxWu9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyOTc1MjUyOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/CryptoCreateTransactionHandler.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNDoxNzozOVrOGEn4mQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxOTowMjo0NFrOGExXHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUwMDk1Mw==", "bodyText": "nit: isn't this duplicate code with ContractCreateTransactionHandler.updateEntity()\nIf so shouldn't the AutoRenew, Key and proxy account logic from the TransactionBody be shared and the differences be called?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407500953", "createdAt": "2020-04-13T14:17:39Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/CryptoCreateTransactionHandler.java", "diffHunk": "@@ -39,4 +44,26 @@ public EntityId getEntityId(RecordItem recordItem) {\n     public boolean updatesEntity() {\n         return true;\n     }\n+\n+    @Override\n+    public void updateTransaction(Transaction transaction, RecordItem recordItem) {\n+        transaction.setInitialBalance(recordItem.getTransactionBody().getCryptoCreateAccount().getInitialBalance());\n+    }\n+\n+    @Override\n+    public void updateEntity(Entities entity, RecordItem recordItem) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8686f1d495948844ff363344cad7fb9d4124a4c6"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYzNDgyMw==", "bodyText": "wanted to, you know i really don't like duplication of code chunks :)\nBut not possible here since we can't write something like\n<T> void processCommonFieldsForCreate(T transactionBody) {\n  ....common logic\n}\n\nIf there's another simple way, lemme know.\nDitto for other similar comments. Will leave this one open.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407634823", "createdAt": "2020-04-13T18:24:10Z", "author": {"login": "apeksharma"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/CryptoCreateTransactionHandler.java", "diffHunk": "@@ -39,4 +44,26 @@ public EntityId getEntityId(RecordItem recordItem) {\n     public boolean updatesEntity() {\n         return true;\n     }\n+\n+    @Override\n+    public void updateTransaction(Transaction transaction, RecordItem recordItem) {\n+        transaction.setInitialBalance(recordItem.getTransactionBody().getCryptoCreateAccount().getInitialBalance());\n+    }\n+\n+    @Override\n+    public void updateEntity(Entities entity, RecordItem recordItem) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUwMDk1Mw=="}, "originalCommit": {"oid": "8686f1d495948844ff363344cad7fb9d4124a4c6"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY1NjIyMQ==", "bodyText": "one thing could be creating utility (not base class) like\nvoid updateEntityAutoRenewPeriod(Entity entity, Duration autoRenewPeriod) {\n  if (autoRenewPeriod.getSeconds() != 0) { // proxy for hasAutoRenewPeriod()\n    entity.setAutoRenewPeriod(autoRenewPeriod.getSeconds());\n  }\n\nThen only use following in TH.updateEntity() fns.\nTransactionHandlerUtility.updateEntityAutoRenewPeriod(entity, txMessage.getAutoRenewPeriod()\nHowever, i don't think it's any better, so left it as such.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407656221", "createdAt": "2020-04-13T19:02:44Z", "author": {"login": "apeksharma"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/CryptoCreateTransactionHandler.java", "diffHunk": "@@ -39,4 +44,26 @@ public EntityId getEntityId(RecordItem recordItem) {\n     public boolean updatesEntity() {\n         return true;\n     }\n+\n+    @Override\n+    public void updateTransaction(Transaction transaction, RecordItem recordItem) {\n+        transaction.setInitialBalance(recordItem.getTransactionBody().getCryptoCreateAccount().getInitialBalance());\n+    }\n+\n+    @Override\n+    public void updateEntity(Entities entity, RecordItem recordItem) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUwMDk1Mw=="}, "originalCommit": {"oid": "8686f1d495948844ff363344cad7fb9d4124a4c6"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyOTc1NDkwOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/CryptoUpdateTransactionHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNDoxODoyMVrOGEn59w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNDoxODoyMVrOGEn59w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUwMTMwMw==", "bodyText": "Same comments. Good amount of duplicate logic shared with ContractUpdateTransactionHandler.updateEntity()", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407501303", "createdAt": "2020-04-13T14:18:21Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/CryptoUpdateTransactionHandler.java", "diffHunk": "@@ -39,4 +44,24 @@ public EntityId getEntityId(RecordItem recordItem) {\n     public boolean updatesEntity() {\n         return true;\n     }\n+\n+    @Override\n+    public void updateEntity(Entities entity, RecordItem recordItem) {\n+        CryptoUpdateTransactionBody txMessage = recordItem.getTransactionBody().getCryptoUpdateAccount();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8686f1d495948844ff363344cad7fb9d4124a4c6"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyOTc2MDQxOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/FileUpdateTransactionHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNDoxOTo1MFrOGEn9QQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNDoxOTo1MFrOGEn9QQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUwMjE0NQ==", "bodyText": "Duplicate code with FileCreateTransactionHandler. updateEntity()", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407502145", "createdAt": "2020-04-13T14:19:50Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/FileUpdateTransactionHandler.java", "diffHunk": "@@ -39,4 +42,15 @@ public EntityId getEntityId(RecordItem recordItem) {\n     public boolean updatesEntity() {\n         return true;\n     }\n+\n+    @Override\n+    public void updateEntity(Entities entity, RecordItem recordItem) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8686f1d495948844ff363344cad7fb9d4124a4c6"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyOTc3NjI5OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/repository/EntityRepositoryCustomImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNDoyNDoxN1rOGEoGwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxODo0NTo0M1rOGEwx0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUwNDU3Ng==", "bodyText": "nit: you call entityId.getId() 3 times. Might as well just get it once and use it 3 times.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407504576", "createdAt": "2020-04-13T14:24:17Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/repository/EntityRepositoryCustomImpl.java", "diffHunk": "@@ -49,8 +49,21 @@\n         return results;\n     }\n \n-    public <S extends Entities> EntityId saveAndCacheEntityId(S entity) {\n-        var saved = entityRepository.save(entity);\n-        return entityRepository.cache(saved.toEntityId());\n+    /**\n+     * @param entityId for which the id needs to be looked up (from cache/repo). If no id is found, the the entity is\n+     *                 inserted into the repo and the newly minted id is returned.\n+     * @return looked up/newly minted id of the given entityId.\n+     */\n+    public long lookupOrCreateId(EntityId entityId) {\n+        if (entityId.getId() != null && entityId.getId() != 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8686f1d495948844ff363344cad7fb9d4124a4c6"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY0NjY3Mw==", "bodyText": "done.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407646673", "createdAt": "2020-04-13T18:45:43Z", "author": {"login": "apeksharma"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/repository/EntityRepositoryCustomImpl.java", "diffHunk": "@@ -49,8 +49,21 @@\n         return results;\n     }\n \n-    public <S extends Entities> EntityId saveAndCacheEntityId(S entity) {\n-        var saved = entityRepository.save(entity);\n-        return entityRepository.cache(saved.toEntityId());\n+    /**\n+     * @param entityId for which the id needs to be looked up (from cache/repo). If no id is found, the the entity is\n+     *                 inserted into the repo and the newly minted id is returned.\n+     * @return looked up/newly minted id of the given entityId.\n+     */\n+    public long lookupOrCreateId(EntityId entityId) {\n+        if (entityId.getId() != null && entityId.getId() != 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUwNDU3Ng=="}, "originalCommit": {"oid": "8686f1d495948844ff363344cad7fb9d4124a4c6"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMDY0NjY5OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/repository/EntityRepositoryTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxODozNzo1M1rOGEwg3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMDo0NDoyMlrOGE0oEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY0MjMzNQ==", "bodyText": "Would prefer not storing these as variables as they're not immutable. Hibernate may or may not populate id on object passed to save. Would prefer helper method entityId()", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407642335", "createdAt": "2020-04-13T18:37:53Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/repository/EntityRepositoryTest.java", "diffHunk": "@@ -21,13 +21,16 @@\n  */\n \n import static org.assertj.core.api.Assertions.assertThat;\n-import static org.junit.jupiter.api.Assertions.*;\n \n import org.junit.jupiter.api.Test;\n \n import com.hedera.mirror.importer.domain.Entities;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n \n public class EntityRepositoryTest extends AbstractRepositoryTest {\n+    private static final EntityId ENTITY_ID = new EntityId(null, 1L, 2L, 3L, EntityTypeEnum.ACCOUNT.getId());\n+    private static final Entities ENTITY = ENTITY_ID.toEntity();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8686f1d495948844ff363344cad7fb9d4124a4c6"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwOTcxMg==", "bodyText": "done.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407709712", "createdAt": "2020-04-13T20:44:22Z", "author": {"login": "apeksharma"}, "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/repository/EntityRepositoryTest.java", "diffHunk": "@@ -21,13 +21,16 @@\n  */\n \n import static org.assertj.core.api.Assertions.assertThat;\n-import static org.junit.jupiter.api.Assertions.*;\n \n import org.junit.jupiter.api.Test;\n \n import com.hedera.mirror.importer.domain.Entities;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n \n public class EntityRepositoryTest extends AbstractRepositoryTest {\n+    private static final EntityId ENTITY_ID = new EntityId(null, 1L, 2L, 3L, EntityTypeEnum.ACCOUNT.getId());\n+    private static final Entities ENTITY = ENTITY_ID.toEntity();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY0MjMzNQ=="}, "originalCommit": {"oid": "8686f1d495948844ff363344cad7fb9d4124a4c6"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMDY1ODgwOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/transactionhandler/AbstractTransactionHandlerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxODo0MTozNlrOGEwonQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMDozMzo1MFrOGE0Szg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY0NDMxNw==", "bodyText": "Would prefer transactionBody and transactionRecord not be stored as it's confusing for sub-classes if they should use getDefaultTransactionBody()/getDefaultTransactionRecord() or use default stored in parent. It also couples the two unnecessarily.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407644317", "createdAt": "2020-04-13T18:41:36Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/transactionhandler/AbstractTransactionHandlerTest.java", "diffHunk": "@@ -28,14 +28,19 @@\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n import org.junit.jupiter.api.TestInfo;\n+import org.mockito.Mock;\n \n import com.hedera.mirror.importer.domain.EntityId;\n import com.hedera.mirror.importer.domain.EntityTypeEnum;\n import com.hedera.mirror.importer.parser.domain.RecordItem;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n \n public abstract class AbstractTransactionHandlerTest {\n     protected static final Long DEFAULT_ENTITY_NUM = 100L;\n-\n+    @Mock\n+    protected EntityRepository entityRepository;\n+    protected TransactionBody transactionBody;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8686f1d495948844ff363344cad7fb9d4124a4c6"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwNDI3MA==", "bodyText": "yeah, right now they are redundant. Removed.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407704270", "createdAt": "2020-04-13T20:33:50Z", "author": {"login": "apeksharma"}, "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/transactionhandler/AbstractTransactionHandlerTest.java", "diffHunk": "@@ -28,14 +28,19 @@\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n import org.junit.jupiter.api.TestInfo;\n+import org.mockito.Mock;\n \n import com.hedera.mirror.importer.domain.EntityId;\n import com.hedera.mirror.importer.domain.EntityTypeEnum;\n import com.hedera.mirror.importer.parser.domain.RecordItem;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n \n public abstract class AbstractTransactionHandlerTest {\n     protected static final Long DEFAULT_ENTITY_NUM = 100L;\n-\n+    @Mock\n+    protected EntityRepository entityRepository;\n+    protected TransactionBody transactionBody;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY0NDMxNw=="}, "originalCommit": {"oid": "8686f1d495948844ff363344cad7fb9d4124a4c6"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMDc5Mjg1OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordItemParser.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxOToyMDozMlrOGEx8EA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMToxMDozNlrOGE1djg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY2NTY4MA==", "bodyText": "Should do tx.setEntity(entityRepository.save(entity)); as Hibernate can return a proxied object. Can move this logic into getEntity() so that it either retrieves or create and saves the entity.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407665680", "createdAt": "2020-04-13T19:20:32Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordItemParser.java", "diffHunk": "@@ -115,185 +110,33 @@ public void onItem(RecordItem recordItem) throws ImporterException {\n             return;\n         }\n \n-        // TODO: updatesEntity() is true for all and only the transaction types which are in body.has*() if-else\n-        //   conditions below. This is temporary to keep scope of changes in single PR limited and will be fixed in\n-        //   followup PR quickly. All if-else conditions will be replaced by:\n-        //     transactionHandler.updateEntity(entity, recordItem).\n-        Entities entity = null; // Entity used when t_entities row must be updated.\n-        if (transactionHandler.updatesEntity()) {\n-            entity = getEntity(entityId);\n-        }\n-\n-        // Only when transaction is successful:\n-        // - Fields of 'entity' will be updated. Fields are not updated for failed transactions since 'entity' may be an\n-        //   instance from cache and reused in future.\n-        // - proxyAccountId/autoRenewAccountId: If present, the account's id will be looked up (from big cache)\n-        //   or created immediately.\n+        boolean isSuccessful = isSuccessful(txRecord);\n+        Transaction tx = buildTransaction(consensusNs, recordItem);\n+        transactionHandler.updateTransaction(tx, recordItem);\n \n-        // For all transactions:\n-        // - 'entity' (may have been updated or not) is always inserted into repo since\n+        // Irrespective of transaction failure/success, if entityId is not null, it will be inserted into repo since:\n         //   (1) it is guaranteed to be valid entity on network (validated to exist in pre-consensus checks)\n         //   (2) fk_cud_entity_id is foreign key in t_transactions\n-        boolean doUpdateEntity = isSuccessful(txRecord);\n-        long initialBalance = 0;\n-\n-        if (entity == null) {\n-            // Do nothing. This can be true if transaction is of type that doesn't update the entity. Or, if the\n-            // transaction doesn't contain non-zero entity id (i.e. with entityNum != 0).\n-        } else if (body.hasContractCreateInstance()) {\n-            if (txRecord.getReceipt().hasContractID()) { // implies SUCCESS\n-                ContractCreateTransactionBody txMessage = body.getContractCreateInstance();\n-                setProxyAccountID(txMessage.getProxyAccountID(), entity);\n-                if (txMessage.hasAutoRenewPeriod()) {\n-                    entity.setAutoRenewPeriod(txMessage.getAutoRenewPeriod().getSeconds());\n-                }\n-                // Can't clear memo on contracts. 0 length indicates no change\n-                if (txMessage.getMemo() != null && txMessage.getMemo().length() > 0) {\n-                    entity.setMemo(txMessage.getMemo());\n-                }\n-\n-                if (txMessage.hasAdminKey()) {\n-                    entity.setKey(txMessage.getAdminKey().toByteArray());\n-                }\n-            }\n-\n-            initialBalance = body.getContractCreateInstance().getInitialBalance();\n-        } else if (body.hasContractDeleteInstance()) {\n-            if (body.getContractDeleteInstance().hasContractID()) {\n-                if (doUpdateEntity) {\n-                    entity.setDeleted(true);\n-                }\n-            }\n-        } else if (body.hasContractUpdateInstance()) {\n-            ContractUpdateTransactionBody txMessage = body.getContractUpdateInstance();\n-            if (doUpdateEntity) {\n-                setProxyAccountID(txMessage.getProxyAccountID(), entity);\n-                if (txMessage.hasExpirationTime()) {\n-                    entity.setExpiryTimeNs(Utility.timestampInNanosMax(txMessage.getExpirationTime()));\n-                }\n-                if (txMessage.hasAutoRenewPeriod()) {\n-                    entity.setAutoRenewPeriod(txMessage.getAutoRenewPeriod().getSeconds());\n-                }\n-                if (txMessage.hasAdminKey()) {\n-                    entity.setKey(txMessage.getAdminKey().toByteArray());\n-                }\n-                // Can't clear memo on contracts. 0 length indicates no change\n-                if (txMessage.getMemo() != null && txMessage.getMemo().length() > 0) {\n-                    entity.setMemo(txMessage.getMemo());\n-                }\n-            }\n-        } else if (body.hasCryptoCreateAccount()) {\n-            if (txRecord.getReceipt().hasAccountID()) { // Implies SUCCESS\n-                CryptoCreateTransactionBody txMessage = body.getCryptoCreateAccount();\n-                setProxyAccountID(txMessage.getProxyAccountID(), entity);\n-                if (txMessage.hasAutoRenewPeriod()) {\n-                    entity.setAutoRenewPeriod(txMessage.getAutoRenewPeriod().getSeconds());\n-                }\n-                if (txMessage.hasKey()) {\n-                    entity.setKey(txMessage.getKey().toByteArray());\n-                }\n-            }\n-\n-            initialBalance = body.getCryptoCreateAccount().getInitialBalance();\n-        } else if (body.hasCryptoDelete()) {\n-            if (body.getCryptoDelete().hasDeleteAccountID()) {\n-                if (doUpdateEntity) {\n-                    entity.setDeleted(true);\n-                }\n-            }\n-        } else if (body.hasCryptoUpdateAccount()) {\n-            CryptoUpdateTransactionBody txMessage = body.getCryptoUpdateAccount();\n-            if (doUpdateEntity) {\n-                setProxyAccountID(txMessage.getProxyAccountID(), entity);\n-                if (txMessage.hasExpirationTime()) {\n-                    entity.setExpiryTimeNs(Utility.timestampInNanosMax(txMessage.getExpirationTime()));\n-                }\n-                if (txMessage.hasAutoRenewPeriod()) {\n-                    entity.setAutoRenewPeriod(txMessage.getAutoRenewPeriod().getSeconds());\n-                }\n-                if (txMessage.hasKey()) {\n-                    entity.setKey(txMessage.getKey().toByteArray());\n-                }\n-            }\n-        } else if (body.hasFileCreate()) {\n-            if (txRecord.getReceipt().hasFileID()) { // Implies SUCCESS\n-                FileCreateTransactionBody txMessage = body.getFileCreate();\n-                if (txMessage.hasExpirationTime()) {\n-                    entity.setExpiryTimeNs(Utility.timestampInNanosMax(txMessage.getExpirationTime()));\n-                }\n-\n-                if (txMessage.hasKeys()) {\n-                    entity.setKey(txMessage.getKeys().toByteArray());\n-                }\n-            }\n-        } else if (body.hasFileDelete()) {\n-            if (body.getFileDelete().hasFileID()) {\n-                if (doUpdateEntity) {\n-                    entity.setDeleted(true);\n-                }\n-            }\n-        } else if (body.hasFileUpdate()) {\n-            FileUpdateTransactionBody txMessage = body.getFileUpdate();\n-            if (doUpdateEntity) {\n-                if (txMessage.hasExpirationTime()) {\n-                    entity.setExpiryTimeNs(Utility.timestampInNanosMax(txMessage.getExpirationTime()));\n-                }\n-\n-                if (txMessage.hasKeys()) {\n-                    entity.setKey(txMessage.getKeys().toByteArray());\n-                }\n-            }\n-        } else if (body.hasSystemDelete()) {\n-            if (doUpdateEntity) {\n-                entity.setDeleted(true);\n-            }\n-        } else if (body.hasSystemUndelete()) {\n-            if (doUpdateEntity) {\n-                entity.setDeleted(false);\n-            }\n-        } else if (body.hasConsensusCreateTopic()) {\n-            consensusCreateTopicUpdateEntity(entity, body, txRecord);\n-        } else if (body.hasConsensusUpdateTopic()) {\n-            consensusUpdateTopicUpdateEntity(entity, body, txRecord);\n-        } else if (body.hasConsensusDeleteTopic()) {\n-            consensusDeleteTopicUpdateEntity(entity, body, txRecord);\n-        }\n-\n-        TransactionID transactionID = body.getTransactionID();\n-        long validDurationSeconds = body.hasTransactionValidDuration() ? body.getTransactionValidDuration()\n-                .getSeconds() : null;\n-        long validStartNs = Utility.timeStampInNanos(transactionID.getTransactionValidStart());\n-        AccountID payerAccountId = transactionID.getAccountID();\n-\n-        com.hedera.mirror.importer.domain.Transaction tx = new com.hedera.mirror.importer.domain.Transaction();\n-        tx.setChargedTxFee(txRecord.getTransactionFee());\n-        tx.setConsensusNs(consensusNs);\n-        tx.setInitialBalance(initialBalance);\n-        tx.setMemo(body.getMemo().getBytes());\n-        tx.setMaxFee(body.getTransactionFee());\n-        tx.setResult(txRecord.getReceipt().getStatusValue());\n-        tx.setType(transactionType);\n-        tx.setTransactionBytes(parserProperties.getPersist().isTransactionBytes() ?\n-                recordItem.getTransactionBytes() : null);\n-        tx.setTransactionHash(txRecord.getTransactionHash().toByteArray());\n-        tx.setValidDurationSeconds(validDurationSeconds);\n-        tx.setValidStartNs(validStartNs);\n-        if (entity != null) {\n+        //\n+        // Additionally, if transaction is successful:\n+        // - Fields of 'entity' will be updated.\n+        // - proxyAccountId/autoRenewAccountId: If present, the account's id are looked up (from big cache) or created\n+        //   immediately in TransactionHandler.updateEntity(..).\n+        if (transactionHandler.updatesEntity() && isSuccessful && entityId != null) {\n+            Entities entity = getEntity(entityId);\n+            transactionHandler.updateEntity(entity, recordItem);\n             tx.setEntity(entity);\n             entityRepository.save(entity);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "617acd2c6adcc310c45ba6841827f8808b7e265d"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyMzQwNg==", "bodyText": "Done.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407723406", "createdAt": "2020-04-13T21:10:36Z", "author": {"login": "apeksharma"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordItemParser.java", "diffHunk": "@@ -115,185 +110,33 @@ public void onItem(RecordItem recordItem) throws ImporterException {\n             return;\n         }\n \n-        // TODO: updatesEntity() is true for all and only the transaction types which are in body.has*() if-else\n-        //   conditions below. This is temporary to keep scope of changes in single PR limited and will be fixed in\n-        //   followup PR quickly. All if-else conditions will be replaced by:\n-        //     transactionHandler.updateEntity(entity, recordItem).\n-        Entities entity = null; // Entity used when t_entities row must be updated.\n-        if (transactionHandler.updatesEntity()) {\n-            entity = getEntity(entityId);\n-        }\n-\n-        // Only when transaction is successful:\n-        // - Fields of 'entity' will be updated. Fields are not updated for failed transactions since 'entity' may be an\n-        //   instance from cache and reused in future.\n-        // - proxyAccountId/autoRenewAccountId: If present, the account's id will be looked up (from big cache)\n-        //   or created immediately.\n+        boolean isSuccessful = isSuccessful(txRecord);\n+        Transaction tx = buildTransaction(consensusNs, recordItem);\n+        transactionHandler.updateTransaction(tx, recordItem);\n \n-        // For all transactions:\n-        // - 'entity' (may have been updated or not) is always inserted into repo since\n+        // Irrespective of transaction failure/success, if entityId is not null, it will be inserted into repo since:\n         //   (1) it is guaranteed to be valid entity on network (validated to exist in pre-consensus checks)\n         //   (2) fk_cud_entity_id is foreign key in t_transactions\n-        boolean doUpdateEntity = isSuccessful(txRecord);\n-        long initialBalance = 0;\n-\n-        if (entity == null) {\n-            // Do nothing. This can be true if transaction is of type that doesn't update the entity. Or, if the\n-            // transaction doesn't contain non-zero entity id (i.e. with entityNum != 0).\n-        } else if (body.hasContractCreateInstance()) {\n-            if (txRecord.getReceipt().hasContractID()) { // implies SUCCESS\n-                ContractCreateTransactionBody txMessage = body.getContractCreateInstance();\n-                setProxyAccountID(txMessage.getProxyAccountID(), entity);\n-                if (txMessage.hasAutoRenewPeriod()) {\n-                    entity.setAutoRenewPeriod(txMessage.getAutoRenewPeriod().getSeconds());\n-                }\n-                // Can't clear memo on contracts. 0 length indicates no change\n-                if (txMessage.getMemo() != null && txMessage.getMemo().length() > 0) {\n-                    entity.setMemo(txMessage.getMemo());\n-                }\n-\n-                if (txMessage.hasAdminKey()) {\n-                    entity.setKey(txMessage.getAdminKey().toByteArray());\n-                }\n-            }\n-\n-            initialBalance = body.getContractCreateInstance().getInitialBalance();\n-        } else if (body.hasContractDeleteInstance()) {\n-            if (body.getContractDeleteInstance().hasContractID()) {\n-                if (doUpdateEntity) {\n-                    entity.setDeleted(true);\n-                }\n-            }\n-        } else if (body.hasContractUpdateInstance()) {\n-            ContractUpdateTransactionBody txMessage = body.getContractUpdateInstance();\n-            if (doUpdateEntity) {\n-                setProxyAccountID(txMessage.getProxyAccountID(), entity);\n-                if (txMessage.hasExpirationTime()) {\n-                    entity.setExpiryTimeNs(Utility.timestampInNanosMax(txMessage.getExpirationTime()));\n-                }\n-                if (txMessage.hasAutoRenewPeriod()) {\n-                    entity.setAutoRenewPeriod(txMessage.getAutoRenewPeriod().getSeconds());\n-                }\n-                if (txMessage.hasAdminKey()) {\n-                    entity.setKey(txMessage.getAdminKey().toByteArray());\n-                }\n-                // Can't clear memo on contracts. 0 length indicates no change\n-                if (txMessage.getMemo() != null && txMessage.getMemo().length() > 0) {\n-                    entity.setMemo(txMessage.getMemo());\n-                }\n-            }\n-        } else if (body.hasCryptoCreateAccount()) {\n-            if (txRecord.getReceipt().hasAccountID()) { // Implies SUCCESS\n-                CryptoCreateTransactionBody txMessage = body.getCryptoCreateAccount();\n-                setProxyAccountID(txMessage.getProxyAccountID(), entity);\n-                if (txMessage.hasAutoRenewPeriod()) {\n-                    entity.setAutoRenewPeriod(txMessage.getAutoRenewPeriod().getSeconds());\n-                }\n-                if (txMessage.hasKey()) {\n-                    entity.setKey(txMessage.getKey().toByteArray());\n-                }\n-            }\n-\n-            initialBalance = body.getCryptoCreateAccount().getInitialBalance();\n-        } else if (body.hasCryptoDelete()) {\n-            if (body.getCryptoDelete().hasDeleteAccountID()) {\n-                if (doUpdateEntity) {\n-                    entity.setDeleted(true);\n-                }\n-            }\n-        } else if (body.hasCryptoUpdateAccount()) {\n-            CryptoUpdateTransactionBody txMessage = body.getCryptoUpdateAccount();\n-            if (doUpdateEntity) {\n-                setProxyAccountID(txMessage.getProxyAccountID(), entity);\n-                if (txMessage.hasExpirationTime()) {\n-                    entity.setExpiryTimeNs(Utility.timestampInNanosMax(txMessage.getExpirationTime()));\n-                }\n-                if (txMessage.hasAutoRenewPeriod()) {\n-                    entity.setAutoRenewPeriod(txMessage.getAutoRenewPeriod().getSeconds());\n-                }\n-                if (txMessage.hasKey()) {\n-                    entity.setKey(txMessage.getKey().toByteArray());\n-                }\n-            }\n-        } else if (body.hasFileCreate()) {\n-            if (txRecord.getReceipt().hasFileID()) { // Implies SUCCESS\n-                FileCreateTransactionBody txMessage = body.getFileCreate();\n-                if (txMessage.hasExpirationTime()) {\n-                    entity.setExpiryTimeNs(Utility.timestampInNanosMax(txMessage.getExpirationTime()));\n-                }\n-\n-                if (txMessage.hasKeys()) {\n-                    entity.setKey(txMessage.getKeys().toByteArray());\n-                }\n-            }\n-        } else if (body.hasFileDelete()) {\n-            if (body.getFileDelete().hasFileID()) {\n-                if (doUpdateEntity) {\n-                    entity.setDeleted(true);\n-                }\n-            }\n-        } else if (body.hasFileUpdate()) {\n-            FileUpdateTransactionBody txMessage = body.getFileUpdate();\n-            if (doUpdateEntity) {\n-                if (txMessage.hasExpirationTime()) {\n-                    entity.setExpiryTimeNs(Utility.timestampInNanosMax(txMessage.getExpirationTime()));\n-                }\n-\n-                if (txMessage.hasKeys()) {\n-                    entity.setKey(txMessage.getKeys().toByteArray());\n-                }\n-            }\n-        } else if (body.hasSystemDelete()) {\n-            if (doUpdateEntity) {\n-                entity.setDeleted(true);\n-            }\n-        } else if (body.hasSystemUndelete()) {\n-            if (doUpdateEntity) {\n-                entity.setDeleted(false);\n-            }\n-        } else if (body.hasConsensusCreateTopic()) {\n-            consensusCreateTopicUpdateEntity(entity, body, txRecord);\n-        } else if (body.hasConsensusUpdateTopic()) {\n-            consensusUpdateTopicUpdateEntity(entity, body, txRecord);\n-        } else if (body.hasConsensusDeleteTopic()) {\n-            consensusDeleteTopicUpdateEntity(entity, body, txRecord);\n-        }\n-\n-        TransactionID transactionID = body.getTransactionID();\n-        long validDurationSeconds = body.hasTransactionValidDuration() ? body.getTransactionValidDuration()\n-                .getSeconds() : null;\n-        long validStartNs = Utility.timeStampInNanos(transactionID.getTransactionValidStart());\n-        AccountID payerAccountId = transactionID.getAccountID();\n-\n-        com.hedera.mirror.importer.domain.Transaction tx = new com.hedera.mirror.importer.domain.Transaction();\n-        tx.setChargedTxFee(txRecord.getTransactionFee());\n-        tx.setConsensusNs(consensusNs);\n-        tx.setInitialBalance(initialBalance);\n-        tx.setMemo(body.getMemo().getBytes());\n-        tx.setMaxFee(body.getTransactionFee());\n-        tx.setResult(txRecord.getReceipt().getStatusValue());\n-        tx.setType(transactionType);\n-        tx.setTransactionBytes(parserProperties.getPersist().isTransactionBytes() ?\n-                recordItem.getTransactionBytes() : null);\n-        tx.setTransactionHash(txRecord.getTransactionHash().toByteArray());\n-        tx.setValidDurationSeconds(validDurationSeconds);\n-        tx.setValidStartNs(validStartNs);\n-        if (entity != null) {\n+        //\n+        // Additionally, if transaction is successful:\n+        // - Fields of 'entity' will be updated.\n+        // - proxyAccountId/autoRenewAccountId: If present, the account's id are looked up (from big cache) or created\n+        //   immediately in TransactionHandler.updateEntity(..).\n+        if (transactionHandler.updatesEntity() && isSuccessful && entityId != null) {\n+            Entities entity = getEntity(entityId);\n+            transactionHandler.updateEntity(entity, recordItem);\n             tx.setEntity(entity);\n             entityRepository.save(entity);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY2NTY4MA=="}, "originalCommit": {"oid": "617acd2c6adcc310c45ba6841827f8808b7e265d"}, "originalPosition": 208}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 969, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}