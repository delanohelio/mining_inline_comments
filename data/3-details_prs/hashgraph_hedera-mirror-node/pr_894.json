{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUzMTM2MjAy", "number": 894, "title": "Store address book in DB", "bodyText": "Detailed description:\nWe currently store the address book on the filesystem which is sub optimal for reasons highlighted in #796\nWe want to be able to persist the address book details in the db for multiple future features\n\nAdded V1_28_1 sql migration to create address_book and address_book_entry . Also updates file_data to have entityId and transaction types.\nAdded address_book table to store address book files with columns for start and end consensus timestamps indicating what time range it was valid and raw bytes\nAdded address_book_entry  tables to store node addresses with similar fields as NodeAddress proto\nAdded AddressBookService interface\nAdded AddressBookServiceImpl class that will check db for a valid address book. If not found it w\nRemoved file system storage and reading of address book with support for loading bootstrap address book from file system or classpath\nUpdated AddressBookServiceImpl.update() to handle fileData objects. Logic will store in file_data. If file is of append operation it will retrieve previous create/update and append operations bytes and concatenate them to create an addressBook. Object is then stored in address_book and address_book_entry tables\nUpdated RecordEntityListener to support addressbook vs non-addressbook file parsing\nUpdated AddressBookServiceImpl to handle update start and end timestamps of address book after network restart\nAdded Java migration to parse all previous file_data rows for potential address books\n\nWhich issue(s) this PR fixes:\nFixes #796\nSpecial notes for your reviewer:\n\nLogic supports multiple address book file 101 and 102\n\nChecklist\n\n Documentation added\n Tests updated", "createdAt": "2020-07-20T07:11:01Z", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894", "merged": true, "mergeCommit": {"oid": "e7051a6f51101e64dccb4d3cf63d41b07e5d8b3d"}, "closed": true, "closedAt": "2020-07-31T06:10:28Z", "author": {"login": "Nana-EC"}, "timelineItems": {"totalCount": 30, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc22sPFgFqTQ1MTgyMDc3OQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABc6LaV0gFqTQ1ODg5MTQzOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxODIwNzc5", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#pullrequestreview-451820779", "createdAt": "2020-07-20T17:38:47Z", "commit": {"oid": "d39f16caea10cf920550a8d833a4163b09d41a9c"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNzozODo0OFrOG0Yg5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxOToxNzoxMVrOG0b2bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU4MDc3NQ==", "bodyText": "redundant not null for primary key", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r457580775", "createdAt": "2020-07-20T17:38:48Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/resources/db/migration/V1.28.0__address_book.sql", "diffHunk": "@@ -0,0 +1,42 @@\n+-------------------\n+-- Support db storage of netowrk address books\n+-------------------\n+\n+-- add address book table\n+create table if not exists address_book\n+(\n+    consensus_timestamp         nanos_timestamp primary key not null,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d39f16caea10cf920550a8d833a4163b09d41a9c"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU4MjYzMg==", "bodyText": "fail early here by throwing an exception? since address book data is not loaded, should not continue to parse it and eventually throw an exception when checking getAddress().isEmpty().", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r457582632", "createdAt": "2020-07-20T17:41:56Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/NetworkAddressBook.java", "diffHunk": "@@ -21,152 +21,309 @@\n  */\n \n import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.FileID;\n import com.hederahashgraph.api.proto.java.NodeAddressBook;\n import com.hederahashgraph.api.proto.java.TransactionBody;\n import java.io.File;\n-import java.io.IOException;\n import java.nio.file.Files;\n-import java.nio.file.OpenOption;\n import java.nio.file.Path;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Optional;\n import javax.inject.Named;\n import lombok.extern.log4j.Log4j2;\n import org.apache.commons.io.IOUtils;\n import org.springframework.core.io.ClassPathResource;\n import org.springframework.core.io.Resource;\n \n import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n import com.hedera.mirror.importer.domain.EntityId;\n import com.hedera.mirror.importer.domain.EntityTypeEnum;\n import com.hedera.mirror.importer.domain.NodeAddress;\n-import com.hedera.mirror.importer.exception.ParserException;\n-import com.hedera.mirror.importer.util.Utility;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.NodeAddressRepository;\n \n @Log4j2\n @Named\n public class NetworkAddressBook {\n \n     private final MirrorProperties mirrorProperties;\n-    private volatile Collection<NodeAddress> nodeAddresses;\n+    private final AddressBookRepository addressBookRepository;\n+    private final NodeAddressRepository nodeAddressRepository;\n \n-    public NetworkAddressBook(MirrorProperties mirrorProperties) {\n+    private volatile Collection<NodeAddress> currentNodeAddresses;\n+    private volatile Collection<NodeAddress> incomingNodeAddresses;\n+    private volatile AddressBook currentAddressBook;\n+    private volatile AddressBook incomingAddressBook;\n+    private final Path addressBookPath;\n+\n+    public NetworkAddressBook(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                              NodeAddressRepository nodeAddressRepository) {\n         this.mirrorProperties = mirrorProperties;\n-        nodeAddresses = Collections.emptyList();\n+        this.addressBookRepository = addressBookRepository;\n+        this.nodeAddressRepository = nodeAddressRepository;\n+        currentNodeAddresses = Collections.emptyList();\n+        incomingNodeAddresses = Collections.emptyList();\n+        currentAddressBook = null;\n+        incomingAddressBook = null;\n+        addressBookPath = mirrorProperties.getAddressBookPath();\n         init();\n     }\n \n-    public static boolean isAddressBook(EntityId entityId) {\n-        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId()\n-                && entityId.getEntityNum() == 102 && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n+    public boolean isAddressBook(EntityId entityId) {\n+        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId() &&\n+                (entityId.getEntityNum() == 101 || entityId.getEntityNum() == mirrorProperties\n+                        .getAddressBookFileIdEntityNum())\n+                && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n     }\n \n-    public void updateFrom(TransactionBody transactionBody) {\n+    public void updateFrom(TransactionBody transactionBody, long consensusTimeStamp, FileID fileID) {\n+        byte[] contents = null;\n+        boolean isAppendOperation = false;\n+\n+        if (transactionBody.hasFileAppend()) {\n+            contents = transactionBody.getFileAppend().getContents().toByteArray();\n+            isAppendOperation = true;\n+        } else if (transactionBody.hasFileUpdate()) {\n+            contents = transactionBody.getFileUpdate().getContents().toByteArray();\n+        } else if (transactionBody.hasFileCreate()) {\n+            contents = transactionBody.getFileCreate().getContents().toByteArray();\n+        }\n+\n+        if (contents == null || contents.length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n         try {\n-            if (transactionBody.hasFileAppend()) {\n-                append(transactionBody.getFileAppend().getContents().toByteArray());\n-            } else if (transactionBody.hasFileUpdate()) {\n-                update(transactionBody.getFileUpdate().getContents().toByteArray());\n-            }\n-        } catch (IOException e) {\n-            throw new ParserException(\"Error appending to network address book\", e);\n+            parse(contents, consensusTimeStamp, fileID, isAppendOperation);\n+        } catch (Exception e) {\n+            log.warn(\"Unable to parse address book: {}\", e.getMessage());\n         }\n+\n+        persistAddressBookToDB(consensusTimeStamp);\n     }\n \n     public Collection<NodeAddress> getAddresses() {\n-        return nodeAddresses;\n+        return currentNodeAddresses;\n+    }\n+\n+    public AddressBook getCurrentAddressBook() {\n+        return currentAddressBook;\n+    }\n+\n+    public AddressBook getPartialAddressBook() {\n+        return incomingAddressBook;\n+    }\n+\n+    private boolean isSupportedAddressBookEntityNum(long entityNum) {\n+        return mirrorProperties.getAddressBookFileIdEntityNum() == entityNum;\n     }\n \n     private void init() {\n-        Path path = mirrorProperties.getAddressBookPath();\n-        try {\n-            File addressBookFile = path.toFile();\n+        // load most recent addressBook\n+        loadAddressBookFromDB();\n \n-            if (!addressBookFile.canRead()) {\n-                if (addressBookFile.exists()) {\n-                    log.warn(\"Backing up unreadable address book: {}\", path);\n-                    Files.move(path, path.resolveSibling(path + \".unreadable\"));\n-                }\n+        if (currentAddressBook == null) {\n+            // no addressBook present in db, load from fileSystem\n+            byte[] addressBookBytes = null;\n+            try {\n+                File addressBookFile = addressBookPath.toFile();\n \n-                byte[] addressBookBytes = null;\n-                Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+                if (!addressBookFile.canRead()) {\n+                    if (addressBookFile.exists()) {\n+                        log.warn(\"Backing up unreadable address book: {}\", addressBookPath);\n+                        Files.move(addressBookPath, addressBookPath.resolveSibling(addressBookPath + \".unreadable\"));\n+                    }\n \n-                if (initialAddressBook != null) {\n-                    addressBookBytes = Files.readAllBytes(initialAddressBook);\n-                    log.info(\"Loading bootstrap address book from {}\", initialAddressBook);\n+                    Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+\n+                    if (initialAddressBook != null) {\n+                        addressBookBytes = Files.readAllBytes(initialAddressBook);\n+                        log.info(\"Loading bootstrap address book from {}\", initialAddressBook);\n+                    } else {\n+                        MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n+                        String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n+                        Resource resource = new ClassPathResource(resourcePath, getClass());\n+                        addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n+                        log.info(\"Loading bootstrap address book from {}\", resource);\n+                    }\n                 } else {\n-                    MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n-                    String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n-                    Resource resource = new ClassPathResource(resourcePath, getClass());\n-                    addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n-                    log.info(\"Loading bootstrap address book from {}\", resource);\n+                    log.info(\"Restoring existing address book {}\", addressBookPath);\n+                    addressBookBytes = Files.readAllBytes(addressBookPath);\n                 }\n+            } catch (Exception e) {\n+                log.error(\"Unable to copy address book from {} to {}\", mirrorProperties\n+                        .getNetwork(), addressBookPath, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d39f16caea10cf920550a8d833a4163b09d41a9c"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU5MTIyMQ==", "bodyText": "should guard it by checking incomingAddressBook != null?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r457591221", "createdAt": "2020-07-20T17:56:46Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/NetworkAddressBook.java", "diffHunk": "@@ -21,152 +21,309 @@\n  */\n \n import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.FileID;\n import com.hederahashgraph.api.proto.java.NodeAddressBook;\n import com.hederahashgraph.api.proto.java.TransactionBody;\n import java.io.File;\n-import java.io.IOException;\n import java.nio.file.Files;\n-import java.nio.file.OpenOption;\n import java.nio.file.Path;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Optional;\n import javax.inject.Named;\n import lombok.extern.log4j.Log4j2;\n import org.apache.commons.io.IOUtils;\n import org.springframework.core.io.ClassPathResource;\n import org.springframework.core.io.Resource;\n \n import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n import com.hedera.mirror.importer.domain.EntityId;\n import com.hedera.mirror.importer.domain.EntityTypeEnum;\n import com.hedera.mirror.importer.domain.NodeAddress;\n-import com.hedera.mirror.importer.exception.ParserException;\n-import com.hedera.mirror.importer.util.Utility;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.NodeAddressRepository;\n \n @Log4j2\n @Named\n public class NetworkAddressBook {\n \n     private final MirrorProperties mirrorProperties;\n-    private volatile Collection<NodeAddress> nodeAddresses;\n+    private final AddressBookRepository addressBookRepository;\n+    private final NodeAddressRepository nodeAddressRepository;\n \n-    public NetworkAddressBook(MirrorProperties mirrorProperties) {\n+    private volatile Collection<NodeAddress> currentNodeAddresses;\n+    private volatile Collection<NodeAddress> incomingNodeAddresses;\n+    private volatile AddressBook currentAddressBook;\n+    private volatile AddressBook incomingAddressBook;\n+    private final Path addressBookPath;\n+\n+    public NetworkAddressBook(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                              NodeAddressRepository nodeAddressRepository) {\n         this.mirrorProperties = mirrorProperties;\n-        nodeAddresses = Collections.emptyList();\n+        this.addressBookRepository = addressBookRepository;\n+        this.nodeAddressRepository = nodeAddressRepository;\n+        currentNodeAddresses = Collections.emptyList();\n+        incomingNodeAddresses = Collections.emptyList();\n+        currentAddressBook = null;\n+        incomingAddressBook = null;\n+        addressBookPath = mirrorProperties.getAddressBookPath();\n         init();\n     }\n \n-    public static boolean isAddressBook(EntityId entityId) {\n-        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId()\n-                && entityId.getEntityNum() == 102 && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n+    public boolean isAddressBook(EntityId entityId) {\n+        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId() &&\n+                (entityId.getEntityNum() == 101 || entityId.getEntityNum() == mirrorProperties\n+                        .getAddressBookFileIdEntityNum())\n+                && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n     }\n \n-    public void updateFrom(TransactionBody transactionBody) {\n+    public void updateFrom(TransactionBody transactionBody, long consensusTimeStamp, FileID fileID) {\n+        byte[] contents = null;\n+        boolean isAppendOperation = false;\n+\n+        if (transactionBody.hasFileAppend()) {\n+            contents = transactionBody.getFileAppend().getContents().toByteArray();\n+            isAppendOperation = true;\n+        } else if (transactionBody.hasFileUpdate()) {\n+            contents = transactionBody.getFileUpdate().getContents().toByteArray();\n+        } else if (transactionBody.hasFileCreate()) {\n+            contents = transactionBody.getFileCreate().getContents().toByteArray();\n+        }\n+\n+        if (contents == null || contents.length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n         try {\n-            if (transactionBody.hasFileAppend()) {\n-                append(transactionBody.getFileAppend().getContents().toByteArray());\n-            } else if (transactionBody.hasFileUpdate()) {\n-                update(transactionBody.getFileUpdate().getContents().toByteArray());\n-            }\n-        } catch (IOException e) {\n-            throw new ParserException(\"Error appending to network address book\", e);\n+            parse(contents, consensusTimeStamp, fileID, isAppendOperation);\n+        } catch (Exception e) {\n+            log.warn(\"Unable to parse address book: {}\", e.getMessage());\n         }\n+\n+        persistAddressBookToDB(consensusTimeStamp);\n     }\n \n     public Collection<NodeAddress> getAddresses() {\n-        return nodeAddresses;\n+        return currentNodeAddresses;\n+    }\n+\n+    public AddressBook getCurrentAddressBook() {\n+        return currentAddressBook;\n+    }\n+\n+    public AddressBook getPartialAddressBook() {\n+        return incomingAddressBook;\n+    }\n+\n+    private boolean isSupportedAddressBookEntityNum(long entityNum) {\n+        return mirrorProperties.getAddressBookFileIdEntityNum() == entityNum;\n     }\n \n     private void init() {\n-        Path path = mirrorProperties.getAddressBookPath();\n-        try {\n-            File addressBookFile = path.toFile();\n+        // load most recent addressBook\n+        loadAddressBookFromDB();\n \n-            if (!addressBookFile.canRead()) {\n-                if (addressBookFile.exists()) {\n-                    log.warn(\"Backing up unreadable address book: {}\", path);\n-                    Files.move(path, path.resolveSibling(path + \".unreadable\"));\n-                }\n+        if (currentAddressBook == null) {\n+            // no addressBook present in db, load from fileSystem\n+            byte[] addressBookBytes = null;\n+            try {\n+                File addressBookFile = addressBookPath.toFile();\n \n-                byte[] addressBookBytes = null;\n-                Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+                if (!addressBookFile.canRead()) {\n+                    if (addressBookFile.exists()) {\n+                        log.warn(\"Backing up unreadable address book: {}\", addressBookPath);\n+                        Files.move(addressBookPath, addressBookPath.resolveSibling(addressBookPath + \".unreadable\"));\n+                    }\n \n-                if (initialAddressBook != null) {\n-                    addressBookBytes = Files.readAllBytes(initialAddressBook);\n-                    log.info(\"Loading bootstrap address book from {}\", initialAddressBook);\n+                    Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+\n+                    if (initialAddressBook != null) {\n+                        addressBookBytes = Files.readAllBytes(initialAddressBook);\n+                        log.info(\"Loading bootstrap address book from {}\", initialAddressBook);\n+                    } else {\n+                        MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n+                        String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n+                        Resource resource = new ClassPathResource(resourcePath, getClass());\n+                        addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n+                        log.info(\"Loading bootstrap address book from {}\", resource);\n+                    }\n                 } else {\n-                    MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n-                    String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n-                    Resource resource = new ClassPathResource(resourcePath, getClass());\n-                    addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n-                    log.info(\"Loading bootstrap address book from {}\", resource);\n+                    log.info(\"Restoring existing address book {}\", addressBookPath);\n+                    addressBookBytes = Files.readAllBytes(addressBookPath);\n                 }\n+            } catch (Exception e) {\n+                log.error(\"Unable to copy address book from {} to {}\", mirrorProperties\n+                        .getNetwork(), addressBookPath, e);\n+            }\n \n-                Utility.ensureDirectory(path.getParent());\n-                update(addressBookBytes);\n-            } else {\n-                log.info(\"Restoring existing address book {}\", path);\n-                update(Files.readAllBytes(path));\n+            try {\n+                parse(addressBookBytes, 0L, FileID.newBuilder()\n+                        .setShardNum(mirrorProperties.getShard()).setRealmNum(0)\n+                        .setFileNum(mirrorProperties.getAddressBookFileIdEntityNum()).build(), false);\n+                persistAddressBookToDB(0);\n+            } catch (Exception e) {\n+                log.error(\"Unable to parse address book: {}\", e.getMessage());\n             }\n-        } catch (Exception e) {\n-            log.error(\"Unable to copy address book from {} to {}\", mirrorProperties.getNetwork(), path, e);\n+        } else {\n+            // addressBook loaded from db\n+            log.info(\"Loaded addressBook details from DB. Valid from {}, {} nodes, fileSize {} B\",\n+                    currentAddressBook.getStartConsensusTimestamp(), currentAddressBook.getNodeCount(),\n+                    currentAddressBook.getFileData().length);\n         }\n \n         if (getAddresses().isEmpty()) {\n             throw new IllegalStateException(\"Unable to load a valid address book\");\n         }\n     }\n \n-    public void update(byte[] newContents) throws IOException {\n-        saveToDisk(newContents, StandardOpenOption.TRUNCATE_EXISTING);\n-    }\n-\n-    private void append(byte[] extraContents) throws IOException {\n-        saveToDisk(extraContents, StandardOpenOption.APPEND);\n-    }\n+    private void parse(byte[] contents, Long consensusTimestamp, FileID fileID, boolean append) throws Exception {\n+        byte[] addressBookBytes = null;\n+        if (append) {\n+            // concatenate bytes for impartial address books\n+            Optional<AddressBook> optionalAddressBook = addressBookRepository\n+                    .findTopByFileIdAndIsCompleteIsFalseOrderByConsensusTimestampDesc(EntityId.of(fileID));\n \n-    private void saveToDisk(byte[] contents, OpenOption openOption) throws IOException {\n-        if (contents == null || contents.length == 0) {\n-            log.warn(\"Ignored empty byte array\");\n-            return;\n+            if (optionalAddressBook.isPresent()) {\n+                AddressBook addressBook = optionalAddressBook.get();\n+                byte[] incompleteBytes = addressBook.getFileData();\n+                byte[] combinedBytes = new byte[incompleteBytes.length + contents.length];\n+                System.arraycopy(incompleteBytes, 0, combinedBytes, 0, incompleteBytes.length);\n+                System.arraycopy(contents, 0, combinedBytes, incompleteBytes.length, contents.length);\n+                addressBookBytes = combinedBytes;\n+                log.info(\"Combined incomplete addressBook from {} of size {} B with bytes from {} of {} B. Combined \" +\n+                                \"length is {}\", addressBook.getConsensusTimestamp(), incompleteBytes.length,\n+                        consensusTimestamp, contents.length, combinedBytes.length);\n+            } else {\n+                log.error(\"Previous incomplete address book entry expected but not found\");\n+            }\n+        } else {\n+            addressBookBytes = contents;\n         }\n \n-        Path path = mirrorProperties.getAddressBookPath();\n-        Path tempPath = path.resolveSibling(path.getFileName() + \".tmp\");\n-        Files.write(tempPath, contents, StandardOpenOption.CREATE, StandardOpenOption.WRITE, openOption);\n-        log.info(\"Saved {}B partial address book update to {}\", contents.length, tempPath);\n+        retrieveAddressBook(addressBookBytes, consensusTimestamp, fileID);\n+    }\n+\n+    private void retrieveAddressBook(byte[] addressBookBytes, long consensusTimestamp, FileID fileID) {\n+        AddressBook.AddressBookBuilder builder = AddressBook.builder()\n+                .fileData(addressBookBytes)\n+                .consensusTimestamp(consensusTimestamp)\n+                .fileId(EntityId.of(fileID));\n \n         try {\n-            Collection<NodeAddress> nodeAddresses = parse(tempPath);\n-            if (!nodeAddresses.isEmpty()) {\n-                Files.move(tempPath, path, StandardCopyOption.REPLACE_EXISTING);\n-                this.nodeAddresses = nodeAddresses;\n-                log.info(\"New address book with {} addresses successfully parsed and saved to {}\",\n-                        nodeAddresses.size(), path);\n+            NodeAddressBook nodeAddressBook = NodeAddressBook.parseFrom(addressBookBytes);\n+            if (nodeAddressBook != null) {\n+                builder = builder\n+                        .isComplete(true)\n+                        .nodeCount(nodeAddressBook.getNodeAddressCount())\n+                        .startConsensusTimestamp(consensusTimestamp);\n+\n+                Collection<NodeAddress> nodeAddresses = retrieveNodeAddressesFromAddressBook(nodeAddressBook);\n+                if (nodeAddressBook.getNodeAddressCount() > 0) {\n+                    incomingNodeAddresses = nodeAddresses;\n+                }\n             }\n         } catch (Exception e) {\n             log.warn(\"Unable to parse address book: {}\", e.getMessage());\n+            incomingNodeAddresses = Collections.emptyList();\n         }\n+\n+        incomingAddressBook = builder.build();\n     }\n \n-    private Collection<NodeAddress> parse(Path path) throws Exception {\n-        byte[] addressBookBytes = Files.readAllBytes(path);\n-        NodeAddressBook nodeAddressBook = NodeAddressBook.parseFrom(addressBookBytes);\n+    private Collection<NodeAddress> retrieveNodeAddressesFromAddressBook(NodeAddressBook nodeAddressBook) {\n         ImmutableList.Builder<NodeAddress> builder = ImmutableList.builder();\n \n-        for (com.hederahashgraph.api.proto.java.NodeAddress nodeAddressProto : nodeAddressBook\n-                .getNodeAddressList()) {\n-            NodeAddress nodeAddress = NodeAddress.builder()\n-                    .id(nodeAddressProto.getMemo().toStringUtf8())\n-                    .ip(nodeAddressProto.getIpAddress().toStringUtf8())\n-                    .port(nodeAddressProto.getPortno())\n-                    .publicKey(nodeAddressProto.getRSAPubKey())\n-                    .build();\n-            builder.add(nodeAddress);\n+        if (nodeAddressBook != null) {\n+            for (com.hederahashgraph.api.proto.java.NodeAddress nodeAddressProto : nodeAddressBook\n+                    .getNodeAddressList()) {\n+                NodeAddress nodeAddress = NodeAddress.builder()\n+                        .memo(nodeAddressProto.getMemo().toStringUtf8())\n+                        .ip(nodeAddressProto.getIpAddress().toStringUtf8())\n+                        .port(nodeAddressProto.getPortno())\n+                        .publicKey(nodeAddressProto.getRSAPubKey())\n+                        .build();\n+                builder.add(nodeAddress);\n+            }\n         }\n \n         return builder.build();\n     }\n+\n+    private void persistAddressBookToDB(long consensusTimestamp) {\n+        // store complete address book\n+        saveAddressBook(consensusTimestamp);\n+\n+        // store node addresses\n+        saveNodeAddresses(consensusTimestamp);\n+    }\n+\n+    private void saveAddressBook(long consensusTimestamp) {\n+        // if address book is complete update end time of previous address book and start time of this\n+        if (incomingAddressBook != null && incomingAddressBook.isComplete()) {\n+            // retrieve last complete address book for fileID and update endConsensusTimestamp\n+            Optional<AddressBook> addressBook = addressBookRepository\n+                    .findTopByFileIdAndIsCompleteIsTrueOrderByConsensusTimestampDesc(incomingAddressBook.getFileId());\n+            if (addressBook.isPresent()) {\n+                addressBookRepository\n+                        .updateEndConsensusTimestamp(addressBook.get().getConsensusTimestamp(), consensusTimestamp - 1);\n+            }\n+        }\n+\n+        // store address book.\n+        // Potential to also remove incomplete address books entries in the db table\n+        addressBookRepository.save(incomingAddressBook);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d39f16caea10cf920550a8d833a4163b09d41a9c"}, "originalPosition": 336}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU5NjM3Mw==", "bodyText": "update addressBook.endConsensusTimestamp and use save() to make the update, if performance is not a concern.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r457596373", "createdAt": "2020-07-20T18:05:55Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/NetworkAddressBook.java", "diffHunk": "@@ -21,152 +21,309 @@\n  */\n \n import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.FileID;\n import com.hederahashgraph.api.proto.java.NodeAddressBook;\n import com.hederahashgraph.api.proto.java.TransactionBody;\n import java.io.File;\n-import java.io.IOException;\n import java.nio.file.Files;\n-import java.nio.file.OpenOption;\n import java.nio.file.Path;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Optional;\n import javax.inject.Named;\n import lombok.extern.log4j.Log4j2;\n import org.apache.commons.io.IOUtils;\n import org.springframework.core.io.ClassPathResource;\n import org.springframework.core.io.Resource;\n \n import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n import com.hedera.mirror.importer.domain.EntityId;\n import com.hedera.mirror.importer.domain.EntityTypeEnum;\n import com.hedera.mirror.importer.domain.NodeAddress;\n-import com.hedera.mirror.importer.exception.ParserException;\n-import com.hedera.mirror.importer.util.Utility;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.NodeAddressRepository;\n \n @Log4j2\n @Named\n public class NetworkAddressBook {\n \n     private final MirrorProperties mirrorProperties;\n-    private volatile Collection<NodeAddress> nodeAddresses;\n+    private final AddressBookRepository addressBookRepository;\n+    private final NodeAddressRepository nodeAddressRepository;\n \n-    public NetworkAddressBook(MirrorProperties mirrorProperties) {\n+    private volatile Collection<NodeAddress> currentNodeAddresses;\n+    private volatile Collection<NodeAddress> incomingNodeAddresses;\n+    private volatile AddressBook currentAddressBook;\n+    private volatile AddressBook incomingAddressBook;\n+    private final Path addressBookPath;\n+\n+    public NetworkAddressBook(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                              NodeAddressRepository nodeAddressRepository) {\n         this.mirrorProperties = mirrorProperties;\n-        nodeAddresses = Collections.emptyList();\n+        this.addressBookRepository = addressBookRepository;\n+        this.nodeAddressRepository = nodeAddressRepository;\n+        currentNodeAddresses = Collections.emptyList();\n+        incomingNodeAddresses = Collections.emptyList();\n+        currentAddressBook = null;\n+        incomingAddressBook = null;\n+        addressBookPath = mirrorProperties.getAddressBookPath();\n         init();\n     }\n \n-    public static boolean isAddressBook(EntityId entityId) {\n-        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId()\n-                && entityId.getEntityNum() == 102 && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n+    public boolean isAddressBook(EntityId entityId) {\n+        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId() &&\n+                (entityId.getEntityNum() == 101 || entityId.getEntityNum() == mirrorProperties\n+                        .getAddressBookFileIdEntityNum())\n+                && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n     }\n \n-    public void updateFrom(TransactionBody transactionBody) {\n+    public void updateFrom(TransactionBody transactionBody, long consensusTimeStamp, FileID fileID) {\n+        byte[] contents = null;\n+        boolean isAppendOperation = false;\n+\n+        if (transactionBody.hasFileAppend()) {\n+            contents = transactionBody.getFileAppend().getContents().toByteArray();\n+            isAppendOperation = true;\n+        } else if (transactionBody.hasFileUpdate()) {\n+            contents = transactionBody.getFileUpdate().getContents().toByteArray();\n+        } else if (transactionBody.hasFileCreate()) {\n+            contents = transactionBody.getFileCreate().getContents().toByteArray();\n+        }\n+\n+        if (contents == null || contents.length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n         try {\n-            if (transactionBody.hasFileAppend()) {\n-                append(transactionBody.getFileAppend().getContents().toByteArray());\n-            } else if (transactionBody.hasFileUpdate()) {\n-                update(transactionBody.getFileUpdate().getContents().toByteArray());\n-            }\n-        } catch (IOException e) {\n-            throw new ParserException(\"Error appending to network address book\", e);\n+            parse(contents, consensusTimeStamp, fileID, isAppendOperation);\n+        } catch (Exception e) {\n+            log.warn(\"Unable to parse address book: {}\", e.getMessage());\n         }\n+\n+        persistAddressBookToDB(consensusTimeStamp);\n     }\n \n     public Collection<NodeAddress> getAddresses() {\n-        return nodeAddresses;\n+        return currentNodeAddresses;\n+    }\n+\n+    public AddressBook getCurrentAddressBook() {\n+        return currentAddressBook;\n+    }\n+\n+    public AddressBook getPartialAddressBook() {\n+        return incomingAddressBook;\n+    }\n+\n+    private boolean isSupportedAddressBookEntityNum(long entityNum) {\n+        return mirrorProperties.getAddressBookFileIdEntityNum() == entityNum;\n     }\n \n     private void init() {\n-        Path path = mirrorProperties.getAddressBookPath();\n-        try {\n-            File addressBookFile = path.toFile();\n+        // load most recent addressBook\n+        loadAddressBookFromDB();\n \n-            if (!addressBookFile.canRead()) {\n-                if (addressBookFile.exists()) {\n-                    log.warn(\"Backing up unreadable address book: {}\", path);\n-                    Files.move(path, path.resolveSibling(path + \".unreadable\"));\n-                }\n+        if (currentAddressBook == null) {\n+            // no addressBook present in db, load from fileSystem\n+            byte[] addressBookBytes = null;\n+            try {\n+                File addressBookFile = addressBookPath.toFile();\n \n-                byte[] addressBookBytes = null;\n-                Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+                if (!addressBookFile.canRead()) {\n+                    if (addressBookFile.exists()) {\n+                        log.warn(\"Backing up unreadable address book: {}\", addressBookPath);\n+                        Files.move(addressBookPath, addressBookPath.resolveSibling(addressBookPath + \".unreadable\"));\n+                    }\n \n-                if (initialAddressBook != null) {\n-                    addressBookBytes = Files.readAllBytes(initialAddressBook);\n-                    log.info(\"Loading bootstrap address book from {}\", initialAddressBook);\n+                    Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+\n+                    if (initialAddressBook != null) {\n+                        addressBookBytes = Files.readAllBytes(initialAddressBook);\n+                        log.info(\"Loading bootstrap address book from {}\", initialAddressBook);\n+                    } else {\n+                        MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n+                        String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n+                        Resource resource = new ClassPathResource(resourcePath, getClass());\n+                        addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n+                        log.info(\"Loading bootstrap address book from {}\", resource);\n+                    }\n                 } else {\n-                    MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n-                    String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n-                    Resource resource = new ClassPathResource(resourcePath, getClass());\n-                    addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n-                    log.info(\"Loading bootstrap address book from {}\", resource);\n+                    log.info(\"Restoring existing address book {}\", addressBookPath);\n+                    addressBookBytes = Files.readAllBytes(addressBookPath);\n                 }\n+            } catch (Exception e) {\n+                log.error(\"Unable to copy address book from {} to {}\", mirrorProperties\n+                        .getNetwork(), addressBookPath, e);\n+            }\n \n-                Utility.ensureDirectory(path.getParent());\n-                update(addressBookBytes);\n-            } else {\n-                log.info(\"Restoring existing address book {}\", path);\n-                update(Files.readAllBytes(path));\n+            try {\n+                parse(addressBookBytes, 0L, FileID.newBuilder()\n+                        .setShardNum(mirrorProperties.getShard()).setRealmNum(0)\n+                        .setFileNum(mirrorProperties.getAddressBookFileIdEntityNum()).build(), false);\n+                persistAddressBookToDB(0);\n+            } catch (Exception e) {\n+                log.error(\"Unable to parse address book: {}\", e.getMessage());\n             }\n-        } catch (Exception e) {\n-            log.error(\"Unable to copy address book from {} to {}\", mirrorProperties.getNetwork(), path, e);\n+        } else {\n+            // addressBook loaded from db\n+            log.info(\"Loaded addressBook details from DB. Valid from {}, {} nodes, fileSize {} B\",\n+                    currentAddressBook.getStartConsensusTimestamp(), currentAddressBook.getNodeCount(),\n+                    currentAddressBook.getFileData().length);\n         }\n \n         if (getAddresses().isEmpty()) {\n             throw new IllegalStateException(\"Unable to load a valid address book\");\n         }\n     }\n \n-    public void update(byte[] newContents) throws IOException {\n-        saveToDisk(newContents, StandardOpenOption.TRUNCATE_EXISTING);\n-    }\n-\n-    private void append(byte[] extraContents) throws IOException {\n-        saveToDisk(extraContents, StandardOpenOption.APPEND);\n-    }\n+    private void parse(byte[] contents, Long consensusTimestamp, FileID fileID, boolean append) throws Exception {\n+        byte[] addressBookBytes = null;\n+        if (append) {\n+            // concatenate bytes for impartial address books\n+            Optional<AddressBook> optionalAddressBook = addressBookRepository\n+                    .findTopByFileIdAndIsCompleteIsFalseOrderByConsensusTimestampDesc(EntityId.of(fileID));\n \n-    private void saveToDisk(byte[] contents, OpenOption openOption) throws IOException {\n-        if (contents == null || contents.length == 0) {\n-            log.warn(\"Ignored empty byte array\");\n-            return;\n+            if (optionalAddressBook.isPresent()) {\n+                AddressBook addressBook = optionalAddressBook.get();\n+                byte[] incompleteBytes = addressBook.getFileData();\n+                byte[] combinedBytes = new byte[incompleteBytes.length + contents.length];\n+                System.arraycopy(incompleteBytes, 0, combinedBytes, 0, incompleteBytes.length);\n+                System.arraycopy(contents, 0, combinedBytes, incompleteBytes.length, contents.length);\n+                addressBookBytes = combinedBytes;\n+                log.info(\"Combined incomplete addressBook from {} of size {} B with bytes from {} of {} B. Combined \" +\n+                                \"length is {}\", addressBook.getConsensusTimestamp(), incompleteBytes.length,\n+                        consensusTimestamp, contents.length, combinedBytes.length);\n+            } else {\n+                log.error(\"Previous incomplete address book entry expected but not found\");\n+            }\n+        } else {\n+            addressBookBytes = contents;\n         }\n \n-        Path path = mirrorProperties.getAddressBookPath();\n-        Path tempPath = path.resolveSibling(path.getFileName() + \".tmp\");\n-        Files.write(tempPath, contents, StandardOpenOption.CREATE, StandardOpenOption.WRITE, openOption);\n-        log.info(\"Saved {}B partial address book update to {}\", contents.length, tempPath);\n+        retrieveAddressBook(addressBookBytes, consensusTimestamp, fileID);\n+    }\n+\n+    private void retrieveAddressBook(byte[] addressBookBytes, long consensusTimestamp, FileID fileID) {\n+        AddressBook.AddressBookBuilder builder = AddressBook.builder()\n+                .fileData(addressBookBytes)\n+                .consensusTimestamp(consensusTimestamp)\n+                .fileId(EntityId.of(fileID));\n \n         try {\n-            Collection<NodeAddress> nodeAddresses = parse(tempPath);\n-            if (!nodeAddresses.isEmpty()) {\n-                Files.move(tempPath, path, StandardCopyOption.REPLACE_EXISTING);\n-                this.nodeAddresses = nodeAddresses;\n-                log.info(\"New address book with {} addresses successfully parsed and saved to {}\",\n-                        nodeAddresses.size(), path);\n+            NodeAddressBook nodeAddressBook = NodeAddressBook.parseFrom(addressBookBytes);\n+            if (nodeAddressBook != null) {\n+                builder = builder\n+                        .isComplete(true)\n+                        .nodeCount(nodeAddressBook.getNodeAddressCount())\n+                        .startConsensusTimestamp(consensusTimestamp);\n+\n+                Collection<NodeAddress> nodeAddresses = retrieveNodeAddressesFromAddressBook(nodeAddressBook);\n+                if (nodeAddressBook.getNodeAddressCount() > 0) {\n+                    incomingNodeAddresses = nodeAddresses;\n+                }\n             }\n         } catch (Exception e) {\n             log.warn(\"Unable to parse address book: {}\", e.getMessage());\n+            incomingNodeAddresses = Collections.emptyList();\n         }\n+\n+        incomingAddressBook = builder.build();\n     }\n \n-    private Collection<NodeAddress> parse(Path path) throws Exception {\n-        byte[] addressBookBytes = Files.readAllBytes(path);\n-        NodeAddressBook nodeAddressBook = NodeAddressBook.parseFrom(addressBookBytes);\n+    private Collection<NodeAddress> retrieveNodeAddressesFromAddressBook(NodeAddressBook nodeAddressBook) {\n         ImmutableList.Builder<NodeAddress> builder = ImmutableList.builder();\n \n-        for (com.hederahashgraph.api.proto.java.NodeAddress nodeAddressProto : nodeAddressBook\n-                .getNodeAddressList()) {\n-            NodeAddress nodeAddress = NodeAddress.builder()\n-                    .id(nodeAddressProto.getMemo().toStringUtf8())\n-                    .ip(nodeAddressProto.getIpAddress().toStringUtf8())\n-                    .port(nodeAddressProto.getPortno())\n-                    .publicKey(nodeAddressProto.getRSAPubKey())\n-                    .build();\n-            builder.add(nodeAddress);\n+        if (nodeAddressBook != null) {\n+            for (com.hederahashgraph.api.proto.java.NodeAddress nodeAddressProto : nodeAddressBook\n+                    .getNodeAddressList()) {\n+                NodeAddress nodeAddress = NodeAddress.builder()\n+                        .memo(nodeAddressProto.getMemo().toStringUtf8())\n+                        .ip(nodeAddressProto.getIpAddress().toStringUtf8())\n+                        .port(nodeAddressProto.getPortno())\n+                        .publicKey(nodeAddressProto.getRSAPubKey())\n+                        .build();\n+                builder.add(nodeAddress);\n+            }\n         }\n \n         return builder.build();\n     }\n+\n+    private void persistAddressBookToDB(long consensusTimestamp) {\n+        // store complete address book\n+        saveAddressBook(consensusTimestamp);\n+\n+        // store node addresses\n+        saveNodeAddresses(consensusTimestamp);\n+    }\n+\n+    private void saveAddressBook(long consensusTimestamp) {\n+        // if address book is complete update end time of previous address book and start time of this\n+        if (incomingAddressBook != null && incomingAddressBook.isComplete()) {\n+            // retrieve last complete address book for fileID and update endConsensusTimestamp\n+            Optional<AddressBook> addressBook = addressBookRepository\n+                    .findTopByFileIdAndIsCompleteIsTrueOrderByConsensusTimestampDesc(incomingAddressBook.getFileId());\n+            if (addressBook.isPresent()) {\n+                addressBookRepository\n+                        .updateEndConsensusTimestamp(addressBook.get().getConsensusTimestamp(), consensusTimestamp - 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d39f16caea10cf920550a8d833a4163b09d41a9c"}, "originalPosition": 330}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYwOTA2NA==", "bodyText": "should it be entityId.getEntityNum() == 102?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r457609064", "createdAt": "2020-07-20T18:29:08Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/NetworkAddressBook.java", "diffHunk": "@@ -21,152 +21,309 @@\n  */\n \n import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.FileID;\n import com.hederahashgraph.api.proto.java.NodeAddressBook;\n import com.hederahashgraph.api.proto.java.TransactionBody;\n import java.io.File;\n-import java.io.IOException;\n import java.nio.file.Files;\n-import java.nio.file.OpenOption;\n import java.nio.file.Path;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Optional;\n import javax.inject.Named;\n import lombok.extern.log4j.Log4j2;\n import org.apache.commons.io.IOUtils;\n import org.springframework.core.io.ClassPathResource;\n import org.springframework.core.io.Resource;\n \n import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n import com.hedera.mirror.importer.domain.EntityId;\n import com.hedera.mirror.importer.domain.EntityTypeEnum;\n import com.hedera.mirror.importer.domain.NodeAddress;\n-import com.hedera.mirror.importer.exception.ParserException;\n-import com.hedera.mirror.importer.util.Utility;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.NodeAddressRepository;\n \n @Log4j2\n @Named\n public class NetworkAddressBook {\n \n     private final MirrorProperties mirrorProperties;\n-    private volatile Collection<NodeAddress> nodeAddresses;\n+    private final AddressBookRepository addressBookRepository;\n+    private final NodeAddressRepository nodeAddressRepository;\n \n-    public NetworkAddressBook(MirrorProperties mirrorProperties) {\n+    private volatile Collection<NodeAddress> currentNodeAddresses;\n+    private volatile Collection<NodeAddress> incomingNodeAddresses;\n+    private volatile AddressBook currentAddressBook;\n+    private volatile AddressBook incomingAddressBook;\n+    private final Path addressBookPath;\n+\n+    public NetworkAddressBook(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                              NodeAddressRepository nodeAddressRepository) {\n         this.mirrorProperties = mirrorProperties;\n-        nodeAddresses = Collections.emptyList();\n+        this.addressBookRepository = addressBookRepository;\n+        this.nodeAddressRepository = nodeAddressRepository;\n+        currentNodeAddresses = Collections.emptyList();\n+        incomingNodeAddresses = Collections.emptyList();\n+        currentAddressBook = null;\n+        incomingAddressBook = null;\n+        addressBookPath = mirrorProperties.getAddressBookPath();\n         init();\n     }\n \n-    public static boolean isAddressBook(EntityId entityId) {\n-        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId()\n-                && entityId.getEntityNum() == 102 && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n+    public boolean isAddressBook(EntityId entityId) {\n+        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId() &&\n+                (entityId.getEntityNum() == 101 || entityId.getEntityNum() == mirrorProperties", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d39f16caea10cf920550a8d833a4163b09d41a9c"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYzNTQzOA==", "bodyText": "redundant: assign the build to itself.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r457635438", "createdAt": "2020-07-20T19:17:11Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/NetworkAddressBook.java", "diffHunk": "@@ -21,152 +21,309 @@\n  */\n \n import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.FileID;\n import com.hederahashgraph.api.proto.java.NodeAddressBook;\n import com.hederahashgraph.api.proto.java.TransactionBody;\n import java.io.File;\n-import java.io.IOException;\n import java.nio.file.Files;\n-import java.nio.file.OpenOption;\n import java.nio.file.Path;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Optional;\n import javax.inject.Named;\n import lombok.extern.log4j.Log4j2;\n import org.apache.commons.io.IOUtils;\n import org.springframework.core.io.ClassPathResource;\n import org.springframework.core.io.Resource;\n \n import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n import com.hedera.mirror.importer.domain.EntityId;\n import com.hedera.mirror.importer.domain.EntityTypeEnum;\n import com.hedera.mirror.importer.domain.NodeAddress;\n-import com.hedera.mirror.importer.exception.ParserException;\n-import com.hedera.mirror.importer.util.Utility;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.NodeAddressRepository;\n \n @Log4j2\n @Named\n public class NetworkAddressBook {\n \n     private final MirrorProperties mirrorProperties;\n-    private volatile Collection<NodeAddress> nodeAddresses;\n+    private final AddressBookRepository addressBookRepository;\n+    private final NodeAddressRepository nodeAddressRepository;\n \n-    public NetworkAddressBook(MirrorProperties mirrorProperties) {\n+    private volatile Collection<NodeAddress> currentNodeAddresses;\n+    private volatile Collection<NodeAddress> incomingNodeAddresses;\n+    private volatile AddressBook currentAddressBook;\n+    private volatile AddressBook incomingAddressBook;\n+    private final Path addressBookPath;\n+\n+    public NetworkAddressBook(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                              NodeAddressRepository nodeAddressRepository) {\n         this.mirrorProperties = mirrorProperties;\n-        nodeAddresses = Collections.emptyList();\n+        this.addressBookRepository = addressBookRepository;\n+        this.nodeAddressRepository = nodeAddressRepository;\n+        currentNodeAddresses = Collections.emptyList();\n+        incomingNodeAddresses = Collections.emptyList();\n+        currentAddressBook = null;\n+        incomingAddressBook = null;\n+        addressBookPath = mirrorProperties.getAddressBookPath();\n         init();\n     }\n \n-    public static boolean isAddressBook(EntityId entityId) {\n-        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId()\n-                && entityId.getEntityNum() == 102 && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n+    public boolean isAddressBook(EntityId entityId) {\n+        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId() &&\n+                (entityId.getEntityNum() == 101 || entityId.getEntityNum() == mirrorProperties\n+                        .getAddressBookFileIdEntityNum())\n+                && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n     }\n \n-    public void updateFrom(TransactionBody transactionBody) {\n+    public void updateFrom(TransactionBody transactionBody, long consensusTimeStamp, FileID fileID) {\n+        byte[] contents = null;\n+        boolean isAppendOperation = false;\n+\n+        if (transactionBody.hasFileAppend()) {\n+            contents = transactionBody.getFileAppend().getContents().toByteArray();\n+            isAppendOperation = true;\n+        } else if (transactionBody.hasFileUpdate()) {\n+            contents = transactionBody.getFileUpdate().getContents().toByteArray();\n+        } else if (transactionBody.hasFileCreate()) {\n+            contents = transactionBody.getFileCreate().getContents().toByteArray();\n+        }\n+\n+        if (contents == null || contents.length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n         try {\n-            if (transactionBody.hasFileAppend()) {\n-                append(transactionBody.getFileAppend().getContents().toByteArray());\n-            } else if (transactionBody.hasFileUpdate()) {\n-                update(transactionBody.getFileUpdate().getContents().toByteArray());\n-            }\n-        } catch (IOException e) {\n-            throw new ParserException(\"Error appending to network address book\", e);\n+            parse(contents, consensusTimeStamp, fileID, isAppendOperation);\n+        } catch (Exception e) {\n+            log.warn(\"Unable to parse address book: {}\", e.getMessage());\n         }\n+\n+        persistAddressBookToDB(consensusTimeStamp);\n     }\n \n     public Collection<NodeAddress> getAddresses() {\n-        return nodeAddresses;\n+        return currentNodeAddresses;\n+    }\n+\n+    public AddressBook getCurrentAddressBook() {\n+        return currentAddressBook;\n+    }\n+\n+    public AddressBook getPartialAddressBook() {\n+        return incomingAddressBook;\n+    }\n+\n+    private boolean isSupportedAddressBookEntityNum(long entityNum) {\n+        return mirrorProperties.getAddressBookFileIdEntityNum() == entityNum;\n     }\n \n     private void init() {\n-        Path path = mirrorProperties.getAddressBookPath();\n-        try {\n-            File addressBookFile = path.toFile();\n+        // load most recent addressBook\n+        loadAddressBookFromDB();\n \n-            if (!addressBookFile.canRead()) {\n-                if (addressBookFile.exists()) {\n-                    log.warn(\"Backing up unreadable address book: {}\", path);\n-                    Files.move(path, path.resolveSibling(path + \".unreadable\"));\n-                }\n+        if (currentAddressBook == null) {\n+            // no addressBook present in db, load from fileSystem\n+            byte[] addressBookBytes = null;\n+            try {\n+                File addressBookFile = addressBookPath.toFile();\n \n-                byte[] addressBookBytes = null;\n-                Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+                if (!addressBookFile.canRead()) {\n+                    if (addressBookFile.exists()) {\n+                        log.warn(\"Backing up unreadable address book: {}\", addressBookPath);\n+                        Files.move(addressBookPath, addressBookPath.resolveSibling(addressBookPath + \".unreadable\"));\n+                    }\n \n-                if (initialAddressBook != null) {\n-                    addressBookBytes = Files.readAllBytes(initialAddressBook);\n-                    log.info(\"Loading bootstrap address book from {}\", initialAddressBook);\n+                    Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+\n+                    if (initialAddressBook != null) {\n+                        addressBookBytes = Files.readAllBytes(initialAddressBook);\n+                        log.info(\"Loading bootstrap address book from {}\", initialAddressBook);\n+                    } else {\n+                        MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n+                        String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n+                        Resource resource = new ClassPathResource(resourcePath, getClass());\n+                        addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n+                        log.info(\"Loading bootstrap address book from {}\", resource);\n+                    }\n                 } else {\n-                    MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n-                    String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n-                    Resource resource = new ClassPathResource(resourcePath, getClass());\n-                    addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n-                    log.info(\"Loading bootstrap address book from {}\", resource);\n+                    log.info(\"Restoring existing address book {}\", addressBookPath);\n+                    addressBookBytes = Files.readAllBytes(addressBookPath);\n                 }\n+            } catch (Exception e) {\n+                log.error(\"Unable to copy address book from {} to {}\", mirrorProperties\n+                        .getNetwork(), addressBookPath, e);\n+            }\n \n-                Utility.ensureDirectory(path.getParent());\n-                update(addressBookBytes);\n-            } else {\n-                log.info(\"Restoring existing address book {}\", path);\n-                update(Files.readAllBytes(path));\n+            try {\n+                parse(addressBookBytes, 0L, FileID.newBuilder()\n+                        .setShardNum(mirrorProperties.getShard()).setRealmNum(0)\n+                        .setFileNum(mirrorProperties.getAddressBookFileIdEntityNum()).build(), false);\n+                persistAddressBookToDB(0);\n+            } catch (Exception e) {\n+                log.error(\"Unable to parse address book: {}\", e.getMessage());\n             }\n-        } catch (Exception e) {\n-            log.error(\"Unable to copy address book from {} to {}\", mirrorProperties.getNetwork(), path, e);\n+        } else {\n+            // addressBook loaded from db\n+            log.info(\"Loaded addressBook details from DB. Valid from {}, {} nodes, fileSize {} B\",\n+                    currentAddressBook.getStartConsensusTimestamp(), currentAddressBook.getNodeCount(),\n+                    currentAddressBook.getFileData().length);\n         }\n \n         if (getAddresses().isEmpty()) {\n             throw new IllegalStateException(\"Unable to load a valid address book\");\n         }\n     }\n \n-    public void update(byte[] newContents) throws IOException {\n-        saveToDisk(newContents, StandardOpenOption.TRUNCATE_EXISTING);\n-    }\n-\n-    private void append(byte[] extraContents) throws IOException {\n-        saveToDisk(extraContents, StandardOpenOption.APPEND);\n-    }\n+    private void parse(byte[] contents, Long consensusTimestamp, FileID fileID, boolean append) throws Exception {\n+        byte[] addressBookBytes = null;\n+        if (append) {\n+            // concatenate bytes for impartial address books\n+            Optional<AddressBook> optionalAddressBook = addressBookRepository\n+                    .findTopByFileIdAndIsCompleteIsFalseOrderByConsensusTimestampDesc(EntityId.of(fileID));\n \n-    private void saveToDisk(byte[] contents, OpenOption openOption) throws IOException {\n-        if (contents == null || contents.length == 0) {\n-            log.warn(\"Ignored empty byte array\");\n-            return;\n+            if (optionalAddressBook.isPresent()) {\n+                AddressBook addressBook = optionalAddressBook.get();\n+                byte[] incompleteBytes = addressBook.getFileData();\n+                byte[] combinedBytes = new byte[incompleteBytes.length + contents.length];\n+                System.arraycopy(incompleteBytes, 0, combinedBytes, 0, incompleteBytes.length);\n+                System.arraycopy(contents, 0, combinedBytes, incompleteBytes.length, contents.length);\n+                addressBookBytes = combinedBytes;\n+                log.info(\"Combined incomplete addressBook from {} of size {} B with bytes from {} of {} B. Combined \" +\n+                                \"length is {}\", addressBook.getConsensusTimestamp(), incompleteBytes.length,\n+                        consensusTimestamp, contents.length, combinedBytes.length);\n+            } else {\n+                log.error(\"Previous incomplete address book entry expected but not found\");\n+            }\n+        } else {\n+            addressBookBytes = contents;\n         }\n \n-        Path path = mirrorProperties.getAddressBookPath();\n-        Path tempPath = path.resolveSibling(path.getFileName() + \".tmp\");\n-        Files.write(tempPath, contents, StandardOpenOption.CREATE, StandardOpenOption.WRITE, openOption);\n-        log.info(\"Saved {}B partial address book update to {}\", contents.length, tempPath);\n+        retrieveAddressBook(addressBookBytes, consensusTimestamp, fileID);\n+    }\n+\n+    private void retrieveAddressBook(byte[] addressBookBytes, long consensusTimestamp, FileID fileID) {\n+        AddressBook.AddressBookBuilder builder = AddressBook.builder()\n+                .fileData(addressBookBytes)\n+                .consensusTimestamp(consensusTimestamp)\n+                .fileId(EntityId.of(fileID));\n \n         try {\n-            Collection<NodeAddress> nodeAddresses = parse(tempPath);\n-            if (!nodeAddresses.isEmpty()) {\n-                Files.move(tempPath, path, StandardCopyOption.REPLACE_EXISTING);\n-                this.nodeAddresses = nodeAddresses;\n-                log.info(\"New address book with {} addresses successfully parsed and saved to {}\",\n-                        nodeAddresses.size(), path);\n+            NodeAddressBook nodeAddressBook = NodeAddressBook.parseFrom(addressBookBytes);\n+            if (nodeAddressBook != null) {\n+                builder = builder\n+                        .isComplete(true)\n+                        .nodeCount(nodeAddressBook.getNodeAddressCount())\n+                        .startConsensusTimestamp(consensusTimestamp);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d39f16caea10cf920550a8d833a4163b09d41a9c"}, "originalPosition": 268}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUzNDA5MzAx", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#pullrequestreview-453409301", "createdAt": "2020-07-22T15:04:29Z", "commit": {"oid": "093fa2bb1e993cf2c39d912e3edeb6a64d62eb9b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxNTowNDoyOVrOG1muqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMTo0NzozOVrOG2cuSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODg2MjI1MA==", "bodyText": "I don't think this needs to be a property. 102 is a well-known system file that council members will be signing. If it changes the entire ecosystem would be at risk. Also, it's confusing since we're also watching 101 but hardcoding that.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r458862250", "createdAt": "2020-07-22T15:04:29Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/MirrorProperties.java", "diffHunk": "@@ -56,6 +56,8 @@\n \n     private Long topicRunningHashV2AddedTimestamp;\n \n+    private Long addressBookFileIdEntityNum = 102L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "093fa2bb1e993cf2c39d912e3edeb6a64d62eb9b"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU0NTc1MA==", "bodyText": "We should remove converter and store in db as string as that is what comes via the protobuf.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459545750", "createdAt": "2020-07-23T15:41:27Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/NodeAddress.java", "diffHunk": "@@ -24,24 +24,51 @@\n import java.security.PublicKey;\n import java.security.spec.EncodedKeySpec;\n import java.security.spec.X509EncodedKeySpec;\n-\n+import javax.persistence.Convert;\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import lombok.AllArgsConstructor;\n import lombok.Builder;\n-import lombok.Value;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n import org.apache.commons.codec.binary.Hex;\n \n-@Builder\n-@Value\n+import com.hedera.mirror.importer.converter.EntityIdConverter;\n+import com.hedera.mirror.importer.converter.StringToByteArrayConverter;\n+\n+@Builder(toBuilder = true)\n+@Data\n+@Entity\n+@NoArgsConstructor\n+@AllArgsConstructor\n public class NodeAddress {\n \n-    private String id;\n+    @Id\n+    @GeneratedValue(strategy = GenerationType.IDENTITY)\n+    private Long id;\n+\n+    private Long consensusTimestamp;\n+\n+    @Convert(converter = StringToByteArrayConverter.class)\n+    private String memo;\n \n     private String ip;\n \n     @Builder.Default\n     private int port = 50211;\n \n+    @Convert(converter = StringToByteArrayConverter.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1159393216a6b7fdc3b26617b1afd2c36c70047e"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU0OTY2OQ==", "bodyText": "We should store as varchar(1024) since it's a hex encoded string and is modeled as string in the protobuf", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459549669", "createdAt": "2020-07-23T15:47:09Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/resources/db/migration/V1.28.0__address_book.sql", "diffHunk": "@@ -0,0 +1,42 @@\n+-------------------\n+-- Support db storage of netowrk address books\n+-------------------\n+\n+-- add address book table\n+create table if not exists address_book\n+(\n+    consensus_timestamp         nanos_timestamp primary key,\n+    start_consensus_timestamp   nanos_timestamp null,\n+    end_consensus_timestamp     nanos_timestamp null,\n+    file_id                     entity_id       not null,\n+    node_count                  smallint        null,\n+    file_data                   bytea           not null,\n+    is_complete                 boolean         not null default false\n+);\n+\n+create index if not exists address_book__fileId_isComplete\n+    on address_book (file_id, is_complete);\n+\n+-- add node address table\n+create table if not exists node_address\n+(\n+    id                      serial          primary key,\n+    consensus_timestamp     nanos_timestamp not null,\n+    ip                      varchar(128)    null,\n+    port                    integer         null,\n+    memo                    bytea           not null,\n+    public_key              bytea           null,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1159393216a6b7fdc3b26617b1afd2c36c70047e"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY2NjU2MA==", "bodyText": "Either a) we don't really care about the type for our purposes and can use generic EntityIdConverter or b) we should extend EntityIdConverter for reuse and supply EntityTypeEnum to parent constructor.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459666560", "createdAt": "2020-07-23T19:05:36Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/converter/FileIdConverter.java", "diffHunk": "@@ -0,0 +1,58 @@\n+package com.hedera.mirror.importer.converter;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import javax.inject.Named;\n+import javax.persistence.AttributeConverter;\n+import org.springframework.boot.context.properties.ConfigurationPropertiesBinding;\n+import org.springframework.core.convert.converter.Converter;\n+\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.util.EntityIdEndec;\n+\n+@Named\n+@javax.persistence.Converter\n+@ConfigurationPropertiesBinding\n+public class FileIdConverter implements AttributeConverter<EntityId, Long>, Converter<String, EntityId> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1159393216a6b7fdc3b26617b1afd2c36c70047e"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY2ODQyOQ==", "bodyText": "There's no point in storing as bytea if we only ever use it as string. We should use string in both places or byte array in both places. Recommend string in both and removing converter.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459668429", "createdAt": "2020-07-23T19:09:14Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/NodeAddress.java", "diffHunk": "@@ -24,24 +24,51 @@\n import java.security.PublicKey;\n import java.security.spec.EncodedKeySpec;\n import java.security.spec.X509EncodedKeySpec;\n-\n+import javax.persistence.Convert;\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import lombok.AllArgsConstructor;\n import lombok.Builder;\n-import lombok.Value;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n import org.apache.commons.codec.binary.Hex;\n \n-@Builder\n-@Value\n+import com.hedera.mirror.importer.converter.EntityIdConverter;\n+import com.hedera.mirror.importer.converter.StringToByteArrayConverter;\n+\n+@Builder(toBuilder = true)\n+@Data\n+@Entity\n+@NoArgsConstructor\n+@AllArgsConstructor\n public class NodeAddress {\n \n-    private String id;\n+    @Id\n+    @GeneratedValue(strategy = GenerationType.IDENTITY)\n+    private Long id;\n+\n+    private Long consensusTimestamp;\n+\n+    @Convert(converter = StringToByteArrayConverter.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1159393216a6b7fdc3b26617b1afd2c36c70047e"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY3MTUyOQ==", "bodyText": "From the protobuf usage to store account ID is deprecated. We should use getNodeAccountId() and if need be internally it should get from memo if it is null to be backwards compatible. This will make it clearer our intent.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459671529", "createdAt": "2020-07-23T19:15:14Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "diffHunk": "@@ -159,7 +159,7 @@ protected void downloadNextBatch() {\n \n         Set<String> nodeAccountIds = networkAddressBook.getAddresses()\n                 .stream()\n-                .map(NodeAddress::getId)\n+                .map(NodeAddress::getMemo)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1159393216a6b7fdc3b26617b1afd2c36c70047e"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY3MTc3MA==", "bodyText": "getNodeAccountId()", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459671770", "createdAt": "2020-07-23T19:15:38Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/NodeSignatureVerifier.java", "diffHunk": "@@ -49,7 +49,7 @@ public NodeSignatureVerifier(NetworkAddressBook networkAddressBook) {\n         nodeIDPubKeyMap = networkAddressBook\n                 .getAddresses()\n                 .stream()\n-                .collect(Collectors.toMap(NodeAddress::getId, NodeAddress::getPublicKeyAsObject));\n+                .collect(Collectors.toMap(NodeAddress::getMemo, NodeAddress::getPublicKeyAsObject));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1159393216a6b7fdc3b26617b1afd2c36c70047e"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY3Mzg3Mg==", "bodyText": "We shouldn't update address book if file transaction was unsuccessful. Since we are no longer writing files and/or updating in memory byte arrays we can push this logic into insertFileData and let db transactions handle whether it gets saved or not.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459673872", "createdAt": "2020-07-23T19:19:42Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -150,26 +150,35 @@ public void onItem(RecordItem recordItem) throws ImporterException {\n             insertContractCreateInstance(consensusNs, body.getContractCreateInstance(), txRecord);\n         }\n \n+        FileID fileID = null;\n+        byte[] fileBytes = null;\n+        boolean isAppendOperation = false;\n         if (isSuccessful) {\n             if (body.hasConsensusSubmitMessage()) {\n                 insertConsensusTopicMessage(body.getConsensusSubmitMessage(), txRecord);\n             } else if (body.hasCryptoAddLiveHash()) {\n                 insertCryptoAddLiveHash(consensusNs, body.getCryptoAddLiveHash());\n             } else if (body.hasFileAppend()) {\n-                insertFileAppend(consensusNs, body.getFileAppend());\n+                fileID = body.getFileAppend().getFileID();\n+                fileBytes = body.getFileAppend().getContents().toByteArray();\n+                isAppendOperation = true;\n+                insertFileData(consensusNs, fileBytes, fileID);\n             } else if (body.hasFileCreate()) {\n-                insertFileData(consensusNs, body.getFileCreate().getContents().toByteArray(),\n-                        txRecord.getReceipt().getFileID());\n+                fileID = txRecord.getReceipt().getFileID();\n+                fileBytes = body.getFileCreate().getContents().toByteArray();\n+                insertFileData(consensusNs, fileBytes, fileID);\n             } else if (body.hasFileUpdate()) {\n-                insertFileUpdate(consensusNs, body.getFileUpdate());\n+                fileID = body.getFileUpdate().getFileID();\n+                fileBytes = body.getFileUpdate().getContents().toByteArray();\n+                insertFileData(consensusNs, fileBytes, fileID);\n             }\n         }\n \n         entityListener.onTransaction(tx);\n         log.debug(\"Storing transaction: {}\", tx);\n \n-        if (NetworkAddressBook.isAddressBook(entityId)) {\n-            networkAddressBook.updateFrom(body);\n+        if (networkAddressBook.isAddressBook(entityId)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1159393216a6b7fdc3b26617b1afd2c36c70047e"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY3Njg4NQ==", "bodyText": "insertFileAppend and insertFileUpdate are now unused methods. Not a fan of moving the per type logic from the individual methods to this if statement. Recommend we keep the more self-contained original approach of single line calls to methods that can handle the types. Also because we later want to refactor this into the separate file handler classes.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459676885", "createdAt": "2020-07-23T19:25:07Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -150,26 +150,35 @@ public void onItem(RecordItem recordItem) throws ImporterException {\n             insertContractCreateInstance(consensusNs, body.getContractCreateInstance(), txRecord);\n         }\n \n+        FileID fileID = null;\n+        byte[] fileBytes = null;\n+        boolean isAppendOperation = false;\n         if (isSuccessful) {\n             if (body.hasConsensusSubmitMessage()) {\n                 insertConsensusTopicMessage(body.getConsensusSubmitMessage(), txRecord);\n             } else if (body.hasCryptoAddLiveHash()) {\n                 insertCryptoAddLiveHash(consensusNs, body.getCryptoAddLiveHash());\n             } else if (body.hasFileAppend()) {\n-                insertFileAppend(consensusNs, body.getFileAppend());\n+                fileID = body.getFileAppend().getFileID();\n+                fileBytes = body.getFileAppend().getContents().toByteArray();\n+                isAppendOperation = true;\n+                insertFileData(consensusNs, fileBytes, fileID);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1159393216a6b7fdc3b26617b1afd2c36c70047e"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY3OTUyMA==", "bodyText": "Recommend normalized FileData object be passed to NetworkAddressBook. Can add a field to FileData to indicate create, update or append.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459679520", "createdAt": "2020-07-23T19:30:09Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -150,26 +150,35 @@ public void onItem(RecordItem recordItem) throws ImporterException {\n             insertContractCreateInstance(consensusNs, body.getContractCreateInstance(), txRecord);\n         }\n \n+        FileID fileID = null;\n+        byte[] fileBytes = null;\n+        boolean isAppendOperation = false;\n         if (isSuccessful) {\n             if (body.hasConsensusSubmitMessage()) {\n                 insertConsensusTopicMessage(body.getConsensusSubmitMessage(), txRecord);\n             } else if (body.hasCryptoAddLiveHash()) {\n                 insertCryptoAddLiveHash(consensusNs, body.getCryptoAddLiveHash());\n             } else if (body.hasFileAppend()) {\n-                insertFileAppend(consensusNs, body.getFileAppend());\n+                fileID = body.getFileAppend().getFileID();\n+                fileBytes = body.getFileAppend().getContents().toByteArray();\n+                isAppendOperation = true;\n+                insertFileData(consensusNs, fileBytes, fileID);\n             } else if (body.hasFileCreate()) {\n-                insertFileData(consensusNs, body.getFileCreate().getContents().toByteArray(),\n-                        txRecord.getReceipt().getFileID());\n+                fileID = txRecord.getReceipt().getFileID();\n+                fileBytes = body.getFileCreate().getContents().toByteArray();\n+                insertFileData(consensusNs, fileBytes, fileID);\n             } else if (body.hasFileUpdate()) {\n-                insertFileUpdate(consensusNs, body.getFileUpdate());\n+                fileID = body.getFileUpdate().getFileID();\n+                fileBytes = body.getFileUpdate().getContents().toByteArray();\n+                insertFileData(consensusNs, fileBytes, fileID);\n             }\n         }\n \n         entityListener.onTransaction(tx);\n         log.debug(\"Storing transaction: {}\", tx);\n \n-        if (NetworkAddressBook.isAddressBook(entityId)) {\n-            networkAddressBook.updateFrom(body);\n+        if (networkAddressBook.isAddressBook(entityId)) {\n+            networkAddressBook.updateFrom(consensusNs, fileBytes, fileID, isAppendOperation);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1159393216a6b7fdc3b26617b1afd2c36c70047e"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcwMDM5Mg==", "bodyText": "I understand it was called NodeAdress previously and the protobuf calls it a NodeAddress, but in terms of domain driven design the AddressBook is the aggregate and this class is its dependent child. Any references to this class have to come via the aggregate as this is not a standalone class without the context that the parent provides. As a result, I recommend we call it something that denotes this dependency like AddressBookEntry.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459700392", "createdAt": "2020-07-23T20:11:32Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/NodeAddress.java", "diffHunk": "@@ -24,24 +24,51 @@\n import java.security.PublicKey;\n import java.security.spec.EncodedKeySpec;\n import java.security.spec.X509EncodedKeySpec;\n-\n+import javax.persistence.Convert;\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import lombok.AllArgsConstructor;\n import lombok.Builder;\n-import lombok.Value;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n import org.apache.commons.codec.binary.Hex;\n \n-@Builder\n-@Value\n+import com.hedera.mirror.importer.converter.EntityIdConverter;\n+import com.hedera.mirror.importer.converter.StringToByteArrayConverter;\n+\n+@Builder(toBuilder = true)\n+@Data\n+@Entity\n+@NoArgsConstructor\n+@AllArgsConstructor\n public class NodeAddress {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1159393216a6b7fdc3b26617b1afd2c36c70047e"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcwMjM0MA==", "bodyText": "Being that this is the aggregate, we should probably model this with @OneToMany and eagerly fetch a list of address book entries directly in the domain. This would reduce the need to use multiple repositories and simplify the code that uses the address book.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459702340", "createdAt": "2020-07-23T20:15:33Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/AddressBook.java", "diffHunk": "@@ -0,0 +1,55 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import javax.persistence.Convert;\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import lombok.AllArgsConstructor;\n+import lombok.Builder;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+\n+import com.hedera.mirror.importer.converter.FileIdConverter;\n+\n+@Builder(toBuilder = true)\n+@Data\n+@Entity\n+@NoArgsConstructor\n+@AllArgsConstructor\n+public class AddressBook {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1159393216a6b7fdc3b26617b1afd2c36c70047e"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcwMzgyOQ==", "bodyText": "This is too complex. Now that we have the address book in the database we should simply delete or modify the necessary rows there for these tests or use repository mocks.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459703829", "createdAt": "2020-07-23T20:18:26Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/downloader/AbstractDownloaderTest.java", "diffHunk": "@@ -206,10 +217,17 @@ void partialConsensus() throws Exception {\n     @DisplayName(\"Exactly 1/3 consensus\")\n     void oneThirdConsensus() throws Exception {\n         // Remove last node from current 4 node address book\n-        byte[] addressBook = Files.readAllBytes(mirrorProperties.getAddressBookPath());\n+        MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n+        String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n+        Resource resource = new ClassPathResource(resourcePath, getClass());\n+        byte[] addressBook = IOUtils.toByteArray(resource.getInputStream());\n         int index = Bytes.lastIndexOf(addressBook, (byte) '\\n');\n         addressBook = Arrays.copyOfRange(addressBook, 0, index);\n-        networkAddressBook.update(addressBook);\n+        networkAddressBook.updateFrom(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1159393216a6b7fdc3b26617b1afd2c36c70047e"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcxNDU3Mg==", "bodyText": "I'm not sure why people keep adding repositories here. We don't need to add to the parent class unless multiple children need it, which they currently don't.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459714572", "createdAt": "2020-07-23T20:39:12Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/repository/AbstractRepositoryTest.java", "diffHunk": "@@ -53,6 +53,10 @@\n     protected TransactionTypeRepository transactionTypeRepository;\n     @Resource\n     protected EntityTypeRepository entityTypeRepository;\n+    @Resource", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1159393216a6b7fdc3b26617b1afd2c36c70047e"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcxNTQ3OA==", "bodyText": "network", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459715478", "createdAt": "2020-07-23T20:40:58Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/resources/db/migration/V1.28.0__address_book.sql", "diffHunk": "@@ -0,0 +1,42 @@\n+-------------------\n+-- Support db storage of netowrk address books", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1159393216a6b7fdc3b26617b1afd2c36c70047e"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcyNzU4Nw==", "bodyText": "As mentioned previously, recommend FileData be only input. nit: Don't like updateFrom, would prefer update(FileData filedata)", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459727587", "createdAt": "2020-07-23T21:05:12Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/NetworkAddressBook.java", "diffHunk": "@@ -21,152 +21,309 @@\n  */\n \n import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.FileID;\n import com.hederahashgraph.api.proto.java.NodeAddressBook;\n-import com.hederahashgraph.api.proto.java.TransactionBody;\n import java.io.File;\n-import java.io.IOException;\n import java.nio.file.Files;\n-import java.nio.file.OpenOption;\n import java.nio.file.Path;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Optional;\n import javax.inject.Named;\n import lombok.extern.log4j.Log4j2;\n import org.apache.commons.io.IOUtils;\n import org.springframework.core.io.ClassPathResource;\n import org.springframework.core.io.Resource;\n \n import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n import com.hedera.mirror.importer.domain.EntityId;\n import com.hedera.mirror.importer.domain.EntityTypeEnum;\n import com.hedera.mirror.importer.domain.NodeAddress;\n-import com.hedera.mirror.importer.exception.ParserException;\n-import com.hedera.mirror.importer.util.Utility;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.NodeAddressRepository;\n \n @Log4j2\n @Named\n public class NetworkAddressBook {\n-\n     private final MirrorProperties mirrorProperties;\n-    private volatile Collection<NodeAddress> nodeAddresses;\n+    private final AddressBookRepository addressBookRepository;\n+    private final NodeAddressRepository nodeAddressRepository;\n+\n+    private volatile Collection<NodeAddress> currentNodeAddresses;\n+    private volatile Collection<NodeAddress> incomingNodeAddresses;\n+    private volatile AddressBook currentAddressBook;\n+    private volatile AddressBook incomingAddressBook;\n+    private final Path addressBookPath;\n \n-    public NetworkAddressBook(MirrorProperties mirrorProperties) {\n+    public NetworkAddressBook(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                              NodeAddressRepository nodeAddressRepository) {\n         this.mirrorProperties = mirrorProperties;\n-        nodeAddresses = Collections.emptyList();\n+        this.addressBookRepository = addressBookRepository;\n+        this.nodeAddressRepository = nodeAddressRepository;\n+        currentNodeAddresses = Collections.emptyList();\n+        incomingNodeAddresses = Collections.emptyList();\n+        currentAddressBook = null;\n+        incomingAddressBook = null;\n+        addressBookPath = mirrorProperties.getAddressBookPath();\n         init();\n     }\n \n-    public static boolean isAddressBook(EntityId entityId) {\n-        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId()\n-                && entityId.getEntityNum() == 102 && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n+    public boolean isAddressBook(EntityId entityId) {\n+        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId() &&\n+                (entityId.getEntityNum() == 101 || entityId.getEntityNum() == mirrorProperties\n+                        .getAddressBookFileIdEntityNum())\n+                && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n     }\n \n-    public void updateFrom(TransactionBody transactionBody) {\n+    public void updateFrom(long consensusTimeStamp, byte[] contents, FileID fileID, boolean isAppendOperation) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1159393216a6b7fdc3b26617b1afd2c36c70047e"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcyODAwNw==", "bodyText": "We should not have public methods for tests", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459728007", "createdAt": "2020-07-23T21:06:01Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/NetworkAddressBook.java", "diffHunk": "@@ -21,152 +21,309 @@\n  */\n \n import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.FileID;\n import com.hederahashgraph.api.proto.java.NodeAddressBook;\n-import com.hederahashgraph.api.proto.java.TransactionBody;\n import java.io.File;\n-import java.io.IOException;\n import java.nio.file.Files;\n-import java.nio.file.OpenOption;\n import java.nio.file.Path;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Optional;\n import javax.inject.Named;\n import lombok.extern.log4j.Log4j2;\n import org.apache.commons.io.IOUtils;\n import org.springframework.core.io.ClassPathResource;\n import org.springframework.core.io.Resource;\n \n import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n import com.hedera.mirror.importer.domain.EntityId;\n import com.hedera.mirror.importer.domain.EntityTypeEnum;\n import com.hedera.mirror.importer.domain.NodeAddress;\n-import com.hedera.mirror.importer.exception.ParserException;\n-import com.hedera.mirror.importer.util.Utility;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.NodeAddressRepository;\n \n @Log4j2\n @Named\n public class NetworkAddressBook {\n-\n     private final MirrorProperties mirrorProperties;\n-    private volatile Collection<NodeAddress> nodeAddresses;\n+    private final AddressBookRepository addressBookRepository;\n+    private final NodeAddressRepository nodeAddressRepository;\n+\n+    private volatile Collection<NodeAddress> currentNodeAddresses;\n+    private volatile Collection<NodeAddress> incomingNodeAddresses;\n+    private volatile AddressBook currentAddressBook;\n+    private volatile AddressBook incomingAddressBook;\n+    private final Path addressBookPath;\n \n-    public NetworkAddressBook(MirrorProperties mirrorProperties) {\n+    public NetworkAddressBook(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                              NodeAddressRepository nodeAddressRepository) {\n         this.mirrorProperties = mirrorProperties;\n-        nodeAddresses = Collections.emptyList();\n+        this.addressBookRepository = addressBookRepository;\n+        this.nodeAddressRepository = nodeAddressRepository;\n+        currentNodeAddresses = Collections.emptyList();\n+        incomingNodeAddresses = Collections.emptyList();\n+        currentAddressBook = null;\n+        incomingAddressBook = null;\n+        addressBookPath = mirrorProperties.getAddressBookPath();\n         init();\n     }\n \n-    public static boolean isAddressBook(EntityId entityId) {\n-        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId()\n-                && entityId.getEntityNum() == 102 && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n+    public boolean isAddressBook(EntityId entityId) {\n+        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId() &&\n+                (entityId.getEntityNum() == 101 || entityId.getEntityNum() == mirrorProperties\n+                        .getAddressBookFileIdEntityNum())\n+                && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n     }\n \n-    public void updateFrom(TransactionBody transactionBody) {\n+    public void updateFrom(long consensusTimeStamp, byte[] contents, FileID fileID, boolean isAppendOperation) {\n+        if (contents == null || contents.length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n         try {\n-            if (transactionBody.hasFileAppend()) {\n-                append(transactionBody.getFileAppend().getContents().toByteArray());\n-            } else if (transactionBody.hasFileUpdate()) {\n-                update(transactionBody.getFileUpdate().getContents().toByteArray());\n-            }\n-        } catch (IOException e) {\n-            throw new ParserException(\"Error appending to network address book\", e);\n+            parse(contents, consensusTimeStamp, fileID, isAppendOperation);\n+        } catch (Exception e) {\n+            log.warn(\"Unable to parse address book: {}\", e.getMessage());\n         }\n+\n+        persistAddressBookToDB(consensusTimeStamp);\n     }\n \n     public Collection<NodeAddress> getAddresses() {\n-        return nodeAddresses;\n+        return currentNodeAddresses;\n+    }\n+\n+    public AddressBook getCurrentAddressBook() {\n+        return currentAddressBook;\n+    }\n+\n+    public AddressBook getPartialAddressBook() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1159393216a6b7fdc3b26617b1afd2c36c70047e"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcyODUyNQ==", "bodyText": "private or package protected for tests. Though this method should go away when we don't store in memory objects.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459728525", "createdAt": "2020-07-23T21:07:04Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/NetworkAddressBook.java", "diffHunk": "@@ -21,152 +21,309 @@\n  */\n \n import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.FileID;\n import com.hederahashgraph.api.proto.java.NodeAddressBook;\n-import com.hederahashgraph.api.proto.java.TransactionBody;\n import java.io.File;\n-import java.io.IOException;\n import java.nio.file.Files;\n-import java.nio.file.OpenOption;\n import java.nio.file.Path;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Optional;\n import javax.inject.Named;\n import lombok.extern.log4j.Log4j2;\n import org.apache.commons.io.IOUtils;\n import org.springframework.core.io.ClassPathResource;\n import org.springframework.core.io.Resource;\n \n import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n import com.hedera.mirror.importer.domain.EntityId;\n import com.hedera.mirror.importer.domain.EntityTypeEnum;\n import com.hedera.mirror.importer.domain.NodeAddress;\n-import com.hedera.mirror.importer.exception.ParserException;\n-import com.hedera.mirror.importer.util.Utility;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.NodeAddressRepository;\n \n @Log4j2\n @Named\n public class NetworkAddressBook {\n-\n     private final MirrorProperties mirrorProperties;\n-    private volatile Collection<NodeAddress> nodeAddresses;\n+    private final AddressBookRepository addressBookRepository;\n+    private final NodeAddressRepository nodeAddressRepository;\n+\n+    private volatile Collection<NodeAddress> currentNodeAddresses;\n+    private volatile Collection<NodeAddress> incomingNodeAddresses;\n+    private volatile AddressBook currentAddressBook;\n+    private volatile AddressBook incomingAddressBook;\n+    private final Path addressBookPath;\n \n-    public NetworkAddressBook(MirrorProperties mirrorProperties) {\n+    public NetworkAddressBook(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                              NodeAddressRepository nodeAddressRepository) {\n         this.mirrorProperties = mirrorProperties;\n-        nodeAddresses = Collections.emptyList();\n+        this.addressBookRepository = addressBookRepository;\n+        this.nodeAddressRepository = nodeAddressRepository;\n+        currentNodeAddresses = Collections.emptyList();\n+        incomingNodeAddresses = Collections.emptyList();\n+        currentAddressBook = null;\n+        incomingAddressBook = null;\n+        addressBookPath = mirrorProperties.getAddressBookPath();\n         init();\n     }\n \n-    public static boolean isAddressBook(EntityId entityId) {\n-        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId()\n-                && entityId.getEntityNum() == 102 && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n+    public boolean isAddressBook(EntityId entityId) {\n+        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId() &&\n+                (entityId.getEntityNum() == 101 || entityId.getEntityNum() == mirrorProperties\n+                        .getAddressBookFileIdEntityNum())\n+                && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n     }\n \n-    public void updateFrom(TransactionBody transactionBody) {\n+    public void updateFrom(long consensusTimeStamp, byte[] contents, FileID fileID, boolean isAppendOperation) {\n+        if (contents == null || contents.length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n         try {\n-            if (transactionBody.hasFileAppend()) {\n-                append(transactionBody.getFileAppend().getContents().toByteArray());\n-            } else if (transactionBody.hasFileUpdate()) {\n-                update(transactionBody.getFileUpdate().getContents().toByteArray());\n-            }\n-        } catch (IOException e) {\n-            throw new ParserException(\"Error appending to network address book\", e);\n+            parse(contents, consensusTimeStamp, fileID, isAppendOperation);\n+        } catch (Exception e) {\n+            log.warn(\"Unable to parse address book: {}\", e.getMessage());\n         }\n+\n+        persistAddressBookToDB(consensusTimeStamp);\n     }\n \n     public Collection<NodeAddress> getAddresses() {\n-        return nodeAddresses;\n+        return currentNodeAddresses;\n+    }\n+\n+    public AddressBook getCurrentAddressBook() {\n+        return currentAddressBook;\n+    }\n+\n+    public AddressBook getPartialAddressBook() {\n+        return incomingAddressBook;\n+    }\n+\n+    private boolean isSupportedAddressBookEntityNum(long entityNum) {\n+        return mirrorProperties.getAddressBookFileIdEntityNum() == entityNum;\n     }\n \n     private void init() {\n-        Path path = mirrorProperties.getAddressBookPath();\n-        try {\n-            File addressBookFile = path.toFile();\n+        // load most recent addressBook\n+        loadAddressBookFromDB();\n \n-            if (!addressBookFile.canRead()) {\n-                if (addressBookFile.exists()) {\n-                    log.warn(\"Backing up unreadable address book: {}\", path);\n-                    Files.move(path, path.resolveSibling(path + \".unreadable\"));\n-                }\n+        if (currentAddressBook == null) {\n+            // no addressBook present in db, load from fileSystem\n+            byte[] addressBookBytes = null;\n+            try {\n+                File addressBookFile = addressBookPath.toFile();\n \n-                byte[] addressBookBytes = null;\n-                Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+                if (!addressBookFile.canRead()) {\n+                    if (addressBookFile.exists()) {\n+                        log.warn(\"Backing up unreadable address book: {}\", addressBookPath);\n+                        Files.move(addressBookPath, addressBookPath.resolveSibling(addressBookPath + \".unreadable\"));\n+                    }\n \n-                if (initialAddressBook != null) {\n-                    addressBookBytes = Files.readAllBytes(initialAddressBook);\n-                    log.info(\"Loading bootstrap address book from {}\", initialAddressBook);\n+                    Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+\n+                    if (initialAddressBook != null) {\n+                        addressBookBytes = Files.readAllBytes(initialAddressBook);\n+                        log.info(\"Loading bootstrap address book from {}\", initialAddressBook);\n+                    } else {\n+                        MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n+                        String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n+                        Resource resource = new ClassPathResource(resourcePath, getClass());\n+                        addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n+                        log.info(\"Loading bootstrap address book from {}\", resource);\n+                    }\n                 } else {\n-                    MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n-                    String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n-                    Resource resource = new ClassPathResource(resourcePath, getClass());\n-                    addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n-                    log.info(\"Loading bootstrap address book from {}\", resource);\n+                    log.info(\"Restoring existing address book {}\", addressBookPath);\n+                    addressBookBytes = Files.readAllBytes(addressBookPath);\n                 }\n+            } catch (Exception e) {\n+                throw new IllegalStateException(String\n+                        .format(\"Unable to load valid address book from %s\", addressBookPath));\n+            }\n \n-                Utility.ensureDirectory(path.getParent());\n-                update(addressBookBytes);\n-            } else {\n-                log.info(\"Restoring existing address book {}\", path);\n-                update(Files.readAllBytes(path));\n+            try {\n+                parse(addressBookBytes, 0L, FileID.newBuilder()\n+                        .setShardNum(mirrorProperties.getShard()).setRealmNum(0)\n+                        .setFileNum(mirrorProperties.getAddressBookFileIdEntityNum()).build(), false);\n+                persistAddressBookToDB(0);\n+            } catch (Exception e) {\n+                throw new IllegalStateException(\"Unable to parse address book: \", e);\n             }\n-        } catch (Exception e) {\n-            log.error(\"Unable to copy address book from {} to {}\", mirrorProperties.getNetwork(), path, e);\n+        } else {\n+            // addressBook loaded from db\n+            log.info(\"Loaded addressBook details from DB. Valid from {}, {} nodes, fileSize {} B\",\n+                    currentAddressBook.getStartConsensusTimestamp(), currentAddressBook.getNodeCount(),\n+                    currentAddressBook.getFileData().length);\n         }\n \n         if (getAddresses().isEmpty()) {\n-            throw new IllegalStateException(\"Unable to load a valid address book\");\n+            throw new IllegalStateException(\"Unable to load a valid address book with node addresses\");\n         }\n     }\n \n-    public void update(byte[] newContents) throws IOException {\n-        saveToDisk(newContents, StandardOpenOption.TRUNCATE_EXISTING);\n-    }\n+    private void parse(byte[] contents, Long consensusTimestamp, FileID fileID, boolean append) throws Exception {\n+        byte[] addressBookBytes = null;\n+        if (append) {\n+            // concatenate bytes for impartial address books\n+            AddressBook addressBook = getPreviousAddressBookToAppendTo(fileID);\n \n-    private void append(byte[] extraContents) throws IOException {\n-        saveToDisk(extraContents, StandardOpenOption.APPEND);\n+            if (addressBook != null) {\n+                byte[] incompleteBytes = addressBook.getFileData();\n+                byte[] combinedBytes = new byte[incompleteBytes.length + contents.length];\n+                System.arraycopy(incompleteBytes, 0, combinedBytes, 0, incompleteBytes.length);\n+                System.arraycopy(contents, 0, combinedBytes, incompleteBytes.length, contents.length);\n+                addressBookBytes = combinedBytes;\n+                log.info(\"Combined incomplete addressBook from {} of size {} B with bytes from {} of {} B. Combined \" +\n+                                \"length is {}\", addressBook.getConsensusTimestamp(), incompleteBytes.length,\n+                        consensusTimestamp, contents.length, combinedBytes.length);\n+            } else {\n+                log.error(\"Previous incomplete address book entry expected but not found\");\n+            }\n+        } else {\n+            addressBookBytes = contents;\n+        }\n+\n+        retrieveAddressBook(addressBookBytes, consensusTimestamp, fileID);\n     }\n \n-    private void saveToDisk(byte[] contents, OpenOption openOption) throws IOException {\n-        if (contents == null || contents.length == 0) {\n-            log.warn(\"Ignored empty byte array\");\n-            return;\n+    private AddressBook getPreviousAddressBookToAppendTo(FileID fileID) {\n+        // if incomingAddressBook is a match use it if not retrieve last address book for given file from Db\n+        if (incomingAddressBook != null && incomingAddressBook.getFileId().getEntityNum() == fileID.getFileNum()) {\n+            return incomingAddressBook;\n         }\n \n-        Path path = mirrorProperties.getAddressBookPath();\n-        Path tempPath = path.resolveSibling(path.getFileName() + \".tmp\");\n-        Files.write(tempPath, contents, StandardOpenOption.CREATE, StandardOpenOption.WRITE, openOption);\n-        log.info(\"Saved {}B partial address book update to {}\", contents.length, tempPath);\n+        Optional<AddressBook> optionalAddressBook = addressBookRepository\n+                .findTopByFileIdOrderByConsensusTimestampDesc(EntityId.of(fileID));\n+\n+        return optionalAddressBook.isPresent() ? optionalAddressBook.get() : null;\n+    }\n+\n+    private void retrieveAddressBook(byte[] addressBookBytes, long consensusTimestamp, FileID fileID) {\n+        AddressBook.AddressBookBuilder builder = AddressBook.builder()\n+                .fileData(addressBookBytes)\n+                .consensusTimestamp(consensusTimestamp)\n+                .fileId(EntityId.of(fileID));\n \n         try {\n-            Collection<NodeAddress> nodeAddresses = parse(tempPath);\n-            if (!nodeAddresses.isEmpty()) {\n-                Files.move(tempPath, path, StandardCopyOption.REPLACE_EXISTING);\n-                this.nodeAddresses = nodeAddresses;\n-                log.info(\"New address book with {} addresses successfully parsed and saved to {}\",\n-                        nodeAddresses.size(), path);\n+            NodeAddressBook nodeAddressBook = NodeAddressBook.parseFrom(addressBookBytes);\n+            if (nodeAddressBook != null) {\n+                builder\n+                        .isComplete(true)\n+                        .nodeCount(nodeAddressBook.getNodeAddressCount())\n+                        .startConsensusTimestamp(consensusTimestamp);\n+\n+                Collection<NodeAddress> nodeAddresses = retrieveNodeAddressesFromAddressBook(nodeAddressBook);\n+                if (nodeAddressBook.getNodeAddressCount() > 0) {\n+                    incomingNodeAddresses = nodeAddresses;\n+                }\n             }\n         } catch (Exception e) {\n             log.warn(\"Unable to parse address book: {}\", e.getMessage());\n+            incomingNodeAddresses = Collections.emptyList();\n         }\n+\n+        incomingAddressBook = builder.build();\n     }\n \n-    private Collection<NodeAddress> parse(Path path) throws Exception {\n-        byte[] addressBookBytes = Files.readAllBytes(path);\n-        NodeAddressBook nodeAddressBook = NodeAddressBook.parseFrom(addressBookBytes);\n+    private Collection<NodeAddress> retrieveNodeAddressesFromAddressBook(NodeAddressBook nodeAddressBook) {\n         ImmutableList.Builder<NodeAddress> builder = ImmutableList.builder();\n \n-        for (com.hederahashgraph.api.proto.java.NodeAddress nodeAddressProto : nodeAddressBook\n-                .getNodeAddressList()) {\n-            NodeAddress nodeAddress = NodeAddress.builder()\n-                    .id(nodeAddressProto.getMemo().toStringUtf8())\n-                    .ip(nodeAddressProto.getIpAddress().toStringUtf8())\n-                    .port(nodeAddressProto.getPortno())\n-                    .publicKey(nodeAddressProto.getRSAPubKey())\n-                    .build();\n-            builder.add(nodeAddress);\n+        if (nodeAddressBook != null) {\n+            for (com.hederahashgraph.api.proto.java.NodeAddress nodeAddressProto : nodeAddressBook\n+                    .getNodeAddressList()) {\n+                NodeAddress nodeAddress = NodeAddress.builder()\n+                        .memo(nodeAddressProto.getMemo().toStringUtf8())\n+                        .ip(nodeAddressProto.getIpAddress().toStringUtf8())\n+                        .port(nodeAddressProto.getPortno())\n+                        .publicKey(nodeAddressProto.getRSAPubKey())\n+                        .build();\n+                builder.add(nodeAddress);\n+            }\n         }\n \n         return builder.build();\n     }\n+\n+    private void persistAddressBookToDB(long consensusTimestamp) {\n+        // store complete address book\n+        saveAddressBook(consensusTimestamp);\n+\n+        // store node addresses\n+        saveNodeAddresses(consensusTimestamp);\n+    }\n+\n+    private void saveAddressBook(long consensusTimestamp) {\n+        if (incomingAddressBook != null) {\n+\n+            // if address book is complete update end time of previous address book and start time of this\n+            if (incomingAddressBook.isComplete()) {\n+                // retrieve last complete address book for fileID and update endConsensusTimestamp\n+                Optional<AddressBook> addressBook = addressBookRepository\n+                        .findTopByFileIdAndIsCompleteIsTrueOrderByConsensusTimestampDesc(incomingAddressBook\n+                                .getFileId());\n+                if (addressBook.isPresent()) {\n+                    addressBookRepository\n+                            .updateEndConsensusTimestamp(addressBook.get()\n+                                    .getConsensusTimestamp(), consensusTimestamp - 1);\n+                }\n+            }\n+\n+            // store address book.\n+            // Potential to also remove incomplete address books entries in the db table\n+            addressBookRepository.save(incomingAddressBook);\n+            log.info(\"Saved new address book to db: {}\", incomingAddressBook);\n+        }\n+    }\n+\n+    private void saveNodeAddresses(long consensusTimestamp) {\n+        // update current node address for matching address file\n+        if (!incomingNodeAddresses.isEmpty()) {\n+            for (NodeAddress nodeAddress : incomingNodeAddresses) {\n+                // set consensusTimestamp\n+                nodeAddress.setConsensusTimestamp(consensusTimestamp);\n+            }\n+\n+            // store node addresses\n+            nodeAddressRepository.saveAll(incomingNodeAddresses);\n+            log.info(\"Saved {} new node address to db: {}\", incomingNodeAddresses.size());\n+\n+            // update currentAddressBook and nodeAddresses for supported addressBook and matching fileID's only\n+            if (isSupportedAddressBookEntityNum(incomingAddressBook.getFileId().getEntityNum())) {\n+                if (currentAddressBook == null || currentAddressBook.getFileId().getId() == incomingAddressBook\n+                        .getFileId().getId()) {\n+\n+                    // update current and reset incoming\n+                    log.info(\"Updating address book in use from {} to {}\", currentAddressBook, incomingAddressBook);\n+                    currentNodeAddresses = new ArrayList(incomingNodeAddresses);\n+                    currentAddressBook = incomingAddressBook.toBuilder().build();\n+                }\n+            }\n+        }\n+    }\n+\n+    public void loadAddressBookFromDB() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1159393216a6b7fdc3b26617b1afd2c36c70047e"}, "originalPosition": 368}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczMDExMw==", "bodyText": "You said you removed the filesystem address book but this is still present. It should be removed and mirrorProperties.getAddressBookPath() also removed", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459730113", "createdAt": "2020-07-23T21:10:36Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/NetworkAddressBook.java", "diffHunk": "@@ -21,152 +21,309 @@\n  */\n \n import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.FileID;\n import com.hederahashgraph.api.proto.java.NodeAddressBook;\n-import com.hederahashgraph.api.proto.java.TransactionBody;\n import java.io.File;\n-import java.io.IOException;\n import java.nio.file.Files;\n-import java.nio.file.OpenOption;\n import java.nio.file.Path;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Optional;\n import javax.inject.Named;\n import lombok.extern.log4j.Log4j2;\n import org.apache.commons.io.IOUtils;\n import org.springframework.core.io.ClassPathResource;\n import org.springframework.core.io.Resource;\n \n import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n import com.hedera.mirror.importer.domain.EntityId;\n import com.hedera.mirror.importer.domain.EntityTypeEnum;\n import com.hedera.mirror.importer.domain.NodeAddress;\n-import com.hedera.mirror.importer.exception.ParserException;\n-import com.hedera.mirror.importer.util.Utility;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.NodeAddressRepository;\n \n @Log4j2\n @Named\n public class NetworkAddressBook {\n-\n     private final MirrorProperties mirrorProperties;\n-    private volatile Collection<NodeAddress> nodeAddresses;\n+    private final AddressBookRepository addressBookRepository;\n+    private final NodeAddressRepository nodeAddressRepository;\n+\n+    private volatile Collection<NodeAddress> currentNodeAddresses;\n+    private volatile Collection<NodeAddress> incomingNodeAddresses;\n+    private volatile AddressBook currentAddressBook;\n+    private volatile AddressBook incomingAddressBook;\n+    private final Path addressBookPath;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1159393216a6b7fdc3b26617b1afd2c36c70047e"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczMzQ2NA==", "bodyText": "We should not store address books (current or incoming) or list of node addresses (current or incoming) in memory. Everything should be stored in the database. Besides making the code more complex to understand and maintain, it is functionally wrong since if we restart the importer between a fileupdate and a fileappend it will be lost. This was why we had the tmp file previously to ensure no loss of data during this gap.\nIf we need to cache some repository methods to make them performant then we should do so.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459733464", "createdAt": "2020-07-23T21:17:59Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/NetworkAddressBook.java", "diffHunk": "@@ -21,152 +21,309 @@\n  */\n \n import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.FileID;\n import com.hederahashgraph.api.proto.java.NodeAddressBook;\n-import com.hederahashgraph.api.proto.java.TransactionBody;\n import java.io.File;\n-import java.io.IOException;\n import java.nio.file.Files;\n-import java.nio.file.OpenOption;\n import java.nio.file.Path;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Optional;\n import javax.inject.Named;\n import lombok.extern.log4j.Log4j2;\n import org.apache.commons.io.IOUtils;\n import org.springframework.core.io.ClassPathResource;\n import org.springframework.core.io.Resource;\n \n import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n import com.hedera.mirror.importer.domain.EntityId;\n import com.hedera.mirror.importer.domain.EntityTypeEnum;\n import com.hedera.mirror.importer.domain.NodeAddress;\n-import com.hedera.mirror.importer.exception.ParserException;\n-import com.hedera.mirror.importer.util.Utility;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.NodeAddressRepository;\n \n @Log4j2\n @Named\n public class NetworkAddressBook {\n-\n     private final MirrorProperties mirrorProperties;\n-    private volatile Collection<NodeAddress> nodeAddresses;\n+    private final AddressBookRepository addressBookRepository;\n+    private final NodeAddressRepository nodeAddressRepository;\n+\n+    private volatile Collection<NodeAddress> currentNodeAddresses;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1159393216a6b7fdc3b26617b1afd2c36c70047e"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczNDQxNQ==", "bodyText": "I believe this entire method goes away and moves to a database migration.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459734415", "createdAt": "2020-07-23T21:20:03Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/NetworkAddressBook.java", "diffHunk": "@@ -21,152 +21,309 @@\n  */\n \n import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.FileID;\n import com.hederahashgraph.api.proto.java.NodeAddressBook;\n-import com.hederahashgraph.api.proto.java.TransactionBody;\n import java.io.File;\n-import java.io.IOException;\n import java.nio.file.Files;\n-import java.nio.file.OpenOption;\n import java.nio.file.Path;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Optional;\n import javax.inject.Named;\n import lombok.extern.log4j.Log4j2;\n import org.apache.commons.io.IOUtils;\n import org.springframework.core.io.ClassPathResource;\n import org.springframework.core.io.Resource;\n \n import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n import com.hedera.mirror.importer.domain.EntityId;\n import com.hedera.mirror.importer.domain.EntityTypeEnum;\n import com.hedera.mirror.importer.domain.NodeAddress;\n-import com.hedera.mirror.importer.exception.ParserException;\n-import com.hedera.mirror.importer.util.Utility;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.NodeAddressRepository;\n \n @Log4j2\n @Named\n public class NetworkAddressBook {\n-\n     private final MirrorProperties mirrorProperties;\n-    private volatile Collection<NodeAddress> nodeAddresses;\n+    private final AddressBookRepository addressBookRepository;\n+    private final NodeAddressRepository nodeAddressRepository;\n+\n+    private volatile Collection<NodeAddress> currentNodeAddresses;\n+    private volatile Collection<NodeAddress> incomingNodeAddresses;\n+    private volatile AddressBook currentAddressBook;\n+    private volatile AddressBook incomingAddressBook;\n+    private final Path addressBookPath;\n \n-    public NetworkAddressBook(MirrorProperties mirrorProperties) {\n+    public NetworkAddressBook(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                              NodeAddressRepository nodeAddressRepository) {\n         this.mirrorProperties = mirrorProperties;\n-        nodeAddresses = Collections.emptyList();\n+        this.addressBookRepository = addressBookRepository;\n+        this.nodeAddressRepository = nodeAddressRepository;\n+        currentNodeAddresses = Collections.emptyList();\n+        incomingNodeAddresses = Collections.emptyList();\n+        currentAddressBook = null;\n+        incomingAddressBook = null;\n+        addressBookPath = mirrorProperties.getAddressBookPath();\n         init();\n     }\n \n-    public static boolean isAddressBook(EntityId entityId) {\n-        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId()\n-                && entityId.getEntityNum() == 102 && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n+    public boolean isAddressBook(EntityId entityId) {\n+        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId() &&\n+                (entityId.getEntityNum() == 101 || entityId.getEntityNum() == mirrorProperties\n+                        .getAddressBookFileIdEntityNum())\n+                && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n     }\n \n-    public void updateFrom(TransactionBody transactionBody) {\n+    public void updateFrom(long consensusTimeStamp, byte[] contents, FileID fileID, boolean isAppendOperation) {\n+        if (contents == null || contents.length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n         try {\n-            if (transactionBody.hasFileAppend()) {\n-                append(transactionBody.getFileAppend().getContents().toByteArray());\n-            } else if (transactionBody.hasFileUpdate()) {\n-                update(transactionBody.getFileUpdate().getContents().toByteArray());\n-            }\n-        } catch (IOException e) {\n-            throw new ParserException(\"Error appending to network address book\", e);\n+            parse(contents, consensusTimeStamp, fileID, isAppendOperation);\n+        } catch (Exception e) {\n+            log.warn(\"Unable to parse address book: {}\", e.getMessage());\n         }\n+\n+        persistAddressBookToDB(consensusTimeStamp);\n     }\n \n     public Collection<NodeAddress> getAddresses() {\n-        return nodeAddresses;\n+        return currentNodeAddresses;\n+    }\n+\n+    public AddressBook getCurrentAddressBook() {\n+        return currentAddressBook;\n+    }\n+\n+    public AddressBook getPartialAddressBook() {\n+        return incomingAddressBook;\n+    }\n+\n+    private boolean isSupportedAddressBookEntityNum(long entityNum) {\n+        return mirrorProperties.getAddressBookFileIdEntityNum() == entityNum;\n     }\n \n     private void init() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1159393216a6b7fdc3b26617b1afd2c36c70047e"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczNTM1OA==", "bodyText": "Instead of having two public methods where the call to the second is conditional on the first returning true, we should move isAddressBook into updateFrom. This would better encapsulate this logic.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459735358", "createdAt": "2020-07-23T21:22:01Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/NetworkAddressBook.java", "diffHunk": "@@ -21,152 +21,309 @@\n  */\n \n import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.FileID;\n import com.hederahashgraph.api.proto.java.NodeAddressBook;\n-import com.hederahashgraph.api.proto.java.TransactionBody;\n import java.io.File;\n-import java.io.IOException;\n import java.nio.file.Files;\n-import java.nio.file.OpenOption;\n import java.nio.file.Path;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Optional;\n import javax.inject.Named;\n import lombok.extern.log4j.Log4j2;\n import org.apache.commons.io.IOUtils;\n import org.springframework.core.io.ClassPathResource;\n import org.springframework.core.io.Resource;\n \n import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n import com.hedera.mirror.importer.domain.EntityId;\n import com.hedera.mirror.importer.domain.EntityTypeEnum;\n import com.hedera.mirror.importer.domain.NodeAddress;\n-import com.hedera.mirror.importer.exception.ParserException;\n-import com.hedera.mirror.importer.util.Utility;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.NodeAddressRepository;\n \n @Log4j2\n @Named\n public class NetworkAddressBook {\n-\n     private final MirrorProperties mirrorProperties;\n-    private volatile Collection<NodeAddress> nodeAddresses;\n+    private final AddressBookRepository addressBookRepository;\n+    private final NodeAddressRepository nodeAddressRepository;\n+\n+    private volatile Collection<NodeAddress> currentNodeAddresses;\n+    private volatile Collection<NodeAddress> incomingNodeAddresses;\n+    private volatile AddressBook currentAddressBook;\n+    private volatile AddressBook incomingAddressBook;\n+    private final Path addressBookPath;\n \n-    public NetworkAddressBook(MirrorProperties mirrorProperties) {\n+    public NetworkAddressBook(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                              NodeAddressRepository nodeAddressRepository) {\n         this.mirrorProperties = mirrorProperties;\n-        nodeAddresses = Collections.emptyList();\n+        this.addressBookRepository = addressBookRepository;\n+        this.nodeAddressRepository = nodeAddressRepository;\n+        currentNodeAddresses = Collections.emptyList();\n+        incomingNodeAddresses = Collections.emptyList();\n+        currentAddressBook = null;\n+        incomingAddressBook = null;\n+        addressBookPath = mirrorProperties.getAddressBookPath();\n         init();\n     }\n \n-    public static boolean isAddressBook(EntityId entityId) {\n-        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId()\n-                && entityId.getEntityNum() == 102 && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n+    public boolean isAddressBook(EntityId entityId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1159393216a6b7fdc3b26617b1afd2c36c70047e"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczNTk2OQ==", "bodyText": "Since we're now dealing with an address book domain, would recommend renaming to AddressBookServiceImpl and an AddressBookService interface created.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459735969", "createdAt": "2020-07-23T21:23:12Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/NetworkAddressBook.java", "diffHunk": "@@ -21,152 +21,309 @@\n  */\n \n import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.FileID;\n import com.hederahashgraph.api.proto.java.NodeAddressBook;\n-import com.hederahashgraph.api.proto.java.TransactionBody;\n import java.io.File;\n-import java.io.IOException;\n import java.nio.file.Files;\n-import java.nio.file.OpenOption;\n import java.nio.file.Path;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Optional;\n import javax.inject.Named;\n import lombok.extern.log4j.Log4j2;\n import org.apache.commons.io.IOUtils;\n import org.springframework.core.io.ClassPathResource;\n import org.springframework.core.io.Resource;\n \n import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n import com.hedera.mirror.importer.domain.EntityId;\n import com.hedera.mirror.importer.domain.EntityTypeEnum;\n import com.hedera.mirror.importer.domain.NodeAddress;\n-import com.hedera.mirror.importer.exception.ParserException;\n-import com.hedera.mirror.importer.util.Utility;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.NodeAddressRepository;\n \n @Log4j2\n @Named\n public class NetworkAddressBook {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1159393216a6b7fdc3b26617b1afd2c36c70047e"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczNzgxNw==", "bodyText": "This does not parse the fields from the 101 file (node cert hash, etc)", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459737817", "createdAt": "2020-07-23T21:27:14Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/NetworkAddressBook.java", "diffHunk": "@@ -21,152 +21,309 @@\n  */\n \n import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.FileID;\n import com.hederahashgraph.api.proto.java.NodeAddressBook;\n-import com.hederahashgraph.api.proto.java.TransactionBody;\n import java.io.File;\n-import java.io.IOException;\n import java.nio.file.Files;\n-import java.nio.file.OpenOption;\n import java.nio.file.Path;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Optional;\n import javax.inject.Named;\n import lombok.extern.log4j.Log4j2;\n import org.apache.commons.io.IOUtils;\n import org.springframework.core.io.ClassPathResource;\n import org.springframework.core.io.Resource;\n \n import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n import com.hedera.mirror.importer.domain.EntityId;\n import com.hedera.mirror.importer.domain.EntityTypeEnum;\n import com.hedera.mirror.importer.domain.NodeAddress;\n-import com.hedera.mirror.importer.exception.ParserException;\n-import com.hedera.mirror.importer.util.Utility;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.NodeAddressRepository;\n \n @Log4j2\n @Named\n public class NetworkAddressBook {\n-\n     private final MirrorProperties mirrorProperties;\n-    private volatile Collection<NodeAddress> nodeAddresses;\n+    private final AddressBookRepository addressBookRepository;\n+    private final NodeAddressRepository nodeAddressRepository;\n+\n+    private volatile Collection<NodeAddress> currentNodeAddresses;\n+    private volatile Collection<NodeAddress> incomingNodeAddresses;\n+    private volatile AddressBook currentAddressBook;\n+    private volatile AddressBook incomingAddressBook;\n+    private final Path addressBookPath;\n \n-    public NetworkAddressBook(MirrorProperties mirrorProperties) {\n+    public NetworkAddressBook(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                              NodeAddressRepository nodeAddressRepository) {\n         this.mirrorProperties = mirrorProperties;\n-        nodeAddresses = Collections.emptyList();\n+        this.addressBookRepository = addressBookRepository;\n+        this.nodeAddressRepository = nodeAddressRepository;\n+        currentNodeAddresses = Collections.emptyList();\n+        incomingNodeAddresses = Collections.emptyList();\n+        currentAddressBook = null;\n+        incomingAddressBook = null;\n+        addressBookPath = mirrorProperties.getAddressBookPath();\n         init();\n     }\n \n-    public static boolean isAddressBook(EntityId entityId) {\n-        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId()\n-                && entityId.getEntityNum() == 102 && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n+    public boolean isAddressBook(EntityId entityId) {\n+        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId() &&\n+                (entityId.getEntityNum() == 101 || entityId.getEntityNum() == mirrorProperties\n+                        .getAddressBookFileIdEntityNum())\n+                && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n     }\n \n-    public void updateFrom(TransactionBody transactionBody) {\n+    public void updateFrom(long consensusTimeStamp, byte[] contents, FileID fileID, boolean isAppendOperation) {\n+        if (contents == null || contents.length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n         try {\n-            if (transactionBody.hasFileAppend()) {\n-                append(transactionBody.getFileAppend().getContents().toByteArray());\n-            } else if (transactionBody.hasFileUpdate()) {\n-                update(transactionBody.getFileUpdate().getContents().toByteArray());\n-            }\n-        } catch (IOException e) {\n-            throw new ParserException(\"Error appending to network address book\", e);\n+            parse(contents, consensusTimeStamp, fileID, isAppendOperation);\n+        } catch (Exception e) {\n+            log.warn(\"Unable to parse address book: {}\", e.getMessage());\n         }\n+\n+        persistAddressBookToDB(consensusTimeStamp);\n     }\n \n     public Collection<NodeAddress> getAddresses() {\n-        return nodeAddresses;\n+        return currentNodeAddresses;\n+    }\n+\n+    public AddressBook getCurrentAddressBook() {\n+        return currentAddressBook;\n+    }\n+\n+    public AddressBook getPartialAddressBook() {\n+        return incomingAddressBook;\n+    }\n+\n+    private boolean isSupportedAddressBookEntityNum(long entityNum) {\n+        return mirrorProperties.getAddressBookFileIdEntityNum() == entityNum;\n     }\n \n     private void init() {\n-        Path path = mirrorProperties.getAddressBookPath();\n-        try {\n-            File addressBookFile = path.toFile();\n+        // load most recent addressBook\n+        loadAddressBookFromDB();\n \n-            if (!addressBookFile.canRead()) {\n-                if (addressBookFile.exists()) {\n-                    log.warn(\"Backing up unreadable address book: {}\", path);\n-                    Files.move(path, path.resolveSibling(path + \".unreadable\"));\n-                }\n+        if (currentAddressBook == null) {\n+            // no addressBook present in db, load from fileSystem\n+            byte[] addressBookBytes = null;\n+            try {\n+                File addressBookFile = addressBookPath.toFile();\n \n-                byte[] addressBookBytes = null;\n-                Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+                if (!addressBookFile.canRead()) {\n+                    if (addressBookFile.exists()) {\n+                        log.warn(\"Backing up unreadable address book: {}\", addressBookPath);\n+                        Files.move(addressBookPath, addressBookPath.resolveSibling(addressBookPath + \".unreadable\"));\n+                    }\n \n-                if (initialAddressBook != null) {\n-                    addressBookBytes = Files.readAllBytes(initialAddressBook);\n-                    log.info(\"Loading bootstrap address book from {}\", initialAddressBook);\n+                    Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+\n+                    if (initialAddressBook != null) {\n+                        addressBookBytes = Files.readAllBytes(initialAddressBook);\n+                        log.info(\"Loading bootstrap address book from {}\", initialAddressBook);\n+                    } else {\n+                        MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n+                        String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n+                        Resource resource = new ClassPathResource(resourcePath, getClass());\n+                        addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n+                        log.info(\"Loading bootstrap address book from {}\", resource);\n+                    }\n                 } else {\n-                    MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n-                    String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n-                    Resource resource = new ClassPathResource(resourcePath, getClass());\n-                    addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n-                    log.info(\"Loading bootstrap address book from {}\", resource);\n+                    log.info(\"Restoring existing address book {}\", addressBookPath);\n+                    addressBookBytes = Files.readAllBytes(addressBookPath);\n                 }\n+            } catch (Exception e) {\n+                throw new IllegalStateException(String\n+                        .format(\"Unable to load valid address book from %s\", addressBookPath));\n+            }\n \n-                Utility.ensureDirectory(path.getParent());\n-                update(addressBookBytes);\n-            } else {\n-                log.info(\"Restoring existing address book {}\", path);\n-                update(Files.readAllBytes(path));\n+            try {\n+                parse(addressBookBytes, 0L, FileID.newBuilder()\n+                        .setShardNum(mirrorProperties.getShard()).setRealmNum(0)\n+                        .setFileNum(mirrorProperties.getAddressBookFileIdEntityNum()).build(), false);\n+                persistAddressBookToDB(0);\n+            } catch (Exception e) {\n+                throw new IllegalStateException(\"Unable to parse address book: \", e);\n             }\n-        } catch (Exception e) {\n-            log.error(\"Unable to copy address book from {} to {}\", mirrorProperties.getNetwork(), path, e);\n+        } else {\n+            // addressBook loaded from db\n+            log.info(\"Loaded addressBook details from DB. Valid from {}, {} nodes, fileSize {} B\",\n+                    currentAddressBook.getStartConsensusTimestamp(), currentAddressBook.getNodeCount(),\n+                    currentAddressBook.getFileData().length);\n         }\n \n         if (getAddresses().isEmpty()) {\n-            throw new IllegalStateException(\"Unable to load a valid address book\");\n+            throw new IllegalStateException(\"Unable to load a valid address book with node addresses\");\n         }\n     }\n \n-    public void update(byte[] newContents) throws IOException {\n-        saveToDisk(newContents, StandardOpenOption.TRUNCATE_EXISTING);\n-    }\n+    private void parse(byte[] contents, Long consensusTimestamp, FileID fileID, boolean append) throws Exception {\n+        byte[] addressBookBytes = null;\n+        if (append) {\n+            // concatenate bytes for impartial address books\n+            AddressBook addressBook = getPreviousAddressBookToAppendTo(fileID);\n \n-    private void append(byte[] extraContents) throws IOException {\n-        saveToDisk(extraContents, StandardOpenOption.APPEND);\n+            if (addressBook != null) {\n+                byte[] incompleteBytes = addressBook.getFileData();\n+                byte[] combinedBytes = new byte[incompleteBytes.length + contents.length];\n+                System.arraycopy(incompleteBytes, 0, combinedBytes, 0, incompleteBytes.length);\n+                System.arraycopy(contents, 0, combinedBytes, incompleteBytes.length, contents.length);\n+                addressBookBytes = combinedBytes;\n+                log.info(\"Combined incomplete addressBook from {} of size {} B with bytes from {} of {} B. Combined \" +\n+                                \"length is {}\", addressBook.getConsensusTimestamp(), incompleteBytes.length,\n+                        consensusTimestamp, contents.length, combinedBytes.length);\n+            } else {\n+                log.error(\"Previous incomplete address book entry expected but not found\");\n+            }\n+        } else {\n+            addressBookBytes = contents;\n+        }\n+\n+        retrieveAddressBook(addressBookBytes, consensusTimestamp, fileID);\n     }\n \n-    private void saveToDisk(byte[] contents, OpenOption openOption) throws IOException {\n-        if (contents == null || contents.length == 0) {\n-            log.warn(\"Ignored empty byte array\");\n-            return;\n+    private AddressBook getPreviousAddressBookToAppendTo(FileID fileID) {\n+        // if incomingAddressBook is a match use it if not retrieve last address book for given file from Db\n+        if (incomingAddressBook != null && incomingAddressBook.getFileId().getEntityNum() == fileID.getFileNum()) {\n+            return incomingAddressBook;\n         }\n \n-        Path path = mirrorProperties.getAddressBookPath();\n-        Path tempPath = path.resolveSibling(path.getFileName() + \".tmp\");\n-        Files.write(tempPath, contents, StandardOpenOption.CREATE, StandardOpenOption.WRITE, openOption);\n-        log.info(\"Saved {}B partial address book update to {}\", contents.length, tempPath);\n+        Optional<AddressBook> optionalAddressBook = addressBookRepository\n+                .findTopByFileIdOrderByConsensusTimestampDesc(EntityId.of(fileID));\n+\n+        return optionalAddressBook.isPresent() ? optionalAddressBook.get() : null;\n+    }\n+\n+    private void retrieveAddressBook(byte[] addressBookBytes, long consensusTimestamp, FileID fileID) {\n+        AddressBook.AddressBookBuilder builder = AddressBook.builder()\n+                .fileData(addressBookBytes)\n+                .consensusTimestamp(consensusTimestamp)\n+                .fileId(EntityId.of(fileID));\n \n         try {\n-            Collection<NodeAddress> nodeAddresses = parse(tempPath);\n-            if (!nodeAddresses.isEmpty()) {\n-                Files.move(tempPath, path, StandardCopyOption.REPLACE_EXISTING);\n-                this.nodeAddresses = nodeAddresses;\n-                log.info(\"New address book with {} addresses successfully parsed and saved to {}\",\n-                        nodeAddresses.size(), path);\n+            NodeAddressBook nodeAddressBook = NodeAddressBook.parseFrom(addressBookBytes);\n+            if (nodeAddressBook != null) {\n+                builder\n+                        .isComplete(true)\n+                        .nodeCount(nodeAddressBook.getNodeAddressCount())\n+                        .startConsensusTimestamp(consensusTimestamp);\n+\n+                Collection<NodeAddress> nodeAddresses = retrieveNodeAddressesFromAddressBook(nodeAddressBook);\n+                if (nodeAddressBook.getNodeAddressCount() > 0) {\n+                    incomingNodeAddresses = nodeAddresses;\n+                }\n             }\n         } catch (Exception e) {\n             log.warn(\"Unable to parse address book: {}\", e.getMessage());\n+            incomingNodeAddresses = Collections.emptyList();\n         }\n+\n+        incomingAddressBook = builder.build();\n     }\n \n-    private Collection<NodeAddress> parse(Path path) throws Exception {\n-        byte[] addressBookBytes = Files.readAllBytes(path);\n-        NodeAddressBook nodeAddressBook = NodeAddressBook.parseFrom(addressBookBytes);\n+    private Collection<NodeAddress> retrieveNodeAddressesFromAddressBook(NodeAddressBook nodeAddressBook) {\n         ImmutableList.Builder<NodeAddress> builder = ImmutableList.builder();\n \n-        for (com.hederahashgraph.api.proto.java.NodeAddress nodeAddressProto : nodeAddressBook\n-                .getNodeAddressList()) {\n-            NodeAddress nodeAddress = NodeAddress.builder()\n-                    .id(nodeAddressProto.getMemo().toStringUtf8())\n-                    .ip(nodeAddressProto.getIpAddress().toStringUtf8())\n-                    .port(nodeAddressProto.getPortno())\n-                    .publicKey(nodeAddressProto.getRSAPubKey())\n-                    .build();\n-            builder.add(nodeAddress);\n+        if (nodeAddressBook != null) {\n+            for (com.hederahashgraph.api.proto.java.NodeAddress nodeAddressProto : nodeAddressBook\n+                    .getNodeAddressList()) {\n+                NodeAddress nodeAddress = NodeAddress.builder()\n+                        .memo(nodeAddressProto.getMemo().toStringUtf8())\n+                        .ip(nodeAddressProto.getIpAddress().toStringUtf8())\n+                        .port(nodeAddressProto.getPortno())\n+                        .publicKey(nodeAddressProto.getRSAPubKey())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1159393216a6b7fdc3b26617b1afd2c36c70047e"}, "originalPosition": 302}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc0Mjk2NA==", "bodyText": "I think we can greatly simplify this class if we always pull the bytes from the file data table. We wouldn't need to have partial address books in the database or an is_complete flag and can just keep the bytes in file data until we get that last filecreate/fileupdate/fileappend that parses. It also makes it easier for readers of the address book to understand that they are only present if valid. Also allows us to be insert only and make fields as non-null like end timestamp.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459742964", "createdAt": "2020-07-23T21:38:58Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/NetworkAddressBook.java", "diffHunk": "@@ -21,152 +21,309 @@\n  */\n \n import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.FileID;\n import com.hederahashgraph.api.proto.java.NodeAddressBook;\n-import com.hederahashgraph.api.proto.java.TransactionBody;\n import java.io.File;\n-import java.io.IOException;\n import java.nio.file.Files;\n-import java.nio.file.OpenOption;\n import java.nio.file.Path;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Optional;\n import javax.inject.Named;\n import lombok.extern.log4j.Log4j2;\n import org.apache.commons.io.IOUtils;\n import org.springframework.core.io.ClassPathResource;\n import org.springframework.core.io.Resource;\n \n import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n import com.hedera.mirror.importer.domain.EntityId;\n import com.hedera.mirror.importer.domain.EntityTypeEnum;\n import com.hedera.mirror.importer.domain.NodeAddress;\n-import com.hedera.mirror.importer.exception.ParserException;\n-import com.hedera.mirror.importer.util.Utility;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.NodeAddressRepository;\n \n @Log4j2\n @Named\n public class NetworkAddressBook {\n-\n     private final MirrorProperties mirrorProperties;\n-    private volatile Collection<NodeAddress> nodeAddresses;\n+    private final AddressBookRepository addressBookRepository;\n+    private final NodeAddressRepository nodeAddressRepository;\n+\n+    private volatile Collection<NodeAddress> currentNodeAddresses;\n+    private volatile Collection<NodeAddress> incomingNodeAddresses;\n+    private volatile AddressBook currentAddressBook;\n+    private volatile AddressBook incomingAddressBook;\n+    private final Path addressBookPath;\n \n-    public NetworkAddressBook(MirrorProperties mirrorProperties) {\n+    public NetworkAddressBook(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                              NodeAddressRepository nodeAddressRepository) {\n         this.mirrorProperties = mirrorProperties;\n-        nodeAddresses = Collections.emptyList();\n+        this.addressBookRepository = addressBookRepository;\n+        this.nodeAddressRepository = nodeAddressRepository;\n+        currentNodeAddresses = Collections.emptyList();\n+        incomingNodeAddresses = Collections.emptyList();\n+        currentAddressBook = null;\n+        incomingAddressBook = null;\n+        addressBookPath = mirrorProperties.getAddressBookPath();\n         init();\n     }\n \n-    public static boolean isAddressBook(EntityId entityId) {\n-        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId()\n-                && entityId.getEntityNum() == 102 && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n+    public boolean isAddressBook(EntityId entityId) {\n+        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId() &&\n+                (entityId.getEntityNum() == 101 || entityId.getEntityNum() == mirrorProperties\n+                        .getAddressBookFileIdEntityNum())\n+                && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n     }\n \n-    public void updateFrom(TransactionBody transactionBody) {\n+    public void updateFrom(long consensusTimeStamp, byte[] contents, FileID fileID, boolean isAppendOperation) {\n+        if (contents == null || contents.length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n         try {\n-            if (transactionBody.hasFileAppend()) {\n-                append(transactionBody.getFileAppend().getContents().toByteArray());\n-            } else if (transactionBody.hasFileUpdate()) {\n-                update(transactionBody.getFileUpdate().getContents().toByteArray());\n-            }\n-        } catch (IOException e) {\n-            throw new ParserException(\"Error appending to network address book\", e);\n+            parse(contents, consensusTimeStamp, fileID, isAppendOperation);\n+        } catch (Exception e) {\n+            log.warn(\"Unable to parse address book: {}\", e.getMessage());\n         }\n+\n+        persistAddressBookToDB(consensusTimeStamp);\n     }\n \n     public Collection<NodeAddress> getAddresses() {\n-        return nodeAddresses;\n+        return currentNodeAddresses;\n+    }\n+\n+    public AddressBook getCurrentAddressBook() {\n+        return currentAddressBook;\n+    }\n+\n+    public AddressBook getPartialAddressBook() {\n+        return incomingAddressBook;\n+    }\n+\n+    private boolean isSupportedAddressBookEntityNum(long entityNum) {\n+        return mirrorProperties.getAddressBookFileIdEntityNum() == entityNum;\n     }\n \n     private void init() {\n-        Path path = mirrorProperties.getAddressBookPath();\n-        try {\n-            File addressBookFile = path.toFile();\n+        // load most recent addressBook\n+        loadAddressBookFromDB();\n \n-            if (!addressBookFile.canRead()) {\n-                if (addressBookFile.exists()) {\n-                    log.warn(\"Backing up unreadable address book: {}\", path);\n-                    Files.move(path, path.resolveSibling(path + \".unreadable\"));\n-                }\n+        if (currentAddressBook == null) {\n+            // no addressBook present in db, load from fileSystem\n+            byte[] addressBookBytes = null;\n+            try {\n+                File addressBookFile = addressBookPath.toFile();\n \n-                byte[] addressBookBytes = null;\n-                Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+                if (!addressBookFile.canRead()) {\n+                    if (addressBookFile.exists()) {\n+                        log.warn(\"Backing up unreadable address book: {}\", addressBookPath);\n+                        Files.move(addressBookPath, addressBookPath.resolveSibling(addressBookPath + \".unreadable\"));\n+                    }\n \n-                if (initialAddressBook != null) {\n-                    addressBookBytes = Files.readAllBytes(initialAddressBook);\n-                    log.info(\"Loading bootstrap address book from {}\", initialAddressBook);\n+                    Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+\n+                    if (initialAddressBook != null) {\n+                        addressBookBytes = Files.readAllBytes(initialAddressBook);\n+                        log.info(\"Loading bootstrap address book from {}\", initialAddressBook);\n+                    } else {\n+                        MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n+                        String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n+                        Resource resource = new ClassPathResource(resourcePath, getClass());\n+                        addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n+                        log.info(\"Loading bootstrap address book from {}\", resource);\n+                    }\n                 } else {\n-                    MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n-                    String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n-                    Resource resource = new ClassPathResource(resourcePath, getClass());\n-                    addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n-                    log.info(\"Loading bootstrap address book from {}\", resource);\n+                    log.info(\"Restoring existing address book {}\", addressBookPath);\n+                    addressBookBytes = Files.readAllBytes(addressBookPath);\n                 }\n+            } catch (Exception e) {\n+                throw new IllegalStateException(String\n+                        .format(\"Unable to load valid address book from %s\", addressBookPath));\n+            }\n \n-                Utility.ensureDirectory(path.getParent());\n-                update(addressBookBytes);\n-            } else {\n-                log.info(\"Restoring existing address book {}\", path);\n-                update(Files.readAllBytes(path));\n+            try {\n+                parse(addressBookBytes, 0L, FileID.newBuilder()\n+                        .setShardNum(mirrorProperties.getShard()).setRealmNum(0)\n+                        .setFileNum(mirrorProperties.getAddressBookFileIdEntityNum()).build(), false);\n+                persistAddressBookToDB(0);\n+            } catch (Exception e) {\n+                throw new IllegalStateException(\"Unable to parse address book: \", e);\n             }\n-        } catch (Exception e) {\n-            log.error(\"Unable to copy address book from {} to {}\", mirrorProperties.getNetwork(), path, e);\n+        } else {\n+            // addressBook loaded from db\n+            log.info(\"Loaded addressBook details from DB. Valid from {}, {} nodes, fileSize {} B\",\n+                    currentAddressBook.getStartConsensusTimestamp(), currentAddressBook.getNodeCount(),\n+                    currentAddressBook.getFileData().length);\n         }\n \n         if (getAddresses().isEmpty()) {\n-            throw new IllegalStateException(\"Unable to load a valid address book\");\n+            throw new IllegalStateException(\"Unable to load a valid address book with node addresses\");\n         }\n     }\n \n-    public void update(byte[] newContents) throws IOException {\n-        saveToDisk(newContents, StandardOpenOption.TRUNCATE_EXISTING);\n-    }\n+    private void parse(byte[] contents, Long consensusTimestamp, FileID fileID, boolean append) throws Exception {\n+        byte[] addressBookBytes = null;\n+        if (append) {\n+            // concatenate bytes for impartial address books\n+            AddressBook addressBook = getPreviousAddressBookToAppendTo(fileID);\n \n-    private void append(byte[] extraContents) throws IOException {\n-        saveToDisk(extraContents, StandardOpenOption.APPEND);\n+            if (addressBook != null) {\n+                byte[] incompleteBytes = addressBook.getFileData();\n+                byte[] combinedBytes = new byte[incompleteBytes.length + contents.length];\n+                System.arraycopy(incompleteBytes, 0, combinedBytes, 0, incompleteBytes.length);\n+                System.arraycopy(contents, 0, combinedBytes, incompleteBytes.length, contents.length);\n+                addressBookBytes = combinedBytes;\n+                log.info(\"Combined incomplete addressBook from {} of size {} B with bytes from {} of {} B. Combined \" +\n+                                \"length is {}\", addressBook.getConsensusTimestamp(), incompleteBytes.length,\n+                        consensusTimestamp, contents.length, combinedBytes.length);\n+            } else {\n+                log.error(\"Previous incomplete address book entry expected but not found\");\n+            }\n+        } else {\n+            addressBookBytes = contents;\n+        }\n+\n+        retrieveAddressBook(addressBookBytes, consensusTimestamp, fileID);\n     }\n \n-    private void saveToDisk(byte[] contents, OpenOption openOption) throws IOException {\n-        if (contents == null || contents.length == 0) {\n-            log.warn(\"Ignored empty byte array\");\n-            return;\n+    private AddressBook getPreviousAddressBookToAppendTo(FileID fileID) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1159393216a6b7fdc3b26617b1afd2c36c70047e"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc0MzgzMw==", "bodyText": "This method goes away if you nest List<AddressBookEntry> entries in AddressBook as suggested. Then you can cascade the persist in one call to addressBookRepository.save(incomingAddressBook).", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459743833", "createdAt": "2020-07-23T21:40:48Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/NetworkAddressBook.java", "diffHunk": "@@ -21,152 +21,309 @@\n  */\n \n import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.FileID;\n import com.hederahashgraph.api.proto.java.NodeAddressBook;\n-import com.hederahashgraph.api.proto.java.TransactionBody;\n import java.io.File;\n-import java.io.IOException;\n import java.nio.file.Files;\n-import java.nio.file.OpenOption;\n import java.nio.file.Path;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Optional;\n import javax.inject.Named;\n import lombok.extern.log4j.Log4j2;\n import org.apache.commons.io.IOUtils;\n import org.springframework.core.io.ClassPathResource;\n import org.springframework.core.io.Resource;\n \n import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n import com.hedera.mirror.importer.domain.EntityId;\n import com.hedera.mirror.importer.domain.EntityTypeEnum;\n import com.hedera.mirror.importer.domain.NodeAddress;\n-import com.hedera.mirror.importer.exception.ParserException;\n-import com.hedera.mirror.importer.util.Utility;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.NodeAddressRepository;\n \n @Log4j2\n @Named\n public class NetworkAddressBook {\n-\n     private final MirrorProperties mirrorProperties;\n-    private volatile Collection<NodeAddress> nodeAddresses;\n+    private final AddressBookRepository addressBookRepository;\n+    private final NodeAddressRepository nodeAddressRepository;\n+\n+    private volatile Collection<NodeAddress> currentNodeAddresses;\n+    private volatile Collection<NodeAddress> incomingNodeAddresses;\n+    private volatile AddressBook currentAddressBook;\n+    private volatile AddressBook incomingAddressBook;\n+    private final Path addressBookPath;\n \n-    public NetworkAddressBook(MirrorProperties mirrorProperties) {\n+    public NetworkAddressBook(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                              NodeAddressRepository nodeAddressRepository) {\n         this.mirrorProperties = mirrorProperties;\n-        nodeAddresses = Collections.emptyList();\n+        this.addressBookRepository = addressBookRepository;\n+        this.nodeAddressRepository = nodeAddressRepository;\n+        currentNodeAddresses = Collections.emptyList();\n+        incomingNodeAddresses = Collections.emptyList();\n+        currentAddressBook = null;\n+        incomingAddressBook = null;\n+        addressBookPath = mirrorProperties.getAddressBookPath();\n         init();\n     }\n \n-    public static boolean isAddressBook(EntityId entityId) {\n-        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId()\n-                && entityId.getEntityNum() == 102 && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n+    public boolean isAddressBook(EntityId entityId) {\n+        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId() &&\n+                (entityId.getEntityNum() == 101 || entityId.getEntityNum() == mirrorProperties\n+                        .getAddressBookFileIdEntityNum())\n+                && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n     }\n \n-    public void updateFrom(TransactionBody transactionBody) {\n+    public void updateFrom(long consensusTimeStamp, byte[] contents, FileID fileID, boolean isAppendOperation) {\n+        if (contents == null || contents.length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n         try {\n-            if (transactionBody.hasFileAppend()) {\n-                append(transactionBody.getFileAppend().getContents().toByteArray());\n-            } else if (transactionBody.hasFileUpdate()) {\n-                update(transactionBody.getFileUpdate().getContents().toByteArray());\n-            }\n-        } catch (IOException e) {\n-            throw new ParserException(\"Error appending to network address book\", e);\n+            parse(contents, consensusTimeStamp, fileID, isAppendOperation);\n+        } catch (Exception e) {\n+            log.warn(\"Unable to parse address book: {}\", e.getMessage());\n         }\n+\n+        persistAddressBookToDB(consensusTimeStamp);\n     }\n \n     public Collection<NodeAddress> getAddresses() {\n-        return nodeAddresses;\n+        return currentNodeAddresses;\n+    }\n+\n+    public AddressBook getCurrentAddressBook() {\n+        return currentAddressBook;\n+    }\n+\n+    public AddressBook getPartialAddressBook() {\n+        return incomingAddressBook;\n+    }\n+\n+    private boolean isSupportedAddressBookEntityNum(long entityNum) {\n+        return mirrorProperties.getAddressBookFileIdEntityNum() == entityNum;\n     }\n \n     private void init() {\n-        Path path = mirrorProperties.getAddressBookPath();\n-        try {\n-            File addressBookFile = path.toFile();\n+        // load most recent addressBook\n+        loadAddressBookFromDB();\n \n-            if (!addressBookFile.canRead()) {\n-                if (addressBookFile.exists()) {\n-                    log.warn(\"Backing up unreadable address book: {}\", path);\n-                    Files.move(path, path.resolveSibling(path + \".unreadable\"));\n-                }\n+        if (currentAddressBook == null) {\n+            // no addressBook present in db, load from fileSystem\n+            byte[] addressBookBytes = null;\n+            try {\n+                File addressBookFile = addressBookPath.toFile();\n \n-                byte[] addressBookBytes = null;\n-                Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+                if (!addressBookFile.canRead()) {\n+                    if (addressBookFile.exists()) {\n+                        log.warn(\"Backing up unreadable address book: {}\", addressBookPath);\n+                        Files.move(addressBookPath, addressBookPath.resolveSibling(addressBookPath + \".unreadable\"));\n+                    }\n \n-                if (initialAddressBook != null) {\n-                    addressBookBytes = Files.readAllBytes(initialAddressBook);\n-                    log.info(\"Loading bootstrap address book from {}\", initialAddressBook);\n+                    Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+\n+                    if (initialAddressBook != null) {\n+                        addressBookBytes = Files.readAllBytes(initialAddressBook);\n+                        log.info(\"Loading bootstrap address book from {}\", initialAddressBook);\n+                    } else {\n+                        MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n+                        String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n+                        Resource resource = new ClassPathResource(resourcePath, getClass());\n+                        addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n+                        log.info(\"Loading bootstrap address book from {}\", resource);\n+                    }\n                 } else {\n-                    MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n-                    String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n-                    Resource resource = new ClassPathResource(resourcePath, getClass());\n-                    addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n-                    log.info(\"Loading bootstrap address book from {}\", resource);\n+                    log.info(\"Restoring existing address book {}\", addressBookPath);\n+                    addressBookBytes = Files.readAllBytes(addressBookPath);\n                 }\n+            } catch (Exception e) {\n+                throw new IllegalStateException(String\n+                        .format(\"Unable to load valid address book from %s\", addressBookPath));\n+            }\n \n-                Utility.ensureDirectory(path.getParent());\n-                update(addressBookBytes);\n-            } else {\n-                log.info(\"Restoring existing address book {}\", path);\n-                update(Files.readAllBytes(path));\n+            try {\n+                parse(addressBookBytes, 0L, FileID.newBuilder()\n+                        .setShardNum(mirrorProperties.getShard()).setRealmNum(0)\n+                        .setFileNum(mirrorProperties.getAddressBookFileIdEntityNum()).build(), false);\n+                persistAddressBookToDB(0);\n+            } catch (Exception e) {\n+                throw new IllegalStateException(\"Unable to parse address book: \", e);\n             }\n-        } catch (Exception e) {\n-            log.error(\"Unable to copy address book from {} to {}\", mirrorProperties.getNetwork(), path, e);\n+        } else {\n+            // addressBook loaded from db\n+            log.info(\"Loaded addressBook details from DB. Valid from {}, {} nodes, fileSize {} B\",\n+                    currentAddressBook.getStartConsensusTimestamp(), currentAddressBook.getNodeCount(),\n+                    currentAddressBook.getFileData().length);\n         }\n \n         if (getAddresses().isEmpty()) {\n-            throw new IllegalStateException(\"Unable to load a valid address book\");\n+            throw new IllegalStateException(\"Unable to load a valid address book with node addresses\");\n         }\n     }\n \n-    public void update(byte[] newContents) throws IOException {\n-        saveToDisk(newContents, StandardOpenOption.TRUNCATE_EXISTING);\n-    }\n+    private void parse(byte[] contents, Long consensusTimestamp, FileID fileID, boolean append) throws Exception {\n+        byte[] addressBookBytes = null;\n+        if (append) {\n+            // concatenate bytes for impartial address books\n+            AddressBook addressBook = getPreviousAddressBookToAppendTo(fileID);\n \n-    private void append(byte[] extraContents) throws IOException {\n-        saveToDisk(extraContents, StandardOpenOption.APPEND);\n+            if (addressBook != null) {\n+                byte[] incompleteBytes = addressBook.getFileData();\n+                byte[] combinedBytes = new byte[incompleteBytes.length + contents.length];\n+                System.arraycopy(incompleteBytes, 0, combinedBytes, 0, incompleteBytes.length);\n+                System.arraycopy(contents, 0, combinedBytes, incompleteBytes.length, contents.length);\n+                addressBookBytes = combinedBytes;\n+                log.info(\"Combined incomplete addressBook from {} of size {} B with bytes from {} of {} B. Combined \" +\n+                                \"length is {}\", addressBook.getConsensusTimestamp(), incompleteBytes.length,\n+                        consensusTimestamp, contents.length, combinedBytes.length);\n+            } else {\n+                log.error(\"Previous incomplete address book entry expected but not found\");\n+            }\n+        } else {\n+            addressBookBytes = contents;\n+        }\n+\n+        retrieveAddressBook(addressBookBytes, consensusTimestamp, fileID);\n     }\n \n-    private void saveToDisk(byte[] contents, OpenOption openOption) throws IOException {\n-        if (contents == null || contents.length == 0) {\n-            log.warn(\"Ignored empty byte array\");\n-            return;\n+    private AddressBook getPreviousAddressBookToAppendTo(FileID fileID) {\n+        // if incomingAddressBook is a match use it if not retrieve last address book for given file from Db\n+        if (incomingAddressBook != null && incomingAddressBook.getFileId().getEntityNum() == fileID.getFileNum()) {\n+            return incomingAddressBook;\n         }\n \n-        Path path = mirrorProperties.getAddressBookPath();\n-        Path tempPath = path.resolveSibling(path.getFileName() + \".tmp\");\n-        Files.write(tempPath, contents, StandardOpenOption.CREATE, StandardOpenOption.WRITE, openOption);\n-        log.info(\"Saved {}B partial address book update to {}\", contents.length, tempPath);\n+        Optional<AddressBook> optionalAddressBook = addressBookRepository\n+                .findTopByFileIdOrderByConsensusTimestampDesc(EntityId.of(fileID));\n+\n+        return optionalAddressBook.isPresent() ? optionalAddressBook.get() : null;\n+    }\n+\n+    private void retrieveAddressBook(byte[] addressBookBytes, long consensusTimestamp, FileID fileID) {\n+        AddressBook.AddressBookBuilder builder = AddressBook.builder()\n+                .fileData(addressBookBytes)\n+                .consensusTimestamp(consensusTimestamp)\n+                .fileId(EntityId.of(fileID));\n \n         try {\n-            Collection<NodeAddress> nodeAddresses = parse(tempPath);\n-            if (!nodeAddresses.isEmpty()) {\n-                Files.move(tempPath, path, StandardCopyOption.REPLACE_EXISTING);\n-                this.nodeAddresses = nodeAddresses;\n-                log.info(\"New address book with {} addresses successfully parsed and saved to {}\",\n-                        nodeAddresses.size(), path);\n+            NodeAddressBook nodeAddressBook = NodeAddressBook.parseFrom(addressBookBytes);\n+            if (nodeAddressBook != null) {\n+                builder\n+                        .isComplete(true)\n+                        .nodeCount(nodeAddressBook.getNodeAddressCount())\n+                        .startConsensusTimestamp(consensusTimestamp);\n+\n+                Collection<NodeAddress> nodeAddresses = retrieveNodeAddressesFromAddressBook(nodeAddressBook);\n+                if (nodeAddressBook.getNodeAddressCount() > 0) {\n+                    incomingNodeAddresses = nodeAddresses;\n+                }\n             }\n         } catch (Exception e) {\n             log.warn(\"Unable to parse address book: {}\", e.getMessage());\n+            incomingNodeAddresses = Collections.emptyList();\n         }\n+\n+        incomingAddressBook = builder.build();\n     }\n \n-    private Collection<NodeAddress> parse(Path path) throws Exception {\n-        byte[] addressBookBytes = Files.readAllBytes(path);\n-        NodeAddressBook nodeAddressBook = NodeAddressBook.parseFrom(addressBookBytes);\n+    private Collection<NodeAddress> retrieveNodeAddressesFromAddressBook(NodeAddressBook nodeAddressBook) {\n         ImmutableList.Builder<NodeAddress> builder = ImmutableList.builder();\n \n-        for (com.hederahashgraph.api.proto.java.NodeAddress nodeAddressProto : nodeAddressBook\n-                .getNodeAddressList()) {\n-            NodeAddress nodeAddress = NodeAddress.builder()\n-                    .id(nodeAddressProto.getMemo().toStringUtf8())\n-                    .ip(nodeAddressProto.getIpAddress().toStringUtf8())\n-                    .port(nodeAddressProto.getPortno())\n-                    .publicKey(nodeAddressProto.getRSAPubKey())\n-                    .build();\n-            builder.add(nodeAddress);\n+        if (nodeAddressBook != null) {\n+            for (com.hederahashgraph.api.proto.java.NodeAddress nodeAddressProto : nodeAddressBook\n+                    .getNodeAddressList()) {\n+                NodeAddress nodeAddress = NodeAddress.builder()\n+                        .memo(nodeAddressProto.getMemo().toStringUtf8())\n+                        .ip(nodeAddressProto.getIpAddress().toStringUtf8())\n+                        .port(nodeAddressProto.getPortno())\n+                        .publicKey(nodeAddressProto.getRSAPubKey())\n+                        .build();\n+                builder.add(nodeAddress);\n+            }\n         }\n \n         return builder.build();\n     }\n+\n+    private void persistAddressBookToDB(long consensusTimestamp) {\n+        // store complete address book\n+        saveAddressBook(consensusTimestamp);\n+\n+        // store node addresses\n+        saveNodeAddresses(consensusTimestamp);\n+    }\n+\n+    private void saveAddressBook(long consensusTimestamp) {\n+        if (incomingAddressBook != null) {\n+\n+            // if address book is complete update end time of previous address book and start time of this\n+            if (incomingAddressBook.isComplete()) {\n+                // retrieve last complete address book for fileID and update endConsensusTimestamp\n+                Optional<AddressBook> addressBook = addressBookRepository\n+                        .findTopByFileIdAndIsCompleteIsTrueOrderByConsensusTimestampDesc(incomingAddressBook\n+                                .getFileId());\n+                if (addressBook.isPresent()) {\n+                    addressBookRepository\n+                            .updateEndConsensusTimestamp(addressBook.get()\n+                                    .getConsensusTimestamp(), consensusTimestamp - 1);\n+                }\n+            }\n+\n+            // store address book.\n+            // Potential to also remove incomplete address books entries in the db table\n+            addressBookRepository.save(incomingAddressBook);\n+            log.info(\"Saved new address book to db: {}\", incomingAddressBook);\n+        }\n+    }\n+\n+    private void saveNodeAddresses(long consensusTimestamp) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1159393216a6b7fdc3b26617b1afd2c36c70047e"}, "originalPosition": 342}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc0NjAzOQ==", "bodyText": "Not sure it makes sense to have consensus_timestamp in this table as this data comes from a blob that potentially spans transactions. It makes more sense to have a foreign key back to address_book table instead.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459746039", "createdAt": "2020-07-23T21:45:40Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/resources/db/migration/V1.28.0__address_book.sql", "diffHunk": "@@ -0,0 +1,42 @@\n+-------------------\n+-- Support db storage of netowrk address books\n+-------------------\n+\n+-- add address book table\n+create table if not exists address_book\n+(\n+    consensus_timestamp         nanos_timestamp primary key,\n+    start_consensus_timestamp   nanos_timestamp null,\n+    end_consensus_timestamp     nanos_timestamp null,\n+    file_id                     entity_id       not null,\n+    node_count                  smallint        null,\n+    file_data                   bytea           not null,\n+    is_complete                 boolean         not null default false\n+);\n+\n+create index if not exists address_book__fileId_isComplete\n+    on address_book (file_id, is_complete);\n+\n+-- add node address table\n+create table if not exists node_address\n+(\n+    id                      serial          primary key,\n+    consensus_timestamp     nanos_timestamp not null,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1159393216a6b7fdc3b26617b1afd2c36c70047e"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc0Njg5MQ==", "bodyText": "Most of these methods go away with my other suggestions.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r459746891", "createdAt": "2020-07-23T21:47:39Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/repository/AddressBookRepository.java", "diffHunk": "@@ -0,0 +1,50 @@\n+package com.hedera.mirror.importer.repository;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import java.util.List;\n+import java.util.Optional;\n+import javax.transaction.Transactional;\n+import org.springframework.data.jpa.repository.Modifying;\n+import org.springframework.data.jpa.repository.Query;\n+import org.springframework.data.repository.CrudRepository;\n+import org.springframework.data.repository.query.Param;\n+\n+import com.hedera.mirror.importer.domain.AddressBook;\n+import com.hedera.mirror.importer.domain.EntityId;\n+\n+@Transactional\n+public interface AddressBookRepository extends CrudRepository<AddressBook, Long> {\n+    @Query(\"from AddressBook where consensusTimestamp <= ?1 and fileId = ?2 and isComplete = true order by \" +\n+            \"consensusTimestamp asc\")\n+    List<AddressBook> findCompleteAddressBooks(long consensusTimestamp, EntityId fileId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1159393216a6b7fdc3b26617b1afd2c36c70047e"}, "originalPosition": 38}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64a2f5e761db876c55dd2e3e741317b159c01911", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/64a2f5e761db876c55dd2e3e741317b159c01911", "committedDate": "2020-07-27T04:58:14Z", "message": "Persist address book to db on first start and on updates\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f23813487e2f0c03cee840b32c19bca3e160057", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/4f23813487e2f0c03cee840b32c19bca3e160057", "committedDate": "2020-07-27T04:58:14Z", "message": "Remove file system storage logic\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "19eb8a64ca8b4a1abcfc4003f4d3f31cc8b3265d", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/19eb8a64ca8b4a1abcfc4003f4d3f31cc8b3265d", "committedDate": "2020-07-27T04:58:14Z", "message": "Fixed most tests and added more NetworkAddressBookTests\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2fee26688d80f738ffb10960f17680c5a64da85f", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/2fee26688d80f738ffb10960f17680c5a64da85f", "committedDate": "2020-07-27T04:58:14Z", "message": "Fixed tests and expanded some test cases and call logic\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68c5c1f63d1d9a1b52889150f4d121d6e61d02c6", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/68c5c1f63d1d9a1b52889150f4d121d6e61d02c6", "committedDate": "2020-07-27T04:58:14Z", "message": "Merged t_record file and pg-notify fixes from master in\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae5efcdec2726c1a05679c5e24c4eef6bdb1108d", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/ae5efcdec2726c1a05679c5e24c4eef6bdb1108d", "committedDate": "2020-07-27T04:58:14Z", "message": "Updated file_data table and Added java migration\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b95420fe5cf739063fc986287327b691268be22", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/7b95420fe5cf739063fc986287327b691268be22", "committedDate": "2020-07-27T05:07:51Z", "message": "Persist address book to db on first start and on updates\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e778804b35af1afcdedbef29748d09c135ed0c79", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/e778804b35af1afcdedbef29748d09c135ed0c79", "committedDate": "2020-07-27T05:12:33Z", "message": "Remove file system storage logic\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb80bcb944bb9a5977f71d970f9b8b38dc2414c7", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/cb80bcb944bb9a5977f71d970f9b8b38dc2414c7", "committedDate": "2020-07-27T05:14:22Z", "message": "Fixed most tests and added more NetworkAddressBookTests\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9b5a3c3c84cb5e9fb8f9a48079c72336039ae897", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/9b5a3c3c84cb5e9fb8f9a48079c72336039ae897", "committedDate": "2020-07-27T05:15:49Z", "message": "Fixed tests and expanded some test cases and call logic\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f41cae7f32809def692f75990496441a32cea8a", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/6f41cae7f32809def692f75990496441a32cea8a", "committedDate": "2020-07-27T05:17:35Z", "message": "Merged t_record file and pg-notify fixes from master in\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c120cb37f0f893ca9468c83a506daacf4f1ac56b", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/c120cb37f0f893ca9468c83a506daacf4f1ac56b", "committedDate": "2020-07-27T05:18:28Z", "message": "Passed in EntityId instead of FileID\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a87120fd35dccd660884ea5dbabbb4464ada000", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/5a87120fd35dccd660884ea5dbabbb4464ada000", "committedDate": "2020-07-27T05:22:19Z", "message": "Adopt file respository store\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4ebe7ae8813bf2e966f418ed7c5134f12845ac44", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/4ebe7ae8813bf2e966f418ed7c5134f12845ac44", "committedDate": "2020-07-27T04:54:15Z", "message": "Adopt file respository store\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}, "afterCommit": {"oid": "5a87120fd35dccd660884ea5dbabbb4464ada000", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/5a87120fd35dccd660884ea5dbabbb4464ada000", "committedDate": "2020-07-27T05:22:19Z", "message": "Adopt file respository store\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3eaa8e9983327eaa211907d6b1de7dcdb25925c7", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/3eaa8e9983327eaa211907d6b1de7dcdb25925c7", "committedDate": "2020-07-28T04:14:57Z", "message": "Fixed merge w PgCopy and fixed java migration\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "34e290be0d6764d0495925757dc6f37689b24b5e", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/34e290be0d6764d0495925757dc6f37689b24b5e", "committedDate": "2020-07-28T16:41:07Z", "message": "Addressed feedback\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ea6a08866f4e8adf7cb0bfff4403b9a00be7724", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/9ea6a08866f4e8adf7cb0bfff4403b9a00be7724", "committedDate": "2020-07-28T19:48:24Z", "message": "Fixed java migration circular dependency issue\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/9f91d29ee4143c257c181403c26fe0fa27a7d9b9", "committedDate": "2020-07-29T02:17:42Z", "message": "Fixed and added tests and customized repository method names\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3MDMxMjI1", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#pullrequestreview-457031225", "createdAt": "2020-07-28T21:32:02Z", "commit": {"oid": "9ea6a08866f4e8adf7cb0bfff4403b9a00be7724"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMTozMjowMlrOG4fqTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMzo1MDoyOFrOG5OI3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MjE3NQ==", "bodyText": "Having an index on a field with only two potential values (101 and 102) is not useful", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r461892175", "createdAt": "2020-07-28T21:32:02Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/resources/db/migration/V1.28.0__address_book.sql", "diffHunk": "@@ -0,0 +1,53 @@\n+-------------------\n+-- Support db storage of network address books\n+-------------------\n+\n+-- add address book table\n+create table if not exists address_book\n+(\n+    consensus_timestamp         nanos_timestamp primary key,\n+    start_consensus_timestamp   nanos_timestamp null,\n+    end_consensus_timestamp     nanos_timestamp null,\n+    file_id                     entity_id       not null,\n+    node_count                  smallint        null,\n+    file_data                   bytea           not null\n+);\n+\n+create index if not exists address_book__fileId", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ea6a08866f4e8adf7cb0bfff4403b9a00be7724"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MzEzNQ==", "bodyText": "I think int would be better for when we go permissionless and doesn't add too much storage for such a small table.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r461893135", "createdAt": "2020-07-28T21:34:06Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/resources/db/migration/V1.28.0__address_book.sql", "diffHunk": "@@ -0,0 +1,53 @@\n+-------------------\n+-- Support db storage of network address books\n+-------------------\n+\n+-- add address book table\n+create table if not exists address_book\n+(\n+    consensus_timestamp         nanos_timestamp primary key,\n+    start_consensus_timestamp   nanos_timestamp null,\n+    end_consensus_timestamp     nanos_timestamp null,\n+    file_id                     entity_id       not null,\n+    node_count                  smallint        null,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ea6a08866f4e8adf7cb0bfff4403b9a00be7724"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MzgyNQ==", "bodyText": "Are we sure 101 has a memo? Memo is deprecated and they might not populate it in the future. We should probably not force it to be not null", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r461893825", "createdAt": "2020-07-28T21:35:30Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/resources/db/migration/V1.28.0__address_book.sql", "diffHunk": "@@ -0,0 +1,53 @@\n+-------------------\n+-- Support db storage of network address books\n+-------------------\n+\n+-- add address book table\n+create table if not exists address_book\n+(\n+    consensus_timestamp         nanos_timestamp primary key,\n+    start_consensus_timestamp   nanos_timestamp null,\n+    end_consensus_timestamp     nanos_timestamp null,\n+    file_id                     entity_id       not null,\n+    node_count                  smallint        null,\n+    file_data                   bytea           not null\n+);\n+\n+create index if not exists address_book__fileId\n+    on address_book (consensus_timestamp, file_id);\n+\n+-- add node address table\n+create table if not exists address_book_entry\n+(\n+    id                      serial          primary key,\n+    consensus_timestamp     nanos_timestamp not null,\n+    ip                      varchar(128)    null,\n+    port                    integer         null,\n+    memo                    varchar(128)    not null,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ea6a08866f4e8adf7cb0bfff4403b9a00be7724"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5NTI2OQ==", "bodyText": "It would be cleaner to return EntityId and clients can convert to string only if needed.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r461895269", "createdAt": "2020-07-28T21:38:54Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/AddressBookEntry.java", "diffHunk": "@@ -52,4 +78,8 @@ public PublicKey getPublicKeyAsObject() {\n             throw new RuntimeException(e);\n         }\n     }\n+\n+    public String getNodeAccountId() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ea6a08866f4e8adf7cb0bfff4403b9a00be7724"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTkwODAwMw==", "bodyText": "nit: Would prefer addressBook.getEntries() instead of redundant within context addressBook.getAddressBookEntries().", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r461908003", "createdAt": "2020-07-28T21:55:28Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/AddressBook.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import java.util.List;\n+import javax.persistence.CascadeType;\n+import javax.persistence.Convert;\n+import javax.persistence.Entity;\n+import javax.persistence.FetchType;\n+import javax.persistence.Id;\n+import javax.persistence.JoinColumn;\n+import javax.persistence.OneToMany;\n+import lombok.AllArgsConstructor;\n+import lombok.Builder;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.ToString;\n+import org.springframework.data.domain.Persistable;\n+\n+import com.hedera.mirror.importer.converter.FileIdConverter;\n+\n+@Builder(toBuilder = true)\n+@Data\n+@Entity\n+@NoArgsConstructor\n+@AllArgsConstructor\n+@ToString(exclude = {\"fileData\"})\n+public class AddressBook implements Persistable<Long> {\n+    @Id\n+    private Long consensusTimestamp; // transaction consensusTimestamp\n+\n+    private Long startConsensusTimestamp; // first transaction parsed with this address book\n+\n+    private Long endConsensusTimestamp; // consensusTimestamp 1 ns prior to next address book startConsensusTimestamp\n+\n+    @Convert(converter = FileIdConverter.class)\n+    private EntityId fileId;\n+\n+    private Integer nodeCount;\n+\n+    private byte[] fileData;\n+\n+    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumn(name = \"consensusTimestamp\")\n+    private List<AddressBookEntry> addressBookEntries;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ea6a08866f4e8adf7cb0bfff4403b9a00be7724"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ0NjQyOA==", "bodyText": "AddressBook is the aggregate and we should return that for our API. Also we should indicate this is the current in method. Recommend AddressBook getCurrent() so that it's clear when invoking addressBookService.getCurrent().", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462446428", "createdAt": "2020-07-29T16:55:50Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookService.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package com.hedera.mirror.importer.addressbook;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import java.util.Collection;\n+\n+import com.hedera.mirror.importer.domain.AddressBookEntry;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.FileData;\n+\n+public interface AddressBookService {\n+\n+    boolean isAddressBook(EntityId entityId);\n+\n+    void update(FileData fileData);\n+\n+    Collection<AddressBookEntry> getAddresses();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ0ODEzNQ==", "bodyText": "Should still probably check isAddressBook here even if it's also done elsewhere to ensure correctness for future users of this method.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462448135", "createdAt": "2020-07-29T16:58:39Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -0,0 +1,271 @@\n+package com.hedera.mirror.importer.addressbook;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.NodeAddressBook;\n+import java.io.ByteArrayOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Instant;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.io.IOUtils;\n+import org.springframework.core.io.ClassPathResource;\n+import org.springframework.core.io.Resource;\n+import org.springframework.util.CollectionUtils;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n+import com.hedera.mirror.importer.domain.AddressBookEntry;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.FileData;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.FileDataRepository;\n+\n+@Log4j2\n+@Named\n+public class AddressBookServiceImpl implements AddressBookService {\n+    public static final EntityId ADDRESS_BOOK_101_ENTITY_ID = EntityId.of(0, 0, 101, EntityTypeEnum.FILE);\n+    public static final EntityId ADDRESS_BOOK_102_ENTITY_ID = EntityId.of(0, 0, 102, EntityTypeEnum.FILE);\n+\n+    private final MirrorProperties mirrorProperties;\n+    private final AddressBookRepository addressBookRepository;\n+    private final FileDataRepository fileDataRepository;\n+    private Collection<AddressBookEntry> addressBookEntries;\n+\n+    public AddressBookServiceImpl(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                                  FileDataRepository fileDataRepository) {\n+        this.mirrorProperties = mirrorProperties;\n+        this.addressBookRepository = addressBookRepository;\n+        this.fileDataRepository = fileDataRepository;\n+        addressBookEntries = Collections.emptyList();\n+        init();\n+    }\n+\n+    @Override\n+    public void update(FileData fileData) {\n+        if (fileData.getFileData() == null || fileData.getFileData().length == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ0ODM3Mw==", "bodyText": "I think we can print the full stacktrace since we already catch and log the common scenario of partial address book elsewhere.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462448373", "createdAt": "2020-07-29T16:59:01Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -0,0 +1,271 @@\n+package com.hedera.mirror.importer.addressbook;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.NodeAddressBook;\n+import java.io.ByteArrayOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Instant;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.io.IOUtils;\n+import org.springframework.core.io.ClassPathResource;\n+import org.springframework.core.io.Resource;\n+import org.springframework.util.CollectionUtils;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n+import com.hedera.mirror.importer.domain.AddressBookEntry;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.FileData;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.FileDataRepository;\n+\n+@Log4j2\n+@Named\n+public class AddressBookServiceImpl implements AddressBookService {\n+    public static final EntityId ADDRESS_BOOK_101_ENTITY_ID = EntityId.of(0, 0, 101, EntityTypeEnum.FILE);\n+    public static final EntityId ADDRESS_BOOK_102_ENTITY_ID = EntityId.of(0, 0, 102, EntityTypeEnum.FILE);\n+\n+    private final MirrorProperties mirrorProperties;\n+    private final AddressBookRepository addressBookRepository;\n+    private final FileDataRepository fileDataRepository;\n+    private Collection<AddressBookEntry> addressBookEntries;\n+\n+    public AddressBookServiceImpl(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                                  FileDataRepository fileDataRepository) {\n+        this.mirrorProperties = mirrorProperties;\n+        this.addressBookRepository = addressBookRepository;\n+        this.fileDataRepository = fileDataRepository;\n+        addressBookEntries = Collections.emptyList();\n+        init();\n+    }\n+\n+    @Override\n+    public void update(FileData fileData) {\n+        if (fileData.getFileData() == null || fileData.getFileData().length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n+        try {\n+            parse(fileData);\n+        } catch (Exception e) {\n+            log.warn(\"Unable to parse address book: {}\", e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2MTAxNw==", "bodyText": "Again, we should not store data in memory even for caching purposes. The more places you have data the more likely they are to be out of sync. We should rely on frameworks to provide caching like @Cacheable on a repository method or the service method if it makes sense there.\nCase in point, this addressBookEntries is currently not changed on calls to update() and only populated on startup.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462461017", "createdAt": "2020-07-29T17:19:42Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -0,0 +1,271 @@\n+package com.hedera.mirror.importer.addressbook;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.NodeAddressBook;\n+import java.io.ByteArrayOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Instant;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.io.IOUtils;\n+import org.springframework.core.io.ClassPathResource;\n+import org.springframework.core.io.Resource;\n+import org.springframework.util.CollectionUtils;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n+import com.hedera.mirror.importer.domain.AddressBookEntry;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.FileData;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.FileDataRepository;\n+\n+@Log4j2\n+@Named\n+public class AddressBookServiceImpl implements AddressBookService {\n+    public static final EntityId ADDRESS_BOOK_101_ENTITY_ID = EntityId.of(0, 0, 101, EntityTypeEnum.FILE);\n+    public static final EntityId ADDRESS_BOOK_102_ENTITY_ID = EntityId.of(0, 0, 102, EntityTypeEnum.FILE);\n+\n+    private final MirrorProperties mirrorProperties;\n+    private final AddressBookRepository addressBookRepository;\n+    private final FileDataRepository fileDataRepository;\n+    private Collection<AddressBookEntry> addressBookEntries;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2MzgxOQ==", "bodyText": "Again, this whole method goes away. Loading from the classpath or the filesystem should be handled by the migration and done once (not once per startup). From then on the database is the source of truth.\nYour current implementation is wrong because it repeatedly reloads from classpath/filesystem on startup, completely ignoring the addressbook in the database. So clients will always get the initial address book and not the latest.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462463819", "createdAt": "2020-07-29T17:24:18Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -0,0 +1,271 @@\n+package com.hedera.mirror.importer.addressbook;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.NodeAddressBook;\n+import java.io.ByteArrayOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Instant;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.io.IOUtils;\n+import org.springframework.core.io.ClassPathResource;\n+import org.springframework.core.io.Resource;\n+import org.springframework.util.CollectionUtils;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n+import com.hedera.mirror.importer.domain.AddressBookEntry;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.FileData;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.FileDataRepository;\n+\n+@Log4j2\n+@Named\n+public class AddressBookServiceImpl implements AddressBookService {\n+    public static final EntityId ADDRESS_BOOK_101_ENTITY_ID = EntityId.of(0, 0, 101, EntityTypeEnum.FILE);\n+    public static final EntityId ADDRESS_BOOK_102_ENTITY_ID = EntityId.of(0, 0, 102, EntityTypeEnum.FILE);\n+\n+    private final MirrorProperties mirrorProperties;\n+    private final AddressBookRepository addressBookRepository;\n+    private final FileDataRepository fileDataRepository;\n+    private Collection<AddressBookEntry> addressBookEntries;\n+\n+    public AddressBookServiceImpl(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                                  FileDataRepository fileDataRepository) {\n+        this.mirrorProperties = mirrorProperties;\n+        this.addressBookRepository = addressBookRepository;\n+        this.fileDataRepository = fileDataRepository;\n+        addressBookEntries = Collections.emptyList();\n+        init();\n+    }\n+\n+    @Override\n+    public void update(FileData fileData) {\n+        if (fileData.getFileData() == null || fileData.getFileData().length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n+        try {\n+            parse(fileData);\n+        } catch (Exception e) {\n+            log.warn(\"Unable to parse address book: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public Collection<AddressBookEntry> getAddresses() {\n+        return addressBookEntries;\n+    }\n+\n+    @Override\n+    public boolean isAddressBook(EntityId entityId) {\n+        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId() &&\n+                (entityId.getEntityNum() == 101 || entityId.getEntityNum() == 102)\n+                && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n+    }\n+\n+    private void init() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2NTA4MA==", "bodyText": "Might make sense to have helper methods like fileData.isAppend()", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462465080", "createdAt": "2020-07-29T17:26:19Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -0,0 +1,271 @@\n+package com.hedera.mirror.importer.addressbook;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.NodeAddressBook;\n+import java.io.ByteArrayOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Instant;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.io.IOUtils;\n+import org.springframework.core.io.ClassPathResource;\n+import org.springframework.core.io.Resource;\n+import org.springframework.util.CollectionUtils;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n+import com.hedera.mirror.importer.domain.AddressBookEntry;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.FileData;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.FileDataRepository;\n+\n+@Log4j2\n+@Named\n+public class AddressBookServiceImpl implements AddressBookService {\n+    public static final EntityId ADDRESS_BOOK_101_ENTITY_ID = EntityId.of(0, 0, 101, EntityTypeEnum.FILE);\n+    public static final EntityId ADDRESS_BOOK_102_ENTITY_ID = EntityId.of(0, 0, 102, EntityTypeEnum.FILE);\n+\n+    private final MirrorProperties mirrorProperties;\n+    private final AddressBookRepository addressBookRepository;\n+    private final FileDataRepository fileDataRepository;\n+    private Collection<AddressBookEntry> addressBookEntries;\n+\n+    public AddressBookServiceImpl(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                                  FileDataRepository fileDataRepository) {\n+        this.mirrorProperties = mirrorProperties;\n+        this.addressBookRepository = addressBookRepository;\n+        this.fileDataRepository = fileDataRepository;\n+        addressBookEntries = Collections.emptyList();\n+        init();\n+    }\n+\n+    @Override\n+    public void update(FileData fileData) {\n+        if (fileData.getFileData() == null || fileData.getFileData().length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n+        try {\n+            parse(fileData);\n+        } catch (Exception e) {\n+            log.warn(\"Unable to parse address book: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public Collection<AddressBookEntry> getAddresses() {\n+        return addressBookEntries;\n+    }\n+\n+    @Override\n+    public boolean isAddressBook(EntityId entityId) {\n+        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId() &&\n+                (entityId.getEntityNum() == 101 || entityId.getEntityNum() == 102)\n+                && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n+    }\n+\n+    private void init() {\n+        // load most recent addressBook\n+        loadAddressBookFromDB();\n+\n+        if (CollectionUtils.isEmpty(addressBookEntries)) {\n+            // no addressBook present in db, load from classpath\n+            byte[] addressBookBytes = null;\n+            try {\n+                Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+                if (initialAddressBook != null) {\n+                    addressBookBytes = Files.readAllBytes(initialAddressBook);\n+                    log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length,\n+                            initialAddressBook);\n+                } else {\n+                    MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n+                    String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n+                    Resource resource = new ClassPathResource(resourcePath, getClass());\n+                    addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n+                    log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length, resource);\n+                }\n+            } catch (Exception e) {\n+                throw new IllegalStateException(\"Unable to load valid address book from classpath\");\n+            }\n+\n+            try {\n+                FileData fileData = new FileData(0L, addressBookBytes, ADDRESS_BOOK_102_ENTITY_ID,\n+                        TransactionTypeEnum.FILECREATE.getProtoId());\n+                AddressBook addressBook = parse(fileData);\n+                addressBookEntries = addressBook.getAddressBookEntries();\n+            } catch (Exception e) {\n+                throw new IllegalStateException(\"Unable to parse address book: \", e);\n+            }\n+        } else {\n+            log.info(\"Loaded addressBook w {} nodes from DB. \", addressBookEntries.size());\n+        }\n+\n+        if (getAddresses().isEmpty()) {\n+            throw new IllegalStateException(\"Unable to load a valid address book with node addresses\");\n+        }\n+    }\n+\n+    /**\n+     * find last fileData for given entityId where operation was create/update using consensusTimestamp find all\n+     * fileData since  that time for given entityId concatenate all binary data in order and attempt to parse if\n+     * successful save\n+     *\n+     * @param fileData file data with timestamp, contents, entity type and transactions type for parsing\n+     * @return Parsed addressbook object if valid. Null otherwise.\n+     * @throws Exception\n+     */\n+    private AddressBook parse(FileData fileData) throws Exception {\n+        byte[] addressBookBytes = null;\n+        AddressBook addressBook = null;\n+\n+        if (fileData.getTransactionType() == TransactionTypeEnum.FILEAPPEND.getProtoId()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2NTc4NQ==", "bodyText": "Once you remove init(), this if statement is duplicated by similar check in update()", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462465785", "createdAt": "2020-07-29T17:27:30Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -0,0 +1,271 @@\n+package com.hedera.mirror.importer.addressbook;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.NodeAddressBook;\n+import java.io.ByteArrayOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Instant;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.io.IOUtils;\n+import org.springframework.core.io.ClassPathResource;\n+import org.springframework.core.io.Resource;\n+import org.springframework.util.CollectionUtils;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n+import com.hedera.mirror.importer.domain.AddressBookEntry;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.FileData;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.FileDataRepository;\n+\n+@Log4j2\n+@Named\n+public class AddressBookServiceImpl implements AddressBookService {\n+    public static final EntityId ADDRESS_BOOK_101_ENTITY_ID = EntityId.of(0, 0, 101, EntityTypeEnum.FILE);\n+    public static final EntityId ADDRESS_BOOK_102_ENTITY_ID = EntityId.of(0, 0, 102, EntityTypeEnum.FILE);\n+\n+    private final MirrorProperties mirrorProperties;\n+    private final AddressBookRepository addressBookRepository;\n+    private final FileDataRepository fileDataRepository;\n+    private Collection<AddressBookEntry> addressBookEntries;\n+\n+    public AddressBookServiceImpl(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                                  FileDataRepository fileDataRepository) {\n+        this.mirrorProperties = mirrorProperties;\n+        this.addressBookRepository = addressBookRepository;\n+        this.fileDataRepository = fileDataRepository;\n+        addressBookEntries = Collections.emptyList();\n+        init();\n+    }\n+\n+    @Override\n+    public void update(FileData fileData) {\n+        if (fileData.getFileData() == null || fileData.getFileData().length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n+        try {\n+            parse(fileData);\n+        } catch (Exception e) {\n+            log.warn(\"Unable to parse address book: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public Collection<AddressBookEntry> getAddresses() {\n+        return addressBookEntries;\n+    }\n+\n+    @Override\n+    public boolean isAddressBook(EntityId entityId) {\n+        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId() &&\n+                (entityId.getEntityNum() == 101 || entityId.getEntityNum() == 102)\n+                && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n+    }\n+\n+    private void init() {\n+        // load most recent addressBook\n+        loadAddressBookFromDB();\n+\n+        if (CollectionUtils.isEmpty(addressBookEntries)) {\n+            // no addressBook present in db, load from classpath\n+            byte[] addressBookBytes = null;\n+            try {\n+                Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+                if (initialAddressBook != null) {\n+                    addressBookBytes = Files.readAllBytes(initialAddressBook);\n+                    log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length,\n+                            initialAddressBook);\n+                } else {\n+                    MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n+                    String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n+                    Resource resource = new ClassPathResource(resourcePath, getClass());\n+                    addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n+                    log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length, resource);\n+                }\n+            } catch (Exception e) {\n+                throw new IllegalStateException(\"Unable to load valid address book from classpath\");\n+            }\n+\n+            try {\n+                FileData fileData = new FileData(0L, addressBookBytes, ADDRESS_BOOK_102_ENTITY_ID,\n+                        TransactionTypeEnum.FILECREATE.getProtoId());\n+                AddressBook addressBook = parse(fileData);\n+                addressBookEntries = addressBook.getAddressBookEntries();\n+            } catch (Exception e) {\n+                throw new IllegalStateException(\"Unable to parse address book: \", e);\n+            }\n+        } else {\n+            log.info(\"Loaded addressBook w {} nodes from DB. \", addressBookEntries.size());\n+        }\n+\n+        if (getAddresses().isEmpty()) {\n+            throw new IllegalStateException(\"Unable to load a valid address book with node addresses\");\n+        }\n+    }\n+\n+    /**\n+     * find last fileData for given entityId where operation was create/update using consensusTimestamp find all\n+     * fileData since  that time for given entityId concatenate all binary data in order and attempt to parse if\n+     * successful save\n+     *\n+     * @param fileData file data with timestamp, contents, entity type and transactions type for parsing\n+     * @return Parsed addressbook object if valid. Null otherwise.\n+     * @throws Exception\n+     */\n+    private AddressBook parse(FileData fileData) throws Exception {\n+        byte[] addressBookBytes = null;\n+        AddressBook addressBook = null;\n+\n+        if (fileData.getTransactionType() == TransactionTypeEnum.FILEAPPEND.getProtoId()) {\n+            // concatenate bytes from partial address book file data in db\n+            if (fileData.getFileData() != null && fileData.getFileData().length > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2NjU0OA==", "bodyText": "nit: Not much point to a two line method that's not reused.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462466548", "createdAt": "2020-07-29T17:28:55Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -0,0 +1,271 @@\n+package com.hedera.mirror.importer.addressbook;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.NodeAddressBook;\n+import java.io.ByteArrayOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Instant;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.io.IOUtils;\n+import org.springframework.core.io.ClassPathResource;\n+import org.springframework.core.io.Resource;\n+import org.springframework.util.CollectionUtils;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n+import com.hedera.mirror.importer.domain.AddressBookEntry;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.FileData;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.FileDataRepository;\n+\n+@Log4j2\n+@Named\n+public class AddressBookServiceImpl implements AddressBookService {\n+    public static final EntityId ADDRESS_BOOK_101_ENTITY_ID = EntityId.of(0, 0, 101, EntityTypeEnum.FILE);\n+    public static final EntityId ADDRESS_BOOK_102_ENTITY_ID = EntityId.of(0, 0, 102, EntityTypeEnum.FILE);\n+\n+    private final MirrorProperties mirrorProperties;\n+    private final AddressBookRepository addressBookRepository;\n+    private final FileDataRepository fileDataRepository;\n+    private Collection<AddressBookEntry> addressBookEntries;\n+\n+    public AddressBookServiceImpl(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                                  FileDataRepository fileDataRepository) {\n+        this.mirrorProperties = mirrorProperties;\n+        this.addressBookRepository = addressBookRepository;\n+        this.fileDataRepository = fileDataRepository;\n+        addressBookEntries = Collections.emptyList();\n+        init();\n+    }\n+\n+    @Override\n+    public void update(FileData fileData) {\n+        if (fileData.getFileData() == null || fileData.getFileData().length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n+        try {\n+            parse(fileData);\n+        } catch (Exception e) {\n+            log.warn(\"Unable to parse address book: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public Collection<AddressBookEntry> getAddresses() {\n+        return addressBookEntries;\n+    }\n+\n+    @Override\n+    public boolean isAddressBook(EntityId entityId) {\n+        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId() &&\n+                (entityId.getEntityNum() == 101 || entityId.getEntityNum() == 102)\n+                && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n+    }\n+\n+    private void init() {\n+        // load most recent addressBook\n+        loadAddressBookFromDB();\n+\n+        if (CollectionUtils.isEmpty(addressBookEntries)) {\n+            // no addressBook present in db, load from classpath\n+            byte[] addressBookBytes = null;\n+            try {\n+                Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+                if (initialAddressBook != null) {\n+                    addressBookBytes = Files.readAllBytes(initialAddressBook);\n+                    log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length,\n+                            initialAddressBook);\n+                } else {\n+                    MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n+                    String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n+                    Resource resource = new ClassPathResource(resourcePath, getClass());\n+                    addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n+                    log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length, resource);\n+                }\n+            } catch (Exception e) {\n+                throw new IllegalStateException(\"Unable to load valid address book from classpath\");\n+            }\n+\n+            try {\n+                FileData fileData = new FileData(0L, addressBookBytes, ADDRESS_BOOK_102_ENTITY_ID,\n+                        TransactionTypeEnum.FILECREATE.getProtoId());\n+                AddressBook addressBook = parse(fileData);\n+                addressBookEntries = addressBook.getAddressBookEntries();\n+            } catch (Exception e) {\n+                throw new IllegalStateException(\"Unable to parse address book: \", e);\n+            }\n+        } else {\n+            log.info(\"Loaded addressBook w {} nodes from DB. \", addressBookEntries.size());\n+        }\n+\n+        if (getAddresses().isEmpty()) {\n+            throw new IllegalStateException(\"Unable to load a valid address book with node addresses\");\n+        }\n+    }\n+\n+    /**\n+     * find last fileData for given entityId where operation was create/update using consensusTimestamp find all\n+     * fileData since  that time for given entityId concatenate all binary data in order and attempt to parse if\n+     * successful save\n+     *\n+     * @param fileData file data with timestamp, contents, entity type and transactions type for parsing\n+     * @return Parsed addressbook object if valid. Null otherwise.\n+     * @throws Exception\n+     */\n+    private AddressBook parse(FileData fileData) throws Exception {\n+        byte[] addressBookBytes = null;\n+        AddressBook addressBook = null;\n+\n+        if (fileData.getTransactionType() == TransactionTypeEnum.FILEAPPEND.getProtoId()) {\n+            // concatenate bytes from partial address book file data in db\n+            if (fileData.getFileData() != null && fileData.getFileData().length > 0) {\n+                addressBookBytes = combinePreviousFileDataContents(fileData);\n+            } else {\n+                log.error(\"Previous incomplete address book entry expected but not found\");\n+            }\n+        } else {\n+            addressBookBytes = fileData.getFileData();\n+        }\n+\n+        // store fileData information\n+        fileDataRepository.save(fileData);\n+\n+        addressBook = buildAddressBook(addressBookBytes, fileData.getConsensusTimestamp(), fileData\n+                .getEntityId());\n+        if (addressBook != null) {\n+            saveAddressBook(addressBook);\n+        }\n+\n+        return addressBook;\n+    }\n+\n+    private byte[] combinePreviousFileDataContents(FileData fileData) {\n+        Optional<FileData> optionalFileData = fileDataRepository.\n+                findLatestMatchingFile(fileData\n+                        .getConsensusTimestamp(), fileData.getEntityId().getId(), List\n+                        .of(TransactionTypeEnum.FILECREATE.getProtoId(), TransactionTypeEnum.FILEUPDATE.getProtoId()));\n+        byte[] combinedBytes = null;\n+        if (optionalFileData.isPresent()) {\n+            FileData firstPartialAddressBook = optionalFileData.get();\n+            long consensusTimeStamp = firstPartialAddressBook.getConsensusTimestamp();\n+            List<FileData> appendFileDataEntries = fileDataRepository\n+                    .findFilesInRange(\n+                            consensusTimeStamp + 1, fileData.getConsensusTimestamp() - 1, firstPartialAddressBook\n+                                    .getEntityId().getId(),\n+                            TransactionTypeEnum.FILEAPPEND.getProtoId());\n+\n+            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+            try {\n+                bos.write(firstPartialAddressBook.getFileData());\n+                for (int i = 0; i < appendFileDataEntries.size(); i++) {\n+                    bos.write(appendFileDataEntries.get(i).getFileData());\n+                }\n+\n+                bos.write(fileData.getFileData());\n+                combinedBytes = bos.toByteArray();\n+            } catch (Exception ex) {\n+                log.error(\"Error concatenating partial address book fileData entries\", ex);\n+            }\n+        }\n+\n+        return combinedBytes;\n+    }\n+\n+    private AddressBook buildAddressBook(byte[] addressBookBytes, long consensusTimestamp, EntityId fileID) {\n+        AddressBook.AddressBookBuilder addressBookBuilder = AddressBook.builder()\n+                .fileData(addressBookBytes)\n+                .consensusTimestamp(consensusTimestamp)\n+                .fileId(fileID);\n+\n+        try {\n+            NodeAddressBook nodeAddressBook = NodeAddressBook.parseFrom(addressBookBytes);\n+            if (nodeAddressBook != null) {\n+\n+                if (nodeAddressBook.getNodeAddressCount() > 0) {\n+                    addressBookBuilder.nodeCount(nodeAddressBook.getNodeAddressCount());\n+                    Collection<AddressBookEntry> addressBookEntryCollection =\n+                            retrieveNodeAddressesFromAddressBook(nodeAddressBook, consensusTimestamp);\n+\n+                    addressBookBuilder.addressBookEntries((List<AddressBookEntry>) addressBookEntryCollection);\n+                }\n+            }\n+        } catch (Exception e) {\n+            log.warn(\"Unable to parse address book: {}\", e.getMessage());\n+            return null;\n+        }\n+\n+        return addressBookBuilder.build();\n+    }\n+\n+    private Collection<AddressBookEntry> retrieveNodeAddressesFromAddressBook(NodeAddressBook nodeAddressBook,\n+                                                                              long consensusTimestamp) {\n+        ImmutableList.Builder<AddressBookEntry> builder = ImmutableList.builder();\n+\n+        if (nodeAddressBook != null) {\n+            for (com.hederahashgraph.api.proto.java.NodeAddress nodeAddressProto : nodeAddressBook\n+                    .getNodeAddressList()) {\n+                AddressBookEntry addressBookEntry = AddressBookEntry.builder()\n+                        .consensusTimestamp(consensusTimestamp)\n+                        .memo(nodeAddressProto.getMemo().toStringUtf8())\n+                        .ip(nodeAddressProto.getIpAddress().toStringUtf8())\n+                        .port(nodeAddressProto.getPortno())\n+                        .publicKey(nodeAddressProto.getRSAPubKey())\n+                        .nodeCertHash(nodeAddressProto.getNodeCertHash().toByteArray())\n+                        .nodeId(nodeAddressProto.getNodeId())\n+                        .nodeAccountId(EntityId.of(nodeAddressProto.getNodeAccountId()))\n+                        .build();\n+                builder.add(addressBookEntry);\n+            }\n+        }\n+\n+        return builder.build();\n+    }\n+\n+    private void saveAddressBook(AddressBook addressBook) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9"}, "originalPosition": 255}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ4Mjg1OA==", "bodyText": "return ADDRESS_BOOK_101_ENTITY_ID.equals(entityId) || ADDRESS_BOOK_102_ENTITY_ID.equals(entityId);", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462482858", "createdAt": "2020-07-29T17:55:45Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -0,0 +1,271 @@\n+package com.hedera.mirror.importer.addressbook;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.NodeAddressBook;\n+import java.io.ByteArrayOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Instant;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.io.IOUtils;\n+import org.springframework.core.io.ClassPathResource;\n+import org.springframework.core.io.Resource;\n+import org.springframework.util.CollectionUtils;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n+import com.hedera.mirror.importer.domain.AddressBookEntry;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.FileData;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.FileDataRepository;\n+\n+@Log4j2\n+@Named\n+public class AddressBookServiceImpl implements AddressBookService {\n+    public static final EntityId ADDRESS_BOOK_101_ENTITY_ID = EntityId.of(0, 0, 101, EntityTypeEnum.FILE);\n+    public static final EntityId ADDRESS_BOOK_102_ENTITY_ID = EntityId.of(0, 0, 102, EntityTypeEnum.FILE);\n+\n+    private final MirrorProperties mirrorProperties;\n+    private final AddressBookRepository addressBookRepository;\n+    private final FileDataRepository fileDataRepository;\n+    private Collection<AddressBookEntry> addressBookEntries;\n+\n+    public AddressBookServiceImpl(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                                  FileDataRepository fileDataRepository) {\n+        this.mirrorProperties = mirrorProperties;\n+        this.addressBookRepository = addressBookRepository;\n+        this.fileDataRepository = fileDataRepository;\n+        addressBookEntries = Collections.emptyList();\n+        init();\n+    }\n+\n+    @Override\n+    public void update(FileData fileData) {\n+        if (fileData.getFileData() == null || fileData.getFileData().length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n+        try {\n+            parse(fileData);\n+        } catch (Exception e) {\n+            log.warn(\"Unable to parse address book: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public Collection<AddressBookEntry> getAddresses() {\n+        return addressBookEntries;\n+    }\n+\n+    @Override\n+    public boolean isAddressBook(EntityId entityId) {\n+        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId() &&", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4MTc1Nw==", "bodyText": "It looks like if we get a fileappend without a corresponding create or update, we still create an address book entry and it will have null bytes. This probably shouldn't happen, but we should probably handle and throw an error.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462581757", "createdAt": "2020-07-29T20:53:16Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -0,0 +1,271 @@\n+package com.hedera.mirror.importer.addressbook;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.NodeAddressBook;\n+import java.io.ByteArrayOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Instant;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.io.IOUtils;\n+import org.springframework.core.io.ClassPathResource;\n+import org.springframework.core.io.Resource;\n+import org.springframework.util.CollectionUtils;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n+import com.hedera.mirror.importer.domain.AddressBookEntry;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.FileData;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.FileDataRepository;\n+\n+@Log4j2\n+@Named\n+public class AddressBookServiceImpl implements AddressBookService {\n+    public static final EntityId ADDRESS_BOOK_101_ENTITY_ID = EntityId.of(0, 0, 101, EntityTypeEnum.FILE);\n+    public static final EntityId ADDRESS_BOOK_102_ENTITY_ID = EntityId.of(0, 0, 102, EntityTypeEnum.FILE);\n+\n+    private final MirrorProperties mirrorProperties;\n+    private final AddressBookRepository addressBookRepository;\n+    private final FileDataRepository fileDataRepository;\n+    private Collection<AddressBookEntry> addressBookEntries;\n+\n+    public AddressBookServiceImpl(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                                  FileDataRepository fileDataRepository) {\n+        this.mirrorProperties = mirrorProperties;\n+        this.addressBookRepository = addressBookRepository;\n+        this.fileDataRepository = fileDataRepository;\n+        addressBookEntries = Collections.emptyList();\n+        init();\n+    }\n+\n+    @Override\n+    public void update(FileData fileData) {\n+        if (fileData.getFileData() == null || fileData.getFileData().length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n+        try {\n+            parse(fileData);\n+        } catch (Exception e) {\n+            log.warn(\"Unable to parse address book: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public Collection<AddressBookEntry> getAddresses() {\n+        return addressBookEntries;\n+    }\n+\n+    @Override\n+    public boolean isAddressBook(EntityId entityId) {\n+        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId() &&\n+                (entityId.getEntityNum() == 101 || entityId.getEntityNum() == 102)\n+                && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n+    }\n+\n+    private void init() {\n+        // load most recent addressBook\n+        loadAddressBookFromDB();\n+\n+        if (CollectionUtils.isEmpty(addressBookEntries)) {\n+            // no addressBook present in db, load from classpath\n+            byte[] addressBookBytes = null;\n+            try {\n+                Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+                if (initialAddressBook != null) {\n+                    addressBookBytes = Files.readAllBytes(initialAddressBook);\n+                    log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length,\n+                            initialAddressBook);\n+                } else {\n+                    MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n+                    String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n+                    Resource resource = new ClassPathResource(resourcePath, getClass());\n+                    addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n+                    log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length, resource);\n+                }\n+            } catch (Exception e) {\n+                throw new IllegalStateException(\"Unable to load valid address book from classpath\");\n+            }\n+\n+            try {\n+                FileData fileData = new FileData(0L, addressBookBytes, ADDRESS_BOOK_102_ENTITY_ID,\n+                        TransactionTypeEnum.FILECREATE.getProtoId());\n+                AddressBook addressBook = parse(fileData);\n+                addressBookEntries = addressBook.getAddressBookEntries();\n+            } catch (Exception e) {\n+                throw new IllegalStateException(\"Unable to parse address book: \", e);\n+            }\n+        } else {\n+            log.info(\"Loaded addressBook w {} nodes from DB. \", addressBookEntries.size());\n+        }\n+\n+        if (getAddresses().isEmpty()) {\n+            throw new IllegalStateException(\"Unable to load a valid address book with node addresses\");\n+        }\n+    }\n+\n+    /**\n+     * find last fileData for given entityId where operation was create/update using consensusTimestamp find all\n+     * fileData since  that time for given entityId concatenate all binary data in order and attempt to parse if\n+     * successful save\n+     *\n+     * @param fileData file data with timestamp, contents, entity type and transactions type for parsing\n+     * @return Parsed addressbook object if valid. Null otherwise.\n+     * @throws Exception\n+     */\n+    private AddressBook parse(FileData fileData) throws Exception {\n+        byte[] addressBookBytes = null;\n+        AddressBook addressBook = null;\n+\n+        if (fileData.getTransactionType() == TransactionTypeEnum.FILEAPPEND.getProtoId()) {\n+            // concatenate bytes from partial address book file data in db\n+            if (fileData.getFileData() != null && fileData.getFileData().length > 0) {\n+                addressBookBytes = combinePreviousFileDataContents(fileData);\n+            } else {\n+                log.error(\"Previous incomplete address book entry expected but not found\");\n+            }\n+        } else {\n+            addressBookBytes = fileData.getFileData();\n+        }\n+\n+        // store fileData information\n+        fileDataRepository.save(fileData);\n+\n+        addressBook = buildAddressBook(addressBookBytes, fileData.getConsensusTimestamp(), fileData", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4ODI1MQ==", "bodyText": "Probably shouldn't swallow this error", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462588251", "createdAt": "2020-07-29T21:05:07Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -0,0 +1,271 @@\n+package com.hedera.mirror.importer.addressbook;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.NodeAddressBook;\n+import java.io.ByteArrayOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Instant;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.io.IOUtils;\n+import org.springframework.core.io.ClassPathResource;\n+import org.springframework.core.io.Resource;\n+import org.springframework.util.CollectionUtils;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n+import com.hedera.mirror.importer.domain.AddressBookEntry;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.FileData;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.FileDataRepository;\n+\n+@Log4j2\n+@Named\n+public class AddressBookServiceImpl implements AddressBookService {\n+    public static final EntityId ADDRESS_BOOK_101_ENTITY_ID = EntityId.of(0, 0, 101, EntityTypeEnum.FILE);\n+    public static final EntityId ADDRESS_BOOK_102_ENTITY_ID = EntityId.of(0, 0, 102, EntityTypeEnum.FILE);\n+\n+    private final MirrorProperties mirrorProperties;\n+    private final AddressBookRepository addressBookRepository;\n+    private final FileDataRepository fileDataRepository;\n+    private Collection<AddressBookEntry> addressBookEntries;\n+\n+    public AddressBookServiceImpl(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                                  FileDataRepository fileDataRepository) {\n+        this.mirrorProperties = mirrorProperties;\n+        this.addressBookRepository = addressBookRepository;\n+        this.fileDataRepository = fileDataRepository;\n+        addressBookEntries = Collections.emptyList();\n+        init();\n+    }\n+\n+    @Override\n+    public void update(FileData fileData) {\n+        if (fileData.getFileData() == null || fileData.getFileData().length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n+        try {\n+            parse(fileData);\n+        } catch (Exception e) {\n+            log.warn(\"Unable to parse address book: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public Collection<AddressBookEntry> getAddresses() {\n+        return addressBookEntries;\n+    }\n+\n+    @Override\n+    public boolean isAddressBook(EntityId entityId) {\n+        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId() &&\n+                (entityId.getEntityNum() == 101 || entityId.getEntityNum() == 102)\n+                && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n+    }\n+\n+    private void init() {\n+        // load most recent addressBook\n+        loadAddressBookFromDB();\n+\n+        if (CollectionUtils.isEmpty(addressBookEntries)) {\n+            // no addressBook present in db, load from classpath\n+            byte[] addressBookBytes = null;\n+            try {\n+                Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+                if (initialAddressBook != null) {\n+                    addressBookBytes = Files.readAllBytes(initialAddressBook);\n+                    log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length,\n+                            initialAddressBook);\n+                } else {\n+                    MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n+                    String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n+                    Resource resource = new ClassPathResource(resourcePath, getClass());\n+                    addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n+                    log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length, resource);\n+                }\n+            } catch (Exception e) {\n+                throw new IllegalStateException(\"Unable to load valid address book from classpath\");\n+            }\n+\n+            try {\n+                FileData fileData = new FileData(0L, addressBookBytes, ADDRESS_BOOK_102_ENTITY_ID,\n+                        TransactionTypeEnum.FILECREATE.getProtoId());\n+                AddressBook addressBook = parse(fileData);\n+                addressBookEntries = addressBook.getAddressBookEntries();\n+            } catch (Exception e) {\n+                throw new IllegalStateException(\"Unable to parse address book: \", e);\n+            }\n+        } else {\n+            log.info(\"Loaded addressBook w {} nodes from DB. \", addressBookEntries.size());\n+        }\n+\n+        if (getAddresses().isEmpty()) {\n+            throw new IllegalStateException(\"Unable to load a valid address book with node addresses\");\n+        }\n+    }\n+\n+    /**\n+     * find last fileData for given entityId where operation was create/update using consensusTimestamp find all\n+     * fileData since  that time for given entityId concatenate all binary data in order and attempt to parse if\n+     * successful save\n+     *\n+     * @param fileData file data with timestamp, contents, entity type and transactions type for parsing\n+     * @return Parsed addressbook object if valid. Null otherwise.\n+     * @throws Exception\n+     */\n+    private AddressBook parse(FileData fileData) throws Exception {\n+        byte[] addressBookBytes = null;\n+        AddressBook addressBook = null;\n+\n+        if (fileData.getTransactionType() == TransactionTypeEnum.FILEAPPEND.getProtoId()) {\n+            // concatenate bytes from partial address book file data in db\n+            if (fileData.getFileData() != null && fileData.getFileData().length > 0) {\n+                addressBookBytes = combinePreviousFileDataContents(fileData);\n+            } else {\n+                log.error(\"Previous incomplete address book entry expected but not found\");\n+            }\n+        } else {\n+            addressBookBytes = fileData.getFileData();\n+        }\n+\n+        // store fileData information\n+        fileDataRepository.save(fileData);\n+\n+        addressBook = buildAddressBook(addressBookBytes, fileData.getConsensusTimestamp(), fileData\n+                .getEntityId());\n+        if (addressBook != null) {\n+            saveAddressBook(addressBook);\n+        }\n+\n+        return addressBook;\n+    }\n+\n+    private byte[] combinePreviousFileDataContents(FileData fileData) {\n+        Optional<FileData> optionalFileData = fileDataRepository.\n+                findLatestMatchingFile(fileData\n+                        .getConsensusTimestamp(), fileData.getEntityId().getId(), List\n+                        .of(TransactionTypeEnum.FILECREATE.getProtoId(), TransactionTypeEnum.FILEUPDATE.getProtoId()));\n+        byte[] combinedBytes = null;\n+        if (optionalFileData.isPresent()) {\n+            FileData firstPartialAddressBook = optionalFileData.get();\n+            long consensusTimeStamp = firstPartialAddressBook.getConsensusTimestamp();\n+            List<FileData> appendFileDataEntries = fileDataRepository\n+                    .findFilesInRange(\n+                            consensusTimeStamp + 1, fileData.getConsensusTimestamp() - 1, firstPartialAddressBook\n+                                    .getEntityId().getId(),\n+                            TransactionTypeEnum.FILEAPPEND.getProtoId());\n+\n+            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+            try {\n+                bos.write(firstPartialAddressBook.getFileData());\n+                for (int i = 0; i < appendFileDataEntries.size(); i++) {\n+                    bos.write(appendFileDataEntries.get(i).getFileData());\n+                }\n+\n+                bos.write(fileData.getFileData());\n+                combinedBytes = bos.toByteArray();\n+            } catch (Exception ex) {\n+                log.error(\"Error concatenating partial address book fileData entries\", ex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5MDI3Mw==", "bodyText": "Can at least set initial size to first address contents size as an optimization. Can also just return initialbytes if appends.size == 0.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462590273", "createdAt": "2020-07-29T21:08:52Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -0,0 +1,271 @@\n+package com.hedera.mirror.importer.addressbook;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.NodeAddressBook;\n+import java.io.ByteArrayOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Instant;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.io.IOUtils;\n+import org.springframework.core.io.ClassPathResource;\n+import org.springframework.core.io.Resource;\n+import org.springframework.util.CollectionUtils;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.AddressBook;\n+import com.hedera.mirror.importer.domain.AddressBookEntry;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.FileData;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.FileDataRepository;\n+\n+@Log4j2\n+@Named\n+public class AddressBookServiceImpl implements AddressBookService {\n+    public static final EntityId ADDRESS_BOOK_101_ENTITY_ID = EntityId.of(0, 0, 101, EntityTypeEnum.FILE);\n+    public static final EntityId ADDRESS_BOOK_102_ENTITY_ID = EntityId.of(0, 0, 102, EntityTypeEnum.FILE);\n+\n+    private final MirrorProperties mirrorProperties;\n+    private final AddressBookRepository addressBookRepository;\n+    private final FileDataRepository fileDataRepository;\n+    private Collection<AddressBookEntry> addressBookEntries;\n+\n+    public AddressBookServiceImpl(MirrorProperties mirrorProperties, AddressBookRepository addressBookRepository,\n+                                  FileDataRepository fileDataRepository) {\n+        this.mirrorProperties = mirrorProperties;\n+        this.addressBookRepository = addressBookRepository;\n+        this.fileDataRepository = fileDataRepository;\n+        addressBookEntries = Collections.emptyList();\n+        init();\n+    }\n+\n+    @Override\n+    public void update(FileData fileData) {\n+        if (fileData.getFileData() == null || fileData.getFileData().length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n+        try {\n+            parse(fileData);\n+        } catch (Exception e) {\n+            log.warn(\"Unable to parse address book: {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public Collection<AddressBookEntry> getAddresses() {\n+        return addressBookEntries;\n+    }\n+\n+    @Override\n+    public boolean isAddressBook(EntityId entityId) {\n+        return entityId != null && entityId.getType() == EntityTypeEnum.FILE.getId() &&\n+                (entityId.getEntityNum() == 101 || entityId.getEntityNum() == 102)\n+                && entityId.getShardNum() == 0 && entityId.getRealmNum() == 0;\n+    }\n+\n+    private void init() {\n+        // load most recent addressBook\n+        loadAddressBookFromDB();\n+\n+        if (CollectionUtils.isEmpty(addressBookEntries)) {\n+            // no addressBook present in db, load from classpath\n+            byte[] addressBookBytes = null;\n+            try {\n+                Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+                if (initialAddressBook != null) {\n+                    addressBookBytes = Files.readAllBytes(initialAddressBook);\n+                    log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length,\n+                            initialAddressBook);\n+                } else {\n+                    MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n+                    String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n+                    Resource resource = new ClassPathResource(resourcePath, getClass());\n+                    addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n+                    log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length, resource);\n+                }\n+            } catch (Exception e) {\n+                throw new IllegalStateException(\"Unable to load valid address book from classpath\");\n+            }\n+\n+            try {\n+                FileData fileData = new FileData(0L, addressBookBytes, ADDRESS_BOOK_102_ENTITY_ID,\n+                        TransactionTypeEnum.FILECREATE.getProtoId());\n+                AddressBook addressBook = parse(fileData);\n+                addressBookEntries = addressBook.getAddressBookEntries();\n+            } catch (Exception e) {\n+                throw new IllegalStateException(\"Unable to parse address book: \", e);\n+            }\n+        } else {\n+            log.info(\"Loaded addressBook w {} nodes from DB. \", addressBookEntries.size());\n+        }\n+\n+        if (getAddresses().isEmpty()) {\n+            throw new IllegalStateException(\"Unable to load a valid address book with node addresses\");\n+        }\n+    }\n+\n+    /**\n+     * find last fileData for given entityId where operation was create/update using consensusTimestamp find all\n+     * fileData since  that time for given entityId concatenate all binary data in order and attempt to parse if\n+     * successful save\n+     *\n+     * @param fileData file data with timestamp, contents, entity type and transactions type for parsing\n+     * @return Parsed addressbook object if valid. Null otherwise.\n+     * @throws Exception\n+     */\n+    private AddressBook parse(FileData fileData) throws Exception {\n+        byte[] addressBookBytes = null;\n+        AddressBook addressBook = null;\n+\n+        if (fileData.getTransactionType() == TransactionTypeEnum.FILEAPPEND.getProtoId()) {\n+            // concatenate bytes from partial address book file data in db\n+            if (fileData.getFileData() != null && fileData.getFileData().length > 0) {\n+                addressBookBytes = combinePreviousFileDataContents(fileData);\n+            } else {\n+                log.error(\"Previous incomplete address book entry expected but not found\");\n+            }\n+        } else {\n+            addressBookBytes = fileData.getFileData();\n+        }\n+\n+        // store fileData information\n+        fileDataRepository.save(fileData);\n+\n+        addressBook = buildAddressBook(addressBookBytes, fileData.getConsensusTimestamp(), fileData\n+                .getEntityId());\n+        if (addressBook != null) {\n+            saveAddressBook(addressBook);\n+        }\n+\n+        return addressBook;\n+    }\n+\n+    private byte[] combinePreviousFileDataContents(FileData fileData) {\n+        Optional<FileData> optionalFileData = fileDataRepository.\n+                findLatestMatchingFile(fileData\n+                        .getConsensusTimestamp(), fileData.getEntityId().getId(), List\n+                        .of(TransactionTypeEnum.FILECREATE.getProtoId(), TransactionTypeEnum.FILEUPDATE.getProtoId()));\n+        byte[] combinedBytes = null;\n+        if (optionalFileData.isPresent()) {\n+            FileData firstPartialAddressBook = optionalFileData.get();\n+            long consensusTimeStamp = firstPartialAddressBook.getConsensusTimestamp();\n+            List<FileData> appendFileDataEntries = fileDataRepository\n+                    .findFilesInRange(\n+                            consensusTimeStamp + 1, fileData.getConsensusTimestamp() - 1, firstPartialAddressBook\n+                                    .getEntityId().getId(),\n+                            TransactionTypeEnum.FILEAPPEND.getProtoId());\n+\n+            ByteArrayOutputStream bos = new ByteArrayOutputStream();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYxNjg0MA==", "bodyText": "Bad practice to add custom methods just for tests.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462616840", "createdAt": "2020-07-29T22:04:57Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/repository/AddressBookEntryRepository.java", "diffHunk": "@@ -0,0 +1,30 @@\n+package com.hedera.mirror.importer.repository;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import java.util.List;\n+import org.springframework.data.repository.CrudRepository;\n+\n+import com.hedera.mirror.importer.domain.AddressBookEntry;\n+\n+public interface AddressBookEntryRepository extends CrudRepository<AddressBookEntry, Long> {\n+    List<AddressBookEntry> findAddressBookEntriesByConsensusTimestamp(Long consensusTimeStamp);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYyMDIwOQ==", "bodyText": "Find object, then update statement doesn't make sense. Just addressBookRepository.save().", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462620209", "createdAt": "2020-07-29T22:13:01Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordFileParser.java", "diffHunk": "@@ -272,4 +281,46 @@ public void parse() {\n             log.error(\"Error parsing files\", e);\n         }\n     }\n+\n+    /**\n+     * Address book updates currently span record files as well as a network shutdown. To account for this verify start\n+     * and end of addressbook are set after a record file is processed. If not set based on first and last transaction\n+     * in record file\n+     *\n+     * @param startConsensusTimestamp\n+     */\n+    private void updateAddressBook(long startConsensusTimestamp) {\n+\n+        log.info(\"**startConsensusTimestamp: {}\", startConsensusTimestamp);\n+        // to:do - explore whether shutdown hook is a better place for address book consensusTimestamp boundary sets\n+        Optional<AddressBook> optionalAddressBook = addressBookRepository\n+                .findLatestAddressBook(startConsensusTimestamp, AddressBookServiceImpl.ADDRESS_BOOK_102_ENTITY_ID\n+                        .getId());\n+\n+        if (optionalAddressBook.isPresent()) {\n+            AddressBook addressBook = optionalAddressBook.get();\n+\n+            // set StartConsensusTimestamp of addressBook as first transaction in record file if not set already\n+            if (addressBook.getStartConsensusTimestamp() == null) {\n+                addressBook.setStartConsensusTimestamp(startConsensusTimestamp);\n+                addressBookRepository\n+                        .updateStartConsensusTimestamp(addressBook.getConsensusTimestamp(), startConsensusTimestamp);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYyMDIzMw==", "bodyText": "Find object, then update statement doesn't make sense. Just addressBookRepository.save().", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462620233", "createdAt": "2020-07-29T22:13:05Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordFileParser.java", "diffHunk": "@@ -272,4 +281,46 @@ public void parse() {\n             log.error(\"Error parsing files\", e);\n         }\n     }\n+\n+    /**\n+     * Address book updates currently span record files as well as a network shutdown. To account for this verify start\n+     * and end of addressbook are set after a record file is processed. If not set based on first and last transaction\n+     * in record file\n+     *\n+     * @param startConsensusTimestamp\n+     */\n+    private void updateAddressBook(long startConsensusTimestamp) {\n+\n+        log.info(\"**startConsensusTimestamp: {}\", startConsensusTimestamp);\n+        // to:do - explore whether shutdown hook is a better place for address book consensusTimestamp boundary sets\n+        Optional<AddressBook> optionalAddressBook = addressBookRepository\n+                .findLatestAddressBook(startConsensusTimestamp, AddressBookServiceImpl.ADDRESS_BOOK_102_ENTITY_ID\n+                        .getId());\n+\n+        if (optionalAddressBook.isPresent()) {\n+            AddressBook addressBook = optionalAddressBook.get();\n+\n+            // set StartConsensusTimestamp of addressBook as first transaction in record file if not set already\n+            if (addressBook.getStartConsensusTimestamp() == null) {\n+                addressBook.setStartConsensusTimestamp(startConsensusTimestamp);\n+                addressBookRepository\n+                        .updateStartConsensusTimestamp(addressBook.getConsensusTimestamp(), startConsensusTimestamp);\n+            }\n+\n+            // close off previous addressBook\n+            Optional<AddressBook> previousOptionalAddressBook = addressBookRepository\n+                    .findLatestAddressBook(addressBook\n+                            .getConsensusTimestamp(), AddressBookServiceImpl.ADDRESS_BOOK_102_ENTITY_ID.getId());\n+            if (previousOptionalAddressBook.isPresent()) {\n+                AddressBook previousAddressbook = previousOptionalAddressBook.get();\n+\n+                // set EndConsensusTimestamp of addressBook as first transaction - 1ns in record file if not set already\n+                if (previousAddressbook.getEndConsensusTimestamp() == null) {\n+                    previousAddressbook.setEndConsensusTimestamp(startConsensusTimestamp - 1);\n+                    addressBookRepository.updateEndConsensusTimestamp(previousAddressbook", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYyMzk2OQ==", "bodyText": "This causes extra queries to run for every record file even if address book wasn't updated in that file. Also, this logic is not necessary. If the intent is to only \"activate\" the address book when finished processing the record file, we can do that purely with transactions. This logic should move to AddressBookService and once an address book is successfully parsed we should set start and end time appropriately.\nI don't think the start time should be the start of the first tx in the record file as the opening and closing of that file holds no special significance in the platform. So until the platform supports updating address book without a restart, we should just set currentaddressbook.start = lastappend.timestamp and previousaddressbook.end= lastappend.timestamp - 1.\nAnd even if this logic is somehow needed, it definitely should not be in RecordFileParser but in AddressBookService.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462623969", "createdAt": "2020-07-29T22:22:00Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordFileParser.java", "diffHunk": "@@ -272,4 +281,46 @@ public void parse() {\n             log.error(\"Error parsing files\", e);\n         }\n     }\n+\n+    /**\n+     * Address book updates currently span record files as well as a network shutdown. To account for this verify start\n+     * and end of addressbook are set after a record file is processed. If not set based on first and last transaction\n+     * in record file\n+     *\n+     * @param startConsensusTimestamp\n+     */\n+    private void updateAddressBook(long startConsensusTimestamp) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYyNDYzNQ==", "bodyText": "Why native here and jpql for others? Query looks simple enough", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462624635", "createdAt": "2020-07-29T22:23:49Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/repository/AddressBookRepository.java", "diffHunk": "@@ -0,0 +1,59 @@\n+package com.hedera.mirror.importer.repository;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import java.util.List;\n+import java.util.Optional;\n+import javax.transaction.Transactional;\n+import org.springframework.cache.annotation.CacheConfig;\n+import org.springframework.cache.annotation.CacheEvict;\n+import org.springframework.data.jpa.repository.Modifying;\n+import org.springframework.data.jpa.repository.Query;\n+import org.springframework.data.repository.CrudRepository;\n+import org.springframework.data.repository.query.Param;\n+\n+import com.hedera.mirror.importer.config.CacheConfiguration;\n+import com.hedera.mirror.importer.domain.AddressBook;\n+import com.hedera.mirror.importer.domain.EntityId;\n+\n+@CacheConfig(cacheNames = \"address_book\", cacheManager = CacheConfiguration.NEVER_EXPIRE_LARGE)\n+@Transactional\n+public interface AddressBookRepository extends CrudRepository<AddressBook, Long> {\n+    @Query(value = \"select * from address_book where consensus_timestamp <= ?1 and file_id = ?2 order by \" +\n+            \"consensus_timestamp desc limit 1\", nativeQuery = true)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYyNDgwNw==", "bodyText": "These look like leftover cacheevicts", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462624807", "createdAt": "2020-07-29T22:24:20Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/repository/AddressBookRepository.java", "diffHunk": "@@ -0,0 +1,59 @@\n+package com.hedera.mirror.importer.repository;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import java.util.List;\n+import java.util.Optional;\n+import javax.transaction.Transactional;\n+import org.springframework.cache.annotation.CacheConfig;\n+import org.springframework.cache.annotation.CacheEvict;\n+import org.springframework.data.jpa.repository.Modifying;\n+import org.springframework.data.jpa.repository.Query;\n+import org.springframework.data.repository.CrudRepository;\n+import org.springframework.data.repository.query.Param;\n+\n+import com.hedera.mirror.importer.config.CacheConfiguration;\n+import com.hedera.mirror.importer.domain.AddressBook;\n+import com.hedera.mirror.importer.domain.EntityId;\n+\n+@CacheConfig(cacheNames = \"address_book\", cacheManager = CacheConfiguration.NEVER_EXPIRE_LARGE)\n+@Transactional\n+public interface AddressBookRepository extends CrudRepository<AddressBook, Long> {\n+    @Query(value = \"select * from address_book where consensus_timestamp <= ?1 and file_id = ?2 order by \" +\n+            \"consensus_timestamp desc limit 1\", nativeQuery = true)\n+    Optional<AddressBook> findLatestAddressBook(long consensusTimestamp, long encodedFileId);\n+\n+    @Query(\"from AddressBook where consensusTimestamp <= ?1 and fileId = ?2 order by \" +\n+            \"consensusTimestamp asc\")\n+    List<AddressBook> findLatestAddressBooks(long consensusTimestamp, EntityId fileId);\n+\n+    @CacheEvict(key = \"#p0\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYzNzQ4MA==", "bodyText": "nit: It's more isolate if the constraint is declared inside the create table.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462637480", "createdAt": "2020-07-29T22:58:47Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/resources/db/migration/V1.28.0__address_book.sql", "diffHunk": "@@ -0,0 +1,53 @@\n+-------------------\n+-- Support db storage of network address books\n+-------------------\n+\n+-- add address book table\n+create table if not exists address_book\n+(\n+    consensus_timestamp         nanos_timestamp primary key,\n+    start_consensus_timestamp   nanos_timestamp null,\n+    end_consensus_timestamp     nanos_timestamp null,\n+    file_id                     entity_id       not null,\n+    node_count                  smallint        null,\n+    file_data                   bytea           not null\n+);\n+\n+create index if not exists address_book__fileId\n+    on address_book (consensus_timestamp, file_id);\n+\n+-- add node address table\n+create table if not exists address_book_entry\n+(\n+    id                      serial          primary key,\n+    consensus_timestamp     nanos_timestamp not null,\n+    ip                      varchar(128)    null,\n+    port                    integer         null,\n+    memo                    varchar(128)    not null,\n+    public_key              varchar(1024)   null,\n+    node_id                 bigint          null,\n+    node_account_id         entity_id       null,\n+    node_cert_hash          bytea           null\n+);\n+\n+create index if not exists address_book_entry__id_timestamp\n+    on address_book_entry (id, consensus_timestamp);\n+\n+-- add foreign key\n+alter table address_book_entry\n+    add constraint fk__address_book foreign key (consensus_timestamp) references address_book (consensus_timestamp);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYzNzc0Mw==", "bodyText": "why would id be included? If we had the id we wouldn't need to query by consensus_timestamp", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462637743", "createdAt": "2020-07-29T22:59:33Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/resources/db/migration/V1.28.0__address_book.sql", "diffHunk": "@@ -0,0 +1,53 @@\n+-------------------\n+-- Support db storage of network address books\n+-------------------\n+\n+-- add address book table\n+create table if not exists address_book\n+(\n+    consensus_timestamp         nanos_timestamp primary key,\n+    start_consensus_timestamp   nanos_timestamp null,\n+    end_consensus_timestamp     nanos_timestamp null,\n+    file_id                     entity_id       not null,\n+    node_count                  smallint        null,\n+    file_data                   bytea           not null\n+);\n+\n+create index if not exists address_book__fileId\n+    on address_book (consensus_timestamp, file_id);\n+\n+-- add node address table\n+create table if not exists address_book_entry\n+(\n+    id                      serial          primary key,\n+    consensus_timestamp     nanos_timestamp not null,\n+    ip                      varchar(128)    null,\n+    port                    integer         null,\n+    memo                    varchar(128)    not null,\n+    public_key              varchar(1024)   null,\n+    node_id                 bigint          null,\n+    node_account_id         entity_id       null,\n+    node_cert_hash          bytea           null\n+);\n+\n+create index if not exists address_book_entry__id_timestamp\n+    on address_book_entry (id, consensus_timestamp);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY0Nzk0Nw==", "bodyText": "q: Are all the casts necessary? Also, wouldn't a simple entity_id in (101, 102) suffice?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462647947", "createdAt": "2020-07-29T23:31:56Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_28_1__Address_Book.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.flywaydb.core.internal.jdbc.JdbcTemplate;\n+import org.flywaydb.core.internal.jdbc.RowMapper;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.util.CollectionUtils;\n+\n+import com.hedera.mirror.importer.addressbook.AddressBookService;\n+import com.hedera.mirror.importer.addressbook.AddressBookServiceImpl;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.FileData;\n+import com.hedera.mirror.importer.util.EntityIdEndec;\n+\n+@Log4j2\n+@Named\n+public class V1_28_1__Address_Book extends BaseJavaMigration {\n+    private final AddressBookService addressBookService;\n+    private final String FILE_DATA_SQL = \"select * from file_data where consensus_timestamp > cast(? as \" +\n+            \"nanos_timestamp) and (entity_id = cast(? as int) or entity_id = cast(? as int)) order by \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY0OTIzNg==", "bodyText": "Missing logic to load from classpath/filesystem.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462649236", "createdAt": "2020-07-29T23:36:10Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_28_1__Address_Book.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.flywaydb.core.internal.jdbc.JdbcTemplate;\n+import org.flywaydb.core.internal.jdbc.RowMapper;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.util.CollectionUtils;\n+\n+import com.hedera.mirror.importer.addressbook.AddressBookService;\n+import com.hedera.mirror.importer.addressbook.AddressBookServiceImpl;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.FileData;\n+import com.hedera.mirror.importer.util.EntityIdEndec;\n+\n+@Log4j2\n+@Named\n+public class V1_28_1__Address_Book extends BaseJavaMigration {\n+    private final AddressBookService addressBookService;\n+    private final String FILE_DATA_SQL = \"select * from file_data where consensus_timestamp > cast(? as \" +\n+            \"nanos_timestamp) and (entity_id = cast(? as int) or entity_id = cast(? as int)) order by \" +\n+            \"consensus_timestamp asc limit cast(? as int)\";\n+    private JdbcTemplate jdbcTemplate;\n+\n+    public V1_28_1__Address_Book(@Lazy AddressBookService addressBookService) {\n+        this.addressBookService = addressBookService;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        jdbcTemplate = new JdbcTemplate(context.getConnection());\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+        AtomicLong currentConsensusTimestamp = new AtomicLong(0);\n+        AtomicLong fileDataEntries = new AtomicLong(0);\n+\n+        // starting from consensusTimeStamp = 0 retrieve pages of fileData entries\n+        int pageSize = 1000; // option to parameterize this", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1MzY2MA==", "bodyText": "How are we mocking address book repository when Downloader only has a reference to AddressBookService? We're testing too many layers here. We should just mock the AddressBookService and remove  the filesystem manipulation and repository. This is the same thing I said before.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r462653660", "createdAt": "2020-07-29T23:50:28Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/downloader/AbstractDownloaderTest.java", "diffHunk": "@@ -211,14 +228,23 @@ void partialConsensus() throws Exception {\n     @Test\n     @DisplayName(\"Exactly 1/3 consensus\")\n     void oneThirdConsensus() throws Exception {\n-        // Remove last node from current 4 node address book\n-        byte[] addressBook = Files.readAllBytes(mirrorProperties.getAddressBookPath());\n+        MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n+        Path addressBookPath = ResourceUtils.getFile(String\n+                .format(\"classpath:addressbook/%s\", hederaNetwork.name().toLowerCase())).toPath();\n+        byte[] addressBook = Files.readAllBytes(addressBookPath);\n         int index = Bytes.lastIndexOf(addressBook, (byte) '\\n');\n         addressBook = Arrays.copyOfRange(addressBook, 0, index);\n-        networkAddressBook.update(addressBook);\n+        EntityId entityId = EntityId.of(0, 0, 102, EntityTypeEnum.FILE);\n+        long now = Instant.now().getEpochSecond();\n+\n+        doReturn(Optional.of(addressBookFromBytes(addressBook, now, entityId)))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f91d29ee4143c257c181403c26fe0fa27a7d9b9"}, "originalPosition": 106}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d92fe2ca1265f71c4e3383cf2ef532166a13e1c5", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/d92fe2ca1265f71c4e3383cf2ef532166a13e1c5", "committedDate": "2020-07-30T00:51:35Z", "message": "Merged memory leak fix and version bumps\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fcd3ea286fbc0c6653859e1486a2b2c3c0a96e94", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/fcd3ea286fbc0c6653859e1486a2b2c3c0a96e94", "committedDate": "2020-07-30T06:07:20Z", "message": "Addressed 1st round of final comments\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "36a094d091407ca77c32e46e4cda52f6886b1e88", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/36a094d091407ca77c32e46e4cda52f6886b1e88", "committedDate": "2020-07-30T09:12:45Z", "message": "Addressed 2nd set of feedback. Also added FREEZE transaction support\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4NDU4NDMz", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#pullrequestreview-458458433", "createdAt": "2020-07-30T14:30:42Z", "commit": {"oid": "36a094d091407ca77c32e46e4cda52f6886b1e88"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNDozMDo0MlrOG5lrcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNDozMDo0MlrOG5lrcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzAzOTM0Nw==", "bodyText": "Use Spring JdbcTemplate not internal Flyway classes.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r463039347", "createdAt": "2020-07-30T14:30:42Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_28_1__Address_Book.java", "diffHunk": "@@ -0,0 +1,130 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.io.IOUtils;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.flywaydb.core.internal.jdbc.JdbcTemplate;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36a094d091407ca77c32e46e4cda52f6886b1e88"}, "originalPosition": 36}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54a4049adcb32cbe251cc8a7a65c21e0a2c9efd5", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/54a4049adcb32cbe251cc8a7a65c21e0a2c9efd5", "committedDate": "2020-07-30T19:08:58Z", "message": "Adopted simpler approach to address book update\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1502ba448a5b3477724480eab01e70f0551bc50", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/a1502ba448a5b3477724480eab01e70f0551bc50", "committedDate": "2020-07-30T22:47:44Z", "message": "Fixed up endpoint timestamp setting logic and removed consensustimestamp\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4ODUxMTIy", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#pullrequestreview-458851122", "createdAt": "2020-07-31T00:41:32Z", "commit": {"oid": "a1502ba448a5b3477724480eab01e70f0551bc50"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwMDo0MTozMlrOG54Zfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwMToxMDoyOFrOG543zA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM0NjA0Nw==", "bodyText": "Test only repository method", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r463346047", "createdAt": "2020-07-31T00:41:32Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/repository/AddressBookRepository.java", "diffHunk": "@@ -0,0 +1,38 @@\n+package com.hedera.mirror.importer.repository;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import java.util.List;\n+import java.util.Optional;\n+import org.springframework.data.jpa.repository.Query;\n+import org.springframework.data.repository.CrudRepository;\n+\n+import com.hedera.mirror.importer.domain.AddressBook;\n+import com.hedera.mirror.importer.domain.EntityId;\n+\n+public interface AddressBookRepository extends CrudRepository<AddressBook, Long> {\n+    @Query(value = \"select * from address_book where start_consensus_timestamp <= ?1 and file_id = ?2 order by \" +\n+            \"start_consensus_timestamp desc limit 1\", nativeQuery = true)\n+    Optional<AddressBook> findLatestAddressBook(long consensusTimestamp, long encodedFileId);\n+\n+    @Query(\"from AddressBook where startConsensusTimestamp <= ?1 and fileId = ?2 order by startConsensusTimestamp asc\")\n+    List<AddressBook> findLatestAddressBooks(long consensusTimestamp, EntityId fileId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1502ba448a5b3477724480eab01e70f0551bc50"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM0NjI3Nw==", "bodyText": "Looks like leftover from refactoring.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r463346277", "createdAt": "2020-07-31T00:42:28Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordFileParser.java", "diffHunk": "@@ -64,6 +65,7 @@\n public class RecordFileParser implements FileParser {\n \n     private final ApplicationStatusRepository applicationStatusRepository;\n+    private final AddressBookRepository addressBookRepository;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1502ba448a5b3477724480eab01e70f0551bc50"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM0ODgzOA==", "bodyText": "This annotation is not applicable here.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r463348838", "createdAt": "2020-07-31T00:50:57Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/AddressBookEntry.java", "diffHunk": "@@ -52,4 +79,18 @@ public PublicKey getPublicKeyAsObject() {\n             throw new RuntimeException(e);\n         }\n     }\n+\n+    public EntityId getNodeAccountId() {\n+        if (nodeAccountId == null) {\n+            return memo == null ? null : EntityId.of(memo, EntityTypeEnum.ACCOUNT);\n+        }\n+\n+        return nodeAccountId;\n+    }\n+\n+    @Lazy", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1502ba448a5b3477724480eab01e70f0551bc50"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1MDMxMw==", "bodyText": "startConsensusTimestamp is always non-null. Can remove Persistable", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r463350313", "createdAt": "2020-07-31T00:56:30Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/AddressBook.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.persistence.CascadeType;\n+import javax.persistence.Convert;\n+import javax.persistence.Entity;\n+import javax.persistence.FetchType;\n+import javax.persistence.Id;\n+import javax.persistence.JoinColumn;\n+import javax.persistence.OneToMany;\n+import lombok.AllArgsConstructor;\n+import lombok.Builder;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.ToString;\n+import org.springframework.data.domain.Persistable;\n+\n+import com.hedera.mirror.importer.converter.FileIdConverter;\n+\n+@Builder(toBuilder = true)\n+@Data\n+@Entity\n+@NoArgsConstructor\n+@AllArgsConstructor\n+@ToString(exclude = {\"fileData\"})\n+public class AddressBook implements Persistable<Long> {\n+    // consensusTimestamp + 1ns of transaction containing final fileAppend operation\n+    @Id\n+    private Long startConsensusTimestamp;\n+\n+    // consensusTimestamp of transaction containing final fileAppend operation of next address book\n+    private Long endConsensusTimestamp;\n+\n+    @Convert(converter = FileIdConverter.class)\n+    private EntityId fileId;\n+\n+    private Integer nodeCount;\n+\n+    private byte[] fileData;\n+\n+    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, fetch = FetchType.EAGER)\n+    @JoinColumn(name = \"consensusTimestamp\")\n+    private List<AddressBookEntry> entries;\n+\n+    @Override\n+    public Long getId() {\n+        return startConsensusTimestamp;\n+    }\n+\n+    @Override\n+    public boolean isNew() {\n+        return startConsensusTimestamp == null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1502ba448a5b3477724480eab01e70f0551bc50"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1MTM4MA==", "bodyText": "I don't think any current user of this method can handle a null returned object, so we'll get NPEs. Better to throw a meaningful exception as it's truly an invalid state if we don't have at least one address book. Thus, most of this method can be collapsed to\nreturn addressBookRepository.findLatestAddressBook(consensus_timestamp, ADDRESS_BOOK_102_ENTITY_ID.getId()).orElseThrow(() -> new IllegalStateException(\"\"));", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r463351380", "createdAt": "2020-07-31T01:00:47Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -0,0 +1,243 @@\n+package com.hedera.mirror.importer.addressbook;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.NodeAddressBook;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.importer.domain.AddressBook;\n+import com.hedera.mirror.importer.domain.AddressBookEntry;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.FileData;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.InvalidDatasetException;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.FileDataRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+@AllArgsConstructor\n+public class AddressBookServiceImpl implements AddressBookService {\n+    public static final EntityId ADDRESS_BOOK_101_ENTITY_ID = EntityId.of(0, 0, 101, EntityTypeEnum.FILE);\n+    public static final EntityId ADDRESS_BOOK_102_ENTITY_ID = EntityId.of(0, 0, 102, EntityTypeEnum.FILE);\n+\n+    private final AddressBookRepository addressBookRepository;\n+    private final FileDataRepository fileDataRepository;\n+\n+    @Override\n+    public void update(FileData fileData) {\n+        if (!isAddressBook(fileData.getEntityId())) {\n+            log.warn(\"Not an address book File ID. Skipping processing ...\");\n+            return;\n+        }\n+\n+        if (fileData.getFileData() == null || fileData.getFileData().length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n+        try {\n+            parse(fileData);\n+        } catch (Exception e) {\n+            log.error(\"Unable to parse address book\", e);\n+        }\n+    }\n+\n+    @Override\n+    public AddressBook getCurrent() {\n+        Instant now = Instant.now();\n+        long consensus_timestamp = Utility.convertToNanos(Instant.now().getEpochSecond(), now.getNano());\n+        Optional<AddressBook> optionalAddressBook = addressBookRepository\n+                .findLatestAddressBook(consensus_timestamp, ADDRESS_BOOK_102_ENTITY_ID.getId());\n+\n+        if (optionalAddressBook.isPresent()) {\n+            AddressBook addressBook = optionalAddressBook.get();\n+            log.info(\"Loaded addressBook from {} with nodes ({}).\", addressBook.getStartConsensusTimestamp(),\n+                    addressBook.getNodeSet());\n+            return addressBook;\n+        }\n+\n+        log.warn(\"No addressBooks before {} were found.\", consensus_timestamp);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1502ba448a5b3477724480eab01e70f0551bc50"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1MTc2Mw==", "bodyText": "Please remove this log. It will be printed many times per second in Downloader.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r463351763", "createdAt": "2020-07-31T01:02:16Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -0,0 +1,243 @@\n+package com.hedera.mirror.importer.addressbook;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.NodeAddressBook;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.importer.domain.AddressBook;\n+import com.hedera.mirror.importer.domain.AddressBookEntry;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.FileData;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.InvalidDatasetException;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.FileDataRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+@AllArgsConstructor\n+public class AddressBookServiceImpl implements AddressBookService {\n+    public static final EntityId ADDRESS_BOOK_101_ENTITY_ID = EntityId.of(0, 0, 101, EntityTypeEnum.FILE);\n+    public static final EntityId ADDRESS_BOOK_102_ENTITY_ID = EntityId.of(0, 0, 102, EntityTypeEnum.FILE);\n+\n+    private final AddressBookRepository addressBookRepository;\n+    private final FileDataRepository fileDataRepository;\n+\n+    @Override\n+    public void update(FileData fileData) {\n+        if (!isAddressBook(fileData.getEntityId())) {\n+            log.warn(\"Not an address book File ID. Skipping processing ...\");\n+            return;\n+        }\n+\n+        if (fileData.getFileData() == null || fileData.getFileData().length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n+        try {\n+            parse(fileData);\n+        } catch (Exception e) {\n+            log.error(\"Unable to parse address book\", e);\n+        }\n+    }\n+\n+    @Override\n+    public AddressBook getCurrent() {\n+        Instant now = Instant.now();\n+        long consensus_timestamp = Utility.convertToNanos(Instant.now().getEpochSecond(), now.getNano());\n+        Optional<AddressBook> optionalAddressBook = addressBookRepository\n+                .findLatestAddressBook(consensus_timestamp, ADDRESS_BOOK_102_ENTITY_ID.getId());\n+\n+        if (optionalAddressBook.isPresent()) {\n+            AddressBook addressBook = optionalAddressBook.get();\n+            log.info(\"Loaded addressBook from {} with nodes ({}).\", addressBook.getStartConsensusTimestamp(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1502ba448a5b3477724480eab01e70f0551bc50"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1MjI5NA==", "bodyText": "camelCase please", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r463352294", "createdAt": "2020-07-31T01:04:30Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -0,0 +1,243 @@\n+package com.hedera.mirror.importer.addressbook;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.NodeAddressBook;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.importer.domain.AddressBook;\n+import com.hedera.mirror.importer.domain.AddressBookEntry;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.FileData;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.InvalidDatasetException;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.FileDataRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+@AllArgsConstructor\n+public class AddressBookServiceImpl implements AddressBookService {\n+    public static final EntityId ADDRESS_BOOK_101_ENTITY_ID = EntityId.of(0, 0, 101, EntityTypeEnum.FILE);\n+    public static final EntityId ADDRESS_BOOK_102_ENTITY_ID = EntityId.of(0, 0, 102, EntityTypeEnum.FILE);\n+\n+    private final AddressBookRepository addressBookRepository;\n+    private final FileDataRepository fileDataRepository;\n+\n+    @Override\n+    public void update(FileData fileData) {\n+        if (!isAddressBook(fileData.getEntityId())) {\n+            log.warn(\"Not an address book File ID. Skipping processing ...\");\n+            return;\n+        }\n+\n+        if (fileData.getFileData() == null || fileData.getFileData().length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n+        try {\n+            parse(fileData);\n+        } catch (Exception e) {\n+            log.error(\"Unable to parse address book\", e);\n+        }\n+    }\n+\n+    @Override\n+    public AddressBook getCurrent() {\n+        Instant now = Instant.now();\n+        long consensus_timestamp = Utility.convertToNanos(Instant.now().getEpochSecond(), now.getNano());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1502ba448a5b3477724480eab01e70f0551bc50"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1MzgwNA==", "bodyText": "nit: Comment could be removed if the method name was more accurately named updatePreviousAddressBook", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#discussion_r463353804", "createdAt": "2020-07-31T01:10:28Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -0,0 +1,243 @@\n+package com.hedera.mirror.importer.addressbook;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.collect.ImmutableList;\n+import com.hederahashgraph.api.proto.java.NodeAddressBook;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.importer.domain.AddressBook;\n+import com.hedera.mirror.importer.domain.AddressBookEntry;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.FileData;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.InvalidDatasetException;\n+import com.hedera.mirror.importer.repository.AddressBookRepository;\n+import com.hedera.mirror.importer.repository.FileDataRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+@AllArgsConstructor\n+public class AddressBookServiceImpl implements AddressBookService {\n+    public static final EntityId ADDRESS_BOOK_101_ENTITY_ID = EntityId.of(0, 0, 101, EntityTypeEnum.FILE);\n+    public static final EntityId ADDRESS_BOOK_102_ENTITY_ID = EntityId.of(0, 0, 102, EntityTypeEnum.FILE);\n+\n+    private final AddressBookRepository addressBookRepository;\n+    private final FileDataRepository fileDataRepository;\n+\n+    @Override\n+    public void update(FileData fileData) {\n+        if (!isAddressBook(fileData.getEntityId())) {\n+            log.warn(\"Not an address book File ID. Skipping processing ...\");\n+            return;\n+        }\n+\n+        if (fileData.getFileData() == null || fileData.getFileData().length == 0) {\n+            log.warn(\"Byte array contents were empty. Skipping processing ...\");\n+            return;\n+        }\n+\n+        try {\n+            parse(fileData);\n+        } catch (Exception e) {\n+            log.error(\"Unable to parse address book\", e);\n+        }\n+    }\n+\n+    @Override\n+    public AddressBook getCurrent() {\n+        Instant now = Instant.now();\n+        long consensus_timestamp = Utility.convertToNanos(Instant.now().getEpochSecond(), now.getNano());\n+        Optional<AddressBook> optionalAddressBook = addressBookRepository\n+                .findLatestAddressBook(consensus_timestamp, ADDRESS_BOOK_102_ENTITY_ID.getId());\n+\n+        if (optionalAddressBook.isPresent()) {\n+            AddressBook addressBook = optionalAddressBook.get();\n+            log.info(\"Loaded addressBook from {} with nodes ({}).\", addressBook.getStartConsensusTimestamp(),\n+                    addressBook.getNodeSet());\n+            return addressBook;\n+        }\n+\n+        log.warn(\"No addressBooks before {} were found.\", consensus_timestamp);\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean isAddressBook(EntityId entityId) {\n+        return ADDRESS_BOOK_101_ENTITY_ID.equals(entityId) || ADDRESS_BOOK_102_ENTITY_ID.equals(entityId);\n+    }\n+\n+    /**\n+     * find last fileData for given entityId where operation was create/update using consensusTimestamp find all\n+     * fileData since  that time for given entityId concatenate all binary data in order and attempt to parse if\n+     * successful save\n+     *\n+     * @param fileData file data with timestamp, contents, entity type and transactions type for parsing\n+     * @return Parsed addressbook object if valid. Null otherwise.\n+     * @throws Exception\n+     */\n+    private void parse(FileData fileData) {\n+        byte[] addressBookBytes = null;\n+        if (fileData.transactionTypeIsAppend()) {\n+            // concatenate bytes from partial address book file data in db\n+            addressBookBytes = combinePreviousFileDataContents(fileData);\n+        } else {\n+            addressBookBytes = fileData.getFileData();\n+        }\n+\n+        // store fileData information\n+        fileData = fileDataRepository.save(fileData);\n+\n+        AddressBook addressBook = buildAddressBook(addressBookBytes, fileData.getConsensusTimestamp(), fileData\n+                .getEntityId());\n+        if (addressBook != null) {\n+            addressBook = addressBookRepository.save(addressBook);\n+            log.info(\"Saved new address book to db: {}\", addressBook);\n+\n+            // update previous addressBook", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1502ba448a5b3477724480eab01e70f0551bc50"}, "originalPosition": 125}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "03cff55aa63d77a2f4387b411b72d2fea645551a", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/03cff55aa63d77a2f4387b411b72d2fea645551a", "committedDate": "2020-07-31T02:53:00Z", "message": "Addressed final feedback\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4ODkxNDM4", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/894#pullrequestreview-458891438", "createdAt": "2020-07-31T03:11:25Z", "commit": {"oid": "03cff55aa63d77a2f4387b411b72d2fea645551a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3013, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}