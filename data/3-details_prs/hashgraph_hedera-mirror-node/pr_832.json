{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM0OTIwNzA4", "number": 832, "title": "Events downloader", "bodyText": "Detailed description:\n\nAdd EventFileDownloader and EventFileReaderImpl to dowload and verify event stream files\nRefactor AbstractDownloaderTest and add AbstractLinkedStreamDownloaderTest so test cases can be shared between 3 downloaders\nAdd sample event stream files for testing\n\nWhich issue(s) this PR fixes:\nFixes #811\nSpecial notes for your reviewer:\nPrevious events code for ref: a809295\nChecklist\n\n Documentation added\n Tests updated", "createdAt": "2020-06-16T01:35:51Z", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832", "merged": true, "mergeCommit": {"oid": "398169952b6ebd8a14ffc856faaaf633cb633c69"}, "closed": true, "closedAt": "2020-07-16T20:00:39Z", "author": {"login": "apeksharma"}, "timelineItems": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcrrDJjgH2gAyNDM0OTIwNzA4OjE4NWM0NTY0N2E3OTNhNmE0NzczM2VhY2FhODRmMGM0OTEwMjFhMjA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc1kohtgFqTQ1MDE2MzQ1MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "185c45647a793a6a47733eacaa84f0c491021a20", "author": {"user": {"login": "apeksharma", "name": "Apekshit Sharma"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/185c45647a793a6a47733eacaa84f0c491021a20", "committedDate": "2020-06-16T01:34:11Z", "message": "Events downloader\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTk3NzI1", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#pullrequestreview-431997725", "createdAt": "2020-06-17T01:29:21Z", "commit": {"oid": "977e0df2ca46a0e04ef30cdc56bd2aead9d6a42c"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwMToyOToyMlrOGkyg-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwMToyOTo1MFrOGkyhgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIyOTU2Mw==", "bodyText": "moved tests from RecordFileDownloaderTest to here.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r441229563", "createdAt": "2020-06-17T01:29:22Z", "author": {"login": "apeksharma"}, "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/downloader/AbstractDownloaderTest.java", "diffHunk": "@@ -153,31 +160,44 @@ protected void assertValidFiles(List<String> filenames) throws Exception {\n                 .containsAll(filenames);\n     }\n \n-    protected void overwriteOnDownloadHelper(String fileName1, String fileName2, ApplicationStatusCode key)\n-            throws Exception {\n+    protected void testMaxDownloadItemsReached(String filename) throws Exception {\n         fileCopier.copy();\n         downloader.download();\n-        verify(applicationStatusRepository).updateStatusValue(key, fileName1);\n-        verify(applicationStatusRepository).updateStatusValue(key, fileName2);\n-        assertValidFiles(List.of(fileName1, fileName2));\n+        assertValidFiles(List.of(filename));\n+    }\n \n-        reset(applicationStatusRepository);\n-        // Corrupt the downloaded signatures to test that they get overwritten by good ones on re-download.\n-        Files.walk(downloaderProperties.getSignaturesPath()).filter(this::isSigFile)\n-                .forEach(AbstractDownloaderTest::corruptFile);\n-        // fileName1 will be used to calculate marker for list request. mockS3 also returns back the marker in the\n-        // results. This is unlike AWS S3 which does not return back the marker.\n-        doReturn(fileName1).when(applicationStatusRepository).findByStatusCode(key);\n+    @Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "977e0df2ca46a0e04ef30cdc56bd2aead9d6a42c"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIyOTY5Nw==", "bodyText": "moved here from RecordFileDownloaderTest", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r441229697", "createdAt": "2020-06-17T01:29:50Z", "author": {"login": "apeksharma"}, "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/downloader/AbstractLinkedStreamDownloaderTest.java", "diffHunk": "@@ -0,0 +1,60 @@\n+package com.hedera.mirror.importer.downloader;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static org.mockito.Mockito.doReturn;\n+\n+import java.time.Instant;\n+import java.util.List;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+// Common tests for streams (record and events) which are linked by previous file's hash.\n+@ExtendWith(MockitoExtension.class)\n+public abstract class AbstractLinkedStreamDownloaderTest extends AbstractDownloaderTest {\n+\n+    @Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "977e0df2ca46a0e04ef30cdc56bd2aead9d6a42c"}, "originalPosition": 36}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684", "author": {"user": {"login": "apeksharma", "name": "Apekshit Sharma"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/e3ebb26716b48396be28c17d9e60d415a8a32684", "committedDate": "2020-06-17T23:36:34Z", "message": "use swirlds jar\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "977e0df2ca46a0e04ef30cdc56bd2aead9d6a42c", "author": {"user": {"login": "apeksharma", "name": "Apekshit Sharma"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/977e0df2ca46a0e04ef30cdc56bd2aead9d6a42c", "committedDate": "2020-06-17T01:19:34Z", "message": "use swirlds jar\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>"}, "afterCommit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684", "author": {"user": {"login": "apeksharma", "name": "Apekshit Sharma"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/e3ebb26716b48396be28c17d9e60d415a8a32684", "committedDate": "2020-06-17T23:36:34Z", "message": "use swirlds jar\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0NjA3ODEz", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#pullrequestreview-434607813", "createdAt": "2020-06-22T05:14:26Z", "commit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwNToxNDoyNlrOGmyJYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwNTo0NDowMFrOGmykvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMyMDY3NA==", "bodyText": "nit: Logic used twice. Just set a boolean with the value 1st time and use it in your if statements", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r443320674", "createdAt": "2020-06-22T05:14:26Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/filedecoder/EventsFileDecoder.java", "diffHunk": "@@ -0,0 +1,275 @@\n+package com.hedera.mirror.importer.filedecoder;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static com.hedera.mirror.importer.util.Utility.readBytes;\n+import static com.hedera.mirror.importer.util.Utility.readInt;\n+\n+import com.swirlds.common.Transaction;\n+import com.swirlds.common.crypto.Signature;\n+import java.io.DataInputStream;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.security.MessageDigest;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.codec.binary.Hex;\n+\n+import com.hedera.mirror.importer.domain.EventFile;\n+import com.hedera.mirror.importer.domain.EventItem;\n+import com.hedera.mirror.importer.exception.HashMismatchException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+public class EventsFileDecoder {\n+    public static final String HASH_ALGORITHM = \"SHA-384\";\n+    public static final byte EVENT_TYPE_PREV_HASH = 1;       // next 48 bytes are hash384 or previous files\n+    public static final byte EVENT_STREAM_FILE_VERSION_LEGACY = 2;\n+    public static final byte EVENT_STREAM_VERSION = 2;\n+    public static final byte EVENT_STREAM_FILE_VERSION_CURRENT = 3;\n+    public static final byte EVENT_STREAM_START_NO_TRANS_WITH_VERSION = 0x5b;\n+    public static final byte EVENT_STREAM_START_WITH_VERSION = 0x5a;\n+    public static final byte EVENT_COMM_EVENT_LAST = 0x46;\n+\n+    /**\n+     * Decodes event stream file.\n+\n+     * @param filePath path to event file\n+     * @param expectedPrevFileHash expected previous file's hash in current file. Throws {@link HashMismatchException}\n+     *                             on mismatch\n+     * @param verifyHashAfter previous file's hash mismatch is ignored if file is from before this time\n+     * @param eventItemConsumer if not null, consumer is invoked for each event in the file\n+     */\n+    public static EventFile decode(String filePath, String expectedPrevFileHash, Instant verifyHashAfter,\n+                                   Consumer<EventItem> eventItemConsumer) {\n+        EventFile eventFile = new EventFile();\n+        eventFile.setName(filePath);\n+        String fileName = Utility.getFileName(filePath);\n+\n+        try (DataInputStream dis = new DataInputStream(new FileInputStream(filePath))) {\n+            // MessageDigest for getting the file Hash\n+            // suppose file[i] = p[i] || h[i] || c[i];\n+            // p[i] denotes the bytes before previousFileHash;\n+            // h[i] denotes the hash of file i - 1, i.e., previousFileHash;\n+            // c[i] denotes the bytes after previousFileHash;\n+            // '||' means concatenation\n+            // for Version2, h[i + 1] = hash(p[i] || h[i] || c[i]);\n+            // for Version3, h[i + 1] = hash(p[i] || h[i] || hash(c[i]))\n+            MessageDigest md = MessageDigest.getInstance(HASH_ALGORITHM);\n+\n+            int fileVersion = readInt(dis, md);\n+            if (fileVersion < EVENT_STREAM_FILE_VERSION_LEGACY) {\n+                throw new IllegalArgumentException(\"Invalid event stream file version \" + fileVersion);\n+            }\n+            eventFile.setFileVersion(fileVersion);\n+\n+            MessageDigest mdForContent = md;\n+            if (fileVersion >= EVENT_STREAM_FILE_VERSION_CURRENT) {\n+                // For calculating hash(c[i]) separately if version >= 3\n+                mdForContent = MessageDigest.getInstance(HASH_ALGORITHM);\n+            }\n+            while (dis.available() != 0) {\n+                byte typeDelimiter = dis.readByte();\n+                EventItem eventItem;\n+                switch (typeDelimiter) {\n+                    case EVENT_TYPE_PREV_HASH:\n+                        md.update(typeDelimiter);\n+                        byte[] readPrevFileHash = readBytes(dis, 48, md);\n+                        eventFile.setPreviousHash(Hex.encodeHexString(readPrevFileHash));\n+                        Instant fileInstant = Instant.parse(fileName.replaceAll(\".evts\", \"\").replaceAll(\"_\", \":\"));\n+\n+                        if (!Utility.verifyHashChain(eventFile.getPreviousHash(), expectedPrevFileHash,\n+                                verifyHashAfter, fileInstant)) {\n+                            throw new HashMismatchException(\"Hash mismatch for file \" + fileName);\n+                        }\n+                        break;\n+\n+                    case EVENT_STREAM_START_NO_TRANS_WITH_VERSION:\n+                        mdForContent.update(typeDelimiter);\n+                        eventItem = loadEvent(dis, mdForContent, false);\n+                        if (eventItemConsumer != null) {\n+                            eventItemConsumer.accept(eventItem);\n+                        }\n+                        break;\n+\n+                    case EVENT_STREAM_START_WITH_VERSION:\n+                        mdForContent.update(typeDelimiter);\n+                        eventItem = loadEvent(dis, mdForContent, true);\n+                        if (eventItemConsumer != null) {\n+                            eventItemConsumer.accept(eventItem);\n+                        }\n+                        break;\n+\n+                    default:\n+                        throw new IllegalArgumentException(String.format(\n+                                \"Unknown event file delimiter %s for file %s\", typeDelimiter, fileName));\n+                }\n+            }\n+            if (fileVersion >= EVENT_STREAM_FILE_VERSION_CURRENT) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMyMjI3MA==", "bodyText": "Isn't this supposed to be done once per file? If so then just do it once by moving this right after the fileName variable is assigned a value.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r443322270", "createdAt": "2020-06-22T05:21:32Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/filedecoder/EventsFileDecoder.java", "diffHunk": "@@ -0,0 +1,275 @@\n+package com.hedera.mirror.importer.filedecoder;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static com.hedera.mirror.importer.util.Utility.readBytes;\n+import static com.hedera.mirror.importer.util.Utility.readInt;\n+\n+import com.swirlds.common.Transaction;\n+import com.swirlds.common.crypto.Signature;\n+import java.io.DataInputStream;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.security.MessageDigest;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.codec.binary.Hex;\n+\n+import com.hedera.mirror.importer.domain.EventFile;\n+import com.hedera.mirror.importer.domain.EventItem;\n+import com.hedera.mirror.importer.exception.HashMismatchException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+public class EventsFileDecoder {\n+    public static final String HASH_ALGORITHM = \"SHA-384\";\n+    public static final byte EVENT_TYPE_PREV_HASH = 1;       // next 48 bytes are hash384 or previous files\n+    public static final byte EVENT_STREAM_FILE_VERSION_LEGACY = 2;\n+    public static final byte EVENT_STREAM_VERSION = 2;\n+    public static final byte EVENT_STREAM_FILE_VERSION_CURRENT = 3;\n+    public static final byte EVENT_STREAM_START_NO_TRANS_WITH_VERSION = 0x5b;\n+    public static final byte EVENT_STREAM_START_WITH_VERSION = 0x5a;\n+    public static final byte EVENT_COMM_EVENT_LAST = 0x46;\n+\n+    /**\n+     * Decodes event stream file.\n+\n+     * @param filePath path to event file\n+     * @param expectedPrevFileHash expected previous file's hash in current file. Throws {@link HashMismatchException}\n+     *                             on mismatch\n+     * @param verifyHashAfter previous file's hash mismatch is ignored if file is from before this time\n+     * @param eventItemConsumer if not null, consumer is invoked for each event in the file\n+     */\n+    public static EventFile decode(String filePath, String expectedPrevFileHash, Instant verifyHashAfter,\n+                                   Consumer<EventItem> eventItemConsumer) {\n+        EventFile eventFile = new EventFile();\n+        eventFile.setName(filePath);\n+        String fileName = Utility.getFileName(filePath);\n+\n+        try (DataInputStream dis = new DataInputStream(new FileInputStream(filePath))) {\n+            // MessageDigest for getting the file Hash\n+            // suppose file[i] = p[i] || h[i] || c[i];\n+            // p[i] denotes the bytes before previousFileHash;\n+            // h[i] denotes the hash of file i - 1, i.e., previousFileHash;\n+            // c[i] denotes the bytes after previousFileHash;\n+            // '||' means concatenation\n+            // for Version2, h[i + 1] = hash(p[i] || h[i] || c[i]);\n+            // for Version3, h[i + 1] = hash(p[i] || h[i] || hash(c[i]))\n+            MessageDigest md = MessageDigest.getInstance(HASH_ALGORITHM);\n+\n+            int fileVersion = readInt(dis, md);\n+            if (fileVersion < EVENT_STREAM_FILE_VERSION_LEGACY) {\n+                throw new IllegalArgumentException(\"Invalid event stream file version \" + fileVersion);\n+            }\n+            eventFile.setFileVersion(fileVersion);\n+\n+            MessageDigest mdForContent = md;\n+            if (fileVersion >= EVENT_STREAM_FILE_VERSION_CURRENT) {\n+                // For calculating hash(c[i]) separately if version >= 3\n+                mdForContent = MessageDigest.getInstance(HASH_ALGORITHM);\n+            }\n+            while (dis.available() != 0) {\n+                byte typeDelimiter = dis.readByte();\n+                EventItem eventItem;\n+                switch (typeDelimiter) {\n+                    case EVENT_TYPE_PREV_HASH:\n+                        md.update(typeDelimiter);\n+                        byte[] readPrevFileHash = readBytes(dis, 48, md);\n+                        eventFile.setPreviousHash(Hex.encodeHexString(readPrevFileHash));\n+                        Instant fileInstant = Instant.parse(fileName.replaceAll(\".evts\", \"\").replaceAll(\"_\", \":\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMyNDg0NA==", "bodyText": "nit: Seems like the read order is important. You might want to put a comment to state this and or reference the actual order so future updates have this in mind.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r443324844", "createdAt": "2020-06-22T05:32:13Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/filedecoder/EventsFileDecoder.java", "diffHunk": "@@ -0,0 +1,275 @@\n+package com.hedera.mirror.importer.filedecoder;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static com.hedera.mirror.importer.util.Utility.readBytes;\n+import static com.hedera.mirror.importer.util.Utility.readInt;\n+\n+import com.swirlds.common.Transaction;\n+import com.swirlds.common.crypto.Signature;\n+import java.io.DataInputStream;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.security.MessageDigest;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.codec.binary.Hex;\n+\n+import com.hedera.mirror.importer.domain.EventFile;\n+import com.hedera.mirror.importer.domain.EventItem;\n+import com.hedera.mirror.importer.exception.HashMismatchException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+public class EventsFileDecoder {\n+    public static final String HASH_ALGORITHM = \"SHA-384\";\n+    public static final byte EVENT_TYPE_PREV_HASH = 1;       // next 48 bytes are hash384 or previous files\n+    public static final byte EVENT_STREAM_FILE_VERSION_LEGACY = 2;\n+    public static final byte EVENT_STREAM_VERSION = 2;\n+    public static final byte EVENT_STREAM_FILE_VERSION_CURRENT = 3;\n+    public static final byte EVENT_STREAM_START_NO_TRANS_WITH_VERSION = 0x5b;\n+    public static final byte EVENT_STREAM_START_WITH_VERSION = 0x5a;\n+    public static final byte EVENT_COMM_EVENT_LAST = 0x46;\n+\n+    /**\n+     * Decodes event stream file.\n+\n+     * @param filePath path to event file\n+     * @param expectedPrevFileHash expected previous file's hash in current file. Throws {@link HashMismatchException}\n+     *                             on mismatch\n+     * @param verifyHashAfter previous file's hash mismatch is ignored if file is from before this time\n+     * @param eventItemConsumer if not null, consumer is invoked for each event in the file\n+     */\n+    public static EventFile decode(String filePath, String expectedPrevFileHash, Instant verifyHashAfter,\n+                                   Consumer<EventItem> eventItemConsumer) {\n+        EventFile eventFile = new EventFile();\n+        eventFile.setName(filePath);\n+        String fileName = Utility.getFileName(filePath);\n+\n+        try (DataInputStream dis = new DataInputStream(new FileInputStream(filePath))) {\n+            // MessageDigest for getting the file Hash\n+            // suppose file[i] = p[i] || h[i] || c[i];\n+            // p[i] denotes the bytes before previousFileHash;\n+            // h[i] denotes the hash of file i - 1, i.e., previousFileHash;\n+            // c[i] denotes the bytes after previousFileHash;\n+            // '||' means concatenation\n+            // for Version2, h[i + 1] = hash(p[i] || h[i] || c[i]);\n+            // for Version3, h[i + 1] = hash(p[i] || h[i] || hash(c[i]))\n+            MessageDigest md = MessageDigest.getInstance(HASH_ALGORITHM);\n+\n+            int fileVersion = readInt(dis, md);\n+            if (fileVersion < EVENT_STREAM_FILE_VERSION_LEGACY) {\n+                throw new IllegalArgumentException(\"Invalid event stream file version \" + fileVersion);\n+            }\n+            eventFile.setFileVersion(fileVersion);\n+\n+            MessageDigest mdForContent = md;\n+            if (fileVersion >= EVENT_STREAM_FILE_VERSION_CURRENT) {\n+                // For calculating hash(c[i]) separately if version >= 3\n+                mdForContent = MessageDigest.getInstance(HASH_ALGORITHM);\n+            }\n+            while (dis.available() != 0) {\n+                byte typeDelimiter = dis.readByte();\n+                EventItem eventItem;\n+                switch (typeDelimiter) {\n+                    case EVENT_TYPE_PREV_HASH:\n+                        md.update(typeDelimiter);\n+                        byte[] readPrevFileHash = readBytes(dis, 48, md);\n+                        eventFile.setPreviousHash(Hex.encodeHexString(readPrevFileHash));\n+                        Instant fileInstant = Instant.parse(fileName.replaceAll(\".evts\", \"\").replaceAll(\"_\", \":\"));\n+\n+                        if (!Utility.verifyHashChain(eventFile.getPreviousHash(), expectedPrevFileHash,\n+                                verifyHashAfter, fileInstant)) {\n+                            throw new HashMismatchException(\"Hash mismatch for file \" + fileName);\n+                        }\n+                        break;\n+\n+                    case EVENT_STREAM_START_NO_TRANS_WITH_VERSION:\n+                        mdForContent.update(typeDelimiter);\n+                        eventItem = loadEvent(dis, mdForContent, false);\n+                        if (eventItemConsumer != null) {\n+                            eventItemConsumer.accept(eventItem);\n+                        }\n+                        break;\n+\n+                    case EVENT_STREAM_START_WITH_VERSION:\n+                        mdForContent.update(typeDelimiter);\n+                        eventItem = loadEvent(dis, mdForContent, true);\n+                        if (eventItemConsumer != null) {\n+                            eventItemConsumer.accept(eventItem);\n+                        }\n+                        break;\n+\n+                    default:\n+                        throw new IllegalArgumentException(String.format(\n+                                \"Unknown event file delimiter %s for file %s\", typeDelimiter, fileName));\n+                }\n+            }\n+            if (fileVersion >= EVENT_STREAM_FILE_VERSION_CURRENT) {\n+                md.update(mdForContent.digest());\n+            }\n+            if (eventFile.getPreviousHash() == null) {\n+                throw new IllegalArgumentException(\"previous hash is null in file \" + fileName);\n+            }\n+            eventFile.setFileHash(Hex.encodeHexString(md.digest()));\n+            log.trace(\"Calculated file hash for the event file {}\", eventFile.getFileHash());\n+            return eventFile;\n+        } catch (Exception e) {\n+            throw new IllegalArgumentException(\"Error parsing bad event file \" + fileName, e);\n+        }\n+    }\n+\n+    private static EventItem loadEvent(DataInputStream dis, MessageDigest md, boolean hasTransactions)\n+            throws IOException {\n+        EventItem eventItem = new EventItem();\n+        int version = readInt(dis, md);\n+        if (version != EVENT_STREAM_VERSION) {\n+            throw new IllegalArgumentException(\"Invalid EventStream format version : \" + version);\n+        }\n+\n+        eventItem.setCreatorId(readLong(dis, md));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMyNjE2NQ==", "bodyText": "nit: All the checkSum values used when calling readAndValidateChecksum () should be private class variables.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r443326165", "createdAt": "2020-06-22T05:37:48Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/filedecoder/EventsFileDecoder.java", "diffHunk": "@@ -0,0 +1,275 @@\n+package com.hedera.mirror.importer.filedecoder;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static com.hedera.mirror.importer.util.Utility.readBytes;\n+import static com.hedera.mirror.importer.util.Utility.readInt;\n+\n+import com.swirlds.common.Transaction;\n+import com.swirlds.common.crypto.Signature;\n+import java.io.DataInputStream;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.security.MessageDigest;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.codec.binary.Hex;\n+\n+import com.hedera.mirror.importer.domain.EventFile;\n+import com.hedera.mirror.importer.domain.EventItem;\n+import com.hedera.mirror.importer.exception.HashMismatchException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+public class EventsFileDecoder {\n+    public static final String HASH_ALGORITHM = \"SHA-384\";\n+    public static final byte EVENT_TYPE_PREV_HASH = 1;       // next 48 bytes are hash384 or previous files\n+    public static final byte EVENT_STREAM_FILE_VERSION_LEGACY = 2;\n+    public static final byte EVENT_STREAM_VERSION = 2;\n+    public static final byte EVENT_STREAM_FILE_VERSION_CURRENT = 3;\n+    public static final byte EVENT_STREAM_START_NO_TRANS_WITH_VERSION = 0x5b;\n+    public static final byte EVENT_STREAM_START_WITH_VERSION = 0x5a;\n+    public static final byte EVENT_COMM_EVENT_LAST = 0x46;\n+\n+    /**\n+     * Decodes event stream file.\n+\n+     * @param filePath path to event file\n+     * @param expectedPrevFileHash expected previous file's hash in current file. Throws {@link HashMismatchException}\n+     *                             on mismatch\n+     * @param verifyHashAfter previous file's hash mismatch is ignored if file is from before this time\n+     * @param eventItemConsumer if not null, consumer is invoked for each event in the file\n+     */\n+    public static EventFile decode(String filePath, String expectedPrevFileHash, Instant verifyHashAfter,\n+                                   Consumer<EventItem> eventItemConsumer) {\n+        EventFile eventFile = new EventFile();\n+        eventFile.setName(filePath);\n+        String fileName = Utility.getFileName(filePath);\n+\n+        try (DataInputStream dis = new DataInputStream(new FileInputStream(filePath))) {\n+            // MessageDigest for getting the file Hash\n+            // suppose file[i] = p[i] || h[i] || c[i];\n+            // p[i] denotes the bytes before previousFileHash;\n+            // h[i] denotes the hash of file i - 1, i.e., previousFileHash;\n+            // c[i] denotes the bytes after previousFileHash;\n+            // '||' means concatenation\n+            // for Version2, h[i + 1] = hash(p[i] || h[i] || c[i]);\n+            // for Version3, h[i + 1] = hash(p[i] || h[i] || hash(c[i]))\n+            MessageDigest md = MessageDigest.getInstance(HASH_ALGORITHM);\n+\n+            int fileVersion = readInt(dis, md);\n+            if (fileVersion < EVENT_STREAM_FILE_VERSION_LEGACY) {\n+                throw new IllegalArgumentException(\"Invalid event stream file version \" + fileVersion);\n+            }\n+            eventFile.setFileVersion(fileVersion);\n+\n+            MessageDigest mdForContent = md;\n+            if (fileVersion >= EVENT_STREAM_FILE_VERSION_CURRENT) {\n+                // For calculating hash(c[i]) separately if version >= 3\n+                mdForContent = MessageDigest.getInstance(HASH_ALGORITHM);\n+            }\n+            while (dis.available() != 0) {\n+                byte typeDelimiter = dis.readByte();\n+                EventItem eventItem;\n+                switch (typeDelimiter) {\n+                    case EVENT_TYPE_PREV_HASH:\n+                        md.update(typeDelimiter);\n+                        byte[] readPrevFileHash = readBytes(dis, 48, md);\n+                        eventFile.setPreviousHash(Hex.encodeHexString(readPrevFileHash));\n+                        Instant fileInstant = Instant.parse(fileName.replaceAll(\".evts\", \"\").replaceAll(\"_\", \":\"));\n+\n+                        if (!Utility.verifyHashChain(eventFile.getPreviousHash(), expectedPrevFileHash,\n+                                verifyHashAfter, fileInstant)) {\n+                            throw new HashMismatchException(\"Hash mismatch for file \" + fileName);\n+                        }\n+                        break;\n+\n+                    case EVENT_STREAM_START_NO_TRANS_WITH_VERSION:\n+                        mdForContent.update(typeDelimiter);\n+                        eventItem = loadEvent(dis, mdForContent, false);\n+                        if (eventItemConsumer != null) {\n+                            eventItemConsumer.accept(eventItem);\n+                        }\n+                        break;\n+\n+                    case EVENT_STREAM_START_WITH_VERSION:\n+                        mdForContent.update(typeDelimiter);\n+                        eventItem = loadEvent(dis, mdForContent, true);\n+                        if (eventItemConsumer != null) {\n+                            eventItemConsumer.accept(eventItem);\n+                        }\n+                        break;\n+\n+                    default:\n+                        throw new IllegalArgumentException(String.format(\n+                                \"Unknown event file delimiter %s for file %s\", typeDelimiter, fileName));\n+                }\n+            }\n+            if (fileVersion >= EVENT_STREAM_FILE_VERSION_CURRENT) {\n+                md.update(mdForContent.digest());\n+            }\n+            if (eventFile.getPreviousHash() == null) {\n+                throw new IllegalArgumentException(\"previous hash is null in file \" + fileName);\n+            }\n+            eventFile.setFileHash(Hex.encodeHexString(md.digest()));\n+            log.trace(\"Calculated file hash for the event file {}\", eventFile.getFileHash());\n+            return eventFile;\n+        } catch (Exception e) {\n+            throw new IllegalArgumentException(\"Error parsing bad event file \" + fileName, e);\n+        }\n+    }\n+\n+    private static EventItem loadEvent(DataInputStream dis, MessageDigest md, boolean hasTransactions)\n+            throws IOException {\n+        EventItem eventItem = new EventItem();\n+        int version = readInt(dis, md);\n+        if (version != EVENT_STREAM_VERSION) {\n+            throw new IllegalArgumentException(\"Invalid EventStream format version : \" + version);\n+        }\n+\n+        eventItem.setCreatorId(readLong(dis, md));\n+        eventItem.setCreatorSeq(readLong(dis, md));\n+        eventItem.setOtherId(readLong(dis, md));\n+        eventItem.setOtherSeq(readLong(dis, md));\n+        eventItem.setSelfParentGen(readLong(dis, md));\n+        eventItem.setOtherParentGen(readLong(dis, md));\n+        eventItem.setSelfParentHash(readBytesWithChecksum(dis, md, true));\n+        eventItem.setOtherParentHash(readBytesWithChecksum(dis, md, true));\n+        if (hasTransactions) {\n+            eventItem.setTransactions(readTransactions(dis, md));\n+        }\n+        eventItem.setTimeCreated(readInstant(dis, md));\n+        eventItem.setSignature(readBytesWithChecksum(dis, md, false));\n+\n+        byte eventEndMarker = dis.readByte();\n+        if (eventEndMarker != EVENT_COMM_EVENT_LAST) {\n+            throw new IllegalArgumentException(\"Invalid event end marker : \" + eventEndMarker);\n+        }\n+        md.update(EVENT_COMM_EVENT_LAST);\n+\n+        eventItem.setHash(readBytesWithChecksum(dis, md, false));  // event's hash\n+        eventItem.setConsensusTimeStamp(readInstant(dis, md));\n+        eventItem.setConsensusOrder(readLong(dis, md));\n+        if (log.isTraceEnabled()) {\n+            log.trace(\"Event: {}\", eventItem);\n+        }\n+        return eventItem;\n+    }\n+\n+    /**\n+     * Read all {@link Transaction}s from the {@link DataInputStream}.\n+     *\n+     * @throws IOException  if the internal checksum cannot be validated, or if any error occurs when reading the file\n+     */\n+    public static List<Transaction> readTransactions(DataInputStream dis, MessageDigest md) throws IOException {\n+        int numTransactions = readInt(dis, md);\n+        if (numTransactions < 0) {\n+            throw new IllegalArgumentException(\"Invalid number of transactions: \" + numTransactions);\n+        }\n+        readAndValidateChecksum(dis, 1873 - numTransactions, md);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMyNzY3Nw==", "bodyText": "Q: Shouldn't these `read?' methods be in the Utility class alongside the other file read methods?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r443327677", "createdAt": "2020-06-22T05:44:00Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/filedecoder/EventsFileDecoder.java", "diffHunk": "@@ -0,0 +1,275 @@\n+package com.hedera.mirror.importer.filedecoder;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static com.hedera.mirror.importer.util.Utility.readBytes;\n+import static com.hedera.mirror.importer.util.Utility.readInt;\n+\n+import com.swirlds.common.Transaction;\n+import com.swirlds.common.crypto.Signature;\n+import java.io.DataInputStream;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.security.MessageDigest;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.codec.binary.Hex;\n+\n+import com.hedera.mirror.importer.domain.EventFile;\n+import com.hedera.mirror.importer.domain.EventItem;\n+import com.hedera.mirror.importer.exception.HashMismatchException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+public class EventsFileDecoder {\n+    public static final String HASH_ALGORITHM = \"SHA-384\";\n+    public static final byte EVENT_TYPE_PREV_HASH = 1;       // next 48 bytes are hash384 or previous files\n+    public static final byte EVENT_STREAM_FILE_VERSION_LEGACY = 2;\n+    public static final byte EVENT_STREAM_VERSION = 2;\n+    public static final byte EVENT_STREAM_FILE_VERSION_CURRENT = 3;\n+    public static final byte EVENT_STREAM_START_NO_TRANS_WITH_VERSION = 0x5b;\n+    public static final byte EVENT_STREAM_START_WITH_VERSION = 0x5a;\n+    public static final byte EVENT_COMM_EVENT_LAST = 0x46;\n+\n+    /**\n+     * Decodes event stream file.\n+\n+     * @param filePath path to event file\n+     * @param expectedPrevFileHash expected previous file's hash in current file. Throws {@link HashMismatchException}\n+     *                             on mismatch\n+     * @param verifyHashAfter previous file's hash mismatch is ignored if file is from before this time\n+     * @param eventItemConsumer if not null, consumer is invoked for each event in the file\n+     */\n+    public static EventFile decode(String filePath, String expectedPrevFileHash, Instant verifyHashAfter,\n+                                   Consumer<EventItem> eventItemConsumer) {\n+        EventFile eventFile = new EventFile();\n+        eventFile.setName(filePath);\n+        String fileName = Utility.getFileName(filePath);\n+\n+        try (DataInputStream dis = new DataInputStream(new FileInputStream(filePath))) {\n+            // MessageDigest for getting the file Hash\n+            // suppose file[i] = p[i] || h[i] || c[i];\n+            // p[i] denotes the bytes before previousFileHash;\n+            // h[i] denotes the hash of file i - 1, i.e., previousFileHash;\n+            // c[i] denotes the bytes after previousFileHash;\n+            // '||' means concatenation\n+            // for Version2, h[i + 1] = hash(p[i] || h[i] || c[i]);\n+            // for Version3, h[i + 1] = hash(p[i] || h[i] || hash(c[i]))\n+            MessageDigest md = MessageDigest.getInstance(HASH_ALGORITHM);\n+\n+            int fileVersion = readInt(dis, md);\n+            if (fileVersion < EVENT_STREAM_FILE_VERSION_LEGACY) {\n+                throw new IllegalArgumentException(\"Invalid event stream file version \" + fileVersion);\n+            }\n+            eventFile.setFileVersion(fileVersion);\n+\n+            MessageDigest mdForContent = md;\n+            if (fileVersion >= EVENT_STREAM_FILE_VERSION_CURRENT) {\n+                // For calculating hash(c[i]) separately if version >= 3\n+                mdForContent = MessageDigest.getInstance(HASH_ALGORITHM);\n+            }\n+            while (dis.available() != 0) {\n+                byte typeDelimiter = dis.readByte();\n+                EventItem eventItem;\n+                switch (typeDelimiter) {\n+                    case EVENT_TYPE_PREV_HASH:\n+                        md.update(typeDelimiter);\n+                        byte[] readPrevFileHash = readBytes(dis, 48, md);\n+                        eventFile.setPreviousHash(Hex.encodeHexString(readPrevFileHash));\n+                        Instant fileInstant = Instant.parse(fileName.replaceAll(\".evts\", \"\").replaceAll(\"_\", \":\"));\n+\n+                        if (!Utility.verifyHashChain(eventFile.getPreviousHash(), expectedPrevFileHash,\n+                                verifyHashAfter, fileInstant)) {\n+                            throw new HashMismatchException(\"Hash mismatch for file \" + fileName);\n+                        }\n+                        break;\n+\n+                    case EVENT_STREAM_START_NO_TRANS_WITH_VERSION:\n+                        mdForContent.update(typeDelimiter);\n+                        eventItem = loadEvent(dis, mdForContent, false);\n+                        if (eventItemConsumer != null) {\n+                            eventItemConsumer.accept(eventItem);\n+                        }\n+                        break;\n+\n+                    case EVENT_STREAM_START_WITH_VERSION:\n+                        mdForContent.update(typeDelimiter);\n+                        eventItem = loadEvent(dis, mdForContent, true);\n+                        if (eventItemConsumer != null) {\n+                            eventItemConsumer.accept(eventItem);\n+                        }\n+                        break;\n+\n+                    default:\n+                        throw new IllegalArgumentException(String.format(\n+                                \"Unknown event file delimiter %s for file %s\", typeDelimiter, fileName));\n+                }\n+            }\n+            if (fileVersion >= EVENT_STREAM_FILE_VERSION_CURRENT) {\n+                md.update(mdForContent.digest());\n+            }\n+            if (eventFile.getPreviousHash() == null) {\n+                throw new IllegalArgumentException(\"previous hash is null in file \" + fileName);\n+            }\n+            eventFile.setFileHash(Hex.encodeHexString(md.digest()));\n+            log.trace(\"Calculated file hash for the event file {}\", eventFile.getFileHash());\n+            return eventFile;\n+        } catch (Exception e) {\n+            throw new IllegalArgumentException(\"Error parsing bad event file \" + fileName, e);\n+        }\n+    }\n+\n+    private static EventItem loadEvent(DataInputStream dis, MessageDigest md, boolean hasTransactions)\n+            throws IOException {\n+        EventItem eventItem = new EventItem();\n+        int version = readInt(dis, md);\n+        if (version != EVENT_STREAM_VERSION) {\n+            throw new IllegalArgumentException(\"Invalid EventStream format version : \" + version);\n+        }\n+\n+        eventItem.setCreatorId(readLong(dis, md));\n+        eventItem.setCreatorSeq(readLong(dis, md));\n+        eventItem.setOtherId(readLong(dis, md));\n+        eventItem.setOtherSeq(readLong(dis, md));\n+        eventItem.setSelfParentGen(readLong(dis, md));\n+        eventItem.setOtherParentGen(readLong(dis, md));\n+        eventItem.setSelfParentHash(readBytesWithChecksum(dis, md, true));\n+        eventItem.setOtherParentHash(readBytesWithChecksum(dis, md, true));\n+        if (hasTransactions) {\n+            eventItem.setTransactions(readTransactions(dis, md));\n+        }\n+        eventItem.setTimeCreated(readInstant(dis, md));\n+        eventItem.setSignature(readBytesWithChecksum(dis, md, false));\n+\n+        byte eventEndMarker = dis.readByte();\n+        if (eventEndMarker != EVENT_COMM_EVENT_LAST) {\n+            throw new IllegalArgumentException(\"Invalid event end marker : \" + eventEndMarker);\n+        }\n+        md.update(EVENT_COMM_EVENT_LAST);\n+\n+        eventItem.setHash(readBytesWithChecksum(dis, md, false));  // event's hash\n+        eventItem.setConsensusTimeStamp(readInstant(dis, md));\n+        eventItem.setConsensusOrder(readLong(dis, md));\n+        if (log.isTraceEnabled()) {\n+            log.trace(\"Event: {}\", eventItem);\n+        }\n+        return eventItem;\n+    }\n+\n+    /**\n+     * Read all {@link Transaction}s from the {@link DataInputStream}.\n+     *\n+     * @throws IOException  if the internal checksum cannot be validated, or if any error occurs when reading the file\n+     */\n+    public static List<Transaction> readTransactions(DataInputStream dis, MessageDigest md) throws IOException {\n+        int numTransactions = readInt(dis, md);\n+        if (numTransactions < 0) {\n+            throw new IllegalArgumentException(\"Invalid number of transactions: \" + numTransactions);\n+        }\n+        readAndValidateChecksum(dis, 1873 - numTransactions, md);\n+        List<Transaction> transactions = new ArrayList<>(numTransactions);\n+        for (int i = 0; i < numTransactions; i++) {\n+            transactions.add(deserialize(dis, md));\n+        }\n+        return transactions;\n+    }\n+\n+    /**\n+     * Read single {@link Transaction} from the {@link DataInputStream}.\n+     *\n+     * @throws IOException  if the internal checksum cannot be validated, or if any error occurs when reading the file\n+     */\n+    private static Transaction deserialize(DataInputStream dis, MessageDigest md) throws IOException {\n+        int txLen = readInt(dis, md);\n+        if (txLen < 0) {\n+            throw new IllegalArgumentException(\"Invalid number of transactions: \" + txLen);\n+        }\n+        readAndValidateChecksum(dis, 277 - txLen, md);\n+        readBoolean(dis, md); // system field of transaction\n+        byte[] contents = readBytes(dis, txLen, md);\n+        Signature[] signatures = readSignatures(dis, md);\n+        return new Transaction(contents, signatures);\n+    }\n+\n+    /**\n+     * Read all {@link Signature}s from the {@link DataInputStream}.\n+     *\n+     * @throws IOException  if the internal checksum cannot be validated, or if any error occurs when reading the file\n+     */\n+    private static Signature[] readSignatures(DataInputStream dis, MessageDigest md) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684"}, "originalPosition": 221}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTgzNjE1", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#pullrequestreview-431983615", "createdAt": "2020-06-17T00:43:41Z", "commit": {"oid": "185c45647a793a6a47733eacaa84f0c491021a20"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwMDo0NzoyOVrOGkx3fQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQyMToyNToyMFrOGnRjlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxODk0MQ==", "bodyText": "Since it's new, let's name it previous_hash so we don't have to manually map the name", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r441218941", "createdAt": "2020-06-17T00:47:29Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EventFile.java", "diffHunk": "@@ -0,0 +1,44 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import javax.persistence.Column;\n+import javax.persistence.Transient;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+\n+@Data\n+@NoArgsConstructor\n+public class EventFile {\n+    private String name;\n+\n+    private Long loadStart;\n+\n+    private Long loadEnd;\n+\n+    private String fileHash;\n+\n+    @Column(name = \"prev_hash\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "185c45647a793a6a47733eacaa84f0c491021a20"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxOTY5NA==", "bodyText": "Why transient? Let's store it", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r441219694", "createdAt": "2020-06-17T00:50:28Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EventFile.java", "diffHunk": "@@ -0,0 +1,44 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import javax.persistence.Column;\n+import javax.persistence.Transient;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+\n+@Data\n+@NoArgsConstructor\n+public class EventFile {\n+    private String name;\n+\n+    private Long loadStart;\n+\n+    private Long loadEnd;\n+\n+    private String fileHash;\n+\n+    @Column(name = \"prev_hash\")\n+    private String previousHash;\n+\n+    @Transient", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "185c45647a793a6a47733eacaa84f0c491021a20"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzYwNTI3Nw==", "bodyText": "How can EventFileDownloaderTest return a rcd file?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r443605277", "createdAt": "2020-06-22T14:35:32Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/downloader/AbstractLinkedStreamDownloaderTest.java", "diffHunk": "@@ -0,0 +1,60 @@\n+package com.hedera.mirror.importer.downloader;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static org.mockito.Mockito.doReturn;\n+\n+import java.time.Instant;\n+import java.util.List;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+// Common tests for streams (record and events) which are linked by previous file's hash.\n+@ExtendWith(MockitoExtension.class)\n+public abstract class AbstractLinkedStreamDownloaderTest extends AbstractDownloaderTest {\n+\n+    @Test\n+    @DisplayName(\"Doesn't match last valid hash\")\n+    void hashMismatchWithPrevious() throws Exception {\n+        doReturn(\"2019-01-01T01:00:00.000000Z.rcd\").when(applicationStatusRepository)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzYxMjIyNQ==", "bodyText": "I think it's the other way around. The reading specific methods in Utility should move into a proper class in the same package as this file in the future.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r443612225", "createdAt": "2020-06-22T14:44:24Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/filedecoder/EventsFileDecoder.java", "diffHunk": "@@ -0,0 +1,275 @@\n+package com.hedera.mirror.importer.filedecoder;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static com.hedera.mirror.importer.util.Utility.readBytes;\n+import static com.hedera.mirror.importer.util.Utility.readInt;\n+\n+import com.swirlds.common.Transaction;\n+import com.swirlds.common.crypto.Signature;\n+import java.io.DataInputStream;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.security.MessageDigest;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.codec.binary.Hex;\n+\n+import com.hedera.mirror.importer.domain.EventFile;\n+import com.hedera.mirror.importer.domain.EventItem;\n+import com.hedera.mirror.importer.exception.HashMismatchException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+public class EventsFileDecoder {\n+    public static final String HASH_ALGORITHM = \"SHA-384\";\n+    public static final byte EVENT_TYPE_PREV_HASH = 1;       // next 48 bytes are hash384 or previous files\n+    public static final byte EVENT_STREAM_FILE_VERSION_LEGACY = 2;\n+    public static final byte EVENT_STREAM_VERSION = 2;\n+    public static final byte EVENT_STREAM_FILE_VERSION_CURRENT = 3;\n+    public static final byte EVENT_STREAM_START_NO_TRANS_WITH_VERSION = 0x5b;\n+    public static final byte EVENT_STREAM_START_WITH_VERSION = 0x5a;\n+    public static final byte EVENT_COMM_EVENT_LAST = 0x46;\n+\n+    /**\n+     * Decodes event stream file.\n+\n+     * @param filePath path to event file\n+     * @param expectedPrevFileHash expected previous file's hash in current file. Throws {@link HashMismatchException}\n+     *                             on mismatch\n+     * @param verifyHashAfter previous file's hash mismatch is ignored if file is from before this time\n+     * @param eventItemConsumer if not null, consumer is invoked for each event in the file\n+     */\n+    public static EventFile decode(String filePath, String expectedPrevFileHash, Instant verifyHashAfter,\n+                                   Consumer<EventItem> eventItemConsumer) {\n+        EventFile eventFile = new EventFile();\n+        eventFile.setName(filePath);\n+        String fileName = Utility.getFileName(filePath);\n+\n+        try (DataInputStream dis = new DataInputStream(new FileInputStream(filePath))) {\n+            // MessageDigest for getting the file Hash\n+            // suppose file[i] = p[i] || h[i] || c[i];\n+            // p[i] denotes the bytes before previousFileHash;\n+            // h[i] denotes the hash of file i - 1, i.e., previousFileHash;\n+            // c[i] denotes the bytes after previousFileHash;\n+            // '||' means concatenation\n+            // for Version2, h[i + 1] = hash(p[i] || h[i] || c[i]);\n+            // for Version3, h[i + 1] = hash(p[i] || h[i] || hash(c[i]))\n+            MessageDigest md = MessageDigest.getInstance(HASH_ALGORITHM);\n+\n+            int fileVersion = readInt(dis, md);\n+            if (fileVersion < EVENT_STREAM_FILE_VERSION_LEGACY) {\n+                throw new IllegalArgumentException(\"Invalid event stream file version \" + fileVersion);\n+            }\n+            eventFile.setFileVersion(fileVersion);\n+\n+            MessageDigest mdForContent = md;\n+            if (fileVersion >= EVENT_STREAM_FILE_VERSION_CURRENT) {\n+                // For calculating hash(c[i]) separately if version >= 3\n+                mdForContent = MessageDigest.getInstance(HASH_ALGORITHM);\n+            }\n+            while (dis.available() != 0) {\n+                byte typeDelimiter = dis.readByte();\n+                EventItem eventItem;\n+                switch (typeDelimiter) {\n+                    case EVENT_TYPE_PREV_HASH:\n+                        md.update(typeDelimiter);\n+                        byte[] readPrevFileHash = readBytes(dis, 48, md);\n+                        eventFile.setPreviousHash(Hex.encodeHexString(readPrevFileHash));\n+                        Instant fileInstant = Instant.parse(fileName.replaceAll(\".evts\", \"\").replaceAll(\"_\", \":\"));\n+\n+                        if (!Utility.verifyHashChain(eventFile.getPreviousHash(), expectedPrevFileHash,\n+                                verifyHashAfter, fileInstant)) {\n+                            throw new HashMismatchException(\"Hash mismatch for file \" + fileName);\n+                        }\n+                        break;\n+\n+                    case EVENT_STREAM_START_NO_TRANS_WITH_VERSION:\n+                        mdForContent.update(typeDelimiter);\n+                        eventItem = loadEvent(dis, mdForContent, false);\n+                        if (eventItemConsumer != null) {\n+                            eventItemConsumer.accept(eventItem);\n+                        }\n+                        break;\n+\n+                    case EVENT_STREAM_START_WITH_VERSION:\n+                        mdForContent.update(typeDelimiter);\n+                        eventItem = loadEvent(dis, mdForContent, true);\n+                        if (eventItemConsumer != null) {\n+                            eventItemConsumer.accept(eventItem);\n+                        }\n+                        break;\n+\n+                    default:\n+                        throw new IllegalArgumentException(String.format(\n+                                \"Unknown event file delimiter %s for file %s\", typeDelimiter, fileName));\n+                }\n+            }\n+            if (fileVersion >= EVENT_STREAM_FILE_VERSION_CURRENT) {\n+                md.update(mdForContent.digest());\n+            }\n+            if (eventFile.getPreviousHash() == null) {\n+                throw new IllegalArgumentException(\"previous hash is null in file \" + fileName);\n+            }\n+            eventFile.setFileHash(Hex.encodeHexString(md.digest()));\n+            log.trace(\"Calculated file hash for the event file {}\", eventFile.getFileHash());\n+            return eventFile;\n+        } catch (Exception e) {\n+            throw new IllegalArgumentException(\"Error parsing bad event file \" + fileName, e);\n+        }\n+    }\n+\n+    private static EventItem loadEvent(DataInputStream dis, MessageDigest md, boolean hasTransactions)\n+            throws IOException {\n+        EventItem eventItem = new EventItem();\n+        int version = readInt(dis, md);\n+        if (version != EVENT_STREAM_VERSION) {\n+            throw new IllegalArgumentException(\"Invalid EventStream format version : \" + version);\n+        }\n+\n+        eventItem.setCreatorId(readLong(dis, md));\n+        eventItem.setCreatorSeq(readLong(dis, md));\n+        eventItem.setOtherId(readLong(dis, md));\n+        eventItem.setOtherSeq(readLong(dis, md));\n+        eventItem.setSelfParentGen(readLong(dis, md));\n+        eventItem.setOtherParentGen(readLong(dis, md));\n+        eventItem.setSelfParentHash(readBytesWithChecksum(dis, md, true));\n+        eventItem.setOtherParentHash(readBytesWithChecksum(dis, md, true));\n+        if (hasTransactions) {\n+            eventItem.setTransactions(readTransactions(dis, md));\n+        }\n+        eventItem.setTimeCreated(readInstant(dis, md));\n+        eventItem.setSignature(readBytesWithChecksum(dis, md, false));\n+\n+        byte eventEndMarker = dis.readByte();\n+        if (eventEndMarker != EVENT_COMM_EVENT_LAST) {\n+            throw new IllegalArgumentException(\"Invalid event end marker : \" + eventEndMarker);\n+        }\n+        md.update(EVENT_COMM_EVENT_LAST);\n+\n+        eventItem.setHash(readBytesWithChecksum(dis, md, false));  // event's hash\n+        eventItem.setConsensusTimeStamp(readInstant(dis, md));\n+        eventItem.setConsensusOrder(readLong(dis, md));\n+        if (log.isTraceEnabled()) {\n+            log.trace(\"Event: {}\", eventItem);\n+        }\n+        return eventItem;\n+    }\n+\n+    /**\n+     * Read all {@link Transaction}s from the {@link DataInputStream}.\n+     *\n+     * @throws IOException  if the internal checksum cannot be validated, or if any error occurs when reading the file\n+     */\n+    public static List<Transaction> readTransactions(DataInputStream dis, MessageDigest md) throws IOException {\n+        int numTransactions = readInt(dis, md);\n+        if (numTransactions < 0) {\n+            throw new IllegalArgumentException(\"Invalid number of transactions: \" + numTransactions);\n+        }\n+        readAndValidateChecksum(dis, 1873 - numTransactions, md);\n+        List<Transaction> transactions = new ArrayList<>(numTransactions);\n+        for (int i = 0; i < numTransactions; i++) {\n+            transactions.add(deserialize(dis, md));\n+        }\n+        return transactions;\n+    }\n+\n+    /**\n+     * Read single {@link Transaction} from the {@link DataInputStream}.\n+     *\n+     * @throws IOException  if the internal checksum cannot be validated, or if any error occurs when reading the file\n+     */\n+    private static Transaction deserialize(DataInputStream dis, MessageDigest md) throws IOException {\n+        int txLen = readInt(dis, md);\n+        if (txLen < 0) {\n+            throw new IllegalArgumentException(\"Invalid number of transactions: \" + txLen);\n+        }\n+        readAndValidateChecksum(dis, 277 - txLen, md);\n+        readBoolean(dis, md); // system field of transaction\n+        byte[] contents = readBytes(dis, txLen, md);\n+        Signature[] signatures = readSignatures(dis, md);\n+        return new Transaction(contents, signatures);\n+    }\n+\n+    /**\n+     * Read all {@link Signature}s from the {@link DataInputStream}.\n+     *\n+     * @throws IOException  if the internal checksum cannot be validated, or if any error occurs when reading the file\n+     */\n+    private static Signature[] readSignatures(DataInputStream dis, MessageDigest md) throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMyNzY3Nw=="}, "originalCommit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzYxMzc2OQ==", "bodyText": "This should be higher since it's not currently a requirement to have low latency for this stream. Maybe 5s?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r443613769", "createdAt": "2020-06-22T14:46:31Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/event/EventDownloaderProperties.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package com.hedera.mirror.importer.downloader.event;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import javax.validation.constraints.Min;\n+import javax.validation.constraints.NotBlank;\n+import javax.validation.constraints.NotNull;\n+import lombok.Data;\n+import org.springframework.boot.context.properties.ConfigurationProperties;\n+import org.springframework.validation.annotation.Validated;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.StreamType;\n+import com.hedera.mirror.importer.downloader.CommonDownloaderProperties;\n+import com.hedera.mirror.importer.downloader.DownloaderProperties;\n+\n+@Data\n+@Validated\n+@ConfigurationProperties(\"hedera.mirror.importer.downloader.event\")\n+public class EventDownloaderProperties implements DownloaderProperties {\n+\n+    private final MirrorProperties mirrorProperties;\n+\n+    private final CommonDownloaderProperties common;\n+\n+    @Min(1)\n+    private int batchSize = 15;\n+\n+    private boolean enabled = false;\n+\n+    @NotNull\n+    private Duration frequency = Duration.ofMillis(500L);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzYyNzUyOA==", "bodyText": "This is too low and makes catch up very inefficient. Would set to 100. We can test later for optimal amount, but 15 definitely too low.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r443627528", "createdAt": "2020-06-22T15:05:11Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/event/EventDownloaderProperties.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package com.hedera.mirror.importer.downloader.event;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import javax.validation.constraints.Min;\n+import javax.validation.constraints.NotBlank;\n+import javax.validation.constraints.NotNull;\n+import lombok.Data;\n+import org.springframework.boot.context.properties.ConfigurationProperties;\n+import org.springframework.validation.annotation.Validated;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.StreamType;\n+import com.hedera.mirror.importer.downloader.CommonDownloaderProperties;\n+import com.hedera.mirror.importer.downloader.DownloaderProperties;\n+\n+@Data\n+@Validated\n+@ConfigurationProperties(\"hedera.mirror.importer.downloader.event\")\n+public class EventDownloaderProperties implements DownloaderProperties {\n+\n+    private final MirrorProperties mirrorProperties;\n+\n+    private final CommonDownloaderProperties common;\n+\n+    @Min(1)\n+    private int batchSize = 15;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY1NDY3OA==", "bodyText": "Static methods should be avoided. Remember RecordFileLogger? Once you make non-static you could use dependency injection to inject properties and repo so you don't need to pass the hash and verifyhashafter as parameters. It would also allow us to support different event versions in the future more easily via different concrete implementations.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r443654678", "createdAt": "2020-06-22T15:44:43Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/filedecoder/EventsFileDecoder.java", "diffHunk": "@@ -0,0 +1,275 @@\n+package com.hedera.mirror.importer.filedecoder;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static com.hedera.mirror.importer.util.Utility.readBytes;\n+import static com.hedera.mirror.importer.util.Utility.readInt;\n+\n+import com.swirlds.common.Transaction;\n+import com.swirlds.common.crypto.Signature;\n+import java.io.DataInputStream;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.security.MessageDigest;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.codec.binary.Hex;\n+\n+import com.hedera.mirror.importer.domain.EventFile;\n+import com.hedera.mirror.importer.domain.EventItem;\n+import com.hedera.mirror.importer.exception.HashMismatchException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+public class EventsFileDecoder {\n+    public static final String HASH_ALGORITHM = \"SHA-384\";\n+    public static final byte EVENT_TYPE_PREV_HASH = 1;       // next 48 bytes are hash384 or previous files\n+    public static final byte EVENT_STREAM_FILE_VERSION_LEGACY = 2;\n+    public static final byte EVENT_STREAM_VERSION = 2;\n+    public static final byte EVENT_STREAM_FILE_VERSION_CURRENT = 3;\n+    public static final byte EVENT_STREAM_START_NO_TRANS_WITH_VERSION = 0x5b;\n+    public static final byte EVENT_STREAM_START_WITH_VERSION = 0x5a;\n+    public static final byte EVENT_COMM_EVENT_LAST = 0x46;\n+\n+    /**\n+     * Decodes event stream file.\n+\n+     * @param filePath path to event file\n+     * @param expectedPrevFileHash expected previous file's hash in current file. Throws {@link HashMismatchException}\n+     *                             on mismatch\n+     * @param verifyHashAfter previous file's hash mismatch is ignored if file is from before this time\n+     * @param eventItemConsumer if not null, consumer is invoked for each event in the file\n+     */\n+    public static EventFile decode(String filePath, String expectedPrevFileHash, Instant verifyHashAfter,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY2MTg5OA==", "bodyText": "Would prefer filereader or reader as it's not decoding anything per se. Same for class name.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r443661898", "createdAt": "2020-06-22T15:55:26Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/filedecoder/EventsFileDecoder.java", "diffHunk": "@@ -0,0 +1,275 @@\n+package com.hedera.mirror.importer.filedecoder;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY3MTY2OA==", "bodyText": "IllegalArgumentException is generally used for user input. Would be better to create a custom exception like FileReaderException extends ImporterException.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r443671668", "createdAt": "2020-06-22T16:10:11Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/filedecoder/EventsFileDecoder.java", "diffHunk": "@@ -0,0 +1,275 @@\n+package com.hedera.mirror.importer.filedecoder;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static com.hedera.mirror.importer.util.Utility.readBytes;\n+import static com.hedera.mirror.importer.util.Utility.readInt;\n+\n+import com.swirlds.common.Transaction;\n+import com.swirlds.common.crypto.Signature;\n+import java.io.DataInputStream;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.security.MessageDigest;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.codec.binary.Hex;\n+\n+import com.hedera.mirror.importer.domain.EventFile;\n+import com.hedera.mirror.importer.domain.EventItem;\n+import com.hedera.mirror.importer.exception.HashMismatchException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+public class EventsFileDecoder {\n+    public static final String HASH_ALGORITHM = \"SHA-384\";\n+    public static final byte EVENT_TYPE_PREV_HASH = 1;       // next 48 bytes are hash384 or previous files\n+    public static final byte EVENT_STREAM_FILE_VERSION_LEGACY = 2;\n+    public static final byte EVENT_STREAM_VERSION = 2;\n+    public static final byte EVENT_STREAM_FILE_VERSION_CURRENT = 3;\n+    public static final byte EVENT_STREAM_START_NO_TRANS_WITH_VERSION = 0x5b;\n+    public static final byte EVENT_STREAM_START_WITH_VERSION = 0x5a;\n+    public static final byte EVENT_COMM_EVENT_LAST = 0x46;\n+\n+    /**\n+     * Decodes event stream file.\n+\n+     * @param filePath path to event file\n+     * @param expectedPrevFileHash expected previous file's hash in current file. Throws {@link HashMismatchException}\n+     *                             on mismatch\n+     * @param verifyHashAfter previous file's hash mismatch is ignored if file is from before this time\n+     * @param eventItemConsumer if not null, consumer is invoked for each event in the file\n+     */\n+    public static EventFile decode(String filePath, String expectedPrevFileHash, Instant verifyHashAfter,\n+                                   Consumer<EventItem> eventItemConsumer) {\n+        EventFile eventFile = new EventFile();\n+        eventFile.setName(filePath);\n+        String fileName = Utility.getFileName(filePath);\n+\n+        try (DataInputStream dis = new DataInputStream(new FileInputStream(filePath))) {\n+            // MessageDigest for getting the file Hash\n+            // suppose file[i] = p[i] || h[i] || c[i];\n+            // p[i] denotes the bytes before previousFileHash;\n+            // h[i] denotes the hash of file i - 1, i.e., previousFileHash;\n+            // c[i] denotes the bytes after previousFileHash;\n+            // '||' means concatenation\n+            // for Version2, h[i + 1] = hash(p[i] || h[i] || c[i]);\n+            // for Version3, h[i + 1] = hash(p[i] || h[i] || hash(c[i]))\n+            MessageDigest md = MessageDigest.getInstance(HASH_ALGORITHM);\n+\n+            int fileVersion = readInt(dis, md);\n+            if (fileVersion < EVENT_STREAM_FILE_VERSION_LEGACY) {\n+                throw new IllegalArgumentException(\"Invalid event stream file version \" + fileVersion);\n+            }\n+            eventFile.setFileVersion(fileVersion);\n+\n+            MessageDigest mdForContent = md;\n+            if (fileVersion >= EVENT_STREAM_FILE_VERSION_CURRENT) {\n+                // For calculating hash(c[i]) separately if version >= 3\n+                mdForContent = MessageDigest.getInstance(HASH_ALGORITHM);\n+            }\n+            while (dis.available() != 0) {\n+                byte typeDelimiter = dis.readByte();\n+                EventItem eventItem;\n+                switch (typeDelimiter) {\n+                    case EVENT_TYPE_PREV_HASH:\n+                        md.update(typeDelimiter);\n+                        byte[] readPrevFileHash = readBytes(dis, 48, md);\n+                        eventFile.setPreviousHash(Hex.encodeHexString(readPrevFileHash));\n+                        Instant fileInstant = Instant.parse(fileName.replaceAll(\".evts\", \"\").replaceAll(\"_\", \":\"));\n+\n+                        if (!Utility.verifyHashChain(eventFile.getPreviousHash(), expectedPrevFileHash,\n+                                verifyHashAfter, fileInstant)) {\n+                            throw new HashMismatchException(\"Hash mismatch for file \" + fileName);\n+                        }\n+                        break;\n+\n+                    case EVENT_STREAM_START_NO_TRANS_WITH_VERSION:\n+                        mdForContent.update(typeDelimiter);\n+                        eventItem = loadEvent(dis, mdForContent, false);\n+                        if (eventItemConsumer != null) {\n+                            eventItemConsumer.accept(eventItem);\n+                        }\n+                        break;\n+\n+                    case EVENT_STREAM_START_WITH_VERSION:\n+                        mdForContent.update(typeDelimiter);\n+                        eventItem = loadEvent(dis, mdForContent, true);\n+                        if (eventItemConsumer != null) {\n+                            eventItemConsumer.accept(eventItem);\n+                        }\n+                        break;\n+\n+                    default:\n+                        throw new IllegalArgumentException(String.format(\n+                                \"Unknown event file delimiter %s for file %s\", typeDelimiter, fileName));\n+                }\n+            }\n+            if (fileVersion >= EVENT_STREAM_FILE_VERSION_CURRENT) {\n+                md.update(mdForContent.digest());\n+            }\n+            if (eventFile.getPreviousHash() == null) {\n+                throw new IllegalArgumentException(\"previous hash is null in file \" + fileName);\n+            }\n+            eventFile.setFileHash(Hex.encodeHexString(md.digest()));\n+            log.trace(\"Calculated file hash for the event file {}\", eventFile.getFileHash());\n+            return eventFile;\n+        } catch (Exception e) {\n+            throw new IllegalArgumentException(\"Error parsing bad event file \" + fileName, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY3MzUzMA==", "bodyText": "Pass File object so you don't create a duplicate File object unnecessarily via FileInputStream", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r443673530", "createdAt": "2020-06-22T16:13:17Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/event/EventFileDownloader.java", "diffHunk": "@@ -0,0 +1,87 @@\n+package com.hedera.mirror.importer.downloader.event;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import java.io.File;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.codec.binary.Hex;\n+import org.springframework.scheduling.annotation.Scheduled;\n+import software.amazon.awssdk.services.s3.S3AsyncClient;\n+\n+import com.hedera.mirror.importer.addressbook.NetworkAddressBook;\n+import com.hedera.mirror.importer.domain.ApplicationStatusCode;\n+import com.hedera.mirror.importer.domain.EventFile;\n+import com.hedera.mirror.importer.downloader.Downloader;\n+import com.hedera.mirror.importer.exception.HashMismatchException;\n+import com.hedera.mirror.importer.filedecoder.EventsFileDecoder;\n+import com.hedera.mirror.importer.leader.Leader;\n+import com.hedera.mirror.importer.repository.ApplicationStatusRepository;\n+\n+@Log4j2\n+@Named\n+public class EventFileDownloader extends Downloader {\n+\n+    public EventFileDownloader(\n+            S3AsyncClient s3Client, ApplicationStatusRepository applicationStatusRepository,\n+            NetworkAddressBook networkAddressBook, EventDownloaderProperties downloaderProperties,\n+            MeterRegistry meterRegistry) {\n+        super(s3Client, applicationStatusRepository, networkAddressBook, downloaderProperties, meterRegistry);\n+    }\n+\n+    @Leader\n+    @Override\n+    @Scheduled(fixedRateString = \"${hedera.mirror.downloader.event.frequency:500}\")\n+    public void download() {\n+        downloadNextBatch();\n+    }\n+\n+    @Override\n+    protected ApplicationStatusCode getLastValidDownloadedFileKey() {\n+        return ApplicationStatusCode.LAST_VALID_DOWNLOADED_EVENT_FILE;\n+    }\n+\n+    @Override\n+    protected ApplicationStatusCode getLastValidDownloadedFileHashKey() {\n+        return ApplicationStatusCode.LAST_VALID_DOWNLOADED_EVENT_FILE_HASH;\n+    }\n+\n+    /**\n+     * Checks that hash of data file matches the verified hash and that data file is next in line based on previous file\n+     * hash. Returns false if any condition is false.\n+     */\n+    @Override\n+    protected boolean verifyDataFile(File file, byte[] verifiedHash) {\n+        String expectedPrevFileHash = applicationStatusRepository.findByStatusCode(getLastValidDownloadedFileHashKey());\n+        try {\n+            EventFile eventFile = EventsFileDecoder.decode(file.getPath(), expectedPrevFileHash,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgzNTAyNQ==", "bodyText": "Would prefer deserialize logic not be a static method or coupled with the POJO. Recommend moving here.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r443835025", "createdAt": "2020-06-22T21:24:51Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/filedecoder/EventsFileDecoder.java", "diffHunk": "@@ -0,0 +1,275 @@\n+package com.hedera.mirror.importer.filedecoder;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static com.hedera.mirror.importer.util.Utility.readBytes;\n+import static com.hedera.mirror.importer.util.Utility.readInt;\n+\n+import com.swirlds.common.Transaction;\n+import com.swirlds.common.crypto.Signature;\n+import java.io.DataInputStream;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.security.MessageDigest;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.codec.binary.Hex;\n+\n+import com.hedera.mirror.importer.domain.EventFile;\n+import com.hedera.mirror.importer.domain.EventItem;\n+import com.hedera.mirror.importer.exception.HashMismatchException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+public class EventsFileDecoder {\n+    public static final String HASH_ALGORITHM = \"SHA-384\";\n+    public static final byte EVENT_TYPE_PREV_HASH = 1;       // next 48 bytes are hash384 or previous files\n+    public static final byte EVENT_STREAM_FILE_VERSION_LEGACY = 2;\n+    public static final byte EVENT_STREAM_VERSION = 2;\n+    public static final byte EVENT_STREAM_FILE_VERSION_CURRENT = 3;\n+    public static final byte EVENT_STREAM_START_NO_TRANS_WITH_VERSION = 0x5b;\n+    public static final byte EVENT_STREAM_START_WITH_VERSION = 0x5a;\n+    public static final byte EVENT_COMM_EVENT_LAST = 0x46;\n+\n+    /**\n+     * Decodes event stream file.\n+\n+     * @param filePath path to event file\n+     * @param expectedPrevFileHash expected previous file's hash in current file. Throws {@link HashMismatchException}\n+     *                             on mismatch\n+     * @param verifyHashAfter previous file's hash mismatch is ignored if file is from before this time\n+     * @param eventItemConsumer if not null, consumer is invoked for each event in the file\n+     */\n+    public static EventFile decode(String filePath, String expectedPrevFileHash, Instant verifyHashAfter,\n+                                   Consumer<EventItem> eventItemConsumer) {\n+        EventFile eventFile = new EventFile();\n+        eventFile.setName(filePath);\n+        String fileName = Utility.getFileName(filePath);\n+\n+        try (DataInputStream dis = new DataInputStream(new FileInputStream(filePath))) {\n+            // MessageDigest for getting the file Hash\n+            // suppose file[i] = p[i] || h[i] || c[i];\n+            // p[i] denotes the bytes before previousFileHash;\n+            // h[i] denotes the hash of file i - 1, i.e., previousFileHash;\n+            // c[i] denotes the bytes after previousFileHash;\n+            // '||' means concatenation\n+            // for Version2, h[i + 1] = hash(p[i] || h[i] || c[i]);\n+            // for Version3, h[i + 1] = hash(p[i] || h[i] || hash(c[i]))\n+            MessageDigest md = MessageDigest.getInstance(HASH_ALGORITHM);\n+\n+            int fileVersion = readInt(dis, md);\n+            if (fileVersion < EVENT_STREAM_FILE_VERSION_LEGACY) {\n+                throw new IllegalArgumentException(\"Invalid event stream file version \" + fileVersion);\n+            }\n+            eventFile.setFileVersion(fileVersion);\n+\n+            MessageDigest mdForContent = md;\n+            if (fileVersion >= EVENT_STREAM_FILE_VERSION_CURRENT) {\n+                // For calculating hash(c[i]) separately if version >= 3\n+                mdForContent = MessageDigest.getInstance(HASH_ALGORITHM);\n+            }\n+            while (dis.available() != 0) {\n+                byte typeDelimiter = dis.readByte();\n+                EventItem eventItem;\n+                switch (typeDelimiter) {\n+                    case EVENT_TYPE_PREV_HASH:\n+                        md.update(typeDelimiter);\n+                        byte[] readPrevFileHash = readBytes(dis, 48, md);\n+                        eventFile.setPreviousHash(Hex.encodeHexString(readPrevFileHash));\n+                        Instant fileInstant = Instant.parse(fileName.replaceAll(\".evts\", \"\").replaceAll(\"_\", \":\"));\n+\n+                        if (!Utility.verifyHashChain(eventFile.getPreviousHash(), expectedPrevFileHash,\n+                                verifyHashAfter, fileInstant)) {\n+                            throw new HashMismatchException(\"Hash mismatch for file \" + fileName);\n+                        }\n+                        break;\n+\n+                    case EVENT_STREAM_START_NO_TRANS_WITH_VERSION:\n+                        mdForContent.update(typeDelimiter);\n+                        eventItem = loadEvent(dis, mdForContent, false);\n+                        if (eventItemConsumer != null) {\n+                            eventItemConsumer.accept(eventItem);\n+                        }\n+                        break;\n+\n+                    case EVENT_STREAM_START_WITH_VERSION:\n+                        mdForContent.update(typeDelimiter);\n+                        eventItem = loadEvent(dis, mdForContent, true);\n+                        if (eventItemConsumer != null) {\n+                            eventItemConsumer.accept(eventItem);\n+                        }\n+                        break;\n+\n+                    default:\n+                        throw new IllegalArgumentException(String.format(\n+                                \"Unknown event file delimiter %s for file %s\", typeDelimiter, fileName));\n+                }\n+            }\n+            if (fileVersion >= EVENT_STREAM_FILE_VERSION_CURRENT) {\n+                md.update(mdForContent.digest());\n+            }\n+            if (eventFile.getPreviousHash() == null) {\n+                throw new IllegalArgumentException(\"previous hash is null in file \" + fileName);\n+            }\n+            eventFile.setFileHash(Hex.encodeHexString(md.digest()));\n+            log.trace(\"Calculated file hash for the event file {}\", eventFile.getFileHash());\n+            return eventFile;\n+        } catch (Exception e) {\n+            throw new IllegalArgumentException(\"Error parsing bad event file \" + fileName, e);\n+        }\n+    }\n+\n+    private static EventItem loadEvent(DataInputStream dis, MessageDigest md, boolean hasTransactions)\n+            throws IOException {\n+        EventItem eventItem = new EventItem();\n+        int version = readInt(dis, md);\n+        if (version != EVENT_STREAM_VERSION) {\n+            throw new IllegalArgumentException(\"Invalid EventStream format version : \" + version);\n+        }\n+\n+        eventItem.setCreatorId(readLong(dis, md));\n+        eventItem.setCreatorSeq(readLong(dis, md));\n+        eventItem.setOtherId(readLong(dis, md));\n+        eventItem.setOtherSeq(readLong(dis, md));\n+        eventItem.setSelfParentGen(readLong(dis, md));\n+        eventItem.setOtherParentGen(readLong(dis, md));\n+        eventItem.setSelfParentHash(readBytesWithChecksum(dis, md, true));\n+        eventItem.setOtherParentHash(readBytesWithChecksum(dis, md, true));\n+        if (hasTransactions) {\n+            eventItem.setTransactions(readTransactions(dis, md));\n+        }\n+        eventItem.setTimeCreated(readInstant(dis, md));\n+        eventItem.setSignature(readBytesWithChecksum(dis, md, false));\n+\n+        byte eventEndMarker = dis.readByte();\n+        if (eventEndMarker != EVENT_COMM_EVENT_LAST) {\n+            throw new IllegalArgumentException(\"Invalid event end marker : \" + eventEndMarker);\n+        }\n+        md.update(EVENT_COMM_EVENT_LAST);\n+\n+        eventItem.setHash(readBytesWithChecksum(dis, md, false));  // event's hash\n+        eventItem.setConsensusTimeStamp(readInstant(dis, md));\n+        eventItem.setConsensusOrder(readLong(dis, md));\n+        if (log.isTraceEnabled()) {\n+            log.trace(\"Event: {}\", eventItem);\n+        }\n+        return eventItem;\n+    }\n+\n+    /**\n+     * Read all {@link Transaction}s from the {@link DataInputStream}.\n+     *\n+     * @throws IOException  if the internal checksum cannot be validated, or if any error occurs when reading the file\n+     */\n+    public static List<Transaction> readTransactions(DataInputStream dis, MessageDigest md) throws IOException {\n+        int numTransactions = readInt(dis, md);\n+        if (numTransactions < 0) {\n+            throw new IllegalArgumentException(\"Invalid number of transactions: \" + numTransactions);\n+        }\n+        readAndValidateChecksum(dis, 1873 - numTransactions, md);\n+        List<Transaction> transactions = new ArrayList<>(numTransactions);\n+        for (int i = 0; i < numTransactions; i++) {\n+            transactions.add(deserialize(dis, md));\n+        }\n+        return transactions;\n+    }\n+\n+    /**\n+     * Read single {@link Transaction} from the {@link DataInputStream}.\n+     *\n+     * @throws IOException  if the internal checksum cannot be validated, or if any error occurs when reading the file\n+     */\n+    private static Transaction deserialize(DataInputStream dis, MessageDigest md) throws IOException {\n+        int txLen = readInt(dis, md);\n+        if (txLen < 0) {\n+            throw new IllegalArgumentException(\"Invalid number of transactions: \" + txLen);\n+        }\n+        readAndValidateChecksum(dis, 277 - txLen, md);\n+        readBoolean(dis, md); // system field of transaction\n+        byte[] contents = readBytes(dis, txLen, md);\n+        Signature[] signatures = readSignatures(dis, md);\n+        return new Transaction(contents, signatures);\n+    }\n+\n+    /**\n+     * Read all {@link Signature}s from the {@link DataInputStream}.\n+     *\n+     * @throws IOException  if the internal checksum cannot be validated, or if any error occurs when reading the file\n+     */\n+    private static Signature[] readSignatures(DataInputStream dis, MessageDigest md) throws IOException {\n+        int numSigs = readInt(dis, md);\n+        if (numSigs < 0) {\n+            throw new IllegalArgumentException(\"Invalid number of signatures: \" + numSigs);\n+        }\n+        readAndValidateChecksum(dis, 353 - numSigs, md);\n+        Signature[] signatures = null;\n+        if (numSigs > 0) {\n+            signatures = new Signature[numSigs];\n+            for (int i = 0; i < numSigs; i++) {\n+                signatures[i] = Signature.deserialize(dis, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgzNTI4NQ==", "bodyText": "Will we be storing event item in the database?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r443835285", "createdAt": "2020-06-22T21:25:20Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EventItem.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.swirlds.common.Transaction;\n+import java.time.Instant;\n+import java.util.List;\n+import lombok.Data;\n+\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Data\n+public class EventItem {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684"}, "originalPosition": 31}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2e4674d2ba5a87cbb3c6f93009cdf9423c6d1bcc", "author": {"user": {"login": "xin-hedera", "name": "Xin Li"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/2e4674d2ba5a87cbb3c6f93009cdf9423c6d1bcc", "committedDate": "2020-07-10T15:44:37Z", "message": "Merge branch 'master' into events_downloader\n\n# Conflicts:\n#\thedera-mirror-importer/src/main/java/com/hedera/mirror/importer/util/Utility.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "51afb7e3595dbb77a64d7ed834ee303bf345f42b", "author": {"user": {"login": "xin-hedera", "name": "Xin Li"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/51afb7e3595dbb77a64d7ed834ee303bf345f42b", "committedDate": "2020-07-10T15:58:16Z", "message": "revert to extract timestamp from filename\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab711eb2a2ccc51554bb06e706c6f1ca0cd30787", "author": {"user": {"login": "xin-hedera", "name": "Xin Li"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/ab711eb2a2ccc51554bb06e706c6f1ca0cd30787", "committedDate": "2020-07-10T16:06:25Z", "message": "fix ossrh-swirlds-staging repo url\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea19eee59ac294cba24299f786db89b507f11913", "author": {"user": {"login": "xin-hedera", "name": "Xin Li"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/ea19eee59ac294cba24299f786db89b507f11913", "committedDate": "2020-07-13T16:51:34Z", "message": "remove dependency on swirlds.jar, add EventFileReader, update tests\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46bd0e91209973956414751558cd1201da7cdbcc", "author": {"user": {"login": "xin-hedera", "name": "Xin Li"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/46bd0e91209973956414751558cd1201da7cdbcc", "committedDate": "2020-07-13T17:21:08Z", "message": "Merge remote-tracking branch 'origin/master' into events_downloader"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "609a7da83cb63161538af05bb0a68e508f59cf9a", "author": {"user": {"login": "xin-hedera", "name": "Xin Li"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/609a7da83cb63161538af05bb0a68e508f59cf9a", "committedDate": "2020-07-13T22:27:18Z", "message": "reuse the file object\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d6171b5e513d6e0dce9706955e7f2ea5139cd3ed", "author": {"user": {"login": "xin-hedera", "name": "Xin Li"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/d6171b5e513d6e0dce9706955e7f2ea5139cd3ed", "committedDate": "2020-07-14T14:32:03Z", "message": "simplify EventFileReader, make it just read the file to extract needed fields\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b07e1dacbc53fb070d5a55e93891c7a9763df30", "author": {"user": {"login": "xin-hedera", "name": "Xin Li"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/8b07e1dacbc53fb070d5a55e93891c7a9763df30", "committedDate": "2020-07-15T16:34:44Z", "message": "change event downloader default batchSize to 100, remove EventItem.java\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "986f0e08a59a27037a704fd78b7078294f0e1bc8", "author": {"user": {"login": "xin-hedera", "name": "Xin Li"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/986f0e08a59a27037a704fd78b7078294f0e1bc8", "committedDate": "2020-07-15T17:01:28Z", "message": "resolve merge conflict\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "017800baa9518bcd2e033b73f89775500cec8099", "author": {"user": {"login": "xin-hedera", "name": "Xin Li"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/017800baa9518bcd2e033b73f89775500cec8099", "committedDate": "2020-07-15T17:20:36Z", "message": "Merge remote-tracking branch 'origin/master' into events_downloader\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5MjUwMzUy", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#pullrequestreview-449250352", "createdAt": "2020-07-15T19:06:11Z", "commit": {"oid": "017800baa9518bcd2e033b73f89775500cec8099"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxOTowNjoxMlrOGyL-lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxOToxMjozOVrOGyMMQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI3ODIzMA==", "bodyText": "Configuration doc says 1m but this says 5s. Update them to agree", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r455278230", "createdAt": "2020-07-15T19:06:12Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/event/EventDownloaderProperties.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package com.hedera.mirror.importer.downloader.event;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import javax.validation.constraints.Min;\n+import javax.validation.constraints.NotBlank;\n+import javax.validation.constraints.NotNull;\n+import lombok.Data;\n+import org.springframework.boot.context.properties.ConfigurationProperties;\n+import org.springframework.validation.annotation.Validated;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.StreamType;\n+import com.hedera.mirror.importer.downloader.CommonDownloaderProperties;\n+import com.hedera.mirror.importer.downloader.DownloaderProperties;\n+\n+@Data\n+@Validated\n+@ConfigurationProperties(\"hedera.mirror.importer.downloader.event\")\n+public class EventDownloaderProperties implements DownloaderProperties {\n+\n+    private final MirrorProperties mirrorProperties;\n+\n+    private final CommonDownloaderProperties common;\n+\n+    @Min(1)\n+    private int batchSize = 100;\n+\n+    private boolean enabled = false;\n+\n+    @NotNull\n+    private Duration frequency = Duration.ofMillis(5000L);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "017800baa9518bcd2e033b73f89775500cec8099"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI4MTcyOA==", "bodyText": "nit: eventsStreams/event?\nAssuming you want standard with accountBalances (accountBalances/balance) and records (recordstreams/record)", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r455281728", "createdAt": "2020-07-15T19:12:39Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/event/EventDownloaderProperties.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package com.hedera.mirror.importer.downloader.event;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import javax.validation.constraints.Min;\n+import javax.validation.constraints.NotBlank;\n+import javax.validation.constraints.NotNull;\n+import lombok.Data;\n+import org.springframework.boot.context.properties.ConfigurationProperties;\n+import org.springframework.validation.annotation.Validated;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.StreamType;\n+import com.hedera.mirror.importer.downloader.CommonDownloaderProperties;\n+import com.hedera.mirror.importer.downloader.DownloaderProperties;\n+\n+@Data\n+@Validated\n+@ConfigurationProperties(\"hedera.mirror.importer.downloader.event\")\n+public class EventDownloaderProperties implements DownloaderProperties {\n+\n+    private final MirrorProperties mirrorProperties;\n+\n+    private final CommonDownloaderProperties common;\n+\n+    @Min(1)\n+    private int batchSize = 100;\n+\n+    private boolean enabled = false;\n+\n+    @NotNull\n+    private Duration frequency = Duration.ofMillis(5000L);\n+\n+    private boolean keepSignatures = false;\n+\n+    @NotBlank\n+    private String prefix = \"eventsStreams/events_\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "017800baa9518bcd2e033b73f89775500cec8099"}, "originalPosition": 57}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "78d6cde0665ba78f10b6a02ac779880320e46ccc", "author": {"user": {"login": "xin-hedera", "name": "Xin Li"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/78d6cde0665ba78f10b6a02ac779880320e46ccc", "committedDate": "2020-07-15T20:11:34Z", "message": "update default value of hedera.mirror.importer.downloader.event.frequency in configuration.md to match implementation\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c373107aed5008870055f7ae1e9fce3db7718f67", "author": {"user": {"login": "xin-hedera", "name": "Xin Li"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/c373107aed5008870055f7ae1e9fce3db7718f67", "committedDate": "2020-07-16T02:33:16Z", "message": "set a larger timeout to make parseAndIngestMultipleFiles60000Transactions happy\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4d8b152bad02d3dc3db108340a27fca1a6e92736", "author": {"user": {"login": "xin-hedera", "name": "Xin Li"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/4d8b152bad02d3dc3db108340a27fca1a6e92736", "committedDate": "2020-07-16T02:30:40Z", "message": "set a larger timeout to make parseAndIngestMultipleFiles60000Transactions happy\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>"}, "afterCommit": {"oid": "c373107aed5008870055f7ae1e9fce3db7718f67", "author": {"user": {"login": "xin-hedera", "name": "Xin Li"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/c373107aed5008870055f7ae1e9fce3db7718f67", "committedDate": "2020-07-16T02:33:16Z", "message": "set a larger timeout to make parseAndIngestMultipleFiles60000Transactions happy\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5OTE3MzUy", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#pullrequestreview-449917352", "createdAt": "2020-07-16T14:41:31Z", "commit": {"oid": "c373107aed5008870055f7ae1e9fce3db7718f67"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b55662475c9d31e2a42ec98d6c1aad5be284b39b", "author": {"user": {"login": "xin-hedera", "name": "Xin Li"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/b55662475c9d31e2a42ec98d6c1aad5be284b39b", "committedDate": "2020-07-16T16:02:00Z", "message": "add test cases for EventFileReaderImpl and disable fragmentedMessagesGroupAcrossHistoricAndIncoming\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwMDY5MjQ2", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#pullrequestreview-450069246", "createdAt": "2020-07-16T17:36:47Z", "commit": {"oid": "b55662475c9d31e2a42ec98d6c1aad5be284b39b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNzozNjo0N1rOGy1a3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxODozMzozOVrOGy3f7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk1NzIxMg==", "bodyText": "Nana's PR fixes it. Let's make sure if this is merged first that Nana's PR removes this.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r455957212", "createdAt": "2020-07-16T17:36:47Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-grpc/src/test/java/com/hedera/mirror/grpc/controller/ConsensusControllerTest.java", "diffHunk": "@@ -221,6 +222,7 @@ void subscribeVerifySequence() throws Exception {\n                 .verify(Duration.ofMillis(1000));\n     }\n \n+    @Disabled(\"Temporarily disable it since it fails randomly\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b55662475c9d31e2a42ec98d6c1aad5be284b39b"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk1ODQyMA==", "bodyText": "Should be 5000 to match readme and properties", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r455958420", "createdAt": "2020-07-16T17:38:46Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/event/EventFileDownloader.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package com.hedera.mirror.importer.downloader.event;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.hedera.mirror.importer.exception.ImporterException;\n+\n+import com.hedera.mirror.importer.util.Utility;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import java.io.File;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.codec.binary.Hex;\n+import org.apache.commons.io.FilenameUtils;\n+import org.springframework.scheduling.annotation.Scheduled;\n+import com.hedera.mirror.importer.reader.event.EventFileReader;\n+import software.amazon.awssdk.services.s3.S3AsyncClient;\n+\n+import com.hedera.mirror.importer.addressbook.NetworkAddressBook;\n+import com.hedera.mirror.importer.domain.ApplicationStatusCode;\n+import com.hedera.mirror.importer.domain.EventFile;\n+import com.hedera.mirror.importer.downloader.Downloader;\n+import com.hedera.mirror.importer.leader.Leader;\n+import com.hedera.mirror.importer.repository.ApplicationStatusRepository;\n+\n+import static com.hedera.mirror.importer.util.Utility.verifyHashChain;\n+\n+@Log4j2\n+@Named\n+public class EventFileDownloader extends Downloader {\n+\n+    private EventFileReader eventFileReader;\n+\n+    public EventFileDownloader(\n+            S3AsyncClient s3Client, ApplicationStatusRepository applicationStatusRepository,\n+            NetworkAddressBook networkAddressBook, EventDownloaderProperties downloaderProperties,\n+            MeterRegistry meterRegistry, EventFileReader eventFileReader) {\n+        super(s3Client, applicationStatusRepository, networkAddressBook, downloaderProperties, meterRegistry);\n+        this.eventFileReader = eventFileReader;\n+    }\n+\n+    @Leader\n+    @Override\n+    @Scheduled(fixedRateString = \"${hedera.mirror.downloader.event.frequency:500}\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b55662475c9d31e2a42ec98d6c1aad5be284b39b"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk5MTI3Ng==", "bodyText": "These constants aren't used outside of EventFileReaderImpl and its associated test. Would prefer they be moved as private members in EventFileReaderImpl.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r455991276", "createdAt": "2020-07-16T18:33:39Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/reader/event/EventFileConstants.java", "diffHunk": "@@ -0,0 +1,34 @@\n+package com.hedera.mirror.importer.reader.event;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+public class EventFileConstants {\n+    public static final String HASH_ALGORITHM = \"SHA-384\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b55662475c9d31e2a42ec98d6c1aad5be284b39b"}, "originalPosition": 24}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "676410722ceb9cffef76443931a1801f354791ce", "author": {"user": {"login": "xin-hedera", "name": "Xin Li"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/676410722ceb9cffef76443931a1801f354791ce", "committedDate": "2020-07-16T19:24:47Z", "message": "allow content of event stream file to be empty, update test cases, remove EventFileConstants\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7cd3be35000b207093c6a0ef7a4bce662dd8dea3", "author": {"user": {"login": "xin-hedera", "name": "Xin Li"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/7cd3be35000b207093c6a0ef7a4bce662dd8dea3", "committedDate": "2020-07-16T19:26:57Z", "message": "Merge remote-tracking branch 'origin/master' into events_downloader"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwMTYzNDUw", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#pullrequestreview-450163450", "createdAt": "2020-07-16T19:44:55Z", "commit": {"oid": "7cd3be35000b207093c6a0ef7a4bce662dd8dea3"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3197, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}