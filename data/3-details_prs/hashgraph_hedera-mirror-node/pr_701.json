{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA2ODQyNTU0", "number": 701, "title": "Fix address book updates that span transactions", "bodyText": "Detailed description:\n\nFix losing partial updates during restart due to storing temporary state in memory\nFix incomplete address books from being used for signature validation by using an addressbook.bin.tmp to store address books that don't fit in a single file update or don't parse\nFix unreadable address book not correcting itself\nFix not failing on startup if no valid address book could be found\nFix null or empty byte array throwing NPE or being persisted\nEnhance reads to return cached immutable object instead of hitting disk\nRename NetworkAddressBook.load() to NetworkAddressBook.getAddresses() since it no longer loads from disk\nAdd unit test coverage\n\nWhich issue(s) this PR fixes:\nFixes #58\nFixes #353\nFixes #695\nSpecial notes for your reviewer:\n\nUnable to test unreadable address book due to CircleCI limitation\n\nChecklist\n\n Documentation added\n Tests updated", "createdAt": "2020-04-21T18:48:15Z", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/701", "merged": true, "mergeCommit": {"oid": "fe4d1288aba56e65caa788a236a7bc4bc09dbad3"}, "closed": true, "closedAt": "2020-04-22T14:23:20Z", "author": {"login": "steven-sheehy"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcZ4Qw5gH2gAyNDA2ODQyNTU0OjA5ODMzMzU3OWQ3NDFiNDE5ZTkxNWQ2OTk1MzcyYmVkY2Y4MTU2OTc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcZ5bxrgFqTM5NzYzNzQ5MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "098333579d741b419e915d6995372bedcf815697", "author": {"user": {"login": "steven-sheehy", "name": "Steven Sheehy"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/098333579d741b419e915d6995372bedcf815697", "committedDate": "2020-04-21T18:47:11Z", "message": "Fix address book updates that span transactions\n\nSigned-off-by: Steven Sheehy <steven.sheehy@hedera.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "467f28fd8eb42a197f232bc856eb23afb476bb53", "author": {"user": {"login": "steven-sheehy", "name": "Steven Sheehy"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/467f28fd8eb42a197f232bc856eb23afb476bb53", "committedDate": "2020-04-21T19:00:24Z", "message": "Remove unreadable test that doesn't work in CircleCI\n\nSigned-off-by: Steven Sheehy <steven.sheehy@hedera.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3NTg0NDUy", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/701#pullrequestreview-397584452", "createdAt": "2020-04-21T18:52:45Z", "commit": {"oid": "098333579d741b419e915d6995372bedcf815697"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxODo1Mjo0NVrOGJTcTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxOToxMjowMFrOGJUNfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQwODkxMA==", "bodyText": "nit: store addressBookFile.exists() and addressBookFile.canRead() and reference them here", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/701#discussion_r412408910", "createdAt": "2020-04-21T18:52:45Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/NetworkAddressBook.java", "diffHunk": "@@ -46,71 +46,100 @@\n @Named\n public class NetworkAddressBook {\n \n-    private MirrorProperties mirrorProperties;\n-    private byte[] addressBookBytes = new byte[0];\n+    private final MirrorProperties mirrorProperties;\n+    private volatile Collection<NodeAddress> nodeAddresses;\n \n     public NetworkAddressBook(MirrorProperties mirrorProperties) {\n         this.mirrorProperties = mirrorProperties;\n+        this.nodeAddresses = Collections.emptyList();\n         init();\n     }\n \n     private void init() {\n         Path path = mirrorProperties.getAddressBookPath();\n         try {\n             File addressBookFile = path.toFile();\n+            byte[] addressBookBytes = null;\n+\n             if (!addressBookFile.exists() || !addressBookFile.canRead()) {\n+                if (addressBookFile.exists() && !addressBookFile.canRead()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "098333579d741b419e915d6995372bedcf815697"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQyMDI3NA==", "bodyText": "q: did you want to log the error for future trouble shooting ?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/701#discussion_r412420274", "createdAt": "2020-04-21T19:10:07Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/NetworkAddressBook.java", "diffHunk": "@@ -46,71 +46,100 @@\n @Named\n public class NetworkAddressBook {\n \n-    private MirrorProperties mirrorProperties;\n-    private byte[] addressBookBytes = new byte[0];\n+    private final MirrorProperties mirrorProperties;\n+    private volatile Collection<NodeAddress> nodeAddresses;\n \n     public NetworkAddressBook(MirrorProperties mirrorProperties) {\n         this.mirrorProperties = mirrorProperties;\n+        this.nodeAddresses = Collections.emptyList();\n         init();\n     }\n \n     private void init() {\n         Path path = mirrorProperties.getAddressBookPath();\n         try {\n             File addressBookFile = path.toFile();\n+            byte[] addressBookBytes = null;\n+\n             if (!addressBookFile.exists() || !addressBookFile.canRead()) {\n+                if (addressBookFile.exists() && !addressBookFile.canRead()) {\n+                    log.warn(\"Backing up unreadable address book: {}\", path);\n+                    Files.move(path, path.resolveSibling(path + \".unreadable\"));\n+                }\n+\n                 HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n                 String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n                 Resource resource = new ClassPathResource(resourcePath, getClass());\n                 Utility.ensureDirectory(path.getParent());\n-                IOUtils.copy(resource.getInputStream(), new FileOutputStream(addressBookFile));\n-                log.info(\"Copied default address book {} to {}\", resource, path);\n+\n+                log.info(\"Loading default address book {}\", resource);\n+                addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n+            } else {\n+                log.info(\"Restoring existing address book {}\", path);\n+                addressBookBytes = Files.readAllBytes(path);\n             }\n+\n+            update(addressBookBytes);\n         } catch (Exception e) {\n             log.error(\"Unable to copy address book from {} to {}\", mirrorProperties.getNetwork(), path, e);\n         }\n+\n+        if (getAddresses().isEmpty()) {\n+            throw new IllegalStateException(\"Unable to load a valid address book\");\n+        }\n     }\n \n     public void update(byte[] newContents) throws IOException {\n-        addressBookBytes = newContents;\n-        saveToDisk();\n+        saveToDisk(newContents, StandardOpenOption.TRUNCATE_EXISTING);\n     }\n \n     public void append(byte[] extraContents) throws IOException {\n-        byte[] newAddressBook = Arrays.copyOf(addressBookBytes, addressBookBytes.length + extraContents.length);\n-        System.arraycopy(extraContents, 0, newAddressBook, addressBookBytes.length, extraContents.length);\n-        addressBookBytes = newAddressBook;\n-        saveToDisk();\n+        saveToDisk(extraContents, StandardOpenOption.APPEND);\n     }\n \n-    private void saveToDisk() throws IOException {\n-        Path path = mirrorProperties.getAddressBookPath();\n-        Files.write(path, addressBookBytes);\n-        log.info(\"New address book successfully saved to {}\", path);\n-    }\n+    private void saveToDisk(byte[] contents, OpenOption openOption) throws IOException {\n+        if (contents == null || contents.length == 0) {\n+            log.warn(\"Ignored empty byte array\");\n+            return;\n+        }\n \n-    public Collection<NodeAddress> load() {\n-        ImmutableList.Builder<NodeAddress> builder = ImmutableList.builder();\n         Path path = mirrorProperties.getAddressBookPath();\n+        Path tempPath = path.resolveSibling(path.getFileName() + \".tmp\");\n+        Files.write(tempPath, contents, StandardOpenOption.CREATE, StandardOpenOption.WRITE, openOption);\n+        log.info(\"Saved {}B partial address book update to {}\", contents.length, tempPath);\n \n         try {\n-            byte[] addressBookBytes = Files.readAllBytes(path);\n-            NodeAddressBook nodeAddressBook = NodeAddressBook.parseFrom(addressBookBytes);\n-\n-            for (com.hederahashgraph.api.proto.java.NodeAddress nodeAddressProto : nodeAddressBook\n-                    .getNodeAddressList()) {\n-                NodeAddress nodeAddress = NodeAddress.builder()\n-                        .id(nodeAddressProto.getMemo().toStringUtf8())\n-                        .ip(nodeAddressProto.getIpAddress().toStringUtf8())\n-                        .port(nodeAddressProto.getPortno())\n-                        .publicKey(nodeAddressProto.getRSAPubKey())\n-                        .build();\n-                builder.add(nodeAddress);\n+            Collection<NodeAddress> nodeAddresses = parse(tempPath);\n+            if (!nodeAddresses.isEmpty()) {\n+                Files.move(tempPath, path, StandardCopyOption.REPLACE_EXISTING);\n+                this.nodeAddresses = nodeAddresses;\n+                log.info(\"New address book successfully parsed and saved to {}\", path);\n             }\n-        } catch (Exception ex) {\n-            log.error(\"Failed to parse NodeAddressBook from {}\", path, ex);\n+        } catch (Exception e) {\n+            // Ignore partial update errors", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "098333579d741b419e915d6995372bedcf815697"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQyMTUwMw==", "bodyText": "Do we have a place that says how many nodes were added to list? If not here's a good place to trace log that.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/701#discussion_r412421503", "createdAt": "2020-04-21T19:12:00Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/NetworkAddressBook.java", "diffHunk": "@@ -46,71 +46,100 @@\n @Named\n public class NetworkAddressBook {\n \n-    private MirrorProperties mirrorProperties;\n-    private byte[] addressBookBytes = new byte[0];\n+    private final MirrorProperties mirrorProperties;\n+    private volatile Collection<NodeAddress> nodeAddresses;\n \n     public NetworkAddressBook(MirrorProperties mirrorProperties) {\n         this.mirrorProperties = mirrorProperties;\n+        this.nodeAddresses = Collections.emptyList();\n         init();\n     }\n \n     private void init() {\n         Path path = mirrorProperties.getAddressBookPath();\n         try {\n             File addressBookFile = path.toFile();\n+            byte[] addressBookBytes = null;\n+\n             if (!addressBookFile.exists() || !addressBookFile.canRead()) {\n+                if (addressBookFile.exists() && !addressBookFile.canRead()) {\n+                    log.warn(\"Backing up unreadable address book: {}\", path);\n+                    Files.move(path, path.resolveSibling(path + \".unreadable\"));\n+                }\n+\n                 HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n                 String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n                 Resource resource = new ClassPathResource(resourcePath, getClass());\n                 Utility.ensureDirectory(path.getParent());\n-                IOUtils.copy(resource.getInputStream(), new FileOutputStream(addressBookFile));\n-                log.info(\"Copied default address book {} to {}\", resource, path);\n+\n+                log.info(\"Loading default address book {}\", resource);\n+                addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n+            } else {\n+                log.info(\"Restoring existing address book {}\", path);\n+                addressBookBytes = Files.readAllBytes(path);\n             }\n+\n+            update(addressBookBytes);\n         } catch (Exception e) {\n             log.error(\"Unable to copy address book from {} to {}\", mirrorProperties.getNetwork(), path, e);\n         }\n+\n+        if (getAddresses().isEmpty()) {\n+            throw new IllegalStateException(\"Unable to load a valid address book\");\n+        }\n     }\n \n     public void update(byte[] newContents) throws IOException {\n-        addressBookBytes = newContents;\n-        saveToDisk();\n+        saveToDisk(newContents, StandardOpenOption.TRUNCATE_EXISTING);\n     }\n \n     public void append(byte[] extraContents) throws IOException {\n-        byte[] newAddressBook = Arrays.copyOf(addressBookBytes, addressBookBytes.length + extraContents.length);\n-        System.arraycopy(extraContents, 0, newAddressBook, addressBookBytes.length, extraContents.length);\n-        addressBookBytes = newAddressBook;\n-        saveToDisk();\n+        saveToDisk(extraContents, StandardOpenOption.APPEND);\n     }\n \n-    private void saveToDisk() throws IOException {\n-        Path path = mirrorProperties.getAddressBookPath();\n-        Files.write(path, addressBookBytes);\n-        log.info(\"New address book successfully saved to {}\", path);\n-    }\n+    private void saveToDisk(byte[] contents, OpenOption openOption) throws IOException {\n+        if (contents == null || contents.length == 0) {\n+            log.warn(\"Ignored empty byte array\");\n+            return;\n+        }\n \n-    public Collection<NodeAddress> load() {\n-        ImmutableList.Builder<NodeAddress> builder = ImmutableList.builder();\n         Path path = mirrorProperties.getAddressBookPath();\n+        Path tempPath = path.resolveSibling(path.getFileName() + \".tmp\");\n+        Files.write(tempPath, contents, StandardOpenOption.CREATE, StandardOpenOption.WRITE, openOption);\n+        log.info(\"Saved {}B partial address book update to {}\", contents.length, tempPath);\n \n         try {\n-            byte[] addressBookBytes = Files.readAllBytes(path);\n-            NodeAddressBook nodeAddressBook = NodeAddressBook.parseFrom(addressBookBytes);\n-\n-            for (com.hederahashgraph.api.proto.java.NodeAddress nodeAddressProto : nodeAddressBook\n-                    .getNodeAddressList()) {\n-                NodeAddress nodeAddress = NodeAddress.builder()\n-                        .id(nodeAddressProto.getMemo().toStringUtf8())\n-                        .ip(nodeAddressProto.getIpAddress().toStringUtf8())\n-                        .port(nodeAddressProto.getPortno())\n-                        .publicKey(nodeAddressProto.getRSAPubKey())\n-                        .build();\n-                builder.add(nodeAddress);\n+            Collection<NodeAddress> nodeAddresses = parse(tempPath);\n+            if (!nodeAddresses.isEmpty()) {\n+                Files.move(tempPath, path, StandardCopyOption.REPLACE_EXISTING);\n+                this.nodeAddresses = nodeAddresses;\n+                log.info(\"New address book successfully parsed and saved to {}\", path);\n             }\n-        } catch (Exception ex) {\n-            log.error(\"Failed to parse NodeAddressBook from {}\", path, ex);\n+        } catch (Exception e) {\n+            // Ignore partial update errors\n+        }\n+    }\n+\n+    private Collection<NodeAddress> parse(Path path) throws Exception {\n+        byte[] addressBookBytes = Files.readAllBytes(path);\n+        NodeAddressBook nodeAddressBook = NodeAddressBook.parseFrom(addressBookBytes);\n+        ImmutableList.Builder<NodeAddress> builder = ImmutableList.builder();\n+\n+        for (com.hederahashgraph.api.proto.java.NodeAddress nodeAddressProto : nodeAddressBook\n+                .getNodeAddressList()) {\n+            NodeAddress nodeAddress = NodeAddress.builder()\n+                    .id(nodeAddressProto.getMemo().toStringUtf8())\n+                    .ip(nodeAddressProto.getIpAddress().toStringUtf8())\n+                    .port(nodeAddressProto.getPortno())\n+                    .publicKey(nodeAddressProto.getRSAPubKey())\n+                    .build();\n+            builder.add(nodeAddress);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "467f28fd8eb42a197f232bc856eb23afb476bb53"}, "originalPosition": 143}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8481a8b76aa00995ac8995b7b44e4717946e01f", "author": {"user": {"login": "steven-sheehy", "name": "Steven Sheehy"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/e8481a8b76aa00995ac8995b7b44e4717946e01f", "committedDate": "2020-04-21T19:28:00Z", "message": "Address review feedback\n\nSigned-off-by: Steven Sheehy <steven.sheehy@hedera.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3NjM3NDkw", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/701#pullrequestreview-397637490", "createdAt": "2020-04-21T20:09:07Z", "commit": {"oid": "e8481a8b76aa00995ac8995b7b44e4717946e01f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3087, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}