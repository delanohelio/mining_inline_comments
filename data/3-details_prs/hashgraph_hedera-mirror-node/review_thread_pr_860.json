{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ3NTQ5NDA3", "number": 860, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNzoxNTowNlrOENWeqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNzo1NTozNFrOENXNSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNDM1MjQxOnYy", "diffSide": "RIGHT", "path": "docs/configuration.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNzoxNTowNlrOGv_Iyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxODozMTozMFrOGwBVyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk3MDY5OA==", "bodyText": "I thought we were leaving the shared poller as the default until we'd gone through through testing?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/860#discussion_r452970698", "createdAt": "2020-07-10T17:15:06Z", "author": {"login": "Nana-EC"}, "path": "docs/configuration.md", "diffHunk": "@@ -109,9 +109,9 @@ value, it is recommended to only populate overridden properties in the custom `a\n | `hedera.mirror.grpc.endTimeInterval`                        | 30s              | How often we should check if a subscription has gone past the end time                         |\n | `hedera.mirror.grpc.entityCacheSize`                        | 50000            | The maximum size of the cache to store entities used for existence check                       |\n | `hedera.mirror.grpc.listener.enabled`                       | true             | Whether to listen for incoming massages or not                                                 |\n-| `hedera.mirror.grpc.listener.maxPageSize`                   | 10000            | The maximum number of messages the listener can return in a single call to the database        |\n-| `hedera.mirror.grpc.listener.pollingFrequency`              | 1s               | How often to polling for new topic messages. Can accept duration units like `50ms`, `10s` etc. |\n-| `hedera.mirror.grpc.listener.type`                          | SHARED_POLL      | The type of listener to use for incoming messages. Accepts either POLL or SHARED_POLL          |\n+| `hedera.mirror.grpc.listener.maxPageSize`                   | 5000             | The maximum number of messages the listener can return in a single call to the database        |\n+| `hedera.mirror.grpc.listener.frequency`                     | 500ms            | How often to poll or retry errors (varies by type). Can accept duration units like `50ms`, `10s`, etc. |\n+| `hedera.mirror.grpc.listener.type`                          | NOTIFY           | The type of listener to use for incoming messages. Accepts either NOTIFY, POLL or SHARED_POLL  |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d35f8459215b060fe10d10492fb35d55a8f3563"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAwNjc5Mg==", "bodyText": "We've accelerated the notify approach as that provides improved latency and we need a quick turnaround.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/860#discussion_r453006792", "createdAt": "2020-07-10T18:31:30Z", "author": {"login": "steven-sheehy"}, "path": "docs/configuration.md", "diffHunk": "@@ -109,9 +109,9 @@ value, it is recommended to only populate overridden properties in the custom `a\n | `hedera.mirror.grpc.endTimeInterval`                        | 30s              | How often we should check if a subscription has gone past the end time                         |\n | `hedera.mirror.grpc.entityCacheSize`                        | 50000            | The maximum size of the cache to store entities used for existence check                       |\n | `hedera.mirror.grpc.listener.enabled`                       | true             | Whether to listen for incoming massages or not                                                 |\n-| `hedera.mirror.grpc.listener.maxPageSize`                   | 10000            | The maximum number of messages the listener can return in a single call to the database        |\n-| `hedera.mirror.grpc.listener.pollingFrequency`              | 1s               | How often to polling for new topic messages. Can accept duration units like `50ms`, `10s` etc. |\n-| `hedera.mirror.grpc.listener.type`                          | SHARED_POLL      | The type of listener to use for incoming messages. Accepts either POLL or SHARED_POLL          |\n+| `hedera.mirror.grpc.listener.maxPageSize`                   | 5000             | The maximum number of messages the listener can return in a single call to the database        |\n+| `hedera.mirror.grpc.listener.frequency`                     | 500ms            | How often to poll or retry errors (varies by type). Can accept duration units like `50ms`, `10s`, etc. |\n+| `hedera.mirror.grpc.listener.type`                          | NOTIFY           | The type of listener to use for incoming messages. Accepts either NOTIFY, POLL or SHARED_POLL  |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk3MDY5OA=="}, "originalCommit": {"oid": "9d35f8459215b060fe10d10492fb35d55a8f3563"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNDM4MDU2OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/resources/db/migration/V1.26.1__pg_notify.sql", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNzoyNDo0NFrOGv_asg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxODozMzo1MlrOGwBaLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk3NTI4Mg==", "bodyText": "q: what do you think about adding a now timestamp here to help give us when the insert happened?\nWe could make a DTO with this additional insertTimestamp that metrics could use to calculate\n\nConsensus -> Ingestion\nConsensus -> Message publish/delivery", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/860#discussion_r452975282", "createdAt": "2020-07-10T17:24:44Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/resources/db/migration/V1.26.1__pg_notify.sql", "diffHunk": "@@ -0,0 +1,34 @@\n+-- Define trigger function. Base64 encoding is required since JSON doesn't support binary\n+create or replace function topic_message_notifier()\n+    returns trigger\n+    language plpgsql\n+as\n+$$\n+declare\n+    topicmessage text := TG_ARGV[0];\n+begin\n+    perform (\n+        with payload(consensus_timestamp, message, realm_num, running_hash, running_hash_version, sequence_number, topic_num) as", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d35f8459215b060fe10d10492fb35d55a8f3563"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAwNzkxNw==", "bodyText": "I think this table can grow too large to warrant storing an additional timestamp. We already have a metric for 1) and 2) (well the receival of it by grpc) and we can use metric arithmetic to find the difference between the two.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/860#discussion_r453007917", "createdAt": "2020-07-10T18:33:52Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/resources/db/migration/V1.26.1__pg_notify.sql", "diffHunk": "@@ -0,0 +1,34 @@\n+-- Define trigger function. Base64 encoding is required since JSON doesn't support binary\n+create or replace function topic_message_notifier()\n+    returns trigger\n+    language plpgsql\n+as\n+$$\n+declare\n+    topicmessage text := TG_ARGV[0];\n+begin\n+    perform (\n+        with payload(consensus_timestamp, message, realm_num, running_hash, running_hash_version, sequence_number, topic_num) as", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk3NTI4Mg=="}, "originalCommit": {"oid": "9d35f8459215b060fe10d10492fb35d55a8f3563"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNDM5MjM0OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/listener/NotifyingTopicListener.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNzoyODoyOFrOGv_h0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxODo1MjoxN1rOGwCJ6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk3NzEwNQ==", "bodyText": "If this logic is shared by all the Listeners should we move it to the CompositeTopicListener()?\nThen the CompositeTopicListener.listen() could call the filter method.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/860#discussion_r452977105", "createdAt": "2020-07-10T17:28:28Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/listener/NotifyingTopicListener.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package com.hedera.mirror.grpc.listener;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.PropertyNamingStrategy;\n+import io.vertx.core.Vertx;\n+import io.vertx.pgclient.PgConnectOptions;\n+import io.vertx.pgclient.pubsub.PgChannel;\n+import io.vertx.pgclient.pubsub.PgSubscriber;\n+import java.time.Duration;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import reactor.core.publisher.EmitterProcessor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.scheduler.Schedulers;\n+import reactor.util.retry.Retry;\n+\n+import com.hedera.mirror.grpc.DbProperties;\n+import com.hedera.mirror.grpc.domain.TopicMessage;\n+import com.hedera.mirror.grpc.domain.TopicMessageFilter;\n+\n+@Named\n+@Log4j2\n+public class NotifyingTopicListener implements TopicListener {\n+\n+    private final ObjectMapper objectMapper;\n+    private final Flux<TopicMessage> topicMessages;\n+    private final PgChannel channel;\n+\n+    public NotifyingTopicListener(DbProperties dbProperties, ListenerProperties listenerProperties) {\n+        this.objectMapper = new ObjectMapper().setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);\n+        PgConnectOptions connectOptions = new PgConnectOptions()\n+                .setDatabase(dbProperties.getName())\n+                .setHost(dbProperties.getHost())\n+                .setPassword(dbProperties.getPassword())\n+                .setPort(dbProperties.getPort())\n+                .setUser(dbProperties.getUsername());\n+\n+        Duration frequency = listenerProperties.getFrequency();\n+        Vertx vertx = Vertx.vertx();\n+        PgSubscriber subscriber = PgSubscriber.subscriber(vertx, connectOptions)\n+                .reconnectPolicy(retries -> {\n+                    log.warn(\"Attempting reconnect\");\n+                    return frequency.toMillis();\n+                });\n+\n+        // Connect asynchronously to avoid crashing the application on startup if the database is down\n+        vertx.setTimer(100L, v -> subscriber.connect(connectResult -> {\n+            if (connectResult.failed()) {\n+                throw new RuntimeException(connectResult.cause());\n+            }\n+            log.info(\"Connected to database\");\n+        }));\n+\n+        channel = subscriber.channel(\"topic_message\");\n+\n+        topicMessages = Flux.defer(() -> listen())\n+                .publishOn(Schedulers.boundedElastic())\n+                .map(this::toTopicMessage)\n+                .name(\"notify\")\n+                .metrics()\n+                .doFinally(s -> unlisten())\n+                .doOnError(t -> log.error(\"Error listening for messages\", t))\n+                .retryWhen(Retry.backoff(Long.MAX_VALUE, frequency).maxBackoff(frequency.multipliedBy(4L)))\n+                .share();\n+    }\n+\n+    @Override\n+    public Flux<TopicMessage> listen(TopicMessageFilter filter) {\n+        return topicMessages.filter(t -> filterMessage(t, filter))\n+                .doOnSubscribe(s -> log.info(\"Subscribing: {}\", filter));\n+    }\n+\n+    private boolean filterMessage(TopicMessage message, TopicMessageFilter filter) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d35f8459215b060fe10d10492fb35d55a8f3563"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAyMDEzOA==", "bodyText": "I did have that change, but then some listeners don't need it filtered like PollingTopicListener and wanted to keep this PR tightly focused on notify.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/860#discussion_r453020138", "createdAt": "2020-07-10T18:52:17Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/listener/NotifyingTopicListener.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package com.hedera.mirror.grpc.listener;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.PropertyNamingStrategy;\n+import io.vertx.core.Vertx;\n+import io.vertx.pgclient.PgConnectOptions;\n+import io.vertx.pgclient.pubsub.PgChannel;\n+import io.vertx.pgclient.pubsub.PgSubscriber;\n+import java.time.Duration;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import reactor.core.publisher.EmitterProcessor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.scheduler.Schedulers;\n+import reactor.util.retry.Retry;\n+\n+import com.hedera.mirror.grpc.DbProperties;\n+import com.hedera.mirror.grpc.domain.TopicMessage;\n+import com.hedera.mirror.grpc.domain.TopicMessageFilter;\n+\n+@Named\n+@Log4j2\n+public class NotifyingTopicListener implements TopicListener {\n+\n+    private final ObjectMapper objectMapper;\n+    private final Flux<TopicMessage> topicMessages;\n+    private final PgChannel channel;\n+\n+    public NotifyingTopicListener(DbProperties dbProperties, ListenerProperties listenerProperties) {\n+        this.objectMapper = new ObjectMapper().setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);\n+        PgConnectOptions connectOptions = new PgConnectOptions()\n+                .setDatabase(dbProperties.getName())\n+                .setHost(dbProperties.getHost())\n+                .setPassword(dbProperties.getPassword())\n+                .setPort(dbProperties.getPort())\n+                .setUser(dbProperties.getUsername());\n+\n+        Duration frequency = listenerProperties.getFrequency();\n+        Vertx vertx = Vertx.vertx();\n+        PgSubscriber subscriber = PgSubscriber.subscriber(vertx, connectOptions)\n+                .reconnectPolicy(retries -> {\n+                    log.warn(\"Attempting reconnect\");\n+                    return frequency.toMillis();\n+                });\n+\n+        // Connect asynchronously to avoid crashing the application on startup if the database is down\n+        vertx.setTimer(100L, v -> subscriber.connect(connectResult -> {\n+            if (connectResult.failed()) {\n+                throw new RuntimeException(connectResult.cause());\n+            }\n+            log.info(\"Connected to database\");\n+        }));\n+\n+        channel = subscriber.channel(\"topic_message\");\n+\n+        topicMessages = Flux.defer(() -> listen())\n+                .publishOn(Schedulers.boundedElastic())\n+                .map(this::toTopicMessage)\n+                .name(\"notify\")\n+                .metrics()\n+                .doFinally(s -> unlisten())\n+                .doOnError(t -> log.error(\"Error listening for messages\", t))\n+                .retryWhen(Retry.backoff(Long.MAX_VALUE, frequency).maxBackoff(frequency.multipliedBy(4L)))\n+                .share();\n+    }\n+\n+    @Override\n+    public Flux<TopicMessage> listen(TopicMessageFilter filter) {\n+        return topicMessages.filter(t -> filterMessage(t, filter))\n+                .doOnSubscribe(s -> log.info(\"Subscribing: {}\", filter));\n+    }\n+\n+    private boolean filterMessage(TopicMessage message, TopicMessageFilter filter) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk3NzEwNQ=="}, "originalCommit": {"oid": "9d35f8459215b060fe10d10492fb35d55a8f3563"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNDQxNjUxOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/listener/NotifyingTopicListener.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNzozNjo0MFrOGv_w-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxODo0NDozMVrOGwBzbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk4MDk4Ng==", "bodyText": "Similar to Shared poller maybe we should have a log for total messages and rate\n\"Finished listen with {} messages in {} ({}/s)\"", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/860#discussion_r452980986", "createdAt": "2020-07-10T17:36:40Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/listener/NotifyingTopicListener.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package com.hedera.mirror.grpc.listener;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.PropertyNamingStrategy;\n+import io.vertx.core.Vertx;\n+import io.vertx.pgclient.PgConnectOptions;\n+import io.vertx.pgclient.pubsub.PgChannel;\n+import io.vertx.pgclient.pubsub.PgSubscriber;\n+import java.time.Duration;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import reactor.core.publisher.EmitterProcessor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.scheduler.Schedulers;\n+import reactor.util.retry.Retry;\n+\n+import com.hedera.mirror.grpc.DbProperties;\n+import com.hedera.mirror.grpc.domain.TopicMessage;\n+import com.hedera.mirror.grpc.domain.TopicMessageFilter;\n+\n+@Named\n+@Log4j2\n+public class NotifyingTopicListener implements TopicListener {\n+\n+    private final ObjectMapper objectMapper;\n+    private final Flux<TopicMessage> topicMessages;\n+    private final PgChannel channel;\n+\n+    public NotifyingTopicListener(DbProperties dbProperties, ListenerProperties listenerProperties) {\n+        this.objectMapper = new ObjectMapper().setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);\n+        PgConnectOptions connectOptions = new PgConnectOptions()\n+                .setDatabase(dbProperties.getName())\n+                .setHost(dbProperties.getHost())\n+                .setPassword(dbProperties.getPassword())\n+                .setPort(dbProperties.getPort())\n+                .setUser(dbProperties.getUsername());\n+\n+        Duration frequency = listenerProperties.getFrequency();\n+        Vertx vertx = Vertx.vertx();\n+        PgSubscriber subscriber = PgSubscriber.subscriber(vertx, connectOptions)\n+                .reconnectPolicy(retries -> {\n+                    log.warn(\"Attempting reconnect\");\n+                    return frequency.toMillis();\n+                });\n+\n+        // Connect asynchronously to avoid crashing the application on startup if the database is down\n+        vertx.setTimer(100L, v -> subscriber.connect(connectResult -> {\n+            if (connectResult.failed()) {\n+                throw new RuntimeException(connectResult.cause());\n+            }\n+            log.info(\"Connected to database\");\n+        }));\n+\n+        channel = subscriber.channel(\"topic_message\");\n+\n+        topicMessages = Flux.defer(() -> listen())\n+                .publishOn(Schedulers.boundedElastic())\n+                .map(this::toTopicMessage)\n+                .name(\"notify\")\n+                .metrics()\n+                .doFinally(s -> unlisten())\n+                .doOnError(t -> log.error(\"Error listening for messages\", t))\n+                .retryWhen(Retry.backoff(Long.MAX_VALUE, frequency).maxBackoff(frequency.multipliedBy(4L)))\n+                .share();\n+    }\n+\n+    @Override\n+    public Flux<TopicMessage> listen(TopicMessageFilter filter) {\n+        return topicMessages.filter(t -> filterMessage(t, filter))\n+                .doOnSubscribe(s -> log.info(\"Subscribing: {}\", filter));\n+    }\n+\n+    private boolean filterMessage(TopicMessage message, TopicMessageFilter filter) {\n+        return message.getRealmNum() == filter.getRealmNum() &&\n+                message.getTopicNum() == filter.getTopicNum() &&\n+                message.getConsensusTimestamp() >= filter.getStartTimeLong();\n+    }\n+\n+    private Flux<String> listen() {\n+        EmitterProcessor<String> emitterProcessor = EmitterProcessor.create();\n+        channel.handler(json -> emitterProcessor.onNext(json));\n+        log.info(\"Listening for messages\");\n+        return emitterProcessor;\n+    }\n+\n+    private void unlisten() {\n+        channel.handler(null);\n+        log.info(\"Stopped listening for messages\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d35f8459215b060fe10d10492fb35d55a8f3563"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAxNDM4MA==", "bodyText": "But shared poller is polling so it is showing that log for that poll period that is common to all subscribers. Notify poller is an asynchronous, streaming publisher so there's no gap in messages at which to record messages. We could potentially keep track per subscriber what the rate is but we have similar info in the service layer. But maybe if we find that latter log useful we can add it at CompositeTopicListener at a later point in time.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/860#discussion_r453014380", "createdAt": "2020-07-10T18:44:31Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/listener/NotifyingTopicListener.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package com.hedera.mirror.grpc.listener;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.PropertyNamingStrategy;\n+import io.vertx.core.Vertx;\n+import io.vertx.pgclient.PgConnectOptions;\n+import io.vertx.pgclient.pubsub.PgChannel;\n+import io.vertx.pgclient.pubsub.PgSubscriber;\n+import java.time.Duration;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import reactor.core.publisher.EmitterProcessor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.scheduler.Schedulers;\n+import reactor.util.retry.Retry;\n+\n+import com.hedera.mirror.grpc.DbProperties;\n+import com.hedera.mirror.grpc.domain.TopicMessage;\n+import com.hedera.mirror.grpc.domain.TopicMessageFilter;\n+\n+@Named\n+@Log4j2\n+public class NotifyingTopicListener implements TopicListener {\n+\n+    private final ObjectMapper objectMapper;\n+    private final Flux<TopicMessage> topicMessages;\n+    private final PgChannel channel;\n+\n+    public NotifyingTopicListener(DbProperties dbProperties, ListenerProperties listenerProperties) {\n+        this.objectMapper = new ObjectMapper().setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);\n+        PgConnectOptions connectOptions = new PgConnectOptions()\n+                .setDatabase(dbProperties.getName())\n+                .setHost(dbProperties.getHost())\n+                .setPassword(dbProperties.getPassword())\n+                .setPort(dbProperties.getPort())\n+                .setUser(dbProperties.getUsername());\n+\n+        Duration frequency = listenerProperties.getFrequency();\n+        Vertx vertx = Vertx.vertx();\n+        PgSubscriber subscriber = PgSubscriber.subscriber(vertx, connectOptions)\n+                .reconnectPolicy(retries -> {\n+                    log.warn(\"Attempting reconnect\");\n+                    return frequency.toMillis();\n+                });\n+\n+        // Connect asynchronously to avoid crashing the application on startup if the database is down\n+        vertx.setTimer(100L, v -> subscriber.connect(connectResult -> {\n+            if (connectResult.failed()) {\n+                throw new RuntimeException(connectResult.cause());\n+            }\n+            log.info(\"Connected to database\");\n+        }));\n+\n+        channel = subscriber.channel(\"topic_message\");\n+\n+        topicMessages = Flux.defer(() -> listen())\n+                .publishOn(Schedulers.boundedElastic())\n+                .map(this::toTopicMessage)\n+                .name(\"notify\")\n+                .metrics()\n+                .doFinally(s -> unlisten())\n+                .doOnError(t -> log.error(\"Error listening for messages\", t))\n+                .retryWhen(Retry.backoff(Long.MAX_VALUE, frequency).maxBackoff(frequency.multipliedBy(4L)))\n+                .share();\n+    }\n+\n+    @Override\n+    public Flux<TopicMessage> listen(TopicMessageFilter filter) {\n+        return topicMessages.filter(t -> filterMessage(t, filter))\n+                .doOnSubscribe(s -> log.info(\"Subscribing: {}\", filter));\n+    }\n+\n+    private boolean filterMessage(TopicMessage message, TopicMessageFilter filter) {\n+        return message.getRealmNum() == filter.getRealmNum() &&\n+                message.getTopicNum() == filter.getTopicNum() &&\n+                message.getConsensusTimestamp() >= filter.getStartTimeLong();\n+    }\n+\n+    private Flux<String> listen() {\n+        EmitterProcessor<String> emitterProcessor = EmitterProcessor.create();\n+        channel.handler(json -> emitterProcessor.onNext(json));\n+        log.info(\"Listening for messages\");\n+        return emitterProcessor;\n+    }\n+\n+    private void unlisten() {\n+        channel.handler(null);\n+        log.info(\"Stopped listening for messages\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk4MDk4Ng=="}, "originalCommit": {"oid": "9d35f8459215b060fe10d10492fb35d55a8f3563"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNDQ3MTc4OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/listener/NotifyingTopicListener.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNzo1NTozNFrOGwAUNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxODo0MTo1MlrOGwBsMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk5MDAwNA==", "bodyText": "If there's a way to pull the notify time from this handler as part of it's in-built API that would be useful for metrics.\nIf not then consider my other suggestion to explore adding the approximate insert time to the notify operation.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/860#discussion_r452990004", "createdAt": "2020-07-10T17:55:34Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/listener/NotifyingTopicListener.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package com.hedera.mirror.grpc.listener;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.PropertyNamingStrategy;\n+import io.vertx.core.Vertx;\n+import io.vertx.pgclient.PgConnectOptions;\n+import io.vertx.pgclient.pubsub.PgChannel;\n+import io.vertx.pgclient.pubsub.PgSubscriber;\n+import java.time.Duration;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import reactor.core.publisher.EmitterProcessor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.scheduler.Schedulers;\n+import reactor.util.retry.Retry;\n+\n+import com.hedera.mirror.grpc.DbProperties;\n+import com.hedera.mirror.grpc.domain.TopicMessage;\n+import com.hedera.mirror.grpc.domain.TopicMessageFilter;\n+\n+@Named\n+@Log4j2\n+public class NotifyingTopicListener implements TopicListener {\n+\n+    private final ObjectMapper objectMapper;\n+    private final Flux<TopicMessage> topicMessages;\n+    private final PgChannel channel;\n+\n+    public NotifyingTopicListener(DbProperties dbProperties, ListenerProperties listenerProperties) {\n+        this.objectMapper = new ObjectMapper().setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);\n+        PgConnectOptions connectOptions = new PgConnectOptions()\n+                .setDatabase(dbProperties.getName())\n+                .setHost(dbProperties.getHost())\n+                .setPassword(dbProperties.getPassword())\n+                .setPort(dbProperties.getPort())\n+                .setUser(dbProperties.getUsername());\n+\n+        Duration frequency = listenerProperties.getFrequency();\n+        Vertx vertx = Vertx.vertx();\n+        PgSubscriber subscriber = PgSubscriber.subscriber(vertx, connectOptions)\n+                .reconnectPolicy(retries -> {\n+                    log.warn(\"Attempting reconnect\");\n+                    return frequency.toMillis();\n+                });\n+\n+        // Connect asynchronously to avoid crashing the application on startup if the database is down\n+        vertx.setTimer(100L, v -> subscriber.connect(connectResult -> {\n+            if (connectResult.failed()) {\n+                throw new RuntimeException(connectResult.cause());\n+            }\n+            log.info(\"Connected to database\");\n+        }));\n+\n+        channel = subscriber.channel(\"topic_message\");\n+\n+        topicMessages = Flux.defer(() -> listen())\n+                .publishOn(Schedulers.boundedElastic())\n+                .map(this::toTopicMessage)\n+                .name(\"notify\")\n+                .metrics()\n+                .doFinally(s -> unlisten())\n+                .doOnError(t -> log.error(\"Error listening for messages\", t))\n+                .retryWhen(Retry.backoff(Long.MAX_VALUE, frequency).maxBackoff(frequency.multipliedBy(4L)))\n+                .share();\n+    }\n+\n+    @Override\n+    public Flux<TopicMessage> listen(TopicMessageFilter filter) {\n+        return topicMessages.filter(t -> filterMessage(t, filter))\n+                .doOnSubscribe(s -> log.info(\"Subscribing: {}\", filter));\n+    }\n+\n+    private boolean filterMessage(TopicMessage message, TopicMessageFilter filter) {\n+        return message.getRealmNum() == filter.getRealmNum() &&\n+                message.getTopicNum() == filter.getTopicNum() &&\n+                message.getConsensusTimestamp() >= filter.getStartTimeLong();\n+    }\n+\n+    private Flux<String> listen() {\n+        EmitterProcessor<String> emitterProcessor = EmitterProcessor.create();\n+        channel.handler(json -> emitterProcessor.onNext(json));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d35f8459215b060fe10d10492fb35d55a8f3563"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAxMjUyOA==", "bodyText": "We already have a metric for notify time in CompositeTopicListener called hedera.mirror.publish.latency. That's why I had you add it there so it's reusable.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/860#discussion_r453012528", "createdAt": "2020-07-10T18:41:52Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/listener/NotifyingTopicListener.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package com.hedera.mirror.grpc.listener;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.PropertyNamingStrategy;\n+import io.vertx.core.Vertx;\n+import io.vertx.pgclient.PgConnectOptions;\n+import io.vertx.pgclient.pubsub.PgChannel;\n+import io.vertx.pgclient.pubsub.PgSubscriber;\n+import java.time.Duration;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import reactor.core.publisher.EmitterProcessor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.scheduler.Schedulers;\n+import reactor.util.retry.Retry;\n+\n+import com.hedera.mirror.grpc.DbProperties;\n+import com.hedera.mirror.grpc.domain.TopicMessage;\n+import com.hedera.mirror.grpc.domain.TopicMessageFilter;\n+\n+@Named\n+@Log4j2\n+public class NotifyingTopicListener implements TopicListener {\n+\n+    private final ObjectMapper objectMapper;\n+    private final Flux<TopicMessage> topicMessages;\n+    private final PgChannel channel;\n+\n+    public NotifyingTopicListener(DbProperties dbProperties, ListenerProperties listenerProperties) {\n+        this.objectMapper = new ObjectMapper().setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);\n+        PgConnectOptions connectOptions = new PgConnectOptions()\n+                .setDatabase(dbProperties.getName())\n+                .setHost(dbProperties.getHost())\n+                .setPassword(dbProperties.getPassword())\n+                .setPort(dbProperties.getPort())\n+                .setUser(dbProperties.getUsername());\n+\n+        Duration frequency = listenerProperties.getFrequency();\n+        Vertx vertx = Vertx.vertx();\n+        PgSubscriber subscriber = PgSubscriber.subscriber(vertx, connectOptions)\n+                .reconnectPolicy(retries -> {\n+                    log.warn(\"Attempting reconnect\");\n+                    return frequency.toMillis();\n+                });\n+\n+        // Connect asynchronously to avoid crashing the application on startup if the database is down\n+        vertx.setTimer(100L, v -> subscriber.connect(connectResult -> {\n+            if (connectResult.failed()) {\n+                throw new RuntimeException(connectResult.cause());\n+            }\n+            log.info(\"Connected to database\");\n+        }));\n+\n+        channel = subscriber.channel(\"topic_message\");\n+\n+        topicMessages = Flux.defer(() -> listen())\n+                .publishOn(Schedulers.boundedElastic())\n+                .map(this::toTopicMessage)\n+                .name(\"notify\")\n+                .metrics()\n+                .doFinally(s -> unlisten())\n+                .doOnError(t -> log.error(\"Error listening for messages\", t))\n+                .retryWhen(Retry.backoff(Long.MAX_VALUE, frequency).maxBackoff(frequency.multipliedBy(4L)))\n+                .share();\n+    }\n+\n+    @Override\n+    public Flux<TopicMessage> listen(TopicMessageFilter filter) {\n+        return topicMessages.filter(t -> filterMessage(t, filter))\n+                .doOnSubscribe(s -> log.info(\"Subscribing: {}\", filter));\n+    }\n+\n+    private boolean filterMessage(TopicMessage message, TopicMessageFilter filter) {\n+        return message.getRealmNum() == filter.getRealmNum() &&\n+                message.getTopicNum() == filter.getTopicNum() &&\n+                message.getConsensusTimestamp() >= filter.getStartTimeLong();\n+    }\n+\n+    private Flux<String> listen() {\n+        EmitterProcessor<String> emitterProcessor = EmitterProcessor.create();\n+        channel.handler(json -> emitterProcessor.onNext(json));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk5MDAwNA=="}, "originalCommit": {"oid": "9d35f8459215b060fe10d10492fb35d55a8f3563"}, "originalPosition": 101}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 905, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}