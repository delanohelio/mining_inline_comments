{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcyODM5MTM3", "number": 2663, "title": "Initial implementation of the authorizations endpoints", "bodyText": "This is the implementation of the authorization features and authorization endpoints according to the REST Contract in\nhttps://github.com/DSpace/Rest7Contract/blob/master/features.md\nhttps://github.com/DSpace/Rest7Contract/blob/master/authorizations.md\nDONE:\n\ngeneral infrastructure to support pluggable AuthorizationFeature\nSample Features withdrawn, reinstate, cclicense\ncomplete features endpoint and integration tests\nsingle authorization endpoint and integration tests\nmerge with changes from the master (the switch from int to string for the type create logical conflict)\nimplement the search method in the authorization endpoint and related ITs\nadd ITs for the first sample features\nContract update PR: DSpace/RestContract#103", "createdAt": "2020-02-09T15:14:41Z", "url": "https://github.com/DSpace/DSpace/pull/2663", "merged": true, "mergeCommit": {"oid": "0039b309d11e3d55a2a92699b25458fe9bfc4740"}, "closed": true, "closedAt": "2020-03-23T12:37:42Z", "author": {"login": "abollini"}, "timelineItems": {"totalCount": 43, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcCpz4BAH2gAyMzcyODM5MTM3OjAyMDFlZjEwNTVmY2RiOTU2MjkzOTg4OGRhY2UxZDhjNjUwYjY2NjI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcQchksgFqTM3OTMzODcxMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "0201ef1055fcdb9562939888dace1d8c650b6662", "author": {"user": {"login": "abollini", "name": "Andrea Bollini"}}, "url": "https://github.com/DSpace/DSpace/commit/0201ef1055fcdb9562939888dace1d8c650b6662", "committedDate": "2020-02-09T14:56:42Z", "message": "Initial implementation of the authorizations endpoints"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3NTIwMTAx", "url": "https://github.com/DSpace/DSpace/pull/2663#pullrequestreview-357520101", "createdAt": "2020-02-12T14:58:19Z", "commit": {"oid": "0201ef1055fcdb9562939888dace1d8c650b6662"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "214d7dfc9b88e1cff51da6218a2559b216401a11", "author": {"user": {"login": "abollini", "name": "Andrea Bollini"}}, "url": "https://github.com/DSpace/DSpace/commit/214d7dfc9b88e1cff51da6218a2559b216401a11", "committedDate": "2020-02-15T23:38:58Z", "message": "DS-4413 complete implementation of the authz infrastructure and ITs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f20954e9d38401ebd50f70cf65d1d196ad1a7e4", "author": {"user": {"login": "abollini", "name": "Andrea Bollini"}}, "url": "https://github.com/DSpace/DSpace/commit/4f20954e9d38401ebd50f70cf65d1d196ad1a7e4", "committedDate": "2020-02-16T15:59:29Z", "message": "DS-4413 fix checkstyle and add ITs for the withdraw, reinstate and cclicense feature"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a7f9e7ada1556525744f820bc7a50618ff914e0", "author": {"user": {"login": "abollini", "name": "Andrea Bollini"}}, "url": "https://github.com/DSpace/DSpace/commit/9a7f9e7ada1556525744f820bc7a50618ff914e0", "committedDate": "2020-02-16T23:53:52Z", "message": "Merge branch 'master' of https://github.com/DSpace/DSpace into authz"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3524f10cccd0672ae3343dd884b6bf97720b624b", "author": {"user": {"login": "abollini", "name": "Andrea Bollini"}}, "url": "https://github.com/DSpace/DSpace/commit/3524f10cccd0672ae3343dd884b6bf97720b624b", "committedDate": "2020-02-17T22:10:38Z", "message": "DS-4413 fix checkstyle and ITs after projection and IndexableObject refactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1d64d8932b15922f4baea4f81d77961d5471d7b9", "author": {"user": {"login": "abollini", "name": "Andrea Bollini"}}, "url": "https://github.com/DSpace/DSpace/commit/1d64d8932b15922f4baea4f81d77961d5471d7b9", "committedDate": "2020-02-18T07:17:42Z", "message": "DS-4413 exclude uniqueType from the json output"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwMjUzMTYw", "url": "https://github.com/DSpace/DSpace/pull/2663#pullrequestreview-360253160", "createdAt": "2020-02-18T11:10:06Z", "commit": {"oid": "1d64d8932b15922f4baea4f81d77961d5471d7b9"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyNzk0OTI2", "url": "https://github.com/DSpace/DSpace/pull/2663#pullrequestreview-362794926", "createdAt": "2020-02-21T17:30:09Z", "commit": {"oid": "1d64d8932b15922f4baea4f81d77961d5471d7b9"}, "state": "COMMENTED", "comments": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxNzozMDowOVrOFs-zeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxODoyODoxOFrOFtAacQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxMDY0OQ==", "bodyText": "Please don't cache the ConfigurationService in a static variable reference. This will cause auto-reloading of the configuration to no longer work properly (i.e. this is a step backwards as the AuthorizationConfiguration would require restarting Tomcat to reload its configurations).  Additionally, keeping the configuration in a static variable means that no tests (unit or integration) can override the settings in AuthorizeConfiguration.\nInstead of doing this, just use DSpaceServicesFactory.getInstance().getConfigurationService() everywhere in this class where you require a static reference.  That will ensure reloading still works and you are always using the latest ConfigurationService instead of a local cache of it.", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382710649", "createdAt": "2020-02-21T17:30:09Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/authorize/AuthorizeConfiguration.java", "diffHunk": "@@ -16,172 +17,35 @@\n  * @author bollini\n  */\n public class AuthorizeConfiguration {\n-\n-    private static boolean can_communityAdmin_group = ConfigurationManager\n-        .getBooleanProperty(\"core.authorization.community-admin.group\",\n-                            true);\n-\n-    // subcommunities and collections\n-    private static boolean can_communityAdmin_createSubelement = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.create-subelement\",\n-            true);\n-\n-    private static boolean can_communityAdmin_deleteSubelement = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.delete-subelement\",\n-            true);\n-\n-    private static boolean can_communityAdmin_policies = ConfigurationManager\n-        .getBooleanProperty(\"core.authorization.community-admin.policies\",\n-                            true);\n-\n-    private static boolean can_communityAdmin_adminGroup = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.admin-group\", true);\n-\n-    private static boolean can_communityAdmin_collectionPolicies = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.collection.policies\",\n-            true);\n-\n-    private static boolean can_communityAdmin_collectionTemplateItem = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.collection.template-item\",\n-            true);\n-\n-    private static boolean can_communityAdmin_collectionSubmitters = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.collection.submitters\",\n-            true);\n-\n-    private static boolean can_communityAdmin_collectionWorkflows = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.collection.workflows\",\n-            true);\n-\n-    private static boolean can_communityAdmin_collectionAdminGroup = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.collection.admin-group\",\n-            true);\n-\n-    private static boolean can_communityAdmin_itemDelete = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.item.delete\", true);\n-\n-    private static boolean can_communityAdmin_itemWithdraw = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.item.withdraw\", true);\n-\n-    private static boolean can_communityAdmin_itemReinstatiate = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.item.reinstatiate\",\n-            true);\n-\n-    private static boolean can_communityAdmin_itemPolicies = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.item.policies\", true);\n-\n-    // # also bundle\n-    private static boolean can_communityAdmin_itemCreateBitstream = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.item.create-bitstream\",\n-            true);\n-\n-    private static boolean can_communityAdmin_itemDeleteBitstream = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.item.delete-bitstream\",\n-            true);\n-\n-    private static boolean can_communityAdmin_itemAdminccLicense = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.item-admin.cc-license\",\n-            true);\n-\n-    // # COLLECTION ADMIN\n-    private static boolean can_collectionAdmin_policies = ConfigurationManager\n-        .getBooleanProperty(\"core.authorization.collection-admin.policies\",\n-                            true);\n-\n-    private static boolean can_collectionAdmin_templateItem = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.template-item\", true);\n-\n-    private static boolean can_collectionAdmin_submitters = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.submitters\", true);\n-\n-    private static boolean can_collectionAdmin_workflows = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.workflows\", true);\n-\n-    private static boolean can_collectionAdmin_adminGroup = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.admin-group\", true);\n-\n-    private static boolean can_collectionAdmin_itemDelete = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.item.delete\", true);\n-\n-    private static boolean can_collectionAdmin_itemWithdraw = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.item.withdraw\", true);\n-\n-    private static boolean can_collectionAdmin_itemReinstatiate = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.item.reinstatiate\",\n-            true);\n-\n-    private static boolean can_collectionAdmin_itemPolicies = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.item.policies\", true);\n-\n-    // # also bundle\n-    private static boolean can_collectionAdmin_itemCreateBitstream = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.item.create-bitstream\",\n-            true);\n-\n-    private static boolean can_collectionAdmin_itemDeleteBitstream = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.item.delete-bitstream\",\n-            true);\n-\n-    private static boolean can_collectionAdmin_itemAdminccLicense = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.item-admin.cc-license\",\n-            true);\n-\n-    // # ITEM ADMIN\n-    private static boolean can_itemAdmin_policies = ConfigurationManager\n-        .getBooleanProperty(\"core.authorization.item-admin.policies\", true);\n-\n-    // # also bundle\n-    private static boolean can_itemAdmin_createBitstream = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.item-admin.create-bitstream\", true);\n-\n-    private static boolean can_itemAdmin_deleteBitstream = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.item-admin.delete-bitstream\", true);\n-\n-    private static boolean can_itemAdmin_ccLicense = ConfigurationManager\n-        .getBooleanProperty(\"core.authorization.item-admin.cc-license\",\n-                            true);\n+    /**\n+     * A static reference to the {@link ConfigurationService} see the init method for initialization\n+     */\n+    private static ConfigurationService configurationService;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d64d8932b15922f4baea4f81d77961d5471d7b9"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxMTUxNQ==", "bodyText": "This init() can be removed. As noted above, we don't need/want a static reference to configurations.", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382711515", "createdAt": "2020-02-21T17:32:00Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/authorize/AuthorizeConfiguration.java", "diffHunk": "@@ -16,172 +17,35 @@\n  * @author bollini\n  */\n public class AuthorizeConfiguration {\n-\n-    private static boolean can_communityAdmin_group = ConfigurationManager\n-        .getBooleanProperty(\"core.authorization.community-admin.group\",\n-                            true);\n-\n-    // subcommunities and collections\n-    private static boolean can_communityAdmin_createSubelement = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.create-subelement\",\n-            true);\n-\n-    private static boolean can_communityAdmin_deleteSubelement = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.delete-subelement\",\n-            true);\n-\n-    private static boolean can_communityAdmin_policies = ConfigurationManager\n-        .getBooleanProperty(\"core.authorization.community-admin.policies\",\n-                            true);\n-\n-    private static boolean can_communityAdmin_adminGroup = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.admin-group\", true);\n-\n-    private static boolean can_communityAdmin_collectionPolicies = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.collection.policies\",\n-            true);\n-\n-    private static boolean can_communityAdmin_collectionTemplateItem = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.collection.template-item\",\n-            true);\n-\n-    private static boolean can_communityAdmin_collectionSubmitters = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.collection.submitters\",\n-            true);\n-\n-    private static boolean can_communityAdmin_collectionWorkflows = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.collection.workflows\",\n-            true);\n-\n-    private static boolean can_communityAdmin_collectionAdminGroup = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.collection.admin-group\",\n-            true);\n-\n-    private static boolean can_communityAdmin_itemDelete = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.item.delete\", true);\n-\n-    private static boolean can_communityAdmin_itemWithdraw = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.item.withdraw\", true);\n-\n-    private static boolean can_communityAdmin_itemReinstatiate = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.item.reinstatiate\",\n-            true);\n-\n-    private static boolean can_communityAdmin_itemPolicies = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.item.policies\", true);\n-\n-    // # also bundle\n-    private static boolean can_communityAdmin_itemCreateBitstream = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.item.create-bitstream\",\n-            true);\n-\n-    private static boolean can_communityAdmin_itemDeleteBitstream = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.item.delete-bitstream\",\n-            true);\n-\n-    private static boolean can_communityAdmin_itemAdminccLicense = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.item-admin.cc-license\",\n-            true);\n-\n-    // # COLLECTION ADMIN\n-    private static boolean can_collectionAdmin_policies = ConfigurationManager\n-        .getBooleanProperty(\"core.authorization.collection-admin.policies\",\n-                            true);\n-\n-    private static boolean can_collectionAdmin_templateItem = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.template-item\", true);\n-\n-    private static boolean can_collectionAdmin_submitters = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.submitters\", true);\n-\n-    private static boolean can_collectionAdmin_workflows = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.workflows\", true);\n-\n-    private static boolean can_collectionAdmin_adminGroup = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.admin-group\", true);\n-\n-    private static boolean can_collectionAdmin_itemDelete = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.item.delete\", true);\n-\n-    private static boolean can_collectionAdmin_itemWithdraw = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.item.withdraw\", true);\n-\n-    private static boolean can_collectionAdmin_itemReinstatiate = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.item.reinstatiate\",\n-            true);\n-\n-    private static boolean can_collectionAdmin_itemPolicies = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.item.policies\", true);\n-\n-    // # also bundle\n-    private static boolean can_collectionAdmin_itemCreateBitstream = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.item.create-bitstream\",\n-            true);\n-\n-    private static boolean can_collectionAdmin_itemDeleteBitstream = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.item.delete-bitstream\",\n-            true);\n-\n-    private static boolean can_collectionAdmin_itemAdminccLicense = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.item-admin.cc-license\",\n-            true);\n-\n-    // # ITEM ADMIN\n-    private static boolean can_itemAdmin_policies = ConfigurationManager\n-        .getBooleanProperty(\"core.authorization.item-admin.policies\", true);\n-\n-    // # also bundle\n-    private static boolean can_itemAdmin_createBitstream = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.item-admin.create-bitstream\", true);\n-\n-    private static boolean can_itemAdmin_deleteBitstream = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.item-admin.delete-bitstream\", true);\n-\n-    private static boolean can_itemAdmin_ccLicense = ConfigurationManager\n-        .getBooleanProperty(\"core.authorization.item-admin.cc-license\",\n-                            true);\n+    /**\n+     * A static reference to the {@link ConfigurationService} see the init method for initialization\n+     */\n+    private static ConfigurationService configurationService;\n \n     /**\n      * Default constructor\n      */\n     private AuthorizeConfiguration() { }\n \n+    /**\n+     * Complete the initialization of the class retrieving a reference to the {@link ConfigurationService}. MUST be\n+     * called at the start of each method\n+     */\n+    private synchronized static void init() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d64d8932b15922f4baea4f81d77961d5471d7b9"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxMjAzMQ==", "bodyText": "Here's where you could just replace this line with:\nreturn DSpaceServicesFactory.getInstance().getConfigurationService().getBooleanProperty(\"core.authorization.community-admin.group\", true);\nThis same replacement will work for all the static methods in this class.", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382712031", "createdAt": "2020-02-21T17:33:12Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/authorize/AuthorizeConfiguration.java", "diffHunk": "@@ -16,172 +17,35 @@\n  * @author bollini\n  */\n public class AuthorizeConfiguration {\n-\n-    private static boolean can_communityAdmin_group = ConfigurationManager\n-        .getBooleanProperty(\"core.authorization.community-admin.group\",\n-                            true);\n-\n-    // subcommunities and collections\n-    private static boolean can_communityAdmin_createSubelement = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.create-subelement\",\n-            true);\n-\n-    private static boolean can_communityAdmin_deleteSubelement = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.delete-subelement\",\n-            true);\n-\n-    private static boolean can_communityAdmin_policies = ConfigurationManager\n-        .getBooleanProperty(\"core.authorization.community-admin.policies\",\n-                            true);\n-\n-    private static boolean can_communityAdmin_adminGroup = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.admin-group\", true);\n-\n-    private static boolean can_communityAdmin_collectionPolicies = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.collection.policies\",\n-            true);\n-\n-    private static boolean can_communityAdmin_collectionTemplateItem = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.collection.template-item\",\n-            true);\n-\n-    private static boolean can_communityAdmin_collectionSubmitters = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.collection.submitters\",\n-            true);\n-\n-    private static boolean can_communityAdmin_collectionWorkflows = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.collection.workflows\",\n-            true);\n-\n-    private static boolean can_communityAdmin_collectionAdminGroup = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.collection.admin-group\",\n-            true);\n-\n-    private static boolean can_communityAdmin_itemDelete = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.item.delete\", true);\n-\n-    private static boolean can_communityAdmin_itemWithdraw = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.item.withdraw\", true);\n-\n-    private static boolean can_communityAdmin_itemReinstatiate = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.item.reinstatiate\",\n-            true);\n-\n-    private static boolean can_communityAdmin_itemPolicies = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.item.policies\", true);\n-\n-    // # also bundle\n-    private static boolean can_communityAdmin_itemCreateBitstream = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.item.create-bitstream\",\n-            true);\n-\n-    private static boolean can_communityAdmin_itemDeleteBitstream = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.item.delete-bitstream\",\n-            true);\n-\n-    private static boolean can_communityAdmin_itemAdminccLicense = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.community-admin.item-admin.cc-license\",\n-            true);\n-\n-    // # COLLECTION ADMIN\n-    private static boolean can_collectionAdmin_policies = ConfigurationManager\n-        .getBooleanProperty(\"core.authorization.collection-admin.policies\",\n-                            true);\n-\n-    private static boolean can_collectionAdmin_templateItem = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.template-item\", true);\n-\n-    private static boolean can_collectionAdmin_submitters = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.submitters\", true);\n-\n-    private static boolean can_collectionAdmin_workflows = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.workflows\", true);\n-\n-    private static boolean can_collectionAdmin_adminGroup = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.admin-group\", true);\n-\n-    private static boolean can_collectionAdmin_itemDelete = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.item.delete\", true);\n-\n-    private static boolean can_collectionAdmin_itemWithdraw = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.item.withdraw\", true);\n-\n-    private static boolean can_collectionAdmin_itemReinstatiate = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.item.reinstatiate\",\n-            true);\n-\n-    private static boolean can_collectionAdmin_itemPolicies = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.item.policies\", true);\n-\n-    // # also bundle\n-    private static boolean can_collectionAdmin_itemCreateBitstream = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.item.create-bitstream\",\n-            true);\n-\n-    private static boolean can_collectionAdmin_itemDeleteBitstream = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.item.delete-bitstream\",\n-            true);\n-\n-    private static boolean can_collectionAdmin_itemAdminccLicense = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.collection-admin.item-admin.cc-license\",\n-            true);\n-\n-    // # ITEM ADMIN\n-    private static boolean can_itemAdmin_policies = ConfigurationManager\n-        .getBooleanProperty(\"core.authorization.item-admin.policies\", true);\n-\n-    // # also bundle\n-    private static boolean can_itemAdmin_createBitstream = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.item-admin.create-bitstream\", true);\n-\n-    private static boolean can_itemAdmin_deleteBitstream = ConfigurationManager\n-        .getBooleanProperty(\n-            \"core.authorization.item-admin.delete-bitstream\", true);\n-\n-    private static boolean can_itemAdmin_ccLicense = ConfigurationManager\n-        .getBooleanProperty(\"core.authorization.item-admin.cc-license\",\n-                            true);\n+    /**\n+     * A static reference to the {@link ConfigurationService} see the init method for initialization\n+     */\n+    private static ConfigurationService configurationService;\n \n     /**\n      * Default constructor\n      */\n     private AuthorizeConfiguration() { }\n \n+    /**\n+     * Complete the initialization of the class retrieving a reference to the {@link ConfigurationService}. MUST be\n+     * called at the start of each method\n+     */\n+    private synchronized static void init() {\n+        if (configurationService != null) {\n+            return;\n+        }\n+        configurationService = new DSpace().getConfigurationService();\n+    }\n     /**\n      * Are community admins allowed to create new, not strictly community\n      * related, group?\n      *\n      * @return true/false\n      */\n     public static boolean canCommunityAdminPerformGroupCreation() {\n-        return can_communityAdmin_group;\n+        init();\n+        return configurationService.getBooleanProperty(\"core.authorization.community-admin.group\", true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d64d8932b15922f4baea4f81d77961d5471d7b9"}, "originalPosition": 195}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxMzY2OQ==", "bodyText": "It'd be useful to provide an example ID in this JavaDocs, just to clarify the exact structure of this ID.  Documenting the exact format here is very important as later JavaDocs (in other methods) reference this method's Javadocs.", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382713669", "createdAt": "2020-02-21T17:36:49Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/authorization/Authorization.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.authorization;\n+\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.content.Site;\n+import org.dspace.discovery.IndexableObject;\n+import org.dspace.eperson.EPerson;\n+\n+/**\n+ * An authorization is the right for a specific {@link EPerson}, eventually null to indicate unauthenticated users, to\n+ * use a specific {@link AuthorizationFeature} on a defined object. The target object must implement the\n+ * {@link IndexableObject} interface so to have an unique ID and type\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+public class Authorization {\n+    /**\n+     * the user authorized to use the feature. <code>null</code> mean unauthenticated user\n+     */\n+    private EPerson eperson;\n+\n+    /**\n+     * the feature that is authorized to be used\n+     */\n+    private AuthorizationFeature feature;\n+\n+    /**\n+     * the object where the feature can be used. Not null, for repository wide feature use the {@link Site} object\n+     */\n+    private BaseObjectRest object;\n+\n+    public Authorization() {\n+    }\n+\n+    public Authorization(EPerson eperson, AuthorizationFeature feature, BaseObjectRest object) {\n+        super();\n+        this.eperson = eperson;\n+        this.feature = feature;\n+        this.object = object;\n+    }\n+\n+\n+    /**\n+     * \n+     * @return the user authorized to use the feature. <code>null</code> mean unauthenticated user\n+     */\n+    public EPerson getEperson() {\n+        return eperson;\n+    }\n+\n+    /**\n+     * \n+     * @param eperson\n+     *            the user authorized to use the feature. <code>null</code> mean unauthenticated user\n+     */\n+    public void setEperson(EPerson eperson) {\n+        this.eperson = eperson;\n+    }\n+\n+    /**\n+     * \n+     * @return the feature that is authorized to be used\n+     */\n+    public AuthorizationFeature getFeature() {\n+        return feature;\n+    }\n+\n+    /**\n+     * \n+     * @param feature\n+     *            the feature that is authorized to be used\n+     */\n+    public void setFeature(AuthorizationFeature feature) {\n+        this.feature = feature;\n+    }\n+\n+    /**\n+     * \n+     * @return the object where the feature can be used. Not null, for repository wide feature use the {@link Site}\n+     *         object\n+     */\n+    public BaseObjectRest getObject() {\n+        return object;\n+    }\n+\n+    /**\n+     * \n+     * @param object\n+     *            the object where the feature can be used. Not null, for repository wide feature use the {@link Site}\n+     *            object\n+     */\n+    public void setObject(BaseObjectRest object) {\n+        this.object = object;\n+    }\n+\n+\n+    /**\n+     * \n+     * @return an unique business identifier generated by concatenation of eperson uuid (if any), feature name and\n+     *         object unique identifier", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d64d8932b15922f4baea4f81d77961d5471d7b9"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxNDg3OA==", "bodyText": "I think you mean the SiteRest object in this comment.  The Site object is not a valid BaseObjectRest object, but the SiteRest object is.", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382714878", "createdAt": "2020-02-21T17:39:29Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/authorization/AuthorizationFeature.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.authorization;\n+\n+import java.sql.SQLException;\n+\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.app.rest.model.RestModel;\n+import org.dspace.content.Site;\n+import org.dspace.core.Context;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+/**\n+ * A feature is the representation of a business goal used in the Authorization endpoint to declare what an user can do\n+ * on a specific object.\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+public interface AuthorizationFeature {\n+    /**\n+     * Check if the eperson in the provided context, or the anonymous user if not loggedin, has access to the feature\n+     * for the requested object\n+     * \n+     * @param context\n+     *            the DSpace Context\n+     * @param object\n+     *            the object target by the feature (MUST be NOT null). Use the {@link Site} object for repository wide", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d64d8932b15922f4baea4f81d77961d5471d7b9"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxNTA5MQ==", "bodyText": "Again, should reference SiteRest object, not Site", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382715091", "createdAt": "2020-02-21T17:39:59Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/authorization/AuthorizationFeatureService.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.authorization;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.content.Site;\n+import org.dspace.core.Context;\n+\n+/**\n+ * This service provides access to the Authorization Features and check if the feature is allowed or not in a specific\n+ * context and object.\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+public interface AuthorizationFeatureService {\n+    /**\n+     * Check if the eperson in the provided context, or the anonymous user if not loggedin, has access to the requested\n+     * feature for the requested object\n+     * \n+     * @param context\n+     *            the DSpace Context\n+     * @param feature\n+     *            the Authorization Feature to check\n+     * @param object\n+     *            the object target by the feature. Passing a null object always return false. To check repository wide\n+     *            feature pass the {@link Site} object", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d64d8932b15922f4baea4f81d77961d5471d7b9"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxNzc0NQ==", "bodyText": "It's unclear to me why this commented out block of code exists here?  It seems like you could remove it, and just add a inline comment (above the return statement) saying something like :\n// Loops through all features, returning any that match the given typeID", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382717745", "createdAt": "2020-02-21T17:45:36Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/authorization/impl/AuthorizationFeatureServiceImpl.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.authorization.impl;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.core.Context;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+/**\n+ * This is the default implementation of the {@link AuthorizationFeatureService}. It is based on the spring autowiring\n+ * feature to discover all the features available in the system\n+ * \n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ *\n+ */\n+@Service\n+public class AuthorizationFeatureServiceImpl implements AuthorizationFeatureService {\n+    @Autowired\n+    private List<AuthorizationFeature> features;\n+\n+    @Autowired\n+    private Utils utils;\n+\n+    @Override\n+    public boolean isAuthorized(Context context, AuthorizationFeature feature, BaseObjectRest object)\n+            throws SQLException {\n+        if (object == null) {\n+            // the authorization interface require that the object is not null\n+            return false;\n+        }\n+\n+        if (feature == null\n+                || !ArrayUtils.contains(feature.getSupportedTypes(), object.getUniqueType())) {\n+            return false;\n+        }\n+\n+        return feature.isAuthorized(context, object);\n+    }\n+\n+    @Override\n+    public List<AuthorizationFeature> findAll() {\n+        return features;\n+    }\n+\n+    @Override\n+    public AuthorizationFeature find(String name) {\n+        for (AuthorizationFeature feature : features) {\n+            if (StringUtils.equals(name, feature.getName())) {\n+                return feature;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public List<AuthorizationFeature> findByResourceType(String typeID) {\n+        return features\n+                .stream()\n+                .filter(f -> ArrayUtils.contains(f.getSupportedTypes(), typeID))\n+                .collect(Collectors.toList());\n+//        List<AuthorizationFeature> foundFeatures = new ArrayList<AuthorizationFeature>();\n+//        for (AuthorizationFeature f : features) {\n+//            if (ArrayUtils.contains(f.getSupportedTypes(), typeID)) {\n+//                foundFeatures.add(f);\n+//            }\n+//        }\n+//        return foundFeatures;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d64d8932b15922f4baea4f81d77961d5471d7b9"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcyMTgxMw==", "bodyText": "This bit of code looks very odd at a glance. Could you add an inline comment to describe it?\nIt looks like you are setting the user to the current user by default, but then changing it to the epersonUuid user when that is not null.", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382721813", "createdAt": "2020-02-21T17:55:01Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/AuthorizationRestRepository.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.repository;\n+\n+import java.io.Serializable;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.app.rest.Parameter;\n+import org.dspace.app.rest.SearchRestMethod;\n+import org.dspace.app.rest.authorization.Authorization;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.exception.RepositoryMethodNotImplementedException;\n+import org.dspace.app.rest.exception.RepositoryNotFoundException;\n+import org.dspace.app.rest.model.AuthorizationRest;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.authorize.AuthorizeException;\n+import org.dspace.authorize.service.AuthorizeService;\n+import org.dspace.core.Context;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.service.EPersonService;\n+import org.dspace.services.ConfigurationService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Component;\n+\n+\n+/**\n+ * This is the repository responsible to manage Authorization Rest object\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+\n+@Component(AuthorizationRest.CATEGORY + \".\" + AuthorizationRest.NAME)\n+public class AuthorizationRestRepository extends DSpaceRestRepository<AuthorizationRest, String> {\n+\n+    private static final Logger log = LoggerFactory.getLogger(AuthorizationRestRepository.class);\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private AuthorizationRestUtil authorizationRestUtil;\n+\n+    @Autowired\n+    private AuthorizeService authorizeService;\n+\n+    @Autowired\n+    private EPersonService epersonService;\n+\n+    @Autowired\n+    protected ConverterService converter;\n+\n+    @Autowired\n+    ConfigurationService configurationService;\n+\n+    @Override\n+    @PreAuthorize(\"hasPermission(#id, 'authorization', 'READ')\")\n+    public AuthorizationRest findOne(Context context, String id) {\n+\n+        AuthorizationRest authorizationRest = null;\n+\n+        String featureName;\n+        try {\n+            featureName = authorizationRestUtil.getFeatureName(id);\n+        } catch (IllegalArgumentException e) {\n+            log.warn(e.getMessage(), e);\n+            return null;\n+        }\n+        try {\n+            BaseObjectRest object = null;\n+            try {\n+                object = authorizationRestUtil.getObject(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Object informations not found in the specified id \" + id, e);\n+                return null;\n+            }\n+\n+            AuthorizationFeature authorizationFeature = null;\n+            if (featureName != null) {\n+                authorizationFeature = authorizationFeatureService.find(featureName);\n+            }\n+\n+            if (authorizationFeature == null) {\n+                return null;\n+            }\n+\n+            EPerson user;\n+            try {\n+                user = authorizationRestUtil.getEperson(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Invalid eperson informations in the specified id \" + id, e);\n+                return null;\n+            }\n+            EPerson currUser = context.getCurrentUser();\n+            context.setCurrentUser(user);\n+\n+            if (authorizationFeatureService.isAuthorized(context, authorizationFeature, object)) {\n+                Authorization authz = new Authorization();\n+                authz.setEperson(user);\n+                authz.setFeature(authorizationFeature);\n+                authz.setObject(object);\n+                authorizationRest = converter.toRest(authz, utils.obtainProjection());\n+            }\n+            context.setCurrentUser(currUser);\n+        } catch (SQLException e) {\n+            throw new RuntimeException(e.getMessage(), e);\n+        }\n+\n+        return authorizationRest;\n+    }\n+\n+\n+    /**\n+     * It returns the list of matching available authorizations granted to the specified eperson or to the anonymous\n+     * user. Only administrators and the user identified by the epersonUuid parameter can access this method\n+     *\n+     * \n+     * @param context\n+     *            the DSpace Context\n+     * @param uri\n+     *            the uri of the object to check the authorization against\n+     * @param epersonUuid\n+     *            the eperson uuid to use in the authorization evaluation\n+     * @param featureName\n+     *            limit the authorization check to only the feature identified via its name\n+     * @param pageable\n+     *            the pagination options\n+     * @return the list of matching authorization available for the requested user and object, filtered by feature if\n+     *         provided\n+     * @throws AuthorizeException\n+     * @throws SQLException\n+     */\n+    @PreAuthorize(\"#epersonUuid==null || hasPermission(#epersonUuid, 'EPERSON', 'READ')\")\n+    @SearchRestMethod(name = \"object\")\n+    public Page<AuthorizationRest> findByObject(@Parameter(value = \"uri\", required = true) String uri,\n+            @Parameter(value = \"eperson\") UUID epersonUuid,\n+            Pageable pageable) throws AuthorizeException, SQLException {\n+        Context context = obtainContext();\n+        BaseObjectRest obj = getObject(context, uri);\n+        if (obj == null) {\n+            return null;\n+        }\n+\n+        EPerson currUser = context.getCurrentUser();\n+        EPerson user = currUser;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d64d8932b15922f4baea4f81d77961d5471d7b9"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcyMjc3Nw==", "bodyText": "This line also looks odd at a glance. It needs an inline comment to describe the logic here.  Something like\n// Temporarily change the Context's current user in order to retrieve authorizations based on that user", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382722777", "createdAt": "2020-02-21T17:57:01Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/AuthorizationRestRepository.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.repository;\n+\n+import java.io.Serializable;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.app.rest.Parameter;\n+import org.dspace.app.rest.SearchRestMethod;\n+import org.dspace.app.rest.authorization.Authorization;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.exception.RepositoryMethodNotImplementedException;\n+import org.dspace.app.rest.exception.RepositoryNotFoundException;\n+import org.dspace.app.rest.model.AuthorizationRest;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.authorize.AuthorizeException;\n+import org.dspace.authorize.service.AuthorizeService;\n+import org.dspace.core.Context;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.service.EPersonService;\n+import org.dspace.services.ConfigurationService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Component;\n+\n+\n+/**\n+ * This is the repository responsible to manage Authorization Rest object\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+\n+@Component(AuthorizationRest.CATEGORY + \".\" + AuthorizationRest.NAME)\n+public class AuthorizationRestRepository extends DSpaceRestRepository<AuthorizationRest, String> {\n+\n+    private static final Logger log = LoggerFactory.getLogger(AuthorizationRestRepository.class);\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private AuthorizationRestUtil authorizationRestUtil;\n+\n+    @Autowired\n+    private AuthorizeService authorizeService;\n+\n+    @Autowired\n+    private EPersonService epersonService;\n+\n+    @Autowired\n+    protected ConverterService converter;\n+\n+    @Autowired\n+    ConfigurationService configurationService;\n+\n+    @Override\n+    @PreAuthorize(\"hasPermission(#id, 'authorization', 'READ')\")\n+    public AuthorizationRest findOne(Context context, String id) {\n+\n+        AuthorizationRest authorizationRest = null;\n+\n+        String featureName;\n+        try {\n+            featureName = authorizationRestUtil.getFeatureName(id);\n+        } catch (IllegalArgumentException e) {\n+            log.warn(e.getMessage(), e);\n+            return null;\n+        }\n+        try {\n+            BaseObjectRest object = null;\n+            try {\n+                object = authorizationRestUtil.getObject(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Object informations not found in the specified id \" + id, e);\n+                return null;\n+            }\n+\n+            AuthorizationFeature authorizationFeature = null;\n+            if (featureName != null) {\n+                authorizationFeature = authorizationFeatureService.find(featureName);\n+            }\n+\n+            if (authorizationFeature == null) {\n+                return null;\n+            }\n+\n+            EPerson user;\n+            try {\n+                user = authorizationRestUtil.getEperson(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Invalid eperson informations in the specified id \" + id, e);\n+                return null;\n+            }\n+            EPerson currUser = context.getCurrentUser();\n+            context.setCurrentUser(user);\n+\n+            if (authorizationFeatureService.isAuthorized(context, authorizationFeature, object)) {\n+                Authorization authz = new Authorization();\n+                authz.setEperson(user);\n+                authz.setFeature(authorizationFeature);\n+                authz.setObject(object);\n+                authorizationRest = converter.toRest(authz, utils.obtainProjection());\n+            }\n+            context.setCurrentUser(currUser);\n+        } catch (SQLException e) {\n+            throw new RuntimeException(e.getMessage(), e);\n+        }\n+\n+        return authorizationRest;\n+    }\n+\n+\n+    /**\n+     * It returns the list of matching available authorizations granted to the specified eperson or to the anonymous\n+     * user. Only administrators and the user identified by the epersonUuid parameter can access this method\n+     *\n+     * \n+     * @param context\n+     *            the DSpace Context\n+     * @param uri\n+     *            the uri of the object to check the authorization against\n+     * @param epersonUuid\n+     *            the eperson uuid to use in the authorization evaluation\n+     * @param featureName\n+     *            limit the authorization check to only the feature identified via its name\n+     * @param pageable\n+     *            the pagination options\n+     * @return the list of matching authorization available for the requested user and object, filtered by feature if\n+     *         provided\n+     * @throws AuthorizeException\n+     * @throws SQLException\n+     */\n+    @PreAuthorize(\"#epersonUuid==null || hasPermission(#epersonUuid, 'EPERSON', 'READ')\")\n+    @SearchRestMethod(name = \"object\")\n+    public Page<AuthorizationRest> findByObject(@Parameter(value = \"uri\", required = true) String uri,\n+            @Parameter(value = \"eperson\") UUID epersonUuid,\n+            Pageable pageable) throws AuthorizeException, SQLException {\n+        Context context = obtainContext();\n+        BaseObjectRest obj = getObject(context, uri);\n+        if (obj == null) {\n+            return null;\n+        }\n+\n+        EPerson currUser = context.getCurrentUser();\n+        EPerson user = currUser;\n+\n+        if (epersonUuid != null) {\n+            if (context.getCurrentUser() == null) {\n+                throw new AuthorizeException(\"attempt to anonymously access the authorization of the eperson \"\n+                        + epersonUuid);\n+            } else {\n+                if (!authorizeService.isAdmin(context) && !epersonUuid.equals(currUser.getID())) {\n+                    throw new AuthorizeException(\"attempt to access the authorization of the eperson \" + epersonUuid\n+                            + \" only system administrators can see the authorization of other users\");\n+                }\n+                user = epersonService.find(context, epersonUuid);\n+            }\n+        } else {\n+            user = null;\n+        }\n+        context.setCurrentUser(user);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d64d8932b15922f4baea4f81d77961d5471d7b9"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcyMzU2NA==", "bodyText": "Please add Javadocs or inline comments to this method. It's quite complex and has no inline comments, making it difficult to follow the logic here.", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382723564", "createdAt": "2020-02-21T17:58:51Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/AuthorizationRestRepository.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.repository;\n+\n+import java.io.Serializable;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.app.rest.Parameter;\n+import org.dspace.app.rest.SearchRestMethod;\n+import org.dspace.app.rest.authorization.Authorization;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.exception.RepositoryMethodNotImplementedException;\n+import org.dspace.app.rest.exception.RepositoryNotFoundException;\n+import org.dspace.app.rest.model.AuthorizationRest;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.authorize.AuthorizeException;\n+import org.dspace.authorize.service.AuthorizeService;\n+import org.dspace.core.Context;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.service.EPersonService;\n+import org.dspace.services.ConfigurationService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Component;\n+\n+\n+/**\n+ * This is the repository responsible to manage Authorization Rest object\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+\n+@Component(AuthorizationRest.CATEGORY + \".\" + AuthorizationRest.NAME)\n+public class AuthorizationRestRepository extends DSpaceRestRepository<AuthorizationRest, String> {\n+\n+    private static final Logger log = LoggerFactory.getLogger(AuthorizationRestRepository.class);\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private AuthorizationRestUtil authorizationRestUtil;\n+\n+    @Autowired\n+    private AuthorizeService authorizeService;\n+\n+    @Autowired\n+    private EPersonService epersonService;\n+\n+    @Autowired\n+    protected ConverterService converter;\n+\n+    @Autowired\n+    ConfigurationService configurationService;\n+\n+    @Override\n+    @PreAuthorize(\"hasPermission(#id, 'authorization', 'READ')\")\n+    public AuthorizationRest findOne(Context context, String id) {\n+\n+        AuthorizationRest authorizationRest = null;\n+\n+        String featureName;\n+        try {\n+            featureName = authorizationRestUtil.getFeatureName(id);\n+        } catch (IllegalArgumentException e) {\n+            log.warn(e.getMessage(), e);\n+            return null;\n+        }\n+        try {\n+            BaseObjectRest object = null;\n+            try {\n+                object = authorizationRestUtil.getObject(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Object informations not found in the specified id \" + id, e);\n+                return null;\n+            }\n+\n+            AuthorizationFeature authorizationFeature = null;\n+            if (featureName != null) {\n+                authorizationFeature = authorizationFeatureService.find(featureName);\n+            }\n+\n+            if (authorizationFeature == null) {\n+                return null;\n+            }\n+\n+            EPerson user;\n+            try {\n+                user = authorizationRestUtil.getEperson(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Invalid eperson informations in the specified id \" + id, e);\n+                return null;\n+            }\n+            EPerson currUser = context.getCurrentUser();\n+            context.setCurrentUser(user);\n+\n+            if (authorizationFeatureService.isAuthorized(context, authorizationFeature, object)) {\n+                Authorization authz = new Authorization();\n+                authz.setEperson(user);\n+                authz.setFeature(authorizationFeature);\n+                authz.setObject(object);\n+                authorizationRest = converter.toRest(authz, utils.obtainProjection());\n+            }\n+            context.setCurrentUser(currUser);\n+        } catch (SQLException e) {\n+            throw new RuntimeException(e.getMessage(), e);\n+        }\n+\n+        return authorizationRest;\n+    }\n+\n+\n+    /**\n+     * It returns the list of matching available authorizations granted to the specified eperson or to the anonymous\n+     * user. Only administrators and the user identified by the epersonUuid parameter can access this method\n+     *\n+     * \n+     * @param context\n+     *            the DSpace Context\n+     * @param uri\n+     *            the uri of the object to check the authorization against\n+     * @param epersonUuid\n+     *            the eperson uuid to use in the authorization evaluation\n+     * @param featureName\n+     *            limit the authorization check to only the feature identified via its name\n+     * @param pageable\n+     *            the pagination options\n+     * @return the list of matching authorization available for the requested user and object, filtered by feature if\n+     *         provided\n+     * @throws AuthorizeException\n+     * @throws SQLException\n+     */\n+    @PreAuthorize(\"#epersonUuid==null || hasPermission(#epersonUuid, 'EPERSON', 'READ')\")\n+    @SearchRestMethod(name = \"object\")\n+    public Page<AuthorizationRest> findByObject(@Parameter(value = \"uri\", required = true) String uri,\n+            @Parameter(value = \"eperson\") UUID epersonUuid,\n+            Pageable pageable) throws AuthorizeException, SQLException {\n+        Context context = obtainContext();\n+        BaseObjectRest obj = getObject(context, uri);\n+        if (obj == null) {\n+            return null;\n+        }\n+\n+        EPerson currUser = context.getCurrentUser();\n+        EPerson user = currUser;\n+\n+        if (epersonUuid != null) {\n+            if (context.getCurrentUser() == null) {\n+                throw new AuthorizeException(\"attempt to anonymously access the authorization of the eperson \"\n+                        + epersonUuid);\n+            } else {\n+                if (!authorizeService.isAdmin(context) && !epersonUuid.equals(currUser.getID())) {\n+                    throw new AuthorizeException(\"attempt to access the authorization of the eperson \" + epersonUuid\n+                            + \" only system administrators can see the authorization of other users\");\n+                }\n+                user = epersonService.find(context, epersonUuid);\n+            }\n+        } else {\n+            user = null;\n+        }\n+        context.setCurrentUser(user);\n+        List<AuthorizationFeature> features = authorizationFeatureService.findByResourceType(obj.getUniqueType());\n+        List<Authorization> authorizations = new ArrayList<Authorization>();\n+        for (AuthorizationFeature f : features) {\n+            if (authorizationFeatureService.isAuthorized(context, f, obj)) {\n+                authorizations.add(new Authorization(user, f, obj));\n+            }\n+        }\n+        context.setCurrentUser(currUser);\n+        return converter.toRestPage(utils.getPage(authorizations, pageable), utils.obtainProjection());\n+    }\n+\n+    /**\n+     * It returns the authorization related to the requested feature if granted to the specified eperson or to the\n+     * anonymous user. Only administrators and the user identified by the epersonUuid parameter can access this method\n+     *\n+     * \n+     * @param context\n+     *            the DSpace Context\n+     * @param uri\n+     *            the uri of the object to check the authorization against\n+     * @param epersonUuid\n+     *            the eperson uuid to use in the authorization evaluation\n+     * @param featureName\n+     *            limit the authorization check to only the feature identified via its name\n+     * @param pageable\n+     *            the pagination options\n+     * @return the list of matching authorization available for the requested user and object, filtered by feature if\n+     *         provided\n+     * @throws AuthorizeException\n+     * @throws SQLException\n+     */\n+    @PreAuthorize(\"#epersonUuid==null || hasPermission(#epersonUuid, 'EPERSON', 'READ')\")\n+    @SearchRestMethod(name = \"objectAndFeature\")\n+    public AuthorizationRest findByObjectAndFeature(@Parameter(value = \"uri\", required = true) String uri,\n+            @Parameter(value = \"eperson\") UUID epersonUuid,\n+            @Parameter(value = \"feature\", required = true) String featureName,\n+            Pageable pageable) throws AuthorizeException, SQLException {\n+        Context context = obtainContext();\n+        BaseObjectRest obj = getObject(context, uri);\n+        if (obj == null) {\n+            return null;\n+        }\n+\n+        EPerson currUser = context.getCurrentUser();\n+        EPerson user = currUser;\n+        if (epersonUuid != null) {\n+            if (context.getCurrentUser() == null) {\n+                throw new AuthorizeException(\"attempt to anonymously access the authorization of the eperson \"\n+                        + epersonUuid);\n+            } else {\n+                if (!authorizeService.isAdmin(context) && !epersonUuid.equals(currUser.getID())) {\n+                    throw new AuthorizeException(\"attempt to access the authorization of the eperson \" + epersonUuid\n+                            + \" only system administrators can see the authorization of other users\");\n+                }\n+                user = epersonService.find(context, epersonUuid);\n+            }\n+        } else {\n+            user = null;\n+        }\n+        context.setCurrentUser(user);\n+        AuthorizationFeature feature = authorizationFeatureService.find(featureName);\n+        AuthorizationRest authorizationRest = null;\n+        if (authorizationFeatureService.isAuthorized(context, feature, obj)) {\n+            Authorization authz = new Authorization();\n+            authz.setEperson(user);\n+            authz.setFeature(feature);\n+            authz.setObject(obj);\n+            authorizationRest = converter.toRest(authz, utils.obtainProjection());\n+        }\n+        context.setCurrentUser(currUser);\n+        return authorizationRest;\n+    }\n+\n+    private BaseObjectRest getObject(Context context, String uri) throws SQLException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d64d8932b15922f4baea4f81d77961d5471d7b9"}, "originalPosition": 251}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcyNzM2OA==", "bodyText": "This JavaDocs needs updating, as FindableObject was removed.", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382727368", "createdAt": "2020-02-21T18:07:34Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/FindableObjectRepository.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.repository;\n+\n+import java.io.Serializable;\n+import java.sql.SQLException;\n+\n+import org.dspace.core.Context;\n+import org.dspace.core.ReloadableEntity;\n+\n+/**\n+ * This interface must be implemented by all the rest repository that deal with resources that can be make\n+ * {@link FindableObject}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d64d8932b15922f4baea4f81d77961d5471d7b9"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcyNzQ5Mg==", "bodyText": "Please add JavaDocs to the two methods in this interface.", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382727492", "createdAt": "2020-02-21T18:07:52Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/FindableObjectRepository.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.repository;\n+\n+import java.io.Serializable;\n+import java.sql.SQLException;\n+\n+import org.dspace.core.Context;\n+import org.dspace.core.ReloadableEntity;\n+\n+/**\n+ * This interface must be implemented by all the rest repository that deal with resources that can be make\n+ * {@link FindableObject}\n+ * \n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ *\n+ * @param <F>\n+ *            the FindableObject type\n+ * @param <PK>\n+ *            the primary key type\n+ */\n+public interface FindableObjectRepository<T extends ReloadableEntity<PK>,\n+    PK extends Serializable> {\n+\n+    T findDomainObjectByPk(Context context, PK id) throws SQLException;\n+\n+    Class<PK> getPKClass();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d64d8932b15922f4baea4f81d77961d5471d7b9"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcyODY2MQ==", "bodyText": "Since this is only checking for READ permission, shouldn't this be named something like ReadAuthorizationPermissionEvaluatorPlugin?  Or maybe just ReadPermissionEvaluatorPlugin?", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382728661", "createdAt": "2020-02-21T18:10:32Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/security/AuthorizationPermissionEvaluatorPlugin.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.security;\n+\n+import java.io.Serializable;\n+import java.sql.SQLException;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.model.AuthorizationRest;\n+import org.dspace.app.rest.utils.ContextUtil;\n+import org.dspace.authorize.service.AuthorizeService;\n+import org.dspace.core.Context;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.service.EPersonService;\n+import org.dspace.services.RequestService;\n+import org.dspace.services.model.Request;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.core.Authentication;\n+import org.springframework.stereotype.Component;\n+\n+/**\n+ * {@link RestPermissionEvaluatorPlugin} class that evaluate READ permissions for an Authorization\n+ * \n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+@Component\n+public class AuthorizationPermissionEvaluatorPlugin extends RestObjectPermissionEvaluatorPlugin {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d64d8932b15922f4baea4f81d77961d5471d7b9"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcyOTQxNQ==", "bodyText": "I don't quite understand this change.  Should we update the Javadocs description of this Regex to describe the format it expects?  Or maybe give an example or two.", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382729415", "createdAt": "2020-02-21T18:12:06Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/utils/RegexUtils.java", "diffHunk": "@@ -22,7 +22,7 @@ private RegexUtils(){}\n      * identifier (digits or uuid)\n      */\n     public static final String REGEX_REQUESTMAPPING_IDENTIFIER_AS_STRING_VERSION_STRONG = \"/{id:^(?!^\\\\d+$)\" +\n-        \"(?!^[0-9a-fxA-FX]{8}-[0-9a-fxA-FX]{4}-[0-9a-fxA-FX]{4}-[0-9a-fxA-FX]{4}-[0-9a-fxA-FX]{12}$)[\\\\w+\\\\-]+$+}\";\n+        \"(?!^[0-9a-fxA-FX]{8}-[0-9a-fxA-FX]{4}-[0-9a-fxA-FX]{4}-[0-9a-fxA-FX]{4}-[0-9a-fxA-FX]{12}$)[\\\\w+\\\\-\\\\.]+$+}\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d64d8932b15922f4baea4f81d77961d5471d7b9"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjczMDU2Ng==", "bodyText": "These tests in this IT all look good, but they all assume you already have admin permissions. Shouldn't we have at least a few tests here to verify the proper errors are thrown if you are unauthenticated or logged in as a non-admin?", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382730566", "createdAt": "2020-02-21T18:14:36Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/AuthorizationFeatureRestRepositoryIT.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static com.jayway.jsonpath.JsonPath.read;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.fail;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import com.jayway.jsonpath.matchers.JsonPathMatchers;\n+import org.dspace.app.rest.authorization.AlwaysTrueFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.hamcrest.Matchers;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+/**\n+ * Test suite for the Authorization Feature endpoint\n+ * \n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ *\n+ */\n+public class AuthorizationFeatureRestRepositoryIT extends AbstractControllerIntegrationTest {\n+    @Autowired\n+    private AuthorizationFeatureService authzFeatureService;\n+\n+    @Test\n+    /**\n+     * All the features should be returned\n+     *\n+     * @throws Exception\n+     */\n+    public void findAllTest() throws Exception {\n+        int featuresNum = authzFeatureService.findAll().size();\n+        int expReturn = featuresNum > 20 ? 20 : featuresNum;\n+        String adminToken = getAuthToken(admin.getEmail(), password);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d64d8932b15922f4baea4f81d77961d5471d7b9"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjczMjg5OQ==", "bodyText": "The PR #2668 is now merged, so these commented out tests should be reenabled.", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382732899", "createdAt": "2020-02-21T18:19:38Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/AuthorizationRestRepositoryIT.java", "diffHunk": "@@ -0,0 +1,1154 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.io.Serializable;\n+import java.util.UUID;\n+\n+import com.jayway.jsonpath.matchers.JsonPathMatchers;\n+import org.dspace.app.rest.authorization.AlwaysFalseFeature;\n+import org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature;\n+import org.dspace.app.rest.authorization.AlwaysTrueFeature;\n+import org.dspace.app.rest.authorization.Authorization;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.authorization.TrueForAdminsFeature;\n+import org.dspace.app.rest.authorization.TrueForLoggedUsersFeature;\n+import org.dspace.app.rest.authorization.TrueForTestUsersFeature;\n+import org.dspace.app.rest.builder.CommunityBuilder;\n+import org.dspace.app.rest.builder.EPersonBuilder;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.matcher.AuthorizationMatcher;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.app.rest.model.CommunityRest;\n+import org.dspace.app.rest.model.EPersonRest;\n+import org.dspace.app.rest.model.ItemRest;\n+import org.dspace.app.rest.model.SiteRest;\n+import org.dspace.app.rest.projection.DefaultProjection;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.content.Community;\n+import org.dspace.content.Site;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.content.service.SiteService;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.services.ConfigurationService;\n+import org.hamcrest.Matchers;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+/**\n+ * Test suite for the Authorization endpoint\n+ * \n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ *\n+ */\n+public class AuthorizationRestRepositoryIT extends AbstractControllerIntegrationTest {\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private AuthorizationRestUtil authorizationRestUtil;\n+\n+    @Autowired\n+    private ConverterService converterService;\n+\n+    @Autowired\n+    private ConfigurationService configurationService;\n+\n+    @Autowired\n+    private Utils utils;\n+\n+    private SiteService siteService;\n+\n+    private AuthorizationFeature alwaysTrue;\n+\n+    private AuthorizationFeature alwaysFalse;\n+\n+    private AuthorizationFeature alwaysException;\n+\n+    private AuthorizationFeature trueForAdmins;\n+\n+    private AuthorizationFeature trueForLoggedUsers;\n+\n+    private AuthorizationFeature trueForTestUsers;\n+\n+    @Override\n+    @Before\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        siteService = ContentServiceFactory.getInstance().getSiteService();\n+        alwaysTrue = authorizationFeatureService.find(AlwaysTrueFeature.NAME);\n+        alwaysFalse = authorizationFeatureService.find(AlwaysFalseFeature.NAME);\n+        alwaysException = authorizationFeatureService.find(AlwaysThrowExceptionFeature.NAME);\n+        trueForAdmins = authorizationFeatureService.find(TrueForAdminsFeature.NAME);\n+        trueForLoggedUsers = authorizationFeatureService.find(TrueForLoggedUsersFeature.NAME);\n+        trueForTestUsers = authorizationFeatureService.find(TrueForTestUsersFeature.NAME);\n+    }\n+\n+    @Test\n+    /**\n+     * This method is not implemented\n+     *\n+     * @throws Exception\n+     */\n+    public void findAllTest() throws Exception {\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations\"))\n+                    .andExpect(status().isMethodNotAllowed());\n+        getClient().perform(get(\"/api/authz/authorizations\"))\n+                    .andExpect(status().isMethodNotAllowed());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that an user can access a specific authorization\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+\n+        // define three authorizations that we know must exists\n+        Authorization authAdminSite = new Authorization(admin, trueForAdmins, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, trueForLoggedUsers, siteRest);\n+        Authorization authAnonymousUserSite = new Authorization(null, alwaysTrue, siteRest);\n+\n+        // access the authorization for the admin user\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authAdminSite))));\n+\n+        // access the authorization for a normal user\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authNormalUserSite))));\n+\n+        // access the authorization for a normal user as administrator\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authNormalUserSite))));\n+\n+        // access the authorization for an anonymous user\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authAnonymousUserSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authAnonymousUserSite))));\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the unauthorized return code is used in the appropriate scenarios\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneUnauthorizedTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+\n+        // define two authorizations that we know must exists\n+        Authorization authAdminSite = new Authorization(admin, alwaysTrue, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysTrue, siteRest);\n+\n+        // try anonymous access to the authorization for the admin user\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isUnauthorized());\n+\n+        // try anonymous access to the authorization for a normal user\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isUnauthorized());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the forbidden return code is used in the appropriate scenarios\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneForbiddenTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+        EPerson testEPerson = EPersonBuilder.createEPerson(context)\n+                .withEmail(\"test-authorization@example.com\")\n+                .withPassword(password).build();\n+        context.restoreAuthSystemState();\n+\n+        // define three authorizations that we know must exists\n+        Authorization authAdminSite = new Authorization(admin, alwaysTrue, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysTrue, siteRest);\n+\n+        String testToken = getAuthToken(testEPerson.getEmail(), password);\n+\n+        // try to access the authorization for the admin user with another user\n+        getClient(testToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isForbidden());\n+\n+        // try to access the authorization of a normal user with another user\n+        getClient(testToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isForbidden());\n+\n+        // check access as a test user to a not existing authorization for another\n+        // eperson (but existing for the test user)\n+        Authorization noTestAuthForNormalUserSite  = new Authorization(eperson, trueForTestUsers, siteRest);\n+        getClient(testToken).perform(get(\"/api/authz/authorizations/\" + noTestAuthForNormalUserSite.getID()))\n+                    .andExpect(status().isForbidden());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the not found return code is used in the appropriate scenarios\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneNotFoundTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+        EPersonRest epersonRest = converterService.toRest(eperson, DefaultProjection.DEFAULT);\n+        context.restoreAuthSystemState();\n+\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+\n+        // define three authorizations that we know will be no granted\n+        Authorization authAdminSite = new Authorization(admin, alwaysFalse, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysFalse, siteRest);\n+        Authorization authAnonymousUserSite = new Authorization(null, alwaysFalse, siteRest);\n+\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isNotFound());\n+\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+        // also the admin cannot retrieve a not existing authorization for the normal user\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                .andExpect(status().isNotFound());\n+\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authAnonymousUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+        // also the admin cannot retrieve a not existing authorization for the anonymous user\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAnonymousUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+\n+        // build a couple of IDs that look good but are related to not existing authorizations\n+        // the trueForAdmins feature is not defined for eperson\n+        String authInvalidType = getAuthorizationID(admin, trueForAdmins, epersonRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authInvalidType))\n+                    .andExpect(status().isNotFound());\n+\n+        // the specified item doesn't exist\n+        String authNotExistingObject = getAuthorizationID(admin, alwaysTrue,\n+                ItemRest.CATEGORY + \".\" + ItemRest.NAME, UUID.randomUUID());\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNotExistingObject))\n+                    .andExpect(status().isNotFound());\n+\n+        // the specified eperson doesn't exist\n+        String authNotExistingEPerson = getAuthorizationID(UUID.randomUUID(), alwaysTrue, siteRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNotExistingEPerson))\n+                    .andExpect(status().isNotFound());\n+\n+        // the specified feature doesn't exist\n+        String authNotExistingFeature = getAuthorizationID(admin, \"notexistingfeature\", siteRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNotExistingFeature))\n+                    .andExpect(status().isNotFound());\n+\n+        // check access as admin to a not existing authorization for another eperson (but existing for the admin)\n+        Authorization noAdminAuthForNormalUserSite  = new Authorization(eperson, trueForAdmins, siteRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + noAdminAuthForNormalUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+\n+        // check a couple of completely wrong IDs\n+        String notValidID = \"notvalidID\";\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + notValidID))\n+                    .andExpect(status().isNotFound());\n+\n+        String notValidIDWithWrongEpersonPart = getAuthorizationID(\"1\", alwaysTrue.getName(),\n+                SiteRest.CATEGORY + \".\" + SiteRest.NAME, site.getID().toString());\n+        // use the admin token otherwise it would result in a forbidden (attempt to access authorization of other users)\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + notValidIDWithWrongEpersonPart))\n+                    .andExpect(status().isNotFound());\n+\n+        String notValidIDWithWrongObjectTypePart = getAuthorizationID(eperson.getID().toString(), alwaysTrue.getName(),\n+                \"SITE\", site.getID().toString());\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + notValidIDWithWrongObjectTypePart))\n+                    .andExpect(status().isNotFound());\n+\n+        String notValidIDWithUnknownObjectTypePart =\n+                getAuthorizationID(eperson.getID().toString(), alwaysTrue.getName(),\n+                        \"core.unknown\", \"1\");\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + notValidIDWithUnknownObjectTypePart))\n+                    .andExpect(status().isNotFound());\n+\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that an exception in the feature check will be reported back\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneInternalServerErrorTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+        // define two authorizations that we know will throw exceptions\n+        Authorization authAdminSite = new Authorization(admin, alwaysException, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysException, siteRest);\n+\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isInternalServerError());\n+\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isInternalServerError());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the search by object works properly in allowed scenarios:\n+     * - for an administrator\n+     * - for an administrator that want to inspect permission of the anonymous users or another user\n+     * - for a logged-in \"normal\" user\n+     * - for anonymous\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, converterService.getProjection(DefaultProjection.NAME));\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+        // verify that it works for administrators\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isOk())\n+            // there are at least 3: alwaysTrue, trueForAdministrators and trueForLoggedUsers\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(3))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            Matchers.startsWith(admin.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(3)));\n+\n+        // verify that it works for normal loggedin users\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            // there are at least 2: alwaysTrue and trueForLoggedUsers\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(2))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName()),\n+                                                is(trueForAdmins.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            Matchers.startsWith(eperson.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(2)));\n+\n+        // verify that it works for administators inspecting other users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            // there are at least 2: alwaysTrue and trueForLoggedUsers\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(2))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName()),\n+                                                // this guarantee that we are looking to the eperson\n+                                                // authz and not to the admin ones\n+                                                is(trueForAdmins.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            // this guarantee that we are looking to the eperson\n+                                            // authz and not to the admin ones\n+                                            Matchers.startsWith(eperson.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(2)));\n+\n+        // verify that it works for anonymous users\n+        getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(1))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName()),\n+                                                is(trueForAdmins.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            Matchers.startsWith(eperson.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(1)));\n+\n+        // verify that it works for administrators inspecting anonymous users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(1))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName()),\n+                                                is(trueForAdmins.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            Matchers.startsWith(eperson.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(1)));\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the findByObject return an empty page when the requested object doesn't exist but the uri is\n+     * potentially valid (i.e. deleted object)\n+     * \n+     * @throws Exception\n+     */\n+    public void findByNotExistingObjectTest() throws Exception {\n+        String wrongSiteUri = \"http://localhost/api/core/sites/\" + UUID.randomUUID();\n+\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+        // verify that it works for administrators, no result\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+\n+        // verify that it works for normal loggedin users\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+\n+        // verify that it works for administators inspecting other users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+\n+        // verify that it works for anonymous users\n+        getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+\n+        // verify that it works for administrators inspecting anonymous users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the findByObject return the 400 Bad Request response for invalid or missing URI (required parameter)\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectBadRequestTest() throws Exception {\n+        String[] invalidUris = new String[] {\n+                \"invalid-uri\",\n+                \"\",\n+                \"http://localhost/api/wrongcategory/wrongmodel/1\",\n+                \"http://localhost/api/core/sites/this-is-not-an-uuid\"\n+        };\n+\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+\n+        for (String invalidUri : invalidUris) {\n+            System.out.println(\"Testing the URI: \" + invalidUri);\n+            // verify that it works for administrators with an invalid or missing uri\n+            String adminToken = getAuthToken(admin.getEmail(), password);\n+            getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri)\n+                    .param(\"eperson\", admin.getID().toString()))\n+                .andExpect(status().isBadRequest());\n+\n+            // verify that it works for normal loggedin users with an invalid or missing uri\n+            String epersonToken = getAuthToken(eperson.getEmail(), password);\n+            getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri)\n+                    .param(\"eperson\", eperson.getID().toString()))\n+                .andExpect(status().isBadRequest());\n+\n+            // verify that it works for administators inspecting other users with an invalid or missing uri\n+            getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri)\n+                    .param(\"eperson\", eperson.getID().toString()))\n+                .andExpect(status().isBadRequest());\n+\n+            // verify that it works for anonymous users with an invalid or missing uri\n+            getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri))\n+                .andExpect(status().isBadRequest());\n+\n+            // verify that it works for administrators inspecting anonymous users with an invalid or missing uri\n+            getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri))\n+                .andExpect(status().isBadRequest());\n+        }\n+        //FIXME add once https://github.com/DSpace/DSpace/pull/2668 is merged", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d64d8932b15922f4baea4f81d77961d5471d7b9"}, "originalPosition": 624}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjczMzMyNg==", "bodyText": "We should remove System.out statements", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382733326", "createdAt": "2020-02-21T18:20:31Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/AuthorizationRestRepositoryIT.java", "diffHunk": "@@ -0,0 +1,1154 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.io.Serializable;\n+import java.util.UUID;\n+\n+import com.jayway.jsonpath.matchers.JsonPathMatchers;\n+import org.dspace.app.rest.authorization.AlwaysFalseFeature;\n+import org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature;\n+import org.dspace.app.rest.authorization.AlwaysTrueFeature;\n+import org.dspace.app.rest.authorization.Authorization;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.authorization.TrueForAdminsFeature;\n+import org.dspace.app.rest.authorization.TrueForLoggedUsersFeature;\n+import org.dspace.app.rest.authorization.TrueForTestUsersFeature;\n+import org.dspace.app.rest.builder.CommunityBuilder;\n+import org.dspace.app.rest.builder.EPersonBuilder;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.matcher.AuthorizationMatcher;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.app.rest.model.CommunityRest;\n+import org.dspace.app.rest.model.EPersonRest;\n+import org.dspace.app.rest.model.ItemRest;\n+import org.dspace.app.rest.model.SiteRest;\n+import org.dspace.app.rest.projection.DefaultProjection;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.content.Community;\n+import org.dspace.content.Site;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.content.service.SiteService;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.services.ConfigurationService;\n+import org.hamcrest.Matchers;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+/**\n+ * Test suite for the Authorization endpoint\n+ * \n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ *\n+ */\n+public class AuthorizationRestRepositoryIT extends AbstractControllerIntegrationTest {\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private AuthorizationRestUtil authorizationRestUtil;\n+\n+    @Autowired\n+    private ConverterService converterService;\n+\n+    @Autowired\n+    private ConfigurationService configurationService;\n+\n+    @Autowired\n+    private Utils utils;\n+\n+    private SiteService siteService;\n+\n+    private AuthorizationFeature alwaysTrue;\n+\n+    private AuthorizationFeature alwaysFalse;\n+\n+    private AuthorizationFeature alwaysException;\n+\n+    private AuthorizationFeature trueForAdmins;\n+\n+    private AuthorizationFeature trueForLoggedUsers;\n+\n+    private AuthorizationFeature trueForTestUsers;\n+\n+    @Override\n+    @Before\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        siteService = ContentServiceFactory.getInstance().getSiteService();\n+        alwaysTrue = authorizationFeatureService.find(AlwaysTrueFeature.NAME);\n+        alwaysFalse = authorizationFeatureService.find(AlwaysFalseFeature.NAME);\n+        alwaysException = authorizationFeatureService.find(AlwaysThrowExceptionFeature.NAME);\n+        trueForAdmins = authorizationFeatureService.find(TrueForAdminsFeature.NAME);\n+        trueForLoggedUsers = authorizationFeatureService.find(TrueForLoggedUsersFeature.NAME);\n+        trueForTestUsers = authorizationFeatureService.find(TrueForTestUsersFeature.NAME);\n+    }\n+\n+    @Test\n+    /**\n+     * This method is not implemented\n+     *\n+     * @throws Exception\n+     */\n+    public void findAllTest() throws Exception {\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations\"))\n+                    .andExpect(status().isMethodNotAllowed());\n+        getClient().perform(get(\"/api/authz/authorizations\"))\n+                    .andExpect(status().isMethodNotAllowed());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that an user can access a specific authorization\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+\n+        // define three authorizations that we know must exists\n+        Authorization authAdminSite = new Authorization(admin, trueForAdmins, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, trueForLoggedUsers, siteRest);\n+        Authorization authAnonymousUserSite = new Authorization(null, alwaysTrue, siteRest);\n+\n+        // access the authorization for the admin user\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authAdminSite))));\n+\n+        // access the authorization for a normal user\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authNormalUserSite))));\n+\n+        // access the authorization for a normal user as administrator\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authNormalUserSite))));\n+\n+        // access the authorization for an anonymous user\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authAnonymousUserSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authAnonymousUserSite))));\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the unauthorized return code is used in the appropriate scenarios\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneUnauthorizedTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+\n+        // define two authorizations that we know must exists\n+        Authorization authAdminSite = new Authorization(admin, alwaysTrue, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysTrue, siteRest);\n+\n+        // try anonymous access to the authorization for the admin user\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isUnauthorized());\n+\n+        // try anonymous access to the authorization for a normal user\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isUnauthorized());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the forbidden return code is used in the appropriate scenarios\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneForbiddenTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+        EPerson testEPerson = EPersonBuilder.createEPerson(context)\n+                .withEmail(\"test-authorization@example.com\")\n+                .withPassword(password).build();\n+        context.restoreAuthSystemState();\n+\n+        // define three authorizations that we know must exists\n+        Authorization authAdminSite = new Authorization(admin, alwaysTrue, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysTrue, siteRest);\n+\n+        String testToken = getAuthToken(testEPerson.getEmail(), password);\n+\n+        // try to access the authorization for the admin user with another user\n+        getClient(testToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isForbidden());\n+\n+        // try to access the authorization of a normal user with another user\n+        getClient(testToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isForbidden());\n+\n+        // check access as a test user to a not existing authorization for another\n+        // eperson (but existing for the test user)\n+        Authorization noTestAuthForNormalUserSite  = new Authorization(eperson, trueForTestUsers, siteRest);\n+        getClient(testToken).perform(get(\"/api/authz/authorizations/\" + noTestAuthForNormalUserSite.getID()))\n+                    .andExpect(status().isForbidden());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the not found return code is used in the appropriate scenarios\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneNotFoundTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+        EPersonRest epersonRest = converterService.toRest(eperson, DefaultProjection.DEFAULT);\n+        context.restoreAuthSystemState();\n+\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+\n+        // define three authorizations that we know will be no granted\n+        Authorization authAdminSite = new Authorization(admin, alwaysFalse, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysFalse, siteRest);\n+        Authorization authAnonymousUserSite = new Authorization(null, alwaysFalse, siteRest);\n+\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isNotFound());\n+\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+        // also the admin cannot retrieve a not existing authorization for the normal user\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                .andExpect(status().isNotFound());\n+\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authAnonymousUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+        // also the admin cannot retrieve a not existing authorization for the anonymous user\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAnonymousUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+\n+        // build a couple of IDs that look good but are related to not existing authorizations\n+        // the trueForAdmins feature is not defined for eperson\n+        String authInvalidType = getAuthorizationID(admin, trueForAdmins, epersonRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authInvalidType))\n+                    .andExpect(status().isNotFound());\n+\n+        // the specified item doesn't exist\n+        String authNotExistingObject = getAuthorizationID(admin, alwaysTrue,\n+                ItemRest.CATEGORY + \".\" + ItemRest.NAME, UUID.randomUUID());\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNotExistingObject))\n+                    .andExpect(status().isNotFound());\n+\n+        // the specified eperson doesn't exist\n+        String authNotExistingEPerson = getAuthorizationID(UUID.randomUUID(), alwaysTrue, siteRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNotExistingEPerson))\n+                    .andExpect(status().isNotFound());\n+\n+        // the specified feature doesn't exist\n+        String authNotExistingFeature = getAuthorizationID(admin, \"notexistingfeature\", siteRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNotExistingFeature))\n+                    .andExpect(status().isNotFound());\n+\n+        // check access as admin to a not existing authorization for another eperson (but existing for the admin)\n+        Authorization noAdminAuthForNormalUserSite  = new Authorization(eperson, trueForAdmins, siteRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + noAdminAuthForNormalUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+\n+        // check a couple of completely wrong IDs\n+        String notValidID = \"notvalidID\";\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + notValidID))\n+                    .andExpect(status().isNotFound());\n+\n+        String notValidIDWithWrongEpersonPart = getAuthorizationID(\"1\", alwaysTrue.getName(),\n+                SiteRest.CATEGORY + \".\" + SiteRest.NAME, site.getID().toString());\n+        // use the admin token otherwise it would result in a forbidden (attempt to access authorization of other users)\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + notValidIDWithWrongEpersonPart))\n+                    .andExpect(status().isNotFound());\n+\n+        String notValidIDWithWrongObjectTypePart = getAuthorizationID(eperson.getID().toString(), alwaysTrue.getName(),\n+                \"SITE\", site.getID().toString());\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + notValidIDWithWrongObjectTypePart))\n+                    .andExpect(status().isNotFound());\n+\n+        String notValidIDWithUnknownObjectTypePart =\n+                getAuthorizationID(eperson.getID().toString(), alwaysTrue.getName(),\n+                        \"core.unknown\", \"1\");\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + notValidIDWithUnknownObjectTypePart))\n+                    .andExpect(status().isNotFound());\n+\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that an exception in the feature check will be reported back\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneInternalServerErrorTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+        // define two authorizations that we know will throw exceptions\n+        Authorization authAdminSite = new Authorization(admin, alwaysException, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysException, siteRest);\n+\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isInternalServerError());\n+\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isInternalServerError());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the search by object works properly in allowed scenarios:\n+     * - for an administrator\n+     * - for an administrator that want to inspect permission of the anonymous users or another user\n+     * - for a logged-in \"normal\" user\n+     * - for anonymous\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, converterService.getProjection(DefaultProjection.NAME));\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+        // verify that it works for administrators\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isOk())\n+            // there are at least 3: alwaysTrue, trueForAdministrators and trueForLoggedUsers\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(3))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            Matchers.startsWith(admin.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(3)));\n+\n+        // verify that it works for normal loggedin users\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            // there are at least 2: alwaysTrue and trueForLoggedUsers\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(2))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName()),\n+                                                is(trueForAdmins.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            Matchers.startsWith(eperson.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(2)));\n+\n+        // verify that it works for administators inspecting other users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            // there are at least 2: alwaysTrue and trueForLoggedUsers\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(2))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName()),\n+                                                // this guarantee that we are looking to the eperson\n+                                                // authz and not to the admin ones\n+                                                is(trueForAdmins.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            // this guarantee that we are looking to the eperson\n+                                            // authz and not to the admin ones\n+                                            Matchers.startsWith(eperson.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(2)));\n+\n+        // verify that it works for anonymous users\n+        getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(1))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName()),\n+                                                is(trueForAdmins.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            Matchers.startsWith(eperson.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(1)));\n+\n+        // verify that it works for administrators inspecting anonymous users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(1))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName()),\n+                                                is(trueForAdmins.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            Matchers.startsWith(eperson.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(1)));\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the findByObject return an empty page when the requested object doesn't exist but the uri is\n+     * potentially valid (i.e. deleted object)\n+     * \n+     * @throws Exception\n+     */\n+    public void findByNotExistingObjectTest() throws Exception {\n+        String wrongSiteUri = \"http://localhost/api/core/sites/\" + UUID.randomUUID();\n+\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+        // verify that it works for administrators, no result\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+\n+        // verify that it works for normal loggedin users\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+\n+        // verify that it works for administators inspecting other users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+\n+        // verify that it works for anonymous users\n+        getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+\n+        // verify that it works for administrators inspecting anonymous users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the findByObject return the 400 Bad Request response for invalid or missing URI (required parameter)\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectBadRequestTest() throws Exception {\n+        String[] invalidUris = new String[] {\n+                \"invalid-uri\",\n+                \"\",\n+                \"http://localhost/api/wrongcategory/wrongmodel/1\",\n+                \"http://localhost/api/core/sites/this-is-not-an-uuid\"\n+        };\n+\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+\n+        for (String invalidUri : invalidUris) {\n+            System.out.println(\"Testing the URI: \" + invalidUri);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d64d8932b15922f4baea4f81d77961d5471d7b9"}, "originalPosition": 593}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjczMzQ1MA==", "bodyText": "Another System.out to remove", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382733450", "createdAt": "2020-02-21T18:20:47Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/AuthorizationRestRepositoryIT.java", "diffHunk": "@@ -0,0 +1,1154 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.io.Serializable;\n+import java.util.UUID;\n+\n+import com.jayway.jsonpath.matchers.JsonPathMatchers;\n+import org.dspace.app.rest.authorization.AlwaysFalseFeature;\n+import org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature;\n+import org.dspace.app.rest.authorization.AlwaysTrueFeature;\n+import org.dspace.app.rest.authorization.Authorization;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.authorization.TrueForAdminsFeature;\n+import org.dspace.app.rest.authorization.TrueForLoggedUsersFeature;\n+import org.dspace.app.rest.authorization.TrueForTestUsersFeature;\n+import org.dspace.app.rest.builder.CommunityBuilder;\n+import org.dspace.app.rest.builder.EPersonBuilder;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.matcher.AuthorizationMatcher;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.app.rest.model.CommunityRest;\n+import org.dspace.app.rest.model.EPersonRest;\n+import org.dspace.app.rest.model.ItemRest;\n+import org.dspace.app.rest.model.SiteRest;\n+import org.dspace.app.rest.projection.DefaultProjection;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.content.Community;\n+import org.dspace.content.Site;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.content.service.SiteService;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.services.ConfigurationService;\n+import org.hamcrest.Matchers;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+/**\n+ * Test suite for the Authorization endpoint\n+ * \n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ *\n+ */\n+public class AuthorizationRestRepositoryIT extends AbstractControllerIntegrationTest {\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private AuthorizationRestUtil authorizationRestUtil;\n+\n+    @Autowired\n+    private ConverterService converterService;\n+\n+    @Autowired\n+    private ConfigurationService configurationService;\n+\n+    @Autowired\n+    private Utils utils;\n+\n+    private SiteService siteService;\n+\n+    private AuthorizationFeature alwaysTrue;\n+\n+    private AuthorizationFeature alwaysFalse;\n+\n+    private AuthorizationFeature alwaysException;\n+\n+    private AuthorizationFeature trueForAdmins;\n+\n+    private AuthorizationFeature trueForLoggedUsers;\n+\n+    private AuthorizationFeature trueForTestUsers;\n+\n+    @Override\n+    @Before\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        siteService = ContentServiceFactory.getInstance().getSiteService();\n+        alwaysTrue = authorizationFeatureService.find(AlwaysTrueFeature.NAME);\n+        alwaysFalse = authorizationFeatureService.find(AlwaysFalseFeature.NAME);\n+        alwaysException = authorizationFeatureService.find(AlwaysThrowExceptionFeature.NAME);\n+        trueForAdmins = authorizationFeatureService.find(TrueForAdminsFeature.NAME);\n+        trueForLoggedUsers = authorizationFeatureService.find(TrueForLoggedUsersFeature.NAME);\n+        trueForTestUsers = authorizationFeatureService.find(TrueForTestUsersFeature.NAME);\n+    }\n+\n+    @Test\n+    /**\n+     * This method is not implemented\n+     *\n+     * @throws Exception\n+     */\n+    public void findAllTest() throws Exception {\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations\"))\n+                    .andExpect(status().isMethodNotAllowed());\n+        getClient().perform(get(\"/api/authz/authorizations\"))\n+                    .andExpect(status().isMethodNotAllowed());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that an user can access a specific authorization\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+\n+        // define three authorizations that we know must exists\n+        Authorization authAdminSite = new Authorization(admin, trueForAdmins, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, trueForLoggedUsers, siteRest);\n+        Authorization authAnonymousUserSite = new Authorization(null, alwaysTrue, siteRest);\n+\n+        // access the authorization for the admin user\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authAdminSite))));\n+\n+        // access the authorization for a normal user\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authNormalUserSite))));\n+\n+        // access the authorization for a normal user as administrator\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authNormalUserSite))));\n+\n+        // access the authorization for an anonymous user\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authAnonymousUserSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authAnonymousUserSite))));\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the unauthorized return code is used in the appropriate scenarios\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneUnauthorizedTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+\n+        // define two authorizations that we know must exists\n+        Authorization authAdminSite = new Authorization(admin, alwaysTrue, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysTrue, siteRest);\n+\n+        // try anonymous access to the authorization for the admin user\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isUnauthorized());\n+\n+        // try anonymous access to the authorization for a normal user\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isUnauthorized());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the forbidden return code is used in the appropriate scenarios\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneForbiddenTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+        EPerson testEPerson = EPersonBuilder.createEPerson(context)\n+                .withEmail(\"test-authorization@example.com\")\n+                .withPassword(password).build();\n+        context.restoreAuthSystemState();\n+\n+        // define three authorizations that we know must exists\n+        Authorization authAdminSite = new Authorization(admin, alwaysTrue, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysTrue, siteRest);\n+\n+        String testToken = getAuthToken(testEPerson.getEmail(), password);\n+\n+        // try to access the authorization for the admin user with another user\n+        getClient(testToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isForbidden());\n+\n+        // try to access the authorization of a normal user with another user\n+        getClient(testToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isForbidden());\n+\n+        // check access as a test user to a not existing authorization for another\n+        // eperson (but existing for the test user)\n+        Authorization noTestAuthForNormalUserSite  = new Authorization(eperson, trueForTestUsers, siteRest);\n+        getClient(testToken).perform(get(\"/api/authz/authorizations/\" + noTestAuthForNormalUserSite.getID()))\n+                    .andExpect(status().isForbidden());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the not found return code is used in the appropriate scenarios\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneNotFoundTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+        EPersonRest epersonRest = converterService.toRest(eperson, DefaultProjection.DEFAULT);\n+        context.restoreAuthSystemState();\n+\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+\n+        // define three authorizations that we know will be no granted\n+        Authorization authAdminSite = new Authorization(admin, alwaysFalse, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysFalse, siteRest);\n+        Authorization authAnonymousUserSite = new Authorization(null, alwaysFalse, siteRest);\n+\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isNotFound());\n+\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+        // also the admin cannot retrieve a not existing authorization for the normal user\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                .andExpect(status().isNotFound());\n+\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authAnonymousUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+        // also the admin cannot retrieve a not existing authorization for the anonymous user\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAnonymousUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+\n+        // build a couple of IDs that look good but are related to not existing authorizations\n+        // the trueForAdmins feature is not defined for eperson\n+        String authInvalidType = getAuthorizationID(admin, trueForAdmins, epersonRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authInvalidType))\n+                    .andExpect(status().isNotFound());\n+\n+        // the specified item doesn't exist\n+        String authNotExistingObject = getAuthorizationID(admin, alwaysTrue,\n+                ItemRest.CATEGORY + \".\" + ItemRest.NAME, UUID.randomUUID());\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNotExistingObject))\n+                    .andExpect(status().isNotFound());\n+\n+        // the specified eperson doesn't exist\n+        String authNotExistingEPerson = getAuthorizationID(UUID.randomUUID(), alwaysTrue, siteRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNotExistingEPerson))\n+                    .andExpect(status().isNotFound());\n+\n+        // the specified feature doesn't exist\n+        String authNotExistingFeature = getAuthorizationID(admin, \"notexistingfeature\", siteRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNotExistingFeature))\n+                    .andExpect(status().isNotFound());\n+\n+        // check access as admin to a not existing authorization for another eperson (but existing for the admin)\n+        Authorization noAdminAuthForNormalUserSite  = new Authorization(eperson, trueForAdmins, siteRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + noAdminAuthForNormalUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+\n+        // check a couple of completely wrong IDs\n+        String notValidID = \"notvalidID\";\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + notValidID))\n+                    .andExpect(status().isNotFound());\n+\n+        String notValidIDWithWrongEpersonPart = getAuthorizationID(\"1\", alwaysTrue.getName(),\n+                SiteRest.CATEGORY + \".\" + SiteRest.NAME, site.getID().toString());\n+        // use the admin token otherwise it would result in a forbidden (attempt to access authorization of other users)\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + notValidIDWithWrongEpersonPart))\n+                    .andExpect(status().isNotFound());\n+\n+        String notValidIDWithWrongObjectTypePart = getAuthorizationID(eperson.getID().toString(), alwaysTrue.getName(),\n+                \"SITE\", site.getID().toString());\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + notValidIDWithWrongObjectTypePart))\n+                    .andExpect(status().isNotFound());\n+\n+        String notValidIDWithUnknownObjectTypePart =\n+                getAuthorizationID(eperson.getID().toString(), alwaysTrue.getName(),\n+                        \"core.unknown\", \"1\");\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + notValidIDWithUnknownObjectTypePart))\n+                    .andExpect(status().isNotFound());\n+\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that an exception in the feature check will be reported back\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneInternalServerErrorTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+        // define two authorizations that we know will throw exceptions\n+        Authorization authAdminSite = new Authorization(admin, alwaysException, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysException, siteRest);\n+\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isInternalServerError());\n+\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isInternalServerError());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the search by object works properly in allowed scenarios:\n+     * - for an administrator\n+     * - for an administrator that want to inspect permission of the anonymous users or another user\n+     * - for a logged-in \"normal\" user\n+     * - for anonymous\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, converterService.getProjection(DefaultProjection.NAME));\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+        // verify that it works for administrators\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isOk())\n+            // there are at least 3: alwaysTrue, trueForAdministrators and trueForLoggedUsers\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(3))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            Matchers.startsWith(admin.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(3)));\n+\n+        // verify that it works for normal loggedin users\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            // there are at least 2: alwaysTrue and trueForLoggedUsers\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(2))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName()),\n+                                                is(trueForAdmins.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            Matchers.startsWith(eperson.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(2)));\n+\n+        // verify that it works for administators inspecting other users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            // there are at least 2: alwaysTrue and trueForLoggedUsers\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(2))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName()),\n+                                                // this guarantee that we are looking to the eperson\n+                                                // authz and not to the admin ones\n+                                                is(trueForAdmins.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            // this guarantee that we are looking to the eperson\n+                                            // authz and not to the admin ones\n+                                            Matchers.startsWith(eperson.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(2)));\n+\n+        // verify that it works for anonymous users\n+        getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(1))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName()),\n+                                                is(trueForAdmins.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            Matchers.startsWith(eperson.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(1)));\n+\n+        // verify that it works for administrators inspecting anonymous users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(1))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName()),\n+                                                is(trueForAdmins.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            Matchers.startsWith(eperson.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(1)));\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the findByObject return an empty page when the requested object doesn't exist but the uri is\n+     * potentially valid (i.e. deleted object)\n+     * \n+     * @throws Exception\n+     */\n+    public void findByNotExistingObjectTest() throws Exception {\n+        String wrongSiteUri = \"http://localhost/api/core/sites/\" + UUID.randomUUID();\n+\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+        // verify that it works for administrators, no result\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+\n+        // verify that it works for normal loggedin users\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+\n+        // verify that it works for administators inspecting other users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+\n+        // verify that it works for anonymous users\n+        getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+\n+        // verify that it works for administrators inspecting anonymous users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the findByObject return the 400 Bad Request response for invalid or missing URI (required parameter)\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectBadRequestTest() throws Exception {\n+        String[] invalidUris = new String[] {\n+                \"invalid-uri\",\n+                \"\",\n+                \"http://localhost/api/wrongcategory/wrongmodel/1\",\n+                \"http://localhost/api/core/sites/this-is-not-an-uuid\"\n+        };\n+\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+\n+        for (String invalidUri : invalidUris) {\n+            System.out.println(\"Testing the URI: \" + invalidUri);\n+            // verify that it works for administrators with an invalid or missing uri\n+            String adminToken = getAuthToken(admin.getEmail(), password);\n+            getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri)\n+                    .param(\"eperson\", admin.getID().toString()))\n+                .andExpect(status().isBadRequest());\n+\n+            // verify that it works for normal loggedin users with an invalid or missing uri\n+            String epersonToken = getAuthToken(eperson.getEmail(), password);\n+            getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri)\n+                    .param(\"eperson\", eperson.getID().toString()))\n+                .andExpect(status().isBadRequest());\n+\n+            // verify that it works for administators inspecting other users with an invalid or missing uri\n+            getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri)\n+                    .param(\"eperson\", eperson.getID().toString()))\n+                .andExpect(status().isBadRequest());\n+\n+            // verify that it works for anonymous users with an invalid or missing uri\n+            getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri))\n+                .andExpect(status().isBadRequest());\n+\n+            // verify that it works for administrators inspecting anonymous users with an invalid or missing uri\n+            getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri))\n+                .andExpect(status().isBadRequest());\n+        }\n+        //FIXME add once https://github.com/DSpace/DSpace/pull/2668 is merged\n+        //        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+        //                .param(\"eperson\", admin.getID().toString()))\n+        //            .andExpect(status().isBadRequest());\n+        //        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/object\")\n+        //                .param(\"eperson\", eperson.getID().toString()))\n+        //            .andExpect(status().isBadRequest());\n+        //        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+        //                .param(\"eperson\", eperson.getID().toString()))\n+        //            .andExpect(status().isBadRequest());\n+        //        getClient().perform(get(\"/api/authz/authorizations/search/object\"))\n+        //            .andExpect(status().isBadRequest());\n+        //        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\"))\n+        //            .andExpect(status().isBadRequest());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the findByObject return the 401 Unauthorized response when an eperson is involved\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectUnauthorizedTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, converterService.getProjection(DefaultProjection.NAME));\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+\n+        getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isUnauthorized());\n+\n+        // verify that it works for normal loggedin users with an invalid or missing uri\n+        getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isUnauthorized());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the findByObject return the 403 Forbidden response when a non-admin eperson try to search the\n+     * authorization of another eperson\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectForbiddenTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, converterService.getProjection(DefaultProjection.NAME));\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+        context.turnOffAuthorisationSystem();\n+        EPerson anotherEperson = EPersonBuilder.createEPerson(context).withEmail(\"another@example.com\")\n+                .withPassword(password).build();\n+        context.restoreAuthSystemState();\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+        String anotherToken = getAuthToken(anotherEperson.getEmail(), password);\n+        // verify that he cannot search the admin authorizations\n+        getClient(anotherToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isForbidden());\n+\n+        // verify that he cannot search the authorizations of another \"normal\" eperson\n+        getClient(anotherToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isForbidden());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that an exception in the feature check will be reported back\n+     * @throws Exception\n+     */\n+    public void findByObjectInternalServerErrorTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, converterService.getProjection(DefaultProjection.NAME));\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+\n+        // verify that it works for administrators\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                // use a large page so that the alwaysThrowExceptionFeature is invoked\n+                // this could become insufficient at some point\n+                .param(\"size\", \"100\")\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isInternalServerError());\n+\n+        // verify that it works for normal loggedin users\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                // use a large page so that the alwaysThrowExceptionFeature is invoked\n+                // this could become insufficient at some point\n+                .param(\"size\", \"100\")\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isInternalServerError());\n+\n+        // verify that it works for anonymous users\n+        getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                // use a large page so that the alwaysThrowExceptionFeature is invoked\n+                // this could become insufficient at some point\n+                .param(\"size\", \"100\"))\n+            .andExpect(status().isInternalServerError());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the search by object and feature works properly in allowed scenarios:\n+     * - for an administrator\n+     * - for an administrator that want to inspect permission of the anonymous users or another user\n+     * - for a logged-in \"normal\" user\n+     * - for anonymous\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectAndFeatureTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        Community com = CommunityBuilder.createCommunity(context).withName(\"A test community\").build();\n+        CommunityRest comRest = converterService.toRest(com, converterService.getProjection(DefaultProjection.NAME));\n+        String comUri = utils.linkToSingleResource(comRest, \"self\").getHref();\n+        context.restoreAuthSystemState();\n+\n+        // verify that it works for administrators\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", comUri)\n+                .param(\"projection\", \"full\")\n+                .param(\"feature\", alwaysTrue.getName())\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$.type\", is(\"authorization\")))\n+            .andExpect(jsonPath(\"$._embedded.feature.id\", is(alwaysTrue.getName())))\n+            .andExpect(jsonPath(\"$.id\", Matchers.is(admin.getID().toString() + \"_\" + alwaysTrue.getName() + \"_\"\n+                    + comRest.getUniqueType() + \"_\" + comRest.getId())));\n+\n+        // verify that it works for normal loggedin users\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", comUri)\n+                .param(\"projection\", \"full\")\n+                .param(\"feature\", alwaysTrue.getName())\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$.type\", is(\"authorization\")))\n+            .andExpect(jsonPath(\"$._embedded.feature.id\", is(alwaysTrue.getName())))\n+            .andExpect(jsonPath(\"$.id\", Matchers.is(eperson.getID().toString() + \"_\" + alwaysTrue.getName() + \"_\"\n+                    + comRest.getUniqueType() + \"_\" + comRest.getId())));\n+\n+        // verify that it works for administators inspecting other users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", comUri)\n+                .param(\"projection\", \"full\")\n+                .param(\"feature\", alwaysTrue.getName())\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$.type\", is(\"authorization\")))\n+            .andExpect(jsonPath(\"$._embedded.feature.id\", is(alwaysTrue.getName())))\n+            .andExpect(jsonPath(\"$.id\", Matchers.is(eperson.getID().toString() + \"_\" + alwaysTrue.getName() + \"_\"\n+                    + comRest.getUniqueType() + \"_\" + comRest.getId())));\n+\n+        // verify that it works for anonymous users\n+        getClient().perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", comUri)\n+                .param(\"projection\", \"full\")\n+                .param(\"feature\", alwaysTrue.getName()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$.type\", is(\"authorization\")))\n+            .andExpect(jsonPath(\"$._embedded.feature.id\", is(alwaysTrue.getName())))\n+            .andExpect(jsonPath(\"$.id\",Matchers.is(alwaysTrue.getName() + \"_\"\n+                    + comRest.getUniqueType() + \"_\" + comRest.getId())));\n+\n+        // verify that it works for administrators inspecting anonymous users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", comUri)\n+                .param(\"projection\", \"full\")\n+                .param(\"feature\", alwaysTrue.getName()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$.type\", is(\"authorization\")))\n+            .andExpect(jsonPath(\"$._embedded.feature.id\", is(alwaysTrue.getName())))\n+            .andExpect(jsonPath(\"$.id\",Matchers.is(alwaysTrue.getName() + \"_\"\n+                    + comRest.getUniqueType() + \"_\" + comRest.getId())));\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the search by object and feature works return 204 No Content when a feature is not granted\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectAndFeatureNotGrantedTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, converterService.getProjection(DefaultProjection.NAME));\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+\n+        // verify that it works for administrators\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", siteUri)\n+                .param(\"feature\", alwaysFalse.getName())\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isNoContent());\n+\n+        // verify that it works for normal loggedin users\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", siteUri)\n+                .param(\"feature\", trueForAdmins.getName())\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isNoContent());\n+\n+        // verify that it works for administators inspecting other users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", siteUri)\n+                .param(\"feature\", trueForAdmins.getName())\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isNoContent());\n+\n+        // verify that it works for anonymous users\n+        getClient().perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", siteUri)\n+                .param(\"feature\", trueForLoggedUsers.getName()))\n+            .andExpect(status().isNoContent());\n+\n+        // verify that it works for administrators inspecting anonymous users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", siteUri)\n+                .param(\"feature\", trueForLoggedUsers.getName()))\n+            .andExpect(status().isNoContent());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the findByObject return the 204 No Content code when the requested object doesn't exist but the uri\n+     * is potentially valid (i.e. deleted object) or the feature doesn't exist\n+     * \n+     * @throws Exception\n+     */\n+    public void findByNotExistingObjectAndFeatureTest() throws Exception {\n+        String wrongSiteUri = \"http://localhost/api/core/sites/\" + UUID.randomUUID();\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, converterService.getProjection(DefaultProjection.NAME));\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+        // verify that it works for administrators, no result\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"feature\", alwaysTrue.getName())\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isNoContent());\n+\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", siteUri)\n+                .param(\"feature\", \"not-existing-feature\")\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isNoContent());\n+\n+        // verify that it works for normal loggedin users\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"feature\", alwaysTrue.getName())\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isNoContent());\n+\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", siteUri)\n+                .param(\"feature\", \"not-existing-feature\")\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isNoContent());\n+\n+        // verify that it works for administators inspecting other users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"feature\", alwaysTrue.getName())\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isNoContent());\n+\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", siteUri)\n+                .param(\"feature\", \"not-existing-feature\")\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isNoContent());\n+\n+        // verify that it works for anonymous users\n+        getClient().perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"feature\", alwaysTrue.getName()))\n+            .andExpect(status().isNoContent());\n+\n+        getClient().perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", siteUri)\n+                .param(\"feature\", \"not-existing-feature\"))\n+            .andExpect(status().isNoContent());\n+\n+        // verify that it works for administrators inspecting anonymous users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"feature\", alwaysTrue.getName()))\n+            .andExpect(status().isNoContent());\n+\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", siteUri)\n+                .param(\"feature\", \"not-existing-feature\"))\n+            .andExpect(status().isNoContent());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the findByObject return the 400 Bad Request response for invalid or missing URI or feature (required\n+     * parameters)\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectAndFeatureBadRequestTest() throws Exception {\n+        String[] invalidUris = new String[] {\n+                \"invalid-uri\",\n+                \"\",\n+                \"http://localhost/api/wrongcategory/wrongmodel/1\",\n+                \"http://localhost/api/core/sites/this-is-not-an-uuid\"\n+        };\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, converterService.getProjection(DefaultProjection.NAME));\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+\n+        for (String invalidUri : invalidUris) {\n+            System.out.println(\"Testing the URI: \" + invalidUri);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d64d8932b15922f4baea4f81d77961d5471d7b9"}, "originalPosition": 961}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjczMzU3MQ==", "bodyText": "Again, these tests can be reenabled", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382733571", "createdAt": "2020-02-21T18:21:03Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/AuthorizationRestRepositoryIT.java", "diffHunk": "@@ -0,0 +1,1154 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.io.Serializable;\n+import java.util.UUID;\n+\n+import com.jayway.jsonpath.matchers.JsonPathMatchers;\n+import org.dspace.app.rest.authorization.AlwaysFalseFeature;\n+import org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature;\n+import org.dspace.app.rest.authorization.AlwaysTrueFeature;\n+import org.dspace.app.rest.authorization.Authorization;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.authorization.TrueForAdminsFeature;\n+import org.dspace.app.rest.authorization.TrueForLoggedUsersFeature;\n+import org.dspace.app.rest.authorization.TrueForTestUsersFeature;\n+import org.dspace.app.rest.builder.CommunityBuilder;\n+import org.dspace.app.rest.builder.EPersonBuilder;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.matcher.AuthorizationMatcher;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.app.rest.model.CommunityRest;\n+import org.dspace.app.rest.model.EPersonRest;\n+import org.dspace.app.rest.model.ItemRest;\n+import org.dspace.app.rest.model.SiteRest;\n+import org.dspace.app.rest.projection.DefaultProjection;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.content.Community;\n+import org.dspace.content.Site;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.content.service.SiteService;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.services.ConfigurationService;\n+import org.hamcrest.Matchers;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+/**\n+ * Test suite for the Authorization endpoint\n+ * \n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ *\n+ */\n+public class AuthorizationRestRepositoryIT extends AbstractControllerIntegrationTest {\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private AuthorizationRestUtil authorizationRestUtil;\n+\n+    @Autowired\n+    private ConverterService converterService;\n+\n+    @Autowired\n+    private ConfigurationService configurationService;\n+\n+    @Autowired\n+    private Utils utils;\n+\n+    private SiteService siteService;\n+\n+    private AuthorizationFeature alwaysTrue;\n+\n+    private AuthorizationFeature alwaysFalse;\n+\n+    private AuthorizationFeature alwaysException;\n+\n+    private AuthorizationFeature trueForAdmins;\n+\n+    private AuthorizationFeature trueForLoggedUsers;\n+\n+    private AuthorizationFeature trueForTestUsers;\n+\n+    @Override\n+    @Before\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        siteService = ContentServiceFactory.getInstance().getSiteService();\n+        alwaysTrue = authorizationFeatureService.find(AlwaysTrueFeature.NAME);\n+        alwaysFalse = authorizationFeatureService.find(AlwaysFalseFeature.NAME);\n+        alwaysException = authorizationFeatureService.find(AlwaysThrowExceptionFeature.NAME);\n+        trueForAdmins = authorizationFeatureService.find(TrueForAdminsFeature.NAME);\n+        trueForLoggedUsers = authorizationFeatureService.find(TrueForLoggedUsersFeature.NAME);\n+        trueForTestUsers = authorizationFeatureService.find(TrueForTestUsersFeature.NAME);\n+    }\n+\n+    @Test\n+    /**\n+     * This method is not implemented\n+     *\n+     * @throws Exception\n+     */\n+    public void findAllTest() throws Exception {\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations\"))\n+                    .andExpect(status().isMethodNotAllowed());\n+        getClient().perform(get(\"/api/authz/authorizations\"))\n+                    .andExpect(status().isMethodNotAllowed());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that an user can access a specific authorization\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+\n+        // define three authorizations that we know must exists\n+        Authorization authAdminSite = new Authorization(admin, trueForAdmins, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, trueForLoggedUsers, siteRest);\n+        Authorization authAnonymousUserSite = new Authorization(null, alwaysTrue, siteRest);\n+\n+        // access the authorization for the admin user\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authAdminSite))));\n+\n+        // access the authorization for a normal user\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authNormalUserSite))));\n+\n+        // access the authorization for a normal user as administrator\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authNormalUserSite))));\n+\n+        // access the authorization for an anonymous user\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authAnonymousUserSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authAnonymousUserSite))));\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the unauthorized return code is used in the appropriate scenarios\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneUnauthorizedTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+\n+        // define two authorizations that we know must exists\n+        Authorization authAdminSite = new Authorization(admin, alwaysTrue, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysTrue, siteRest);\n+\n+        // try anonymous access to the authorization for the admin user\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isUnauthorized());\n+\n+        // try anonymous access to the authorization for a normal user\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isUnauthorized());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the forbidden return code is used in the appropriate scenarios\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneForbiddenTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+        EPerson testEPerson = EPersonBuilder.createEPerson(context)\n+                .withEmail(\"test-authorization@example.com\")\n+                .withPassword(password).build();\n+        context.restoreAuthSystemState();\n+\n+        // define three authorizations that we know must exists\n+        Authorization authAdminSite = new Authorization(admin, alwaysTrue, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysTrue, siteRest);\n+\n+        String testToken = getAuthToken(testEPerson.getEmail(), password);\n+\n+        // try to access the authorization for the admin user with another user\n+        getClient(testToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isForbidden());\n+\n+        // try to access the authorization of a normal user with another user\n+        getClient(testToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isForbidden());\n+\n+        // check access as a test user to a not existing authorization for another\n+        // eperson (but existing for the test user)\n+        Authorization noTestAuthForNormalUserSite  = new Authorization(eperson, trueForTestUsers, siteRest);\n+        getClient(testToken).perform(get(\"/api/authz/authorizations/\" + noTestAuthForNormalUserSite.getID()))\n+                    .andExpect(status().isForbidden());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the not found return code is used in the appropriate scenarios\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneNotFoundTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+        EPersonRest epersonRest = converterService.toRest(eperson, DefaultProjection.DEFAULT);\n+        context.restoreAuthSystemState();\n+\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+\n+        // define three authorizations that we know will be no granted\n+        Authorization authAdminSite = new Authorization(admin, alwaysFalse, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysFalse, siteRest);\n+        Authorization authAnonymousUserSite = new Authorization(null, alwaysFalse, siteRest);\n+\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isNotFound());\n+\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+        // also the admin cannot retrieve a not existing authorization for the normal user\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                .andExpect(status().isNotFound());\n+\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authAnonymousUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+        // also the admin cannot retrieve a not existing authorization for the anonymous user\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAnonymousUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+\n+        // build a couple of IDs that look good but are related to not existing authorizations\n+        // the trueForAdmins feature is not defined for eperson\n+        String authInvalidType = getAuthorizationID(admin, trueForAdmins, epersonRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authInvalidType))\n+                    .andExpect(status().isNotFound());\n+\n+        // the specified item doesn't exist\n+        String authNotExistingObject = getAuthorizationID(admin, alwaysTrue,\n+                ItemRest.CATEGORY + \".\" + ItemRest.NAME, UUID.randomUUID());\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNotExistingObject))\n+                    .andExpect(status().isNotFound());\n+\n+        // the specified eperson doesn't exist\n+        String authNotExistingEPerson = getAuthorizationID(UUID.randomUUID(), alwaysTrue, siteRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNotExistingEPerson))\n+                    .andExpect(status().isNotFound());\n+\n+        // the specified feature doesn't exist\n+        String authNotExistingFeature = getAuthorizationID(admin, \"notexistingfeature\", siteRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNotExistingFeature))\n+                    .andExpect(status().isNotFound());\n+\n+        // check access as admin to a not existing authorization for another eperson (but existing for the admin)\n+        Authorization noAdminAuthForNormalUserSite  = new Authorization(eperson, trueForAdmins, siteRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + noAdminAuthForNormalUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+\n+        // check a couple of completely wrong IDs\n+        String notValidID = \"notvalidID\";\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + notValidID))\n+                    .andExpect(status().isNotFound());\n+\n+        String notValidIDWithWrongEpersonPart = getAuthorizationID(\"1\", alwaysTrue.getName(),\n+                SiteRest.CATEGORY + \".\" + SiteRest.NAME, site.getID().toString());\n+        // use the admin token otherwise it would result in a forbidden (attempt to access authorization of other users)\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + notValidIDWithWrongEpersonPart))\n+                    .andExpect(status().isNotFound());\n+\n+        String notValidIDWithWrongObjectTypePart = getAuthorizationID(eperson.getID().toString(), alwaysTrue.getName(),\n+                \"SITE\", site.getID().toString());\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + notValidIDWithWrongObjectTypePart))\n+                    .andExpect(status().isNotFound());\n+\n+        String notValidIDWithUnknownObjectTypePart =\n+                getAuthorizationID(eperson.getID().toString(), alwaysTrue.getName(),\n+                        \"core.unknown\", \"1\");\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + notValidIDWithUnknownObjectTypePart))\n+                    .andExpect(status().isNotFound());\n+\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that an exception in the feature check will be reported back\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneInternalServerErrorTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+        // define two authorizations that we know will throw exceptions\n+        Authorization authAdminSite = new Authorization(admin, alwaysException, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysException, siteRest);\n+\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isInternalServerError());\n+\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isInternalServerError());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the search by object works properly in allowed scenarios:\n+     * - for an administrator\n+     * - for an administrator that want to inspect permission of the anonymous users or another user\n+     * - for a logged-in \"normal\" user\n+     * - for anonymous\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, converterService.getProjection(DefaultProjection.NAME));\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+        // verify that it works for administrators\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isOk())\n+            // there are at least 3: alwaysTrue, trueForAdministrators and trueForLoggedUsers\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(3))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            Matchers.startsWith(admin.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(3)));\n+\n+        // verify that it works for normal loggedin users\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            // there are at least 2: alwaysTrue and trueForLoggedUsers\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(2))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName()),\n+                                                is(trueForAdmins.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            Matchers.startsWith(eperson.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(2)));\n+\n+        // verify that it works for administators inspecting other users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            // there are at least 2: alwaysTrue and trueForLoggedUsers\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(2))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName()),\n+                                                // this guarantee that we are looking to the eperson\n+                                                // authz and not to the admin ones\n+                                                is(trueForAdmins.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            // this guarantee that we are looking to the eperson\n+                                            // authz and not to the admin ones\n+                                            Matchers.startsWith(eperson.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(2)));\n+\n+        // verify that it works for anonymous users\n+        getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(1))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName()),\n+                                                is(trueForAdmins.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            Matchers.startsWith(eperson.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(1)));\n+\n+        // verify that it works for administrators inspecting anonymous users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(1))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName()),\n+                                                is(trueForAdmins.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            Matchers.startsWith(eperson.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(1)));\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the findByObject return an empty page when the requested object doesn't exist but the uri is\n+     * potentially valid (i.e. deleted object)\n+     * \n+     * @throws Exception\n+     */\n+    public void findByNotExistingObjectTest() throws Exception {\n+        String wrongSiteUri = \"http://localhost/api/core/sites/\" + UUID.randomUUID();\n+\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+        // verify that it works for administrators, no result\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+\n+        // verify that it works for normal loggedin users\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+\n+        // verify that it works for administators inspecting other users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+\n+        // verify that it works for anonymous users\n+        getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+\n+        // verify that it works for administrators inspecting anonymous users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the findByObject return the 400 Bad Request response for invalid or missing URI (required parameter)\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectBadRequestTest() throws Exception {\n+        String[] invalidUris = new String[] {\n+                \"invalid-uri\",\n+                \"\",\n+                \"http://localhost/api/wrongcategory/wrongmodel/1\",\n+                \"http://localhost/api/core/sites/this-is-not-an-uuid\"\n+        };\n+\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+\n+        for (String invalidUri : invalidUris) {\n+            System.out.println(\"Testing the URI: \" + invalidUri);\n+            // verify that it works for administrators with an invalid or missing uri\n+            String adminToken = getAuthToken(admin.getEmail(), password);\n+            getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri)\n+                    .param(\"eperson\", admin.getID().toString()))\n+                .andExpect(status().isBadRequest());\n+\n+            // verify that it works for normal loggedin users with an invalid or missing uri\n+            String epersonToken = getAuthToken(eperson.getEmail(), password);\n+            getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri)\n+                    .param(\"eperson\", eperson.getID().toString()))\n+                .andExpect(status().isBadRequest());\n+\n+            // verify that it works for administators inspecting other users with an invalid or missing uri\n+            getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri)\n+                    .param(\"eperson\", eperson.getID().toString()))\n+                .andExpect(status().isBadRequest());\n+\n+            // verify that it works for anonymous users with an invalid or missing uri\n+            getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri))\n+                .andExpect(status().isBadRequest());\n+\n+            // verify that it works for administrators inspecting anonymous users with an invalid or missing uri\n+            getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri))\n+                .andExpect(status().isBadRequest());\n+        }\n+        //FIXME add once https://github.com/DSpace/DSpace/pull/2668 is merged\n+        //        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+        //                .param(\"eperson\", admin.getID().toString()))\n+        //            .andExpect(status().isBadRequest());\n+        //        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/object\")\n+        //                .param(\"eperson\", eperson.getID().toString()))\n+        //            .andExpect(status().isBadRequest());\n+        //        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+        //                .param(\"eperson\", eperson.getID().toString()))\n+        //            .andExpect(status().isBadRequest());\n+        //        getClient().perform(get(\"/api/authz/authorizations/search/object\"))\n+        //            .andExpect(status().isBadRequest());\n+        //        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\"))\n+        //            .andExpect(status().isBadRequest());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the findByObject return the 401 Unauthorized response when an eperson is involved\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectUnauthorizedTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, converterService.getProjection(DefaultProjection.NAME));\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+\n+        getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isUnauthorized());\n+\n+        // verify that it works for normal loggedin users with an invalid or missing uri\n+        getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isUnauthorized());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the findByObject return the 403 Forbidden response when a non-admin eperson try to search the\n+     * authorization of another eperson\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectForbiddenTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, converterService.getProjection(DefaultProjection.NAME));\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+        context.turnOffAuthorisationSystem();\n+        EPerson anotherEperson = EPersonBuilder.createEPerson(context).withEmail(\"another@example.com\")\n+                .withPassword(password).build();\n+        context.restoreAuthSystemState();\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+        String anotherToken = getAuthToken(anotherEperson.getEmail(), password);\n+        // verify that he cannot search the admin authorizations\n+        getClient(anotherToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isForbidden());\n+\n+        // verify that he cannot search the authorizations of another \"normal\" eperson\n+        getClient(anotherToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isForbidden());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that an exception in the feature check will be reported back\n+     * @throws Exception\n+     */\n+    public void findByObjectInternalServerErrorTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, converterService.getProjection(DefaultProjection.NAME));\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+\n+        // verify that it works for administrators\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                // use a large page so that the alwaysThrowExceptionFeature is invoked\n+                // this could become insufficient at some point\n+                .param(\"size\", \"100\")\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isInternalServerError());\n+\n+        // verify that it works for normal loggedin users\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                // use a large page so that the alwaysThrowExceptionFeature is invoked\n+                // this could become insufficient at some point\n+                .param(\"size\", \"100\")\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isInternalServerError());\n+\n+        // verify that it works for anonymous users\n+        getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                // use a large page so that the alwaysThrowExceptionFeature is invoked\n+                // this could become insufficient at some point\n+                .param(\"size\", \"100\"))\n+            .andExpect(status().isInternalServerError());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the search by object and feature works properly in allowed scenarios:\n+     * - for an administrator\n+     * - for an administrator that want to inspect permission of the anonymous users or another user\n+     * - for a logged-in \"normal\" user\n+     * - for anonymous\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectAndFeatureTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        Community com = CommunityBuilder.createCommunity(context).withName(\"A test community\").build();\n+        CommunityRest comRest = converterService.toRest(com, converterService.getProjection(DefaultProjection.NAME));\n+        String comUri = utils.linkToSingleResource(comRest, \"self\").getHref();\n+        context.restoreAuthSystemState();\n+\n+        // verify that it works for administrators\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", comUri)\n+                .param(\"projection\", \"full\")\n+                .param(\"feature\", alwaysTrue.getName())\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$.type\", is(\"authorization\")))\n+            .andExpect(jsonPath(\"$._embedded.feature.id\", is(alwaysTrue.getName())))\n+            .andExpect(jsonPath(\"$.id\", Matchers.is(admin.getID().toString() + \"_\" + alwaysTrue.getName() + \"_\"\n+                    + comRest.getUniqueType() + \"_\" + comRest.getId())));\n+\n+        // verify that it works for normal loggedin users\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", comUri)\n+                .param(\"projection\", \"full\")\n+                .param(\"feature\", alwaysTrue.getName())\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$.type\", is(\"authorization\")))\n+            .andExpect(jsonPath(\"$._embedded.feature.id\", is(alwaysTrue.getName())))\n+            .andExpect(jsonPath(\"$.id\", Matchers.is(eperson.getID().toString() + \"_\" + alwaysTrue.getName() + \"_\"\n+                    + comRest.getUniqueType() + \"_\" + comRest.getId())));\n+\n+        // verify that it works for administators inspecting other users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", comUri)\n+                .param(\"projection\", \"full\")\n+                .param(\"feature\", alwaysTrue.getName())\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$.type\", is(\"authorization\")))\n+            .andExpect(jsonPath(\"$._embedded.feature.id\", is(alwaysTrue.getName())))\n+            .andExpect(jsonPath(\"$.id\", Matchers.is(eperson.getID().toString() + \"_\" + alwaysTrue.getName() + \"_\"\n+                    + comRest.getUniqueType() + \"_\" + comRest.getId())));\n+\n+        // verify that it works for anonymous users\n+        getClient().perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", comUri)\n+                .param(\"projection\", \"full\")\n+                .param(\"feature\", alwaysTrue.getName()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$.type\", is(\"authorization\")))\n+            .andExpect(jsonPath(\"$._embedded.feature.id\", is(alwaysTrue.getName())))\n+            .andExpect(jsonPath(\"$.id\",Matchers.is(alwaysTrue.getName() + \"_\"\n+                    + comRest.getUniqueType() + \"_\" + comRest.getId())));\n+\n+        // verify that it works for administrators inspecting anonymous users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", comUri)\n+                .param(\"projection\", \"full\")\n+                .param(\"feature\", alwaysTrue.getName()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$.type\", is(\"authorization\")))\n+            .andExpect(jsonPath(\"$._embedded.feature.id\", is(alwaysTrue.getName())))\n+            .andExpect(jsonPath(\"$.id\",Matchers.is(alwaysTrue.getName() + \"_\"\n+                    + comRest.getUniqueType() + \"_\" + comRest.getId())));\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the search by object and feature works return 204 No Content when a feature is not granted\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectAndFeatureNotGrantedTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, converterService.getProjection(DefaultProjection.NAME));\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+\n+        // verify that it works for administrators\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", siteUri)\n+                .param(\"feature\", alwaysFalse.getName())\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isNoContent());\n+\n+        // verify that it works for normal loggedin users\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", siteUri)\n+                .param(\"feature\", trueForAdmins.getName())\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isNoContent());\n+\n+        // verify that it works for administators inspecting other users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", siteUri)\n+                .param(\"feature\", trueForAdmins.getName())\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isNoContent());\n+\n+        // verify that it works for anonymous users\n+        getClient().perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", siteUri)\n+                .param(\"feature\", trueForLoggedUsers.getName()))\n+            .andExpect(status().isNoContent());\n+\n+        // verify that it works for administrators inspecting anonymous users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", siteUri)\n+                .param(\"feature\", trueForLoggedUsers.getName()))\n+            .andExpect(status().isNoContent());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the findByObject return the 204 No Content code when the requested object doesn't exist but the uri\n+     * is potentially valid (i.e. deleted object) or the feature doesn't exist\n+     * \n+     * @throws Exception\n+     */\n+    public void findByNotExistingObjectAndFeatureTest() throws Exception {\n+        String wrongSiteUri = \"http://localhost/api/core/sites/\" + UUID.randomUUID();\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, converterService.getProjection(DefaultProjection.NAME));\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+        // verify that it works for administrators, no result\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"feature\", alwaysTrue.getName())\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isNoContent());\n+\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", siteUri)\n+                .param(\"feature\", \"not-existing-feature\")\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isNoContent());\n+\n+        // verify that it works for normal loggedin users\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"feature\", alwaysTrue.getName())\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isNoContent());\n+\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", siteUri)\n+                .param(\"feature\", \"not-existing-feature\")\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isNoContent());\n+\n+        // verify that it works for administators inspecting other users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"feature\", alwaysTrue.getName())\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isNoContent());\n+\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", siteUri)\n+                .param(\"feature\", \"not-existing-feature\")\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isNoContent());\n+\n+        // verify that it works for anonymous users\n+        getClient().perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"feature\", alwaysTrue.getName()))\n+            .andExpect(status().isNoContent());\n+\n+        getClient().perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", siteUri)\n+                .param(\"feature\", \"not-existing-feature\"))\n+            .andExpect(status().isNoContent());\n+\n+        // verify that it works for administrators inspecting anonymous users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"feature\", alwaysTrue.getName()))\n+            .andExpect(status().isNoContent());\n+\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", siteUri)\n+                .param(\"feature\", \"not-existing-feature\"))\n+            .andExpect(status().isNoContent());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the findByObject return the 400 Bad Request response for invalid or missing URI or feature (required\n+     * parameters)\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectAndFeatureBadRequestTest() throws Exception {\n+        String[] invalidUris = new String[] {\n+                \"invalid-uri\",\n+                \"\",\n+                \"http://localhost/api/wrongcategory/wrongmodel/1\",\n+                \"http://localhost/api/core/sites/this-is-not-an-uuid\"\n+        };\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, converterService.getProjection(DefaultProjection.NAME));\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+\n+        for (String invalidUri : invalidUris) {\n+            System.out.println(\"Testing the URI: \" + invalidUri);\n+            // verify that it works for administrators with an invalid or missing uri\n+            String adminToken = getAuthToken(admin.getEmail(), password);\n+            getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                    .param(\"uri\", invalidUri)\n+                    .param(\"feature\", alwaysTrue.getName())\n+                    .param(\"eperson\", admin.getID().toString()))\n+                .andExpect(status().isBadRequest());\n+\n+            // verify that it works for normal loggedin users with an invalid or missing uri\n+            String epersonToken = getAuthToken(eperson.getEmail(), password);\n+            getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri)\n+                    .param(\"feature\", alwaysTrue.getName())\n+                    .param(\"eperson\", eperson.getID().toString()))\n+                .andExpect(status().isBadRequest());\n+\n+            // verify that it works for administators inspecting other users with an invalid or missing uri\n+            getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri)\n+                    .param(\"feature\", alwaysTrue.getName())\n+                    .param(\"eperson\", eperson.getID().toString()))\n+                .andExpect(status().isBadRequest());\n+\n+            // verify that it works for anonymous users with an invalid or missing uri\n+            getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri)\n+                    .param(\"feature\", alwaysTrue.getName()))\n+                .andExpect(status().isBadRequest());\n+\n+            // verify that it works for administrators inspecting anonymous users with an invalid or missing uri\n+            getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri)\n+                    .param(\"feature\", alwaysTrue.getName()))\n+                .andExpect(status().isBadRequest());\n+        }\n+\n+        //FIXME add once https://github.com/DSpace/DSpace/pull/2668 is merged", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d64d8932b15922f4baea4f81d77961d5471d7b9"}, "originalPosition": 998}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjczNTE3Mg==", "bodyText": "All these private AuthorizationFeature variables were initially confusing to me, as it wasn't clear these were real test data classes.  Since this alwaysFalse feature is actually represented by the AlwaysFalseFeature class, I wonder if we should reference it here by that class.  Otherwise, this IT looks a little confusing, as it's unclear what test classes it's using.", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382735172", "createdAt": "2020-02-21T18:24:32Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/AuthorizationRestRepositoryIT.java", "diffHunk": "@@ -0,0 +1,1154 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.io.Serializable;\n+import java.util.UUID;\n+\n+import com.jayway.jsonpath.matchers.JsonPathMatchers;\n+import org.dspace.app.rest.authorization.AlwaysFalseFeature;\n+import org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature;\n+import org.dspace.app.rest.authorization.AlwaysTrueFeature;\n+import org.dspace.app.rest.authorization.Authorization;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.authorization.TrueForAdminsFeature;\n+import org.dspace.app.rest.authorization.TrueForLoggedUsersFeature;\n+import org.dspace.app.rest.authorization.TrueForTestUsersFeature;\n+import org.dspace.app.rest.builder.CommunityBuilder;\n+import org.dspace.app.rest.builder.EPersonBuilder;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.matcher.AuthorizationMatcher;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.app.rest.model.CommunityRest;\n+import org.dspace.app.rest.model.EPersonRest;\n+import org.dspace.app.rest.model.ItemRest;\n+import org.dspace.app.rest.model.SiteRest;\n+import org.dspace.app.rest.projection.DefaultProjection;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.content.Community;\n+import org.dspace.content.Site;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.content.service.SiteService;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.services.ConfigurationService;\n+import org.hamcrest.Matchers;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+/**\n+ * Test suite for the Authorization endpoint\n+ * \n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ *\n+ */\n+public class AuthorizationRestRepositoryIT extends AbstractControllerIntegrationTest {\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private AuthorizationRestUtil authorizationRestUtil;\n+\n+    @Autowired\n+    private ConverterService converterService;\n+\n+    @Autowired\n+    private ConfigurationService configurationService;\n+\n+    @Autowired\n+    private Utils utils;\n+\n+    private SiteService siteService;\n+\n+    private AuthorizationFeature alwaysTrue;\n+\n+    private AuthorizationFeature alwaysFalse;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d64d8932b15922f4baea4f81d77961d5471d7b9"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjczNzAwOQ==", "bodyText": "I'm unclear why this change is needed.  It's not obvious to me where this is being used in this PR.", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r382737009", "createdAt": "2020-02-21T18:28:18Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/discovery/IndexableObject.java", "diffHunk": "@@ -21,7 +21,7 @@\n  * @param <PK>\n  *            the Class of the primary key\n  */\n-public interface IndexableObject<T extends ReloadableEntity, PK extends Serializable> {\n+public interface IndexableObject<T extends ReloadableEntity<PK>, PK extends Serializable> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d64d8932b15922f4baea4f81d77961d5471d7b9"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "de8e3ec93bee615195cc219f4b99b9679675beff", "author": {"user": {"login": "abollini", "name": "Andrea Bollini"}}, "url": "https://github.com/DSpace/DSpace/commit/de8e3ec93bee615195cc219f4b99b9679675beff", "committedDate": "2020-02-22T14:39:20Z", "message": "Add IT to proof that the AuthorizeConfiguration support the config reload"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6acfd30d1509902f0063fa96001edfba0d7474a7", "author": {"user": {"login": "abollini", "name": "Andrea Bollini"}}, "url": "https://github.com/DSpace/DSpace/commit/6acfd30d1509902f0063fa96001edfba0d7474a7", "committedDate": "2020-02-22T15:40:08Z", "message": "Code cleanup and improved documentation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d797ab0407df2d0003285bc9dd488cbb9343ba36", "author": {"user": {"login": "abollini", "name": "Andrea Bollini"}}, "url": "https://github.com/DSpace/DSpace/commit/d797ab0407df2d0003285bc9dd488cbb9343ba36", "committedDate": "2020-02-22T15:40:47Z", "message": "track the reset of the local.cfg file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2726bc627776de8e55444958d2177695906954fc", "author": {"user": {"login": "abollini", "name": "Andrea Bollini"}}, "url": "https://github.com/DSpace/DSpace/commit/2726bc627776de8e55444958d2177695906954fc", "committedDate": "2020-02-22T15:52:13Z", "message": "Merge branch 'master' of https://github.com/DSpace/DSpace into authz"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "81b9a18e81d517db887273eba09b6ca97483b248", "author": {"user": {"login": "abollini", "name": "Andrea Bollini"}}, "url": "https://github.com/DSpace/DSpace/commit/81b9a18e81d517db887273eba09b6ca97483b248", "committedDate": "2020-02-22T16:02:53Z", "message": "Enable additional test for bad request"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "61cd47107975ed1d49283252d4f60b8604424ac5", "author": {"user": {"login": "abollini", "name": "Andrea Bollini"}}, "url": "https://github.com/DSpace/DSpace/commit/61cd47107975ed1d49283252d4f60b8604424ac5", "committedDate": "2020-02-22T16:04:29Z", "message": "remove unused field"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "adfe2b6959a89763d573652939ad0f28846a561f", "author": {"user": {"login": "abollini", "name": "Andrea Bollini"}}, "url": "https://github.com/DSpace/DSpace/commit/adfe2b6959a89763d573652939ad0f28846a561f", "committedDate": "2020-02-22T16:26:46Z", "message": "Move the getBaseObjectRestFromUri method to the Utils class and add javadoc"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0OTIzMzM0", "url": "https://github.com/DSpace/DSpace/pull/2663#pullrequestreview-364923334", "createdAt": "2020-02-26T14:05:46Z", "commit": {"oid": "adfe2b6959a89763d573652939ad0f28846a561f"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNDowNTo0NlrOFusvDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNTo1MjowM1rOFuxJtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUxMTc1OA==", "bodyText": "Where did the 5.5 seconds originate from?\nIs this because the configuration will auto-verify every 5 seconds, or will this be dependent on the responsiveness of the environment?\nSince each call to appendToLocalConfiguration increases test duration and each destroy after the appendToLocalConfiguration was call will also increase test duration, I would prefer to add a warning to minimize use of this method", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r384511758", "createdAt": "2020-02-26T14:05:46Z", "author": {"login": "benbosman"}, "path": "dspace-api/src/test/java/org/dspace/AbstractIntegrationTest.java", "diffHunk": "@@ -21,5 +32,96 @@\n  */\n @Ignore\n public class AbstractIntegrationTest extends AbstractUnitTest {\n-    // This class intentionally left blank.\n+\n+    /**\n+     * holds the size of the local.cfg file, see {@link #cleanExtraConfigurations()}\n+     **/\n+    private long initialLocalCfgSize;\n+\n+    /**\n+     * set to true if the local cfg has been manipulated\n+     */\n+    private boolean localCfgChanged = false;\n+\n+    @Override\n+    @Before\n+    /**\n+     * Extend the {@link AbstractUnitTest#init} method to deal with extra\n+     * configuration that can be manipulated at runtime during the Integration Test\n+     */\n+    public void init() {\n+        super.init();\n+        String extraConfPath = getLocalConfigurationFilePath();\n+        FileChannel fileOpen;\n+        try {\n+            fileOpen = FileChannel.open(Paths.get(extraConfPath), StandardOpenOption.READ);\n+            initialLocalCfgSize = fileOpen.size();\n+            fileOpen.close();\n+        } catch (IOException e) {\n+            throw new RuntimeException(e.getMessage(), e);\n+        }\n+    }\n+\n+    @Override\n+    @After\n+    /**\n+     * Extend the {@link AbstractUnitTest#destroy} method to deal with extra\n+     * configurations that can be manipulated at runtime during the Integration Test\n+     */\n+    public void destroy() {\n+        super.destroy();\n+        cleanExtraConfigurations();\n+    }\n+\n+    /**\n+     * Restore the local.cfg file to its initial size\n+     */\n+    protected void cleanExtraConfigurations() {\n+        if (!localCfgChanged) {\n+            // return immediately as no changes have been applied so we can avoid to wait\n+            // for configuration reload\n+            return;\n+        }\n+        String extraConfPath = getLocalConfigurationFilePath();\n+        try {\n+            FileChannel.open(Paths.get(extraConfPath), StandardOpenOption.WRITE)\n+                .truncate(initialLocalCfgSize).close();\n+            localCfgChanged = false;\n+            // sleep for 5.5 seconds to give the time to the configuration to note the change\n+            Thread.sleep(5500);\n+        } catch (IOException | InterruptedException e) {\n+            throw new RuntimeException(e.getMessage(), e);\n+        }\n+    }\n+\n+    /**\n+     * \n+     * @return the full path to the in use local.cfg file\n+     */\n+    private String getLocalConfigurationFilePath() {\n+        return new DSpace().getConfigurationService()\n+                .getProperty(\"dspace.dir\") + \"/config/local.cfg\";\n+    }\n+\n+    /**\n+     * Append the input text to the current local.cfg file assuring\n+     * that the new text goes in a new line and sleep enough time to allow the\n+     * configuration reload\n+     * \n+     * @param textToAppend\n+     */\n+    protected void appendToLocalConfiguration(String textToAppend) {\n+        String extraConfPath = getLocalConfigurationFilePath();\n+        try (Writer output = new BufferedWriter(new FileWriter(extraConfPath, true))) {\n+            output.append(\"\\n\");\n+            output.append(textToAppend);\n+            output.flush();\n+            output.close();\n+            localCfgChanged = true;\n+            // sleep for 5.5 seconds to give the time to the configuration to note the change\n+            Thread.sleep(5500);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adfe2b6959a89763d573652939ad0f28846a561f"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUxNjE0Ng==", "bodyText": "Since this is bound to an EPerson, how will this impact special groups?\nPerhaps this can be sorted out with an IT verifying for a user who's permissions are granted via a special group (e.g. using IPAuthentication or password authentication)", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r384516146", "createdAt": "2020-02-26T14:12:57Z", "author": {"login": "benbosman"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/authorization/Authorization.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.authorization;\n+\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.content.Site;\n+import org.dspace.discovery.IndexableObject;\n+import org.dspace.eperson.EPerson;\n+\n+/**\n+ * An authorization is the right for a specific {@link EPerson}, eventually null to indicate unauthenticated users, to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adfe2b6959a89763d573652939ad0f28846a561f"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUyMDQyMQ==", "bodyText": "Could you also add a description for at least some of the features, this is currently not used", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r384520421", "createdAt": "2020-02-26T14:19:38Z", "author": {"login": "benbosman"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/authorization/AuthorizationFeature.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.authorization;\n+\n+import java.sql.SQLException;\n+\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.app.rest.model.RestModel;\n+import org.dspace.app.rest.model.SiteRest;\n+import org.dspace.core.Context;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+/**\n+ * A feature is the representation of a business goal used in the Authorization endpoint to declare what an user can do\n+ * on a specific object.\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+public interface AuthorizationFeature {\n+    /**\n+     * Check if the eperson in the provided context, or the anonymous user if not loggedin, has access to the feature\n+     * for the requested object\n+     * \n+     * @param context\n+     *            the DSpace Context\n+     * @param object\n+     *            the object target by the feature (MUST be NOT null). Use the {@link SiteRest} object for repository\n+     *            wide feature\n+     * @return true if the user associated with the context has access to the feature for the specified object\n+     */\n+    boolean isAuthorized(Context context, BaseObjectRest object) throws SQLException;\n+\n+    /**\n+     * Return the name of the feature\n+     * \n+     * @return the name of the feature\n+     */\n+    default String getName() {\n+        AuthorizationFeatureDocumentation anno =\n+                AnnotationUtils.findAnnotation(this.getClass(), AuthorizationFeatureDocumentation.class);\n+        if (anno != null) {\n+            return anno.name();\n+        }\n+        return this.getClass().getSimpleName();\n+    }\n+\n+    /**\n+     * Return the description of the feature\n+     *\n+     * @return the description of the feature\n+     */\n+    default String getDescription() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adfe2b6959a89763d573652939ad0f28846a561f"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUyNzgyMw==", "bodyText": "Can you add a description here, this feature is not clear based on the name alone. The JavaDocs are quite clear and would be a good start except for the fact that I wasn't sure whether this is limited to archived items", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r384527823", "createdAt": "2020-02-26T14:31:15Z", "author": {"login": "benbosman"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/authorization/impl/CCLicenseFeature.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.authorization.impl;\n+\n+import java.sql.SQLException;\n+\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureDocumentation;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.app.rest.model.ItemRest;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.app.util.AuthorizeUtil;\n+import org.dspace.authorize.AuthorizeException;\n+import org.dspace.content.Item;\n+import org.dspace.core.Context;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+\n+/**\n+ * The cclicense feature. It can be used by administrators (or community/collection delegate) to manage the Creative\n+ * Commons license for an item\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+@Component\n+@AuthorizationFeatureDocumentation(name = CCLicenseFeature.NAME)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adfe2b6959a89763d573652939ad0f28846a561f"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUzOTM1MA==", "bodyText": "Can you add a comment clearly stating this user can be null", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r384539350", "createdAt": "2020-02-26T14:48:29Z", "author": {"login": "benbosman"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/AuthorizationRestRepository.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.repository;\n+\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import org.dspace.app.rest.Parameter;\n+import org.dspace.app.rest.SearchRestMethod;\n+import org.dspace.app.rest.authorization.Authorization;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.exception.RepositoryMethodNotImplementedException;\n+import org.dspace.app.rest.model.AuthorizationRest;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.authorize.AuthorizeException;\n+import org.dspace.authorize.service.AuthorizeService;\n+import org.dspace.core.Context;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.service.EPersonService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Component;\n+\n+\n+/**\n+ * This is the repository responsible to manage Authorization Rest object\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+\n+@Component(AuthorizationRest.CATEGORY + \".\" + AuthorizationRest.NAME)\n+public class AuthorizationRestRepository extends DSpaceRestRepository<AuthorizationRest, String> {\n+\n+    private static final Logger log = LoggerFactory.getLogger(AuthorizationRestRepository.class);\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private AuthorizationRestUtil authorizationRestUtil;\n+\n+    @Autowired\n+    private AuthorizeService authorizeService;\n+\n+    @Autowired\n+    private EPersonService epersonService;\n+\n+    @Autowired\n+    protected ConverterService converter;\n+\n+    @Override\n+    @PreAuthorize(\"hasPermission(#id, 'authorization', 'READ')\")\n+    public AuthorizationRest findOne(Context context, String id) {\n+\n+        AuthorizationRest authorizationRest = null;\n+\n+        String featureName;\n+        try {\n+            featureName = authorizationRestUtil.getFeatureName(id);\n+        } catch (IllegalArgumentException e) {\n+            log.warn(e.getMessage(), e);\n+            return null;\n+        }\n+        try {\n+            BaseObjectRest object = null;\n+            try {\n+                object = authorizationRestUtil.getObject(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Object informations not found in the specified id \" + id, e);\n+                return null;\n+            }\n+\n+            AuthorizationFeature authorizationFeature = null;\n+            if (featureName != null) {\n+                authorizationFeature = authorizationFeatureService.find(featureName);\n+            }\n+\n+            if (authorizationFeature == null) {\n+                return null;\n+            }\n+            // get the user specified identified by the id\n+            EPerson user;\n+            try {\n+                user = authorizationRestUtil.getEperson(context, id);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adfe2b6959a89763d573652939ad0f28846a561f"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU0MTcxMA==", "bodyText": "If the current context contains special groups, but they're not applicable for the included user (admins requesting permissions of other users), those special groups seem to be used to verify the user is authorized\nCan you add an IT for this use case, and resolve this if it's indeed a problem (e.g. temporarily removing the special groups for the test and making sure they're not permanently removed)", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r384541710", "createdAt": "2020-02-26T14:51:44Z", "author": {"login": "benbosman"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/AuthorizationRestRepository.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.repository;\n+\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import org.dspace.app.rest.Parameter;\n+import org.dspace.app.rest.SearchRestMethod;\n+import org.dspace.app.rest.authorization.Authorization;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.exception.RepositoryMethodNotImplementedException;\n+import org.dspace.app.rest.model.AuthorizationRest;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.authorize.AuthorizeException;\n+import org.dspace.authorize.service.AuthorizeService;\n+import org.dspace.core.Context;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.service.EPersonService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Component;\n+\n+\n+/**\n+ * This is the repository responsible to manage Authorization Rest object\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+\n+@Component(AuthorizationRest.CATEGORY + \".\" + AuthorizationRest.NAME)\n+public class AuthorizationRestRepository extends DSpaceRestRepository<AuthorizationRest, String> {\n+\n+    private static final Logger log = LoggerFactory.getLogger(AuthorizationRestRepository.class);\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private AuthorizationRestUtil authorizationRestUtil;\n+\n+    @Autowired\n+    private AuthorizeService authorizeService;\n+\n+    @Autowired\n+    private EPersonService epersonService;\n+\n+    @Autowired\n+    protected ConverterService converter;\n+\n+    @Override\n+    @PreAuthorize(\"hasPermission(#id, 'authorization', 'READ')\")\n+    public AuthorizationRest findOne(Context context, String id) {\n+\n+        AuthorizationRest authorizationRest = null;\n+\n+        String featureName;\n+        try {\n+            featureName = authorizationRestUtil.getFeatureName(id);\n+        } catch (IllegalArgumentException e) {\n+            log.warn(e.getMessage(), e);\n+            return null;\n+        }\n+        try {\n+            BaseObjectRest object = null;\n+            try {\n+                object = authorizationRestUtil.getObject(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Object informations not found in the specified id \" + id, e);\n+                return null;\n+            }\n+\n+            AuthorizationFeature authorizationFeature = null;\n+            if (featureName != null) {\n+                authorizationFeature = authorizationFeatureService.find(featureName);\n+            }\n+\n+            if (authorizationFeature == null) {\n+                return null;\n+            }\n+            // get the user specified identified by the id\n+            EPerson user;\n+            try {\n+                user = authorizationRestUtil.getEperson(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Invalid eperson informations in the specified id \" + id, e);\n+                return null;\n+            }\n+            EPerson currUser = context.getCurrentUser();\n+            // Temporarily change the Context's current user in order to retrieve\n+            // authorizations based on that user\n+            context.setCurrentUser(user);\n+\n+            if (authorizationFeatureService.isAuthorized(context, authorizationFeature, object)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adfe2b6959a89763d573652939ad0f28846a561f"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU0NDk3Mw==", "bodyText": "The Javadocs don't match the method parameters here", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r384544973", "createdAt": "2020-02-26T14:56:22Z", "author": {"login": "benbosman"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/AuthorizationRestRepository.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.repository;\n+\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import org.dspace.app.rest.Parameter;\n+import org.dspace.app.rest.SearchRestMethod;\n+import org.dspace.app.rest.authorization.Authorization;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.exception.RepositoryMethodNotImplementedException;\n+import org.dspace.app.rest.model.AuthorizationRest;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.authorize.AuthorizeException;\n+import org.dspace.authorize.service.AuthorizeService;\n+import org.dspace.core.Context;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.service.EPersonService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Component;\n+\n+\n+/**\n+ * This is the repository responsible to manage Authorization Rest object\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+\n+@Component(AuthorizationRest.CATEGORY + \".\" + AuthorizationRest.NAME)\n+public class AuthorizationRestRepository extends DSpaceRestRepository<AuthorizationRest, String> {\n+\n+    private static final Logger log = LoggerFactory.getLogger(AuthorizationRestRepository.class);\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private AuthorizationRestUtil authorizationRestUtil;\n+\n+    @Autowired\n+    private AuthorizeService authorizeService;\n+\n+    @Autowired\n+    private EPersonService epersonService;\n+\n+    @Autowired\n+    protected ConverterService converter;\n+\n+    @Override\n+    @PreAuthorize(\"hasPermission(#id, 'authorization', 'READ')\")\n+    public AuthorizationRest findOne(Context context, String id) {\n+\n+        AuthorizationRest authorizationRest = null;\n+\n+        String featureName;\n+        try {\n+            featureName = authorizationRestUtil.getFeatureName(id);\n+        } catch (IllegalArgumentException e) {\n+            log.warn(e.getMessage(), e);\n+            return null;\n+        }\n+        try {\n+            BaseObjectRest object = null;\n+            try {\n+                object = authorizationRestUtil.getObject(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Object informations not found in the specified id \" + id, e);\n+                return null;\n+            }\n+\n+            AuthorizationFeature authorizationFeature = null;\n+            if (featureName != null) {\n+                authorizationFeature = authorizationFeatureService.find(featureName);\n+            }\n+\n+            if (authorizationFeature == null) {\n+                return null;\n+            }\n+            // get the user specified identified by the id\n+            EPerson user;\n+            try {\n+                user = authorizationRestUtil.getEperson(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Invalid eperson informations in the specified id \" + id, e);\n+                return null;\n+            }\n+            EPerson currUser = context.getCurrentUser();\n+            // Temporarily change the Context's current user in order to retrieve\n+            // authorizations based on that user\n+            context.setCurrentUser(user);\n+\n+            if (authorizationFeatureService.isAuthorized(context, authorizationFeature, object)) {\n+                Authorization authz = new Authorization();\n+                authz.setEperson(user);\n+                authz.setFeature(authorizationFeature);\n+                authz.setObject(object);\n+                authorizationRest = converter.toRest(authz, utils.obtainProjection());\n+            }\n+            // restore the real current user\n+            context.setCurrentUser(currUser);\n+        } catch (SQLException e) {\n+            throw new RuntimeException(e.getMessage(), e);\n+        }\n+\n+        return authorizationRest;\n+    }\n+\n+\n+    /**\n+     * It returns the list of matching available authorizations granted to the specified eperson or to the anonymous\n+     * user. Only administrators and the user identified by the epersonUuid parameter can access this method\n+     *\n+     * \n+     * @param context\n+     *            the DSpace Context\n+     * @param uri\n+     *            the uri of the object to check the authorization against\n+     * @param epersonUuid\n+     *            the eperson uuid to use in the authorization evaluation\n+     * @param featureName\n+     *            limit the authorization check to only the feature identified via its name\n+     * @param pageable\n+     *            the pagination options\n+     * @return the list of matching authorization available for the requested user and object, filtered by feature if\n+     *         provided\n+     * @throws AuthorizeException\n+     * @throws SQLException\n+     */\n+    @PreAuthorize(\"#epersonUuid==null || hasPermission(#epersonUuid, 'EPERSON', 'READ')\")\n+    @SearchRestMethod(name = \"object\")\n+    public Page<AuthorizationRest> findByObject(@Parameter(value = \"uri\", required = true) String uri,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adfe2b6959a89763d573652939ad0f28846a561f"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU0NzAwOA==", "bodyText": "Similar to above, can you check the impact of special groups", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r384547008", "createdAt": "2020-02-26T14:59:17Z", "author": {"login": "benbosman"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/AuthorizationRestRepository.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.repository;\n+\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import org.dspace.app.rest.Parameter;\n+import org.dspace.app.rest.SearchRestMethod;\n+import org.dspace.app.rest.authorization.Authorization;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.exception.RepositoryMethodNotImplementedException;\n+import org.dspace.app.rest.model.AuthorizationRest;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.authorize.AuthorizeException;\n+import org.dspace.authorize.service.AuthorizeService;\n+import org.dspace.core.Context;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.service.EPersonService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Component;\n+\n+\n+/**\n+ * This is the repository responsible to manage Authorization Rest object\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+\n+@Component(AuthorizationRest.CATEGORY + \".\" + AuthorizationRest.NAME)\n+public class AuthorizationRestRepository extends DSpaceRestRepository<AuthorizationRest, String> {\n+\n+    private static final Logger log = LoggerFactory.getLogger(AuthorizationRestRepository.class);\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private AuthorizationRestUtil authorizationRestUtil;\n+\n+    @Autowired\n+    private AuthorizeService authorizeService;\n+\n+    @Autowired\n+    private EPersonService epersonService;\n+\n+    @Autowired\n+    protected ConverterService converter;\n+\n+    @Override\n+    @PreAuthorize(\"hasPermission(#id, 'authorization', 'READ')\")\n+    public AuthorizationRest findOne(Context context, String id) {\n+\n+        AuthorizationRest authorizationRest = null;\n+\n+        String featureName;\n+        try {\n+            featureName = authorizationRestUtil.getFeatureName(id);\n+        } catch (IllegalArgumentException e) {\n+            log.warn(e.getMessage(), e);\n+            return null;\n+        }\n+        try {\n+            BaseObjectRest object = null;\n+            try {\n+                object = authorizationRestUtil.getObject(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Object informations not found in the specified id \" + id, e);\n+                return null;\n+            }\n+\n+            AuthorizationFeature authorizationFeature = null;\n+            if (featureName != null) {\n+                authorizationFeature = authorizationFeatureService.find(featureName);\n+            }\n+\n+            if (authorizationFeature == null) {\n+                return null;\n+            }\n+            // get the user specified identified by the id\n+            EPerson user;\n+            try {\n+                user = authorizationRestUtil.getEperson(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Invalid eperson informations in the specified id \" + id, e);\n+                return null;\n+            }\n+            EPerson currUser = context.getCurrentUser();\n+            // Temporarily change the Context's current user in order to retrieve\n+            // authorizations based on that user\n+            context.setCurrentUser(user);\n+\n+            if (authorizationFeatureService.isAuthorized(context, authorizationFeature, object)) {\n+                Authorization authz = new Authorization();\n+                authz.setEperson(user);\n+                authz.setFeature(authorizationFeature);\n+                authz.setObject(object);\n+                authorizationRest = converter.toRest(authz, utils.obtainProjection());\n+            }\n+            // restore the real current user\n+            context.setCurrentUser(currUser);\n+        } catch (SQLException e) {\n+            throw new RuntimeException(e.getMessage(), e);\n+        }\n+\n+        return authorizationRest;\n+    }\n+\n+\n+    /**\n+     * It returns the list of matching available authorizations granted to the specified eperson or to the anonymous\n+     * user. Only administrators and the user identified by the epersonUuid parameter can access this method\n+     *\n+     * \n+     * @param context\n+     *            the DSpace Context\n+     * @param uri\n+     *            the uri of the object to check the authorization against\n+     * @param epersonUuid\n+     *            the eperson uuid to use in the authorization evaluation\n+     * @param featureName\n+     *            limit the authorization check to only the feature identified via its name\n+     * @param pageable\n+     *            the pagination options\n+     * @return the list of matching authorization available for the requested user and object, filtered by feature if\n+     *         provided\n+     * @throws AuthorizeException\n+     * @throws SQLException\n+     */\n+    @PreAuthorize(\"#epersonUuid==null || hasPermission(#epersonUuid, 'EPERSON', 'READ')\")\n+    @SearchRestMethod(name = \"object\")\n+    public Page<AuthorizationRest> findByObject(@Parameter(value = \"uri\", required = true) String uri,\n+            @Parameter(value = \"eperson\") UUID epersonUuid,\n+            Pageable pageable) throws AuthorizeException, SQLException {\n+        Context context = obtainContext();\n+        BaseObjectRest obj = utils.getBaseObjectRestFromUri(context, uri);\n+        if (obj == null) {\n+            return null;\n+        }\n+\n+        EPerson currUser = context.getCurrentUser();\n+        // get the user specified in the requested parameters\n+        EPerson user = getUserFromRequestParameter(context, epersonUuid);\n+        // Temporarily change the Context's current user in order to retrieve\n+        // authorizations based on that user\n+        context.setCurrentUser(user);\n+        List<AuthorizationFeature> features = authorizationFeatureService.findByResourceType(obj.getUniqueType());\n+        List<Authorization> authorizations = new ArrayList<Authorization>();\n+        for (AuthorizationFeature f : features) {\n+            if (authorizationFeatureService.isAuthorized(context, f, obj)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adfe2b6959a89763d573652939ad0f28846a561f"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU0NzE5Nw==", "bodyText": "Similar to above, can you check the impact of special groups", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r384547197", "createdAt": "2020-02-26T14:59:34Z", "author": {"login": "benbosman"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/AuthorizationRestRepository.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.repository;\n+\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import org.dspace.app.rest.Parameter;\n+import org.dspace.app.rest.SearchRestMethod;\n+import org.dspace.app.rest.authorization.Authorization;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.exception.RepositoryMethodNotImplementedException;\n+import org.dspace.app.rest.model.AuthorizationRest;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.authorize.AuthorizeException;\n+import org.dspace.authorize.service.AuthorizeService;\n+import org.dspace.core.Context;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.service.EPersonService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Component;\n+\n+\n+/**\n+ * This is the repository responsible to manage Authorization Rest object\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+\n+@Component(AuthorizationRest.CATEGORY + \".\" + AuthorizationRest.NAME)\n+public class AuthorizationRestRepository extends DSpaceRestRepository<AuthorizationRest, String> {\n+\n+    private static final Logger log = LoggerFactory.getLogger(AuthorizationRestRepository.class);\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private AuthorizationRestUtil authorizationRestUtil;\n+\n+    @Autowired\n+    private AuthorizeService authorizeService;\n+\n+    @Autowired\n+    private EPersonService epersonService;\n+\n+    @Autowired\n+    protected ConverterService converter;\n+\n+    @Override\n+    @PreAuthorize(\"hasPermission(#id, 'authorization', 'READ')\")\n+    public AuthorizationRest findOne(Context context, String id) {\n+\n+        AuthorizationRest authorizationRest = null;\n+\n+        String featureName;\n+        try {\n+            featureName = authorizationRestUtil.getFeatureName(id);\n+        } catch (IllegalArgumentException e) {\n+            log.warn(e.getMessage(), e);\n+            return null;\n+        }\n+        try {\n+            BaseObjectRest object = null;\n+            try {\n+                object = authorizationRestUtil.getObject(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Object informations not found in the specified id \" + id, e);\n+                return null;\n+            }\n+\n+            AuthorizationFeature authorizationFeature = null;\n+            if (featureName != null) {\n+                authorizationFeature = authorizationFeatureService.find(featureName);\n+            }\n+\n+            if (authorizationFeature == null) {\n+                return null;\n+            }\n+            // get the user specified identified by the id\n+            EPerson user;\n+            try {\n+                user = authorizationRestUtil.getEperson(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Invalid eperson informations in the specified id \" + id, e);\n+                return null;\n+            }\n+            EPerson currUser = context.getCurrentUser();\n+            // Temporarily change the Context's current user in order to retrieve\n+            // authorizations based on that user\n+            context.setCurrentUser(user);\n+\n+            if (authorizationFeatureService.isAuthorized(context, authorizationFeature, object)) {\n+                Authorization authz = new Authorization();\n+                authz.setEperson(user);\n+                authz.setFeature(authorizationFeature);\n+                authz.setObject(object);\n+                authorizationRest = converter.toRest(authz, utils.obtainProjection());\n+            }\n+            // restore the real current user\n+            context.setCurrentUser(currUser);\n+        } catch (SQLException e) {\n+            throw new RuntimeException(e.getMessage(), e);\n+        }\n+\n+        return authorizationRest;\n+    }\n+\n+\n+    /**\n+     * It returns the list of matching available authorizations granted to the specified eperson or to the anonymous\n+     * user. Only administrators and the user identified by the epersonUuid parameter can access this method\n+     *\n+     * \n+     * @param context\n+     *            the DSpace Context\n+     * @param uri\n+     *            the uri of the object to check the authorization against\n+     * @param epersonUuid\n+     *            the eperson uuid to use in the authorization evaluation\n+     * @param featureName\n+     *            limit the authorization check to only the feature identified via its name\n+     * @param pageable\n+     *            the pagination options\n+     * @return the list of matching authorization available for the requested user and object, filtered by feature if\n+     *         provided\n+     * @throws AuthorizeException\n+     * @throws SQLException\n+     */\n+    @PreAuthorize(\"#epersonUuid==null || hasPermission(#epersonUuid, 'EPERSON', 'READ')\")\n+    @SearchRestMethod(name = \"object\")\n+    public Page<AuthorizationRest> findByObject(@Parameter(value = \"uri\", required = true) String uri,\n+            @Parameter(value = \"eperson\") UUID epersonUuid,\n+            Pageable pageable) throws AuthorizeException, SQLException {\n+        Context context = obtainContext();\n+        BaseObjectRest obj = utils.getBaseObjectRestFromUri(context, uri);\n+        if (obj == null) {\n+            return null;\n+        }\n+\n+        EPerson currUser = context.getCurrentUser();\n+        // get the user specified in the requested parameters\n+        EPerson user = getUserFromRequestParameter(context, epersonUuid);\n+        // Temporarily change the Context's current user in order to retrieve\n+        // authorizations based on that user\n+        context.setCurrentUser(user);\n+        List<AuthorizationFeature> features = authorizationFeatureService.findByResourceType(obj.getUniqueType());\n+        List<Authorization> authorizations = new ArrayList<Authorization>();\n+        for (AuthorizationFeature f : features) {\n+            if (authorizationFeatureService.isAuthorized(context, f, obj)) {\n+                authorizations.add(new Authorization(user, f, obj));\n+            }\n+        }\n+        // restore the real current user\n+        context.setCurrentUser(currUser);\n+        return converter.toRestPage(utils.getPage(authorizations, pageable), utils.obtainProjection());\n+    }\n+\n+    /**\n+     * It returns the authorization related to the requested feature if granted to the specified eperson or to the\n+     * anonymous user. Only administrators and the user identified by the epersonUuid parameter can access this method\n+     *\n+     * \n+     * @param context\n+     *            the DSpace Context\n+     * @param uri\n+     *            the uri of the object to check the authorization against\n+     * @param epersonUuid\n+     *            the eperson uuid to use in the authorization evaluation\n+     * @param featureName\n+     *            limit the authorization check to only the feature identified via its name\n+     * @param pageable\n+     *            the pagination options\n+     * @return the list of matching authorization available for the requested user and object, filtered by feature if\n+     *         provided\n+     * @throws AuthorizeException\n+     * @throws SQLException\n+     */\n+    @PreAuthorize(\"#epersonUuid==null || hasPermission(#epersonUuid, 'EPERSON', 'READ')\")\n+    @SearchRestMethod(name = \"objectAndFeature\")\n+    public AuthorizationRest findByObjectAndFeature(@Parameter(value = \"uri\", required = true) String uri,\n+            @Parameter(value = \"eperson\") UUID epersonUuid,\n+            @Parameter(value = \"feature\", required = true) String featureName,\n+            Pageable pageable) throws AuthorizeException, SQLException {\n+        Context context = obtainContext();\n+        BaseObjectRest obj = utils.getBaseObjectRestFromUri(context, uri);\n+        if (obj == null) {\n+            return null;\n+        }\n+\n+        EPerson currUser = context.getCurrentUser();\n+        // get the user specified in the requested parameters\n+        EPerson user = getUserFromRequestParameter(context, epersonUuid);\n+        // Temporarily change the Context's current user in order to retrieve\n+        // authorizations based on that user\n+        context.setCurrentUser(user);\n+        AuthorizationFeature feature = authorizationFeatureService.find(featureName);\n+        AuthorizationRest authorizationRest = null;\n+        if (authorizationFeatureService.isAuthorized(context, feature, obj)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adfe2b6959a89763d573652939ad0f28846a561f"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU0NzMyNw==", "bodyText": "The Javadocs don't match the method parameters here", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r384547327", "createdAt": "2020-02-26T14:59:47Z", "author": {"login": "benbosman"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/AuthorizationRestRepository.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.repository;\n+\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import org.dspace.app.rest.Parameter;\n+import org.dspace.app.rest.SearchRestMethod;\n+import org.dspace.app.rest.authorization.Authorization;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.exception.RepositoryMethodNotImplementedException;\n+import org.dspace.app.rest.model.AuthorizationRest;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.authorize.AuthorizeException;\n+import org.dspace.authorize.service.AuthorizeService;\n+import org.dspace.core.Context;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.service.EPersonService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Component;\n+\n+\n+/**\n+ * This is the repository responsible to manage Authorization Rest object\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+\n+@Component(AuthorizationRest.CATEGORY + \".\" + AuthorizationRest.NAME)\n+public class AuthorizationRestRepository extends DSpaceRestRepository<AuthorizationRest, String> {\n+\n+    private static final Logger log = LoggerFactory.getLogger(AuthorizationRestRepository.class);\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private AuthorizationRestUtil authorizationRestUtil;\n+\n+    @Autowired\n+    private AuthorizeService authorizeService;\n+\n+    @Autowired\n+    private EPersonService epersonService;\n+\n+    @Autowired\n+    protected ConverterService converter;\n+\n+    @Override\n+    @PreAuthorize(\"hasPermission(#id, 'authorization', 'READ')\")\n+    public AuthorizationRest findOne(Context context, String id) {\n+\n+        AuthorizationRest authorizationRest = null;\n+\n+        String featureName;\n+        try {\n+            featureName = authorizationRestUtil.getFeatureName(id);\n+        } catch (IllegalArgumentException e) {\n+            log.warn(e.getMessage(), e);\n+            return null;\n+        }\n+        try {\n+            BaseObjectRest object = null;\n+            try {\n+                object = authorizationRestUtil.getObject(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Object informations not found in the specified id \" + id, e);\n+                return null;\n+            }\n+\n+            AuthorizationFeature authorizationFeature = null;\n+            if (featureName != null) {\n+                authorizationFeature = authorizationFeatureService.find(featureName);\n+            }\n+\n+            if (authorizationFeature == null) {\n+                return null;\n+            }\n+            // get the user specified identified by the id\n+            EPerson user;\n+            try {\n+                user = authorizationRestUtil.getEperson(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Invalid eperson informations in the specified id \" + id, e);\n+                return null;\n+            }\n+            EPerson currUser = context.getCurrentUser();\n+            // Temporarily change the Context's current user in order to retrieve\n+            // authorizations based on that user\n+            context.setCurrentUser(user);\n+\n+            if (authorizationFeatureService.isAuthorized(context, authorizationFeature, object)) {\n+                Authorization authz = new Authorization();\n+                authz.setEperson(user);\n+                authz.setFeature(authorizationFeature);\n+                authz.setObject(object);\n+                authorizationRest = converter.toRest(authz, utils.obtainProjection());\n+            }\n+            // restore the real current user\n+            context.setCurrentUser(currUser);\n+        } catch (SQLException e) {\n+            throw new RuntimeException(e.getMessage(), e);\n+        }\n+\n+        return authorizationRest;\n+    }\n+\n+\n+    /**\n+     * It returns the list of matching available authorizations granted to the specified eperson or to the anonymous\n+     * user. Only administrators and the user identified by the epersonUuid parameter can access this method\n+     *\n+     * \n+     * @param context\n+     *            the DSpace Context\n+     * @param uri\n+     *            the uri of the object to check the authorization against\n+     * @param epersonUuid\n+     *            the eperson uuid to use in the authorization evaluation\n+     * @param featureName\n+     *            limit the authorization check to only the feature identified via its name\n+     * @param pageable\n+     *            the pagination options\n+     * @return the list of matching authorization available for the requested user and object, filtered by feature if\n+     *         provided\n+     * @throws AuthorizeException\n+     * @throws SQLException\n+     */\n+    @PreAuthorize(\"#epersonUuid==null || hasPermission(#epersonUuid, 'EPERSON', 'READ')\")\n+    @SearchRestMethod(name = \"object\")\n+    public Page<AuthorizationRest> findByObject(@Parameter(value = \"uri\", required = true) String uri,\n+            @Parameter(value = \"eperson\") UUID epersonUuid,\n+            Pageable pageable) throws AuthorizeException, SQLException {\n+        Context context = obtainContext();\n+        BaseObjectRest obj = utils.getBaseObjectRestFromUri(context, uri);\n+        if (obj == null) {\n+            return null;\n+        }\n+\n+        EPerson currUser = context.getCurrentUser();\n+        // get the user specified in the requested parameters\n+        EPerson user = getUserFromRequestParameter(context, epersonUuid);\n+        // Temporarily change the Context's current user in order to retrieve\n+        // authorizations based on that user\n+        context.setCurrentUser(user);\n+        List<AuthorizationFeature> features = authorizationFeatureService.findByResourceType(obj.getUniqueType());\n+        List<Authorization> authorizations = new ArrayList<Authorization>();\n+        for (AuthorizationFeature f : features) {\n+            if (authorizationFeatureService.isAuthorized(context, f, obj)) {\n+                authorizations.add(new Authorization(user, f, obj));\n+            }\n+        }\n+        // restore the real current user\n+        context.setCurrentUser(currUser);\n+        return converter.toRestPage(utils.getPage(authorizations, pageable), utils.obtainProjection());\n+    }\n+\n+    /**\n+     * It returns the authorization related to the requested feature if granted to the specified eperson or to the\n+     * anonymous user. Only administrators and the user identified by the epersonUuid parameter can access this method\n+     *\n+     * \n+     * @param context\n+     *            the DSpace Context\n+     * @param uri\n+     *            the uri of the object to check the authorization against\n+     * @param epersonUuid\n+     *            the eperson uuid to use in the authorization evaluation\n+     * @param featureName\n+     *            limit the authorization check to only the feature identified via its name\n+     * @param pageable\n+     *            the pagination options\n+     * @return the list of matching authorization available for the requested user and object, filtered by feature if\n+     *         provided\n+     * @throws AuthorizeException\n+     * @throws SQLException\n+     */\n+    @PreAuthorize(\"#epersonUuid==null || hasPermission(#epersonUuid, 'EPERSON', 'READ')\")\n+    @SearchRestMethod(name = \"objectAndFeature\")\n+    public AuthorizationRest findByObjectAndFeature(@Parameter(value = \"uri\", required = true) String uri,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adfe2b6959a89763d573652939ad0f28846a561f"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU0ODY2Mw==", "bodyText": "Isn't this a ReloadableEntityObjectRepository? Findable sounds like it's search related", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r384548663", "createdAt": "2020-02-26T15:01:39Z", "author": {"login": "benbosman"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/FindableObjectRepository.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.repository;\n+\n+import java.io.Serializable;\n+import java.sql.SQLException;\n+\n+import org.dspace.core.Context;\n+import org.dspace.core.ReloadableEntity;\n+\n+/**\n+ * This interface must be implemented by all the rest repository that need to\n+ * provide access to the DSpace API model objects corresponding to the REST\n+ * resources that it manages\n+ * \n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ *\n+ * @param <F> the ReloadableEntity type\n+ * @param <PK> the primary key type\n+ */\n+public interface FindableObjectRepository<T extends ReloadableEntity<PK>,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adfe2b6959a89763d573652939ad0f28846a561f"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1MjY5MQ==", "bodyText": "Why is this not based on context.getCurrentUser()?", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r384552691", "createdAt": "2020-02-26T15:07:53Z", "author": {"login": "benbosman"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/security/ReadAuthorizationPermissionEvaluatorPlugin.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.security;\n+\n+import java.io.Serializable;\n+import java.sql.SQLException;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.model.AuthorizationRest;\n+import org.dspace.app.rest.utils.ContextUtil;\n+import org.dspace.authorize.service.AuthorizeService;\n+import org.dspace.core.Context;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.service.EPersonService;\n+import org.dspace.services.RequestService;\n+import org.dspace.services.model.Request;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.core.Authentication;\n+import org.springframework.stereotype.Component;\n+\n+/**\n+ * {@link RestPermissionEvaluatorPlugin} class that evaluate READ permissions for an Authorization\n+ * \n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+@Component\n+public class ReadAuthorizationPermissionEvaluatorPlugin extends RestObjectPermissionEvaluatorPlugin {\n+\n+    private static final Logger log = LoggerFactory.getLogger(ReadAuthorizationPermissionEvaluatorPlugin.class);\n+\n+    @Autowired\n+    AuthorizeService authorizeService;\n+\n+    @Autowired\n+    private RequestService requestService;\n+\n+    @Autowired\n+    private EPersonService ePersonService;\n+\n+    @Autowired\n+    private AuthorizationRestUtil authorizationRestUtil;\n+\n+    @Override\n+    public boolean hasDSpacePermission(Authentication authentication, Serializable targetId, String targetType,\n+            DSpaceRestPermission permission) {\n+\n+        DSpaceRestPermission restPermission = DSpaceRestPermission.convert(permission);\n+\n+        if (!DSpaceRestPermission.READ.equals(restPermission)\n+                || !StringUtils.equalsIgnoreCase(targetType, AuthorizationRest.NAME)) {\n+            return false;\n+        }\n+\n+        Request request = requestService.getCurrentRequest();\n+        Context context = ContextUtil.obtainContext(request.getServletRequest());\n+        try {\n+            // admin can always access\n+            if (authorizeService.isAdmin(context)) {\n+                return true;\n+            }\n+            EPerson ePerson = authorizationRestUtil.getEperson(context, targetId.toString());\n+            EPerson currUser = null;\n+\n+            currUser = ePersonService.findByEmail(context, (String) authentication.getPrincipal());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adfe2b6959a89763d573652939ad0f28846a561f"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU3MDE5NA==", "bodyText": "why is this a separate endpoint? According to the contract this should be part of the /object endpoint, and the feature is an optional parameter", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r384570194", "createdAt": "2020-02-26T15:32:22Z", "author": {"login": "benbosman"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/AuthorizationRestRepository.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.repository;\n+\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import org.dspace.app.rest.Parameter;\n+import org.dspace.app.rest.SearchRestMethod;\n+import org.dspace.app.rest.authorization.Authorization;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.exception.RepositoryMethodNotImplementedException;\n+import org.dspace.app.rest.model.AuthorizationRest;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.authorize.AuthorizeException;\n+import org.dspace.authorize.service.AuthorizeService;\n+import org.dspace.core.Context;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.service.EPersonService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Component;\n+\n+\n+/**\n+ * This is the repository responsible to manage Authorization Rest object\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+\n+@Component(AuthorizationRest.CATEGORY + \".\" + AuthorizationRest.NAME)\n+public class AuthorizationRestRepository extends DSpaceRestRepository<AuthorizationRest, String> {\n+\n+    private static final Logger log = LoggerFactory.getLogger(AuthorizationRestRepository.class);\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private AuthorizationRestUtil authorizationRestUtil;\n+\n+    @Autowired\n+    private AuthorizeService authorizeService;\n+\n+    @Autowired\n+    private EPersonService epersonService;\n+\n+    @Autowired\n+    protected ConverterService converter;\n+\n+    @Override\n+    @PreAuthorize(\"hasPermission(#id, 'authorization', 'READ')\")\n+    public AuthorizationRest findOne(Context context, String id) {\n+\n+        AuthorizationRest authorizationRest = null;\n+\n+        String featureName;\n+        try {\n+            featureName = authorizationRestUtil.getFeatureName(id);\n+        } catch (IllegalArgumentException e) {\n+            log.warn(e.getMessage(), e);\n+            return null;\n+        }\n+        try {\n+            BaseObjectRest object = null;\n+            try {\n+                object = authorizationRestUtil.getObject(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Object informations not found in the specified id \" + id, e);\n+                return null;\n+            }\n+\n+            AuthorizationFeature authorizationFeature = null;\n+            if (featureName != null) {\n+                authorizationFeature = authorizationFeatureService.find(featureName);\n+            }\n+\n+            if (authorizationFeature == null) {\n+                return null;\n+            }\n+            // get the user specified identified by the id\n+            EPerson user;\n+            try {\n+                user = authorizationRestUtil.getEperson(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Invalid eperson informations in the specified id \" + id, e);\n+                return null;\n+            }\n+            EPerson currUser = context.getCurrentUser();\n+            // Temporarily change the Context's current user in order to retrieve\n+            // authorizations based on that user\n+            context.setCurrentUser(user);\n+\n+            if (authorizationFeatureService.isAuthorized(context, authorizationFeature, object)) {\n+                Authorization authz = new Authorization();\n+                authz.setEperson(user);\n+                authz.setFeature(authorizationFeature);\n+                authz.setObject(object);\n+                authorizationRest = converter.toRest(authz, utils.obtainProjection());\n+            }\n+            // restore the real current user\n+            context.setCurrentUser(currUser);\n+        } catch (SQLException e) {\n+            throw new RuntimeException(e.getMessage(), e);\n+        }\n+\n+        return authorizationRest;\n+    }\n+\n+\n+    /**\n+     * It returns the list of matching available authorizations granted to the specified eperson or to the anonymous\n+     * user. Only administrators and the user identified by the epersonUuid parameter can access this method\n+     *\n+     * \n+     * @param context\n+     *            the DSpace Context\n+     * @param uri\n+     *            the uri of the object to check the authorization against\n+     * @param epersonUuid\n+     *            the eperson uuid to use in the authorization evaluation\n+     * @param featureName\n+     *            limit the authorization check to only the feature identified via its name\n+     * @param pageable\n+     *            the pagination options\n+     * @return the list of matching authorization available for the requested user and object, filtered by feature if\n+     *         provided\n+     * @throws AuthorizeException\n+     * @throws SQLException\n+     */\n+    @PreAuthorize(\"#epersonUuid==null || hasPermission(#epersonUuid, 'EPERSON', 'READ')\")\n+    @SearchRestMethod(name = \"object\")\n+    public Page<AuthorizationRest> findByObject(@Parameter(value = \"uri\", required = true) String uri,\n+            @Parameter(value = \"eperson\") UUID epersonUuid,\n+            Pageable pageable) throws AuthorizeException, SQLException {\n+        Context context = obtainContext();\n+        BaseObjectRest obj = utils.getBaseObjectRestFromUri(context, uri);\n+        if (obj == null) {\n+            return null;\n+        }\n+\n+        EPerson currUser = context.getCurrentUser();\n+        // get the user specified in the requested parameters\n+        EPerson user = getUserFromRequestParameter(context, epersonUuid);\n+        // Temporarily change the Context's current user in order to retrieve\n+        // authorizations based on that user\n+        context.setCurrentUser(user);\n+        List<AuthorizationFeature> features = authorizationFeatureService.findByResourceType(obj.getUniqueType());\n+        List<Authorization> authorizations = new ArrayList<Authorization>();\n+        for (AuthorizationFeature f : features) {\n+            if (authorizationFeatureService.isAuthorized(context, f, obj)) {\n+                authorizations.add(new Authorization(user, f, obj));\n+            }\n+        }\n+        // restore the real current user\n+        context.setCurrentUser(currUser);\n+        return converter.toRestPage(utils.getPage(authorizations, pageable), utils.obtainProjection());\n+    }\n+\n+    /**\n+     * It returns the authorization related to the requested feature if granted to the specified eperson or to the\n+     * anonymous user. Only administrators and the user identified by the epersonUuid parameter can access this method\n+     *\n+     * \n+     * @param context\n+     *            the DSpace Context\n+     * @param uri\n+     *            the uri of the object to check the authorization against\n+     * @param epersonUuid\n+     *            the eperson uuid to use in the authorization evaluation\n+     * @param featureName\n+     *            limit the authorization check to only the feature identified via its name\n+     * @param pageable\n+     *            the pagination options\n+     * @return the list of matching authorization available for the requested user and object, filtered by feature if\n+     *         provided\n+     * @throws AuthorizeException\n+     * @throws SQLException\n+     */\n+    @PreAuthorize(\"#epersonUuid==null || hasPermission(#epersonUuid, 'EPERSON', 'READ')\")\n+    @SearchRestMethod(name = \"objectAndFeature\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adfe2b6959a89763d573652939ad0f28846a561f"}, "originalPosition": 195}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU4NDExOA==", "bodyText": "Does this imply you can only request the \"features\" of resources you have read rights for?\nI was under the assumption this could be used to identify whether the current user has permissions to download a bitstream on the item which are displayed in DSpace 6 with a lock icon", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r384584118", "createdAt": "2020-02-26T15:52:03Z", "author": {"login": "benbosman"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/AuthorizationRestRepository.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.repository;\n+\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import org.dspace.app.rest.Parameter;\n+import org.dspace.app.rest.SearchRestMethod;\n+import org.dspace.app.rest.authorization.Authorization;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.exception.RepositoryMethodNotImplementedException;\n+import org.dspace.app.rest.model.AuthorizationRest;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.authorize.AuthorizeException;\n+import org.dspace.authorize.service.AuthorizeService;\n+import org.dspace.core.Context;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.service.EPersonService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Component;\n+\n+\n+/**\n+ * This is the repository responsible to manage Authorization Rest object\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+\n+@Component(AuthorizationRest.CATEGORY + \".\" + AuthorizationRest.NAME)\n+public class AuthorizationRestRepository extends DSpaceRestRepository<AuthorizationRest, String> {\n+\n+    private static final Logger log = LoggerFactory.getLogger(AuthorizationRestRepository.class);\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private AuthorizationRestUtil authorizationRestUtil;\n+\n+    @Autowired\n+    private AuthorizeService authorizeService;\n+\n+    @Autowired\n+    private EPersonService epersonService;\n+\n+    @Autowired\n+    protected ConverterService converter;\n+\n+    @Override\n+    @PreAuthorize(\"hasPermission(#id, 'authorization', 'READ')\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adfe2b6959a89763d573652939ad0f28846a561f"}, "originalPosition": 66}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MDgyODAy", "url": "https://github.com/DSpace/DSpace/pull/2663#pullrequestreview-365082802", "createdAt": "2020-02-26T17:08:55Z", "commit": {"oid": "adfe2b6959a89763d573652939ad0f28846a561f"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNzowODo1NVrOFu0VxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwOTo0NDozMVrOFvLXxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDYzNjM1Nw==", "bodyText": "Why is this being tested? Should this have been a test on epersonAuthToken to verify it's forbidden?", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r384636357", "createdAt": "2020-02-26T17:08:55Z", "author": {"login": "benbosman"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/AuthorizationFeatureRestRepositoryIT.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static com.jayway.jsonpath.JsonPath.read;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.fail;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import com.jayway.jsonpath.matchers.JsonPathMatchers;\n+import org.dspace.app.rest.authorization.AlwaysTrueFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.hamcrest.Matchers;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+/**\n+ * Test suite for the Authorization Feature endpoint\n+ * \n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ *\n+ */\n+public class AuthorizationFeatureRestRepositoryIT extends AbstractControllerIntegrationTest {\n+    @Autowired\n+    private AuthorizationFeatureService authzFeatureService;\n+\n+    @Test\n+    /**\n+     * All the features should be returned\n+     *\n+     * @throws Exception\n+     */\n+    public void findAllTest() throws Exception {\n+        int featuresNum = authzFeatureService.findAll().size();\n+        int expReturn = featuresNum > 20 ? 20 : featuresNum;\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+\n+        getClient(adminToken).perform(get(\"/api/authz/features\")).andExpect(status().isOk())\n+                .andExpect(jsonPath(\"$._embedded.features\", Matchers.hasSize(is(expReturn))))\n+                .andExpect(jsonPath(\"$._links.self.href\", Matchers.containsString(\"/api/authz/features\")))\n+                .andExpect(jsonPath(\"$.page.size\", is(20)))\n+                .andExpect(jsonPath(\"$.page.totalElements\", is(featuresNum)));\n+\n+        getClient().perform(get(\"/api/authz/features\")).andExpect(status().isUnauthorized());\n+\n+        String epersonAuthToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonAuthToken).perform(get(\"/api/authz/features\")).andExpect(status().isForbidden());\n+\n+    }\n+\n+    @Test\n+    /**\n+     * The feature endpoint must provide proper pagination\n+     *\n+     * @throws Exception\n+     */\n+    public void findAllWithPaginationTest() throws Exception {\n+        int featuresNum = authzFeatureService.findAll().size();\n+\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        List<String> featureIDs = new ArrayList<String>();\n+        for (int page = 0; page < featuresNum; page++) {\n+            AtomicReference<String> idRef = new AtomicReference<String>();\n+\n+            getClient(adminToken)\n+                    .perform(get(\"/api/authz/features\").param(\"page\", String.valueOf(page)).param(\"size\", \"1\"))\n+                    .andExpect(status().isOk()).andExpect(jsonPath(\"$._embedded.features\", Matchers.hasSize(is(1))))\n+                    .andExpect(jsonPath(\"$._links.self.href\", Matchers.containsString(\"/api/authz/features\")))\n+                    .andExpect(\n+                            (page == 0) ? jsonPath(\"$._links.prev.href\").doesNotExist()\n+                                    : jsonPath(\"$._links.prev.href\", Matchers.containsString(\"/api/authz/features\")))\n+                    .andExpect((page == featuresNum - 1)\n+                            ? jsonPath(\"$._links.next.href\").doesNotExist()\n+                            : jsonPath(\"$._links.next.href\", Matchers.containsString(\"/api/authz/features\")))\n+                    .andExpect(jsonPath(\"$._links.first.href\", Matchers.containsString(\"/api/authz/features\")))\n+                    .andExpect(jsonPath(\"$._links.last.href\", Matchers.containsString(\"/api/authz/features\")))\n+                    .andExpect(jsonPath(\"$.page.size\", is(1)))\n+                    .andExpect(jsonPath(\"$.page.totalElements\", is(Integer.valueOf(featuresNum))))\n+                    .andDo(result -> idRef\n+                            .set(read(result.getResponse().getContentAsString(), \"$._embedded.features[0].id\")));\n+\n+            if (idRef.get() == null || featureIDs.contains(idRef.get())) {\n+                fail(\"Duplicate feature \" + idRef.get() + \" returned at page \" + page);\n+            }\n+            featureIDs.add(idRef.get());\n+        }\n+    }\n+\n+    @Test\n+    /**\n+     * The feature resource endpoint must expose the proper structure and be reserved to administrators\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneTest() throws Exception {\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+\n+        getClient(adminToken).perform(get(\"/api/authz/features/withdrawItem\")).andExpect(status().isOk())\n+                .andExpect(jsonPath(\"$.id\", is(\"withdrawItem\")))\n+                .andExpect(jsonPath(\"$.description\", Matchers.any(String.class)))\n+                .andExpect(jsonPath(\"$.resourcetypes\", Matchers.contains(\"core.item\")))\n+                .andExpect(jsonPath(\"$.type\", is(\"feature\")));\n+\n+        getClient().perform(get(\"/api/authz/features/withdrawItem\")).andExpect(status().isUnauthorized());\n+\n+        String epersonAuthToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonAuthToken).perform(get(\"/api/authz/features/withdrawItem\")).andExpect(status().isForbidden());\n+    }\n+\n+    @Test\n+    public void findOneNotFoundTest() throws Exception {\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+\n+        getClient(adminToken).perform(get(\"/api/authz/features/not-existing-feature\")).andExpect(status().isNotFound());\n+\n+        getClient().perform(get(\"/api/authz/features/not-existing-feature\")).andExpect(status().isUnauthorized());\n+\n+        getClient(adminToken).perform(get(\"/api/authz/features/1\")).andExpect(status().isNotFound());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adfe2b6959a89763d573652939ad0f28846a561f"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk5ODgzMw==", "bodyText": "This tests which features are not embedded, but doesn't verify which features are embedded. The same applies for tests below\nAlso, I don't expect anything to be embedded since no projection is requested", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r384998833", "createdAt": "2020-02-27T09:18:31Z", "author": {"login": "benbosman"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/AuthorizationRestRepositoryIT.java", "diffHunk": "@@ -0,0 +1,1170 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.io.Serializable;\n+import java.util.UUID;\n+\n+import com.jayway.jsonpath.matchers.JsonPathMatchers;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.rest.authorization.AlwaysFalseFeature;\n+import org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature;\n+import org.dspace.app.rest.authorization.AlwaysTrueFeature;\n+import org.dspace.app.rest.authorization.Authorization;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.authorization.TrueForAdminsFeature;\n+import org.dspace.app.rest.authorization.TrueForLoggedUsersFeature;\n+import org.dspace.app.rest.authorization.TrueForTestUsersFeature;\n+import org.dspace.app.rest.builder.CommunityBuilder;\n+import org.dspace.app.rest.builder.EPersonBuilder;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.matcher.AuthorizationMatcher;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.app.rest.model.CommunityRest;\n+import org.dspace.app.rest.model.EPersonRest;\n+import org.dspace.app.rest.model.ItemRest;\n+import org.dspace.app.rest.model.SiteRest;\n+import org.dspace.app.rest.projection.DefaultProjection;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.content.Community;\n+import org.dspace.content.Site;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.content.service.SiteService;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.services.ConfigurationService;\n+import org.hamcrest.Matchers;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+/**\n+ * Test suite for the Authorization endpoint\n+ * \n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ *\n+ */\n+public class AuthorizationRestRepositoryIT extends AbstractControllerIntegrationTest {\n+\n+    private static final Logger log = org.apache.logging.log4j.LogManager\n+            .getLogger(AuthorizationRestRepositoryIT.class);\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private ConverterService converterService;\n+\n+    @Autowired\n+    private ConfigurationService configurationService;\n+\n+    @Autowired\n+    private Utils utils;\n+\n+    private SiteService siteService;\n+\n+    /** \n+     * this hold a reference to the test feature {@link AlwaysTrueFeature}\n+     */\n+    private AuthorizationFeature alwaysTrue;\n+\n+    /** \n+     * this hold a reference to the test feature {@link AlwaysFalseFeature}\n+     */\n+    private AuthorizationFeature alwaysFalse;\n+\n+    /** \n+     * this hold a reference to the test feature {@link AlwaysThrowExceptionFeature}\n+     */\n+    private AuthorizationFeature alwaysException;\n+\n+    /** \n+     * this hold a reference to the test feature {@link TrueForAdminsFeature}\n+     */\n+    private AuthorizationFeature trueForAdmins;\n+\n+    /** \n+     * this hold a reference to the test feature {@link TrueForLoggedUsersFeature}\n+     */\n+    private AuthorizationFeature trueForLoggedUsers;\n+\n+    /** \n+     * this hold a reference to the test feature {@link TrueForTestFeature}\n+     */\n+    private AuthorizationFeature trueForTestUsers;\n+\n+    @Override\n+    @Before\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        siteService = ContentServiceFactory.getInstance().getSiteService();\n+        alwaysTrue = authorizationFeatureService.find(AlwaysTrueFeature.NAME);\n+        alwaysFalse = authorizationFeatureService.find(AlwaysFalseFeature.NAME);\n+        alwaysException = authorizationFeatureService.find(AlwaysThrowExceptionFeature.NAME);\n+        trueForAdmins = authorizationFeatureService.find(TrueForAdminsFeature.NAME);\n+        trueForLoggedUsers = authorizationFeatureService.find(TrueForLoggedUsersFeature.NAME);\n+        trueForTestUsers = authorizationFeatureService.find(TrueForTestUsersFeature.NAME);\n+    }\n+\n+    @Test\n+    /**\n+     * This method is not implemented\n+     *\n+     * @throws Exception\n+     */\n+    public void findAllTest() throws Exception {\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations\"))\n+                    .andExpect(status().isMethodNotAllowed());\n+        getClient().perform(get(\"/api/authz/authorizations\"))\n+                    .andExpect(status().isMethodNotAllowed());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that an user can access a specific authorization\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+\n+        // define three authorizations that we know must exists\n+        Authorization authAdminSite = new Authorization(admin, trueForAdmins, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, trueForLoggedUsers, siteRest);\n+        Authorization authAnonymousUserSite = new Authorization(null, alwaysTrue, siteRest);\n+\n+        // access the authorization for the admin user\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authAdminSite))));\n+\n+        // access the authorization for a normal user\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authNormalUserSite))));\n+\n+        // access the authorization for a normal user as administrator\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authNormalUserSite))));\n+\n+        // access the authorization for an anonymous user\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authAnonymousUserSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authAnonymousUserSite))));\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the unauthorized return code is used in the appropriate scenarios\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneUnauthorizedTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+\n+        // define two authorizations that we know must exists\n+        Authorization authAdminSite = new Authorization(admin, alwaysTrue, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysTrue, siteRest);\n+\n+        // try anonymous access to the authorization for the admin user\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isUnauthorized());\n+\n+        // try anonymous access to the authorization for a normal user\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isUnauthorized());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the forbidden return code is used in the appropriate scenarios\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneForbiddenTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+        EPerson testEPerson = EPersonBuilder.createEPerson(context)\n+                .withEmail(\"test-authorization@example.com\")\n+                .withPassword(password).build();\n+        context.restoreAuthSystemState();\n+\n+        // define three authorizations that we know must exists\n+        Authorization authAdminSite = new Authorization(admin, alwaysTrue, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysTrue, siteRest);\n+\n+        String testToken = getAuthToken(testEPerson.getEmail(), password);\n+\n+        // try to access the authorization for the admin user with another user\n+        getClient(testToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isForbidden());\n+\n+        // try to access the authorization of a normal user with another user\n+        getClient(testToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isForbidden());\n+\n+        // check access as a test user to a not existing authorization for another\n+        // eperson (but existing for the test user)\n+        Authorization noTestAuthForNormalUserSite  = new Authorization(eperson, trueForTestUsers, siteRest);\n+        getClient(testToken).perform(get(\"/api/authz/authorizations/\" + noTestAuthForNormalUserSite.getID()))\n+                    .andExpect(status().isForbidden());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the not found return code is used in the appropriate scenarios\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneNotFoundTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+        EPersonRest epersonRest = converterService.toRest(eperson, DefaultProjection.DEFAULT);\n+        context.restoreAuthSystemState();\n+\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+\n+        // define three authorizations that we know will be no granted\n+        Authorization authAdminSite = new Authorization(admin, alwaysFalse, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysFalse, siteRest);\n+        Authorization authAnonymousUserSite = new Authorization(null, alwaysFalse, siteRest);\n+\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isNotFound());\n+\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+        // also the admin cannot retrieve a not existing authorization for the normal user\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                .andExpect(status().isNotFound());\n+\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authAnonymousUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+        // also the admin cannot retrieve a not existing authorization for the anonymous user\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAnonymousUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+\n+        // build a couple of IDs that look good but are related to not existing authorizations\n+        // the trueForAdmins feature is not defined for eperson\n+        String authInvalidType = getAuthorizationID(admin, trueForAdmins, epersonRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authInvalidType))\n+                    .andExpect(status().isNotFound());\n+\n+        // the specified item doesn't exist\n+        String authNotExistingObject = getAuthorizationID(admin, alwaysTrue,\n+                ItemRest.CATEGORY + \".\" + ItemRest.NAME, UUID.randomUUID());\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNotExistingObject))\n+                    .andExpect(status().isNotFound());\n+\n+        // the specified eperson doesn't exist\n+        String authNotExistingEPerson = getAuthorizationID(UUID.randomUUID(), alwaysTrue, siteRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNotExistingEPerson))\n+                    .andExpect(status().isNotFound());\n+\n+        // the specified feature doesn't exist\n+        String authNotExistingFeature = getAuthorizationID(admin, \"notexistingfeature\", siteRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNotExistingFeature))\n+                    .andExpect(status().isNotFound());\n+\n+        // check access as admin to a not existing authorization for another eperson (but existing for the admin)\n+        Authorization noAdminAuthForNormalUserSite  = new Authorization(eperson, trueForAdmins, siteRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + noAdminAuthForNormalUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+\n+        // check a couple of completely wrong IDs\n+        String notValidID = \"notvalidID\";\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + notValidID))\n+                    .andExpect(status().isNotFound());\n+\n+        String notValidIDWithWrongEpersonPart = getAuthorizationID(\"1\", alwaysTrue.getName(),\n+                SiteRest.CATEGORY + \".\" + SiteRest.NAME, site.getID().toString());\n+        // use the admin token otherwise it would result in a forbidden (attempt to access authorization of other users)\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + notValidIDWithWrongEpersonPart))\n+                    .andExpect(status().isNotFound());\n+\n+        String notValidIDWithWrongObjectTypePart = getAuthorizationID(eperson.getID().toString(), alwaysTrue.getName(),\n+                \"SITE\", site.getID().toString());\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + notValidIDWithWrongObjectTypePart))\n+                    .andExpect(status().isNotFound());\n+\n+        String notValidIDWithUnknownObjectTypePart =\n+                getAuthorizationID(eperson.getID().toString(), alwaysTrue.getName(),\n+                        \"core.unknown\", \"1\");\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + notValidIDWithUnknownObjectTypePart))\n+                    .andExpect(status().isNotFound());\n+\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that an exception in the feature check will be reported back\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneInternalServerErrorTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+        // define two authorizations that we know will throw exceptions\n+        Authorization authAdminSite = new Authorization(admin, alwaysException, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysException, siteRest);\n+\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isInternalServerError());\n+\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isInternalServerError());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the search by object works properly in allowed scenarios:\n+     * - for an administrator\n+     * - for an administrator that want to inspect permission of the anonymous users or another user\n+     * - for a logged-in \"normal\" user\n+     * - for anonymous\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, converterService.getProjection(DefaultProjection.NAME));\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+        // verify that it works for administrators\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isOk())\n+            // there are at least 3: alwaysTrue, trueForAdministrators and trueForLoggedUsers\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(3))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adfe2b6959a89763d573652939ad0f28846a561f"}, "originalPosition": 375}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAwNzgxNQ==", "bodyText": "Wouldn't it be better to replace 100 with authzFeatureService.findAll().size() (same for the similar tests below)", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r385007815", "createdAt": "2020-02-27T09:34:46Z", "author": {"login": "benbosman"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/AuthorizationRestRepositoryIT.java", "diffHunk": "@@ -0,0 +1,1170 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.io.Serializable;\n+import java.util.UUID;\n+\n+import com.jayway.jsonpath.matchers.JsonPathMatchers;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.rest.authorization.AlwaysFalseFeature;\n+import org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature;\n+import org.dspace.app.rest.authorization.AlwaysTrueFeature;\n+import org.dspace.app.rest.authorization.Authorization;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.authorization.TrueForAdminsFeature;\n+import org.dspace.app.rest.authorization.TrueForLoggedUsersFeature;\n+import org.dspace.app.rest.authorization.TrueForTestUsersFeature;\n+import org.dspace.app.rest.builder.CommunityBuilder;\n+import org.dspace.app.rest.builder.EPersonBuilder;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.matcher.AuthorizationMatcher;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.app.rest.model.CommunityRest;\n+import org.dspace.app.rest.model.EPersonRest;\n+import org.dspace.app.rest.model.ItemRest;\n+import org.dspace.app.rest.model.SiteRest;\n+import org.dspace.app.rest.projection.DefaultProjection;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.content.Community;\n+import org.dspace.content.Site;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.content.service.SiteService;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.services.ConfigurationService;\n+import org.hamcrest.Matchers;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+/**\n+ * Test suite for the Authorization endpoint\n+ * \n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ *\n+ */\n+public class AuthorizationRestRepositoryIT extends AbstractControllerIntegrationTest {\n+\n+    private static final Logger log = org.apache.logging.log4j.LogManager\n+            .getLogger(AuthorizationRestRepositoryIT.class);\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private ConverterService converterService;\n+\n+    @Autowired\n+    private ConfigurationService configurationService;\n+\n+    @Autowired\n+    private Utils utils;\n+\n+    private SiteService siteService;\n+\n+    /** \n+     * this hold a reference to the test feature {@link AlwaysTrueFeature}\n+     */\n+    private AuthorizationFeature alwaysTrue;\n+\n+    /** \n+     * this hold a reference to the test feature {@link AlwaysFalseFeature}\n+     */\n+    private AuthorizationFeature alwaysFalse;\n+\n+    /** \n+     * this hold a reference to the test feature {@link AlwaysThrowExceptionFeature}\n+     */\n+    private AuthorizationFeature alwaysException;\n+\n+    /** \n+     * this hold a reference to the test feature {@link TrueForAdminsFeature}\n+     */\n+    private AuthorizationFeature trueForAdmins;\n+\n+    /** \n+     * this hold a reference to the test feature {@link TrueForLoggedUsersFeature}\n+     */\n+    private AuthorizationFeature trueForLoggedUsers;\n+\n+    /** \n+     * this hold a reference to the test feature {@link TrueForTestFeature}\n+     */\n+    private AuthorizationFeature trueForTestUsers;\n+\n+    @Override\n+    @Before\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        siteService = ContentServiceFactory.getInstance().getSiteService();\n+        alwaysTrue = authorizationFeatureService.find(AlwaysTrueFeature.NAME);\n+        alwaysFalse = authorizationFeatureService.find(AlwaysFalseFeature.NAME);\n+        alwaysException = authorizationFeatureService.find(AlwaysThrowExceptionFeature.NAME);\n+        trueForAdmins = authorizationFeatureService.find(TrueForAdminsFeature.NAME);\n+        trueForLoggedUsers = authorizationFeatureService.find(TrueForLoggedUsersFeature.NAME);\n+        trueForTestUsers = authorizationFeatureService.find(TrueForTestUsersFeature.NAME);\n+    }\n+\n+    @Test\n+    /**\n+     * This method is not implemented\n+     *\n+     * @throws Exception\n+     */\n+    public void findAllTest() throws Exception {\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations\"))\n+                    .andExpect(status().isMethodNotAllowed());\n+        getClient().perform(get(\"/api/authz/authorizations\"))\n+                    .andExpect(status().isMethodNotAllowed());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that an user can access a specific authorization\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+\n+        // define three authorizations that we know must exists\n+        Authorization authAdminSite = new Authorization(admin, trueForAdmins, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, trueForLoggedUsers, siteRest);\n+        Authorization authAnonymousUserSite = new Authorization(null, alwaysTrue, siteRest);\n+\n+        // access the authorization for the admin user\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authAdminSite))));\n+\n+        // access the authorization for a normal user\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authNormalUserSite))));\n+\n+        // access the authorization for a normal user as administrator\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authNormalUserSite))));\n+\n+        // access the authorization for an anonymous user\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authAnonymousUserSite.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authAnonymousUserSite))));\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the unauthorized return code is used in the appropriate scenarios\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneUnauthorizedTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+\n+        // define two authorizations that we know must exists\n+        Authorization authAdminSite = new Authorization(admin, alwaysTrue, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysTrue, siteRest);\n+\n+        // try anonymous access to the authorization for the admin user\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isUnauthorized());\n+\n+        // try anonymous access to the authorization for a normal user\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isUnauthorized());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the forbidden return code is used in the appropriate scenarios\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneForbiddenTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+        EPerson testEPerson = EPersonBuilder.createEPerson(context)\n+                .withEmail(\"test-authorization@example.com\")\n+                .withPassword(password).build();\n+        context.restoreAuthSystemState();\n+\n+        // define three authorizations that we know must exists\n+        Authorization authAdminSite = new Authorization(admin, alwaysTrue, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysTrue, siteRest);\n+\n+        String testToken = getAuthToken(testEPerson.getEmail(), password);\n+\n+        // try to access the authorization for the admin user with another user\n+        getClient(testToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isForbidden());\n+\n+        // try to access the authorization of a normal user with another user\n+        getClient(testToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isForbidden());\n+\n+        // check access as a test user to a not existing authorization for another\n+        // eperson (but existing for the test user)\n+        Authorization noTestAuthForNormalUserSite  = new Authorization(eperson, trueForTestUsers, siteRest);\n+        getClient(testToken).perform(get(\"/api/authz/authorizations/\" + noTestAuthForNormalUserSite.getID()))\n+                    .andExpect(status().isForbidden());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the not found return code is used in the appropriate scenarios\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneNotFoundTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+        EPersonRest epersonRest = converterService.toRest(eperson, DefaultProjection.DEFAULT);\n+        context.restoreAuthSystemState();\n+\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+\n+        // define three authorizations that we know will be no granted\n+        Authorization authAdminSite = new Authorization(admin, alwaysFalse, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysFalse, siteRest);\n+        Authorization authAnonymousUserSite = new Authorization(null, alwaysFalse, siteRest);\n+\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isNotFound());\n+\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+        // also the admin cannot retrieve a not existing authorization for the normal user\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                .andExpect(status().isNotFound());\n+\n+        getClient().perform(get(\"/api/authz/authorizations/\" + authAnonymousUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+        // also the admin cannot retrieve a not existing authorization for the anonymous user\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAnonymousUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+\n+        // build a couple of IDs that look good but are related to not existing authorizations\n+        // the trueForAdmins feature is not defined for eperson\n+        String authInvalidType = getAuthorizationID(admin, trueForAdmins, epersonRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authInvalidType))\n+                    .andExpect(status().isNotFound());\n+\n+        // the specified item doesn't exist\n+        String authNotExistingObject = getAuthorizationID(admin, alwaysTrue,\n+                ItemRest.CATEGORY + \".\" + ItemRest.NAME, UUID.randomUUID());\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNotExistingObject))\n+                    .andExpect(status().isNotFound());\n+\n+        // the specified eperson doesn't exist\n+        String authNotExistingEPerson = getAuthorizationID(UUID.randomUUID(), alwaysTrue, siteRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNotExistingEPerson))\n+                    .andExpect(status().isNotFound());\n+\n+        // the specified feature doesn't exist\n+        String authNotExistingFeature = getAuthorizationID(admin, \"notexistingfeature\", siteRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authNotExistingFeature))\n+                    .andExpect(status().isNotFound());\n+\n+        // check access as admin to a not existing authorization for another eperson (but existing for the admin)\n+        Authorization noAdminAuthForNormalUserSite  = new Authorization(eperson, trueForAdmins, siteRest);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + noAdminAuthForNormalUserSite.getID()))\n+                    .andExpect(status().isNotFound());\n+\n+        // check a couple of completely wrong IDs\n+        String notValidID = \"notvalidID\";\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + notValidID))\n+                    .andExpect(status().isNotFound());\n+\n+        String notValidIDWithWrongEpersonPart = getAuthorizationID(\"1\", alwaysTrue.getName(),\n+                SiteRest.CATEGORY + \".\" + SiteRest.NAME, site.getID().toString());\n+        // use the admin token otherwise it would result in a forbidden (attempt to access authorization of other users)\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + notValidIDWithWrongEpersonPart))\n+                    .andExpect(status().isNotFound());\n+\n+        String notValidIDWithWrongObjectTypePart = getAuthorizationID(eperson.getID().toString(), alwaysTrue.getName(),\n+                \"SITE\", site.getID().toString());\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + notValidIDWithWrongObjectTypePart))\n+                    .andExpect(status().isNotFound());\n+\n+        String notValidIDWithUnknownObjectTypePart =\n+                getAuthorizationID(eperson.getID().toString(), alwaysTrue.getName(),\n+                        \"core.unknown\", \"1\");\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + notValidIDWithUnknownObjectTypePart))\n+                    .andExpect(status().isNotFound());\n+\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that an exception in the feature check will be reported back\n+     *\n+     * @throws Exception\n+     */\n+    public void findOneInternalServerErrorTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, DefaultProjection.DEFAULT);\n+        // define two authorizations that we know will throw exceptions\n+        Authorization authAdminSite = new Authorization(admin, alwaysException, siteRest);\n+        Authorization authNormalUserSite = new Authorization(eperson, alwaysException, siteRest);\n+\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAdminSite.getID()))\n+                    .andExpect(status().isInternalServerError());\n+\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/\" + authNormalUserSite.getID()))\n+                    .andExpect(status().isInternalServerError());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the search by object works properly in allowed scenarios:\n+     * - for an administrator\n+     * - for an administrator that want to inspect permission of the anonymous users or another user\n+     * - for a logged-in \"normal\" user\n+     * - for anonymous\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, converterService.getProjection(DefaultProjection.NAME));\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+        // verify that it works for administrators\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isOk())\n+            // there are at least 3: alwaysTrue, trueForAdministrators and trueForLoggedUsers\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(3))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            Matchers.startsWith(admin.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(3)));\n+\n+        // verify that it works for normal loggedin users\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            // there are at least 2: alwaysTrue and trueForLoggedUsers\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(2))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName()),\n+                                                is(trueForAdmins.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            Matchers.startsWith(eperson.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(2)));\n+\n+        // verify that it works for administators inspecting other users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            // there are at least 2: alwaysTrue and trueForLoggedUsers\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(2))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName()),\n+                                                // this guarantee that we are looking to the eperson\n+                                                // authz and not to the admin ones\n+                                                is(trueForAdmins.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            // this guarantee that we are looking to the eperson\n+                                            // authz and not to the admin ones\n+                                            Matchers.startsWith(eperson.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(2)));\n+\n+        // verify that it works for anonymous users\n+        getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(1))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName()),\n+                                                is(trueForAdmins.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            Matchers.startsWith(eperson.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(1)));\n+\n+        // verify that it works for administrators inspecting anonymous users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasSize(greaterThanOrEqualTo(1))))\n+            .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.everyItem(\n+                    Matchers.anyOf(\n+                            JsonPathMatchers.hasJsonPath(\"$.type\", is(\"authorization\")),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature\",\n+                                    Matchers.not(Matchers.anyOf(\n+                                                is(alwaysFalse.getName()),\n+                                                is(alwaysException.getName()),\n+                                                is(trueForTestUsers.getName()),\n+                                                is(trueForAdmins.getName())\n+                                            )\n+                                    )),\n+                            JsonPathMatchers.hasJsonPath(\"$._embedded.feature.resourcetypes\",\n+                                    Matchers.hasItem(is(\"authorization\"))),\n+                            JsonPathMatchers.hasJsonPath(\"$.id\",\n+                                    Matchers.anyOf(\n+                                            Matchers.startsWith(eperson.getID().toString()),\n+                                            Matchers.endsWith(siteRest.getUniqueType() + \"_\" + siteRest.getId()))))\n+                                    )\n+                    )\n+            )\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", greaterThanOrEqualTo(1)));\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the findByObject return an empty page when the requested object doesn't exist but the uri is\n+     * potentially valid (i.e. deleted object)\n+     * \n+     * @throws Exception\n+     */\n+    public void findByNotExistingObjectTest() throws Exception {\n+        String wrongSiteUri = \"http://localhost/api/core/sites/\" + UUID.randomUUID();\n+\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+        // verify that it works for administrators, no result\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+\n+        // verify that it works for normal loggedin users\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+\n+        // verify that it works for administators inspecting other users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+\n+        // verify that it works for anonymous users\n+        getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+\n+        // verify that it works for administrators inspecting anonymous users\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", wrongSiteUri))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\", JsonPathMatchers.hasNoJsonPath(\"$._embedded.authorizations\")))\n+            .andExpect(jsonPath(\"$._links.self.href\",\n+                    Matchers.containsString(\"/api/authz/authorizations/search/object\")))\n+            .andExpect(jsonPath(\"$.page.size\", is(20)))\n+            .andExpect(jsonPath(\"$.page.totalElements\", is(0)));\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the findByObject return the 400 Bad Request response for invalid or missing URI (required parameter)\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectBadRequestTest() throws Exception {\n+        String[] invalidUris = new String[] {\n+                \"invalid-uri\",\n+                \"\",\n+                \"http://localhost/api/wrongcategory/wrongmodel/1\",\n+                \"http://localhost/api/core/sites/this-is-not-an-uuid\"\n+        };\n+\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        String epersonToken = getAuthToken(eperson.getEmail(), password);\n+        for (String invalidUri : invalidUris) {\n+            log.debug(\"findByObjectBadRequestTest - Testing the URI: \" + invalidUri);\n+            // verify that it works for administrators with an invalid or missing uri\n+            getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri)\n+                    .param(\"eperson\", admin.getID().toString()))\n+                .andExpect(status().isBadRequest());\n+\n+            // verify that it works for normal loggedin users with an invalid or missing uri\n+            getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri)\n+                    .param(\"eperson\", eperson.getID().toString()))\n+                .andExpect(status().isBadRequest());\n+\n+            // verify that it works for administators inspecting other users with an invalid or missing uri\n+            getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri)\n+                    .param(\"eperson\", eperson.getID().toString()))\n+                .andExpect(status().isBadRequest());\n+\n+            // verify that it works for anonymous users with an invalid or missing uri\n+            getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri))\n+                .andExpect(status().isBadRequest());\n+\n+            // verify that it works for administrators inspecting anonymous users with an invalid or missing uri\n+            getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                    .param(\"uri\", invalidUri))\n+                .andExpect(status().isBadRequest());\n+        }\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isBadRequest());\n+        getClient(epersonToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isBadRequest());\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isBadRequest());\n+        getClient().perform(get(\"/api/authz/authorizations/search/object\"))\n+            .andExpect(status().isBadRequest());\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\"))\n+            .andExpect(status().isBadRequest());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the findByObject return the 401 Unauthorized response when an eperson is involved\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectUnauthorizedTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, converterService.getProjection(DefaultProjection.NAME));\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+\n+        getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isUnauthorized());\n+\n+        // verify that it works for normal loggedin users with an invalid or missing uri\n+        getClient().perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isUnauthorized());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that the findByObject return the 403 Forbidden response when a non-admin eperson try to search the\n+     * authorization of another eperson\n+     * \n+     * @throws Exception\n+     */\n+    public void findByObjectForbiddenTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, converterService.getProjection(DefaultProjection.NAME));\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+        context.turnOffAuthorisationSystem();\n+        EPerson anotherEperson = EPersonBuilder.createEPerson(context).withEmail(\"another@example.com\")\n+                .withPassword(password).build();\n+        context.restoreAuthSystemState();\n+        // disarm the alwaysThrowExceptionFeature\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+        String anotherToken = getAuthToken(anotherEperson.getEmail(), password);\n+        // verify that he cannot search the admin authorizations\n+        getClient(anotherToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", admin.getID().toString()))\n+            .andExpect(status().isForbidden());\n+\n+        // verify that he cannot search the authorizations of another \"normal\" eperson\n+        getClient(anotherToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                .param(\"eperson\", eperson.getID().toString()))\n+            .andExpect(status().isForbidden());\n+    }\n+\n+    @Test\n+    /**\n+     * Verify that an exception in the feature check will be reported back\n+     * @throws Exception\n+     */\n+    public void findByObjectInternalServerErrorTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = converterService.toRest(site, converterService.getProjection(DefaultProjection.NAME));\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+\n+        // verify that it works for administrators\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object\")\n+                .param(\"uri\", siteUri)\n+                // use a large page so that the alwaysThrowExceptionFeature is invoked\n+                // this could become insufficient at some point\n+                .param(\"size\", \"100\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adfe2b6959a89763d573652939ad0f28846a561f"}, "originalPosition": 730}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAxMzcwMQ==", "bodyText": "I assume this should not be disabled here?", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r385013701", "createdAt": "2020-02-27T09:44:31Z", "author": {"login": "benbosman"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/authorization/CCLicenseFeatureRestIT.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.authorization;\n+\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import org.dspace.app.rest.authorization.impl.CCLicenseFeature;\n+import org.dspace.app.rest.builder.CollectionBuilder;\n+import org.dspace.app.rest.builder.CommunityBuilder;\n+import org.dspace.app.rest.builder.ItemBuilder;\n+import org.dspace.app.rest.builder.ResourcePolicyBuilder;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.matcher.AuthorizationMatcher;\n+import org.dspace.app.rest.model.ItemRest;\n+import org.dspace.app.rest.projection.DefaultProjection;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.authorize.ResourcePolicy;\n+import org.dspace.content.Collection;\n+import org.dspace.content.Community;\n+import org.dspace.content.Item;\n+import org.dspace.core.Constants;\n+import org.dspace.services.ConfigurationService;\n+import org.hamcrest.Matchers;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+/**\n+ * Test suite for the ccLicense feature\n+ * \n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ *\n+ */\n+public class CCLicenseFeatureRestIT extends AbstractControllerIntegrationTest {\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private ConverterService converterService;\n+\n+    @Autowired\n+    private ConfigurationService configurationService;\n+\n+    @Autowired\n+    private Utils utils;\n+\n+    private AuthorizationFeature ccLicenseFeature;\n+\n+    @Override\n+    @Before\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        ccLicenseFeature = authorizationFeatureService.find(CCLicenseFeature.NAME);\n+    }\n+\n+    @Test\n+    public void authorizedAsAdminTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        Community com = CommunityBuilder.createCommunity(context).withName(\"A community\").build();\n+        Collection col = CollectionBuilder.createCollection(context, com).withName(\"A collection\").build();\n+        Item item = ItemBuilder.createItem(context, col).withTitle(\"Item to withdraw\").build();\n+        context.restoreAuthSystemState();\n+\n+        ItemRest itemRest = converterService.toRest(item, converterService.getProjection(DefaultProjection.NAME));\n+        String itemUri = utils.linkToSingleResource(itemRest, \"self\").getHref();\n+        Authorization authAdminCCLicense = new Authorization(admin, ccLicenseFeature, itemRest);\n+\n+        // access the authorization for the admin user\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/\" + authAdminCCLicense.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authAdminCCLicense))));\n+\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", itemUri)\n+                .param(\"eperson\", admin.getID().toString())\n+                .param(\"feature\", ccLicenseFeature.getName()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\",\n+                    Matchers.is(AuthorizationMatcher.matchAuthorization(authAdminCCLicense))));\n+    }\n+\n+    @Test\n+    public void checkAuthorizationAsCommunityAdminTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        Community com = CommunityBuilder.createCommunity(context).withName(\"A community\").withAdminGroup(eperson)\n+                .build();\n+        Collection col = CollectionBuilder.createCollection(context, com).withName(\"A collection\").build();\n+        Item item = ItemBuilder.createItem(context, col).withTitle(\"Item to withdraw\").build();\n+        context.restoreAuthSystemState();\n+\n+        ItemRest itemRest = converterService.toRest(item, converterService.getProjection(DefaultProjection.NAME));\n+        String itemUri = utils.linkToSingleResource(itemRest, \"self\").getHref();\n+        Authorization authAdminCCLicense = new Authorization(eperson, ccLicenseFeature, itemRest);\n+\n+        // access the authorization for the community admin user\n+        String comAdminToken = getAuthToken(eperson.getEmail(), password);\n+        getClient(comAdminToken).perform(get(\"/api/authz/authorizations/\" + authAdminCCLicense.getID()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$\",\n+                            Matchers.is(AuthorizationMatcher.matchAuthorization(authAdminCCLicense))));\n+\n+        getClient(comAdminToken).perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                .param(\"uri\", itemUri)\n+                .param(\"eperson\", eperson.getID().toString())\n+                .param(\"feature\", ccLicenseFeature.getName()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$\",\n+                    Matchers.is(AuthorizationMatcher.matchAuthorization(authAdminCCLicense))));\n+\n+        // verify that the property core.authorization.collection-admin.item-admin.cc-license = false is respected\n+        // the community admins should be still authorized\n+        configurationService.setProperty(\"core.authorization.item-admin.cc-license\", false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adfe2b6959a89763d573652939ad0f28846a561f"}, "originalPosition": 123}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be410e2cb885009cde9de287c09f1ed9c4629fcf", "author": {"user": {"login": "abollini", "name": "Andrea Bollini"}}, "url": "https://github.com/DSpace/DSpace/commit/be410e2cb885009cde9de287c09f1ed9c4629fcf", "committedDate": "2020-02-27T14:19:34Z", "message": "improve comments about all the managed scenarios"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb83c4c1618a49c6b07d27be15e24270c318f82a", "author": {"user": {"login": "abollini", "name": "Andrea Bollini"}}, "url": "https://github.com/DSpace/DSpace/commit/cb83c4c1618a49c6b07d27be15e24270c318f82a", "committedDate": "2020-02-27T14:31:10Z", "message": "Clarify the reason of the sleep time"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e08df614a0a71c223b05ccd3ebba9ae01e11276", "author": {"user": {"login": "abollini", "name": "Andrea Bollini"}}, "url": "https://github.com/DSpace/DSpace/commit/9e08df614a0a71c223b05ccd3ebba9ae01e11276", "committedDate": "2020-02-27T14:39:50Z", "message": "add description to the features"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0403f45dc1af7a21b3c7073f91c7c0ecf130b298", "author": {"user": {"login": "abollini", "name": "Andrea Bollini"}}, "url": "https://github.com/DSpace/DSpace/commit/0403f45dc1af7a21b3c7073f91c7c0ecf130b298", "committedDate": "2020-02-27T14:40:14Z", "message": "improve the comments clarifying the null scenario"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MTA3MTk3", "url": "https://github.com/DSpace/DSpace/pull/2663#pullrequestreview-369107197", "createdAt": "2020-03-04T20:42:41Z", "commit": {"oid": "adfe2b6959a89763d573652939ad0f28846a561f"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQyMDo0Mjo0MlrOFx86Tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQyMDo0ODowNFrOFx9Eqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzkyMjUxMA==", "bodyText": "Why isn't this method using ItemRest.getUniqueType() instead of hardcoding the same value here?  I notice all the Feature classes in this PR are hardcoding their own getSupportedTypes(), instead of using the value(s) returned via getUniqueType()", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r387922510", "createdAt": "2020-03-04T20:42:42Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/authorization/impl/CCLicenseFeature.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.authorization.impl;\n+\n+import java.sql.SQLException;\n+\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureDocumentation;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.app.rest.model.ItemRest;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.app.util.AuthorizeUtil;\n+import org.dspace.authorize.AuthorizeException;\n+import org.dspace.content.Item;\n+import org.dspace.core.Context;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+\n+/**\n+ * The cclicense feature. It can be used by administrators (or community/collection delegate) to manage the Creative\n+ * Commons license for an item\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+@Component\n+@AuthorizationFeatureDocumentation(name = CCLicenseFeature.NAME)\n+public class CCLicenseFeature implements AuthorizationFeature {\n+\n+    public static final String NAME = \"cclicense\";\n+\n+    @Autowired\n+    private Utils utils;\n+\n+    @Override\n+    public boolean isAuthorized(Context context, BaseObjectRest object) throws SQLException {\n+        if (!(object instanceof ItemRest)) {\n+            return false;\n+        }\n+        Item item = (Item) utils.getDSpaceAPIObjectFromRest(context, object);\n+        try {\n+            AuthorizeUtil.authorizeManageCCLicense(context, item);\n+        } catch (AuthorizeException e) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public String[] getSupportedTypes() {\n+        return new String[] { ItemRest.CATEGORY + \".\" + ItemRest.NAME };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adfe2b6959a89763d573652939ad0f28846a561f"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzkyMzkxNg==", "bodyText": "I want to talk more about this method in tomorrow's meeting. But, this method should have JavaDocs to describe it, and especially how it differs from the existing RestModel.getType() method (and when to use one over the other).", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r387923916", "createdAt": "2020-03-04T20:45:34Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/model/RestAddressableModel.java", "diffHunk": "@@ -44,4 +44,9 @@ public Projection getProjection() {\n     public void setProjection(Projection projection) {\n         this.projection = projection;\n     }\n+\n+    @JsonIgnore\n+    public String getUniqueType() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adfe2b6959a89763d573652939ad0f28846a561f"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzkyNTE2Mg==", "bodyText": "This JavaDocs is currently incorrect, as it's not using RestModel.getType(). Instead it's using RestAddressableModel.getUniqueType().  However, I'd like to discuss this more in tomorrow's meeting to decide on a final direction here... it currently seems odd to me to have both a getType() and a getUniqueType().", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r387925162", "createdAt": "2020-03-04T20:48:04Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/authorization/AuthorizationFeature.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.authorization;\n+\n+import java.sql.SQLException;\n+\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.app.rest.model.RestModel;\n+import org.dspace.app.rest.model.SiteRest;\n+import org.dspace.core.Context;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+/**\n+ * A feature is the representation of a business goal used in the Authorization endpoint to declare what an user can do\n+ * on a specific object.\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+public interface AuthorizationFeature {\n+    /**\n+     * Check if the eperson in the provided context, or the anonymous user if not loggedin, has access to the feature\n+     * for the requested object\n+     * \n+     * @param context\n+     *            the DSpace Context\n+     * @param object\n+     *            the object target by the feature (MUST be NOT null). Use the {@link SiteRest} object for repository\n+     *            wide feature\n+     * @return true if the user associated with the context has access to the feature for the specified object\n+     */\n+    boolean isAuthorized(Context context, BaseObjectRest object) throws SQLException;\n+\n+    /**\n+     * Return the name of the feature\n+     * \n+     * @return the name of the feature\n+     */\n+    default String getName() {\n+        AuthorizationFeatureDocumentation anno =\n+                AnnotationUtils.findAnnotation(this.getClass(), AuthorizationFeatureDocumentation.class);\n+        if (anno != null) {\n+            return anno.name();\n+        }\n+        return this.getClass().getSimpleName();\n+    }\n+\n+    /**\n+     * Return the description of the feature\n+     *\n+     * @return the description of the feature\n+     */\n+    default String getDescription() {\n+        AuthorizationFeatureDocumentation anno =\n+                AnnotationUtils.findAnnotation(this.getClass(), AuthorizationFeatureDocumentation.class);\n+        if (anno != null) {\n+            return anno.description();\n+        }\n+        return this.getClass().getSimpleName();\n+    }\n+\n+    /**\n+     * Return the supported object type according to the {@link RestModel#getType()}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adfe2b6959a89763d573652939ad0f28846a561f"}, "originalPosition": 67}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e975bc2289ca02dd04187647c2402c66e788074", "author": {"user": {"login": "abollini", "name": "Andrea Bollini"}}, "url": "https://github.com/DSpace/DSpace/commit/8e975bc2289ca02dd04187647c2402c66e788074", "committedDate": "2020-03-05T16:31:27Z", "message": "Rename FindableObjectRepository in ReloadableEntityObjectRepository"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMzIzMTI1", "url": "https://github.com/DSpace/DSpace/pull/2663#pullrequestreview-370323125", "createdAt": "2020-03-06T13:33:42Z", "commit": {"oid": "adfe2b6959a89763d573652939ad0f28846a561f"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxMzozMzo0MlrOFy406w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxMzozNjo1MFrOFy462g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkwNDE3MQ==", "bodyText": "The IndexableObject is mentioned here, but it isn't used in this class, I assume it should be the \"BaseObjectRest\" ?", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r388904171", "createdAt": "2020-03-06T13:33:42Z", "author": {"login": "KevinVdV"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/authorization/Authorization.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.authorization;\n+\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.content.Site;\n+import org.dspace.discovery.IndexableObject;\n+import org.dspace.eperson.EPerson;\n+\n+/**\n+ * An authorization is the right for a specific {@link EPerson}, eventually null to indicate unauthenticated users, to\n+ * use a specific {@link AuthorizationFeature} on a defined object. The target object must implement the\n+ * {@link IndexableObject} interface so to have an unique ID and type", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adfe2b6959a89763d573652939ad0f28846a561f"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkwNDM0OQ==", "bodyText": "What if the item is Null ?", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r388904349", "createdAt": "2020-03-06T13:34:06Z", "author": {"login": "KevinVdV"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/authorization/impl/ReinstateFeature.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.authorization.impl;\n+\n+import java.sql.SQLException;\n+\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureDocumentation;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.app.rest.model.ItemRest;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.app.util.AuthorizeUtil;\n+import org.dspace.authorize.AuthorizeException;\n+import org.dspace.content.Item;\n+import org.dspace.core.Context;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+\n+/**\n+ * The reinstate feature. It can be used by administrators (or community/collection delegate) to reinstate an item that\n+ * was previously withdrawn\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+@Component\n+@AuthorizationFeatureDocumentation(name = ReinstateFeature.NAME)\n+public class ReinstateFeature implements AuthorizationFeature {\n+\n+    public static final String NAME = \"reinstateItem\";\n+\n+    @Autowired\n+    private Utils utils;\n+\n+    @Override\n+    public boolean isAuthorized(Context context, BaseObjectRest object) throws SQLException {\n+        if (!(object instanceof ItemRest)) {\n+            return false;\n+        }\n+        Item item = (Item) utils.getDSpaceAPIObjectFromRest(context, object);\n+        if (!item.isWithdrawn()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adfe2b6959a89763d573652939ad0f28846a561f"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkwNDQ4OQ==", "bodyText": "Perhaps add a small message here for the log ?", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r388904489", "createdAt": "2020-03-06T13:34:26Z", "author": {"login": "KevinVdV"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/AuthorizationRestRepository.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.repository;\n+\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import org.dspace.app.rest.Parameter;\n+import org.dspace.app.rest.SearchRestMethod;\n+import org.dspace.app.rest.authorization.Authorization;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.exception.RepositoryMethodNotImplementedException;\n+import org.dspace.app.rest.model.AuthorizationRest;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.authorize.AuthorizeException;\n+import org.dspace.authorize.service.AuthorizeService;\n+import org.dspace.core.Context;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.service.EPersonService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Component;\n+\n+\n+/**\n+ * This is the repository responsible to manage Authorization Rest object\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+\n+@Component(AuthorizationRest.CATEGORY + \".\" + AuthorizationRest.NAME)\n+public class AuthorizationRestRepository extends DSpaceRestRepository<AuthorizationRest, String> {\n+\n+    private static final Logger log = LoggerFactory.getLogger(AuthorizationRestRepository.class);\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private AuthorizationRestUtil authorizationRestUtil;\n+\n+    @Autowired\n+    private AuthorizeService authorizeService;\n+\n+    @Autowired\n+    private EPersonService epersonService;\n+\n+    @Autowired\n+    protected ConverterService converter;\n+\n+    @Override\n+    @PreAuthorize(\"hasPermission(#id, 'authorization', 'READ')\")\n+    public AuthorizationRest findOne(Context context, String id) {\n+\n+        AuthorizationRest authorizationRest = null;\n+\n+        String featureName;\n+        try {\n+            featureName = authorizationRestUtil.getFeatureName(id);\n+        } catch (IllegalArgumentException e) {\n+            log.warn(e.getMessage(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adfe2b6959a89763d573652939ad0f28846a561f"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkwNDkyMQ==", "bodyText": "This param isn't used in this method.", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r388904921", "createdAt": "2020-03-06T13:35:18Z", "author": {"login": "KevinVdV"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/AuthorizationRestRepository.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.repository;\n+\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import org.dspace.app.rest.Parameter;\n+import org.dspace.app.rest.SearchRestMethod;\n+import org.dspace.app.rest.authorization.Authorization;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.exception.RepositoryMethodNotImplementedException;\n+import org.dspace.app.rest.model.AuthorizationRest;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.authorize.AuthorizeException;\n+import org.dspace.authorize.service.AuthorizeService;\n+import org.dspace.core.Context;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.service.EPersonService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Component;\n+\n+\n+/**\n+ * This is the repository responsible to manage Authorization Rest object\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+\n+@Component(AuthorizationRest.CATEGORY + \".\" + AuthorizationRest.NAME)\n+public class AuthorizationRestRepository extends DSpaceRestRepository<AuthorizationRest, String> {\n+\n+    private static final Logger log = LoggerFactory.getLogger(AuthorizationRestRepository.class);\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private AuthorizationRestUtil authorizationRestUtil;\n+\n+    @Autowired\n+    private AuthorizeService authorizeService;\n+\n+    @Autowired\n+    private EPersonService epersonService;\n+\n+    @Autowired\n+    protected ConverterService converter;\n+\n+    @Override\n+    @PreAuthorize(\"hasPermission(#id, 'authorization', 'READ')\")\n+    public AuthorizationRest findOne(Context context, String id) {\n+\n+        AuthorizationRest authorizationRest = null;\n+\n+        String featureName;\n+        try {\n+            featureName = authorizationRestUtil.getFeatureName(id);\n+        } catch (IllegalArgumentException e) {\n+            log.warn(e.getMessage(), e);\n+            return null;\n+        }\n+        try {\n+            BaseObjectRest object = null;\n+            try {\n+                object = authorizationRestUtil.getObject(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Object informations not found in the specified id \" + id, e);\n+                return null;\n+            }\n+\n+            AuthorizationFeature authorizationFeature = null;\n+            if (featureName != null) {\n+                authorizationFeature = authorizationFeatureService.find(featureName);\n+            }\n+\n+            if (authorizationFeature == null) {\n+                return null;\n+            }\n+            // get the user specified identified by the id\n+            EPerson user;\n+            try {\n+                user = authorizationRestUtil.getEperson(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Invalid eperson informations in the specified id \" + id, e);\n+                return null;\n+            }\n+            EPerson currUser = context.getCurrentUser();\n+            // Temporarily change the Context's current user in order to retrieve\n+            // authorizations based on that user\n+            context.setCurrentUser(user);\n+\n+            if (authorizationFeatureService.isAuthorized(context, authorizationFeature, object)) {\n+                Authorization authz = new Authorization();\n+                authz.setEperson(user);\n+                authz.setFeature(authorizationFeature);\n+                authz.setObject(object);\n+                authorizationRest = converter.toRest(authz, utils.obtainProjection());\n+            }\n+            // restore the real current user\n+            context.setCurrentUser(currUser);\n+        } catch (SQLException e) {\n+            throw new RuntimeException(e.getMessage(), e);\n+        }\n+\n+        return authorizationRest;\n+    }\n+\n+\n+    /**\n+     * It returns the list of matching available authorizations granted to the specified eperson or to the anonymous\n+     * user. Only administrators and the user identified by the epersonUuid parameter can access this method\n+     *\n+     * \n+     * @param context", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adfe2b6959a89763d573652939ad0f28846a561f"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkwNDk3Mw==", "bodyText": "This param isn't used in this method.", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r388904973", "createdAt": "2020-03-06T13:35:25Z", "author": {"login": "KevinVdV"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/AuthorizationRestRepository.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.repository;\n+\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import org.dspace.app.rest.Parameter;\n+import org.dspace.app.rest.SearchRestMethod;\n+import org.dspace.app.rest.authorization.Authorization;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.exception.RepositoryMethodNotImplementedException;\n+import org.dspace.app.rest.model.AuthorizationRest;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.authorize.AuthorizeException;\n+import org.dspace.authorize.service.AuthorizeService;\n+import org.dspace.core.Context;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.service.EPersonService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Component;\n+\n+\n+/**\n+ * This is the repository responsible to manage Authorization Rest object\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+\n+@Component(AuthorizationRest.CATEGORY + \".\" + AuthorizationRest.NAME)\n+public class AuthorizationRestRepository extends DSpaceRestRepository<AuthorizationRest, String> {\n+\n+    private static final Logger log = LoggerFactory.getLogger(AuthorizationRestRepository.class);\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private AuthorizationRestUtil authorizationRestUtil;\n+\n+    @Autowired\n+    private AuthorizeService authorizeService;\n+\n+    @Autowired\n+    private EPersonService epersonService;\n+\n+    @Autowired\n+    protected ConverterService converter;\n+\n+    @Override\n+    @PreAuthorize(\"hasPermission(#id, 'authorization', 'READ')\")\n+    public AuthorizationRest findOne(Context context, String id) {\n+\n+        AuthorizationRest authorizationRest = null;\n+\n+        String featureName;\n+        try {\n+            featureName = authorizationRestUtil.getFeatureName(id);\n+        } catch (IllegalArgumentException e) {\n+            log.warn(e.getMessage(), e);\n+            return null;\n+        }\n+        try {\n+            BaseObjectRest object = null;\n+            try {\n+                object = authorizationRestUtil.getObject(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Object informations not found in the specified id \" + id, e);\n+                return null;\n+            }\n+\n+            AuthorizationFeature authorizationFeature = null;\n+            if (featureName != null) {\n+                authorizationFeature = authorizationFeatureService.find(featureName);\n+            }\n+\n+            if (authorizationFeature == null) {\n+                return null;\n+            }\n+            // get the user specified identified by the id\n+            EPerson user;\n+            try {\n+                user = authorizationRestUtil.getEperson(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Invalid eperson informations in the specified id \" + id, e);\n+                return null;\n+            }\n+            EPerson currUser = context.getCurrentUser();\n+            // Temporarily change the Context's current user in order to retrieve\n+            // authorizations based on that user\n+            context.setCurrentUser(user);\n+\n+            if (authorizationFeatureService.isAuthorized(context, authorizationFeature, object)) {\n+                Authorization authz = new Authorization();\n+                authz.setEperson(user);\n+                authz.setFeature(authorizationFeature);\n+                authz.setObject(object);\n+                authorizationRest = converter.toRest(authz, utils.obtainProjection());\n+            }\n+            // restore the real current user\n+            context.setCurrentUser(currUser);\n+        } catch (SQLException e) {\n+            throw new RuntimeException(e.getMessage(), e);\n+        }\n+\n+        return authorizationRest;\n+    }\n+\n+\n+    /**\n+     * It returns the list of matching available authorizations granted to the specified eperson or to the anonymous\n+     * user. Only administrators and the user identified by the epersonUuid parameter can access this method\n+     *\n+     * \n+     * @param context\n+     *            the DSpace Context\n+     * @param uri\n+     *            the uri of the object to check the authorization against\n+     * @param epersonUuid\n+     *            the eperson uuid to use in the authorization evaluation\n+     * @param featureName", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adfe2b6959a89763d573652939ad0f28846a561f"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkwNTEwNA==", "bodyText": "This param isn't used in this method.", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r388905104", "createdAt": "2020-03-06T13:35:42Z", "author": {"login": "KevinVdV"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/AuthorizationRestRepository.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.repository;\n+\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import org.dspace.app.rest.Parameter;\n+import org.dspace.app.rest.SearchRestMethod;\n+import org.dspace.app.rest.authorization.Authorization;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.exception.RepositoryMethodNotImplementedException;\n+import org.dspace.app.rest.model.AuthorizationRest;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.authorize.AuthorizeException;\n+import org.dspace.authorize.service.AuthorizeService;\n+import org.dspace.core.Context;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.service.EPersonService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.stereotype.Component;\n+\n+\n+/**\n+ * This is the repository responsible to manage Authorization Rest object\n+ *\n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+\n+@Component(AuthorizationRest.CATEGORY + \".\" + AuthorizationRest.NAME)\n+public class AuthorizationRestRepository extends DSpaceRestRepository<AuthorizationRest, String> {\n+\n+    private static final Logger log = LoggerFactory.getLogger(AuthorizationRestRepository.class);\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private AuthorizationRestUtil authorizationRestUtil;\n+\n+    @Autowired\n+    private AuthorizeService authorizeService;\n+\n+    @Autowired\n+    private EPersonService epersonService;\n+\n+    @Autowired\n+    protected ConverterService converter;\n+\n+    @Override\n+    @PreAuthorize(\"hasPermission(#id, 'authorization', 'READ')\")\n+    public AuthorizationRest findOne(Context context, String id) {\n+\n+        AuthorizationRest authorizationRest = null;\n+\n+        String featureName;\n+        try {\n+            featureName = authorizationRestUtil.getFeatureName(id);\n+        } catch (IllegalArgumentException e) {\n+            log.warn(e.getMessage(), e);\n+            return null;\n+        }\n+        try {\n+            BaseObjectRest object = null;\n+            try {\n+                object = authorizationRestUtil.getObject(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Object informations not found in the specified id \" + id, e);\n+                return null;\n+            }\n+\n+            AuthorizationFeature authorizationFeature = null;\n+            if (featureName != null) {\n+                authorizationFeature = authorizationFeatureService.find(featureName);\n+            }\n+\n+            if (authorizationFeature == null) {\n+                return null;\n+            }\n+            // get the user specified identified by the id\n+            EPerson user;\n+            try {\n+                user = authorizationRestUtil.getEperson(context, id);\n+            } catch (IllegalArgumentException e) {\n+                log.warn(\"Invalid eperson informations in the specified id \" + id, e);\n+                return null;\n+            }\n+            EPerson currUser = context.getCurrentUser();\n+            // Temporarily change the Context's current user in order to retrieve\n+            // authorizations based on that user\n+            context.setCurrentUser(user);\n+\n+            if (authorizationFeatureService.isAuthorized(context, authorizationFeature, object)) {\n+                Authorization authz = new Authorization();\n+                authz.setEperson(user);\n+                authz.setFeature(authorizationFeature);\n+                authz.setObject(object);\n+                authorizationRest = converter.toRest(authz, utils.obtainProjection());\n+            }\n+            // restore the real current user\n+            context.setCurrentUser(currUser);\n+        } catch (SQLException e) {\n+            throw new RuntimeException(e.getMessage(), e);\n+        }\n+\n+        return authorizationRest;\n+    }\n+\n+\n+    /**\n+     * It returns the list of matching available authorizations granted to the specified eperson or to the anonymous\n+     * user. Only administrators and the user identified by the epersonUuid parameter can access this method\n+     *\n+     * \n+     * @param context\n+     *            the DSpace Context\n+     * @param uri\n+     *            the uri of the object to check the authorization against\n+     * @param epersonUuid\n+     *            the eperson uuid to use in the authorization evaluation\n+     * @param featureName\n+     *            limit the authorization check to only the feature identified via its name\n+     * @param pageable\n+     *            the pagination options\n+     * @return the list of matching authorization available for the requested user and object, filtered by feature if\n+     *         provided\n+     * @throws AuthorizeException\n+     * @throws SQLException\n+     */\n+    @PreAuthorize(\"#epersonUuid==null || hasPermission(#epersonUuid, 'EPERSON', 'READ')\")\n+    @SearchRestMethod(name = \"object\")\n+    public Page<AuthorizationRest> findByObject(@Parameter(value = \"uri\", required = true) String uri,\n+            @Parameter(value = \"eperson\") UUID epersonUuid,\n+            Pageable pageable) throws AuthorizeException, SQLException {\n+        Context context = obtainContext();\n+        BaseObjectRest obj = utils.getBaseObjectRestFromUri(context, uri);\n+        if (obj == null) {\n+            return null;\n+        }\n+\n+        EPerson currUser = context.getCurrentUser();\n+        // get the user specified in the requested parameters\n+        EPerson user = getUserFromRequestParameter(context, epersonUuid);\n+        // Temporarily change the Context's current user in order to retrieve\n+        // authorizations based on that user\n+        context.setCurrentUser(user);\n+        List<AuthorizationFeature> features = authorizationFeatureService.findByResourceType(obj.getUniqueType());\n+        List<Authorization> authorizations = new ArrayList<Authorization>();\n+        for (AuthorizationFeature f : features) {\n+            if (authorizationFeatureService.isAuthorized(context, f, obj)) {\n+                authorizations.add(new Authorization(user, f, obj));\n+            }\n+        }\n+        // restore the real current user\n+        context.setCurrentUser(currUser);\n+        return converter.toRestPage(utils.getPage(authorizations, pageable), utils.obtainProjection());\n+    }\n+\n+    /**\n+     * It returns the authorization related to the requested feature if granted to the specified eperson or to the\n+     * anonymous user. Only administrators and the user identified by the epersonUuid parameter can access this method\n+     *\n+     * \n+     * @param context", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adfe2b6959a89763d573652939ad0f28846a561f"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkwNTQxMA==", "bodyText": "This , should be", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r388905410", "createdAt": "2020-03-06T13:36:18Z", "author": {"login": "KevinVdV"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/FindableObjectRepository.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.repository;\n+\n+import java.io.Serializable;\n+import java.sql.SQLException;\n+\n+import org.dspace.core.Context;\n+import org.dspace.core.ReloadableEntity;\n+\n+/**\n+ * This interface must be implemented by all the rest repository that need to\n+ * provide access to the DSpace API model objects corresponding to the REST\n+ * resources that it manages\n+ * \n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ *\n+ * @param <F> the ReloadableEntity type", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adfe2b6959a89763d573652939ad0f28846a561f"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkwNTY5MA==", "bodyText": "Perhaps add a small message here for the log ?", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r388905690", "createdAt": "2020-03-06T13:36:50Z", "author": {"login": "KevinVdV"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/security/ReadAuthorizationPermissionEvaluatorPlugin.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.security;\n+\n+import java.io.Serializable;\n+import java.sql.SQLException;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.app.rest.authorization.AuthorizationRestUtil;\n+import org.dspace.app.rest.model.AuthorizationRest;\n+import org.dspace.app.rest.utils.ContextUtil;\n+import org.dspace.authorize.service.AuthorizeService;\n+import org.dspace.core.Context;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.service.EPersonService;\n+import org.dspace.services.RequestService;\n+import org.dspace.services.model.Request;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.core.Authentication;\n+import org.springframework.stereotype.Component;\n+\n+/**\n+ * {@link RestPermissionEvaluatorPlugin} class that evaluate READ permissions for an Authorization\n+ * \n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ */\n+@Component\n+public class ReadAuthorizationPermissionEvaluatorPlugin extends RestObjectPermissionEvaluatorPlugin {\n+\n+    private static final Logger log = LoggerFactory.getLogger(ReadAuthorizationPermissionEvaluatorPlugin.class);\n+\n+    @Autowired\n+    AuthorizeService authorizeService;\n+\n+    @Autowired\n+    private RequestService requestService;\n+\n+    @Autowired\n+    private EPersonService ePersonService;\n+\n+    @Autowired\n+    private AuthorizationRestUtil authorizationRestUtil;\n+\n+    @Override\n+    public boolean hasDSpacePermission(Authentication authentication, Serializable targetId, String targetType,\n+            DSpaceRestPermission permission) {\n+\n+        DSpaceRestPermission restPermission = DSpaceRestPermission.convert(permission);\n+\n+        if (!DSpaceRestPermission.READ.equals(restPermission)\n+                || !StringUtils.equalsIgnoreCase(targetType, AuthorizationRest.NAME)) {\n+            return false;\n+        }\n+\n+        Request request = requestService.getCurrentRequest();\n+        Context context = ContextUtil.obtainContext(request.getServletRequest());\n+        try {\n+            // admin can always access\n+            if (authorizeService.isAdmin(context)) {\n+                return true;\n+            }\n+            EPerson ePerson = authorizationRestUtil.getEperson(context, targetId.toString());\n+            EPerson currUser = null;\n+\n+            currUser = ePersonService.findByEmail(context, (String) authentication.getPrincipal());\n+\n+            if (ePerson == null) {\n+                // everyone can check authorization for the anonymous user\n+                return true;\n+            } else {\n+                // anonymous user\n+                if (currUser != null && currUser.getID().equals(ePerson.getID())) {\n+                    return true;\n+                }\n+            }\n+        } catch (SQLException e) {\n+            log.error(e.getMessage(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adfe2b6959a89763d573652939ad0f28846a561f"}, "originalPosition": 84}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d63493905bba7f33237e7de961050c5b662c6adf", "author": {"user": {"login": "abollini", "name": "Andrea Bollini"}}, "url": "https://github.com/DSpace/DSpace/commit/d63493905bba7f33237e7de961050c5b662c6adf", "committedDate": "2020-03-08T15:42:01Z", "message": "Javadoc cleanup, force projection in test that need it"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "db2257e6bf8c5270ad4a41b9647e810fd60120d7", "author": {"user": {"login": "abollini", "name": "Andrea Bollini"}}, "url": "https://github.com/DSpace/DSpace/commit/db2257e6bf8c5270ad4a41b9647e810fd60120d7", "committedDate": "2020-03-08T16:41:52Z", "message": "Add test related to the specialGroups"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ace118a722e22abd75282313e276560efd8c02f2", "author": {"user": {"login": "abollini", "name": "Andrea Bollini"}}, "url": "https://github.com/DSpace/DSpace/commit/ace118a722e22abd75282313e276560efd8c02f2", "committedDate": "2020-03-08T16:43:28Z", "message": "Fix special groups scenario"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "616323a887a32136e1a00ad7db0964ee76278bcf", "author": {"user": {"login": "abollini", "name": "Andrea Bollini"}}, "url": "https://github.com/DSpace/DSpace/commit/616323a887a32136e1a00ad7db0964ee76278bcf", "committedDate": "2020-03-08T18:11:43Z", "message": "Add test for the AuthorizationFeatureService"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4192b09d105d10408ec131783263866349ce0c4d", "author": {"user": {"login": "abollini", "name": "Andrea Bollini"}}, "url": "https://github.com/DSpace/DSpace/commit/4192b09d105d10408ec131783263866349ce0c4d", "committedDate": "2020-03-08T18:21:27Z", "message": "Add test for null object in isAuthorized"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "82d4908d62a00326e590b53a96e6ddac1615f382", "author": {"user": {"login": "abollini", "name": "Andrea Bollini"}}, "url": "https://github.com/DSpace/DSpace/commit/82d4908d62a00326e590b53a96e6ddac1615f382", "committedDate": "2020-03-10T08:58:20Z", "message": "Merge branch 'master' of https://github.com/DSpace/DSpace into authz"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2e7a12e16638a965f12e354df226afed4e2e257e", "author": {"user": {"login": "abollini", "name": "Andrea Bollini"}}, "url": "https://github.com/DSpace/DSpace/commit/2e7a12e16638a965f12e354df226afed4e2e257e", "committedDate": "2020-03-10T17:00:52Z", "message": "Fix unnoted merge conflict by git"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyMzM3NDc5", "url": "https://github.com/DSpace/DSpace/pull/2663#pullrequestreview-372337479", "createdAt": "2020-03-10T21:33:03Z", "commit": {"oid": "2e7a12e16638a965f12e354df226afed4e2e257e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQyMTozMzowNFrOF0hzrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQyMTozMzowNFrOF0hzrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDYyNDE3Mw==", "bodyText": "If I correctly understand the purpose of this new method, I'd  like to suggest we instead change the behavior of setCurrentUser() to automatically clear the (cached) specialGroups List whenever it is called.\nIt seems fragile to me to expect code to know when to empty out the specialGroups listing by calling this new method.  Instead, it's more logical to remove the cached specialGroups whenever the current user changes....a new current user should not inherit the groups of the last current user.", "url": "https://github.com/DSpace/DSpace/pull/2663#discussion_r390624173", "createdAt": "2020-03-10T21:33:04Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/core/Context.java", "diffHunk": "@@ -628,6 +628,17 @@ public boolean inSpecialGroup(UUID groupID) {\n         return myGroups;\n     }\n \n+    /**\n+     * This method will remove any special group that was assigned to the context.\n+     * This should be used in very specific scenario such as login-as feature where\n+     * we don't want to pass special group related to the current request /\n+     * authentication method. Normally an authentication method only need to add it\n+     * own additional group without touching what is already set in the context\n+     */\n+    public void emptySpecialGroups() {\n+        specialGroups.clear();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e7a12e16638a965f12e354df226afed4e2e257e"}, "originalPosition": 13}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f0210c5a46bbb5f9123ec1e4cb5187e9c441e590", "author": {"user": {"login": "abollini", "name": "Andrea Bollini"}}, "url": "https://github.com/DSpace/DSpace/commit/f0210c5a46bbb5f9123ec1e4cb5187e9c441e590", "committedDate": "2020-03-16T17:36:38Z", "message": "encapsulate the logic to switch current user in the context class"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2NDA3MzMw", "url": "https://github.com/DSpace/DSpace/pull/2663#pullrequestreview-376407330", "createdAt": "2020-03-17T21:09:29Z", "commit": {"oid": "f0210c5a46bbb5f9123ec1e4cb5187e9c441e590"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "59b7716725588fafc44c988a8517aab022b6fc4e", "author": {"user": {"login": "abollini", "name": "Andrea Bollini"}}, "url": "https://github.com/DSpace/DSpace/commit/59b7716725588fafc44c988a8517aab022b6fc4e", "committedDate": "2020-03-20T17:28:30Z", "message": "Add expected embedded in the search test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8cced80df3393ff2cddbe68c35b40e91d0fcbc68", "author": {"user": {"login": "abollini", "name": "Andrea Bollini"}}, "url": "https://github.com/DSpace/DSpace/commit/8cced80df3393ff2cddbe68c35b40e91d0fcbc68", "committedDate": "2020-03-20T17:35:42Z", "message": "Merge branch 'master' of https://github.com/DSpace/DSpace into authz"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e2fc68fbd09308bad55b0bda334e631c413ced6", "author": {"user": {"login": "abollini", "name": "Andrea Bollini"}}, "url": "https://github.com/DSpace/DSpace/commit/5e2fc68fbd09308bad55b0bda334e631c413ced6", "committedDate": "2020-03-20T18:04:09Z", "message": "Code cleanup - removed unused special group lists"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NzM3NzAy", "url": "https://github.com/DSpace/DSpace/pull/2663#pullrequestreview-378737702", "createdAt": "2020-03-20T18:55:03Z", "commit": {"oid": "5e2fc68fbd09308bad55b0bda334e631c413ced6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "95504b41219132a79bd1a96e6707bd039fceb6e8", "author": {"user": {"login": "abollini", "name": "Andrea Bollini"}}, "url": "https://github.com/DSpace/DSpace/commit/95504b41219132a79bd1a96e6707bd039fceb6e8", "committedDate": "2020-03-20T20:46:48Z", "message": "Fix checkstyle issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c9bca71bbf68a3a804142b08c5a1d22a02ec1963", "author": {"user": {"login": "abollini", "name": "Andrea Bollini"}}, "url": "https://github.com/DSpace/DSpace/commit/c9bca71bbf68a3a804142b08c5a1d22a02ec1963", "committedDate": "2020-03-23T10:30:58Z", "message": "Add extra check to verify that the returned feature is the expected one"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5MzI5NjE1", "url": "https://github.com/DSpace/DSpace/pull/2663#pullrequestreview-379329615", "createdAt": "2020-03-23T11:09:29Z", "commit": {"oid": "c9bca71bbf68a3a804142b08c5a1d22a02ec1963"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5MzM4NzEy", "url": "https://github.com/DSpace/DSpace/pull/2663#pullrequestreview-379338712", "createdAt": "2020-03-23T11:22:53Z", "commit": {"oid": "c9bca71bbf68a3a804142b08c5a1d22a02ec1963"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1584, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}