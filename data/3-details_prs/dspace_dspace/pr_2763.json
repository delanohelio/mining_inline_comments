{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIwNTU3MzQw", "number": 2763, "title": "DS-4027: New user registration & forgot password", "bodyText": "References\n\nLink to JIRA ticket\nLink to REST Contract\n\nDescription\nThis is the backend to:\n\nRequest a new user registration (which sends an email)\nComplete a new user registration (creating the user with the token)\nRequests a new password (which sends an email)\nComplete a password update (patching the user with the token)\n\nInstructions for Reviewers\nList of changes in this PR:\n\nRequest a new user registration and Requests a new password are handled using POST /api/eperson/registrations\nComplete a new user registration is handled using POST /api/eperson/epersons?token=<:token>\nComplete a password update is handled using PATCH /api/eperson/epersons/<:id-eperson>?token=<:token>\nAn authorization feature to verify whether you can register as a new user is created\nThe details of the token can be retrieved using the token (but not using the email address)\nNone of these requests require authentication\n\nChecklist\nThis checklist provides a reminder of what we are going to look for when reviewing your PR. You need not complete this checklist prior to creating your PR (draft PRs are always welcome). If you are unsure about an item in the checklist, don't hesitate to ask. We're here to help!\n\n My PR is small in size (e.g. less than 1,000 lines of code, not including comments & integration tests). Exceptions may be made if previously agreed upon.\n My PR passes Checkstyle validation based on the Code Style Guide\n My PR includes Javadoc for all new (or modified) public methods and classes. It also includes Javadoc for large or complex private methods.\n My PR passes all tests and includes new/updated Unit or Integration Tests for any bug fixes, improvements or new features. A few reminders about what constitutes good tests:\n\nInclude tests for different user types, including: (1) Anonymous user, (2) Logged in user (non-admin), and (3) Administrator.\nInclude tests for known error scenarios and error codes (e.g. 400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found, etc)\nFor bug fixes, include a test that reproduces the bug and proves it is fixed. For clarity, it may be useful to provide the test in a separate commit from the bug fix.\n\n\n If my PR includes new, third-party dependencies (in any pom.xml), I've made sure their licenses align with the DSpace BSD License based on the Licensing of Contributions documentation.\n If my PR modifies the REST API, I've linked to the REST Contract page (or open PR) related to this change.", "createdAt": "2020-05-20T07:19:56Z", "url": "https://github.com/DSpace/DSpace/pull/2763", "merged": true, "mergeCommit": {"oid": "cc362d8449c550eb5c49679c97f245c9fbc3afe5"}, "closed": true, "closedAt": "2020-06-30T15:26:24Z", "author": {"login": "benbosman"}, "timelineItems": {"totalCount": 33, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcXggh5AH2gAyNDIwNTU3MzQwOjQ0ZDNkMmJjYzNjMzljNTdjZWEyOWVkMWFlOWIxNThlMDc2OWYyYmU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcwXUkmAFqTQ0MDEzMDU0Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "44d3d2bcc3c39c57cea29ed1ae9b158e0769f2be", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/44d3d2bcc3c39c57cea29ed1ae9b158e0769f2be", "committedDate": "2020-04-14T09:58:50Z", "message": "[Task 70273] added POST endpoint for new registration creation and IT"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f07c3824412919b1760ee50acb966e8e3d4b037a", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/f07c3824412919b1760ee50acb966e8e3d4b037a", "committedDate": "2020-04-15T08:31:29Z", "message": "[Task 70382] added the search findByToken method for Registrations and added ITs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7da7ff03786802a4c707e2fb68e5c99079fa2bae", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/7da7ff03786802a4c707e2fb68e5c99079fa2bae", "committedDate": "2020-04-15T10:57:51Z", "message": "[Task 70397] added EPersonRegistrationFeature and added ITs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fee24e3f96dba9f2a21b97aabae29485915a3fca", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/fee24e3f96dba9f2a21b97aabae29485915a3fca", "committedDate": "2020-04-17T12:14:25Z", "message": "[Task 70398] implementing change password with token patch and added ITs for the functionality"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb8b5c8efc3baaa535b1545f31313c8a3364e02f", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/cb8b5c8efc3baaa535b1545f31313c8a3364e02f", "committedDate": "2020-04-20T09:31:34Z", "message": "[Task 70399] created the POST EPerson endpoint with token and added tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "94d9f623587bd0f48fb64ee8c62706dfd8031ac1", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/94d9f623587bd0f48fb64ee8c62706dfd8031ac1", "committedDate": "2020-04-27T12:52:00Z", "message": "[Task 70399] added context authorizations modifications for eperson post with token and added its to verify functionality"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b59aeecf0e09f5d215fd8b583d27659bbe66a80a", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/b59aeecf0e09f5d215fd8b583d27659bbe66a80a", "committedDate": "2020-04-29T12:03:03Z", "message": "Added extra cleanup to the EPersonRestRepositoryIT and optimized test in RegistrationRestControllerIT"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc91b0b858a47519cb5e9aaab6738a259c1dab05", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/fc91b0b858a47519cb5e9aaab6738a259c1dab05", "committedDate": "2020-05-05T09:59:05Z", "message": "Fixed checkstyle in the EPersonRestRepositoryIT class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3dc9f511d4a8797079a8d08fa84b93a949401127", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/3dc9f511d4a8797079a8d08fa84b93a949401127", "committedDate": "2020-05-08T13:43:18Z", "message": "[Task 70808] changed the link the mail to include the token in the url instead of as a parameter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b18b52a621f9b75d92417c4a33730e56343a19b4", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/b18b52a621f9b75d92417c4a33730e56343a19b4", "committedDate": "2020-05-11T06:59:47Z", "message": "[Task 70808] added javadocs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea47ef0c924f973aa4ec3090fac163e9881b142e", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/ea47ef0c924f973aa4ec3090fac163e9881b142e", "committedDate": "2020-05-11T09:49:57Z", "message": "[Task 70808] applied feedback to the registration implementation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ff77a9e6d289e06e133d6e0dfd694337140f4a0", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/8ff77a9e6d289e06e133d6e0dfd694337140f4a0", "committedDate": "2020-05-11T09:51:38Z", "message": "[Task 70808] added javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d3cc506b260470125c4690e73bd3f1fbca86f139", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/d3cc506b260470125c4690e73bd3f1fbca86f139", "committedDate": "2020-05-19T11:42:24Z", "message": "[Task 70937] removed the canLogin parameter from the AuthorizeUtil#authorizeUpdatePassword method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d75c9d3cae9ba165c604f30af26b24c65e9e188a", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/d75c9d3cae9ba165c604f30af26b24c65e9e188a", "committedDate": "2020-05-19T12:27:24Z", "message": "Merge remote-tracking branch 'dspace/master' into w2p-70273_create-new-registration\n\nConflicts:\n\tdspace-api/src/main/java/org/dspace/app/util/AuthorizeUtil.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a0971d8fbb4f27e07efe73476243c3e3c03133c", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/2a0971d8fbb4f27e07efe73476243c3e3c03133c", "committedDate": "2020-05-19T12:27:40Z", "message": "[Task 70937] fixes after merge"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NDAwMzUy", "url": "https://github.com/DSpace/DSpace/pull/2763#pullrequestreview-416400352", "createdAt": "2020-05-21T18:45:26Z", "commit": {"oid": "2a0971d8fbb4f27e07efe73476243c3e3c03133c"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 27, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODo0NToyN1rOGY-ihA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxOTozMjoxNlrOGZAASg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg0MzY1Mg==", "bodyText": "Shouldn't this call AuthenticateServiceFactory.getInstance().getAuthenticationService() .allowSetPassword(context, request, null); ?  It seems odd here that anyone can update a password as long as the EPerson exists and can login.", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428843652", "createdAt": "2020-05-21T18:45:27Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/app/util/AuthorizeUtil.java", "diffHunk": "@@ -601,4 +607,41 @@ public static void authorizeManageGroup(Context context, Group group) throws SQL\n \n         throw new AuthorizeException(\"not authorized to manage this group\");\n     }\n+\n+    /**\n+     * This method will return a boolean indicating whether the current user is allowed to register a new\n+     * account or not\n+     * @param context   The relevant DSpace context\n+     * @param request   The current request\n+     * @return          A boolean indicating whether the current user can register a new account or not\n+     * @throws SQLException If something goes wrong\n+     */\n+    public static boolean authorizeNewAccountRegistration(Context context, HttpServletRequest request)\n+        throws SQLException {\n+        if (DSpaceServicesFactory.getInstance().getConfigurationService()\n+                                 .getBooleanProperty(\"user.registration\", true)) {\n+            return AuthenticateServiceFactory.getInstance().getAuthenticationService()\n+                                             .allowSetPassword(context, request, null);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * This method will return a boolean indicating whether it's allowed to update the password for the EPerson\n+     * with the given email and canLogin property\n+     * @param context   The relevant DSpace context\n+     * @param email     The email to be checked\n+     * @return          A boolean indicating if the password can be updated or not\n+     */\n+    public static boolean authorizeUpdatePassword(Context context, String email) {\n+        try {\n+            EPerson eperson = EPersonServiceFactory.getInstance().getEPersonService().findByEmail(context, email);\n+            if (eperson != null && eperson.canLogIn()) {\n+                return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a0971d8fbb4f27e07efe73476243c3e3c03133c"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg0NDQwMQ==", "bodyText": "It's odd to me that this is using allowSetPassword instead of canSelfRegister.  It seems like it should use canSelfRegister method in the AuthenticationService", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428844401", "createdAt": "2020-05-21T18:46:52Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/app/util/AuthorizeUtil.java", "diffHunk": "@@ -601,4 +607,41 @@ public static void authorizeManageGroup(Context context, Group group) throws SQL\n \n         throw new AuthorizeException(\"not authorized to manage this group\");\n     }\n+\n+    /**\n+     * This method will return a boolean indicating whether the current user is allowed to register a new\n+     * account or not\n+     * @param context   The relevant DSpace context\n+     * @param request   The current request\n+     * @return          A boolean indicating whether the current user can register a new account or not\n+     * @throws SQLException If something goes wrong\n+     */\n+    public static boolean authorizeNewAccountRegistration(Context context, HttpServletRequest request)\n+        throws SQLException {\n+        if (DSpaceServicesFactory.getInstance().getConfigurationService()\n+                                 .getBooleanProperty(\"user.registration\", true)) {\n+            return AuthenticateServiceFactory.getInstance().getAuthenticationService()\n+                                             .allowSetPassword(context, request, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a0971d8fbb4f27e07efe73476243c3e3c03133c"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg0NTAzMw==", "bodyText": "Silly thing but these two ifs can be collapsed...an empty password would have a length < 6 already.", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428845033", "createdAt": "2020-05-21T18:48:04Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/eperson/AccountServiceImpl.java", "diffHunk": "@@ -155,6 +162,17 @@ public void deleteToken(Context context, String token)\n         registrationDataService.deleteByToken(context, token);\n     }\n \n+    @Override\n+    public boolean verifyPasswordStructure(String password) {\n+        if (StringUtils.isBlank(password)) {\n+            return false;\n+        }\n+        if (StringUtils.length(password) < 6) {\n+            return false;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a0971d8fbb4f27e07efe73476243c3e3c03133c"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg0NjA5Ng==", "bodyText": "We should check if registration is disabled at the very beginning.  There's no need to do any of the EPerson lookup or validation of fields if registration is disabled.  So, this should be moved towards the top of the method.", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428846096", "createdAt": "2020-05-21T18:50:09Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/RegistrationRestController.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import java.io.IOException;\n+import java.sql.SQLException;\n+import javax.mail.MessagingException;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.exception.DSpaceBadRequestException;\n+import org.dspace.app.rest.exception.UnprocessableEntityException;\n+import org.dspace.app.rest.model.RegistrationRest;\n+import org.dspace.app.rest.utils.ContextUtil;\n+import org.dspace.app.util.AuthorizeUtil;\n+import org.dspace.authorize.AuthorizeException;\n+import org.dspace.content.service.SiteService;\n+import org.dspace.core.Context;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.service.AccountService;\n+import org.dspace.eperson.service.EPersonService;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.rest.webmvc.ControllerUtils;\n+import org.springframework.hateoas.RepresentationModel;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RequestMethod;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+/**\n+ * This will be the Controller class that handles calls to the /api/eperson/registrations endpoints\n+ */\n+@RestController\n+@RequestMapping(\"/api/\" + RegistrationRest.CATEGORY + \"/\" + RegistrationRest.NAME_PLURAL)\n+public class RegistrationRestController {\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private SiteService siteService;\n+\n+    @Autowired\n+    private ConverterService converterService;\n+\n+    @Autowired\n+    private AccountService accountService;\n+\n+    @Autowired\n+    private EPersonService ePersonService;\n+\n+    /**\n+     * This method will be used to either register a new user or to send forgotten password info in a mail.\n+     * It can be called by doing a POST request to the /api/eperson/registrations endpoint.\n+     * It'll create a RegistrationRest object from the inputstream in the request and it'll check whether the email\n+     * defined in that object is in the DB or not.\n+     * If it is in the db then we'll send the forgotten password info, if it wasn't in the database then we'll send\n+     * registration info.\n+     *\n+     * @param request   The current request\n+     * @param response  The current response\n+     * @return          An empty response containing a 201 status code\n+     * @throws SQLException If something goes wrong\n+     * @throws IOException  If something goes wrong\n+     * @throws MessagingException   If something goes wrong\n+     * @throws AuthorizeException   If something goes wrong\n+     */\n+    @RequestMapping(method = RequestMethod.POST)\n+    public ResponseEntity<RepresentationModel<?>> register(HttpServletRequest request, HttpServletResponse response)\n+        throws SQLException, IOException, MessagingException, AuthorizeException {\n+\n+        Context context = ContextUtil.obtainContext(request);\n+        ObjectMapper mapper = new ObjectMapper();\n+        RegistrationRest registrationRest;\n+        try {\n+            ServletInputStream input = request.getInputStream();\n+            registrationRest = mapper.readValue(input, RegistrationRest.class);\n+        } catch (IOException e1) {\n+            throw new UnprocessableEntityException(\"Error parsing request body.\", e1);\n+        }\n+        if (StringUtils.isBlank(registrationRest.getEmail())) {\n+            throw new UnprocessableEntityException(\"The email cannot be omitted from the Registration endpoint\");\n+        }\n+        EPerson eperson = ePersonService.findByEmail(context, registrationRest.getEmail());\n+        if (eperson != null) {\n+            if (!AuthorizeUtil.authorizeUpdatePassword(context, eperson.getEmail())) {\n+                throw new DSpaceBadRequestException(\"Password cannot be updated for the given EPerson with email: \" +\n+                                                        eperson.getEmail());\n+            }\n+            accountService.sendForgotPasswordInfo(context, registrationRest.getEmail());\n+        } else {\n+            if (!AuthorizeUtil.authorizeNewAccountRegistration(context, request)) {\n+                throw new AccessDeniedException(\n+                    \"Registration is disabled, you are not authorized to create a new Authorization\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a0971d8fbb4f27e07efe73476243c3e3c03133c"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg0ODEyMQ==", "bodyText": "I don't think we need a custom Controller here.  From what I see in this class, it seems like we can do the same thing by implementing a RegistrationRestRepository that uses the createAndReturn() method for the POST action to create a new registration. If I've overlooked something, let me know.\nRemember, when possible please always use a RestRepository class...we are trying to avoid custom Controllers unless required.", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428848121", "createdAt": "2020-05-21T18:53:53Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/RegistrationRestController.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import java.io.IOException;\n+import java.sql.SQLException;\n+import javax.mail.MessagingException;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.exception.DSpaceBadRequestException;\n+import org.dspace.app.rest.exception.UnprocessableEntityException;\n+import org.dspace.app.rest.model.RegistrationRest;\n+import org.dspace.app.rest.utils.ContextUtil;\n+import org.dspace.app.util.AuthorizeUtil;\n+import org.dspace.authorize.AuthorizeException;\n+import org.dspace.content.service.SiteService;\n+import org.dspace.core.Context;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.service.AccountService;\n+import org.dspace.eperson.service.EPersonService;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.rest.webmvc.ControllerUtils;\n+import org.springframework.hateoas.RepresentationModel;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RequestMethod;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+/**\n+ * This will be the Controller class that handles calls to the /api/eperson/registrations endpoints\n+ */\n+@RestController\n+@RequestMapping(\"/api/\" + RegistrationRest.CATEGORY + \"/\" + RegistrationRest.NAME_PLURAL)\n+public class RegistrationRestController {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a0971d8fbb4f27e07efe73476243c3e3c03133c"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg0OTkzNw==", "bodyText": "This log.error should match the below RuntimeException.  So, this should be:\nlog.error(\"Something went wrong in the creation of an EPerson with token: \" + token, e);\nNOTE: the RuntimeException below says \"with wrong\" when it should say \"went wrong\"", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428849937", "createdAt": "2020-05-21T18:57:18Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/EPersonRestRepository.java", "diffHunk": "@@ -64,7 +90,23 @@ protected EPersonRest createAndReturn(Context context)\n         } catch (IOException e1) {\n             throw new UnprocessableEntityException(\"error parsing the body... maybe this is not the right error code\");\n         }\n+        String token = req.getParameter(\"token\");\n+        // If a token is available, we'll swap to the execution that is token based\n+        if (StringUtils.isNotBlank(token)) {\n+            try {\n+                return createAndReturn(context, epersonRest, token);\n+            } catch (SQLException e) {\n+                log.error(e.getMessage(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a0971d8fbb4f27e07efe73476243c3e3c03133c"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1MDkxNQ==", "bodyText": "This is a large, important method.  It should have JavaDocs please.", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428850915", "createdAt": "2020-05-21T18:59:01Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/EPersonRestRepository.java", "diffHunk": "@@ -82,8 +124,63 @@ protected EPersonRest createAndReturn(Context context)\n         } catch (SQLException e) {\n             throw new RuntimeException(e.getMessage(), e);\n         }\n+        return eperson;\n+    }\n+\n+    private EPersonRest createAndReturn(Context context, EPersonRest epersonRest, String token)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a0971d8fbb4f27e07efe73476243c3e3c03133c"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1MTY1OA==", "bodyText": "Again, this should be moved to the top of the method.  No need to do all the checks above if registration is disabled altogether.", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428851658", "createdAt": "2020-05-21T19:00:30Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/EPersonRestRepository.java", "diffHunk": "@@ -82,8 +124,63 @@ protected EPersonRest createAndReturn(Context context)\n         } catch (SQLException e) {\n             throw new RuntimeException(e.getMessage(), e);\n         }\n+        return eperson;\n+    }\n+\n+    private EPersonRest createAndReturn(Context context, EPersonRest epersonRest, String token)\n+        throws AuthorizeException, SQLException {\n+        RegistrationData registrationData = registrationDataService.findByToken(context, token);\n+        if (registrationData == null) {\n+            throw new DSpaceBadRequestException(\"The token given as parameter: \" + token + \" does not exist\" +\n+                                                \" in the database\");\n+        }\n+        if (es.findByEmail(context, registrationData.getEmail()) != null) {\n+            throw new DSpaceBadRequestException(\"The token given already contains an email address that resolves\" +\n+                                                \"to an eperson\");\n+        }\n+        String emailFromJson = epersonRest.getEmail();\n+        if (StringUtils.isNotBlank(emailFromJson)) {\n+            if (!StringUtils.equalsIgnoreCase(registrationData.getEmail(), emailFromJson)) {\n+                throw new DSpaceBadRequestException(\"The email resulting from the token does not match the email given\"\n+                                                        + \" in the json body. Email from token: \" +\n+                                                    registrationData.getEmail() + \" email from the json body: \"\n+                                                    + emailFromJson);\n+            }\n+        }\n+        if (epersonRest.isSelfRegistered() != null && !epersonRest.isSelfRegistered()) {\n+            throw new DSpaceBadRequestException(\"The self registered property cannot be set to false using this method\"\n+                                                    + \" with a token\");\n+        }\n+        checkRequiredProperties(epersonRest);\n+        if (!AuthorizeUtil.authorizeNewAccountRegistration(context, requestService\n+            .getCurrentRequest().getHttpServletRequest())) {\n+            throw new DSpaceBadRequestException(\n+                \"Registration is disabled, you are not authorized to create a new Authorization\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a0971d8fbb4f27e07efe73476243c3e3c03133c"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1MjUyNg==", "bodyText": "This if can be simplified by using StringUtils.isNotBlank as you have in other methods. It checks for both null and empty", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428852526", "createdAt": "2020-05-21T19:02:09Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/EPersonRestRepository.java", "diffHunk": "@@ -82,8 +124,63 @@ protected EPersonRest createAndReturn(Context context)\n         } catch (SQLException e) {\n             throw new RuntimeException(e.getMessage(), e);\n         }\n+        return eperson;\n+    }\n+\n+    private EPersonRest createAndReturn(Context context, EPersonRest epersonRest, String token)\n+        throws AuthorizeException, SQLException {\n+        RegistrationData registrationData = registrationDataService.findByToken(context, token);\n+        if (registrationData == null) {\n+            throw new DSpaceBadRequestException(\"The token given as parameter: \" + token + \" does not exist\" +\n+                                                \" in the database\");\n+        }\n+        if (es.findByEmail(context, registrationData.getEmail()) != null) {\n+            throw new DSpaceBadRequestException(\"The token given already contains an email address that resolves\" +\n+                                                \"to an eperson\");\n+        }\n+        String emailFromJson = epersonRest.getEmail();\n+        if (StringUtils.isNotBlank(emailFromJson)) {\n+            if (!StringUtils.equalsIgnoreCase(registrationData.getEmail(), emailFromJson)) {\n+                throw new DSpaceBadRequestException(\"The email resulting from the token does not match the email given\"\n+                                                        + \" in the json body. Email from token: \" +\n+                                                    registrationData.getEmail() + \" email from the json body: \"\n+                                                    + emailFromJson);\n+            }\n+        }\n+        if (epersonRest.isSelfRegistered() != null && !epersonRest.isSelfRegistered()) {\n+            throw new DSpaceBadRequestException(\"The self registered property cannot be set to false using this method\"\n+                                                    + \" with a token\");\n+        }\n+        checkRequiredProperties(epersonRest);\n+        if (!AuthorizeUtil.authorizeNewAccountRegistration(context, requestService\n+            .getCurrentRequest().getHttpServletRequest())) {\n+            throw new DSpaceBadRequestException(\n+                \"Registration is disabled, you are not authorized to create a new Authorization\");\n+        }\n+        // We'll turn off authorisation system because this call isn't admin based as it's token based\n+        context.turnOffAuthorisationSystem();\n+        EPerson ePerson = createEPersonFromRestObject(context, epersonRest);\n+        context.restoreAuthSystemState();\n+        // Restoring authorisation state right after the creation call\n+        accountService.deleteToken(context, token);\n+        return converter.toRest(ePerson, utils.obtainProjection());\n+    }\n \n-        return converter.toRest(eperson, utils.obtainProjection());\n+    private void checkRequiredProperties(EPersonRest epersonRest) {\n+        MetadataRest metadataRest = epersonRest.getMetadata();\n+        if (metadataRest != null) {\n+            List<MetadataValueRest> epersonFirstName = metadataRest.getMap().get(\"eperson.firstname\");\n+            List<MetadataValueRest> epersonLastName = metadataRest.getMap().get(\"eperson.lastname\");\n+            if (epersonFirstName == null || epersonLastName == null ||\n+                epersonFirstName.isEmpty() || epersonLastName.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a0971d8fbb4f27e07efe73476243c3e3c03133c"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1MzA2OQ==", "bodyText": "This error should say the password is invalid.  It's not necessarily blank, as it's also invalid if it's < 6 characters (according to the verifyPasswordStructure() method)", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428853069", "createdAt": "2020-05-21T19:03:07Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/EPersonRestRepository.java", "diffHunk": "@@ -82,8 +124,63 @@ protected EPersonRest createAndReturn(Context context)\n         } catch (SQLException e) {\n             throw new RuntimeException(e.getMessage(), e);\n         }\n+        return eperson;\n+    }\n+\n+    private EPersonRest createAndReturn(Context context, EPersonRest epersonRest, String token)\n+        throws AuthorizeException, SQLException {\n+        RegistrationData registrationData = registrationDataService.findByToken(context, token);\n+        if (registrationData == null) {\n+            throw new DSpaceBadRequestException(\"The token given as parameter: \" + token + \" does not exist\" +\n+                                                \" in the database\");\n+        }\n+        if (es.findByEmail(context, registrationData.getEmail()) != null) {\n+            throw new DSpaceBadRequestException(\"The token given already contains an email address that resolves\" +\n+                                                \"to an eperson\");\n+        }\n+        String emailFromJson = epersonRest.getEmail();\n+        if (StringUtils.isNotBlank(emailFromJson)) {\n+            if (!StringUtils.equalsIgnoreCase(registrationData.getEmail(), emailFromJson)) {\n+                throw new DSpaceBadRequestException(\"The email resulting from the token does not match the email given\"\n+                                                        + \" in the json body. Email from token: \" +\n+                                                    registrationData.getEmail() + \" email from the json body: \"\n+                                                    + emailFromJson);\n+            }\n+        }\n+        if (epersonRest.isSelfRegistered() != null && !epersonRest.isSelfRegistered()) {\n+            throw new DSpaceBadRequestException(\"The self registered property cannot be set to false using this method\"\n+                                                    + \" with a token\");\n+        }\n+        checkRequiredProperties(epersonRest);\n+        if (!AuthorizeUtil.authorizeNewAccountRegistration(context, requestService\n+            .getCurrentRequest().getHttpServletRequest())) {\n+            throw new DSpaceBadRequestException(\n+                \"Registration is disabled, you are not authorized to create a new Authorization\");\n+        }\n+        // We'll turn off authorisation system because this call isn't admin based as it's token based\n+        context.turnOffAuthorisationSystem();\n+        EPerson ePerson = createEPersonFromRestObject(context, epersonRest);\n+        context.restoreAuthSystemState();\n+        // Restoring authorisation state right after the creation call\n+        accountService.deleteToken(context, token);\n+        return converter.toRest(ePerson, utils.obtainProjection());\n+    }\n \n-        return converter.toRest(eperson, utils.obtainProjection());\n+    private void checkRequiredProperties(EPersonRest epersonRest) {\n+        MetadataRest metadataRest = epersonRest.getMetadata();\n+        if (metadataRest != null) {\n+            List<MetadataValueRest> epersonFirstName = metadataRest.getMap().get(\"eperson.firstname\");\n+            List<MetadataValueRest> epersonLastName = metadataRest.getMap().get(\"eperson.lastname\");\n+            if (epersonFirstName == null || epersonLastName == null ||\n+                epersonFirstName.isEmpty() || epersonLastName.isEmpty()) {\n+                throw new DSpaceBadRequestException(\"The eperson.firstname and eperson.lastname values need to be \" +\n+                                                    \"filled in\");\n+            }\n+        }\n+        String password = epersonRest.getPassword();\n+        if (!accountService.verifyPasswordStructure(password)) {\n+            throw new DSpaceBadRequestException(\"the password cannot be left blank\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a0971d8fbb4f27e07efe73476243c3e3c03133c"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1NTMxMw==", "bodyText": "I think this error message needs improving.  But, I'm not sure how to reword it as I'm not sure I understand what is going on here.  Is this code trying to check if this is a self-registration & verify then that you must change your password?  Or am I misunderstanding why a Token requires a password change?", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428855313", "createdAt": "2020-05-21T19:07:36Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/EPersonRestRepository.java", "diffHunk": "@@ -167,6 +264,18 @@ public EPersonRest findByEmail(@Parameter(value = \"email\", required = true) Stri\n     @PreAuthorize(\"hasPermission(#uuid, 'EPERSON', #patch)\")\n     protected void patch(Context context, HttpServletRequest request, String apiCategory, String model, UUID uuid,\n                          Patch patch) throws AuthorizeException, SQLException {\n+        if (StringUtils.isNotBlank(request.getParameter(\"token\"))) {\n+            boolean passwordChangeFound = false;\n+            for (Operation operation : patch.getOperations()) {\n+                if (StringUtils.equalsIgnoreCase(operation.getPath(), \"/password\")) {\n+                    passwordChangeFound = true;\n+                }\n+            }\n+            if (!passwordChangeFound) {\n+                throw new AccessDeniedException(\"Couldn't perform the patch as a token with provided without \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a0971d8fbb4f27e07efe73476243c3e3c03133c"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1NjcxMQ==", "bodyText": "Why does this authorization check happen after the patchWithToken()?  Shouldn't it be happening higher up in this method?  Or am I misunderstanding the code here? If I am misunderstanding, then we need to add inline comments to describe the new code...as currently it looks like if a token is included, then anyone can change the password (without checking authorization).", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428856711", "createdAt": "2020-05-21T19:10:22Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/EPersonPasswordReplaceOperation.java", "diffHunk": "@@ -27,25 +37,59 @@\n @Component\n public class EPersonPasswordReplaceOperation<R> extends PatchOperation<R> {\n \n+    private static final Logger log = org.apache.logging.log4j.LogManager\n+        .getLogger(EPersonPasswordReplaceOperation.class);\n+\n     /**\n      * Path in json body of patch that uses this operation\n      */\n     public static final String OPERATION_PASSWORD_CHANGE = \"/password\";\n     protected EPersonService ePersonService = EPersonServiceFactory.getInstance().getEPersonService();\n \n+    @Autowired\n+    private RequestService requestService;\n+\n+    @Autowired\n+    private AccountService accountService;\n+\n     @Override\n     public R perform(Context context, R object, Operation operation) {\n         checkOperationValue(operation.getValue());\n         if (supports(object, operation)) {\n             EPerson eperson = (EPerson) object;\n+            String token = requestService.getCurrentRequest().getHttpServletRequest().getParameter(\"token\");\n             checkModelForExistingValue(eperson);\n+            if (StringUtils.isNotBlank(token)) {\n+                patchWithToken(context,eperson, token, operation);\n+            }\n+            if (!AuthorizeUtil.authorizeUpdatePassword(context, eperson.getEmail())) {\n+                throw new DSpaceBadRequestException(\"Password cannot be updated for the given EPerson with email: \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a0971d8fbb4f27e07efe73476243c3e3c03133c"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1NzQ5NA==", "bodyText": "Please log a more descriptive message.  e.getMessage() gives no more information to the logs than what e already provides.", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428857494", "createdAt": "2020-05-21T19:12:06Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/EPersonPasswordReplaceOperation.java", "diffHunk": "@@ -27,25 +37,59 @@\n @Component\n public class EPersonPasswordReplaceOperation<R> extends PatchOperation<R> {\n \n+    private static final Logger log = org.apache.logging.log4j.LogManager\n+        .getLogger(EPersonPasswordReplaceOperation.class);\n+\n     /**\n      * Path in json body of patch that uses this operation\n      */\n     public static final String OPERATION_PASSWORD_CHANGE = \"/password\";\n     protected EPersonService ePersonService = EPersonServiceFactory.getInstance().getEPersonService();\n \n+    @Autowired\n+    private RequestService requestService;\n+\n+    @Autowired\n+    private AccountService accountService;\n+\n     @Override\n     public R perform(Context context, R object, Operation operation) {\n         checkOperationValue(operation.getValue());\n         if (supports(object, operation)) {\n             EPerson eperson = (EPerson) object;\n+            String token = requestService.getCurrentRequest().getHttpServletRequest().getParameter(\"token\");\n             checkModelForExistingValue(eperson);\n+            if (StringUtils.isNotBlank(token)) {\n+                patchWithToken(context,eperson, token, operation);\n+            }\n+            if (!AuthorizeUtil.authorizeUpdatePassword(context, eperson.getEmail())) {\n+                throw new DSpaceBadRequestException(\"Password cannot be updated for the given EPerson with email: \" +\n+                                                        eperson.getEmail());\n+            }\n             ePersonService.setPassword(eperson, (String) operation.getValue());\n             return object;\n         } else {\n             throw new DSpaceBadRequestException(\"EPersonPasswordReplaceOperation does not support this operation\");\n         }\n     }\n \n+    private void patchWithToken(Context context, EPerson eperson, String token, Operation operation) {\n+        try {\n+            EPerson ePersonFromToken = accountService.getEPerson(context, token);\n+            if (ePersonFromToken == null) {\n+                throw new AccessDeniedException(\"The token in the parameter: \" + token + \" couldn't\" +\n+                                                    \" be associated with an EPerson\");\n+            }\n+            if (!ePersonFromToken.getID().equals(eperson.getID())) {\n+                throw new AccessDeniedException(\"The token in the parameter belongs to a different EPerson\" +\n+                                                    \" than the uri indicates\");\n+            }\n+            accountService.deleteToken(context, token);\n+        } catch (SQLException | AuthorizeException e) {\n+            log.error(e.getMessage(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a0971d8fbb4f27e07efe73476243c3e3c03133c"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1NzY2NA==", "bodyText": "This method appears to be misnamed.  I don't see a patch going on here...it looks to just delete the token?", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428857664", "createdAt": "2020-05-21T19:12:28Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/EPersonPasswordReplaceOperation.java", "diffHunk": "@@ -27,25 +37,59 @@\n @Component\n public class EPersonPasswordReplaceOperation<R> extends PatchOperation<R> {\n \n+    private static final Logger log = org.apache.logging.log4j.LogManager\n+        .getLogger(EPersonPasswordReplaceOperation.class);\n+\n     /**\n      * Path in json body of patch that uses this operation\n      */\n     public static final String OPERATION_PASSWORD_CHANGE = \"/password\";\n     protected EPersonService ePersonService = EPersonServiceFactory.getInstance().getEPersonService();\n \n+    @Autowired\n+    private RequestService requestService;\n+\n+    @Autowired\n+    private AccountService accountService;\n+\n     @Override\n     public R perform(Context context, R object, Operation operation) {\n         checkOperationValue(operation.getValue());\n         if (supports(object, operation)) {\n             EPerson eperson = (EPerson) object;\n+            String token = requestService.getCurrentRequest().getHttpServletRequest().getParameter(\"token\");\n             checkModelForExistingValue(eperson);\n+            if (StringUtils.isNotBlank(token)) {\n+                patchWithToken(context,eperson, token, operation);\n+            }\n+            if (!AuthorizeUtil.authorizeUpdatePassword(context, eperson.getEmail())) {\n+                throw new DSpaceBadRequestException(\"Password cannot be updated for the given EPerson with email: \" +\n+                                                        eperson.getEmail());\n+            }\n             ePersonService.setPassword(eperson, (String) operation.getValue());\n             return object;\n         } else {\n             throw new DSpaceBadRequestException(\"EPersonPasswordReplaceOperation does not support this operation\");\n         }\n     }\n \n+    private void patchWithToken(Context context, EPerson eperson, String token, Operation operation) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a0971d8fbb4f27e07efe73476243c3e3c03133c"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1ODMyMA==", "bodyText": "This must be followed by a context.restoreAuthSystemState(); in this same method after you are done creating content", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428858320", "createdAt": "2020-05-21T19:13:57Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -110,6 +135,34 @@ public void createTest() throws Exception {\n         // TODO cleanup the context!!!\n     }\n \n+    @Test\n+    public void createAnonAccessDeniedTest() throws Exception {\n+        context.turnOffAuthorisationSystem();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a0971d8fbb4f27e07efe73476243c3e3c03133c"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1ODQ4Nw==", "bodyText": "After this POST, we should have a test to verify that the person was not created.", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428858487", "createdAt": "2020-05-21T19:14:18Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -110,6 +135,34 @@ public void createTest() throws Exception {\n         // TODO cleanup the context!!!\n     }\n \n+    @Test\n+    public void createAnonAccessDeniedTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        // we should check how to get it from Spring\n+        ObjectMapper mapper = new ObjectMapper();\n+        EPersonRest data = new EPersonRest();\n+        EPersonRest dataFull = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        data.setEmail(\"createtest@fake-email.com\");\n+        data.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        data.setMetadata(metadataRest);\n+        dataFull.setEmail(\"createtestFull@fake-email.com\");\n+        dataFull.setCanLogIn(true);\n+        dataFull.setMetadata(metadataRest);\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                         .content(mapper.writeValueAsBytes(data))\n+                                         .contentType(contentType)\n+                                         .param(\"projection\", \"full\"))\n+                            .andExpect(status().isUnauthorized());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a0971d8fbb4f27e07efe73476243c3e3c03133c"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2MDAxNA==", "bodyText": "Maybe I'm misunderstanding something, but if the registration data is null, then shouldn't the token have been deleted already?  Why do we need to have the deleteByToken() here?", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428860014", "createdAt": "2020-05-21T19:17:18Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1773,4 +1826,668 @@ public void getDirectEpersonGroups() throws Exception {\n                             );\n \n     }\n+\n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertFalse(oldPassword.equals(newPasswordHash));\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a0971d8fbb4f27e07efe73476243c3e3c03133c"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2MDgxOA==", "bodyText": "Just as a note, you can use assertNotEquals() here...it makes these tests much much easier to read/review...there's also an assertEquals() method.  You don't always need to only use assertFalse and assertTrue.\nSimilarly, the next line can just say assertNull()", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428860818", "createdAt": "2020-05-21T19:18:50Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1773,4 +1826,668 @@ public void getDirectEpersonGroups() throws Exception {\n                             );\n \n     }\n+\n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertFalse(oldPassword.equals(newPasswordHash));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a0971d8fbb4f27e07efe73476243c3e3c03133c"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2MTk2Mw==", "bodyText": "I'm finding these asserts hard to read/understand.  I'd recommend these be assertEquals(), assertNotNull and assertEquals()", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428861963", "createdAt": "2020-05-21T19:21:01Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1773,4 +1826,668 @@ public void getDirectEpersonGroups() throws Exception {\n                             );\n \n     }\n+\n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertFalse(oldPassword.equals(newPasswordHash));\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertTrue(StringUtils.equals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a0971d8fbb4f27e07efe73476243c3e3c03133c"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2MjU3OQ==", "bodyText": "Again, can be assertEquals and assertNotNull", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428862579", "createdAt": "2020-05-21T19:22:18Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1773,4 +1826,668 @@ public void getDirectEpersonGroups() throws Exception {\n                             );\n \n     }\n+\n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertFalse(oldPassword.equals(newPasswordHash));\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertTrue(StringUtils.equals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(),\n+                                      tokenForEPerson));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplacePasswordWithOtherUserTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+\n+        EPerson ePersonTwo = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"Smith\", \"Donald\")\n+                                        .withEmail(\"donaldSmith@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        accountService.sendRegistrationInfo(context, ePersonTwo.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String tokenForEPersonTwo = registrationDataService.findByEmail(context, ePersonTwo.getEmail()).getToken();\n+\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPersonTwo))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a0971d8fbb4f27e07efe73476243c3e3c03133c"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2MjgzNg==", "bodyText": "Can be assertEquals, assertNotNull, and assertEquals", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428862836", "createdAt": "2020-05-21T19:22:47Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1773,4 +1826,668 @@ public void getDirectEpersonGroups() throws Exception {\n                             );\n \n     }\n+\n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertFalse(oldPassword.equals(newPasswordHash));\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertTrue(StringUtils.equals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(),\n+                                      tokenForEPerson));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplacePasswordWithOtherUserTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+\n+        EPerson ePersonTwo = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"Smith\", \"Donald\")\n+                                        .withEmail(\"donaldSmith@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        accountService.sendRegistrationInfo(context, ePersonTwo.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String tokenForEPersonTwo = registrationDataService.findByEmail(context, ePersonTwo.getEmail()).getToken();\n+\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPersonTwo))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        registrationDataService.deleteByToken(context, tokenForEPersonTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplaceEmailWithTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        String originalEmail = \"Johndoe@fake-email.com\";\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(originalEmail)\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newEmail = \"johnyandmaria@fake-email.com\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/email\", newEmail);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertTrue(StringUtils.equalsIgnoreCase(ePerson.getEmail(), originalEmail));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a0971d8fbb4f27e07efe73476243c3e3c03133c"}, "originalPosition": 264}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2MzQwNQ==", "bodyText": "Should the registration data simply be cleaned up by the EPersonBuilder?  That'd simplify having to do all this manual cleanup in every method.", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428863405", "createdAt": "2020-05-21T19:23:58Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1773,4 +1826,668 @@ public void getDirectEpersonGroups() throws Exception {\n                             );\n \n     }\n+\n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertFalse(oldPassword.equals(newPasswordHash));\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertTrue(StringUtils.equals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(),\n+                                      tokenForEPerson));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplacePasswordWithOtherUserTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+\n+        EPerson ePersonTwo = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"Smith\", \"Donald\")\n+                                        .withEmail(\"donaldSmith@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        accountService.sendRegistrationInfo(context, ePersonTwo.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String tokenForEPersonTwo = registrationDataService.findByEmail(context, ePersonTwo.getEmail()).getToken();\n+\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPersonTwo))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        registrationDataService.deleteByToken(context, tokenForEPersonTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplaceEmailWithTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        String originalEmail = \"Johndoe@fake-email.com\";\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(originalEmail)\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newEmail = \"johnyandmaria@fake-email.com\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/email\", newEmail);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertTrue(StringUtils.equalsIgnoreCase(ePerson.getEmail(), originalEmail));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, tokenForEPerson);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a0971d8fbb4f27e07efe73476243c3e3c03133c"}, "originalPosition": 268}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2NDkxOQ==", "bodyText": "We should never create manual JSON in tests. Please look at examples from other ITs on how this is done.  You should be able to just fill out an EPersonRest object and call .content(mapper.writeValueAsBytes(epersonRest)).  See for example the createTest() in this same class.", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428864919", "createdAt": "2020-05-21T19:26:59Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1773,4 +1826,668 @@ public void getDirectEpersonGroups() throws Exception {\n                             );\n \n     }\n+\n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertFalse(oldPassword.equals(newPasswordHash));\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertTrue(StringUtils.equals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(),\n+                                      tokenForEPerson));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplacePasswordWithOtherUserTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+\n+        EPerson ePersonTwo = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"Smith\", \"Donald\")\n+                                        .withEmail(\"donaldSmith@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        accountService.sendRegistrationInfo(context, ePersonTwo.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String tokenForEPersonTwo = registrationDataService.findByEmail(context, ePersonTwo.getEmail()).getToken();\n+\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPersonTwo))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        registrationDataService.deleteByToken(context, tokenForEPersonTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplaceEmailWithTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        String originalEmail = \"Johndoe@fake-email.com\";\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(originalEmail)\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newEmail = \"johnyandmaria@fake-email.com\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/email\", newEmail);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertTrue(StringUtils.equalsIgnoreCase(ePerson.getEmail(), originalEmail));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void registerNewAccountPatchUpdatePasswordRandomUserUuidFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                            .contentType(MediaType.APPLICATION_JSON)\n+                            .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", newRegisterToken))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertFalse(registrationDataService.findByEmail(context, newRegisterEmail) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        String json = \"{\\\"metadata\\\":{\\\"eperson.firstname\\\":[{\\\"value\\\":\\\"John\\\"}],\" +\n+            \"\\\"eperson.lastname\\\":[{\\\"value\\\":\\\"Doe\\\"}]},\\\"password\\\":\\\"somePassword\\\",\" +\n+            \"\\\"type\\\":\\\"eperson\\\"}\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a0971d8fbb4f27e07efe73476243c3e3c03133c"}, "originalPosition": 338}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2NjE4OQ==", "bodyText": "Please look at the newly updated createTest() method for the proper way to cleanup an EPerson after a POST.  The way you are doing this in this method has performance issues, which we cleaned up in #2759", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428866189", "createdAt": "2020-05-21T19:29:32Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1773,4 +1826,668 @@ public void getDirectEpersonGroups() throws Exception {\n                             );\n \n     }\n+\n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertFalse(oldPassword.equals(newPasswordHash));\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertTrue(StringUtils.equals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(),\n+                                      tokenForEPerson));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplacePasswordWithOtherUserTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+\n+        EPerson ePersonTwo = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"Smith\", \"Donald\")\n+                                        .withEmail(\"donaldSmith@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        accountService.sendRegistrationInfo(context, ePersonTwo.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String tokenForEPersonTwo = registrationDataService.findByEmail(context, ePersonTwo.getEmail()).getToken();\n+\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPersonTwo))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        registrationDataService.deleteByToken(context, tokenForEPersonTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplaceEmailWithTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        String originalEmail = \"Johndoe@fake-email.com\";\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(originalEmail)\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newEmail = \"johnyandmaria@fake-email.com\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/email\", newEmail);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertTrue(StringUtils.equalsIgnoreCase(ePerson.getEmail(), originalEmail));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void registerNewAccountPatchUpdatePasswordRandomUserUuidFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                            .contentType(MediaType.APPLICATION_JSON)\n+                            .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", newRegisterToken))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertFalse(registrationDataService.findByEmail(context, newRegisterEmail) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        String json = \"{\\\"metadata\\\":{\\\"eperson.firstname\\\":[{\\\"value\\\":\\\"John\\\"}],\" +\n+            \"\\\"eperson.lastname\\\":[{\\\"value\\\":\\\"Doe\\\"}]},\\\"password\\\":\\\"somePassword\\\",\" +\n+            \"\\\"type\\\":\\\"eperson\\\"}\";\n+\n+        MvcResult mvcResult = getClient().perform(post(\"/api/eperson/epersons\")\n+                                .param(\"token\", newRegisterToken)\n+                                .content(json)\n+                                .contentType(MediaType.APPLICATION_JSON))\n+                                  .andExpect(status().isCreated())\n+                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                            hasJsonPath(\"$.uuid\", not(empty())),\n+                            // is it what you expect? EPerson.getName() returns the email...\n+                            //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                            hasJsonPath(\"$.type\", is(\"eperson\")),\n+                            hasJsonPath(\"$._links.self.href\", not(empty())),\n+                            hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                matchMetadata(\"eperson.firstname\", \"John\"),\n+                                matchMetadata(\"eperson.lastname\", \"Doe\")\n+                            ))))).andReturn();\n+\n+        String content = mvcResult.getResponse().getContentAsString();\n+        Map<String,Object> map = mapper.readValue(content, Map.class);\n+        String epersonUuid = String.valueOf(map.get(\"uuid\"));\n+        EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+        assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+\n+        assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+        context.turnOffAuthorisationSystem();\n+        ePersonService.delete(context, createdEPerson);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a0971d8fbb4f27e07efe73476243c3e3c03133c"}, "originalPosition": 364}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2NjMyMA==", "bodyText": "Again, no manually created JSON please", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428866320", "createdAt": "2020-05-21T19:29:47Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1773,4 +1826,668 @@ public void getDirectEpersonGroups() throws Exception {\n                             );\n \n     }\n+\n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertFalse(oldPassword.equals(newPasswordHash));\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertTrue(StringUtils.equals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(),\n+                                      tokenForEPerson));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplacePasswordWithOtherUserTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+\n+        EPerson ePersonTwo = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"Smith\", \"Donald\")\n+                                        .withEmail(\"donaldSmith@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        accountService.sendRegistrationInfo(context, ePersonTwo.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String tokenForEPersonTwo = registrationDataService.findByEmail(context, ePersonTwo.getEmail()).getToken();\n+\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPersonTwo))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        registrationDataService.deleteByToken(context, tokenForEPersonTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplaceEmailWithTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        String originalEmail = \"Johndoe@fake-email.com\";\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(originalEmail)\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newEmail = \"johnyandmaria@fake-email.com\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/email\", newEmail);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertTrue(StringUtils.equalsIgnoreCase(ePerson.getEmail(), originalEmail));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void registerNewAccountPatchUpdatePasswordRandomUserUuidFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                            .contentType(MediaType.APPLICATION_JSON)\n+                            .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", newRegisterToken))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertFalse(registrationDataService.findByEmail(context, newRegisterEmail) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        String json = \"{\\\"metadata\\\":{\\\"eperson.firstname\\\":[{\\\"value\\\":\\\"John\\\"}],\" +\n+            \"\\\"eperson.lastname\\\":[{\\\"value\\\":\\\"Doe\\\"}]},\\\"password\\\":\\\"somePassword\\\",\" +\n+            \"\\\"type\\\":\\\"eperson\\\"}\";\n+\n+        MvcResult mvcResult = getClient().perform(post(\"/api/eperson/epersons\")\n+                                .param(\"token\", newRegisterToken)\n+                                .content(json)\n+                                .contentType(MediaType.APPLICATION_JSON))\n+                                  .andExpect(status().isCreated())\n+                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                            hasJsonPath(\"$.uuid\", not(empty())),\n+                            // is it what you expect? EPerson.getName() returns the email...\n+                            //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                            hasJsonPath(\"$.type\", is(\"eperson\")),\n+                            hasJsonPath(\"$._links.self.href\", not(empty())),\n+                            hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                matchMetadata(\"eperson.firstname\", \"John\"),\n+                                matchMetadata(\"eperson.lastname\", \"Doe\")\n+                            ))))).andReturn();\n+\n+        String content = mvcResult.getResponse().getContentAsString();\n+        Map<String,Object> map = mapper.readValue(content, Map.class);\n+        String epersonUuid = String.valueOf(map.get(\"uuid\"));\n+        EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+        assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+\n+        assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+        context.turnOffAuthorisationSystem();\n+        ePersonService.delete(context, createdEPerson);\n+        context.restoreAuthSystemState();\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        String json = \"{\\\"metadata\\\":{\\\"eperson.firstname\\\":[{\\\"value\\\":\\\"John\\\"}],\" +\n+            \"\\\"eperson.lastname\\\":[{\\\"value\\\":\\\"Doe\\\"}]},\\\"email\\\":\\\"\" + newRegisterEmail +\n+            \"\\\",\\\"password\\\":\\\"somePassword\\\",\\\"type\\\":\\\"eperson\\\"}\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a0971d8fbb4f27e07efe73476243c3e3c03133c"}, "originalPosition": 388}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2NjYwMw==", "bodyText": "Again, look at the best practices of cleanup after a POST established in #2759", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428866603", "createdAt": "2020-05-21T19:30:14Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1773,4 +1826,668 @@ public void getDirectEpersonGroups() throws Exception {\n                             );\n \n     }\n+\n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertFalse(oldPassword.equals(newPasswordHash));\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertTrue(StringUtils.equals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(),\n+                                      tokenForEPerson));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplacePasswordWithOtherUserTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+\n+        EPerson ePersonTwo = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"Smith\", \"Donald\")\n+                                        .withEmail(\"donaldSmith@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        accountService.sendRegistrationInfo(context, ePersonTwo.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String tokenForEPersonTwo = registrationDataService.findByEmail(context, ePersonTwo.getEmail()).getToken();\n+\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPersonTwo))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        registrationDataService.deleteByToken(context, tokenForEPersonTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplaceEmailWithTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        String originalEmail = \"Johndoe@fake-email.com\";\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(originalEmail)\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newEmail = \"johnyandmaria@fake-email.com\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/email\", newEmail);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertTrue(StringUtils.equalsIgnoreCase(ePerson.getEmail(), originalEmail));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void registerNewAccountPatchUpdatePasswordRandomUserUuidFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                            .contentType(MediaType.APPLICATION_JSON)\n+                            .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", newRegisterToken))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertFalse(registrationDataService.findByEmail(context, newRegisterEmail) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        String json = \"{\\\"metadata\\\":{\\\"eperson.firstname\\\":[{\\\"value\\\":\\\"John\\\"}],\" +\n+            \"\\\"eperson.lastname\\\":[{\\\"value\\\":\\\"Doe\\\"}]},\\\"password\\\":\\\"somePassword\\\",\" +\n+            \"\\\"type\\\":\\\"eperson\\\"}\";\n+\n+        MvcResult mvcResult = getClient().perform(post(\"/api/eperson/epersons\")\n+                                .param(\"token\", newRegisterToken)\n+                                .content(json)\n+                                .contentType(MediaType.APPLICATION_JSON))\n+                                  .andExpect(status().isCreated())\n+                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                            hasJsonPath(\"$.uuid\", not(empty())),\n+                            // is it what you expect? EPerson.getName() returns the email...\n+                            //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                            hasJsonPath(\"$.type\", is(\"eperson\")),\n+                            hasJsonPath(\"$._links.self.href\", not(empty())),\n+                            hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                matchMetadata(\"eperson.firstname\", \"John\"),\n+                                matchMetadata(\"eperson.lastname\", \"Doe\")\n+                            ))))).andReturn();\n+\n+        String content = mvcResult.getResponse().getContentAsString();\n+        Map<String,Object> map = mapper.readValue(content, Map.class);\n+        String epersonUuid = String.valueOf(map.get(\"uuid\"));\n+        EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+        assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+\n+        assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+        context.turnOffAuthorisationSystem();\n+        ePersonService.delete(context, createdEPerson);\n+        context.restoreAuthSystemState();\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        String json = \"{\\\"metadata\\\":{\\\"eperson.firstname\\\":[{\\\"value\\\":\\\"John\\\"}],\" +\n+            \"\\\"eperson.lastname\\\":[{\\\"value\\\":\\\"Doe\\\"}]},\\\"email\\\":\\\"\" + newRegisterEmail +\n+            \"\\\",\\\"password\\\":\\\"somePassword\\\",\\\"type\\\":\\\"eperson\\\"}\";\n+\n+        MvcResult mvcResult = getClient().perform(post(\"/api/eperson/epersons\")\n+                                                           .param(\"token\", newRegisterToken)\n+                                                           .content(json)\n+                                                           .contentType(MediaType.APPLICATION_JSON))\n+                                              .andExpect(status().isCreated())\n+                                              .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                  hasJsonPath(\"$.uuid\", not(empty())),\n+                                                  // is it what you expect? EPerson.getName() returns the email...\n+                                                  //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                  hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                  hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                  hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                  hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                      matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                      matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                  ))))).andReturn();\n+\n+        String content = mvcResult.getResponse().getContentAsString();\n+        Map<String,Object> map = mapper.readValue(content, Map.class);\n+        String epersonUuid = String.valueOf(map.get(\"uuid\"));\n+        EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+        assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+        assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        ePersonService.delete(context, createdEPerson);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a0971d8fbb4f27e07efe73476243c3e3c03133c"}, "originalPosition": 415}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2NzY1OA==", "bodyText": "Same in this method.  No manual JSON & correct the POST cleanup", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428867658", "createdAt": "2020-05-21T19:32:16Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1773,4 +1826,668 @@ public void getDirectEpersonGroups() throws Exception {\n                             );\n \n     }\n+\n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertFalse(oldPassword.equals(newPasswordHash));\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertTrue(StringUtils.equals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(),\n+                                      tokenForEPerson));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplacePasswordWithOtherUserTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+\n+        EPerson ePersonTwo = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"Smith\", \"Donald\")\n+                                        .withEmail(\"donaldSmith@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        accountService.sendRegistrationInfo(context, ePersonTwo.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String tokenForEPersonTwo = registrationDataService.findByEmail(context, ePersonTwo.getEmail()).getToken();\n+\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPersonTwo))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        registrationDataService.deleteByToken(context, tokenForEPersonTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplaceEmailWithTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        String originalEmail = \"Johndoe@fake-email.com\";\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(originalEmail)\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newEmail = \"johnyandmaria@fake-email.com\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/email\", newEmail);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertTrue(StringUtils.equalsIgnoreCase(ePerson.getEmail(), originalEmail));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void registerNewAccountPatchUpdatePasswordRandomUserUuidFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                            .contentType(MediaType.APPLICATION_JSON)\n+                            .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", newRegisterToken))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertFalse(registrationDataService.findByEmail(context, newRegisterEmail) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        String json = \"{\\\"metadata\\\":{\\\"eperson.firstname\\\":[{\\\"value\\\":\\\"John\\\"}],\" +\n+            \"\\\"eperson.lastname\\\":[{\\\"value\\\":\\\"Doe\\\"}]},\\\"password\\\":\\\"somePassword\\\",\" +\n+            \"\\\"type\\\":\\\"eperson\\\"}\";\n+\n+        MvcResult mvcResult = getClient().perform(post(\"/api/eperson/epersons\")\n+                                .param(\"token\", newRegisterToken)\n+                                .content(json)\n+                                .contentType(MediaType.APPLICATION_JSON))\n+                                  .andExpect(status().isCreated())\n+                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                            hasJsonPath(\"$.uuid\", not(empty())),\n+                            // is it what you expect? EPerson.getName() returns the email...\n+                            //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                            hasJsonPath(\"$.type\", is(\"eperson\")),\n+                            hasJsonPath(\"$._links.self.href\", not(empty())),\n+                            hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                matchMetadata(\"eperson.firstname\", \"John\"),\n+                                matchMetadata(\"eperson.lastname\", \"Doe\")\n+                            ))))).andReturn();\n+\n+        String content = mvcResult.getResponse().getContentAsString();\n+        Map<String,Object> map = mapper.readValue(content, Map.class);\n+        String epersonUuid = String.valueOf(map.get(\"uuid\"));\n+        EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+        assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+\n+        assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+        context.turnOffAuthorisationSystem();\n+        ePersonService.delete(context, createdEPerson);\n+        context.restoreAuthSystemState();\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        String json = \"{\\\"metadata\\\":{\\\"eperson.firstname\\\":[{\\\"value\\\":\\\"John\\\"}],\" +\n+            \"\\\"eperson.lastname\\\":[{\\\"value\\\":\\\"Doe\\\"}]},\\\"email\\\":\\\"\" + newRegisterEmail +\n+            \"\\\",\\\"password\\\":\\\"somePassword\\\",\\\"type\\\":\\\"eperson\\\"}\";\n+\n+        MvcResult mvcResult = getClient().perform(post(\"/api/eperson/epersons\")\n+                                                           .param(\"token\", newRegisterToken)\n+                                                           .content(json)\n+                                                           .contentType(MediaType.APPLICATION_JSON))\n+                                              .andExpect(status().isCreated())\n+                                              .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                  hasJsonPath(\"$.uuid\", not(empty())),\n+                                                  // is it what you expect? EPerson.getName() returns the email...\n+                                                  //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                  hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                  hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                  hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                  hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                      matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                      matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                  ))))).andReturn();\n+\n+        String content = mvcResult.getResponse().getContentAsString();\n+        Map<String,Object> map = mapper.readValue(content, Map.class);\n+        String epersonUuid = String.valueOf(map.get(\"uuid\"));\n+        EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+        assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+        assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        ePersonService.delete(context, createdEPerson);\n+        context.restoreAuthSystemState();\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailAndSelfRegisteredProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        String json = \"{\\\"metadata\\\":{\\\"eperson.firstname\\\":[{\\\"value\\\":\\\"John\\\"}],\" +\n+            \"\\\"eperson.lastname\\\":[{\\\"value\\\":\\\"Doe\\\"}]},\\\"selfRegistered\\\":true,\\\"email\\\":\\\"\" + newRegisterEmail +\n+            \"\\\",\\\"password\\\":\\\"somePassword\\\",\\\"type\\\":\\\"eperson\\\"}\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a0971d8fbb4f27e07efe73476243c3e3c03133c"}, "originalPosition": 440}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4ea4f9112948d28858fb9b8f727da75fe4312032", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/4ea4f9112948d28858fb9b8f727da75fe4312032", "committedDate": "2020-06-03T12:42:40Z", "message": "[Task 71213] applied feedback to the new registration creation functionality"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ccdff521c5f32a9d7404b061fcdbc85550f2943", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/9ccdff521c5f32a9d7404b061fcdbc85550f2943", "committedDate": "2020-06-08T13:21:09Z", "message": "Merge remote-tracking branch 'dspace/master' into w2p-70273_create-new-registration\n\nConflicts:\n\tdspace-server-webapp/src/main/java/org/dspace/app/rest/repository/EPersonRestRepository.java\n\tdspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fdaddd934fe140c60a3db77a1c79a363b369ecb6", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/fdaddd934fe140c60a3db77a1c79a363b369ecb6", "committedDate": "2020-06-08T14:24:19Z", "message": "[Task 71271] applied fixes after merge and applied community feedback to the new registration endpoints"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "80f7bad4944924b6644d02cfeb9e99e4529cce5b", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/80f7bad4944924b6644d02cfeb9e99e4529cce5b", "committedDate": "2020-06-11T08:23:50Z", "message": "[Task 71348] fixed the patch replace password for eperson with a token to now be available to anonymous calls"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3aba1b7545546a068f311adf7f71695699df84d9", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/3aba1b7545546a068f311adf7f71695699df84d9", "committedDate": "2020-06-11T13:08:03Z", "message": "Added a way to ignore write only properties in REST objects for tests and rewrote EPersonRestRepositoryIT tests to use this"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5MjM5Mzkx", "url": "https://github.com/DSpace/DSpace/pull/2763#pullrequestreview-429239391", "createdAt": "2020-06-11T19:57:02Z", "commit": {"oid": "3aba1b7545546a068f311adf7f71695699df84d9"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxOTo1NzowMlrOGisfDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMDoxNToxMlrOGitJ6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAzMzYxNA==", "bodyText": "Looks like we still have one instance of manually created JSON.  Can we replace this one as well? (by using IgnoreJacksonWriteOnlyAccess())", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r439033614", "createdAt": "2020-06-11T19:57:02Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1787,6 +1846,793 @@ public void getDirectEpersonGroups() throws Exception {\n \n     }\n \n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertNotEquals(oldPassword, newPasswordHash);\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        assertNull(registrationDataService.findByToken(context, tokenForEPerson));\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(), tokenForEPerson);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplacePasswordWithOtherUserTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+\n+        EPerson ePersonTwo = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"Smith\", \"Donald\")\n+                                        .withEmail(\"donaldSmith@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        accountService.sendRegistrationInfo(context, ePersonTwo.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String tokenForEPersonTwo = registrationDataService.findByEmail(context, ePersonTwo.getEmail()).getToken();\n+\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPersonTwo))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        registrationDataService.deleteByToken(context, tokenForEPersonTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplaceEmailWithTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        String originalEmail = \"johndoe@fake-email.com\";\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(originalEmail)\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newEmail = \"johnyandmaria@fake-email.com\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/email\", newEmail);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(ePerson.getEmail(), originalEmail);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void registerNewAccountPatchUpdatePasswordRandomUserUuidFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                            .contentType(MediaType.APPLICATION_JSON)\n+                            .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", newRegisterToken))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertFalse(registrationDataService.findByEmail(context, newRegisterEmail) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        // We need to create this json manually to support actually setting the password to a value.\n+        // When using the mapper to write an EPersonRest object to JSON to pass it along, the password gets lost\n+        String json = \"{\\\"metadata\\\":{\\\"eperson.firstname\\\":[{\\\"value\\\":\\\"John\\\"}],\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3aba1b7545546a068f311adf7f71695699df84d9"}, "originalPosition": 336}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAzNDI5MA==", "bodyText": "These two context lines can be removed.  They aren't doing anything :)  Likely an accidental copy & paste mistake", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r439034290", "createdAt": "2020-06-11T19:58:23Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1787,6 +1846,793 @@ public void getDirectEpersonGroups() throws Exception {\n \n     }\n \n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertNotEquals(oldPassword, newPasswordHash);\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        assertNull(registrationDataService.findByToken(context, tokenForEPerson));\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(), tokenForEPerson);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplacePasswordWithOtherUserTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+\n+        EPerson ePersonTwo = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"Smith\", \"Donald\")\n+                                        .withEmail(\"donaldSmith@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        accountService.sendRegistrationInfo(context, ePersonTwo.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String tokenForEPersonTwo = registrationDataService.findByEmail(context, ePersonTwo.getEmail()).getToken();\n+\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPersonTwo))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        registrationDataService.deleteByToken(context, tokenForEPersonTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplaceEmailWithTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        String originalEmail = \"johndoe@fake-email.com\";\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(originalEmail)\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newEmail = \"johnyandmaria@fake-email.com\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/email\", newEmail);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(ePerson.getEmail(), originalEmail);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void registerNewAccountPatchUpdatePasswordRandomUserUuidFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                            .contentType(MediaType.APPLICATION_JSON)\n+                            .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", newRegisterToken))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertFalse(registrationDataService.findByEmail(context, newRegisterEmail) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        // We need to create this json manually to support actually setting the password to a value.\n+        // When using the mapper to write an EPersonRest object to JSON to pass it along, the password gets lost\n+        String json = \"{\\\"metadata\\\":{\\\"eperson.firstname\\\":[{\\\"value\\\":\\\"John\\\"}],\" +\n+            \"\\\"eperson.lastname\\\":[{\\\"value\\\":\\\"Doe\\\"}]},\\\"password\\\":\\\"somePassword\\\",\" +\n+            \"\\\"type\\\":\\\"eperson\\\"}\";\n+\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                    .param(\"token\", newRegisterToken)\n+                                    .content(json)\n+                                    .contentType(MediaType.APPLICATION_JSON))\n+                                      .andExpect(status().isCreated())\n+                                      .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                hasJsonPath(\"$.uuid\", not(empty())),\n+                                // is it what you expect? EPerson.getName() returns the email...\n+                                //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                    matchMetadata(\"eperson.firstname\", \"John\"),\n+                                    matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                )))))\n+                                .andDo(result -> idRef\n+                                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                                               .param(\"token\", newRegisterToken)\n+                                                               .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                               .contentType(MediaType.APPLICATION_JSON))\n+                                                  .andExpect(status().isCreated())\n+                                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                      hasJsonPath(\"$.uuid\", not(empty())),\n+                                                      // is it what you expect? EPerson.getName() returns the email...\n+                                                      //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                      hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                      hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                      hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                      hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                          matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                          matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                      ))))).andDo(result -> idRef\n+                            .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailAndSelfRegisteredProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(true);\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                                               .param(\"token\", newRegisterToken)\n+                                                               .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                               .contentType(MediaType.APPLICATION_JSON))\n+                                                  .andExpect(status().isCreated())\n+                                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                      hasJsonPath(\"$.uuid\", not(empty())),\n+                                                      // is it what you expect? EPerson.getName() returns the email...\n+                                                      //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                      hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                      hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                      hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                      hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                          matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                          matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                      ))))).andDo(result -> idRef\n+                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            context.restoreAuthSystemState();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3aba1b7545546a068f311adf7f71695699df84d9"}, "originalPosition": 497}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAzNjAwOA==", "bodyText": "This looks like unrelated code.  I don't understand what this would have to do with user registration / forgot password.  Was this accidentally included in a recent commit?", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r439036008", "createdAt": "2020-06-11T20:02:08Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/ProcessRestRepositoryIT.java", "diffHunk": "@@ -43,6 +43,13 @@\n \n     @Before\n     public void setup() throws SQLException {\n+        CollectionUtils.emptyIfNull(processService.findAll(context)).stream().forEach(process -> {\n+            try {\n+                processService.delete(context, process);\n+            } catch (SQLException e) {\n+                throw new RuntimeException(e);\n+            }\n+        });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3aba1b7545546a068f311adf7f71695699df84d9"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAzNzA0OQ==", "bodyText": "Since you are now cleaning up the created registration data in each of the below tests (and in other tests in this PR), this entire setup() should be unnecessary & likely can be removed.  Each test should cleanup after itself instead of doing \"just in case\" cleanup before running each test.", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r439037049", "createdAt": "2020-06-11T20:04:26Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/RegistrationRestControllerIT.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.sql.SQLException;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.app.rest.model.RegistrationRest;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.eperson.RegistrationData;\n+import org.dspace.eperson.dao.RegistrationDataDAO;\n+import org.dspace.services.ConfigurationService;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+public class RegistrationRestControllerIT extends AbstractControllerIntegrationTest {\n+\n+    @Autowired\n+    private RegistrationDataDAO registrationDataDAO;\n+\n+    @Autowired\n+    private ConfigurationService configurationService;\n+\n+\n+    @Before\n+    public void setup() throws SQLException {\n+        CollectionUtils.emptyIfNull(registrationDataDAO.findAll(context, RegistrationData.class)).stream()\n+                       .forEach(registrationData -> {\n+                           try {\n+                               registrationDataDAO.delete(context, registrationData);\n+                           } catch (SQLException e) {\n+                               throw new RuntimeException(e);\n+                           }\n+                       });\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3aba1b7545546a068f311adf7f71695699df84d9"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAzNzY0Nw==", "bodyText": "Just a note, you don't need to make context changes to set a configuration properly.  So the two context lines can be removed here, they aren't doing anything.", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r439037647", "createdAt": "2020-06-11T20:05:42Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/authorization/EPersonRegistrationFeatureIT.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.authorization;\n+\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import org.dspace.app.rest.authorization.impl.EPersonRegistrationFeature;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.converter.SiteConverter;\n+import org.dspace.app.rest.model.SiteRest;\n+import org.dspace.app.rest.projection.Projection;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.content.Site;\n+import org.dspace.content.service.SiteService;\n+import org.dspace.services.ConfigurationService;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+public class EPersonRegistrationFeatureIT extends AbstractControllerIntegrationTest {\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private ConverterService converterService;\n+\n+    @Autowired\n+    private ConfigurationService configurationService;\n+\n+    @Autowired\n+    private SiteService siteService;\n+\n+    @Autowired\n+    private SiteConverter siteConverter;\n+\n+    @Autowired\n+    private Utils utils;\n+\n+    private AuthorizationFeature epersonRegistrationFeature;\n+\n+    public static final String[] SHIB_ONLY = {\"org.dspace.authenticate.ShibAuthentication\"};\n+\n+    @Override\n+    @Before\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        epersonRegistrationFeature = authorizationFeatureService.find(EPersonRegistrationFeature.NAME);\n+    }\n+\n+    @Test\n+    public void userRegistrationEnabledSuccessTest() throws Exception {\n+\n+        Site site = siteService.findSite(context);\n+        SiteRest SiteRest = siteConverter.convert(site, Projection.DEFAULT);\n+        String siteUri = utils.linkToSingleResource(SiteRest, \"self\").getHref();\n+\n+\n+        getClient().perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                                          .param(\"uri\", siteUri)\n+                                          .param(\"feature\", epersonRegistrationFeature.getName()))\n+                             .andExpect(status().isOk());\n+    }\n+\n+    @Test\n+    public void userRegistrationDisabledUnAuthorizedTest() throws Exception {\n+\n+        Site site = siteService.findSite(context);\n+        SiteRest SiteRest = siteConverter.convert(site, Projection.DEFAULT);\n+        String siteUri = utils.linkToSingleResource(SiteRest, \"self\").getHref();\n+\n+        context.turnOffAuthorisationSystem();\n+        configurationService.setProperty(\"user.registration\", false);\n+        context.restoreAuthSystemState();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3aba1b7545546a068f311adf7f71695699df84d9"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAzODA0MA==", "bodyText": "Same as above, the two context lines aren't doing anything.  As a sidenote too, the configurationService reloads between test classes, so you don't need to reset the configuration properly here if you don't want to.  In other words, these three lines could be removed", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r439038040", "createdAt": "2020-06-11T20:06:34Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/authorization/EPersonRegistrationFeatureIT.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.authorization;\n+\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import org.dspace.app.rest.authorization.impl.EPersonRegistrationFeature;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.converter.SiteConverter;\n+import org.dspace.app.rest.model.SiteRest;\n+import org.dspace.app.rest.projection.Projection;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.content.Site;\n+import org.dspace.content.service.SiteService;\n+import org.dspace.services.ConfigurationService;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+public class EPersonRegistrationFeatureIT extends AbstractControllerIntegrationTest {\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private ConverterService converterService;\n+\n+    @Autowired\n+    private ConfigurationService configurationService;\n+\n+    @Autowired\n+    private SiteService siteService;\n+\n+    @Autowired\n+    private SiteConverter siteConverter;\n+\n+    @Autowired\n+    private Utils utils;\n+\n+    private AuthorizationFeature epersonRegistrationFeature;\n+\n+    public static final String[] SHIB_ONLY = {\"org.dspace.authenticate.ShibAuthentication\"};\n+\n+    @Override\n+    @Before\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        epersonRegistrationFeature = authorizationFeatureService.find(EPersonRegistrationFeature.NAME);\n+    }\n+\n+    @Test\n+    public void userRegistrationEnabledSuccessTest() throws Exception {\n+\n+        Site site = siteService.findSite(context);\n+        SiteRest SiteRest = siteConverter.convert(site, Projection.DEFAULT);\n+        String siteUri = utils.linkToSingleResource(SiteRest, \"self\").getHref();\n+\n+\n+        getClient().perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                                          .param(\"uri\", siteUri)\n+                                          .param(\"feature\", epersonRegistrationFeature.getName()))\n+                             .andExpect(status().isOk());\n+    }\n+\n+    @Test\n+    public void userRegistrationDisabledUnAuthorizedTest() throws Exception {\n+\n+        Site site = siteService.findSite(context);\n+        SiteRest SiteRest = siteConverter.convert(site, Projection.DEFAULT);\n+        String siteUri = utils.linkToSingleResource(SiteRest, \"self\").getHref();\n+\n+        context.turnOffAuthorisationSystem();\n+        configurationService.setProperty(\"user.registration\", false);\n+        context.restoreAuthSystemState();\n+\n+        getClient().perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                                          .param(\"uri\", siteUri)\n+                                          .param(\"feature\", epersonRegistrationFeature.getName()))\n+                             .andExpect(status().isNoContent());\n+\n+        context.turnOffAuthorisationSystem();\n+        configurationService.setProperty(\"user.registration\", true);\n+        context.restoreAuthSystemState();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3aba1b7545546a068f311adf7f71695699df84d9"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAzODM3Mg==", "bodyText": "Same here, context lines aren't doing anything. You can change configs without turning off authorization.", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r439038372", "createdAt": "2020-06-11T20:07:00Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/authorization/EPersonRegistrationFeatureIT.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.authorization;\n+\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import org.dspace.app.rest.authorization.impl.EPersonRegistrationFeature;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.converter.SiteConverter;\n+import org.dspace.app.rest.model.SiteRest;\n+import org.dspace.app.rest.projection.Projection;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.content.Site;\n+import org.dspace.content.service.SiteService;\n+import org.dspace.services.ConfigurationService;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+public class EPersonRegistrationFeatureIT extends AbstractControllerIntegrationTest {\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private ConverterService converterService;\n+\n+    @Autowired\n+    private ConfigurationService configurationService;\n+\n+    @Autowired\n+    private SiteService siteService;\n+\n+    @Autowired\n+    private SiteConverter siteConverter;\n+\n+    @Autowired\n+    private Utils utils;\n+\n+    private AuthorizationFeature epersonRegistrationFeature;\n+\n+    public static final String[] SHIB_ONLY = {\"org.dspace.authenticate.ShibAuthentication\"};\n+\n+    @Override\n+    @Before\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        epersonRegistrationFeature = authorizationFeatureService.find(EPersonRegistrationFeature.NAME);\n+    }\n+\n+    @Test\n+    public void userRegistrationEnabledSuccessTest() throws Exception {\n+\n+        Site site = siteService.findSite(context);\n+        SiteRest SiteRest = siteConverter.convert(site, Projection.DEFAULT);\n+        String siteUri = utils.linkToSingleResource(SiteRest, \"self\").getHref();\n+\n+\n+        getClient().perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                                          .param(\"uri\", siteUri)\n+                                          .param(\"feature\", epersonRegistrationFeature.getName()))\n+                             .andExpect(status().isOk());\n+    }\n+\n+    @Test\n+    public void userRegistrationDisabledUnAuthorizedTest() throws Exception {\n+\n+        Site site = siteService.findSite(context);\n+        SiteRest SiteRest = siteConverter.convert(site, Projection.DEFAULT);\n+        String siteUri = utils.linkToSingleResource(SiteRest, \"self\").getHref();\n+\n+        context.turnOffAuthorisationSystem();\n+        configurationService.setProperty(\"user.registration\", false);\n+        context.restoreAuthSystemState();\n+\n+        getClient().perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                                          .param(\"uri\", siteUri)\n+                                          .param(\"feature\", epersonRegistrationFeature.getName()))\n+                             .andExpect(status().isNoContent());\n+\n+        context.turnOffAuthorisationSystem();\n+        configurationService.setProperty(\"user.registration\", true);\n+        context.restoreAuthSystemState();\n+    }\n+\n+\n+    @Test\n+    public void userRegistrationEnabledShibTest() throws Exception {\n+\n+        Site site = siteService.findSite(context);\n+        SiteRest SiteRest = siteConverter.convert(site, Projection.DEFAULT);\n+        String siteUri = utils.linkToSingleResource(SiteRest, \"self\").getHref();\n+\n+\n+        getClient().perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                                          .param(\"uri\", siteUri)\n+                                          .param(\"feature\", epersonRegistrationFeature.getName()))\n+                             .andExpect(status().isOk());\n+\n+        context.turnOffAuthorisationSystem();\n+        //Enable Shibboleth and password login\n+        configurationService.setProperty(\"plugin.sequence.org.dspace.authenticate.AuthenticationMethod\", SHIB_ONLY);\n+        context.restoreAuthSystemState();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3aba1b7545546a068f311adf7f71695699df84d9"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA0NDU4NA==", "bodyText": "Can we add in JavaDocs here?  It should say something like:\nThis is a custom JacksonAnnotationIntrospector which allows us to ignore `@JsonProperty(access = Access.WRITE_ONLY)` annotations in our tests.\nNormally, this annotation allows the property to be written to (during deserialization),\nbut does NOT allow it to be read (during serialization).  \nIn some tests, we need to ignore this annotation so that the test can use/verify the property\nduring both serialization & deserialization.\n\nIn order to use this class in a test, assign it the the current mapper like this:\nmapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r439044584", "createdAt": "2020-06-11T20:15:12Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/jackson/IgnoreJacksonWriteOnlyAccess.java", "diffHunk": "@@ -0,0 +1,24 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.jackson;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.databind.introspect.Annotated;\n+import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;\n+\n+public class IgnoreJacksonWriteOnlyAccess extends JacksonAnnotationIntrospector {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3aba1b7545546a068f311adf7f71695699df84d9"}, "originalPosition": 14}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d212a84a4e1d2739e958337258e94811c589d7d0", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/d212a84a4e1d2739e958337258e94811c589d7d0", "committedDate": "2020-06-19T07:56:34Z", "message": "[Task 71442] applied feedback to the new registration endpoint"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e73686e05bf4ffcc7e5f1096a97f10121239d11f", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/e73686e05bf4ffcc7e5f1096a97f10121239d11f", "committedDate": "2020-06-19T08:17:57Z", "message": "Merge remote-tracking branch 'dspace/master' into w2p-70273_create-new-registration\n\nConflicts:\n\tdspace-api/src/main/java/org/dspace/app/util/AuthorizeUtil.java\n\tdspace-server-webapp/src/main/java/org/dspace/app/rest/security/EPersonRestPermissionEvaluatorPlugin.java\n\tdspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "de6bc7d8d024b88d9b69da5032c0ba7edb9c854c", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/de6bc7d8d024b88d9b69da5032c0ba7edb9c854c", "committedDate": "2020-06-19T08:18:28Z", "message": "[Task 71442] fixed compile error after merge"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "891ab3f3e261e8a78321091b8835fab413937899", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/891ab3f3e261e8a78321091b8835fab413937899", "committedDate": "2020-06-19T12:47:53Z", "message": "[Task 71442] fixed the tests without the additional cleanup required"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1MDMyODMz", "url": "https://github.com/DSpace/DSpace/pull/2763#pullrequestreview-435032833", "createdAt": "2020-06-22T15:23:46Z", "commit": {"oid": "891ab3f3e261e8a78321091b8835fab413937899"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNToyMzo0NlrOGnFpxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNToyNTowOFrOGnFtvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY0MDI2Mw==", "bodyText": "This IT class can be removed. The RegistrationRestController was removed and refactored into RegistrationRestRepository.  So, these tests can also be moved if they don't already exist elsewhere or simply removed if they are duplicative.\nKeep in mind, if the tests here are kept, they need cleanup. They are not cleaning up after a POST properly (in both methods) and the forgotPasswordTest() test is strangely calling context.complete() and turning off authorization around a simple config change.\nI think these same functions are already tested elsewhere though, so I'd lean towards removing this IT class entirely as it looks duplicative.", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r443640263", "createdAt": "2020-06-22T15:23:46Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/RegistrationRestControllerIT.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.app.rest.model.RegistrationRest;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.eperson.RegistrationData;\n+import org.dspace.eperson.dao.RegistrationDataDAO;\n+import org.dspace.services.ConfigurationService;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+public class RegistrationRestControllerIT extends AbstractControllerIntegrationTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "891ab3f3e261e8a78321091b8835fab413937899"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY0MTI3Nw==", "bodyText": "Needs to cleanup after POST. See https://wiki.lyrasis.org/display/DSPACE/Code+Testing+Guide#CodeTestingGuide-Cleaninguptestdata", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r443641277", "createdAt": "2020-06-22T15:25:08Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/RegistrationRestRepositoryIT.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.util.List;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.dspace.app.rest.matcher.RegistrationMatcher;\n+import org.dspace.app.rest.model.RegistrationRest;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.eperson.RegistrationData;\n+import org.dspace.eperson.dao.RegistrationDataDAO;\n+import org.hamcrest.Matchers;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+public class RegistrationRestRepositoryIT extends AbstractControllerIntegrationTest {\n+\n+    @Autowired\n+    private RegistrationDataDAO registrationDataDAO;\n+\n+    @Test\n+    public void findByTokenTestExistingUserTest() throws Exception {\n+        String email = eperson.getEmail();\n+        createTokenForEmail(email);\n+        RegistrationData registrationData = registrationDataDAO.findByEmail(context, email);\n+\n+        getClient().perform(get(\"/api/eperson/registrations/search/findByToken\")\n+                                .param(\"token\", registrationData.getToken()))\n+                   .andExpect(status().isOk())\n+                   .andExpect(\n+                       jsonPath(\"$\", Matchers.is(RegistrationMatcher.matchRegistration(email, eperson.getID()))));\n+\n+        email = \"newUser@testnewuser.com\";\n+        createTokenForEmail(email);\n+        registrationData = registrationDataDAO.findByEmail(context, email);\n+\n+        getClient().perform(get(\"/api/eperson/registrations/search/findByToken\")\n+                                .param(\"token\", registrationData.getToken()))\n+                   .andExpect(status().isOk())\n+                   .andExpect(\n+                       jsonPath(\"$\", Matchers.is(RegistrationMatcher.matchRegistration(email, null))));\n+\n+        registrationDataDAO.delete(context, registrationData);\n+\n+    }\n+\n+    @Test\n+    public void findByTokenTestNewUserTest() throws Exception {\n+        String email = \"newUser@testnewuser.com\";\n+        createTokenForEmail(email);\n+        RegistrationData registrationData = registrationDataDAO.findByEmail(context, email);\n+\n+        getClient().perform(get(\"/api/eperson/registrations/search/findByToken\")\n+                                .param(\"token\", registrationData.getToken()))\n+                   .andExpect(status().isOk())\n+                   .andExpect(\n+                       jsonPath(\"$\", Matchers.is(RegistrationMatcher.matchRegistration(email, null))));\n+\n+        registrationDataDAO.delete(context, registrationData);\n+    }\n+\n+    @Test\n+    public void findByTokenNotExistingTokenTest() throws Exception {\n+        getClient().perform(get(\"/api/eperson/registration/search/findByToken\")\n+                                .param(\"token\", \"ThisTokenDoesNotExist\"))\n+                   .andExpect(status().isNotFound());\n+    }\n+\n+    private void createTokenForEmail(String email) throws Exception {\n+        List<RegistrationData> registrationDatas;\n+        ObjectMapper mapper = new ObjectMapper();\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(email);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .content(mapper.writeValueAsBytes(registrationRest))\n+                                .contentType(contentType))\n+                   .andExpect(status().isCreated());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "891ab3f3e261e8a78321091b8835fab413937899"}, "originalPosition": 88}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "32a03eed36a9fbe08e44d0bc6a945a4b5853a8d6", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/32a03eed36a9fbe08e44d0bc6a945a4b5853a8d6", "committedDate": "2020-06-25T14:17:36Z", "message": "[Task 71604] moved RegistrationRestControllerIT tests to RegistrationRestRepositoryIT and added extra cleanup"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3NTAzNDE2", "url": "https://github.com/DSpace/DSpace/pull/2763#pullrequestreview-437503416", "createdAt": "2020-06-25T13:39:45Z", "commit": {"oid": "891ab3f3e261e8a78321091b8835fab413937899"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxMzozOTo0NlrOGo7K_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNzo1MToxM1rOGpFeIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU2NTY5NQ==", "bodyText": "I have read the previous discussion but I still don't understand why we cannot simply rely only on the dspace.cfg property. Why should I put user.registration to true if I wan't allow user registration?", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445565695", "createdAt": "2020-06-25T13:39:46Z", "author": {"login": "abollini"}, "path": "dspace-api/src/main/java/org/dspace/app/util/AuthorizeUtil.java", "diffHunk": "@@ -605,9 +612,53 @@ public static void authorizeManageGroup(Context context, Group group) throws SQL\n         throw new AuthorizeException(\"not authorized to manage this group\");\n     }\n \n+    /**\n+     * This method will return a boolean indicating whether the current user is allowed to register a new\n+     * account or not\n+     * @param context   The relevant DSpace context\n+     * @param request   The current request\n+     * @return          A boolean indicating whether the current user can register a new account or not\n+     * @throws SQLException If something goes wrong\n+     */\n+    public static boolean authorizeNewAccountRegistration(Context context, HttpServletRequest request)\n+        throws SQLException {\n+        if (DSpaceServicesFactory.getInstance().getConfigurationService()\n+                                 .getBooleanProperty(\"user.registration\", true)) {\n+            // This allowSetPassword is currently the only mthod that would return true only when it's\n+            // actually expected to be returning true.\n+            // For example the LDAP canSelfRegister will return true due to auto-register, while that\n+            // does not imply a new user can register explicitly\n+            return AuthenticateServiceFactory.getInstance().getAuthenticationService()\n+                                             .allowSetPassword(context, request, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "891ab3f3e261e8a78321091b8835fab413937899"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU2NzA3NQ==", "bodyText": "this seems me to confirm that we only need to check the dspace.cfg parameter (see previous comment)", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445567075", "createdAt": "2020-06-25T13:41:44Z", "author": {"login": "abollini"}, "path": "dspace-api/src/main/java/org/dspace/eperson/AccountServiceImpl.java", "diffHunk": "@@ -67,6 +71,9 @@ protected AccountServiceImpl() {\n     public void sendRegistrationInfo(Context context, String email)\n         throws SQLException, IOException, MessagingException,\n         AuthorizeException {\n+        if (!configurationService.getBooleanProperty(\"user.registration\", true)) {\n+            throw new IllegalStateException(\"The user.registration parameter was set to false\");\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "891ab3f3e261e8a78321091b8835fab413937899"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU3MjcxNg==", "bodyText": "this meet the current contract, I'm just thinking that a 422 would be more appropriate here as there is a semantic / status issue more than a formal error. But if you don't agree, ignore it and we can eventually open an issue to discuss it in future and apply later the changes (if agreed)", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445572716", "createdAt": "2020-06-25T13:49:41Z", "author": {"login": "abollini"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/EPersonRestRepository.java", "diffHunk": "@@ -90,8 +132,81 @@ protected EPersonRest createAndReturn(Context context)\n         } catch (SQLException e) {\n             throw new RuntimeException(e.getMessage(), e);\n         }\n+        return eperson;\n+    }\n \n-        return converter.toRest(eperson, utils.obtainProjection());\n+    /**\n+     * This method will perform checks on whether or not the given Request was valid for the creation of an EPerson\n+     * with a token or not.\n+     * It'll check that the token exists, that the token doesn't yet resolve to an actual eperson already,\n+     * that the email in the given json is equal to the email for the token and that other properties are set to\n+     * what we expect in this creation.\n+     * It'll check if all of those constraints hold true and if we're allowed to register new accounts.\n+     * If this is the case, we'll create an EPerson without any authorization checks and delete the token\n+     * @param context       The DSpace context\n+     * @param epersonRest   The EPersonRest given to be created\n+     * @param token         The token to be used\n+     * @return              The EPersonRest after the creation of the EPerson object\n+     * @throws AuthorizeException   If something goes wrong\n+     * @throws SQLException         If something goes wrong\n+     */\n+    private EPersonRest createAndReturn(Context context, EPersonRest epersonRest, String token)\n+        throws AuthorizeException, SQLException {\n+        if (!AuthorizeUtil.authorizeNewAccountRegistration(context, requestService\n+            .getCurrentRequest().getHttpServletRequest())) {\n+            throw new DSpaceBadRequestException(\n+                \"Registration is disabled, you are not authorized to create a new Authorization\");\n+        }\n+        RegistrationData registrationData = registrationDataService.findByToken(context, token);\n+        if (registrationData == null) {\n+            throw new DSpaceBadRequestException(\"The token given as parameter: \" + token + \" does not exist\" +\n+                                                \" in the database\");\n+        }\n+        if (es.findByEmail(context, registrationData.getEmail()) != null) {\n+            throw new DSpaceBadRequestException(\"The token given already contains an email address that resolves\" +\n+                                                \"to an eperson\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "891ab3f3e261e8a78321091b8835fab413937899"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU3NDQ4OQ==", "bodyText": "also in this case, as the issue is inside the json I would prefer a 422. It would be useful in any case note in the contract that this error is throw when the metadata are missing (it is noted that they are mandatory)", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445574489", "createdAt": "2020-06-25T13:51:52Z", "author": {"login": "abollini"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/EPersonRestRepository.java", "diffHunk": "@@ -90,8 +132,81 @@ protected EPersonRest createAndReturn(Context context)\n         } catch (SQLException e) {\n             throw new RuntimeException(e.getMessage(), e);\n         }\n+        return eperson;\n+    }\n \n-        return converter.toRest(eperson, utils.obtainProjection());\n+    /**\n+     * This method will perform checks on whether or not the given Request was valid for the creation of an EPerson\n+     * with a token or not.\n+     * It'll check that the token exists, that the token doesn't yet resolve to an actual eperson already,\n+     * that the email in the given json is equal to the email for the token and that other properties are set to\n+     * what we expect in this creation.\n+     * It'll check if all of those constraints hold true and if we're allowed to register new accounts.\n+     * If this is the case, we'll create an EPerson without any authorization checks and delete the token\n+     * @param context       The DSpace context\n+     * @param epersonRest   The EPersonRest given to be created\n+     * @param token         The token to be used\n+     * @return              The EPersonRest after the creation of the EPerson object\n+     * @throws AuthorizeException   If something goes wrong\n+     * @throws SQLException         If something goes wrong\n+     */\n+    private EPersonRest createAndReturn(Context context, EPersonRest epersonRest, String token)\n+        throws AuthorizeException, SQLException {\n+        if (!AuthorizeUtil.authorizeNewAccountRegistration(context, requestService\n+            .getCurrentRequest().getHttpServletRequest())) {\n+            throw new DSpaceBadRequestException(\n+                \"Registration is disabled, you are not authorized to create a new Authorization\");\n+        }\n+        RegistrationData registrationData = registrationDataService.findByToken(context, token);\n+        if (registrationData == null) {\n+            throw new DSpaceBadRequestException(\"The token given as parameter: \" + token + \" does not exist\" +\n+                                                \" in the database\");\n+        }\n+        if (es.findByEmail(context, registrationData.getEmail()) != null) {\n+            throw new DSpaceBadRequestException(\"The token given already contains an email address that resolves\" +\n+                                                \"to an eperson\");\n+        }\n+        String emailFromJson = epersonRest.getEmail();\n+        if (StringUtils.isNotBlank(emailFromJson)) {\n+            if (!StringUtils.equalsIgnoreCase(registrationData.getEmail(), emailFromJson)) {\n+                throw new DSpaceBadRequestException(\"The email resulting from the token does not match the email given\"\n+                                                        + \" in the json body. Email from token: \" +\n+                                                    registrationData.getEmail() + \" email from the json body: \"\n+                                                    + emailFromJson);\n+            }\n+        }\n+        if (epersonRest.isSelfRegistered() != null && !epersonRest.isSelfRegistered()) {\n+            throw new DSpaceBadRequestException(\"The self registered property cannot be set to false using this method\"\n+                                                    + \" with a token\");\n+        }\n+        checkRequiredProperties(epersonRest);\n+        // We'll turn off authorisation system because this call isn't admin based as it's token based\n+        context.turnOffAuthorisationSystem();\n+        EPerson ePerson = createEPersonFromRestObject(context, epersonRest);\n+        context.restoreAuthSystemState();\n+        // Restoring authorisation state right after the creation call\n+        accountService.deleteToken(context, token);\n+        if (context.getCurrentUser() == null) {\n+            context.setCurrentUser(ePerson);\n+        }\n+        return converter.toRest(ePerson, utils.obtainProjection());\n+    }\n+\n+    private void checkRequiredProperties(EPersonRest epersonRest) {\n+        MetadataRest metadataRest = epersonRest.getMetadata();\n+        if (metadataRest != null) {\n+            List<MetadataValueRest> epersonFirstName = metadataRest.getMap().get(\"eperson.firstname\");\n+            List<MetadataValueRest> epersonLastName = metadataRest.getMap().get(\"eperson.lastname\");\n+            if (epersonFirstName == null || epersonLastName == null ||\n+                epersonFirstName.isEmpty() || epersonLastName.isEmpty()) {\n+                throw new DSpaceBadRequestException(\"The eperson.firstname and eperson.lastname values need to be \" +\n+                                                    \"filled in\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "891ab3f3e261e8a78321091b8835fab413937899"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU3OTg5Ng==", "bodyText": "small thing but I would appreciate if we can use the constant here", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445579896", "createdAt": "2020-06-25T13:59:01Z", "author": {"login": "abollini"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/RegistrationRestControllerIT.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.app.rest.model.RegistrationRest;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.eperson.RegistrationData;\n+import org.dspace.eperson.dao.RegistrationDataDAO;\n+import org.dspace.services.ConfigurationService;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+public class RegistrationRestControllerIT extends AbstractControllerIntegrationTest {\n+\n+    @Autowired\n+    private RegistrationDataDAO registrationDataDAO;\n+\n+    @Autowired\n+    private ConfigurationService configurationService;\n+\n+    @Test\n+    public void registrationFlowTest() throws Exception {\n+        List<RegistrationData> registrationDataList = registrationDataDAO.findAll(context, RegistrationData.class);\n+        assertEquals(0, registrationDataList.size());\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(eperson.getEmail());\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .content(mapper.writeValueAsBytes(registrationRest))\n+                                .contentType(contentType))\n+                   .andExpect(status().isCreated());\n+        registrationDataList = registrationDataDAO.findAll(context, RegistrationData.class);\n+        assertEquals(1, registrationDataList.size());\n+        assertTrue(StringUtils.equalsIgnoreCase(registrationDataList.get(0).getEmail(), eperson.getEmail()));\n+\n+        String newEmail = \"newEPersonTest@gmail.com\";\n+        registrationRest.setEmail(newEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .content(mapper.writeValueAsBytes(registrationRest))\n+                                .contentType(contentType))\n+                   .andExpect(status().isCreated());\n+        registrationDataList = registrationDataDAO.findAll(context, RegistrationData.class);\n+        assertTrue(registrationDataList.size() == 2);\n+        assertTrue(StringUtils.equalsIgnoreCase(registrationDataList.get(0).getEmail(), newEmail) ||\n+                       StringUtils.equalsIgnoreCase(registrationDataList.get(1).getEmail(), newEmail));\n+        configurationService.setProperty(\"user.registration\", false);\n+\n+        newEmail = \"newEPersonTestTwo@gmail.com\";\n+        registrationRest.setEmail(newEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .content(mapper.writeValueAsBytes(registrationRest))\n+                                .contentType(contentType))\n+                   .andExpect(status().is(401));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "891ab3f3e261e8a78321091b8835fab413937899"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTcyOTk0Mw==", "bodyText": "this should go in a finally to be sure that it is executed also in case of test failure, otherwise a failure in this test due to a refactoring would produce a lot of unrelated failure due to a dirty testenv", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445729943", "createdAt": "2020-06-25T17:43:23Z", "author": {"login": "abollini"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1793,6 +1851,797 @@ public void getDirectEpersonGroups() throws Exception {\n \n     }\n \n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertNotEquals(oldPassword, newPasswordHash);\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        assertNull(registrationDataService.findByToken(context, tokenForEPerson));\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(), tokenForEPerson);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplacePasswordWithOtherUserTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+\n+        EPerson ePersonTwo = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"Smith\", \"Donald\")\n+                                        .withEmail(\"donaldSmith@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        accountService.sendRegistrationInfo(context, ePersonTwo.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String tokenForEPersonTwo = registrationDataService.findByEmail(context, ePersonTwo.getEmail()).getToken();\n+\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPersonTwo))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        registrationDataService.deleteByToken(context, tokenForEPersonTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplaceEmailWithTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        String originalEmail = \"johndoe@fake-email.com\";\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(originalEmail)\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newEmail = \"johnyandmaria@fake-email.com\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/email\", newEmail);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(ePerson.getEmail(), originalEmail);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void registerNewAccountPatchUpdatePasswordRandomUserUuidFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                            .contentType(MediaType.APPLICATION_JSON)\n+                            .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", newRegisterToken))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertFalse(registrationDataService.findByEmail(context, newRegisterEmail) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32a03eed36a9fbe08e44d0bc6a945a4b5853a8d6"}, "originalPosition": 317}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMDIyMA==", "bodyText": "mote in the finally part please", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445730220", "createdAt": "2020-06-25T17:43:48Z", "author": {"login": "abollini"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1793,6 +1851,797 @@ public void getDirectEpersonGroups() throws Exception {\n \n     }\n \n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertNotEquals(oldPassword, newPasswordHash);\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        assertNull(registrationDataService.findByToken(context, tokenForEPerson));\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(), tokenForEPerson);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplacePasswordWithOtherUserTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+\n+        EPerson ePersonTwo = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"Smith\", \"Donald\")\n+                                        .withEmail(\"donaldSmith@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        accountService.sendRegistrationInfo(context, ePersonTwo.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String tokenForEPersonTwo = registrationDataService.findByEmail(context, ePersonTwo.getEmail()).getToken();\n+\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPersonTwo))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        registrationDataService.deleteByToken(context, tokenForEPersonTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplaceEmailWithTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        String originalEmail = \"johndoe@fake-email.com\";\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(originalEmail)\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newEmail = \"johnyandmaria@fake-email.com\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/email\", newEmail);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(ePerson.getEmail(), originalEmail);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void registerNewAccountPatchUpdatePasswordRandomUserUuidFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                            .contentType(MediaType.APPLICATION_JSON)\n+                            .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", newRegisterToken))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertFalse(registrationDataService.findByEmail(context, newRegisterEmail) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                    .param(\"token\", newRegisterToken)\n+                                    .content(mapper.writeValueAsBytes(ePersonRest))\n+                                    .contentType(MediaType.APPLICATION_JSON))\n+                                      .andExpect(status().isCreated())\n+                                      .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                hasJsonPath(\"$.uuid\", not(empty())),\n+                                // is it what you expect? EPerson.getName() returns the email...\n+                                //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                    matchMetadata(\"eperson.firstname\", \"John\"),\n+                                    matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                )))))\n+                                .andDo(result -> idRef\n+                                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32a03eed36a9fbe08e44d0bc6a945a4b5853a8d6"}, "originalPosition": 378}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMDU3Mg==", "bodyText": "put in the finally block", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445730572", "createdAt": "2020-06-25T17:44:25Z", "author": {"login": "abollini"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1793,6 +1851,797 @@ public void getDirectEpersonGroups() throws Exception {\n \n     }\n \n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertNotEquals(oldPassword, newPasswordHash);\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        assertNull(registrationDataService.findByToken(context, tokenForEPerson));\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(), tokenForEPerson);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplacePasswordWithOtherUserTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+\n+        EPerson ePersonTwo = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"Smith\", \"Donald\")\n+                                        .withEmail(\"donaldSmith@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        accountService.sendRegistrationInfo(context, ePersonTwo.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String tokenForEPersonTwo = registrationDataService.findByEmail(context, ePersonTwo.getEmail()).getToken();\n+\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPersonTwo))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        registrationDataService.deleteByToken(context, tokenForEPersonTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplaceEmailWithTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        String originalEmail = \"johndoe@fake-email.com\";\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(originalEmail)\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newEmail = \"johnyandmaria@fake-email.com\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/email\", newEmail);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(ePerson.getEmail(), originalEmail);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void registerNewAccountPatchUpdatePasswordRandomUserUuidFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                            .contentType(MediaType.APPLICATION_JSON)\n+                            .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", newRegisterToken))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertFalse(registrationDataService.findByEmail(context, newRegisterEmail) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                    .param(\"token\", newRegisterToken)\n+                                    .content(mapper.writeValueAsBytes(ePersonRest))\n+                                    .contentType(MediaType.APPLICATION_JSON))\n+                                      .andExpect(status().isCreated())\n+                                      .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                hasJsonPath(\"$.uuid\", not(empty())),\n+                                // is it what you expect? EPerson.getName() returns the email...\n+                                //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                    matchMetadata(\"eperson.firstname\", \"John\"),\n+                                    matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                )))))\n+                                .andDo(result -> idRef\n+                                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                                               .param(\"token\", newRegisterToken)\n+                                                               .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                               .contentType(MediaType.APPLICATION_JSON))\n+                                                  .andExpect(status().isCreated())\n+                                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                      hasJsonPath(\"$.uuid\", not(empty())),\n+                                                      // is it what you expect? EPerson.getName() returns the email...\n+                                                      //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                      hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                      hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                      hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                      hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                          matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                          matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                      ))))).andDo(result -> idRef\n+                            .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32a03eed36a9fbe08e44d0bc6a945a4b5853a8d6"}, "originalPosition": 439}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMDc4OA==", "bodyText": "put in the finally block", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445730788", "createdAt": "2020-06-25T17:44:47Z", "author": {"login": "abollini"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1793,6 +1851,797 @@ public void getDirectEpersonGroups() throws Exception {\n \n     }\n \n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertNotEquals(oldPassword, newPasswordHash);\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        assertNull(registrationDataService.findByToken(context, tokenForEPerson));\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(), tokenForEPerson);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplacePasswordWithOtherUserTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+\n+        EPerson ePersonTwo = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"Smith\", \"Donald\")\n+                                        .withEmail(\"donaldSmith@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        accountService.sendRegistrationInfo(context, ePersonTwo.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String tokenForEPersonTwo = registrationDataService.findByEmail(context, ePersonTwo.getEmail()).getToken();\n+\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPersonTwo))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        registrationDataService.deleteByToken(context, tokenForEPersonTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplaceEmailWithTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        String originalEmail = \"johndoe@fake-email.com\";\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(originalEmail)\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newEmail = \"johnyandmaria@fake-email.com\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/email\", newEmail);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(ePerson.getEmail(), originalEmail);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void registerNewAccountPatchUpdatePasswordRandomUserUuidFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                            .contentType(MediaType.APPLICATION_JSON)\n+                            .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", newRegisterToken))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertFalse(registrationDataService.findByEmail(context, newRegisterEmail) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                    .param(\"token\", newRegisterToken)\n+                                    .content(mapper.writeValueAsBytes(ePersonRest))\n+                                    .contentType(MediaType.APPLICATION_JSON))\n+                                      .andExpect(status().isCreated())\n+                                      .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                hasJsonPath(\"$.uuid\", not(empty())),\n+                                // is it what you expect? EPerson.getName() returns the email...\n+                                //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                    matchMetadata(\"eperson.firstname\", \"John\"),\n+                                    matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                )))))\n+                                .andDo(result -> idRef\n+                                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                                               .param(\"token\", newRegisterToken)\n+                                                               .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                               .contentType(MediaType.APPLICATION_JSON))\n+                                                  .andExpect(status().isCreated())\n+                                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                      hasJsonPath(\"$.uuid\", not(empty())),\n+                                                      // is it what you expect? EPerson.getName() returns the email...\n+                                                      //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                      hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                      hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                      hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                      hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                          matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                          matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                      ))))).andDo(result -> idRef\n+                            .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailAndSelfRegisteredProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(true);\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                                               .param(\"token\", newRegisterToken)\n+                                                               .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                               .contentType(MediaType.APPLICATION_JSON))\n+                                                  .andExpect(status().isCreated())\n+                                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                      hasJsonPath(\"$.uuid\", not(empty())),\n+                                                      // is it what you expect? EPerson.getName() returns the email...\n+                                                      //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                      hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                      hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                      hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                      hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                          matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                          matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                      ))))).andDo(result -> idRef\n+                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32a03eed36a9fbe08e44d0bc6a945a4b5853a8d6"}, "originalPosition": 505}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMDk3NA==", "bodyText": "put in a finally block", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445730974", "createdAt": "2020-06-25T17:45:05Z", "author": {"login": "abollini"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1793,6 +1851,797 @@ public void getDirectEpersonGroups() throws Exception {\n \n     }\n \n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertNotEquals(oldPassword, newPasswordHash);\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        assertNull(registrationDataService.findByToken(context, tokenForEPerson));\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(), tokenForEPerson);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplacePasswordWithOtherUserTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+\n+        EPerson ePersonTwo = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"Smith\", \"Donald\")\n+                                        .withEmail(\"donaldSmith@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        accountService.sendRegistrationInfo(context, ePersonTwo.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String tokenForEPersonTwo = registrationDataService.findByEmail(context, ePersonTwo.getEmail()).getToken();\n+\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPersonTwo))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        registrationDataService.deleteByToken(context, tokenForEPersonTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplaceEmailWithTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        String originalEmail = \"johndoe@fake-email.com\";\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(originalEmail)\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newEmail = \"johnyandmaria@fake-email.com\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/email\", newEmail);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(ePerson.getEmail(), originalEmail);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void registerNewAccountPatchUpdatePasswordRandomUserUuidFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                            .contentType(MediaType.APPLICATION_JSON)\n+                            .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", newRegisterToken))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertFalse(registrationDataService.findByEmail(context, newRegisterEmail) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                    .param(\"token\", newRegisterToken)\n+                                    .content(mapper.writeValueAsBytes(ePersonRest))\n+                                    .contentType(MediaType.APPLICATION_JSON))\n+                                      .andExpect(status().isCreated())\n+                                      .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                hasJsonPath(\"$.uuid\", not(empty())),\n+                                // is it what you expect? EPerson.getName() returns the email...\n+                                //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                    matchMetadata(\"eperson.firstname\", \"John\"),\n+                                    matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                )))))\n+                                .andDo(result -> idRef\n+                                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                                               .param(\"token\", newRegisterToken)\n+                                                               .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                               .contentType(MediaType.APPLICATION_JSON))\n+                                                  .andExpect(status().isCreated())\n+                                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                      hasJsonPath(\"$.uuid\", not(empty())),\n+                                                      // is it what you expect? EPerson.getName() returns the email...\n+                                                      //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                      hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                      hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                      hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                      hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                          matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                          matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                      ))))).andDo(result -> idRef\n+                            .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailAndSelfRegisteredProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(true);\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                                               .param(\"token\", newRegisterToken)\n+                                                               .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                               .contentType(MediaType.APPLICATION_JSON))\n+                                                  .andExpect(status().isCreated())\n+                                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                      hasJsonPath(\"$.uuid\", not(empty())),\n+                                                      // is it what you expect? EPerson.getName() returns the email...\n+                                                      //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                      hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                      hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                      hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                      hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                          matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                          matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                      ))))).andDo(result -> idRef\n+                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithTwoTokensDifferentEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        String newRegisterEmailTwo = \"new-register-two@fake-email.com\";\n+        RegistrationRest registrationRestTwo = new RegistrationRest();\n+        registrationRestTwo.setEmail(newRegisterEmailTwo);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRestTwo)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterTokenTwo = registrationDataService.findByEmail(context, newRegisterEmailTwo).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmailTwo);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                                           .param(\"token\", newRegisterToken)\n+                                                           .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                           .contentType(MediaType.APPLICATION_JSON))\n+                                              .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmailTwo);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterTokenTwo));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        registrationDataService.deleteByToken(context, newRegisterTokenTwo);\n+        context.restoreAuthSystemState();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32a03eed36a9fbe08e44d0bc6a945a4b5853a8d6"}, "originalPosition": 565}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMTMyMg==", "bodyText": "put in a finally block", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445731322", "createdAt": "2020-06-25T17:45:36Z", "author": {"login": "abollini"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1793,6 +1851,797 @@ public void getDirectEpersonGroups() throws Exception {\n \n     }\n \n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertNotEquals(oldPassword, newPasswordHash);\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        assertNull(registrationDataService.findByToken(context, tokenForEPerson));\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(), tokenForEPerson);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplacePasswordWithOtherUserTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+\n+        EPerson ePersonTwo = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"Smith\", \"Donald\")\n+                                        .withEmail(\"donaldSmith@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        accountService.sendRegistrationInfo(context, ePersonTwo.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String tokenForEPersonTwo = registrationDataService.findByEmail(context, ePersonTwo.getEmail()).getToken();\n+\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPersonTwo))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        registrationDataService.deleteByToken(context, tokenForEPersonTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplaceEmailWithTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        String originalEmail = \"johndoe@fake-email.com\";\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(originalEmail)\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newEmail = \"johnyandmaria@fake-email.com\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/email\", newEmail);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(ePerson.getEmail(), originalEmail);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void registerNewAccountPatchUpdatePasswordRandomUserUuidFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                            .contentType(MediaType.APPLICATION_JSON)\n+                            .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", newRegisterToken))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertFalse(registrationDataService.findByEmail(context, newRegisterEmail) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                    .param(\"token\", newRegisterToken)\n+                                    .content(mapper.writeValueAsBytes(ePersonRest))\n+                                    .contentType(MediaType.APPLICATION_JSON))\n+                                      .andExpect(status().isCreated())\n+                                      .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                hasJsonPath(\"$.uuid\", not(empty())),\n+                                // is it what you expect? EPerson.getName() returns the email...\n+                                //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                    matchMetadata(\"eperson.firstname\", \"John\"),\n+                                    matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                )))))\n+                                .andDo(result -> idRef\n+                                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                                               .param(\"token\", newRegisterToken)\n+                                                               .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                               .contentType(MediaType.APPLICATION_JSON))\n+                                                  .andExpect(status().isCreated())\n+                                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                      hasJsonPath(\"$.uuid\", not(empty())),\n+                                                      // is it what you expect? EPerson.getName() returns the email...\n+                                                      //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                      hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                      hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                      hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                      hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                          matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                          matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                      ))))).andDo(result -> idRef\n+                            .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailAndSelfRegisteredProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(true);\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                                               .param(\"token\", newRegisterToken)\n+                                                               .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                               .contentType(MediaType.APPLICATION_JSON))\n+                                                  .andExpect(status().isCreated())\n+                                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                      hasJsonPath(\"$.uuid\", not(empty())),\n+                                                      // is it what you expect? EPerson.getName() returns the email...\n+                                                      //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                      hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                      hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                      hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                      hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                          matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                          matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                      ))))).andDo(result -> idRef\n+                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithTwoTokensDifferentEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        String newRegisterEmailTwo = \"new-register-two@fake-email.com\";\n+        RegistrationRest registrationRestTwo = new RegistrationRest();\n+        registrationRestTwo.setEmail(newRegisterEmailTwo);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRestTwo)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterTokenTwo = registrationDataService.findByEmail(context, newRegisterEmailTwo).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmailTwo);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                                           .param(\"token\", newRegisterToken)\n+                                                           .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                           .contentType(MediaType.APPLICATION_JSON))\n+                                              .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmailTwo);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterTokenTwo));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        registrationDataService.deleteByToken(context, newRegisterTokenTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithRandomTokenWithEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                     .param(\"token\", \"randomToken\")\n+                                     .content(mapper.writeValueAsBytes(ePersonRest))\n+                                     .contentType(MediaType.APPLICATION_JSON))\n+                        .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32a03eed36a9fbe08e44d0bc6a945a4b5853a8d6"}, "originalPosition": 610}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMTQ4Ng==", "bodyText": "put in a finally block", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445731486", "createdAt": "2020-06-25T17:45:52Z", "author": {"login": "abollini"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1793,6 +1851,797 @@ public void getDirectEpersonGroups() throws Exception {\n \n     }\n \n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertNotEquals(oldPassword, newPasswordHash);\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        assertNull(registrationDataService.findByToken(context, tokenForEPerson));\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(), tokenForEPerson);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplacePasswordWithOtherUserTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+\n+        EPerson ePersonTwo = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"Smith\", \"Donald\")\n+                                        .withEmail(\"donaldSmith@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        accountService.sendRegistrationInfo(context, ePersonTwo.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String tokenForEPersonTwo = registrationDataService.findByEmail(context, ePersonTwo.getEmail()).getToken();\n+\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPersonTwo))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        registrationDataService.deleteByToken(context, tokenForEPersonTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplaceEmailWithTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        String originalEmail = \"johndoe@fake-email.com\";\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(originalEmail)\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newEmail = \"johnyandmaria@fake-email.com\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/email\", newEmail);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(ePerson.getEmail(), originalEmail);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void registerNewAccountPatchUpdatePasswordRandomUserUuidFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                            .contentType(MediaType.APPLICATION_JSON)\n+                            .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", newRegisterToken))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertFalse(registrationDataService.findByEmail(context, newRegisterEmail) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                    .param(\"token\", newRegisterToken)\n+                                    .content(mapper.writeValueAsBytes(ePersonRest))\n+                                    .contentType(MediaType.APPLICATION_JSON))\n+                                      .andExpect(status().isCreated())\n+                                      .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                hasJsonPath(\"$.uuid\", not(empty())),\n+                                // is it what you expect? EPerson.getName() returns the email...\n+                                //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                    matchMetadata(\"eperson.firstname\", \"John\"),\n+                                    matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                )))))\n+                                .andDo(result -> idRef\n+                                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                                               .param(\"token\", newRegisterToken)\n+                                                               .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                               .contentType(MediaType.APPLICATION_JSON))\n+                                                  .andExpect(status().isCreated())\n+                                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                      hasJsonPath(\"$.uuid\", not(empty())),\n+                                                      // is it what you expect? EPerson.getName() returns the email...\n+                                                      //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                      hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                      hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                      hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                      hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                          matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                          matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                      ))))).andDo(result -> idRef\n+                            .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailAndSelfRegisteredProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(true);\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                                               .param(\"token\", newRegisterToken)\n+                                                               .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                               .contentType(MediaType.APPLICATION_JSON))\n+                                                  .andExpect(status().isCreated())\n+                                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                      hasJsonPath(\"$.uuid\", not(empty())),\n+                                                      // is it what you expect? EPerson.getName() returns the email...\n+                                                      //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                      hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                      hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                      hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                      hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                          matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                          matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                      ))))).andDo(result -> idRef\n+                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithTwoTokensDifferentEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        String newRegisterEmailTwo = \"new-register-two@fake-email.com\";\n+        RegistrationRest registrationRestTwo = new RegistrationRest();\n+        registrationRestTwo.setEmail(newRegisterEmailTwo);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRestTwo)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterTokenTwo = registrationDataService.findByEmail(context, newRegisterEmailTwo).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmailTwo);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                                           .param(\"token\", newRegisterToken)\n+                                                           .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                           .contentType(MediaType.APPLICATION_JSON))\n+                                              .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmailTwo);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterTokenTwo));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        registrationDataService.deleteByToken(context, newRegisterTokenTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithRandomTokenWithEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                     .param(\"token\", \"randomToken\")\n+                                     .content(mapper.writeValueAsBytes(ePersonRest))\n+                                     .contentType(MediaType.APPLICATION_JSON))\n+                        .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailAndSelfRegisteredFalseProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(false);\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                                           .param(\"token\", newRegisterToken)\n+                                                           .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                           .contentType(MediaType.APPLICATION_JSON))\n+                                              .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32a03eed36a9fbe08e44d0bc6a945a4b5853a8d6"}, "originalPosition": 656}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMTYxMw==", "bodyText": "put in a finally block", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445731613", "createdAt": "2020-06-25T17:46:07Z", "author": {"login": "abollini"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1793,6 +1851,797 @@ public void getDirectEpersonGroups() throws Exception {\n \n     }\n \n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertNotEquals(oldPassword, newPasswordHash);\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        assertNull(registrationDataService.findByToken(context, tokenForEPerson));\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(), tokenForEPerson);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplacePasswordWithOtherUserTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+\n+        EPerson ePersonTwo = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"Smith\", \"Donald\")\n+                                        .withEmail(\"donaldSmith@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        accountService.sendRegistrationInfo(context, ePersonTwo.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String tokenForEPersonTwo = registrationDataService.findByEmail(context, ePersonTwo.getEmail()).getToken();\n+\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPersonTwo))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        registrationDataService.deleteByToken(context, tokenForEPersonTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplaceEmailWithTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        String originalEmail = \"johndoe@fake-email.com\";\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(originalEmail)\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newEmail = \"johnyandmaria@fake-email.com\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/email\", newEmail);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(ePerson.getEmail(), originalEmail);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void registerNewAccountPatchUpdatePasswordRandomUserUuidFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                            .contentType(MediaType.APPLICATION_JSON)\n+                            .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", newRegisterToken))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertFalse(registrationDataService.findByEmail(context, newRegisterEmail) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                    .param(\"token\", newRegisterToken)\n+                                    .content(mapper.writeValueAsBytes(ePersonRest))\n+                                    .contentType(MediaType.APPLICATION_JSON))\n+                                      .andExpect(status().isCreated())\n+                                      .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                hasJsonPath(\"$.uuid\", not(empty())),\n+                                // is it what you expect? EPerson.getName() returns the email...\n+                                //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                    matchMetadata(\"eperson.firstname\", \"John\"),\n+                                    matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                )))))\n+                                .andDo(result -> idRef\n+                                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                                               .param(\"token\", newRegisterToken)\n+                                                               .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                               .contentType(MediaType.APPLICATION_JSON))\n+                                                  .andExpect(status().isCreated())\n+                                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                      hasJsonPath(\"$.uuid\", not(empty())),\n+                                                      // is it what you expect? EPerson.getName() returns the email...\n+                                                      //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                      hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                      hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                      hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                      hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                          matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                          matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                      ))))).andDo(result -> idRef\n+                            .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailAndSelfRegisteredProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(true);\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                                               .param(\"token\", newRegisterToken)\n+                                                               .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                               .contentType(MediaType.APPLICATION_JSON))\n+                                                  .andExpect(status().isCreated())\n+                                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                      hasJsonPath(\"$.uuid\", not(empty())),\n+                                                      // is it what you expect? EPerson.getName() returns the email...\n+                                                      //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                      hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                      hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                      hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                      hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                          matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                          matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                      ))))).andDo(result -> idRef\n+                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithTwoTokensDifferentEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        String newRegisterEmailTwo = \"new-register-two@fake-email.com\";\n+        RegistrationRest registrationRestTwo = new RegistrationRest();\n+        registrationRestTwo.setEmail(newRegisterEmailTwo);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRestTwo)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterTokenTwo = registrationDataService.findByEmail(context, newRegisterEmailTwo).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmailTwo);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                                           .param(\"token\", newRegisterToken)\n+                                                           .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                           .contentType(MediaType.APPLICATION_JSON))\n+                                              .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmailTwo);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterTokenTwo));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        registrationDataService.deleteByToken(context, newRegisterTokenTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithRandomTokenWithEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                     .param(\"token\", \"randomToken\")\n+                                     .content(mapper.writeValueAsBytes(ePersonRest))\n+                                     .contentType(MediaType.APPLICATION_JSON))\n+                        .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailAndSelfRegisteredFalseProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(false);\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                                           .param(\"token\", newRegisterToken)\n+                                                           .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                           .contentType(MediaType.APPLICATION_JSON))\n+                                              .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutLastNameProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(true);\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                     .param(\"token\", newRegisterToken)\n+                                     .content(mapper.writeValueAsBytes(ePersonRest))\n+                                     .contentType(MediaType.APPLICATION_JSON))\n+                        .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32a03eed36a9fbe08e44d0bc6a945a4b5853a8d6"}, "originalPosition": 699}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMTcyNQ==", "bodyText": "put in a finally block", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445731725", "createdAt": "2020-06-25T17:46:17Z", "author": {"login": "abollini"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1793,6 +1851,797 @@ public void getDirectEpersonGroups() throws Exception {\n \n     }\n \n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertNotEquals(oldPassword, newPasswordHash);\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        assertNull(registrationDataService.findByToken(context, tokenForEPerson));\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(), tokenForEPerson);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplacePasswordWithOtherUserTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+\n+        EPerson ePersonTwo = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"Smith\", \"Donald\")\n+                                        .withEmail(\"donaldSmith@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        accountService.sendRegistrationInfo(context, ePersonTwo.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String tokenForEPersonTwo = registrationDataService.findByEmail(context, ePersonTwo.getEmail()).getToken();\n+\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPersonTwo))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        registrationDataService.deleteByToken(context, tokenForEPersonTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplaceEmailWithTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        String originalEmail = \"johndoe@fake-email.com\";\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(originalEmail)\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newEmail = \"johnyandmaria@fake-email.com\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/email\", newEmail);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(ePerson.getEmail(), originalEmail);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void registerNewAccountPatchUpdatePasswordRandomUserUuidFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                            .contentType(MediaType.APPLICATION_JSON)\n+                            .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", newRegisterToken))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertFalse(registrationDataService.findByEmail(context, newRegisterEmail) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                    .param(\"token\", newRegisterToken)\n+                                    .content(mapper.writeValueAsBytes(ePersonRest))\n+                                    .contentType(MediaType.APPLICATION_JSON))\n+                                      .andExpect(status().isCreated())\n+                                      .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                hasJsonPath(\"$.uuid\", not(empty())),\n+                                // is it what you expect? EPerson.getName() returns the email...\n+                                //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                    matchMetadata(\"eperson.firstname\", \"John\"),\n+                                    matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                )))))\n+                                .andDo(result -> idRef\n+                                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                                               .param(\"token\", newRegisterToken)\n+                                                               .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                               .contentType(MediaType.APPLICATION_JSON))\n+                                                  .andExpect(status().isCreated())\n+                                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                      hasJsonPath(\"$.uuid\", not(empty())),\n+                                                      // is it what you expect? EPerson.getName() returns the email...\n+                                                      //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                      hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                      hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                      hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                      hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                          matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                          matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                      ))))).andDo(result -> idRef\n+                            .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailAndSelfRegisteredProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(true);\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                                               .param(\"token\", newRegisterToken)\n+                                                               .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                               .contentType(MediaType.APPLICATION_JSON))\n+                                                  .andExpect(status().isCreated())\n+                                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                      hasJsonPath(\"$.uuid\", not(empty())),\n+                                                      // is it what you expect? EPerson.getName() returns the email...\n+                                                      //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                      hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                      hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                      hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                      hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                          matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                          matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                      ))))).andDo(result -> idRef\n+                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithTwoTokensDifferentEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        String newRegisterEmailTwo = \"new-register-two@fake-email.com\";\n+        RegistrationRest registrationRestTwo = new RegistrationRest();\n+        registrationRestTwo.setEmail(newRegisterEmailTwo);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRestTwo)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterTokenTwo = registrationDataService.findByEmail(context, newRegisterEmailTwo).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmailTwo);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                                           .param(\"token\", newRegisterToken)\n+                                                           .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                           .contentType(MediaType.APPLICATION_JSON))\n+                                              .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmailTwo);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterTokenTwo));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        registrationDataService.deleteByToken(context, newRegisterTokenTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithRandomTokenWithEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                     .param(\"token\", \"randomToken\")\n+                                     .content(mapper.writeValueAsBytes(ePersonRest))\n+                                     .contentType(MediaType.APPLICATION_JSON))\n+                        .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailAndSelfRegisteredFalseProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(false);\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                                           .param(\"token\", newRegisterToken)\n+                                                           .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                           .contentType(MediaType.APPLICATION_JSON))\n+                                              .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutLastNameProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(true);\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                     .param(\"token\", newRegisterToken)\n+                                     .content(mapper.writeValueAsBytes(ePersonRest))\n+                                     .contentType(MediaType.APPLICATION_JSON))\n+                        .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutFirstNameProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(true);\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                     .param(\"token\", newRegisterToken)\n+                                     .content(mapper.writeValueAsBytes(ePersonRest))\n+                                     .contentType(MediaType.APPLICATION_JSON))\n+                        .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32a03eed36a9fbe08e44d0bc6a945a4b5853a8d6"}, "originalPosition": 742}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMTgwNA==", "bodyText": "put in a finally block", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445731804", "createdAt": "2020-06-25T17:46:25Z", "author": {"login": "abollini"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1793,6 +1851,797 @@ public void getDirectEpersonGroups() throws Exception {\n \n     }\n \n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertNotEquals(oldPassword, newPasswordHash);\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        assertNull(registrationDataService.findByToken(context, tokenForEPerson));\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(), tokenForEPerson);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplacePasswordWithOtherUserTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+\n+        EPerson ePersonTwo = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"Smith\", \"Donald\")\n+                                        .withEmail(\"donaldSmith@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        accountService.sendRegistrationInfo(context, ePersonTwo.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String tokenForEPersonTwo = registrationDataService.findByEmail(context, ePersonTwo.getEmail()).getToken();\n+\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPersonTwo))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        registrationDataService.deleteByToken(context, tokenForEPersonTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplaceEmailWithTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        String originalEmail = \"johndoe@fake-email.com\";\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(originalEmail)\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newEmail = \"johnyandmaria@fake-email.com\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/email\", newEmail);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(ePerson.getEmail(), originalEmail);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void registerNewAccountPatchUpdatePasswordRandomUserUuidFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                            .contentType(MediaType.APPLICATION_JSON)\n+                            .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", newRegisterToken))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertFalse(registrationDataService.findByEmail(context, newRegisterEmail) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                    .param(\"token\", newRegisterToken)\n+                                    .content(mapper.writeValueAsBytes(ePersonRest))\n+                                    .contentType(MediaType.APPLICATION_JSON))\n+                                      .andExpect(status().isCreated())\n+                                      .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                hasJsonPath(\"$.uuid\", not(empty())),\n+                                // is it what you expect? EPerson.getName() returns the email...\n+                                //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                    matchMetadata(\"eperson.firstname\", \"John\"),\n+                                    matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                )))))\n+                                .andDo(result -> idRef\n+                                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                                               .param(\"token\", newRegisterToken)\n+                                                               .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                               .contentType(MediaType.APPLICATION_JSON))\n+                                                  .andExpect(status().isCreated())\n+                                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                      hasJsonPath(\"$.uuid\", not(empty())),\n+                                                      // is it what you expect? EPerson.getName() returns the email...\n+                                                      //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                      hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                      hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                      hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                      hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                          matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                          matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                      ))))).andDo(result -> idRef\n+                            .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailAndSelfRegisteredProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(true);\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                                               .param(\"token\", newRegisterToken)\n+                                                               .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                               .contentType(MediaType.APPLICATION_JSON))\n+                                                  .andExpect(status().isCreated())\n+                                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                      hasJsonPath(\"$.uuid\", not(empty())),\n+                                                      // is it what you expect? EPerson.getName() returns the email...\n+                                                      //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                      hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                      hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                      hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                      hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                          matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                          matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                      ))))).andDo(result -> idRef\n+                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithTwoTokensDifferentEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        String newRegisterEmailTwo = \"new-register-two@fake-email.com\";\n+        RegistrationRest registrationRestTwo = new RegistrationRest();\n+        registrationRestTwo.setEmail(newRegisterEmailTwo);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRestTwo)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterTokenTwo = registrationDataService.findByEmail(context, newRegisterEmailTwo).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmailTwo);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                                           .param(\"token\", newRegisterToken)\n+                                                           .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                           .contentType(MediaType.APPLICATION_JSON))\n+                                              .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmailTwo);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterTokenTwo));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        registrationDataService.deleteByToken(context, newRegisterTokenTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithRandomTokenWithEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                     .param(\"token\", \"randomToken\")\n+                                     .content(mapper.writeValueAsBytes(ePersonRest))\n+                                     .contentType(MediaType.APPLICATION_JSON))\n+                        .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailAndSelfRegisteredFalseProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(false);\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                                           .param(\"token\", newRegisterToken)\n+                                                           .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                           .contentType(MediaType.APPLICATION_JSON))\n+                                              .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutLastNameProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(true);\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                     .param(\"token\", newRegisterToken)\n+                                     .content(mapper.writeValueAsBytes(ePersonRest))\n+                                     .contentType(MediaType.APPLICATION_JSON))\n+                        .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutFirstNameProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(true);\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                     .param(\"token\", newRegisterToken)\n+                                     .content(mapper.writeValueAsBytes(ePersonRest))\n+                                     .contentType(MediaType.APPLICATION_JSON))\n+                        .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutPasswordProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                     .param(\"token\", newRegisterToken)\n+                                     .content(mapper.writeValueAsBytes(ePersonRest))\n+                                     .contentType(MediaType.APPLICATION_JSON))\n+                        .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32a03eed36a9fbe08e44d0bc6a945a4b5853a8d6"}, "originalPosition": 786}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMTg5MQ==", "bodyText": "put in a finally block", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445731891", "createdAt": "2020-06-25T17:46:34Z", "author": {"login": "abollini"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1793,6 +1851,797 @@ public void getDirectEpersonGroups() throws Exception {\n \n     }\n \n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertNotEquals(oldPassword, newPasswordHash);\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        assertNull(registrationDataService.findByToken(context, tokenForEPerson));\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(), tokenForEPerson);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplacePasswordWithOtherUserTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+\n+        EPerson ePersonTwo = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"Smith\", \"Donald\")\n+                                        .withEmail(\"donaldSmith@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        accountService.sendRegistrationInfo(context, ePersonTwo.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String tokenForEPersonTwo = registrationDataService.findByEmail(context, ePersonTwo.getEmail()).getToken();\n+\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPersonTwo))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        registrationDataService.deleteByToken(context, tokenForEPersonTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplaceEmailWithTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        String originalEmail = \"johndoe@fake-email.com\";\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(originalEmail)\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newEmail = \"johnyandmaria@fake-email.com\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/email\", newEmail);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(ePerson.getEmail(), originalEmail);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void registerNewAccountPatchUpdatePasswordRandomUserUuidFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                            .contentType(MediaType.APPLICATION_JSON)\n+                            .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", newRegisterToken))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertFalse(registrationDataService.findByEmail(context, newRegisterEmail) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                    .param(\"token\", newRegisterToken)\n+                                    .content(mapper.writeValueAsBytes(ePersonRest))\n+                                    .contentType(MediaType.APPLICATION_JSON))\n+                                      .andExpect(status().isCreated())\n+                                      .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                hasJsonPath(\"$.uuid\", not(empty())),\n+                                // is it what you expect? EPerson.getName() returns the email...\n+                                //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                    matchMetadata(\"eperson.firstname\", \"John\"),\n+                                    matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                )))))\n+                                .andDo(result -> idRef\n+                                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                                               .param(\"token\", newRegisterToken)\n+                                                               .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                               .contentType(MediaType.APPLICATION_JSON))\n+                                                  .andExpect(status().isCreated())\n+                                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                      hasJsonPath(\"$.uuid\", not(empty())),\n+                                                      // is it what you expect? EPerson.getName() returns the email...\n+                                                      //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                      hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                      hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                      hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                      hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                          matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                          matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                      ))))).andDo(result -> idRef\n+                            .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailAndSelfRegisteredProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(true);\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                                               .param(\"token\", newRegisterToken)\n+                                                               .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                               .contentType(MediaType.APPLICATION_JSON))\n+                                                  .andExpect(status().isCreated())\n+                                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                      hasJsonPath(\"$.uuid\", not(empty())),\n+                                                      // is it what you expect? EPerson.getName() returns the email...\n+                                                      //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                      hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                      hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                      hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                      hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                          matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                          matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                      ))))).andDo(result -> idRef\n+                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithTwoTokensDifferentEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        String newRegisterEmailTwo = \"new-register-two@fake-email.com\";\n+        RegistrationRest registrationRestTwo = new RegistrationRest();\n+        registrationRestTwo.setEmail(newRegisterEmailTwo);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRestTwo)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterTokenTwo = registrationDataService.findByEmail(context, newRegisterEmailTwo).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmailTwo);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                                           .param(\"token\", newRegisterToken)\n+                                                           .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                           .contentType(MediaType.APPLICATION_JSON))\n+                                              .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmailTwo);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterTokenTwo));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        registrationDataService.deleteByToken(context, newRegisterTokenTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithRandomTokenWithEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                     .param(\"token\", \"randomToken\")\n+                                     .content(mapper.writeValueAsBytes(ePersonRest))\n+                                     .contentType(MediaType.APPLICATION_JSON))\n+                        .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailAndSelfRegisteredFalseProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(false);\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                                           .param(\"token\", newRegisterToken)\n+                                                           .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                           .contentType(MediaType.APPLICATION_JSON))\n+                                              .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutLastNameProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(true);\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                     .param(\"token\", newRegisterToken)\n+                                     .content(mapper.writeValueAsBytes(ePersonRest))\n+                                     .contentType(MediaType.APPLICATION_JSON))\n+                        .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutFirstNameProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(true);\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                     .param(\"token\", newRegisterToken)\n+                                     .content(mapper.writeValueAsBytes(ePersonRest))\n+                                     .contentType(MediaType.APPLICATION_JSON))\n+                        .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutPasswordProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                     .param(\"token\", newRegisterToken)\n+                                     .content(mapper.writeValueAsBytes(ePersonRest))\n+                                     .contentType(MediaType.APPLICATION_JSON))\n+                        .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void postEPersonWithWrongToken() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String newEmail = \"new-email@fake-email.com\";\n+\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(eperson.getEmail());\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String forgotPasswordToken = registrationDataService.findByEmail(context, eperson.getEmail()).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(true);\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                     .param(\"token\", forgotPasswordToken)\n+                                     .content(mapper.writeValueAsBytes(ePersonRest))\n+                                     .contentType(MediaType.APPLICATION_JSON))\n+                        .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, forgotPasswordToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, forgotPasswordToken);\n+        context.restoreAuthSystemState();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32a03eed36a9fbe08e44d0bc6a945a4b5853a8d6"}, "originalPosition": 832}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMjEyNA==", "bodyText": "more to the finally block", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445732124", "createdAt": "2020-06-25T17:47:03Z", "author": {"login": "abollini"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1793,6 +1851,797 @@ public void getDirectEpersonGroups() throws Exception {\n \n     }\n \n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertNotEquals(oldPassword, newPasswordHash);\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        assertNull(registrationDataService.findByToken(context, tokenForEPerson));\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(), tokenForEPerson);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplacePasswordWithOtherUserTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+\n+        EPerson ePersonTwo = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"Smith\", \"Donald\")\n+                                        .withEmail(\"donaldSmith@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        accountService.sendRegistrationInfo(context, ePersonTwo.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String tokenForEPersonTwo = registrationDataService.findByEmail(context, ePersonTwo.getEmail()).getToken();\n+\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPersonTwo))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        registrationDataService.deleteByToken(context, tokenForEPersonTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplaceEmailWithTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        String originalEmail = \"johndoe@fake-email.com\";\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(originalEmail)\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newEmail = \"johnyandmaria@fake-email.com\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/email\", newEmail);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(ePerson.getEmail(), originalEmail);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void registerNewAccountPatchUpdatePasswordRandomUserUuidFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                            .contentType(MediaType.APPLICATION_JSON)\n+                            .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", newRegisterToken))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertFalse(registrationDataService.findByEmail(context, newRegisterEmail) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                    .param(\"token\", newRegisterToken)\n+                                    .content(mapper.writeValueAsBytes(ePersonRest))\n+                                    .contentType(MediaType.APPLICATION_JSON))\n+                                      .andExpect(status().isCreated())\n+                                      .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                hasJsonPath(\"$.uuid\", not(empty())),\n+                                // is it what you expect? EPerson.getName() returns the email...\n+                                //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                    matchMetadata(\"eperson.firstname\", \"John\"),\n+                                    matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                )))))\n+                                .andDo(result -> idRef\n+                                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                                               .param(\"token\", newRegisterToken)\n+                                                               .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                               .contentType(MediaType.APPLICATION_JSON))\n+                                                  .andExpect(status().isCreated())\n+                                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                      hasJsonPath(\"$.uuid\", not(empty())),\n+                                                      // is it what you expect? EPerson.getName() returns the email...\n+                                                      //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                      hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                      hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                      hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                      hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                          matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                          matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                      ))))).andDo(result -> idRef\n+                            .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailAndSelfRegisteredProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(true);\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                                               .param(\"token\", newRegisterToken)\n+                                                               .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                               .contentType(MediaType.APPLICATION_JSON))\n+                                                  .andExpect(status().isCreated())\n+                                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                      hasJsonPath(\"$.uuid\", not(empty())),\n+                                                      // is it what you expect? EPerson.getName() returns the email...\n+                                                      //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                      hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                      hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                      hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                      hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                          matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                          matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                      ))))).andDo(result -> idRef\n+                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithTwoTokensDifferentEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        String newRegisterEmailTwo = \"new-register-two@fake-email.com\";\n+        RegistrationRest registrationRestTwo = new RegistrationRest();\n+        registrationRestTwo.setEmail(newRegisterEmailTwo);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRestTwo)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterTokenTwo = registrationDataService.findByEmail(context, newRegisterEmailTwo).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmailTwo);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                                           .param(\"token\", newRegisterToken)\n+                                                           .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                           .contentType(MediaType.APPLICATION_JSON))\n+                                              .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmailTwo);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterTokenTwo));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        registrationDataService.deleteByToken(context, newRegisterTokenTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithRandomTokenWithEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                     .param(\"token\", \"randomToken\")\n+                                     .content(mapper.writeValueAsBytes(ePersonRest))\n+                                     .contentType(MediaType.APPLICATION_JSON))\n+                        .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailAndSelfRegisteredFalseProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(false);\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                                           .param(\"token\", newRegisterToken)\n+                                                           .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                           .contentType(MediaType.APPLICATION_JSON))\n+                                              .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutLastNameProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(true);\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                     .param(\"token\", newRegisterToken)\n+                                     .content(mapper.writeValueAsBytes(ePersonRest))\n+                                     .contentType(MediaType.APPLICATION_JSON))\n+                        .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutFirstNameProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(true);\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                     .param(\"token\", newRegisterToken)\n+                                     .content(mapper.writeValueAsBytes(ePersonRest))\n+                                     .contentType(MediaType.APPLICATION_JSON))\n+                        .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutPasswordProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                     .param(\"token\", newRegisterToken)\n+                                     .content(mapper.writeValueAsBytes(ePersonRest))\n+                                     .contentType(MediaType.APPLICATION_JSON))\n+                        .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void postEPersonWithWrongToken() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String newEmail = \"new-email@fake-email.com\";\n+\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(eperson.getEmail());\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String forgotPasswordToken = registrationDataService.findByEmail(context, eperson.getEmail()).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(true);\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                     .param(\"token\", forgotPasswordToken)\n+                                     .content(mapper.writeValueAsBytes(ePersonRest))\n+                                     .contentType(MediaType.APPLICATION_JSON))\n+                        .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, forgotPasswordToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, forgotPasswordToken);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailPropertyAnonUser() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                                               .param(\"token\", newRegisterToken)\n+                                                               .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                               .contentType(MediaType.APPLICATION_JSON))\n+                                                  .andExpect(status().isCreated())\n+                                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                      hasJsonPath(\"$.uuid\", not(empty())),\n+                                                      // is it what you expect? EPerson.getName() returns the email...\n+                                                      //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                      hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                      hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                      hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                      hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                          matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                          matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                      ))))).andDo(result -> idRef\n+                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32a03eed36a9fbe08e44d0bc6a945a4b5853a8d6"}, "originalPosition": 894}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMjI4OQ==", "bodyText": "put in a finally block", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445732289", "createdAt": "2020-06-25T17:47:21Z", "author": {"login": "abollini"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/RegistrationRestRepositoryIT.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.app.rest.matcher.RegistrationMatcher;\n+import org.dspace.app.rest.model.RegistrationRest;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.eperson.RegistrationData;\n+import org.dspace.eperson.dao.RegistrationDataDAO;\n+import org.dspace.services.ConfigurationService;\n+import org.hamcrest.Matchers;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+public class RegistrationRestRepositoryIT extends AbstractControllerIntegrationTest {\n+\n+    @Autowired\n+    private RegistrationDataDAO registrationDataDAO;\n+\n+    @Autowired\n+    private ConfigurationService configurationService;\n+\n+    @Test\n+    public void findByTokenTestExistingUserTest() throws Exception {\n+        String email = eperson.getEmail();\n+        createTokenForEmail(email);\n+        RegistrationData registrationData = registrationDataDAO.findByEmail(context, email);\n+\n+        getClient().perform(get(\"/api/eperson/registrations/search/findByToken\")\n+                                .param(\"token\", registrationData.getToken()))\n+                   .andExpect(status().isOk())\n+                   .andExpect(\n+                       jsonPath(\"$\", Matchers.is(RegistrationMatcher.matchRegistration(email, eperson.getID()))));\n+\n+        registrationDataDAO.delete(context, registrationData);\n+\n+        email = \"newUser@testnewuser.com\";\n+        createTokenForEmail(email);\n+        registrationData = registrationDataDAO.findByEmail(context, email);\n+\n+        getClient().perform(get(\"/api/eperson/registrations/search/findByToken\")\n+                                .param(\"token\", registrationData.getToken()))\n+                   .andExpect(status().isOk())\n+                   .andExpect(\n+                       jsonPath(\"$\", Matchers.is(RegistrationMatcher.matchRegistration(email, null))));\n+\n+        registrationDataDAO.delete(context, registrationData);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32a03eed36a9fbe08e44d0bc6a945a4b5853a8d6"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMjMzNw==", "bodyText": "put in a finally block", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445732337", "createdAt": "2020-06-25T17:47:26Z", "author": {"login": "abollini"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/RegistrationRestRepositoryIT.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.app.rest.matcher.RegistrationMatcher;\n+import org.dspace.app.rest.model.RegistrationRest;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.eperson.RegistrationData;\n+import org.dspace.eperson.dao.RegistrationDataDAO;\n+import org.dspace.services.ConfigurationService;\n+import org.hamcrest.Matchers;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+public class RegistrationRestRepositoryIT extends AbstractControllerIntegrationTest {\n+\n+    @Autowired\n+    private RegistrationDataDAO registrationDataDAO;\n+\n+    @Autowired\n+    private ConfigurationService configurationService;\n+\n+    @Test\n+    public void findByTokenTestExistingUserTest() throws Exception {\n+        String email = eperson.getEmail();\n+        createTokenForEmail(email);\n+        RegistrationData registrationData = registrationDataDAO.findByEmail(context, email);\n+\n+        getClient().perform(get(\"/api/eperson/registrations/search/findByToken\")\n+                                .param(\"token\", registrationData.getToken()))\n+                   .andExpect(status().isOk())\n+                   .andExpect(\n+                       jsonPath(\"$\", Matchers.is(RegistrationMatcher.matchRegistration(email, eperson.getID()))));\n+\n+        registrationDataDAO.delete(context, registrationData);\n+\n+        email = \"newUser@testnewuser.com\";\n+        createTokenForEmail(email);\n+        registrationData = registrationDataDAO.findByEmail(context, email);\n+\n+        getClient().perform(get(\"/api/eperson/registrations/search/findByToken\")\n+                                .param(\"token\", registrationData.getToken()))\n+                   .andExpect(status().isOk())\n+                   .andExpect(\n+                       jsonPath(\"$\", Matchers.is(RegistrationMatcher.matchRegistration(email, null))));\n+\n+        registrationDataDAO.delete(context, registrationData);\n+\n+    }\n+\n+    @Test\n+    public void findByTokenTestNewUserTest() throws Exception {\n+        String email = \"newUser@testnewuser.com\";\n+        createTokenForEmail(email);\n+        RegistrationData registrationData = registrationDataDAO.findByEmail(context, email);\n+\n+        getClient().perform(get(\"/api/eperson/registrations/search/findByToken\")\n+                                .param(\"token\", registrationData.getToken()))\n+                   .andExpect(status().isOk())\n+                   .andExpect(\n+                       jsonPath(\"$\", Matchers.is(RegistrationMatcher.matchRegistration(email, null))));\n+\n+        registrationDataDAO.delete(context, registrationData);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32a03eed36a9fbe08e44d0bc6a945a4b5853a8d6"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMjYxOA==", "bodyText": "yes I agree with @benbosman", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445732618", "createdAt": "2020-06-25T17:47:59Z", "author": {"login": "abollini"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/RegistrationRestRepositoryIT.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.util.List;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.dspace.app.rest.matcher.RegistrationMatcher;\n+import org.dspace.app.rest.model.RegistrationRest;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.eperson.RegistrationData;\n+import org.dspace.eperson.dao.RegistrationDataDAO;\n+import org.hamcrest.Matchers;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+public class RegistrationRestRepositoryIT extends AbstractControllerIntegrationTest {\n+\n+    @Autowired\n+    private RegistrationDataDAO registrationDataDAO;\n+\n+    @Test\n+    public void findByTokenTestExistingUserTest() throws Exception {\n+        String email = eperson.getEmail();\n+        createTokenForEmail(email);\n+        RegistrationData registrationData = registrationDataDAO.findByEmail(context, email);\n+\n+        getClient().perform(get(\"/api/eperson/registrations/search/findByToken\")\n+                                .param(\"token\", registrationData.getToken()))\n+                   .andExpect(status().isOk())\n+                   .andExpect(\n+                       jsonPath(\"$\", Matchers.is(RegistrationMatcher.matchRegistration(email, eperson.getID()))));\n+\n+        email = \"newUser@testnewuser.com\";\n+        createTokenForEmail(email);\n+        registrationData = registrationDataDAO.findByEmail(context, email);\n+\n+        getClient().perform(get(\"/api/eperson/registrations/search/findByToken\")\n+                                .param(\"token\", registrationData.getToken()))\n+                   .andExpect(status().isOk())\n+                   .andExpect(\n+                       jsonPath(\"$\", Matchers.is(RegistrationMatcher.matchRegistration(email, null))));\n+\n+        registrationDataDAO.delete(context, registrationData);\n+\n+    }\n+\n+    @Test\n+    public void findByTokenTestNewUserTest() throws Exception {\n+        String email = \"newUser@testnewuser.com\";\n+        createTokenForEmail(email);\n+        RegistrationData registrationData = registrationDataDAO.findByEmail(context, email);\n+\n+        getClient().perform(get(\"/api/eperson/registrations/search/findByToken\")\n+                                .param(\"token\", registrationData.getToken()))\n+                   .andExpect(status().isOk())\n+                   .andExpect(\n+                       jsonPath(\"$\", Matchers.is(RegistrationMatcher.matchRegistration(email, null))));\n+\n+        registrationDataDAO.delete(context, registrationData);\n+    }\n+\n+    @Test\n+    public void findByTokenNotExistingTokenTest() throws Exception {\n+        getClient().perform(get(\"/api/eperson/registration/search/findByToken\")\n+                                .param(\"token\", \"ThisTokenDoesNotExist\"))\n+                   .andExpect(status().isNotFound());\n+    }\n+\n+    private void createTokenForEmail(String email) throws Exception {\n+        List<RegistrationData> registrationDatas;\n+        ObjectMapper mapper = new ObjectMapper();\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(email);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .content(mapper.writeValueAsBytes(registrationRest))\n+                                .contentType(contentType))\n+                   .andExpect(status().isCreated());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY0MTI3Nw=="}, "originalCommit": {"oid": "891ab3f3e261e8a78321091b8835fab413937899"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMjc4NA==", "bodyText": "put in a finally block", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445732784", "createdAt": "2020-06-25T17:48:20Z", "author": {"login": "abollini"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/RegistrationRestRepositoryIT.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.app.rest.matcher.RegistrationMatcher;\n+import org.dspace.app.rest.model.RegistrationRest;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.eperson.RegistrationData;\n+import org.dspace.eperson.dao.RegistrationDataDAO;\n+import org.dspace.services.ConfigurationService;\n+import org.hamcrest.Matchers;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+public class RegistrationRestRepositoryIT extends AbstractControllerIntegrationTest {\n+\n+    @Autowired\n+    private RegistrationDataDAO registrationDataDAO;\n+\n+    @Autowired\n+    private ConfigurationService configurationService;\n+\n+    @Test\n+    public void findByTokenTestExistingUserTest() throws Exception {\n+        String email = eperson.getEmail();\n+        createTokenForEmail(email);\n+        RegistrationData registrationData = registrationDataDAO.findByEmail(context, email);\n+\n+        getClient().perform(get(\"/api/eperson/registrations/search/findByToken\")\n+                                .param(\"token\", registrationData.getToken()))\n+                   .andExpect(status().isOk())\n+                   .andExpect(\n+                       jsonPath(\"$\", Matchers.is(RegistrationMatcher.matchRegistration(email, eperson.getID()))));\n+\n+        registrationDataDAO.delete(context, registrationData);\n+\n+        email = \"newUser@testnewuser.com\";\n+        createTokenForEmail(email);\n+        registrationData = registrationDataDAO.findByEmail(context, email);\n+\n+        getClient().perform(get(\"/api/eperson/registrations/search/findByToken\")\n+                                .param(\"token\", registrationData.getToken()))\n+                   .andExpect(status().isOk())\n+                   .andExpect(\n+                       jsonPath(\"$\", Matchers.is(RegistrationMatcher.matchRegistration(email, null))));\n+\n+        registrationDataDAO.delete(context, registrationData);\n+\n+    }\n+\n+    @Test\n+    public void findByTokenTestNewUserTest() throws Exception {\n+        String email = \"newUser@testnewuser.com\";\n+        createTokenForEmail(email);\n+        RegistrationData registrationData = registrationDataDAO.findByEmail(context, email);\n+\n+        getClient().perform(get(\"/api/eperson/registrations/search/findByToken\")\n+                                .param(\"token\", registrationData.getToken()))\n+                   .andExpect(status().isOk())\n+                   .andExpect(\n+                       jsonPath(\"$\", Matchers.is(RegistrationMatcher.matchRegistration(email, null))));\n+\n+        registrationDataDAO.delete(context, registrationData);\n+    }\n+\n+    @Test\n+    public void findByTokenNotExistingTokenTest() throws Exception {\n+        getClient().perform(get(\"/api/eperson/registration/search/findByToken\")\n+                                .param(\"token\", \"ThisTokenDoesNotExist\"))\n+                   .andExpect(status().isNotFound());\n+    }\n+\n+    private void createTokenForEmail(String email) throws Exception {\n+        List<RegistrationData> registrationDatas;\n+        ObjectMapper mapper = new ObjectMapper();\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(email);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .content(mapper.writeValueAsBytes(registrationRest))\n+                                .contentType(contentType))\n+                   .andExpect(status().isCreated());\n+    }\n+\n+    @Test\n+    public void registrationFlowTest() throws Exception {\n+        List<RegistrationData> registrationDataList = registrationDataDAO.findAll(context, RegistrationData.class);\n+        assertEquals(0, registrationDataList.size());\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(eperson.getEmail());\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .content(mapper.writeValueAsBytes(registrationRest))\n+                                .contentType(contentType))\n+                   .andExpect(status().isCreated());\n+        registrationDataList = registrationDataDAO.findAll(context, RegistrationData.class);\n+        assertEquals(1, registrationDataList.size());\n+        assertTrue(StringUtils.equalsIgnoreCase(registrationDataList.get(0).getEmail(), eperson.getEmail()));\n+\n+        String newEmail = \"newEPersonTest@gmail.com\";\n+        registrationRest.setEmail(newEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .content(mapper.writeValueAsBytes(registrationRest))\n+                                .contentType(contentType))\n+                   .andExpect(status().isCreated());\n+        registrationDataList = registrationDataDAO.findAll(context, RegistrationData.class);\n+        assertTrue(registrationDataList.size() == 2);\n+        assertTrue(StringUtils.equalsIgnoreCase(registrationDataList.get(0).getEmail(), newEmail) ||\n+                       StringUtils.equalsIgnoreCase(registrationDataList.get(1).getEmail(), newEmail));\n+        configurationService.setProperty(\"user.registration\", false);\n+\n+        newEmail = \"newEPersonTestTwo@gmail.com\";\n+        registrationRest.setEmail(newEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .content(mapper.writeValueAsBytes(registrationRest))\n+                                .contentType(contentType))\n+                   .andExpect(status().is(401));\n+\n+        assertEquals(2, registrationDataList.size());\n+        assertTrue(!StringUtils.equalsIgnoreCase(registrationDataList.get(0).getEmail(), newEmail) &&\n+                       !StringUtils.equalsIgnoreCase(registrationDataList.get(1).getEmail(), newEmail));\n+\n+        Iterator<RegistrationData> iterator = registrationDataList.iterator();\n+        while (iterator.hasNext()) {\n+            RegistrationData registrationData = iterator.next();\n+            registrationDataDAO.delete(context, registrationData);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32a03eed36a9fbe08e44d0bc6a945a4b5853a8d6"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMjkwNg==", "bodyText": "put in a finally block", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445732906", "createdAt": "2020-06-25T17:48:33Z", "author": {"login": "abollini"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/RegistrationRestRepositoryIT.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.app.rest.matcher.RegistrationMatcher;\n+import org.dspace.app.rest.model.RegistrationRest;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.eperson.RegistrationData;\n+import org.dspace.eperson.dao.RegistrationDataDAO;\n+import org.dspace.services.ConfigurationService;\n+import org.hamcrest.Matchers;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+public class RegistrationRestRepositoryIT extends AbstractControllerIntegrationTest {\n+\n+    @Autowired\n+    private RegistrationDataDAO registrationDataDAO;\n+\n+    @Autowired\n+    private ConfigurationService configurationService;\n+\n+    @Test\n+    public void findByTokenTestExistingUserTest() throws Exception {\n+        String email = eperson.getEmail();\n+        createTokenForEmail(email);\n+        RegistrationData registrationData = registrationDataDAO.findByEmail(context, email);\n+\n+        getClient().perform(get(\"/api/eperson/registrations/search/findByToken\")\n+                                .param(\"token\", registrationData.getToken()))\n+                   .andExpect(status().isOk())\n+                   .andExpect(\n+                       jsonPath(\"$\", Matchers.is(RegistrationMatcher.matchRegistration(email, eperson.getID()))));\n+\n+        registrationDataDAO.delete(context, registrationData);\n+\n+        email = \"newUser@testnewuser.com\";\n+        createTokenForEmail(email);\n+        registrationData = registrationDataDAO.findByEmail(context, email);\n+\n+        getClient().perform(get(\"/api/eperson/registrations/search/findByToken\")\n+                                .param(\"token\", registrationData.getToken()))\n+                   .andExpect(status().isOk())\n+                   .andExpect(\n+                       jsonPath(\"$\", Matchers.is(RegistrationMatcher.matchRegistration(email, null))));\n+\n+        registrationDataDAO.delete(context, registrationData);\n+\n+    }\n+\n+    @Test\n+    public void findByTokenTestNewUserTest() throws Exception {\n+        String email = \"newUser@testnewuser.com\";\n+        createTokenForEmail(email);\n+        RegistrationData registrationData = registrationDataDAO.findByEmail(context, email);\n+\n+        getClient().perform(get(\"/api/eperson/registrations/search/findByToken\")\n+                                .param(\"token\", registrationData.getToken()))\n+                   .andExpect(status().isOk())\n+                   .andExpect(\n+                       jsonPath(\"$\", Matchers.is(RegistrationMatcher.matchRegistration(email, null))));\n+\n+        registrationDataDAO.delete(context, registrationData);\n+    }\n+\n+    @Test\n+    public void findByTokenNotExistingTokenTest() throws Exception {\n+        getClient().perform(get(\"/api/eperson/registration/search/findByToken\")\n+                                .param(\"token\", \"ThisTokenDoesNotExist\"))\n+                   .andExpect(status().isNotFound());\n+    }\n+\n+    private void createTokenForEmail(String email) throws Exception {\n+        List<RegistrationData> registrationDatas;\n+        ObjectMapper mapper = new ObjectMapper();\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(email);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .content(mapper.writeValueAsBytes(registrationRest))\n+                                .contentType(contentType))\n+                   .andExpect(status().isCreated());\n+    }\n+\n+    @Test\n+    public void registrationFlowTest() throws Exception {\n+        List<RegistrationData> registrationDataList = registrationDataDAO.findAll(context, RegistrationData.class);\n+        assertEquals(0, registrationDataList.size());\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(eperson.getEmail());\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .content(mapper.writeValueAsBytes(registrationRest))\n+                                .contentType(contentType))\n+                   .andExpect(status().isCreated());\n+        registrationDataList = registrationDataDAO.findAll(context, RegistrationData.class);\n+        assertEquals(1, registrationDataList.size());\n+        assertTrue(StringUtils.equalsIgnoreCase(registrationDataList.get(0).getEmail(), eperson.getEmail()));\n+\n+        String newEmail = \"newEPersonTest@gmail.com\";\n+        registrationRest.setEmail(newEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .content(mapper.writeValueAsBytes(registrationRest))\n+                                .contentType(contentType))\n+                   .andExpect(status().isCreated());\n+        registrationDataList = registrationDataDAO.findAll(context, RegistrationData.class);\n+        assertTrue(registrationDataList.size() == 2);\n+        assertTrue(StringUtils.equalsIgnoreCase(registrationDataList.get(0).getEmail(), newEmail) ||\n+                       StringUtils.equalsIgnoreCase(registrationDataList.get(1).getEmail(), newEmail));\n+        configurationService.setProperty(\"user.registration\", false);\n+\n+        newEmail = \"newEPersonTestTwo@gmail.com\";\n+        registrationRest.setEmail(newEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .content(mapper.writeValueAsBytes(registrationRest))\n+                                .contentType(contentType))\n+                   .andExpect(status().is(401));\n+\n+        assertEquals(2, registrationDataList.size());\n+        assertTrue(!StringUtils.equalsIgnoreCase(registrationDataList.get(0).getEmail(), newEmail) &&\n+                       !StringUtils.equalsIgnoreCase(registrationDataList.get(1).getEmail(), newEmail));\n+\n+        Iterator<RegistrationData> iterator = registrationDataList.iterator();\n+        while (iterator.hasNext()) {\n+            RegistrationData registrationData = iterator.next();\n+            registrationDataDAO.delete(context, registrationData);\n+        }\n+    }\n+\n+    @Test\n+    public void forgotPasswordTest() throws Exception {\n+        configurationService.setProperty(\"user.registration\", false);\n+\n+        List<RegistrationData> registrationDataList = registrationDataDAO.findAll(context, RegistrationData.class);\n+        assertEquals(0, registrationDataList.size());\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(eperson.getEmail());\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .content(mapper.writeValueAsBytes(registrationRest))\n+                                .contentType(contentType))\n+                   .andExpect(status().isCreated());\n+        registrationDataList = registrationDataDAO.findAll(context, RegistrationData.class);\n+        assertEquals(1, registrationDataList.size());\n+        assertTrue(StringUtils.equalsIgnoreCase(registrationDataList.get(0).getEmail(), eperson.getEmail()));\n+        Iterator<RegistrationData> iterator = registrationDataList.iterator();\n+        while (iterator.hasNext()) {\n+            RegistrationData registrationData = iterator.next();\n+            registrationDataDAO.delete(context, registrationData);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32a03eed36a9fbe08e44d0bc6a945a4b5853a8d6"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczNDQzNA==", "bodyText": "I don't think that this is sufficient to get shibboleth enabled as the plugins were already read and so cached", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445734434", "createdAt": "2020-06-25T17:51:13Z", "author": {"login": "abollini"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/authorization/EPersonRegistrationFeatureIT.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.authorization;\n+\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import org.dspace.app.rest.authorization.impl.EPersonRegistrationFeature;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.converter.SiteConverter;\n+import org.dspace.app.rest.model.SiteRest;\n+import org.dspace.app.rest.projection.Projection;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.content.Site;\n+import org.dspace.content.service.SiteService;\n+import org.dspace.services.ConfigurationService;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+public class EPersonRegistrationFeatureIT extends AbstractControllerIntegrationTest {\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private ConverterService converterService;\n+\n+    @Autowired\n+    private ConfigurationService configurationService;\n+\n+    @Autowired\n+    private SiteService siteService;\n+\n+    @Autowired\n+    private SiteConverter siteConverter;\n+\n+    @Autowired\n+    private Utils utils;\n+\n+    private AuthorizationFeature epersonRegistrationFeature;\n+\n+    public static final String[] SHIB_ONLY = {\"org.dspace.authenticate.ShibAuthentication\"};\n+\n+    @Override\n+    @Before\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        epersonRegistrationFeature = authorizationFeatureService.find(EPersonRegistrationFeature.NAME);\n+    }\n+\n+    @Test\n+    public void userRegistrationEnabledSuccessTest() throws Exception {\n+\n+        Site site = siteService.findSite(context);\n+        SiteRest SiteRest = siteConverter.convert(site, Projection.DEFAULT);\n+        String siteUri = utils.linkToSingleResource(SiteRest, \"self\").getHref();\n+\n+\n+        getClient().perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                                          .param(\"uri\", siteUri)\n+                                          .param(\"feature\", epersonRegistrationFeature.getName()))\n+                             .andExpect(status().isOk());\n+    }\n+\n+    @Test\n+    public void userRegistrationDisabledUnAuthorizedTest() throws Exception {\n+\n+        Site site = siteService.findSite(context);\n+        SiteRest SiteRest = siteConverter.convert(site, Projection.DEFAULT);\n+        String siteUri = utils.linkToSingleResource(SiteRest, \"self\").getHref();\n+\n+        configurationService.setProperty(\"user.registration\", false);\n+\n+        getClient().perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                                          .param(\"uri\", siteUri)\n+                                          .param(\"feature\", epersonRegistrationFeature.getName()))\n+                             .andExpect(status().isNoContent());\n+\n+    }\n+\n+\n+    @Test\n+    public void userRegistrationEnabledShibTest() throws Exception {\n+\n+        Site site = siteService.findSite(context);\n+        SiteRest SiteRest = siteConverter.convert(site, Projection.DEFAULT);\n+        String siteUri = utils.linkToSingleResource(SiteRest, \"self\").getHref();\n+\n+\n+        getClient().perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                                          .param(\"uri\", siteUri)\n+                                          .param(\"feature\", epersonRegistrationFeature.getName()))\n+                             .andExpect(status().isOk());\n+\n+        //Enable Shibboleth and password login\n+        configurationService.setProperty(\"plugin.sequence.org.dspace.authenticate.AuthenticationMethod\", SHIB_ONLY);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32a03eed36a9fbe08e44d0bc6a945a4b5853a8d6"}, "originalPosition": 103}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4NjA4Nzg5", "url": "https://github.com/DSpace/DSpace/pull/2763#pullrequestreview-438608789", "createdAt": "2020-06-26T21:34:53Z", "commit": {"oid": "32a03eed36a9fbe08e44d0bc6a945a4b5853a8d6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0555644c9a8d1c15bbe71afb13068ba632eb6f9d", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/0555644c9a8d1c15bbe71afb13068ba632eb6f9d", "committedDate": "2020-06-30T06:30:01Z", "message": "[Task 71627] addressed feedback on the new registration functionaliity"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a6731297cc8c7c7f1387cf214800e42a9672071", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/2a6731297cc8c7c7f1387cf214800e42a9672071", "committedDate": "2020-06-30T08:27:47Z", "message": "Fixed LGTM issue with an error String"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwMTMwNTQy", "url": "https://github.com/DSpace/DSpace/pull/2763#pullrequestreview-440130542", "createdAt": "2020-06-30T15:24:44Z", "commit": {"oid": "2a6731297cc8c7c7f1387cf214800e42a9672071"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1463, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}