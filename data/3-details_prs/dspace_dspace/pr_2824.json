{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQzNzg4MDc5", "number": 2824, "title": "DS-4515 - Start new submission via Search or ID Lookup (using Live Import)", "bodyText": "References\n\nhttps://jira.lyrasis.org/browse/DS-4515\nFixes #2790\nhttps://wiki.lyrasis.org/display/DSPACE/BTE+transition%3A+4Science+implementation+proposal+and+estimation\n\nDescription\nThis PR move ArXiv external provider searches from BTE to Live Import architecture.\nThere are no changes to the rest contract nor to the interfaces.\nInstructions for Reviewers\nAccording to the policy for remote resources, no tests are available. We like to add test once that the #2791 is merged so to benefit of the refactor of the pubmed/arxiv importer also in a file importer making easier to mock the remote response. To verify the implementation, you can call the APIs in the same way as before addressing the new providers (arxiv or pubmed).\nEg.:\nSearch by query:\ncurl --location --request GET '{{server_url}}/api/integration/externalsources/arxiv/entries?query=all'\n\nSearch by id:\ncurl --location --request GET '{{server_url}}/api/integration/externalsources/arxiv/entryValues/{{id}}'\n\nList of changes in this PR:\n\nReplace ArXiv BTE implementation which one based on Live Import\nRemove all dead code for ArXiv and Pubmed implementations based on BTE\n\nChecklist\nThis checklist provides a reminder of what we are going to look for when reviewing your PR. You need not complete this checklist prior to creating your PR (draft PRs are always welcome). If you are unsure about an item in the checklist, don't hesitate to ask. We're here to help!\n\n My PR is small in size (e.g. less than 1,000 lines of code, not including comments & integration tests). Exceptions may be made if previously agreed upon.\n My PR passes Checkstyle validation based on the Code Style Guide.\n My PR includes Javadoc for all new (or modified) public methods and classes. It also includes Javadoc for large or complex private methods.\n My PR passes all tests and includes new/updated Unit or Integration Tests based on the Code Testing Guide.\n[] If my PR includes new, third-party dependencies (in any pom.xml), I've made sure their licenses align with the DSpace BSD License based on the Licensing of Contributions documentation.\n If my PR modifies the REST API, I've linked to the REST Contract page (or open PR) related to this change.", "createdAt": "2020-07-02T23:54:48Z", "url": "https://github.com/DSpace/DSpace/pull/2824", "merged": true, "mergeCommit": {"oid": "4c8c1496b5b1051f1af3cafa3e503cf3f96cfe35"}, "closed": true, "closedAt": "2020-09-04T14:47:51Z", "author": {"login": "pasqualecvl"}, "timelineItems": {"totalCount": 40, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABctKi-yAH2gAyNDQzNzg4MDc5OjVjOGZmMmM3NDMxMmM1Yzk3YTE0YzAxZTJlZmE0ZDg1MjFjMWMxY2I=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdFgpp5gFqTQ4MjQ0NzQ4OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "5c8ff2c74312c5c97a14c01e2efa4d8521c1c1cb", "author": {"user": {"login": "abollini", "name": "Andrea Bollini"}}, "url": "https://github.com/DSpace/DSpace/commit/5c8ff2c74312c5c97a14c01e2efa4d8521c1c1cb", "committedDate": "2020-06-20T16:49:56Z", "message": "DS-4530 enforce the use of the latest override of the findOne when checking permission for embedding"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f50d0d664832142525d68ed22ae4e5ec935d9770", "author": {"user": {"login": "abollini", "name": "Andrea Bollini"}}, "url": "https://github.com/DSpace/DSpace/commit/f50d0d664832142525d68ed22ae4e5ec935d9770", "committedDate": "2020-06-20T16:50:36Z", "message": "Add dependency needed by the pubmed live import provider"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "38c566723384729f1e97ab0b7687d6696bb79180", "author": {"user": {"login": "abollini", "name": "Andrea Bollini"}}, "url": "https://github.com/DSpace/DSpace/commit/38c566723384729f1e97ab0b7687d6696bb79180", "committedDate": "2020-06-20T16:52:23Z", "message": "DS-4515 enable live import provider as external authority"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bd2cf94376e5560559d838c04d74cd0817c654a4", "author": {"user": {"login": "abollini", "name": "Andrea Bollini"}}, "url": "https://github.com/DSpace/DSpace/commit/bd2cf94376e5560559d838c04d74cd0817c654a4", "committedDate": "2020-06-20T16:52:45Z", "message": "DS-4529 External authorities endpoint doesn't support the pagination"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f3844e63a4dfff1eae7c8e6901741fa49e88b09d", "author": {"user": {"login": "Micheleboychuk", "name": "Mykhaylo Boychuk"}}, "url": "https://github.com/DSpace/DSpace/commit/f3844e63a4dfff1eae7c8e6901741fa49e88b09d", "committedDate": "2020-06-24T15:01:03Z", "message": "Merge branch 'master' into DS-4515_submit-external-source"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "808c4633f159246543b79c723f3617e06c70c0db", "author": {"user": {"login": "pasqualecvl", "name": "Pasquale Cavallo"}}, "url": "https://github.com/DSpace/DSpace/commit/808c4633f159246543b79c723f3617e06c70c0db", "committedDate": "2020-07-01T08:36:43Z", "message": "submit external suorce partial implementation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "238317bc8df250130af162de845623702b43cd81", "author": {"user": {"login": "pasqualecvl", "name": "Pasquale Cavallo"}}, "url": "https://github.com/DSpace/DSpace/commit/238317bc8df250130af162de845623702b43cd81", "committedDate": "2020-07-01T14:50:45Z", "message": "Arxiv Live import integration"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b15fa7c5b0c381dd05d6493d0b5dd3e08a402c02", "author": {"user": {"login": "pasqualecvl", "name": "Pasquale Cavallo"}}, "url": "https://github.com/DSpace/DSpace/commit/b15fa7c5b0c381dd05d6493d0b5dd3e08a402c02", "committedDate": "2020-07-02T00:32:11Z", "message": "show ids and links in response"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f71866b5e300453aec669e24ea087204d93ff90c", "author": {"user": {"login": "pasqualecvl", "name": "Pasquale Cavallo"}}, "url": "https://github.com/DSpace/DSpace/commit/f71866b5e300453aec669e24ea087204d93ff90c", "committedDate": "2020-07-02T08:30:49Z", "message": "Add comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "03ac31dc109d733917c94f1bf1cb8d26a6f14bcf", "author": {"user": {"login": "pasqualecvl", "name": "Pasquale Cavallo"}}, "url": "https://github.com/DSpace/DSpace/commit/03ac31dc109d733917c94f1bf1cb8d26a6f14bcf", "committedDate": "2020-07-02T10:05:50Z", "message": "Exception handling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "02953eb087c931dba77fd84d3e6ba788464b4458", "author": {"user": {"login": "pasqualecvl", "name": "Pasquale Cavallo"}}, "url": "https://github.com/DSpace/DSpace/commit/02953eb087c931dba77fd84d3e6ba788464b4458", "committedDate": "2020-07-02T12:45:04Z", "message": "Update comment and minor fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dbde82478b052371bfc1b3780a622797b3ebf333", "author": {"user": {"login": "pasqualecvl", "name": "Pasquale Cavallo"}}, "url": "https://github.com/DSpace/DSpace/commit/dbde82478b052371bfc1b3780a622797b3ebf333", "committedDate": "2020-07-02T14:22:36Z", "message": "remove unused code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af38c36bdb094d91f934565d79bab66e29679363", "author": {"user": {"login": "pasqualecvl", "name": "Pasquale Cavallo"}}, "url": "https://github.com/DSpace/DSpace/commit/af38c36bdb094d91f934565d79bab66e29679363", "committedDate": "2020-07-06T09:33:52Z", "message": "add JavaDoc to LiveImportDataProvider public method"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5NjY5NTIy", "url": "https://github.com/DSpace/DSpace/pull/2824#pullrequestreview-449669522", "createdAt": "2020-07-16T09:18:37Z", "commit": {"oid": "af38c36bdb094d91f934565d79bab66e29679363"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwOToxODozN1rOGyiaBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwOToyNToxNVrOGyirKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY0NTcwMA==", "bodyText": "Since this is a new method compared to the SimpleXpathMetadatumContributor, can add some docs explaining what it does?", "url": "https://github.com/DSpace/DSpace/pull/2824#discussion_r455645700", "createdAt": "2020-07-16T09:18:37Z", "author": {"login": "benbosman"}, "path": "dspace-api/src/main/java/org/dspace/importer/external/arxiv/metadatamapping/contributor/ArXivIdMetadataContributor.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.importer.external.arxiv.metadatamapping.contributor;\n+\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Resource;\n+\n+import org.apache.axiom.om.OMAttribute;\n+import org.apache.axiom.om.OMElement;\n+import org.apache.axiom.om.OMText;\n+import org.apache.axiom.om.xpath.AXIOMXPath;\n+import org.dspace.importer.external.metadatamapping.MetadataFieldConfig;\n+import org.dspace.importer.external.metadatamapping.MetadataFieldMapping;\n+import org.dspace.importer.external.metadatamapping.MetadatumDTO;\n+import org.dspace.importer.external.metadatamapping.contributor.MetadataContributor;\n+import org.jaxen.JaxenException;\n+import org.springframework.beans.factory.annotation.Required;\n+\n+/**\n+ * Arxiv specific implementation of {@link MetadataContributor}\n+ * Responsible for generating the ArXiv Id from the retrieved item.\n+ * \n+ * @author Pasquale Cavallo (pasquale.cavallo at 4science dot it)\n+ *\n+ */\n+public class ArXivIdMetadataContributor implements MetadataContributor<OMElement> {\n+    private MetadataFieldConfig field;\n+\n+    /**\n+     * Return prefixToNamespaceMapping\n+     *\n+     * @return a prefixToNamespaceMapping map\n+     */\n+    public Map<String, String> getPrefixToNamespaceMapping() {\n+        return prefixToNamespaceMapping;\n+    }\n+\n+    private MetadataFieldMapping<OMElement, MetadataContributor<OMElement>> metadataFieldMapping;\n+\n+    /**\n+     * Return metadataFieldMapping\n+     *\n+     * @return MetadataFieldMapping\n+     */\n+    public MetadataFieldMapping<OMElement, MetadataContributor<OMElement>> getMetadataFieldMapping() {\n+        return metadataFieldMapping;\n+    }\n+\n+    /**\n+     * Set the metadataFieldMapping of this ArXivIdMetadataContributor\n+     *\n+     * @param metadataFieldMapping the new mapping.\n+     */\n+    public void setMetadataFieldMapping(\n+        MetadataFieldMapping<OMElement, MetadataContributor<OMElement>> metadataFieldMapping) {\n+        this.metadataFieldMapping = metadataFieldMapping;\n+    }\n+\n+    /**\n+     * Set the prefixToNamespaceMapping for this object,\n+     *\n+     * @param prefixToNamespaceMapping the new mapping.\n+     */\n+    @Resource(name = \"isiFullprefixMapping\")\n+    public void setPrefixToNamespaceMapping(Map<String, String> prefixToNamespaceMapping) {\n+        this.prefixToNamespaceMapping = prefixToNamespaceMapping;\n+    }\n+\n+    private Map<String, String> prefixToNamespaceMapping;\n+\n+    /**\n+     * Initialize ArXivIdMetadataContributor with a query, prefixToNamespaceMapping and MetadataFieldConfig\n+     *\n+     * @param query                    query string\n+     * @param prefixToNamespaceMapping metadata prefix to namespace mapping\n+     * @param field\n+     * <a href=\"https://github.com/DSpace/DSpace/tree/master/dspace-api/src/main/java/org/dspace/importer/external#metadata-mapping-\">MetadataFieldConfig</a>\n+     */\n+    public ArXivIdMetadataContributor(String query, Map<String, String> prefixToNamespaceMapping,\n+                                           MetadataFieldConfig field) {\n+        this.query = query;\n+        this.prefixToNamespaceMapping = prefixToNamespaceMapping;\n+        this.field = field;\n+    }\n+\n+    /**\n+     * Empty constructor for ArXivIdMetadataContributor\n+     */\n+    public ArXivIdMetadataContributor() {\n+\n+    }\n+\n+    private String query;\n+\n+    /**\n+     * Return the MetadataFieldConfig used while retrieving MetadatumDTO\n+     *\n+     * @return MetadataFieldConfig\n+     */\n+    public MetadataFieldConfig getField() {\n+        return field;\n+    }\n+\n+    /**\n+     * Setting the MetadataFieldConfig\n+     *\n+     * @param field MetadataFieldConfig used while retrieving MetadatumDTO\n+     */\n+    @Required\n+    public void setField(MetadataFieldConfig field) {\n+        this.field = field;\n+    }\n+\n+    /**\n+     * Return query used to create an xpathExpression on, this query is used to\n+     *\n+     * @return the query this instance is based on\n+     */\n+    public String getQuery() {\n+        return query;\n+    }\n+\n+    @Required\n+    public void setQuery(String query) {\n+        this.query = query;\n+    }\n+\n+    /**\n+     * Retrieve the metadata associated with the given object.\n+     * Depending on the retrieved node (using the query), different types of values will be added to the MetadatumDTO\n+     * list\n+     *\n+     * @param t A class to retrieve metadata from.\n+     * @return a collection of import records. Only the identifier of the found records may be put in the record.\n+     */\n+    @Override\n+    public Collection<MetadatumDTO> contributeMetadata(OMElement t) {\n+        List<MetadatumDTO> values = new LinkedList<>();\n+        try {\n+            AXIOMXPath xpath = new AXIOMXPath(query);\n+            for (String ns : prefixToNamespaceMapping.keySet()) {\n+                xpath.addNamespace(prefixToNamespaceMapping.get(ns), ns);\n+            }\n+            List<Object> nodes = xpath.selectNodes(t);\n+            for (Object el : nodes) {\n+                if (el instanceof OMElement) {\n+                    values.add(metadataFieldMapping.toDCValue(field, ((OMElement) el).getText()));\n+                } else if (el instanceof OMAttribute) {\n+                    values.add(metadataFieldMapping.toDCValue(field, ((OMAttribute) el).getAttributeValue()));\n+                } else if (el instanceof String) {\n+                    values.add(metadataFieldMapping.toDCValue(field, (String) el));\n+                } else if (el instanceof OMText) {\n+                    values.add(metadataFieldMapping.toDCValue(field, ((OMText) el).getText()));\n+                } else {\n+                    System.err.println(\"node of type: \" + el.getClass());\n+                }\n+            }\n+            parseValue(values);\n+            return values;\n+        } catch (JaxenException e) {\n+            System.err.println(query);\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private void parseValue(List<MetadatumDTO> dtos) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af38c36bdb094d91f934565d79bab66e29679363"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY0ODI3NA==", "bodyText": "why is this customization necessary?", "url": "https://github.com/DSpace/DSpace/pull/2824#discussion_r455648274", "createdAt": "2020-07-16T09:22:40Z", "author": {"login": "benbosman"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/converter/ConverterService.java", "diffHunk": "@@ -149,14 +149,29 @@ private Annotation getAnnotationForRestObject(BaseObjectRest restObject) {\n         DSpaceRestRepository repositoryToUse = utils\n             .getResourceRepositoryByCategoryAndModel(baseObjectRest.getCategory(), baseObjectRest.getType());\n         Annotation preAuthorize = null;\n+        int maxDepth = 0;\n         for (Method m : repositoryToUse.getClass().getMethods()) {\n             if (StringUtils.equalsIgnoreCase(m.getName(), \"findOne\")) {\n-                preAuthorize = AnnotationUtils.findAnnotation(m, PreAuthorize.class);\n+                int depth = howManySuperclass(m.getDeclaringClass());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af38c36bdb094d91f934565d79bab66e29679363"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY1MDA5MA==", "bodyText": "why is the total dropped?", "url": "https://github.com/DSpace/DSpace/pull/2824#discussion_r455650090", "createdAt": "2020-07-16T09:25:15Z", "author": {"login": "benbosman"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/ExternalSourceRestRepository.java", "diffHunk": "@@ -89,10 +89,10 @@ public ExternalSourceRest findOne(Context context, String externalSourceName) {\n     }\n \n     @Override\n+    @PreAuthorize(\"permitAll()\")\n     public Page<ExternalSourceRest> findAll(Context context, Pageable pageable) {\n         List<ExternalDataProvider> externalSources = externalDataService.getExternalDataProviders();\n-        return converter.toRestPage(externalSources, pageable, externalSources.size(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af38c36bdb094d91f934565d79bab66e29679363"}, "originalPosition": 7}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5Njg0Mzg1", "url": "https://github.com/DSpace/DSpace/pull/2824#pullrequestreview-449684385", "createdAt": "2020-07-16T09:38:03Z", "commit": {"oid": "af38c36bdb094d91f934565d79bab66e29679363"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwOTozODowM1rOGyjI2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwOTozODowM1rOGyjI2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY1NzY4OQ==", "bodyText": "Also just noticed this uses System.err.println, while log.error is preferred. This is also happening at https://github.com/DSpace/DSpace/blob/main/dspace-api/src/main/java/org/dspace/importer/external/metadatamapping/contributor/SimpleXpathMetadatumContributor.java#L160 which is why I didn't see it immediately. This should be a small change to improve\nThis also happens a few lines below", "url": "https://github.com/DSpace/DSpace/pull/2824#discussion_r455657689", "createdAt": "2020-07-16T09:38:03Z", "author": {"login": "benbosman"}, "path": "dspace-api/src/main/java/org/dspace/importer/external/arxiv/metadatamapping/contributor/ArXivIdMetadataContributor.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.importer.external.arxiv.metadatamapping.contributor;\n+\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Resource;\n+\n+import org.apache.axiom.om.OMAttribute;\n+import org.apache.axiom.om.OMElement;\n+import org.apache.axiom.om.OMText;\n+import org.apache.axiom.om.xpath.AXIOMXPath;\n+import org.dspace.importer.external.metadatamapping.MetadataFieldConfig;\n+import org.dspace.importer.external.metadatamapping.MetadataFieldMapping;\n+import org.dspace.importer.external.metadatamapping.MetadatumDTO;\n+import org.dspace.importer.external.metadatamapping.contributor.MetadataContributor;\n+import org.jaxen.JaxenException;\n+import org.springframework.beans.factory.annotation.Required;\n+\n+/**\n+ * Arxiv specific implementation of {@link MetadataContributor}\n+ * Responsible for generating the ArXiv Id from the retrieved item.\n+ * \n+ * @author Pasquale Cavallo (pasquale.cavallo at 4science dot it)\n+ *\n+ */\n+public class ArXivIdMetadataContributor implements MetadataContributor<OMElement> {\n+    private MetadataFieldConfig field;\n+\n+    /**\n+     * Return prefixToNamespaceMapping\n+     *\n+     * @return a prefixToNamespaceMapping map\n+     */\n+    public Map<String, String> getPrefixToNamespaceMapping() {\n+        return prefixToNamespaceMapping;\n+    }\n+\n+    private MetadataFieldMapping<OMElement, MetadataContributor<OMElement>> metadataFieldMapping;\n+\n+    /**\n+     * Return metadataFieldMapping\n+     *\n+     * @return MetadataFieldMapping\n+     */\n+    public MetadataFieldMapping<OMElement, MetadataContributor<OMElement>> getMetadataFieldMapping() {\n+        return metadataFieldMapping;\n+    }\n+\n+    /**\n+     * Set the metadataFieldMapping of this ArXivIdMetadataContributor\n+     *\n+     * @param metadataFieldMapping the new mapping.\n+     */\n+    public void setMetadataFieldMapping(\n+        MetadataFieldMapping<OMElement, MetadataContributor<OMElement>> metadataFieldMapping) {\n+        this.metadataFieldMapping = metadataFieldMapping;\n+    }\n+\n+    /**\n+     * Set the prefixToNamespaceMapping for this object,\n+     *\n+     * @param prefixToNamespaceMapping the new mapping.\n+     */\n+    @Resource(name = \"isiFullprefixMapping\")\n+    public void setPrefixToNamespaceMapping(Map<String, String> prefixToNamespaceMapping) {\n+        this.prefixToNamespaceMapping = prefixToNamespaceMapping;\n+    }\n+\n+    private Map<String, String> prefixToNamespaceMapping;\n+\n+    /**\n+     * Initialize ArXivIdMetadataContributor with a query, prefixToNamespaceMapping and MetadataFieldConfig\n+     *\n+     * @param query                    query string\n+     * @param prefixToNamespaceMapping metadata prefix to namespace mapping\n+     * @param field\n+     * <a href=\"https://github.com/DSpace/DSpace/tree/master/dspace-api/src/main/java/org/dspace/importer/external#metadata-mapping-\">MetadataFieldConfig</a>\n+     */\n+    public ArXivIdMetadataContributor(String query, Map<String, String> prefixToNamespaceMapping,\n+                                           MetadataFieldConfig field) {\n+        this.query = query;\n+        this.prefixToNamespaceMapping = prefixToNamespaceMapping;\n+        this.field = field;\n+    }\n+\n+    /**\n+     * Empty constructor for ArXivIdMetadataContributor\n+     */\n+    public ArXivIdMetadataContributor() {\n+\n+    }\n+\n+    private String query;\n+\n+    /**\n+     * Return the MetadataFieldConfig used while retrieving MetadatumDTO\n+     *\n+     * @return MetadataFieldConfig\n+     */\n+    public MetadataFieldConfig getField() {\n+        return field;\n+    }\n+\n+    /**\n+     * Setting the MetadataFieldConfig\n+     *\n+     * @param field MetadataFieldConfig used while retrieving MetadatumDTO\n+     */\n+    @Required\n+    public void setField(MetadataFieldConfig field) {\n+        this.field = field;\n+    }\n+\n+    /**\n+     * Return query used to create an xpathExpression on, this query is used to\n+     *\n+     * @return the query this instance is based on\n+     */\n+    public String getQuery() {\n+        return query;\n+    }\n+\n+    @Required\n+    public void setQuery(String query) {\n+        this.query = query;\n+    }\n+\n+    /**\n+     * Retrieve the metadata associated with the given object.\n+     * Depending on the retrieved node (using the query), different types of values will be added to the MetadatumDTO\n+     * list\n+     *\n+     * @param t A class to retrieve metadata from.\n+     * @return a collection of import records. Only the identifier of the found records may be put in the record.\n+     */\n+    @Override\n+    public Collection<MetadatumDTO> contributeMetadata(OMElement t) {\n+        List<MetadatumDTO> values = new LinkedList<>();\n+        try {\n+            AXIOMXPath xpath = new AXIOMXPath(query);\n+            for (String ns : prefixToNamespaceMapping.keySet()) {\n+                xpath.addNamespace(prefixToNamespaceMapping.get(ns), ns);\n+            }\n+            List<Object> nodes = xpath.selectNodes(t);\n+            for (Object el : nodes) {\n+                if (el instanceof OMElement) {\n+                    values.add(metadataFieldMapping.toDCValue(field, ((OMElement) el).getText()));\n+                } else if (el instanceof OMAttribute) {\n+                    values.add(metadataFieldMapping.toDCValue(field, ((OMAttribute) el).getAttributeValue()));\n+                } else if (el instanceof String) {\n+                    values.add(metadataFieldMapping.toDCValue(field, (String) el));\n+                } else if (el instanceof OMText) {\n+                    values.add(metadataFieldMapping.toDCValue(field, ((OMText) el).getText()));\n+                } else {\n+                    System.err.println(\"node of type: \" + el.getClass());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af38c36bdb094d91f934565d79bab66e29679363"}, "originalPosition": 163}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76d2e067108a3b7099e5e901cf69d47bb6d71396", "author": {"user": {"login": "Micheleboychuk", "name": "Mykhaylo Boychuk"}}, "url": "https://github.com/DSpace/DSpace/commit/76d2e067108a3b7099e5e901cf69d47bb6d71396", "committedDate": "2020-07-20T15:53:07Z", "message": "added Logger"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1MDM2NDYz", "url": "https://github.com/DSpace/DSpace/pull/2824#pullrequestreview-455036463", "createdAt": "2020-07-24T16:47:00Z", "commit": {"oid": "76d2e067108a3b7099e5e901cf69d47bb6d71396"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxNjo0NzowMFrOG22huA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxOTowNToyMlrOG26n5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE2OTY1Ng==", "bodyText": "I'm not seeing where this new dependency is needed within this PR?  Could you point it out?  I'd like to make the comment here more specific to call out the exact Class where this dependency is needed (is it PubMedImportService? or something else that needs this?).  So, I'd rather this say something like Needed to support PubMed API call in [ClassName]", "url": "https://github.com/DSpace/DSpace/pull/2824#discussion_r460169656", "createdAt": "2020-07-24T16:47:00Z", "author": {"login": "tdonohue"}, "path": "dspace-api/pom.xml", "diffHunk": "@@ -622,6 +622,12 @@\n             <artifactId>jersey-client</artifactId>\n             <version>${jersey.version}</version>\n         </dependency>\n+        <!-- This was added to support the pubmed api call -->\n+        <dependency>\n+            <groupId>org.glassfish.jersey.inject</groupId>\n+            <artifactId>jersey-hk2</artifactId>\n+            <version>${jersey.version}</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76d2e067108a3b7099e5e901cf69d47bb6d71396"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIzNTg4OQ==", "bodyText": "I agree this new method should have JavaDocs. It's not clear the purpose of this method...it seems to be changing the current value of all MetadatumDTO objects?", "url": "https://github.com/DSpace/DSpace/pull/2824#discussion_r460235889", "createdAt": "2020-07-24T19:03:29Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/importer/external/arxiv/metadatamapping/contributor/ArXivIdMetadataContributor.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.importer.external.arxiv.metadatamapping.contributor;\n+\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Resource;\n+\n+import org.apache.axiom.om.OMAttribute;\n+import org.apache.axiom.om.OMElement;\n+import org.apache.axiom.om.OMText;\n+import org.apache.axiom.om.xpath.AXIOMXPath;\n+import org.dspace.importer.external.metadatamapping.MetadataFieldConfig;\n+import org.dspace.importer.external.metadatamapping.MetadataFieldMapping;\n+import org.dspace.importer.external.metadatamapping.MetadatumDTO;\n+import org.dspace.importer.external.metadatamapping.contributor.MetadataContributor;\n+import org.jaxen.JaxenException;\n+import org.springframework.beans.factory.annotation.Required;\n+\n+/**\n+ * Arxiv specific implementation of {@link MetadataContributor}\n+ * Responsible for generating the ArXiv Id from the retrieved item.\n+ * \n+ * @author Pasquale Cavallo (pasquale.cavallo at 4science dot it)\n+ *\n+ */\n+public class ArXivIdMetadataContributor implements MetadataContributor<OMElement> {\n+    private MetadataFieldConfig field;\n+\n+    /**\n+     * Return prefixToNamespaceMapping\n+     *\n+     * @return a prefixToNamespaceMapping map\n+     */\n+    public Map<String, String> getPrefixToNamespaceMapping() {\n+        return prefixToNamespaceMapping;\n+    }\n+\n+    private MetadataFieldMapping<OMElement, MetadataContributor<OMElement>> metadataFieldMapping;\n+\n+    /**\n+     * Return metadataFieldMapping\n+     *\n+     * @return MetadataFieldMapping\n+     */\n+    public MetadataFieldMapping<OMElement, MetadataContributor<OMElement>> getMetadataFieldMapping() {\n+        return metadataFieldMapping;\n+    }\n+\n+    /**\n+     * Set the metadataFieldMapping of this ArXivIdMetadataContributor\n+     *\n+     * @param metadataFieldMapping the new mapping.\n+     */\n+    public void setMetadataFieldMapping(\n+        MetadataFieldMapping<OMElement, MetadataContributor<OMElement>> metadataFieldMapping) {\n+        this.metadataFieldMapping = metadataFieldMapping;\n+    }\n+\n+    /**\n+     * Set the prefixToNamespaceMapping for this object,\n+     *\n+     * @param prefixToNamespaceMapping the new mapping.\n+     */\n+    @Resource(name = \"isiFullprefixMapping\")\n+    public void setPrefixToNamespaceMapping(Map<String, String> prefixToNamespaceMapping) {\n+        this.prefixToNamespaceMapping = prefixToNamespaceMapping;\n+    }\n+\n+    private Map<String, String> prefixToNamespaceMapping;\n+\n+    /**\n+     * Initialize ArXivIdMetadataContributor with a query, prefixToNamespaceMapping and MetadataFieldConfig\n+     *\n+     * @param query                    query string\n+     * @param prefixToNamespaceMapping metadata prefix to namespace mapping\n+     * @param field\n+     * <a href=\"https://github.com/DSpace/DSpace/tree/master/dspace-api/src/main/java/org/dspace/importer/external#metadata-mapping-\">MetadataFieldConfig</a>\n+     */\n+    public ArXivIdMetadataContributor(String query, Map<String, String> prefixToNamespaceMapping,\n+                                           MetadataFieldConfig field) {\n+        this.query = query;\n+        this.prefixToNamespaceMapping = prefixToNamespaceMapping;\n+        this.field = field;\n+    }\n+\n+    /**\n+     * Empty constructor for ArXivIdMetadataContributor\n+     */\n+    public ArXivIdMetadataContributor() {\n+\n+    }\n+\n+    private String query;\n+\n+    /**\n+     * Return the MetadataFieldConfig used while retrieving MetadatumDTO\n+     *\n+     * @return MetadataFieldConfig\n+     */\n+    public MetadataFieldConfig getField() {\n+        return field;\n+    }\n+\n+    /**\n+     * Setting the MetadataFieldConfig\n+     *\n+     * @param field MetadataFieldConfig used while retrieving MetadatumDTO\n+     */\n+    @Required\n+    public void setField(MetadataFieldConfig field) {\n+        this.field = field;\n+    }\n+\n+    /**\n+     * Return query used to create an xpathExpression on, this query is used to\n+     *\n+     * @return the query this instance is based on\n+     */\n+    public String getQuery() {\n+        return query;\n+    }\n+\n+    @Required\n+    public void setQuery(String query) {\n+        this.query = query;\n+    }\n+\n+    /**\n+     * Retrieve the metadata associated with the given object.\n+     * Depending on the retrieved node (using the query), different types of values will be added to the MetadatumDTO\n+     * list\n+     *\n+     * @param t A class to retrieve metadata from.\n+     * @return a collection of import records. Only the identifier of the found records may be put in the record.\n+     */\n+    @Override\n+    public Collection<MetadatumDTO> contributeMetadata(OMElement t) {\n+        List<MetadatumDTO> values = new LinkedList<>();\n+        try {\n+            AXIOMXPath xpath = new AXIOMXPath(query);\n+            for (String ns : prefixToNamespaceMapping.keySet()) {\n+                xpath.addNamespace(prefixToNamespaceMapping.get(ns), ns);\n+            }\n+            List<Object> nodes = xpath.selectNodes(t);\n+            for (Object el : nodes) {\n+                if (el instanceof OMElement) {\n+                    values.add(metadataFieldMapping.toDCValue(field, ((OMElement) el).getText()));\n+                } else if (el instanceof OMAttribute) {\n+                    values.add(metadataFieldMapping.toDCValue(field, ((OMAttribute) el).getAttributeValue()));\n+                } else if (el instanceof String) {\n+                    values.add(metadataFieldMapping.toDCValue(field, (String) el));\n+                } else if (el instanceof OMText) {\n+                    values.add(metadataFieldMapping.toDCValue(field, ((OMText) el).getText()));\n+                } else {\n+                    System.err.println(\"node of type: \" + el.getClass());\n+                }\n+            }\n+            parseValue(values);\n+            return values;\n+        } catch (JaxenException e) {\n+            System.err.println(query);\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private void parseValue(List<MetadatumDTO> dtos) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY0NTcwMA=="}, "originalCommit": {"oid": "af38c36bdb094d91f934565d79bab66e29679363"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIzNjQwNA==", "bodyText": "Please add JavaDocs to this private Class.  All classes (private or public) need JavaDocs.", "url": "https://github.com/DSpace/DSpace/pull/2824#discussion_r460236404", "createdAt": "2020-07-24T19:04:36Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/importer/external/arxiv/service/ArXivImportMetadataSourceServiceImpl.java", "diffHunk": "@@ -0,0 +1,360 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.importer.external.arxiv.service;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import javax.el.MethodNotFoundException;\n+import javax.ws.rs.client.Client;\n+import javax.ws.rs.client.ClientBuilder;\n+import javax.ws.rs.client.Invocation;\n+import javax.ws.rs.client.WebTarget;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.axiom.om.OMElement;\n+import org.apache.axiom.om.OMXMLBuilderFactory;\n+import org.apache.axiom.om.OMXMLParserWrapper;\n+import org.apache.axiom.om.xpath.AXIOMXPath;\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.content.Item;\n+import org.dspace.importer.external.datamodel.ImportRecord;\n+import org.dspace.importer.external.datamodel.Query;\n+import org.dspace.importer.external.exception.MetadataSourceException;\n+import org.dspace.importer.external.service.AbstractImportMetadataSourceService;\n+import org.jaxen.JaxenException;\n+\n+/**\n+ * Implements a data source for querying ArXiv\n+ * \n+ * @author Pasquale Cavallo (pasquale.cavallo at 4Science dot it)\n+ *\n+ */\n+public class ArXivImportMetadataSourceServiceImpl extends AbstractImportMetadataSourceService<OMElement> {\n+\n+    private WebTarget webTarget;\n+    private String baseAddress;\n+\n+    /**\n+     * Find the number of records matching a string query. Supports pagination\n+     *\n+     * @param query a query string to base the search on.\n+     * @param start offset to start at\n+     * @param count number of records to retrieve.\n+     * @return a set of records. Fully transformed.\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public Collection<ImportRecord> getRecords(String query, int start, int count) throws MetadataSourceException {\n+        return retry(new SearchByQueryCallable(query, count, start));\n+    }\n+\n+    /**\n+     * Find records based on a object query.\n+     *\n+     * @param query a query object to base the search on.\n+     * @return a set of records. Fully transformed.\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public Collection<ImportRecord> getRecords(Query query) throws MetadataSourceException {\n+        return retry(new SearchByQueryCallable(query));\n+    }\n+\n+    /**\n+     * Find the number of records matching a query;\n+     *\n+     * @param query a query object to base the search on.\n+     * @return the sum of the matching records over this import source\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public int getNbRecords(String query) throws MetadataSourceException {\n+        return retry(new CountByQueryCallable(query));\n+    }\n+\n+\n+    /**\n+     * Find the number of records matching a query;\n+     *\n+     * @param query a query string to base the search on.\n+     * @return the sum of the matching records over this import source\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public int getNbRecords(Query query) throws MetadataSourceException {\n+        return retry(new CountByQueryCallable(query));\n+    }\n+\n+    /**\n+     * Get a single record from the source by id\n+     *\n+     * @param id id of the record in ArXiv\n+     * @return the first matching record\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+\n+    @Override\n+    public ImportRecord getRecord(String id) throws MetadataSourceException {\n+        List<ImportRecord> records = retry(new SearchByIdCallable(id));\n+        return records == null || records.isEmpty() ? null : records.get(0);\n+    }\n+\n+    /**\n+     * Get a single record from the source.\n+     *\n+     * @param query a query matching a single record\n+     * @return the first matching record\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public ImportRecord getRecord(Query query) throws MetadataSourceException {\n+        List<ImportRecord> records = retry(new SearchByIdCallable(query));\n+        return records == null || records.isEmpty() ? null : records.get(0);\n+    }\n+\n+    /**\n+     * Initialize the class\n+     *\n+     * @throws Exception on generic exception\n+     */\n+    @Override\n+    public void init() throws Exception {\n+        Client client = ClientBuilder.newClient();\n+        webTarget = client.target(baseAddress);\n+    }\n+\n+    /**\n+     * The string that identifies this import implementation. Preferable a URI\n+     *\n+     * @return the identifying uri\n+     */\n+    @Override\n+    public String getImportSource() {\n+        return \"arxiv\";\n+    }\n+\n+    /**\n+     * Expect this method will be not used and erased from the interface soon\n+     */\n+    @Override\n+    public Collection<ImportRecord> findMatchingRecords(Item item) throws MetadataSourceException {\n+        // FIXME: we need this method?\n+        throw new MethodNotFoundException(\"This method is not implemented for ArXiv\");\n+    }\n+\n+    /**\n+     * Finds records based on query object.\n+     * Supports search by title and/or author\n+     *\n+     * @param query a query object to base the search on.\n+     * @return a collection of import records.\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public Collection<ImportRecord> findMatchingRecords(Query query) throws MetadataSourceException {\n+        return retry(new FindMatchingRecordCallable(query));\n+    }\n+\n+    private class CountByQueryCallable implements Callable<Integer> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76d2e067108a3b7099e5e901cf69d47bb6d71396"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIzNjU5MQ==", "bodyText": "Again, private, internal class needs JavaDocs", "url": "https://github.com/DSpace/DSpace/pull/2824#discussion_r460236591", "createdAt": "2020-07-24T19:04:59Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/importer/external/arxiv/service/ArXivImportMetadataSourceServiceImpl.java", "diffHunk": "@@ -0,0 +1,360 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.importer.external.arxiv.service;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import javax.el.MethodNotFoundException;\n+import javax.ws.rs.client.Client;\n+import javax.ws.rs.client.ClientBuilder;\n+import javax.ws.rs.client.Invocation;\n+import javax.ws.rs.client.WebTarget;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.axiom.om.OMElement;\n+import org.apache.axiom.om.OMXMLBuilderFactory;\n+import org.apache.axiom.om.OMXMLParserWrapper;\n+import org.apache.axiom.om.xpath.AXIOMXPath;\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.content.Item;\n+import org.dspace.importer.external.datamodel.ImportRecord;\n+import org.dspace.importer.external.datamodel.Query;\n+import org.dspace.importer.external.exception.MetadataSourceException;\n+import org.dspace.importer.external.service.AbstractImportMetadataSourceService;\n+import org.jaxen.JaxenException;\n+\n+/**\n+ * Implements a data source for querying ArXiv\n+ * \n+ * @author Pasquale Cavallo (pasquale.cavallo at 4Science dot it)\n+ *\n+ */\n+public class ArXivImportMetadataSourceServiceImpl extends AbstractImportMetadataSourceService<OMElement> {\n+\n+    private WebTarget webTarget;\n+    private String baseAddress;\n+\n+    /**\n+     * Find the number of records matching a string query. Supports pagination\n+     *\n+     * @param query a query string to base the search on.\n+     * @param start offset to start at\n+     * @param count number of records to retrieve.\n+     * @return a set of records. Fully transformed.\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public Collection<ImportRecord> getRecords(String query, int start, int count) throws MetadataSourceException {\n+        return retry(new SearchByQueryCallable(query, count, start));\n+    }\n+\n+    /**\n+     * Find records based on a object query.\n+     *\n+     * @param query a query object to base the search on.\n+     * @return a set of records. Fully transformed.\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public Collection<ImportRecord> getRecords(Query query) throws MetadataSourceException {\n+        return retry(new SearchByQueryCallable(query));\n+    }\n+\n+    /**\n+     * Find the number of records matching a query;\n+     *\n+     * @param query a query object to base the search on.\n+     * @return the sum of the matching records over this import source\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public int getNbRecords(String query) throws MetadataSourceException {\n+        return retry(new CountByQueryCallable(query));\n+    }\n+\n+\n+    /**\n+     * Find the number of records matching a query;\n+     *\n+     * @param query a query string to base the search on.\n+     * @return the sum of the matching records over this import source\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public int getNbRecords(Query query) throws MetadataSourceException {\n+        return retry(new CountByQueryCallable(query));\n+    }\n+\n+    /**\n+     * Get a single record from the source by id\n+     *\n+     * @param id id of the record in ArXiv\n+     * @return the first matching record\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+\n+    @Override\n+    public ImportRecord getRecord(String id) throws MetadataSourceException {\n+        List<ImportRecord> records = retry(new SearchByIdCallable(id));\n+        return records == null || records.isEmpty() ? null : records.get(0);\n+    }\n+\n+    /**\n+     * Get a single record from the source.\n+     *\n+     * @param query a query matching a single record\n+     * @return the first matching record\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public ImportRecord getRecord(Query query) throws MetadataSourceException {\n+        List<ImportRecord> records = retry(new SearchByIdCallable(query));\n+        return records == null || records.isEmpty() ? null : records.get(0);\n+    }\n+\n+    /**\n+     * Initialize the class\n+     *\n+     * @throws Exception on generic exception\n+     */\n+    @Override\n+    public void init() throws Exception {\n+        Client client = ClientBuilder.newClient();\n+        webTarget = client.target(baseAddress);\n+    }\n+\n+    /**\n+     * The string that identifies this import implementation. Preferable a URI\n+     *\n+     * @return the identifying uri\n+     */\n+    @Override\n+    public String getImportSource() {\n+        return \"arxiv\";\n+    }\n+\n+    /**\n+     * Expect this method will be not used and erased from the interface soon\n+     */\n+    @Override\n+    public Collection<ImportRecord> findMatchingRecords(Item item) throws MetadataSourceException {\n+        // FIXME: we need this method?\n+        throw new MethodNotFoundException(\"This method is not implemented for ArXiv\");\n+    }\n+\n+    /**\n+     * Finds records based on query object.\n+     * Supports search by title and/or author\n+     *\n+     * @param query a query object to base the search on.\n+     * @return a collection of import records.\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public Collection<ImportRecord> findMatchingRecords(Query query) throws MetadataSourceException {\n+        return retry(new FindMatchingRecordCallable(query));\n+    }\n+\n+    private class CountByQueryCallable implements Callable<Integer> {\n+        private Query query;\n+\n+\n+        private CountByQueryCallable(String queryString) {\n+            query = new Query();\n+            query.addParameter(\"query\", queryString);\n+        }\n+\n+        private CountByQueryCallable(Query query) {\n+            this.query = query;\n+        }\n+\n+\n+        @Override\n+        public Integer call() throws Exception {\n+            String queryString = query.getParameterAsClass(\"query\", String.class);\n+            Integer start = query.getParameterAsClass(\"start\", Integer.class);\n+            Integer maxResult = query.getParameterAsClass(\"count\", Integer.class);\n+            WebTarget local = webTarget.queryParam(\"search_query\", queryString);\n+            if (maxResult != null) {\n+                local = local.queryParam(\"max_results\", String.valueOf(maxResult));\n+            }\n+            if (start != null) {\n+                local = local.queryParam(\"start\", String.valueOf(start));\n+            }\n+            Invocation.Builder invocationBuilder = local.request(MediaType.TEXT_PLAIN_TYPE);\n+            Response response = invocationBuilder.get();\n+            String responseString = response.readEntity(String.class);\n+            OMXMLParserWrapper records = OMXMLBuilderFactory.createOMBuilder(new StringReader(responseString));\n+            OMElement element = records.getDocumentElement();\n+            AXIOMXPath xpath = null;\n+            try {\n+                xpath = new AXIOMXPath(\"opensearch:totalResults\");\n+                xpath.addNamespace(\"opensearch\", \"http://a9.com/-/spec/opensearch/1.1/\");\n+                OMElement count = (OMElement) xpath.selectSingleNode(element);\n+                return Integer.parseInt(count.getText());\n+            } catch (JaxenException e) {\n+                return null;\n+            }\n+        }\n+    }\n+\n+\n+    private class SearchByQueryCallable implements Callable<List<ImportRecord>> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76d2e067108a3b7099e5e901cf69d47bb6d71396"}, "originalPosition": 211}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIzNjY4OQ==", "bodyText": "Same here, needs Javadocs", "url": "https://github.com/DSpace/DSpace/pull/2824#discussion_r460236689", "createdAt": "2020-07-24T19:05:11Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/importer/external/arxiv/service/ArXivImportMetadataSourceServiceImpl.java", "diffHunk": "@@ -0,0 +1,360 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.importer.external.arxiv.service;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import javax.el.MethodNotFoundException;\n+import javax.ws.rs.client.Client;\n+import javax.ws.rs.client.ClientBuilder;\n+import javax.ws.rs.client.Invocation;\n+import javax.ws.rs.client.WebTarget;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.axiom.om.OMElement;\n+import org.apache.axiom.om.OMXMLBuilderFactory;\n+import org.apache.axiom.om.OMXMLParserWrapper;\n+import org.apache.axiom.om.xpath.AXIOMXPath;\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.content.Item;\n+import org.dspace.importer.external.datamodel.ImportRecord;\n+import org.dspace.importer.external.datamodel.Query;\n+import org.dspace.importer.external.exception.MetadataSourceException;\n+import org.dspace.importer.external.service.AbstractImportMetadataSourceService;\n+import org.jaxen.JaxenException;\n+\n+/**\n+ * Implements a data source for querying ArXiv\n+ * \n+ * @author Pasquale Cavallo (pasquale.cavallo at 4Science dot it)\n+ *\n+ */\n+public class ArXivImportMetadataSourceServiceImpl extends AbstractImportMetadataSourceService<OMElement> {\n+\n+    private WebTarget webTarget;\n+    private String baseAddress;\n+\n+    /**\n+     * Find the number of records matching a string query. Supports pagination\n+     *\n+     * @param query a query string to base the search on.\n+     * @param start offset to start at\n+     * @param count number of records to retrieve.\n+     * @return a set of records. Fully transformed.\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public Collection<ImportRecord> getRecords(String query, int start, int count) throws MetadataSourceException {\n+        return retry(new SearchByQueryCallable(query, count, start));\n+    }\n+\n+    /**\n+     * Find records based on a object query.\n+     *\n+     * @param query a query object to base the search on.\n+     * @return a set of records. Fully transformed.\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public Collection<ImportRecord> getRecords(Query query) throws MetadataSourceException {\n+        return retry(new SearchByQueryCallable(query));\n+    }\n+\n+    /**\n+     * Find the number of records matching a query;\n+     *\n+     * @param query a query object to base the search on.\n+     * @return the sum of the matching records over this import source\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public int getNbRecords(String query) throws MetadataSourceException {\n+        return retry(new CountByQueryCallable(query));\n+    }\n+\n+\n+    /**\n+     * Find the number of records matching a query;\n+     *\n+     * @param query a query string to base the search on.\n+     * @return the sum of the matching records over this import source\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public int getNbRecords(Query query) throws MetadataSourceException {\n+        return retry(new CountByQueryCallable(query));\n+    }\n+\n+    /**\n+     * Get a single record from the source by id\n+     *\n+     * @param id id of the record in ArXiv\n+     * @return the first matching record\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+\n+    @Override\n+    public ImportRecord getRecord(String id) throws MetadataSourceException {\n+        List<ImportRecord> records = retry(new SearchByIdCallable(id));\n+        return records == null || records.isEmpty() ? null : records.get(0);\n+    }\n+\n+    /**\n+     * Get a single record from the source.\n+     *\n+     * @param query a query matching a single record\n+     * @return the first matching record\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public ImportRecord getRecord(Query query) throws MetadataSourceException {\n+        List<ImportRecord> records = retry(new SearchByIdCallable(query));\n+        return records == null || records.isEmpty() ? null : records.get(0);\n+    }\n+\n+    /**\n+     * Initialize the class\n+     *\n+     * @throws Exception on generic exception\n+     */\n+    @Override\n+    public void init() throws Exception {\n+        Client client = ClientBuilder.newClient();\n+        webTarget = client.target(baseAddress);\n+    }\n+\n+    /**\n+     * The string that identifies this import implementation. Preferable a URI\n+     *\n+     * @return the identifying uri\n+     */\n+    @Override\n+    public String getImportSource() {\n+        return \"arxiv\";\n+    }\n+\n+    /**\n+     * Expect this method will be not used and erased from the interface soon\n+     */\n+    @Override\n+    public Collection<ImportRecord> findMatchingRecords(Item item) throws MetadataSourceException {\n+        // FIXME: we need this method?\n+        throw new MethodNotFoundException(\"This method is not implemented for ArXiv\");\n+    }\n+\n+    /**\n+     * Finds records based on query object.\n+     * Supports search by title and/or author\n+     *\n+     * @param query a query object to base the search on.\n+     * @return a collection of import records.\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public Collection<ImportRecord> findMatchingRecords(Query query) throws MetadataSourceException {\n+        return retry(new FindMatchingRecordCallable(query));\n+    }\n+\n+    private class CountByQueryCallable implements Callable<Integer> {\n+        private Query query;\n+\n+\n+        private CountByQueryCallable(String queryString) {\n+            query = new Query();\n+            query.addParameter(\"query\", queryString);\n+        }\n+\n+        private CountByQueryCallable(Query query) {\n+            this.query = query;\n+        }\n+\n+\n+        @Override\n+        public Integer call() throws Exception {\n+            String queryString = query.getParameterAsClass(\"query\", String.class);\n+            Integer start = query.getParameterAsClass(\"start\", Integer.class);\n+            Integer maxResult = query.getParameterAsClass(\"count\", Integer.class);\n+            WebTarget local = webTarget.queryParam(\"search_query\", queryString);\n+            if (maxResult != null) {\n+                local = local.queryParam(\"max_results\", String.valueOf(maxResult));\n+            }\n+            if (start != null) {\n+                local = local.queryParam(\"start\", String.valueOf(start));\n+            }\n+            Invocation.Builder invocationBuilder = local.request(MediaType.TEXT_PLAIN_TYPE);\n+            Response response = invocationBuilder.get();\n+            String responseString = response.readEntity(String.class);\n+            OMXMLParserWrapper records = OMXMLBuilderFactory.createOMBuilder(new StringReader(responseString));\n+            OMElement element = records.getDocumentElement();\n+            AXIOMXPath xpath = null;\n+            try {\n+                xpath = new AXIOMXPath(\"opensearch:totalResults\");\n+                xpath.addNamespace(\"opensearch\", \"http://a9.com/-/spec/opensearch/1.1/\");\n+                OMElement count = (OMElement) xpath.selectSingleNode(element);\n+                return Integer.parseInt(count.getText());\n+            } catch (JaxenException e) {\n+                return null;\n+            }\n+        }\n+    }\n+\n+\n+    private class SearchByQueryCallable implements Callable<List<ImportRecord>> {\n+        private Query query;\n+\n+\n+        private SearchByQueryCallable(String queryString, Integer maxResult, Integer start) {\n+            query = new Query();\n+            query.addParameter(\"query\", queryString);\n+            query.addParameter(\"start\", start);\n+            query.addParameter(\"count\", maxResult);\n+        }\n+\n+        private SearchByQueryCallable(Query query) {\n+            this.query = query;\n+        }\n+\n+\n+        @Override\n+        public List<ImportRecord> call() throws Exception {\n+            List<ImportRecord> results = new ArrayList<ImportRecord>();\n+            String queryString = query.getParameterAsClass(\"query\", String.class);\n+            Integer start = query.getParameterAsClass(\"start\", Integer.class);\n+            Integer maxResult = query.getParameterAsClass(\"count\", Integer.class);\n+            WebTarget local = webTarget.queryParam(\"search_query\", queryString);\n+            if (maxResult != null) {\n+                local = local.queryParam(\"max_results\", String.valueOf(maxResult));\n+            }\n+            if (start != null) {\n+                local = local.queryParam(\"start\", String.valueOf(start));\n+            }\n+            Invocation.Builder invocationBuilder = local.request(MediaType.TEXT_PLAIN_TYPE);\n+            Response response = invocationBuilder.get();\n+            String responseString = response.readEntity(String.class);\n+            List<OMElement> omElements = splitToRecords(responseString);\n+            for (OMElement record : omElements) {\n+                results.add(transformSourceRecords(record));\n+            }\n+            return results;\n+        }\n+    }\n+\n+    private class SearchByIdCallable implements Callable<List<ImportRecord>> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76d2e067108a3b7099e5e901cf69d47bb6d71396"}, "originalPosition": 251}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIzNjc3Mg==", "bodyText": "Again, needs JavaDocs", "url": "https://github.com/DSpace/DSpace/pull/2824#discussion_r460236772", "createdAt": "2020-07-24T19:05:22Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/importer/external/arxiv/service/ArXivImportMetadataSourceServiceImpl.java", "diffHunk": "@@ -0,0 +1,360 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.importer.external.arxiv.service;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import javax.el.MethodNotFoundException;\n+import javax.ws.rs.client.Client;\n+import javax.ws.rs.client.ClientBuilder;\n+import javax.ws.rs.client.Invocation;\n+import javax.ws.rs.client.WebTarget;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.axiom.om.OMElement;\n+import org.apache.axiom.om.OMXMLBuilderFactory;\n+import org.apache.axiom.om.OMXMLParserWrapper;\n+import org.apache.axiom.om.xpath.AXIOMXPath;\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.content.Item;\n+import org.dspace.importer.external.datamodel.ImportRecord;\n+import org.dspace.importer.external.datamodel.Query;\n+import org.dspace.importer.external.exception.MetadataSourceException;\n+import org.dspace.importer.external.service.AbstractImportMetadataSourceService;\n+import org.jaxen.JaxenException;\n+\n+/**\n+ * Implements a data source for querying ArXiv\n+ * \n+ * @author Pasquale Cavallo (pasquale.cavallo at 4Science dot it)\n+ *\n+ */\n+public class ArXivImportMetadataSourceServiceImpl extends AbstractImportMetadataSourceService<OMElement> {\n+\n+    private WebTarget webTarget;\n+    private String baseAddress;\n+\n+    /**\n+     * Find the number of records matching a string query. Supports pagination\n+     *\n+     * @param query a query string to base the search on.\n+     * @param start offset to start at\n+     * @param count number of records to retrieve.\n+     * @return a set of records. Fully transformed.\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public Collection<ImportRecord> getRecords(String query, int start, int count) throws MetadataSourceException {\n+        return retry(new SearchByQueryCallable(query, count, start));\n+    }\n+\n+    /**\n+     * Find records based on a object query.\n+     *\n+     * @param query a query object to base the search on.\n+     * @return a set of records. Fully transformed.\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public Collection<ImportRecord> getRecords(Query query) throws MetadataSourceException {\n+        return retry(new SearchByQueryCallable(query));\n+    }\n+\n+    /**\n+     * Find the number of records matching a query;\n+     *\n+     * @param query a query object to base the search on.\n+     * @return the sum of the matching records over this import source\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public int getNbRecords(String query) throws MetadataSourceException {\n+        return retry(new CountByQueryCallable(query));\n+    }\n+\n+\n+    /**\n+     * Find the number of records matching a query;\n+     *\n+     * @param query a query string to base the search on.\n+     * @return the sum of the matching records over this import source\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public int getNbRecords(Query query) throws MetadataSourceException {\n+        return retry(new CountByQueryCallable(query));\n+    }\n+\n+    /**\n+     * Get a single record from the source by id\n+     *\n+     * @param id id of the record in ArXiv\n+     * @return the first matching record\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+\n+    @Override\n+    public ImportRecord getRecord(String id) throws MetadataSourceException {\n+        List<ImportRecord> records = retry(new SearchByIdCallable(id));\n+        return records == null || records.isEmpty() ? null : records.get(0);\n+    }\n+\n+    /**\n+     * Get a single record from the source.\n+     *\n+     * @param query a query matching a single record\n+     * @return the first matching record\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public ImportRecord getRecord(Query query) throws MetadataSourceException {\n+        List<ImportRecord> records = retry(new SearchByIdCallable(query));\n+        return records == null || records.isEmpty() ? null : records.get(0);\n+    }\n+\n+    /**\n+     * Initialize the class\n+     *\n+     * @throws Exception on generic exception\n+     */\n+    @Override\n+    public void init() throws Exception {\n+        Client client = ClientBuilder.newClient();\n+        webTarget = client.target(baseAddress);\n+    }\n+\n+    /**\n+     * The string that identifies this import implementation. Preferable a URI\n+     *\n+     * @return the identifying uri\n+     */\n+    @Override\n+    public String getImportSource() {\n+        return \"arxiv\";\n+    }\n+\n+    /**\n+     * Expect this method will be not used and erased from the interface soon\n+     */\n+    @Override\n+    public Collection<ImportRecord> findMatchingRecords(Item item) throws MetadataSourceException {\n+        // FIXME: we need this method?\n+        throw new MethodNotFoundException(\"This method is not implemented for ArXiv\");\n+    }\n+\n+    /**\n+     * Finds records based on query object.\n+     * Supports search by title and/or author\n+     *\n+     * @param query a query object to base the search on.\n+     * @return a collection of import records.\n+     * @throws MetadataSourceException if the underlying methods throw any exception.\n+     */\n+    @Override\n+    public Collection<ImportRecord> findMatchingRecords(Query query) throws MetadataSourceException {\n+        return retry(new FindMatchingRecordCallable(query));\n+    }\n+\n+    private class CountByQueryCallable implements Callable<Integer> {\n+        private Query query;\n+\n+\n+        private CountByQueryCallable(String queryString) {\n+            query = new Query();\n+            query.addParameter(\"query\", queryString);\n+        }\n+\n+        private CountByQueryCallable(Query query) {\n+            this.query = query;\n+        }\n+\n+\n+        @Override\n+        public Integer call() throws Exception {\n+            String queryString = query.getParameterAsClass(\"query\", String.class);\n+            Integer start = query.getParameterAsClass(\"start\", Integer.class);\n+            Integer maxResult = query.getParameterAsClass(\"count\", Integer.class);\n+            WebTarget local = webTarget.queryParam(\"search_query\", queryString);\n+            if (maxResult != null) {\n+                local = local.queryParam(\"max_results\", String.valueOf(maxResult));\n+            }\n+            if (start != null) {\n+                local = local.queryParam(\"start\", String.valueOf(start));\n+            }\n+            Invocation.Builder invocationBuilder = local.request(MediaType.TEXT_PLAIN_TYPE);\n+            Response response = invocationBuilder.get();\n+            String responseString = response.readEntity(String.class);\n+            OMXMLParserWrapper records = OMXMLBuilderFactory.createOMBuilder(new StringReader(responseString));\n+            OMElement element = records.getDocumentElement();\n+            AXIOMXPath xpath = null;\n+            try {\n+                xpath = new AXIOMXPath(\"opensearch:totalResults\");\n+                xpath.addNamespace(\"opensearch\", \"http://a9.com/-/spec/opensearch/1.1/\");\n+                OMElement count = (OMElement) xpath.selectSingleNode(element);\n+                return Integer.parseInt(count.getText());\n+            } catch (JaxenException e) {\n+                return null;\n+            }\n+        }\n+    }\n+\n+\n+    private class SearchByQueryCallable implements Callable<List<ImportRecord>> {\n+        private Query query;\n+\n+\n+        private SearchByQueryCallable(String queryString, Integer maxResult, Integer start) {\n+            query = new Query();\n+            query.addParameter(\"query\", queryString);\n+            query.addParameter(\"start\", start);\n+            query.addParameter(\"count\", maxResult);\n+        }\n+\n+        private SearchByQueryCallable(Query query) {\n+            this.query = query;\n+        }\n+\n+\n+        @Override\n+        public List<ImportRecord> call() throws Exception {\n+            List<ImportRecord> results = new ArrayList<ImportRecord>();\n+            String queryString = query.getParameterAsClass(\"query\", String.class);\n+            Integer start = query.getParameterAsClass(\"start\", Integer.class);\n+            Integer maxResult = query.getParameterAsClass(\"count\", Integer.class);\n+            WebTarget local = webTarget.queryParam(\"search_query\", queryString);\n+            if (maxResult != null) {\n+                local = local.queryParam(\"max_results\", String.valueOf(maxResult));\n+            }\n+            if (start != null) {\n+                local = local.queryParam(\"start\", String.valueOf(start));\n+            }\n+            Invocation.Builder invocationBuilder = local.request(MediaType.TEXT_PLAIN_TYPE);\n+            Response response = invocationBuilder.get();\n+            String responseString = response.readEntity(String.class);\n+            List<OMElement> omElements = splitToRecords(responseString);\n+            for (OMElement record : omElements) {\n+                results.add(transformSourceRecords(record));\n+            }\n+            return results;\n+        }\n+    }\n+\n+    private class SearchByIdCallable implements Callable<List<ImportRecord>> {\n+        private Query query;\n+\n+        private SearchByIdCallable(Query query) {\n+            this.query = query;\n+        }\n+\n+        private SearchByIdCallable(String id) {\n+            this.query = new Query();\n+            query.addParameter(\"id\", id);\n+        }\n+\n+        @Override\n+        public List<ImportRecord> call() throws Exception {\n+            List<ImportRecord> results = new ArrayList<ImportRecord>();\n+            String arxivid = query.getParameterAsClass(\"id\", String.class);\n+            if (StringUtils.isNotBlank(arxivid)) {\n+                arxivid = arxivid.trim();\n+                if (arxivid.startsWith(\"http://arxiv.org/abs/\")) {\n+                    arxivid = arxivid.substring(\"http://arxiv.org/abs/\".length());\n+                } else if (arxivid.toLowerCase().startsWith(\"arxiv:\")) {\n+                    arxivid = arxivid.substring(\"arxiv:\".length());\n+                }\n+            }\n+            WebTarget local = webTarget.queryParam(\"id_list\", arxivid);\n+            Invocation.Builder invocationBuilder = local.request(MediaType.TEXT_PLAIN_TYPE);\n+            Response response = invocationBuilder.get();\n+            String responseString = response.readEntity(String.class);\n+            List<OMElement> omElements = splitToRecords(responseString);\n+            for (OMElement record : omElements) {\n+                results.add(transformSourceRecords(record));\n+            }\n+            return results;\n+        }\n+    }\n+\n+    private class FindMatchingRecordCallable implements Callable<List<ImportRecord>> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76d2e067108a3b7099e5e901cf69d47bb6d71396"}, "originalPosition": 287}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "25bed852d39d0a95fdd90af77017346495ff521e", "author": {"user": {"login": "pasqualecvl", "name": "Pasquale Cavallo"}}, "url": "https://github.com/DSpace/DSpace/commit/25bed852d39d0a95fdd90af77017346495ff521e", "committedDate": "2020-07-28T23:19:20Z", "message": "Add comment, rewrite ArxivIdMetadataContributor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "afd6436c5c3b65697692c741244b258f9a94546b", "author": {"user": {"login": "pasqualecvl", "name": "Pasquale Cavallo"}}, "url": "https://github.com/DSpace/DSpace/commit/afd6436c5c3b65697692c741244b258f9a94546b", "committedDate": "2020-07-28T23:44:25Z", "message": "Clean code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c1e4432d108fb5a32b95367f83aa71ac11a0dd3", "author": {"user": {"login": "pasqualecvl", "name": "Pasquale Cavallo"}}, "url": "https://github.com/DSpace/DSpace/commit/4c1e4432d108fb5a32b95367f83aa71ac11a0dd3", "committedDate": "2020-07-29T13:14:07Z", "message": "Merge remote-tracking branch 'refs/remotes/origin/main'\n\nConflicts:\n\tdspace-api/src/main/java/org/dspace/submit/lookup/ArXivService.java\n\tdspace-api/src/main/java/org/dspace/submit/lookup/PubmedService.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1406a4c2e669b0dea1f9499eacfac033dbc7dddf", "author": {"user": {"login": "pasqualecvl", "name": "Pasquale Cavallo"}}, "url": "https://github.com/DSpace/DSpace/commit/1406a4c2e669b0dea1f9499eacfac033dbc7dddf", "committedDate": "2020-07-31T15:08:23Z", "message": "Update pom.xml, ArXivService.java, and PubmedService.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e35084cf239067f1118fcca5e3793aeda264d220", "author": {"user": {"login": "pasqualecvl", "name": "Pasquale Cavallo"}}, "url": "https://github.com/DSpace/DSpace/commit/e35084cf239067f1118fcca5e3793aeda264d220", "committedDate": "2020-07-31T15:13:18Z", "message": "rollback dspace.cfg changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "774e3893f9806b0da4f6c9606cd0e21f6d016932", "author": {"user": {"login": "pasqualecvl", "name": "Pasquale Cavallo"}}, "url": "https://github.com/DSpace/DSpace/commit/774e3893f9806b0da4f6c9606cd0e21f6d016932", "committedDate": "2020-08-03T12:22:48Z", "message": "Add fix from DS-4530"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ee5762c3492ee4bd9edfb3f650b88d70619fb6c", "author": {"user": {"login": "pasqualecvl", "name": "Pasquale Cavallo"}}, "url": "https://github.com/DSpace/DSpace/commit/9ee5762c3492ee4bd9edfb3f650b88d70619fb6c", "committedDate": "2020-08-03T13:20:50Z", "message": "return 400 in external source if no record were found"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bdcf064660b471b37061b33eb90b5927362c5e14", "author": {"user": {"login": "pasqualecvl", "name": "Pasquale Cavallo"}}, "url": "https://github.com/DSpace/DSpace/commit/bdcf064660b471b37061b33eb90b5927362c5e14", "committedDate": "2020-08-03T13:21:30Z", "message": "return 400 on arxiv in no record were found"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f1bd9ee811bf1be8fadd5444947076004916641", "author": {"user": {"login": "pasqualecvl", "name": "Pasquale Cavallo"}}, "url": "https://github.com/DSpace/DSpace/commit/1f1bd9ee811bf1be8fadd5444947076004916641", "committedDate": "2020-08-11T13:16:44Z", "message": "Merge branch 'main' into DS-4515_submit-external-source"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c733576f5010a48e089231a7560fa0832feac6f0", "author": {"user": {"login": "pasqualecvl", "name": "Pasquale Cavallo"}}, "url": "https://github.com/DSpace/DSpace/commit/c733576f5010a48e089231a7560fa0832feac6f0", "committedDate": "2020-08-12T13:37:51Z", "message": "Fix conflict"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "052e775bc532cd81d196b298b11fa855d7051183", "author": {"user": {"login": "pasqualecvl", "name": "Pasquale Cavallo"}}, "url": "https://github.com/DSpace/DSpace/commit/052e775bc532cd81d196b298b11fa855d7051183", "committedDate": "2020-08-12T14:48:38Z", "message": "Fix conflict on live import"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2NzM5MzE3", "url": "https://github.com/DSpace/DSpace/pull/2824#pullrequestreview-466739317", "createdAt": "2020-08-13T13:03:43Z", "commit": {"oid": "afd6436c5c3b65697692c741244b258f9a94546b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMzowMzo0M1rOHAKh4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMzowMzo0M1rOHAKh4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkzNDU2MA==", "bodyText": "Can you add the exception (resulting in a stack trace) to the log.error", "url": "https://github.com/DSpace/DSpace/pull/2824#discussion_r469934560", "createdAt": "2020-08-13T13:03:43Z", "author": {"login": "benbosman"}, "path": "dspace-api/src/main/java/org/dspace/importer/external/metadatamapping/contributor/SimpleXpathMetadatumContributor.java", "diffHunk": "@@ -157,12 +161,12 @@ public void setQuery(String query) {\n                 } else if (el instanceof OMText) {\n                     values.add(metadataFieldMapping.toDCValue(field, ((OMText) el).getText()));\n                 } else {\n-                    System.err.println(\"node of type: \" + el.getClass());\n+                    log.error(\"node of type: \" + el.getClass());\n                 }\n             }\n             return values;\n         } catch (JaxenException e) {\n-            System.err.println(query);\n+            log.error(query);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afd6436c5c3b65697692c741244b258f9a94546b"}, "originalPosition": 29}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ef44b15876c7ca9c5e36e96941167a0a3f61db8", "author": {"user": {"login": "pasqualecvl", "name": "Pasquale Cavallo"}}, "url": "https://github.com/DSpace/DSpace/commit/2ef44b15876c7ca9c5e36e96941167a0a3f61db8", "committedDate": "2020-08-13T14:35:21Z", "message": "lof exception in SimpleXPathMetadataContributor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe6f51d246fbd83482c4c29573d4d6dae4ebf858", "author": {"user": {"login": "pasqualecvl", "name": "Pasquale Cavallo"}}, "url": "https://github.com/DSpace/DSpace/commit/fe6f51d246fbd83482c4c29573d4d6dae4ebf858", "committedDate": "2020-08-13T15:01:25Z", "message": "Improve Java on ArXivImportMetadataSourceServiceImpl"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyNjE5ODU4", "url": "https://github.com/DSpace/DSpace/pull/2824#pullrequestreview-472619858", "createdAt": "2020-08-21T16:15:00Z", "commit": {"oid": "fe6f51d246fbd83482c4c29573d4d6dae4ebf858"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNjoxNTowMFrOHEzNbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNjoyNTo1NVrOHEzjlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc5NTM3NQ==", "bodyText": "This FIXME can be removed. You've already switched to using ExternalDataObject below", "url": "https://github.com/DSpace/DSpace/pull/2824#discussion_r474795375", "createdAt": "2020-08-21T16:15:00Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/LiveImportDataProvider.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+import org.dspace.importer.external.datamodel.ImportRecord;\n+import org.dspace.importer.external.exception.MetadataSourceException;\n+import org.dspace.importer.external.metadatamapping.MetadatumDTO;\n+import org.dspace.importer.external.service.components.QuerySource;\n+\n+/**\n+ * This class allows to configure a Live Import Provider as an External Data Provider\n+ * \n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ *\n+ */\n+public class LiveImportDataProvider implements ExternalDataProvider {\n+    /**\n+     * The {@link QuerySource} live import provider\n+     */\n+    private QuerySource querySource;\n+\n+    /**\n+     * An unique human readable identifier for this provider\n+     */\n+    private String sourceIdentifier;\n+\n+    private String recordIdMetadata;\n+\n+    private String displayMetadata = \"dc.title\";\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * This method set the SourceIdentifier for the ExternalDataProvider\n+     * @param sourceIdentifier   The UNIQUE sourceIdentifier to be set on any LiveImport data provider\n+     */\n+    public void setSourceIdentifier(String sourceIdentifier) {\n+        this.sourceIdentifier = sourceIdentifier;\n+    }\n+\n+    /**\n+     * This method set the MetadataSource for the ExternalDataProvider\n+     * @param metadataSource {@link org.dspace.importer.external.service.components.MetadataSource} implementation used to process the input data\n+     */\n+    public void setMetadataSource(QuerySource querySource) {\n+        this.querySource = querySource;\n+    }\n+\n+    /**\n+     * This method set dublin core identifier to use as metadata id\n+     * @param recordIdMetadata dublin core identifier to use as metadata id\n+     */\n+    public void setRecordIdMetadata(String recordIdMetadata) {\n+        this.recordIdMetadata = recordIdMetadata;\n+    }\n+\n+    /**\n+     * This method set the dublin core identifier to display the title\n+     * @param displayMetadata metadata to use as title\n+     */\n+    public void setDisplayMetadata(String displayMetadata) {\n+        this.displayMetadata = displayMetadata;\n+    }\n+\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+        try {\n+            ExternalDataObject externalDataObject = getExternalDataObject(querySource.getRecord(id));\n+            return Optional.of(externalDataObject);\n+        } catch (MetadataSourceException e) {\n+            throw new RuntimeException(\n+                    \"The live import provider \" + querySource.getImportSource() + \" throws an exception\", e);\n+        }\n+    }\n+\n+    @Override\n+    public List<ExternalDataObject> searchExternalDataObjects(String query, int start, int limit) {\n+        Collection<ImportRecord> records;\n+        try {\n+            records = querySource.getRecords(query, start, limit);\n+            return records.stream().map(r -> getExternalDataObject(r)).collect(Collectors.toList());\n+        } catch (MetadataSourceException e) {\n+            throw new RuntimeException(\n+                    \"The live import provider \" + querySource.getImportSource() + \" throws an exception\", e);\n+        }\n+    }\n+\n+    @Override\n+    public boolean supports(String source) {\n+        return StringUtils.equalsIgnoreCase(sourceIdentifier, source);\n+    }\n+\n+    @Override\n+    public int getNumberOfResults(String query) {\n+        try {\n+            return querySource.getRecordsCount(query);\n+        } catch (MetadataSourceException e) {\n+            throw new RuntimeException(\n+                    \"The live import provider \" + querySource.getImportSource() + \" throws an exception\", e);\n+        }\n+    }\n+\n+    /**\n+     * Internal method to convert an ImportRecord to an ExternalDataObject\n+     * \n+     * FIXME it would be useful to remove ImportRecord at all in favor of the\n+     * ExternalDataObject", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe6f51d246fbd83482c4c29573d4d6dae4ebf858"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc5NjY1MA==", "bodyText": "Based on discussion in the PR comments, I'd recommend we reword these comments to say:\n <!-- Required to support PubMed API call in \"PubmedImportMetadataSourceServiceImpl.GetRecord\" -->\nThis better clarifies the exact class which requires this dependency...so that we can ensure it gets updated as needed in the future.", "url": "https://github.com/DSpace/DSpace/pull/2824#discussion_r474796650", "createdAt": "2020-08-21T16:17:28Z", "author": {"login": "tdonohue"}, "path": "dspace-api/pom.xml", "diffHunk": "@@ -325,6 +325,14 @@\n             <artifactId>apache-jena-libs</artifactId>\n             <type>pom</type>\n         </dependency>\n+        <!-- This was added to support the pubmed api call -->\n+        <!-- Makes runtime operations in Jersey Dependency Injection -->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe6f51d246fbd83482c4c29573d4d6dae4ebf858"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc5OTI1OQ==", "bodyText": "I think this FIXME also might already be fixed?  It looks like you are using MetadataValueDTO", "url": "https://github.com/DSpace/DSpace/pull/2824#discussion_r474799259", "createdAt": "2020-08-21T16:22:24Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/LiveImportDataProvider.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+import org.dspace.importer.external.datamodel.ImportRecord;\n+import org.dspace.importer.external.exception.MetadataSourceException;\n+import org.dspace.importer.external.metadatamapping.MetadatumDTO;\n+import org.dspace.importer.external.service.components.QuerySource;\n+\n+/**\n+ * This class allows to configure a Live Import Provider as an External Data Provider\n+ * \n+ * @author Andrea Bollini (andrea.bollini at 4science.it)\n+ *\n+ */\n+public class LiveImportDataProvider implements ExternalDataProvider {\n+    /**\n+     * The {@link QuerySource} live import provider\n+     */\n+    private QuerySource querySource;\n+\n+    /**\n+     * An unique human readable identifier for this provider\n+     */\n+    private String sourceIdentifier;\n+\n+    private String recordIdMetadata;\n+\n+    private String displayMetadata = \"dc.title\";\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * This method set the SourceIdentifier for the ExternalDataProvider\n+     * @param sourceIdentifier   The UNIQUE sourceIdentifier to be set on any LiveImport data provider\n+     */\n+    public void setSourceIdentifier(String sourceIdentifier) {\n+        this.sourceIdentifier = sourceIdentifier;\n+    }\n+\n+    /**\n+     * This method set the MetadataSource for the ExternalDataProvider\n+     * @param metadataSource {@link org.dspace.importer.external.service.components.MetadataSource} implementation used to process the input data\n+     */\n+    public void setMetadataSource(QuerySource querySource) {\n+        this.querySource = querySource;\n+    }\n+\n+    /**\n+     * This method set dublin core identifier to use as metadata id\n+     * @param recordIdMetadata dublin core identifier to use as metadata id\n+     */\n+    public void setRecordIdMetadata(String recordIdMetadata) {\n+        this.recordIdMetadata = recordIdMetadata;\n+    }\n+\n+    /**\n+     * This method set the dublin core identifier to display the title\n+     * @param displayMetadata metadata to use as title\n+     */\n+    public void setDisplayMetadata(String displayMetadata) {\n+        this.displayMetadata = displayMetadata;\n+    }\n+\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+        try {\n+            ExternalDataObject externalDataObject = getExternalDataObject(querySource.getRecord(id));\n+            return Optional.of(externalDataObject);\n+        } catch (MetadataSourceException e) {\n+            throw new RuntimeException(\n+                    \"The live import provider \" + querySource.getImportSource() + \" throws an exception\", e);\n+        }\n+    }\n+\n+    @Override\n+    public List<ExternalDataObject> searchExternalDataObjects(String query, int start, int limit) {\n+        Collection<ImportRecord> records;\n+        try {\n+            records = querySource.getRecords(query, start, limit);\n+            return records.stream().map(r -> getExternalDataObject(r)).collect(Collectors.toList());\n+        } catch (MetadataSourceException e) {\n+            throw new RuntimeException(\n+                    \"The live import provider \" + querySource.getImportSource() + \" throws an exception\", e);\n+        }\n+    }\n+\n+    @Override\n+    public boolean supports(String source) {\n+        return StringUtils.equalsIgnoreCase(sourceIdentifier, source);\n+    }\n+\n+    @Override\n+    public int getNumberOfResults(String query) {\n+        try {\n+            return querySource.getRecordsCount(query);\n+        } catch (MetadataSourceException e) {\n+            throw new RuntimeException(\n+                    \"The live import provider \" + querySource.getImportSource() + \" throws an exception\", e);\n+        }\n+    }\n+\n+    /**\n+     * Internal method to convert an ImportRecord to an ExternalDataObject\n+     * \n+     * FIXME it would be useful to remove ImportRecord at all in favor of the\n+     * ExternalDataObject\n+     * \n+     * @param record\n+     * @return\n+     */\n+    private ExternalDataObject getExternalDataObject(ImportRecord record) {\n+        //return 400 if no record were found\n+        if (record == null) {\n+            throw new IllegalArgumentException(\"No record found for query or id\");\n+        }\n+        ExternalDataObject externalDataObject = new ExternalDataObject(sourceIdentifier);\n+        String id = getFirstValue(record, recordIdMetadata);\n+        String display = getFirstValue(record, displayMetadata);\n+        externalDataObject.setId(id);\n+        externalDataObject.setDisplayValue(display);\n+        externalDataObject.setValue(display);\n+        for (MetadatumDTO dto : record.getValueList()) {\n+            // FIXME it would be useful to remove MetadatumDTO in favor of MetadataValueDTO", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe6f51d246fbd83482c4c29573d4d6dae4ebf858"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgwMTA0NQ==", "bodyText": "I don't understand this JavaDoc description.  What is the \"path parameter\" you are talking about?\nIt looks to me like this parseValue method is replacing the value of all the MetadatumDTOs by parsing out just the ending of the existing value (removing anything before a slash).  Is that correct?  If so, we should update this JavaDocs to say that...or give an example of what the values look like before and after this method runs.", "url": "https://github.com/DSpace/DSpace/pull/2824#discussion_r474801045", "createdAt": "2020-08-21T16:25:55Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/importer/external/arxiv/metadatamapping/contributor/ArXivIdMetadataContributor.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.importer.external.arxiv.metadatamapping.contributor;\n+\n+import java.util.Collection;\n+\n+import org.apache.axiom.om.OMElement;\n+import org.dspace.importer.external.metadatamapping.MetadatumDTO;\n+import org.dspace.importer.external.metadatamapping.contributor.MetadataContributor;\n+import org.dspace.importer.external.metadatamapping.contributor.SimpleXpathMetadatumContributor;\n+\n+/**\n+ * Arxiv specific implementation of {@link MetadataContributor}\n+ * Responsible for generating the ArXiv Id from the retrieved item.\n+ * \n+ * @author Pasquale Cavallo (pasquale.cavallo at 4science dot it)\n+ *\n+ */\n+public class ArXivIdMetadataContributor extends SimpleXpathMetadatumContributor {\n+\n+    /**\n+     * Retrieve the metadata associated with the given object.\n+     * Depending on the retrieved node (using the query), different types of values will be added to the MetadatumDTO\n+     * list\n+     *\n+     * @param t A class to retrieve metadata from.\n+     * @return a collection of import records. Only the identifier of the found records may be put in the record.\n+     */\n+    @Override\n+    public Collection<MetadatumDTO> contributeMetadata(OMElement t) {\n+        Collection<MetadatumDTO> values = super.contributeMetadata(t);\n+        parseValue(values);\n+        return values;\n+    }\n+\n+    /**\n+     * ArXiv doesn't return the item id. We have to get this from the path parameter", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe6f51d246fbd83482c4c29573d4d6dae4ebf858"}, "originalPosition": 42}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fdc0cda30b065141ec6722d90bae4763bfe98624", "author": {"user": {"login": "pasqualecvl", "name": "Pasquale Cavallo"}}, "url": "https://github.com/DSpace/DSpace/commit/fdc0cda30b065141ec6722d90bae4763bfe98624", "committedDate": "2020-08-26T12:27:56Z", "message": "Update pom.xml\n\nAdd comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7422dafef5d511281b808a333785e5598aec5bc4", "author": {"user": {"login": "pasqualecvl", "name": "Pasquale Cavallo"}}, "url": "https://github.com/DSpace/DSpace/commit/7422dafef5d511281b808a333785e5598aec5bc4", "committedDate": "2020-08-27T14:22:29Z", "message": "Change javadoc on ArXivIdMetadataContributor.parseValue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "397bc1efcbc3b57a4e1a1601e4fc451f1d69a3e8", "author": {"user": {"login": "pasqualecvl", "name": "Pasquale Cavallo"}}, "url": "https://github.com/DSpace/DSpace/commit/397bc1efcbc3b57a4e1a1601e4fc451f1d69a3e8", "committedDate": "2020-08-27T14:23:13Z", "message": "Merge branch 'DS-4515_submit-external-source' of https://github.com/4Science/DSpace into DS-4515_submit-external-source"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4NzY5NjEz", "url": "https://github.com/DSpace/DSpace/pull/2824#pullrequestreview-478769613", "createdAt": "2020-08-31T16:38:56Z", "commit": {"oid": "397bc1efcbc3b57a4e1a1601e4fc451f1d69a3e8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4ODc5MTI4", "url": "https://github.com/DSpace/DSpace/pull/2824#pullrequestreview-478879128", "createdAt": "2020-08-31T19:09:11Z", "commit": {"oid": "397bc1efcbc3b57a4e1a1601e4fc451f1d69a3e8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxNjk0OTcw", "url": "https://github.com/DSpace/DSpace/pull/2824#pullrequestreview-481694970", "createdAt": "2020-09-03T10:11:46Z", "commit": {"oid": "397bc1efcbc3b57a4e1a1601e4fc451f1d69a3e8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMDoxMTo0NlrOHMf0Nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMDoxMTo0NlrOHMf0Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg2NjIzMQ==", "bodyText": "I assume this is a typing error, and it's not related to items?", "url": "https://github.com/DSpace/DSpace/pull/2824#discussion_r482866231", "createdAt": "2020-09-03T10:11:46Z", "author": {"login": "benbosman"}, "path": "dspace-api/src/main/java/org/dspace/importer/external/arxiv/metadatamapping/contributor/ArXivIdMetadataContributor.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.importer.external.arxiv.metadatamapping.contributor;\n+\n+import java.util.Collection;\n+\n+import org.apache.axiom.om.OMElement;\n+import org.dspace.importer.external.metadatamapping.MetadatumDTO;\n+import org.dspace.importer.external.metadatamapping.contributor.MetadataContributor;\n+import org.dspace.importer.external.metadatamapping.contributor.SimpleXpathMetadatumContributor;\n+\n+/**\n+ * Arxiv specific implementation of {@link MetadataContributor}\n+ * Responsible for generating the ArXiv Id from the retrieved item.\n+ * \n+ * @author Pasquale Cavallo (pasquale.cavallo at 4science dot it)\n+ *\n+ */\n+public class ArXivIdMetadataContributor extends SimpleXpathMetadatumContributor {\n+\n+    /**\n+     * Retrieve the metadata associated with the given object.\n+     * Depending on the retrieved node (using the query), different types of values will be added to the MetadatumDTO\n+     * list\n+     *\n+     * @param t A class to retrieve metadata from.\n+     * @return a collection of import records. Only the identifier of the found records may be put in the record.\n+     */\n+    @Override\n+    public Collection<MetadatumDTO> contributeMetadata(OMElement t) {\n+        Collection<MetadatumDTO> values = super.contributeMetadata(t);\n+        parseValue(values);\n+        return values;\n+    }\n+\n+    /**\n+     * ArXiv returns a full URL as in the <id> value, e.g. http://arxiv.org/abs/1911.11405v1.\n+     * This method parses out the identifier from the end of the URL, e.g. 1911.11405v1.\n+     * \n+     * @param dtos Metadata which contains the items uri\n+     * @return the items ids", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "397bc1efcbc3b57a4e1a1601e4fc451f1d69a3e8"}, "originalPosition": 46}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b4988d9d6df0b0c7dc87ed56e142be9d7bb736e", "author": {"user": {"login": "pasqualecvl", "name": "Pasquale Cavallo"}}, "url": "https://github.com/DSpace/DSpace/commit/1b4988d9d6df0b0c7dc87ed56e142be9d7bb736e", "committedDate": "2020-09-03T15:25:02Z", "message": "remove wrong comment"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyNDQ3NDg5", "url": "https://github.com/DSpace/DSpace/pull/2824#pullrequestreview-482447489", "createdAt": "2020-09-04T08:09:19Z", "commit": {"oid": "1b4988d9d6df0b0c7dc87ed56e142be9d7bb736e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1520, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}