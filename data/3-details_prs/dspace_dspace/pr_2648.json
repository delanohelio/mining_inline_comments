{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY1ODkwMzM4", "number": 2648, "title": "Scripts & processes: importing and exporting csv's", "bodyText": "This PR adds REST api support for the following 2 CLI scripts:\n\nmetadata-export\nmetadata-import\n\nBecause these imports use files (both as input and output), some REST changes were needed, these REST changes can be found here: DSpace/RestContract#99", "createdAt": "2020-01-22T14:41:32Z", "url": "https://github.com/DSpace/DSpace/pull/2648", "merged": true, "mergeCommit": {"oid": "88215a1581bd9203e20ae4db87ba89c52039c989"}, "closed": true, "closedAt": "2020-06-22T17:37:27Z", "author": {"login": "KevinVdV"}, "timelineItems": {"totalCount": 43, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABbo3poWgH2gAyMzY1ODkwMzM4OjA4YzdkYTQ0NDYxMDlhNDQwZTAyNjMyNjZjYzE3M2RiNGE2ZDg1Y2I=", "endCursor": "Y3Vyc29yOnYyOpPPAAABct0XmfgFqTQzNTEzNjY2NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "08c7da4446109a440e0263266cc173db4a6d85cb", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/08c7da4446109a440e0263266cc173db4a6d85cb", "committedDate": "2019-11-21T12:22:09Z", "message": "Implementing file import and export scripts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9733bd34413b62d0ded645c153d2eb95521ae837", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/9733bd34413b62d0ded645c153d2eb95521ae837", "committedDate": "2019-11-21T14:19:05Z", "message": "Merged master into this branch and fixed tests/issues with metadata-import"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "84775128b1ed5b768c24a1d18a5da972366a20ec", "author": {"user": {"login": "KevinVdV", "name": "Kevin Van de Velde"}}, "url": "https://github.com/DSpace/DSpace/commit/84775128b1ed5b768c24a1d18a5da972366a20ec", "committedDate": "2019-12-05T14:59:52Z", "message": "Adding missing MetadataExportServiceImpl to the core-services.xml file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e295a76c70a8f211531248957ceb27df2019a078", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/e295a76c70a8f211531248957ceb27df2019a078", "committedDate": "2019-12-10T15:13:54Z", "message": "[Task 66428] Applied feedback to the MetadataImport and Export scripts and framework"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "248e67f9a34713a93f7979987d3a108522db667c", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/248e67f9a34713a93f7979987d3a108522db667c", "committedDate": "2020-01-06T13:11:55Z", "message": "Merge remote-tracking branch 'dspace/master' into w2p-64428_scripts-prototype-importing-and-exporting\n\nConflicts:\n\tdspace-api/src/main/java/org/dspace/app/launcher/ScriptLauncher.java\n\tdspace-server-webapp/src/main/java/org/dspace/app/rest/ScriptProcessesController.java\n\tdspace-server-webapp/src/main/java/org/dspace/app/rest/scripts/handler/impl/RestDSpaceRunnableHandler.java\n\tdspace-server-webapp/src/test/java/org/dspace/app/scripts/handler/impl/TestDSpaceRunnableHandler.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a208058d387a2ec06c9153735e6deba15c0deded", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/a208058d387a2ec06c9153735e6deba15c0deded", "committedDate": "2020-01-06T13:12:08Z", "message": "Working on fixes test issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "24f5cf0896632c29e0631dfa0909fa0473f5ba1e", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/24f5cf0896632c29e0631dfa0909fa0473f5ba1e", "committedDate": "2020-01-09T14:03:42Z", "message": "Fixed tests in CSVMetadataImportReferenceTest and script bean issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "182a8f01f373d25031f9bc1a71c51e8ba8ddbae4", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/182a8f01f373d25031f9bc1a71c51e8ba8ddbae4", "committedDate": "2020-01-15T12:49:31Z", "message": "Applied feedback to the MetadataExport and MetadataImport scripts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d9e688d95ab065ed0c21a619a8cefb291123d1c", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/2d9e688d95ab065ed0c21a619a8cefb291123d1c", "committedDate": "2020-01-20T10:43:14Z", "message": "[Task 68281] applied feedback to the metadata-import and metadata-export scripts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "130db9531d871edc49af6412665babff082af7df", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/130db9531d871edc49af6412665babff082af7df", "committedDate": "2020-01-22T13:14:01Z", "message": "[Task 68380] added files and file endpoints to the Process endpoints"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5265ebd382097d221b9b9bfc2df708b5819f1fa0", "author": {"user": {"login": "KevinVdV", "name": "Kevin Van de Velde"}}, "url": "https://github.com/DSpace/DSpace/commit/5265ebd382097d221b9b9bfc2df708b5819f1fa0", "committedDate": "2020-01-22T13:53:42Z", "message": "Removing commented out code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzMTIwNzk1", "url": "https://github.com/DSpace/DSpace/pull/2648#pullrequestreview-353120795", "createdAt": "2020-02-04T16:31:00Z", "commit": {"oid": "5265ebd382097d221b9b9bfc2df708b5819f1fa0"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxNjozMTowMFrOFla1LA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxNzoxMjo1M1rOFlcWxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc4MTIyOA==", "bodyText": "I think you meant to import java.nio.charset.StandardCharsets here and use StandardCharsets.UTF_8 in the code later in this file.  It's a bit odd to be using PDFBox here, since obviously this CSV code has nothing to do with PDFs.", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r374781228", "createdAt": "2020-02-04T16:31:00Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/app/bulkedit/DSpaceCSV.java", "diffHunk": "@@ -27,7 +22,9 @@\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n+import org.apache.commons.io.IOUtils;\n import org.apache.commons.lang3.StringUtils;\n+import org.apache.pdfbox.util.Charsets;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5265ebd382097d221b9b9bfc2df708b5819f1fa0"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc4NDU2OQ==", "bodyText": "No method should complete() a Context that it does not create.  This could have unintended consequences (as a completed Context can no longer be used).", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r374784569", "createdAt": "2020-02-04T16:36:35Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/app/bulkedit/MetadataExport.java", "diffHunk": "@@ -7,272 +7,101 @@\n  */\n package org.dspace.app.bulkedit;\n \n+import java.io.OutputStream;\n import java.sql.SQLException;\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n \n-import com.google.common.collect.Iterators;\n-import org.apache.commons.cli.CommandLine;\n-import org.apache.commons.cli.CommandLineParser;\n-import org.apache.commons.cli.HelpFormatter;\n import org.apache.commons.cli.Options;\n import org.apache.commons.cli.ParseException;\n-import org.apache.commons.cli.PosixParser;\n-import org.dspace.content.Collection;\n-import org.dspace.content.Community;\n-import org.dspace.content.DSpaceObject;\n-import org.dspace.content.Item;\n-import org.dspace.content.factory.ContentServiceFactory;\n-import org.dspace.content.service.ItemService;\n-import org.dspace.core.Constants;\n+import org.dspace.content.service.MetadataDSpaceCsvExportService;\n import org.dspace.core.Context;\n-import org.dspace.handle.factory.HandleServiceFactory;\n+import org.dspace.eperson.service.EPersonService;\n+import org.dspace.scripts.DSpaceRunnable;\n+import org.springframework.beans.factory.annotation.Autowired;\n \n /**\n  * Metadata exporter to allow the batch export of metadata into a file\n  *\n  * @author Stuart Lewis\n  */\n-public class MetadataExport {\n-    /**\n-     * The items to export\n-     */\n-    protected Iterator<Item> toExport;\n+public class MetadataExport extends DSpaceRunnable {\n \n-    protected ItemService itemService;\n+    private Context context = null;\n+    private boolean help = false;\n+    private String filename = null;\n+    private String handle = null;\n+    private boolean exportAllMetadata = false;\n+    private boolean exportAllItems = false;\n \n-    protected Context context;\n+    @Autowired\n+    private MetadataDSpaceCsvExportService metadataDSpaceCsvExportService;\n \n-    /**\n-     * Whether to export all metadata, or just normally edited metadata\n-     */\n-    protected boolean exportAll;\n+    @Autowired\n+    private EPersonService ePersonService;\n \n-    protected MetadataExport() {\n-        itemService = ContentServiceFactory.getInstance().getItemService();\n+    private MetadataExport() {\n+        this.options = constructOptions();\n     }\n \n-    /**\n-     * Set up a new metadata export\n-     *\n-     * @param c         The Context\n-     * @param toExport  The ItemIterator of items to export\n-     * @param exportAll whether to export all metadata or not (include handle, provenance etc)\n-     */\n-    public MetadataExport(Context c, Iterator<Item> toExport, boolean exportAll) {\n-        itemService = ContentServiceFactory.getInstance().getItemService();\n-\n-        // Store the export settings\n-        this.toExport = toExport;\n-        this.exportAll = exportAll;\n-        this.context = c;\n-    }\n-\n-    /**\n-     * Method to export a community (and sub-communities and collections)\n-     *\n-     * @param c         The Context\n-     * @param toExport  The Community to export\n-     * @param exportAll whether to export all metadata or not (include handle, provenance etc)\n-     */\n-    public MetadataExport(Context c, Community toExport, boolean exportAll) {\n-        itemService = ContentServiceFactory.getInstance().getItemService();\n-\n-        try {\n-            // Try to export the community\n-            this.toExport = buildFromCommunity(c, toExport, 0);\n-            this.exportAll = exportAll;\n-            this.context = c;\n-        } catch (SQLException sqle) {\n-            // Something went wrong...\n-            System.err.println(\"Error running exporter:\");\n-            sqle.printStackTrace(System.err);\n-            System.exit(1);\n-        }\n-    }\n-\n-    /**\n-     * Build an array list of item ids that are in a community (include sub-communities and collections)\n-     *\n-     * @param context   DSpace context\n-     * @param community The community to build from\n-     * @param indent    How many spaces to use when writing out the names of items added\n-     * @return The list of item ids\n-     * @throws SQLException if database error\n-     */\n-    protected Iterator<Item> buildFromCommunity(Context context, Community community, int indent)\n-        throws SQLException {\n-        // Add all the collections\n-        List<Collection> collections = community.getCollections();\n-        Iterator<Item> result = null;\n-        for (Collection collection : collections) {\n-            for (int i = 0; i < indent; i++) {\n-                System.out.print(\" \");\n-            }\n-\n-            Iterator<Item> items = itemService.findByCollection(context, collection);\n-            result = addItemsToResult(result, items);\n-\n-        }\n-        // Add all the sub-communities\n-        List<Community> communities = community.getSubcommunities();\n-        for (Community subCommunity : communities) {\n-            for (int i = 0; i < indent; i++) {\n-                System.out.print(\" \");\n-            }\n-            Iterator<Item> items = buildFromCommunity(context, subCommunity, indent + 1);\n-            result = addItemsToResult(result, items);\n-        }\n-\n-        return result;\n-    }\n-\n-    private Iterator<Item> addItemsToResult(Iterator<Item> result, Iterator<Item> items) {\n-        if (result == null) {\n-            result = items;\n-        } else {\n-            result = Iterators.concat(result, items);\n-        }\n-\n-        return result;\n-    }\n-\n-    /**\n-     * Run the export\n-     *\n-     * @return the exported CSV lines\n-     */\n-    public DSpaceCSV export() {\n-        try {\n-            Context.Mode originalMode = context.getCurrentMode();\n-            context.setMode(Context.Mode.READ_ONLY);\n-\n-            // Process each item\n-            DSpaceCSV csv = new DSpaceCSV(exportAll);\n-            while (toExport.hasNext()) {\n-                Item item = toExport.next();\n-                csv.addItem(item);\n-                context.uncacheEntity(item);\n-            }\n-\n-            context.setMode(originalMode);\n-            // Return the results\n-            return csv;\n-        } catch (Exception e) {\n-            // Something went wrong...\n-            System.err.println(\"Error exporting to CSV:\");\n-            e.printStackTrace();\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * Print the help message\n-     *\n-     * @param options  The command line options the user gave\n-     * @param exitCode the system exit code to use\n-     */\n-    private static void printHelp(Options options, int exitCode) {\n-        // print the help message\n-        HelpFormatter myhelp = new HelpFormatter();\n-        myhelp.printHelp(\"MetadataExport\\n\", options);\n-        System.out.println(\"\\nfull export: metadataexport -f filename\");\n-        System.out.println(\"partial export: metadataexport -i handle -f filename\");\n-        System.exit(exitCode);\n-    }\n-\n-    /**\n-     * main method to run the metadata exporter\n-     *\n-     * @param argv the command line arguments given\n-     * @throws Exception if error occurs\n-     */\n-    public static void main(String[] argv) throws Exception {\n-        // Create an options object and populate it\n-        CommandLineParser parser = new PosixParser();\n-\n+    private Options constructOptions() {\n         Options options = new Options();\n \n         options.addOption(\"i\", \"id\", true, \"ID or handle of thing to export (item, collection, or community)\");\n+        options.getOption(\"i\").setType(String.class);\n         options.addOption(\"f\", \"file\", true, \"destination where you want file written\");\n+        options.getOption(\"f\").setType(OutputStream.class);\n+        options.getOption(\"f\").setRequired(true);\n         options.addOption(\"a\", \"all\", false,\n                           \"include all metadata fields that are not normally changed (e.g. provenance)\");\n+        options.getOption(\"a\").setType(boolean.class);\n         options.addOption(\"h\", \"help\", false, \"help\");\n+        options.getOption(\"h\").setType(boolean.class);\n \n-        CommandLine line = null;\n-\n-        try {\n-            line = parser.parse(options, argv);\n-        } catch (ParseException pe) {\n-            System.err.println(\"Error with commands.\");\n-            printHelp(options, 1);\n-            System.exit(0);\n-        }\n \n-        if (line.hasOption('h')) {\n-            printHelp(options, 0);\n-        }\n+        return options;\n+    }\n \n-        // Check a filename is given\n-        if (!line.hasOption('f')) {\n-            System.err.println(\"Required parameter -f missing!\");\n-            printHelp(options, 1);\n+    public void internalRun() throws Exception {\n+        if (help) {\n+            handler.logInfo(\"\\nfull export: metadata-export -f filename\");\n+            handler.logInfo(\"partial export: metadata-export -i handle -f filename\");\n+            printHelp();\n+            return;\n         }\n-        String filename = line.getOptionValue('f');\n \n-        // Create a context\n-        Context c = new Context(Context.Mode.READ_ONLY);\n-        c.turnOffAuthorisationSystem();\n-\n-        // The things we'll export\n-        Iterator<Item> toExport = null;\n-        MetadataExport exporter = null;\n+        DSpaceCSV dSpaceCSV = metadataDSpaceCsvExportService\n+            .handleExport(context, exportAllItems, exportAllMetadata, handle,\n+                          handler);\n+        handler.writeFilestream(context, filename, dSpaceCSV.getInputStream(), \"exportCSV\");\n+        context.restoreAuthSystemState();\n+        context.complete();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5265ebd382097d221b9b9bfc2df708b5819f1fa0"}, "originalPosition": 262}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc4NTg1MQ==", "bodyText": "We seem to be turning off Authorisation in this Context for a long time (which also could have unintended consequences). It's turned off here in the setup, but not restored again until internalRun() finishes up.  That means the context is not checking any authorizations during that entire time.\nOur best practice is to only use turnOffAuthorisationSystem() and restoreAuthSystemState() around small blocks of code. We should never leave authorization turned off between methods.", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r374785851", "createdAt": "2020-02-04T16:38:45Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/app/bulkedit/MetadataExport.java", "diffHunk": "@@ -7,272 +7,101 @@\n  */\n package org.dspace.app.bulkedit;\n \n+import java.io.OutputStream;\n import java.sql.SQLException;\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n \n-import com.google.common.collect.Iterators;\n-import org.apache.commons.cli.CommandLine;\n-import org.apache.commons.cli.CommandLineParser;\n-import org.apache.commons.cli.HelpFormatter;\n import org.apache.commons.cli.Options;\n import org.apache.commons.cli.ParseException;\n-import org.apache.commons.cli.PosixParser;\n-import org.dspace.content.Collection;\n-import org.dspace.content.Community;\n-import org.dspace.content.DSpaceObject;\n-import org.dspace.content.Item;\n-import org.dspace.content.factory.ContentServiceFactory;\n-import org.dspace.content.service.ItemService;\n-import org.dspace.core.Constants;\n+import org.dspace.content.service.MetadataDSpaceCsvExportService;\n import org.dspace.core.Context;\n-import org.dspace.handle.factory.HandleServiceFactory;\n+import org.dspace.eperson.service.EPersonService;\n+import org.dspace.scripts.DSpaceRunnable;\n+import org.springframework.beans.factory.annotation.Autowired;\n \n /**\n  * Metadata exporter to allow the batch export of metadata into a file\n  *\n  * @author Stuart Lewis\n  */\n-public class MetadataExport {\n-    /**\n-     * The items to export\n-     */\n-    protected Iterator<Item> toExport;\n+public class MetadataExport extends DSpaceRunnable {\n \n-    protected ItemService itemService;\n+    private Context context = null;\n+    private boolean help = false;\n+    private String filename = null;\n+    private String handle = null;\n+    private boolean exportAllMetadata = false;\n+    private boolean exportAllItems = false;\n \n-    protected Context context;\n+    @Autowired\n+    private MetadataDSpaceCsvExportService metadataDSpaceCsvExportService;\n \n-    /**\n-     * Whether to export all metadata, or just normally edited metadata\n-     */\n-    protected boolean exportAll;\n+    @Autowired\n+    private EPersonService ePersonService;\n \n-    protected MetadataExport() {\n-        itemService = ContentServiceFactory.getInstance().getItemService();\n+    private MetadataExport() {\n+        this.options = constructOptions();\n     }\n \n-    /**\n-     * Set up a new metadata export\n-     *\n-     * @param c         The Context\n-     * @param toExport  The ItemIterator of items to export\n-     * @param exportAll whether to export all metadata or not (include handle, provenance etc)\n-     */\n-    public MetadataExport(Context c, Iterator<Item> toExport, boolean exportAll) {\n-        itemService = ContentServiceFactory.getInstance().getItemService();\n-\n-        // Store the export settings\n-        this.toExport = toExport;\n-        this.exportAll = exportAll;\n-        this.context = c;\n-    }\n-\n-    /**\n-     * Method to export a community (and sub-communities and collections)\n-     *\n-     * @param c         The Context\n-     * @param toExport  The Community to export\n-     * @param exportAll whether to export all metadata or not (include handle, provenance etc)\n-     */\n-    public MetadataExport(Context c, Community toExport, boolean exportAll) {\n-        itemService = ContentServiceFactory.getInstance().getItemService();\n-\n-        try {\n-            // Try to export the community\n-            this.toExport = buildFromCommunity(c, toExport, 0);\n-            this.exportAll = exportAll;\n-            this.context = c;\n-        } catch (SQLException sqle) {\n-            // Something went wrong...\n-            System.err.println(\"Error running exporter:\");\n-            sqle.printStackTrace(System.err);\n-            System.exit(1);\n-        }\n-    }\n-\n-    /**\n-     * Build an array list of item ids that are in a community (include sub-communities and collections)\n-     *\n-     * @param context   DSpace context\n-     * @param community The community to build from\n-     * @param indent    How many spaces to use when writing out the names of items added\n-     * @return The list of item ids\n-     * @throws SQLException if database error\n-     */\n-    protected Iterator<Item> buildFromCommunity(Context context, Community community, int indent)\n-        throws SQLException {\n-        // Add all the collections\n-        List<Collection> collections = community.getCollections();\n-        Iterator<Item> result = null;\n-        for (Collection collection : collections) {\n-            for (int i = 0; i < indent; i++) {\n-                System.out.print(\" \");\n-            }\n-\n-            Iterator<Item> items = itemService.findByCollection(context, collection);\n-            result = addItemsToResult(result, items);\n-\n-        }\n-        // Add all the sub-communities\n-        List<Community> communities = community.getSubcommunities();\n-        for (Community subCommunity : communities) {\n-            for (int i = 0; i < indent; i++) {\n-                System.out.print(\" \");\n-            }\n-            Iterator<Item> items = buildFromCommunity(context, subCommunity, indent + 1);\n-            result = addItemsToResult(result, items);\n-        }\n-\n-        return result;\n-    }\n-\n-    private Iterator<Item> addItemsToResult(Iterator<Item> result, Iterator<Item> items) {\n-        if (result == null) {\n-            result = items;\n-        } else {\n-            result = Iterators.concat(result, items);\n-        }\n-\n-        return result;\n-    }\n-\n-    /**\n-     * Run the export\n-     *\n-     * @return the exported CSV lines\n-     */\n-    public DSpaceCSV export() {\n-        try {\n-            Context.Mode originalMode = context.getCurrentMode();\n-            context.setMode(Context.Mode.READ_ONLY);\n-\n-            // Process each item\n-            DSpaceCSV csv = new DSpaceCSV(exportAll);\n-            while (toExport.hasNext()) {\n-                Item item = toExport.next();\n-                csv.addItem(item);\n-                context.uncacheEntity(item);\n-            }\n-\n-            context.setMode(originalMode);\n-            // Return the results\n-            return csv;\n-        } catch (Exception e) {\n-            // Something went wrong...\n-            System.err.println(\"Error exporting to CSV:\");\n-            e.printStackTrace();\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * Print the help message\n-     *\n-     * @param options  The command line options the user gave\n-     * @param exitCode the system exit code to use\n-     */\n-    private static void printHelp(Options options, int exitCode) {\n-        // print the help message\n-        HelpFormatter myhelp = new HelpFormatter();\n-        myhelp.printHelp(\"MetadataExport\\n\", options);\n-        System.out.println(\"\\nfull export: metadataexport -f filename\");\n-        System.out.println(\"partial export: metadataexport -i handle -f filename\");\n-        System.exit(exitCode);\n-    }\n-\n-    /**\n-     * main method to run the metadata exporter\n-     *\n-     * @param argv the command line arguments given\n-     * @throws Exception if error occurs\n-     */\n-    public static void main(String[] argv) throws Exception {\n-        // Create an options object and populate it\n-        CommandLineParser parser = new PosixParser();\n-\n+    private Options constructOptions() {\n         Options options = new Options();\n \n         options.addOption(\"i\", \"id\", true, \"ID or handle of thing to export (item, collection, or community)\");\n+        options.getOption(\"i\").setType(String.class);\n         options.addOption(\"f\", \"file\", true, \"destination where you want file written\");\n+        options.getOption(\"f\").setType(OutputStream.class);\n+        options.getOption(\"f\").setRequired(true);\n         options.addOption(\"a\", \"all\", false,\n                           \"include all metadata fields that are not normally changed (e.g. provenance)\");\n+        options.getOption(\"a\").setType(boolean.class);\n         options.addOption(\"h\", \"help\", false, \"help\");\n+        options.getOption(\"h\").setType(boolean.class);\n \n-        CommandLine line = null;\n-\n-        try {\n-            line = parser.parse(options, argv);\n-        } catch (ParseException pe) {\n-            System.err.println(\"Error with commands.\");\n-            printHelp(options, 1);\n-            System.exit(0);\n-        }\n \n-        if (line.hasOption('h')) {\n-            printHelp(options, 0);\n-        }\n+        return options;\n+    }\n \n-        // Check a filename is given\n-        if (!line.hasOption('f')) {\n-            System.err.println(\"Required parameter -f missing!\");\n-            printHelp(options, 1);\n+    public void internalRun() throws Exception {\n+        if (help) {\n+            handler.logInfo(\"\\nfull export: metadata-export -f filename\");\n+            handler.logInfo(\"partial export: metadata-export -i handle -f filename\");\n+            printHelp();\n+            return;\n         }\n-        String filename = line.getOptionValue('f');\n \n-        // Create a context\n-        Context c = new Context(Context.Mode.READ_ONLY);\n-        c.turnOffAuthorisationSystem();\n-\n-        // The things we'll export\n-        Iterator<Item> toExport = null;\n-        MetadataExport exporter = null;\n+        DSpaceCSV dSpaceCSV = metadataDSpaceCsvExportService\n+            .handleExport(context, exportAllItems, exportAllMetadata, handle,\n+                          handler);\n+        handler.writeFilestream(context, filename, dSpaceCSV.getInputStream(), \"exportCSV\");\n+        context.restoreAuthSystemState();\n+        context.complete();\n+    }\n \n-        // Export everything?\n-        boolean exportAll = line.hasOption('a');\n+    public void setup() throws ParseException {\n+        context = new Context();\n+        context.turnOffAuthorisationSystem();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5265ebd382097d221b9b9bfc2df708b5819f1fa0"}, "originalPosition": 269}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc4NjU0Mw==", "bodyText": "I think this method (and others in this same file) is missing an @Override annotation", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r374786543", "createdAt": "2020-02-04T16:39:51Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/app/bulkedit/MetadataExport.java", "diffHunk": "@@ -7,272 +7,101 @@\n  */\n package org.dspace.app.bulkedit;\n \n+import java.io.OutputStream;\n import java.sql.SQLException;\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n \n-import com.google.common.collect.Iterators;\n-import org.apache.commons.cli.CommandLine;\n-import org.apache.commons.cli.CommandLineParser;\n-import org.apache.commons.cli.HelpFormatter;\n import org.apache.commons.cli.Options;\n import org.apache.commons.cli.ParseException;\n-import org.apache.commons.cli.PosixParser;\n-import org.dspace.content.Collection;\n-import org.dspace.content.Community;\n-import org.dspace.content.DSpaceObject;\n-import org.dspace.content.Item;\n-import org.dspace.content.factory.ContentServiceFactory;\n-import org.dspace.content.service.ItemService;\n-import org.dspace.core.Constants;\n+import org.dspace.content.service.MetadataDSpaceCsvExportService;\n import org.dspace.core.Context;\n-import org.dspace.handle.factory.HandleServiceFactory;\n+import org.dspace.eperson.service.EPersonService;\n+import org.dspace.scripts.DSpaceRunnable;\n+import org.springframework.beans.factory.annotation.Autowired;\n \n /**\n  * Metadata exporter to allow the batch export of metadata into a file\n  *\n  * @author Stuart Lewis\n  */\n-public class MetadataExport {\n-    /**\n-     * The items to export\n-     */\n-    protected Iterator<Item> toExport;\n+public class MetadataExport extends DSpaceRunnable {\n \n-    protected ItemService itemService;\n+    private Context context = null;\n+    private boolean help = false;\n+    private String filename = null;\n+    private String handle = null;\n+    private boolean exportAllMetadata = false;\n+    private boolean exportAllItems = false;\n \n-    protected Context context;\n+    @Autowired\n+    private MetadataDSpaceCsvExportService metadataDSpaceCsvExportService;\n \n-    /**\n-     * Whether to export all metadata, or just normally edited metadata\n-     */\n-    protected boolean exportAll;\n+    @Autowired\n+    private EPersonService ePersonService;\n \n-    protected MetadataExport() {\n-        itemService = ContentServiceFactory.getInstance().getItemService();\n+    private MetadataExport() {\n+        this.options = constructOptions();\n     }\n \n-    /**\n-     * Set up a new metadata export\n-     *\n-     * @param c         The Context\n-     * @param toExport  The ItemIterator of items to export\n-     * @param exportAll whether to export all metadata or not (include handle, provenance etc)\n-     */\n-    public MetadataExport(Context c, Iterator<Item> toExport, boolean exportAll) {\n-        itemService = ContentServiceFactory.getInstance().getItemService();\n-\n-        // Store the export settings\n-        this.toExport = toExport;\n-        this.exportAll = exportAll;\n-        this.context = c;\n-    }\n-\n-    /**\n-     * Method to export a community (and sub-communities and collections)\n-     *\n-     * @param c         The Context\n-     * @param toExport  The Community to export\n-     * @param exportAll whether to export all metadata or not (include handle, provenance etc)\n-     */\n-    public MetadataExport(Context c, Community toExport, boolean exportAll) {\n-        itemService = ContentServiceFactory.getInstance().getItemService();\n-\n-        try {\n-            // Try to export the community\n-            this.toExport = buildFromCommunity(c, toExport, 0);\n-            this.exportAll = exportAll;\n-            this.context = c;\n-        } catch (SQLException sqle) {\n-            // Something went wrong...\n-            System.err.println(\"Error running exporter:\");\n-            sqle.printStackTrace(System.err);\n-            System.exit(1);\n-        }\n-    }\n-\n-    /**\n-     * Build an array list of item ids that are in a community (include sub-communities and collections)\n-     *\n-     * @param context   DSpace context\n-     * @param community The community to build from\n-     * @param indent    How many spaces to use when writing out the names of items added\n-     * @return The list of item ids\n-     * @throws SQLException if database error\n-     */\n-    protected Iterator<Item> buildFromCommunity(Context context, Community community, int indent)\n-        throws SQLException {\n-        // Add all the collections\n-        List<Collection> collections = community.getCollections();\n-        Iterator<Item> result = null;\n-        for (Collection collection : collections) {\n-            for (int i = 0; i < indent; i++) {\n-                System.out.print(\" \");\n-            }\n-\n-            Iterator<Item> items = itemService.findByCollection(context, collection);\n-            result = addItemsToResult(result, items);\n-\n-        }\n-        // Add all the sub-communities\n-        List<Community> communities = community.getSubcommunities();\n-        for (Community subCommunity : communities) {\n-            for (int i = 0; i < indent; i++) {\n-                System.out.print(\" \");\n-            }\n-            Iterator<Item> items = buildFromCommunity(context, subCommunity, indent + 1);\n-            result = addItemsToResult(result, items);\n-        }\n-\n-        return result;\n-    }\n-\n-    private Iterator<Item> addItemsToResult(Iterator<Item> result, Iterator<Item> items) {\n-        if (result == null) {\n-            result = items;\n-        } else {\n-            result = Iterators.concat(result, items);\n-        }\n-\n-        return result;\n-    }\n-\n-    /**\n-     * Run the export\n-     *\n-     * @return the exported CSV lines\n-     */\n-    public DSpaceCSV export() {\n-        try {\n-            Context.Mode originalMode = context.getCurrentMode();\n-            context.setMode(Context.Mode.READ_ONLY);\n-\n-            // Process each item\n-            DSpaceCSV csv = new DSpaceCSV(exportAll);\n-            while (toExport.hasNext()) {\n-                Item item = toExport.next();\n-                csv.addItem(item);\n-                context.uncacheEntity(item);\n-            }\n-\n-            context.setMode(originalMode);\n-            // Return the results\n-            return csv;\n-        } catch (Exception e) {\n-            // Something went wrong...\n-            System.err.println(\"Error exporting to CSV:\");\n-            e.printStackTrace();\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * Print the help message\n-     *\n-     * @param options  The command line options the user gave\n-     * @param exitCode the system exit code to use\n-     */\n-    private static void printHelp(Options options, int exitCode) {\n-        // print the help message\n-        HelpFormatter myhelp = new HelpFormatter();\n-        myhelp.printHelp(\"MetadataExport\\n\", options);\n-        System.out.println(\"\\nfull export: metadataexport -f filename\");\n-        System.out.println(\"partial export: metadataexport -i handle -f filename\");\n-        System.exit(exitCode);\n-    }\n-\n-    /**\n-     * main method to run the metadata exporter\n-     *\n-     * @param argv the command line arguments given\n-     * @throws Exception if error occurs\n-     */\n-    public static void main(String[] argv) throws Exception {\n-        // Create an options object and populate it\n-        CommandLineParser parser = new PosixParser();\n-\n+    private Options constructOptions() {\n         Options options = new Options();\n \n         options.addOption(\"i\", \"id\", true, \"ID or handle of thing to export (item, collection, or community)\");\n+        options.getOption(\"i\").setType(String.class);\n         options.addOption(\"f\", \"file\", true, \"destination where you want file written\");\n+        options.getOption(\"f\").setType(OutputStream.class);\n+        options.getOption(\"f\").setRequired(true);\n         options.addOption(\"a\", \"all\", false,\n                           \"include all metadata fields that are not normally changed (e.g. provenance)\");\n+        options.getOption(\"a\").setType(boolean.class);\n         options.addOption(\"h\", \"help\", false, \"help\");\n+        options.getOption(\"h\").setType(boolean.class);\n \n-        CommandLine line = null;\n-\n-        try {\n-            line = parser.parse(options, argv);\n-        } catch (ParseException pe) {\n-            System.err.println(\"Error with commands.\");\n-            printHelp(options, 1);\n-            System.exit(0);\n-        }\n \n-        if (line.hasOption('h')) {\n-            printHelp(options, 0);\n-        }\n+        return options;\n+    }\n \n-        // Check a filename is given\n-        if (!line.hasOption('f')) {\n-            System.err.println(\"Required parameter -f missing!\");\n-            printHelp(options, 1);\n+    public void internalRun() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5265ebd382097d221b9b9bfc2df708b5819f1fa0"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc4NzgzMw==", "bodyText": "Again, not a best practice. This method is completing a Context it didn't create.", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r374787833", "createdAt": "2020-02-04T16:41:51Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/app/bulkedit/MetadataImport.java", "diffHunk": "@@ -167,21 +178,201 @@\n      * @param c        The context\n      * @param toImport An array of CSV lines to examine\n      */\n-    public MetadataImport(Context c, DSpaceCSV toImport) {\n+    public void initMetadataImport(DSpaceCSV toImport) {\n         // Store the import settings\n-        this.c = c;\n-        csv = toImport;\n         this.toImport = toImport.getCSVLines();\n-        installItemService = ContentServiceFactory.getInstance().getInstallItemService();\n-        itemService = ContentServiceFactory.getInstance().getItemService();\n-        collectionService = ContentServiceFactory.getInstance().getCollectionService();\n-        handleService = HandleServiceFactory.getInstance().getHandleService();\n-        authorityValueService = AuthorityServiceFactory.getInstance().getAuthorityValueService();\n-        workspaceItemService = ContentServiceFactory.getInstance().getWorkspaceItemService();\n-        relationshipService = ContentServiceFactory.getInstance().getRelationshipService();\n-        relationshipTypeService = ContentServiceFactory.getInstance().getRelationshipTypeService();\n-        entityTypeService = ContentServiceFactory.getInstance().getEntityTypeService();\n-        entityService = ContentServiceFactory.getInstance().getEntityService();\n+    }\n+\n+    @Override\n+    public void internalRun() throws Exception {\n+        if (help) {\n+            printHelp();\n+            return;\n+        }\n+        // Read commandLines from the CSV file\n+        try {\n+\n+            Optional<InputStream> optionalFileStream = handler.getFileStream(c, filename);\n+            if (optionalFileStream.isPresent()) {\n+                csv = new DSpaceCSV(optionalFileStream.get(), c);\n+            } else {\n+                throw new IllegalArgumentException(\"Error reading file, the file couldn't be found for filename: \" +\n+                                                       filename);\n+            }\n+        } catch (MetadataImportInvalidHeadingException miihe) {\n+            throw miihe;\n+        } catch (Exception e) {\n+            throw new Exception(\"Error reading file: \" + e.getMessage(), e);\n+        }\n+\n+        // Perform the first import - just highlight differences\n+        initMetadataImport(csv);\n+        List<BulkEditChange> changes;\n+\n+        if (!commandLine.hasOption('s') || validateOnly) {\n+            // See what has changed\n+            try {\n+                changes = runImport(false, useWorkflow, workflowNotify, useTemplate);\n+            } catch (MetadataImportException mie) {\n+                throw mie;\n+            }\n+\n+            // Display the changes\n+            int changeCounter = displayChanges(changes, false);\n+\n+            // If there were changes, ask if we should execute them\n+            if (!validateOnly && changeCounter > 0) {\n+                try {\n+                    // Ask the user if they want to make the changes\n+                    handler.logInfo(\"\\n\" + changeCounter + \" item(s) will be changed\\n\");\n+                    change = determineChange(handler);\n+\n+                } catch (IOException ioe) {\n+                    throw new IOException(\"Error: \" + ioe.getMessage() + \", No changes have been made\", ioe);\n+                }\n+            } else {\n+                handler.logInfo(\"There were no changes detected\");\n+            }\n+        } else {\n+            change = true;\n+        }\n+\n+        try {\n+            // If required, make the change\n+            if (change && !validateOnly) {\n+                try {\n+                    // Make the changes\n+                    changes = runImport(true, useWorkflow, workflowNotify, useTemplate);\n+                } catch (MetadataImportException mie) {\n+                    throw mie;\n+                }\n+\n+                // Display the changes\n+                displayChanges(changes, true);\n+            }\n+\n+            // Finsh off and tidy up\n+            c.restoreAuthSystemState();\n+            c.complete();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5265ebd382097d221b9b9bfc2df708b5819f1fa0"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc4ODIyNw==", "bodyText": "Again, we are turning off all authorization checks and leaving them off until internalRun gets called. This is a bad practice.", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r374788227", "createdAt": "2020-02-04T16:42:29Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/app/bulkedit/MetadataImport.java", "diffHunk": "@@ -167,21 +178,201 @@\n      * @param c        The context\n      * @param toImport An array of CSV lines to examine\n      */\n-    public MetadataImport(Context c, DSpaceCSV toImport) {\n+    public void initMetadataImport(DSpaceCSV toImport) {\n         // Store the import settings\n-        this.c = c;\n-        csv = toImport;\n         this.toImport = toImport.getCSVLines();\n-        installItemService = ContentServiceFactory.getInstance().getInstallItemService();\n-        itemService = ContentServiceFactory.getInstance().getItemService();\n-        collectionService = ContentServiceFactory.getInstance().getCollectionService();\n-        handleService = HandleServiceFactory.getInstance().getHandleService();\n-        authorityValueService = AuthorityServiceFactory.getInstance().getAuthorityValueService();\n-        workspaceItemService = ContentServiceFactory.getInstance().getWorkspaceItemService();\n-        relationshipService = ContentServiceFactory.getInstance().getRelationshipService();\n-        relationshipTypeService = ContentServiceFactory.getInstance().getRelationshipTypeService();\n-        entityTypeService = ContentServiceFactory.getInstance().getEntityTypeService();\n-        entityService = ContentServiceFactory.getInstance().getEntityService();\n+    }\n+\n+    @Override\n+    public void internalRun() throws Exception {\n+        if (help) {\n+            printHelp();\n+            return;\n+        }\n+        // Read commandLines from the CSV file\n+        try {\n+\n+            Optional<InputStream> optionalFileStream = handler.getFileStream(c, filename);\n+            if (optionalFileStream.isPresent()) {\n+                csv = new DSpaceCSV(optionalFileStream.get(), c);\n+            } else {\n+                throw new IllegalArgumentException(\"Error reading file, the file couldn't be found for filename: \" +\n+                                                       filename);\n+            }\n+        } catch (MetadataImportInvalidHeadingException miihe) {\n+            throw miihe;\n+        } catch (Exception e) {\n+            throw new Exception(\"Error reading file: \" + e.getMessage(), e);\n+        }\n+\n+        // Perform the first import - just highlight differences\n+        initMetadataImport(csv);\n+        List<BulkEditChange> changes;\n+\n+        if (!commandLine.hasOption('s') || validateOnly) {\n+            // See what has changed\n+            try {\n+                changes = runImport(false, useWorkflow, workflowNotify, useTemplate);\n+            } catch (MetadataImportException mie) {\n+                throw mie;\n+            }\n+\n+            // Display the changes\n+            int changeCounter = displayChanges(changes, false);\n+\n+            // If there were changes, ask if we should execute them\n+            if (!validateOnly && changeCounter > 0) {\n+                try {\n+                    // Ask the user if they want to make the changes\n+                    handler.logInfo(\"\\n\" + changeCounter + \" item(s) will be changed\\n\");\n+                    change = determineChange(handler);\n+\n+                } catch (IOException ioe) {\n+                    throw new IOException(\"Error: \" + ioe.getMessage() + \", No changes have been made\", ioe);\n+                }\n+            } else {\n+                handler.logInfo(\"There were no changes detected\");\n+            }\n+        } else {\n+            change = true;\n+        }\n+\n+        try {\n+            // If required, make the change\n+            if (change && !validateOnly) {\n+                try {\n+                    // Make the changes\n+                    changes = runImport(true, useWorkflow, workflowNotify, useTemplate);\n+                } catch (MetadataImportException mie) {\n+                    throw mie;\n+                }\n+\n+                // Display the changes\n+                displayChanges(changes, true);\n+            }\n+\n+            // Finsh off and tidy up\n+            c.restoreAuthSystemState();\n+            c.complete();\n+        } catch (Exception e) {\n+            c.abort();\n+            throw new Exception(\n+                \"Error committing changes to database: \" + e.getMessage() + \", aborting most recent changes\", e);\n+        }\n+\n+    }\n+\n+    /**\n+     * This method determines whether the changes should be applied or not. This is default set to true for the REST\n+     * script as we don't want to interact with the caller. This will be overwritten in the CLI script to ask for\n+     * confirmation\n+     * @param handler   Applicable DSpaceRunnableHandler\n+     * @return boolean indicating the value\n+     * @throws IOException  If something goes wrong\n+     */\n+    protected boolean determineChange(DSpaceRunnableHandler handler) throws IOException {\n+        return true;\n+    }\n+\n+    public void setup() throws ParseException {\n+        useTemplate = false;\n+        filename = null;\n+        useWorkflow = false;\n+        workflowNotify = false;\n+\n+        if (commandLine.hasOption('h')) {\n+            help = true;\n+            return;\n+        }\n+\n+        // Check a filename is given\n+        if (!commandLine.hasOption('f')) {\n+            throw new ParseException(\"Required parameter -f missing!\");\n+        }\n+        filename = commandLine.getOptionValue('f');\n+\n+        // Option to apply template to new items\n+        if (commandLine.hasOption('t')) {\n+            useTemplate = true;\n+        }\n+\n+        // Options for workflows, and workflow notifications for new items\n+        if (commandLine.hasOption('w')) {\n+            useWorkflow = true;\n+            if (commandLine.hasOption('n')) {\n+                workflowNotify = true;\n+            }\n+        } else if (commandLine.hasOption('n')) {\n+            throw new ParseException(\n+                \"Invalid option 'n': (notify) can only be specified with the 'w' (workflow) option.\");\n+        }\n+        validateOnly = commandLine.hasOption('v');\n+\n+\n+        // Create a context\n+        try {\n+            c = new Context();\n+            c.turnOffAuthorisationSystem();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5265ebd382097d221b9b9bfc2df708b5819f1fa0"}, "originalPosition": 272}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc5MjQ1NA==", "bodyText": "Could we describe what the \"epersonIdentifier\" is?  I'm assuming this should actually say something like \"Get the UUID of the EPerson that the script is running as\"?\nSame for setEpersonIdentifier() method below....what the \"epersonIdentifier\" refers to is not currently clear to me. But, I think it likely is the EPerson this script is running as.", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r374792454", "createdAt": "2020-02-04T16:49:22Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/scripts/DSpaceRunnable.java", "diffHunk": "@@ -153,4 +170,32 @@ public boolean isAllowedToExecute(Context context) {\n         }\n         return false;\n     }\n+\n+    public void setBeanName(String beanName) {\n+        this.name = beanName;\n+    }\n+\n+    /**\n+     * Generic getter for the name\n+     * @return the name value of this DSpaceRunnable\n+     */\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     * Generic getter for the epersonIdentifier", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5265ebd382097d221b9b9bfc2df708b5819f1fa0"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc5OTYzMw==", "bodyText": "Please rename this class...this is not a generic controller for the processes endpoint, as it looks like most of those requests would use ProcessRestRepository.  Instead, this should be updated to specifically deal with  /processes/files subresource.  So, maybe this should be:\n@RequestMapping(\"/api\" + ProcessRest.CATEGORY + \"/\" + ProcessRest.PLURAL_NAME + \"/files)\npublic class ProcessFilesRestController {", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r374799633", "createdAt": "2020-02-04T17:01:14Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/ProcessRestController.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.springframework.hateoas.mvc.ControllerLinkBuilder.linkTo;\n+import static org.springframework.hateoas.mvc.ControllerLinkBuilder.methodOn;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.rest.link.HalLinkService;\n+import org.dspace.app.rest.link.process.ProcessResourceHalLinkFactory;\n+import org.dspace.app.rest.model.BitstreamRest;\n+import org.dspace.app.rest.model.ProcessRest;\n+import org.dspace.app.rest.model.hateoas.BitstreamResource;\n+import org.dspace.app.rest.model.hateoas.ProcessFileWrapperResource;\n+import org.dspace.app.rest.repository.ProcessRestRepository;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.authorize.AuthorizeException;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.data.web.PagedResourcesAssembler;\n+import org.springframework.hateoas.Link;\n+import org.springframework.hateoas.PagedResources;\n+import org.springframework.web.bind.annotation.PathVariable;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RequestMethod;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+@RestController\n+@RequestMapping(\"/api/\" + ProcessRest.CATEGORY + \"/\" + ProcessRest.PLURAL_NAME)\n+public class ProcessRestController {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5265ebd382097d221b9b9bfc2df708b5819f1fa0"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDgwMDI5MQ==", "bodyText": "I'm assuming each of these methods should have @PreAuthorize annotations to access restrict files in some way?", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r374800291", "createdAt": "2020-02-04T17:02:21Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/ProcessRestController.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.springframework.hateoas.mvc.ControllerLinkBuilder.linkTo;\n+import static org.springframework.hateoas.mvc.ControllerLinkBuilder.methodOn;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.rest.link.HalLinkService;\n+import org.dspace.app.rest.link.process.ProcessResourceHalLinkFactory;\n+import org.dspace.app.rest.model.BitstreamRest;\n+import org.dspace.app.rest.model.ProcessRest;\n+import org.dspace.app.rest.model.hateoas.BitstreamResource;\n+import org.dspace.app.rest.model.hateoas.ProcessFileWrapperResource;\n+import org.dspace.app.rest.repository.ProcessRestRepository;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.authorize.AuthorizeException;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.data.web.PagedResourcesAssembler;\n+import org.springframework.hateoas.Link;\n+import org.springframework.hateoas.PagedResources;\n+import org.springframework.web.bind.annotation.PathVariable;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RequestMethod;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+@RestController\n+@RequestMapping(\"/api/\" + ProcessRest.CATEGORY + \"/\" + ProcessRest.PLURAL_NAME)\n+public class ProcessRestController {\n+\n+    private static final Logger log = LogManager.getLogger();\n+\n+    @Autowired\n+    HalLinkService linkService;\n+\n+    @Autowired\n+    private ProcessRestRepository processRestRepository;\n+\n+    @Autowired\n+    private Utils utils;\n+\n+    @Autowired\n+    private HalLinkService halLinkService;\n+\n+    @Autowired\n+    ProcessResourceHalLinkFactory processResourceHalLinkFactory;\n+\n+    @RequestMapping(method = RequestMethod.GET, value = \"/{processId}/files\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5265ebd382097d221b9b9bfc2df708b5819f1fa0"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDgwMDY1MA==", "bodyText": "This class is missing JavaDocs...as are the methods.", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r374800650", "createdAt": "2020-02-04T17:03:01Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/model/ProcessFileWrapperRest.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.model;\n+\n+import java.util.List;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+\n+public class ProcessFileWrapperRest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5265ebd382097d221b9b9bfc2df708b5819f1fa0"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDgwMDc3Ng==", "bodyText": "This class is also missing JavaDocs", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r374800776", "createdAt": "2020-02-04T17:03:14Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/model/hateoas/ProcessFileWrapperResource.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.model.hateoas;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.dspace.app.rest.model.BitstreamRest;\n+import org.dspace.app.rest.model.MetadataValueRest;\n+import org.dspace.app.rest.model.ProcessFileWrapperRest;\n+import org.dspace.app.rest.utils.Utils;\n+\n+\n+public class ProcessFileWrapperResource extends HALResource<ProcessFileWrapperRest> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5265ebd382097d221b9b9bfc2df708b5819f1fa0"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDgwMTE0OA==", "bodyText": "Please add JavaDocs to all the new methods in this class", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r374801148", "createdAt": "2020-02-04T17:03:48Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/ProcessRestRepository.java", "diffHunk": "@@ -59,6 +77,64 @@ public ProcessRest findOne(Context context, Integer id) {\n         }\n     }\n \n+    public List<BitstreamRest> getProcessBitstreams(Integer processId) throws SQLException, AuthorizeException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5265ebd382097d221b9b9bfc2df708b5819f1fa0"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDgwNDI3MQ==", "bodyText": "This should have a scope note, as its purpose is unclear...and it sounds like we do not want people to use this field. I'm also not sure I like having a schema with a single metadata field.  We should think about creating a dspace schema for fields that are internal, rather than creating new schemas every time we need an internal field.", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r374804271", "createdAt": "2020-02-04T17:09:24Z", "author": {"login": "tdonohue"}, "path": "dspace/config/registries/process-types.xml", "diffHunk": "@@ -0,0 +1,20 @@\n+<dspace-dc-types>\n+\n+    <dspace-header>\n+        <title>DSpace Process Types</title>\n+    </dspace-header>\n+\n+    <dc-schema>\n+        <name>process</name>\n+        <namespace>http://dspace.org/process</namespace>\n+    </dc-schema>\n+\n+    <dc-type>\n+        <schema>process</schema>\n+        <element>type</element>\n+        <qualifier></qualifier>\n+        <scope_note></scope_note>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5265ebd382097d221b9b9bfc2df708b5819f1fa0"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDgwNjIxMg==", "bodyText": "Since this \"type\" of \"exportCSV\" is going to end up saved into a metadata field (process.type), should we consider using a constant for the value (maybe in the Process class or similar?).  It seems odd to hardcode it if the value means something to the Process.", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r374806212", "createdAt": "2020-02-04T17:12:53Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/app/bulkedit/MetadataExport.java", "diffHunk": "@@ -7,272 +7,101 @@\n  */\n package org.dspace.app.bulkedit;\n \n+import java.io.OutputStream;\n import java.sql.SQLException;\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n \n-import com.google.common.collect.Iterators;\n-import org.apache.commons.cli.CommandLine;\n-import org.apache.commons.cli.CommandLineParser;\n-import org.apache.commons.cli.HelpFormatter;\n import org.apache.commons.cli.Options;\n import org.apache.commons.cli.ParseException;\n-import org.apache.commons.cli.PosixParser;\n-import org.dspace.content.Collection;\n-import org.dspace.content.Community;\n-import org.dspace.content.DSpaceObject;\n-import org.dspace.content.Item;\n-import org.dspace.content.factory.ContentServiceFactory;\n-import org.dspace.content.service.ItemService;\n-import org.dspace.core.Constants;\n+import org.dspace.content.service.MetadataDSpaceCsvExportService;\n import org.dspace.core.Context;\n-import org.dspace.handle.factory.HandleServiceFactory;\n+import org.dspace.eperson.service.EPersonService;\n+import org.dspace.scripts.DSpaceRunnable;\n+import org.springframework.beans.factory.annotation.Autowired;\n \n /**\n  * Metadata exporter to allow the batch export of metadata into a file\n  *\n  * @author Stuart Lewis\n  */\n-public class MetadataExport {\n-    /**\n-     * The items to export\n-     */\n-    protected Iterator<Item> toExport;\n+public class MetadataExport extends DSpaceRunnable {\n \n-    protected ItemService itemService;\n+    private Context context = null;\n+    private boolean help = false;\n+    private String filename = null;\n+    private String handle = null;\n+    private boolean exportAllMetadata = false;\n+    private boolean exportAllItems = false;\n \n-    protected Context context;\n+    @Autowired\n+    private MetadataDSpaceCsvExportService metadataDSpaceCsvExportService;\n \n-    /**\n-     * Whether to export all metadata, or just normally edited metadata\n-     */\n-    protected boolean exportAll;\n+    @Autowired\n+    private EPersonService ePersonService;\n \n-    protected MetadataExport() {\n-        itemService = ContentServiceFactory.getInstance().getItemService();\n+    private MetadataExport() {\n+        this.options = constructOptions();\n     }\n \n-    /**\n-     * Set up a new metadata export\n-     *\n-     * @param c         The Context\n-     * @param toExport  The ItemIterator of items to export\n-     * @param exportAll whether to export all metadata or not (include handle, provenance etc)\n-     */\n-    public MetadataExport(Context c, Iterator<Item> toExport, boolean exportAll) {\n-        itemService = ContentServiceFactory.getInstance().getItemService();\n-\n-        // Store the export settings\n-        this.toExport = toExport;\n-        this.exportAll = exportAll;\n-        this.context = c;\n-    }\n-\n-    /**\n-     * Method to export a community (and sub-communities and collections)\n-     *\n-     * @param c         The Context\n-     * @param toExport  The Community to export\n-     * @param exportAll whether to export all metadata or not (include handle, provenance etc)\n-     */\n-    public MetadataExport(Context c, Community toExport, boolean exportAll) {\n-        itemService = ContentServiceFactory.getInstance().getItemService();\n-\n-        try {\n-            // Try to export the community\n-            this.toExport = buildFromCommunity(c, toExport, 0);\n-            this.exportAll = exportAll;\n-            this.context = c;\n-        } catch (SQLException sqle) {\n-            // Something went wrong...\n-            System.err.println(\"Error running exporter:\");\n-            sqle.printStackTrace(System.err);\n-            System.exit(1);\n-        }\n-    }\n-\n-    /**\n-     * Build an array list of item ids that are in a community (include sub-communities and collections)\n-     *\n-     * @param context   DSpace context\n-     * @param community The community to build from\n-     * @param indent    How many spaces to use when writing out the names of items added\n-     * @return The list of item ids\n-     * @throws SQLException if database error\n-     */\n-    protected Iterator<Item> buildFromCommunity(Context context, Community community, int indent)\n-        throws SQLException {\n-        // Add all the collections\n-        List<Collection> collections = community.getCollections();\n-        Iterator<Item> result = null;\n-        for (Collection collection : collections) {\n-            for (int i = 0; i < indent; i++) {\n-                System.out.print(\" \");\n-            }\n-\n-            Iterator<Item> items = itemService.findByCollection(context, collection);\n-            result = addItemsToResult(result, items);\n-\n-        }\n-        // Add all the sub-communities\n-        List<Community> communities = community.getSubcommunities();\n-        for (Community subCommunity : communities) {\n-            for (int i = 0; i < indent; i++) {\n-                System.out.print(\" \");\n-            }\n-            Iterator<Item> items = buildFromCommunity(context, subCommunity, indent + 1);\n-            result = addItemsToResult(result, items);\n-        }\n-\n-        return result;\n-    }\n-\n-    private Iterator<Item> addItemsToResult(Iterator<Item> result, Iterator<Item> items) {\n-        if (result == null) {\n-            result = items;\n-        } else {\n-            result = Iterators.concat(result, items);\n-        }\n-\n-        return result;\n-    }\n-\n-    /**\n-     * Run the export\n-     *\n-     * @return the exported CSV lines\n-     */\n-    public DSpaceCSV export() {\n-        try {\n-            Context.Mode originalMode = context.getCurrentMode();\n-            context.setMode(Context.Mode.READ_ONLY);\n-\n-            // Process each item\n-            DSpaceCSV csv = new DSpaceCSV(exportAll);\n-            while (toExport.hasNext()) {\n-                Item item = toExport.next();\n-                csv.addItem(item);\n-                context.uncacheEntity(item);\n-            }\n-\n-            context.setMode(originalMode);\n-            // Return the results\n-            return csv;\n-        } catch (Exception e) {\n-            // Something went wrong...\n-            System.err.println(\"Error exporting to CSV:\");\n-            e.printStackTrace();\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * Print the help message\n-     *\n-     * @param options  The command line options the user gave\n-     * @param exitCode the system exit code to use\n-     */\n-    private static void printHelp(Options options, int exitCode) {\n-        // print the help message\n-        HelpFormatter myhelp = new HelpFormatter();\n-        myhelp.printHelp(\"MetadataExport\\n\", options);\n-        System.out.println(\"\\nfull export: metadataexport -f filename\");\n-        System.out.println(\"partial export: metadataexport -i handle -f filename\");\n-        System.exit(exitCode);\n-    }\n-\n-    /**\n-     * main method to run the metadata exporter\n-     *\n-     * @param argv the command line arguments given\n-     * @throws Exception if error occurs\n-     */\n-    public static void main(String[] argv) throws Exception {\n-        // Create an options object and populate it\n-        CommandLineParser parser = new PosixParser();\n-\n+    private Options constructOptions() {\n         Options options = new Options();\n \n         options.addOption(\"i\", \"id\", true, \"ID or handle of thing to export (item, collection, or community)\");\n+        options.getOption(\"i\").setType(String.class);\n         options.addOption(\"f\", \"file\", true, \"destination where you want file written\");\n+        options.getOption(\"f\").setType(OutputStream.class);\n+        options.getOption(\"f\").setRequired(true);\n         options.addOption(\"a\", \"all\", false,\n                           \"include all metadata fields that are not normally changed (e.g. provenance)\");\n+        options.getOption(\"a\").setType(boolean.class);\n         options.addOption(\"h\", \"help\", false, \"help\");\n+        options.getOption(\"h\").setType(boolean.class);\n \n-        CommandLine line = null;\n-\n-        try {\n-            line = parser.parse(options, argv);\n-        } catch (ParseException pe) {\n-            System.err.println(\"Error with commands.\");\n-            printHelp(options, 1);\n-            System.exit(0);\n-        }\n \n-        if (line.hasOption('h')) {\n-            printHelp(options, 0);\n-        }\n+        return options;\n+    }\n \n-        // Check a filename is given\n-        if (!line.hasOption('f')) {\n-            System.err.println(\"Required parameter -f missing!\");\n-            printHelp(options, 1);\n+    public void internalRun() throws Exception {\n+        if (help) {\n+            handler.logInfo(\"\\nfull export: metadata-export -f filename\");\n+            handler.logInfo(\"partial export: metadata-export -i handle -f filename\");\n+            printHelp();\n+            return;\n         }\n-        String filename = line.getOptionValue('f');\n \n-        // Create a context\n-        Context c = new Context(Context.Mode.READ_ONLY);\n-        c.turnOffAuthorisationSystem();\n-\n-        // The things we'll export\n-        Iterator<Item> toExport = null;\n-        MetadataExport exporter = null;\n+        DSpaceCSV dSpaceCSV = metadataDSpaceCsvExportService\n+            .handleExport(context, exportAllItems, exportAllMetadata, handle,\n+                          handler);\n+        handler.writeFilestream(context, filename, dSpaceCSV.getInputStream(), \"exportCSV\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5265ebd382097d221b9b9bfc2df708b5819f1fa0"}, "originalPosition": 260}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "90073abfb7b7ffec2482751dd6ad92939ec874b0", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/90073abfb7b7ffec2482751dd6ad92939ec874b0", "committedDate": "2020-02-11T11:41:48Z", "message": "[Task 68534] applied feedback to the metadata import and export script and wrote tests for them"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMjQ3NjI4", "url": "https://github.com/DSpace/DSpace/pull/2648#pullrequestreview-362247628", "createdAt": "2020-02-20T21:30:37Z", "commit": {"oid": "90073abfb7b7ffec2482751dd6ad92939ec874b0"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQwOToxNDowMlrOFtKT4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQwOToxNDowMlrOFtKT4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg5OTE2OQ==", "bodyText": "if this attribute hold information related to a specific execution this imply that the bean needs to be declared as prototype or we need to force a single thread model. Both options are suboptimal, am I misreading?", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r382899169", "createdAt": "2020-02-22T09:14:02Z", "author": {"login": "abollini"}, "path": "dspace-api/src/main/java/org/dspace/scripts/DSpaceRunnable.java", "diffHunk": "@@ -24,8 +31,9 @@\n  * it provides the basic variables to be hold by the script as well as the means to initialize, parse and run the script\n  * Every DSpaceRunnable that is implemented in this way should be defined in the scripts.xml config file as a bean\n  */\n-public abstract class DSpaceRunnable implements Runnable {\n+public abstract class DSpaceRunnable implements Runnable, BeanNameAware {\n \n+    private UUID epersonIdentifier;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90073abfb7b7ffec2482751dd6ad92939ec874b0"}, "originalPosition": 30}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c5285109e97fd5b9a6fe4a4cecc75545216bd1a5", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/c5285109e97fd5b9a6fe4a4cecc75545216bd1a5", "committedDate": "2020-03-23T10:32:01Z", "message": "Merge remote-tracking branch 'dspace/master' into w2p-64428_scripts-prototype-importing-and-exporting\n\nConflicts:\n\tdspace-server-webapp/src/main/java/org/dspace/app/rest/link/process/ProcessResourceHalLinkFactory.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e9d56e7c4146e718c5dfb32b369a1dbaf00f69cb", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/e9d56e7c4146e718c5dfb32b369a1dbaf00f69cb", "committedDate": "2020-03-23T13:13:11Z", "message": "[Task 69724] Scripts&Processes: split configuration and runnable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "25ca31f8cf7a0e4da0bef4da4f812d51102228f9", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/25ca31f8cf7a0e4da0bef4da4f812d51102228f9", "committedDate": "2020-03-23T13:44:55Z", "message": "[Task 69724] Scripts&Processes: cleanup and javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0232916dc5c04503f1ba08e082585a00b77f8d70", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/0232916dc5c04503f1ba08e082585a00b77f8d70", "committedDate": "2020-03-27T14:03:05Z", "message": "[Task 70080] applying feedback to scripts and processes splitting config and runnable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "95f1124de55299825ce55aedd9a889aaabae63ca", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/95f1124de55299825ce55aedd9a889aaabae63ca", "committedDate": "2020-03-30T09:36:42Z", "message": "[Task 70080] implemented generics and DSpaceRunnableClass definition on Spring level and fixed ITs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4031e41a5dca40bd64d15052decd4906deea22c6", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/4031e41a5dca40bd64d15052decd4906deea22c6", "committedDate": "2020-04-06T08:41:51Z", "message": "[Task 70080] applied feedback to the scripts and processes functionality"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "861cdfb2b852a69347e467c2eb435f3f82a86528", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/861cdfb2b852a69347e467c2eb435f3f82a86528", "committedDate": "2020-05-06T09:02:47Z", "message": "[Task 70080] applied feedback to the scripts prototype"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e6a746404724e2591cb059f9712cc1029b846a4", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/9e6a746404724e2591cb059f9712cc1029b846a4", "committedDate": "2020-05-06T09:49:23Z", "message": "Merge remote-tracking branch 'dspace/master' into w2p-64428_scripts-prototype-importing-and-exporting\n\nConflicts:\n\tdspace-server-webapp/src/main/java/org/dspace/app/rest/ScriptProcessesController.java\n\tdspace-server-webapp/src/main/java/org/dspace/app/rest/model/ParameterRest.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e212192afa81f1da2fb393e3f02320c41947e27", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/5e212192afa81f1da2fb393e3f02320c41947e27", "committedDate": "2020-05-06T09:49:39Z", "message": "[Task 70050] fixes after master merge"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "026c2308eccf07a5f60dbf9572c264c028598f48", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/026c2308eccf07a5f60dbf9572c264c028598f48", "committedDate": "2020-05-06T14:38:27Z", "message": "[Task 70750] made the Bitstream findAll endpoint not implemented"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyOTUwNzYx", "url": "https://github.com/DSpace/DSpace/pull/2648#pullrequestreview-412950761", "createdAt": "2020-05-15T20:34:58Z", "commit": {"oid": "026c2308eccf07a5f60dbf9572c264c028598f48"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQyMDozNDo1OFrOGWTESQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQyMDo1NToxNlrOGWTj4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAzNDI0OQ==", "bodyText": "This is still unresolved.  It looks like you should be importing java.nio.charset.StandardCharsets here, as this code has nothing to do with PDFBox or PDFs.", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r426034249", "createdAt": "2020-05-15T20:34:58Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/app/bulkedit/DSpaceCSV.java", "diffHunk": "@@ -27,7 +22,9 @@\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n+import org.apache.commons.io.IOUtils;\n import org.apache.commons.lang3.StringUtils;\n+import org.apache.pdfbox.util.Charsets;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc4MTIyOA=="}, "originalCommit": {"oid": "5265ebd382097d221b9b9bfc2df708b5819f1fa0"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAzNTU2Mw==", "bodyText": "Once you update the import to be StandardCharsets, this line should likely replace \"UTF-8\" with StandardCharsets.UTF_8 for consistency.", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r426035563", "createdAt": "2020-05-15T20:38:08Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/app/bulkedit/DSpaceCSV.java", "diffHunk": "@@ -141,18 +138,18 @@ public DSpaceCSV(boolean exportAll) {\n     /**\n      * Create a new instance, reading the lines in from file\n      *\n-     * @param f The file to read from\n+     * @param inputStream the inputstream to read from\n      * @param c The DSpace Context\n      * @throws Exception thrown if there is an error reading or processing the file\n      */\n-    public DSpaceCSV(File f, Context c) throws Exception {\n+    public DSpaceCSV(InputStream inputStream, Context c) throws Exception {\n         // Initialise the class\n         init();\n \n         // Open the CSV file\n         BufferedReader input = null;\n         try {\n-            input = new BufferedReader(new InputStreamReader(new FileInputStream(f), \"UTF-8\"));\n+            input = new BufferedReader(new InputStreamReader(inputStream, \"UTF-8\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "026c2308eccf07a5f60dbf9572c264c028598f48"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAzNTU5OQ==", "bodyText": "Please add JavaDocs to this new public method.", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r426035599", "createdAt": "2020-05-15T20:38:14Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/app/bulkedit/DSpaceCSV.java", "diffHunk": "@@ -622,22 +619,12 @@ public final void addItem(String line) throws Exception {\n         return csvLines;\n     }\n \n-    /**\n-     * Save the CSV file to the given filename\n-     *\n-     * @param filename The filename to save the CSV file to\n-     * @throws IOException Thrown if an error occurs when writing the file\n-     */\n-    public final void save(String filename) throws IOException {\n-        // Save the file\n-        BufferedWriter out = new BufferedWriter(\n-            new OutputStreamWriter(\n-                new FileOutputStream(filename), \"UTF-8\"));\n+    public InputStream getInputStream() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "026c2308eccf07a5f60dbf9572c264c028598f48"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAzNTc5OA==", "bodyText": "Again, still missing an @Override here I believe.", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r426035798", "createdAt": "2020-05-15T20:38:41Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/app/bulkedit/MetadataExport.java", "diffHunk": "@@ -7,272 +7,101 @@\n  */\n package org.dspace.app.bulkedit;\n \n+import java.io.OutputStream;\n import java.sql.SQLException;\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n \n-import com.google.common.collect.Iterators;\n-import org.apache.commons.cli.CommandLine;\n-import org.apache.commons.cli.CommandLineParser;\n-import org.apache.commons.cli.HelpFormatter;\n import org.apache.commons.cli.Options;\n import org.apache.commons.cli.ParseException;\n-import org.apache.commons.cli.PosixParser;\n-import org.dspace.content.Collection;\n-import org.dspace.content.Community;\n-import org.dspace.content.DSpaceObject;\n-import org.dspace.content.Item;\n-import org.dspace.content.factory.ContentServiceFactory;\n-import org.dspace.content.service.ItemService;\n-import org.dspace.core.Constants;\n+import org.dspace.content.service.MetadataDSpaceCsvExportService;\n import org.dspace.core.Context;\n-import org.dspace.handle.factory.HandleServiceFactory;\n+import org.dspace.eperson.service.EPersonService;\n+import org.dspace.scripts.DSpaceRunnable;\n+import org.springframework.beans.factory.annotation.Autowired;\n \n /**\n  * Metadata exporter to allow the batch export of metadata into a file\n  *\n  * @author Stuart Lewis\n  */\n-public class MetadataExport {\n-    /**\n-     * The items to export\n-     */\n-    protected Iterator<Item> toExport;\n+public class MetadataExport extends DSpaceRunnable {\n \n-    protected ItemService itemService;\n+    private Context context = null;\n+    private boolean help = false;\n+    private String filename = null;\n+    private String handle = null;\n+    private boolean exportAllMetadata = false;\n+    private boolean exportAllItems = false;\n \n-    protected Context context;\n+    @Autowired\n+    private MetadataDSpaceCsvExportService metadataDSpaceCsvExportService;\n \n-    /**\n-     * Whether to export all metadata, or just normally edited metadata\n-     */\n-    protected boolean exportAll;\n+    @Autowired\n+    private EPersonService ePersonService;\n \n-    protected MetadataExport() {\n-        itemService = ContentServiceFactory.getInstance().getItemService();\n+    private MetadataExport() {\n+        this.options = constructOptions();\n     }\n \n-    /**\n-     * Set up a new metadata export\n-     *\n-     * @param c         The Context\n-     * @param toExport  The ItemIterator of items to export\n-     * @param exportAll whether to export all metadata or not (include handle, provenance etc)\n-     */\n-    public MetadataExport(Context c, Iterator<Item> toExport, boolean exportAll) {\n-        itemService = ContentServiceFactory.getInstance().getItemService();\n-\n-        // Store the export settings\n-        this.toExport = toExport;\n-        this.exportAll = exportAll;\n-        this.context = c;\n-    }\n-\n-    /**\n-     * Method to export a community (and sub-communities and collections)\n-     *\n-     * @param c         The Context\n-     * @param toExport  The Community to export\n-     * @param exportAll whether to export all metadata or not (include handle, provenance etc)\n-     */\n-    public MetadataExport(Context c, Community toExport, boolean exportAll) {\n-        itemService = ContentServiceFactory.getInstance().getItemService();\n-\n-        try {\n-            // Try to export the community\n-            this.toExport = buildFromCommunity(c, toExport, 0);\n-            this.exportAll = exportAll;\n-            this.context = c;\n-        } catch (SQLException sqle) {\n-            // Something went wrong...\n-            System.err.println(\"Error running exporter:\");\n-            sqle.printStackTrace(System.err);\n-            System.exit(1);\n-        }\n-    }\n-\n-    /**\n-     * Build an array list of item ids that are in a community (include sub-communities and collections)\n-     *\n-     * @param context   DSpace context\n-     * @param community The community to build from\n-     * @param indent    How many spaces to use when writing out the names of items added\n-     * @return The list of item ids\n-     * @throws SQLException if database error\n-     */\n-    protected Iterator<Item> buildFromCommunity(Context context, Community community, int indent)\n-        throws SQLException {\n-        // Add all the collections\n-        List<Collection> collections = community.getCollections();\n-        Iterator<Item> result = null;\n-        for (Collection collection : collections) {\n-            for (int i = 0; i < indent; i++) {\n-                System.out.print(\" \");\n-            }\n-\n-            Iterator<Item> items = itemService.findByCollection(context, collection);\n-            result = addItemsToResult(result, items);\n-\n-        }\n-        // Add all the sub-communities\n-        List<Community> communities = community.getSubcommunities();\n-        for (Community subCommunity : communities) {\n-            for (int i = 0; i < indent; i++) {\n-                System.out.print(\" \");\n-            }\n-            Iterator<Item> items = buildFromCommunity(context, subCommunity, indent + 1);\n-            result = addItemsToResult(result, items);\n-        }\n-\n-        return result;\n-    }\n-\n-    private Iterator<Item> addItemsToResult(Iterator<Item> result, Iterator<Item> items) {\n-        if (result == null) {\n-            result = items;\n-        } else {\n-            result = Iterators.concat(result, items);\n-        }\n-\n-        return result;\n-    }\n-\n-    /**\n-     * Run the export\n-     *\n-     * @return the exported CSV lines\n-     */\n-    public DSpaceCSV export() {\n-        try {\n-            Context.Mode originalMode = context.getCurrentMode();\n-            context.setMode(Context.Mode.READ_ONLY);\n-\n-            // Process each item\n-            DSpaceCSV csv = new DSpaceCSV(exportAll);\n-            while (toExport.hasNext()) {\n-                Item item = toExport.next();\n-                csv.addItem(item);\n-                context.uncacheEntity(item);\n-            }\n-\n-            context.setMode(originalMode);\n-            // Return the results\n-            return csv;\n-        } catch (Exception e) {\n-            // Something went wrong...\n-            System.err.println(\"Error exporting to CSV:\");\n-            e.printStackTrace();\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * Print the help message\n-     *\n-     * @param options  The command line options the user gave\n-     * @param exitCode the system exit code to use\n-     */\n-    private static void printHelp(Options options, int exitCode) {\n-        // print the help message\n-        HelpFormatter myhelp = new HelpFormatter();\n-        myhelp.printHelp(\"MetadataExport\\n\", options);\n-        System.out.println(\"\\nfull export: metadataexport -f filename\");\n-        System.out.println(\"partial export: metadataexport -i handle -f filename\");\n-        System.exit(exitCode);\n-    }\n-\n-    /**\n-     * main method to run the metadata exporter\n-     *\n-     * @param argv the command line arguments given\n-     * @throws Exception if error occurs\n-     */\n-    public static void main(String[] argv) throws Exception {\n-        // Create an options object and populate it\n-        CommandLineParser parser = new PosixParser();\n-\n+    private Options constructOptions() {\n         Options options = new Options();\n \n         options.addOption(\"i\", \"id\", true, \"ID or handle of thing to export (item, collection, or community)\");\n+        options.getOption(\"i\").setType(String.class);\n         options.addOption(\"f\", \"file\", true, \"destination where you want file written\");\n+        options.getOption(\"f\").setType(OutputStream.class);\n+        options.getOption(\"f\").setRequired(true);\n         options.addOption(\"a\", \"all\", false,\n                           \"include all metadata fields that are not normally changed (e.g. provenance)\");\n+        options.getOption(\"a\").setType(boolean.class);\n         options.addOption(\"h\", \"help\", false, \"help\");\n+        options.getOption(\"h\").setType(boolean.class);\n \n-        CommandLine line = null;\n-\n-        try {\n-            line = parser.parse(options, argv);\n-        } catch (ParseException pe) {\n-            System.err.println(\"Error with commands.\");\n-            printHelp(options, 1);\n-            System.exit(0);\n-        }\n \n-        if (line.hasOption('h')) {\n-            printHelp(options, 0);\n-        }\n+        return options;\n+    }\n \n-        // Check a filename is given\n-        if (!line.hasOption('f')) {\n-            System.err.println(\"Required parameter -f missing!\");\n-            printHelp(options, 1);\n+    public void internalRun() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc4NjU0Mw=="}, "originalCommit": {"oid": "5265ebd382097d221b9b9bfc2df708b5819f1fa0"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAzNjkwMA==", "bodyText": "Again, please resolve prior feedback here.", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r426036900", "createdAt": "2020-05-15T20:41:23Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/app/bulkedit/MetadataExport.java", "diffHunk": "@@ -7,272 +7,101 @@\n  */\n package org.dspace.app.bulkedit;\n \n+import java.io.OutputStream;\n import java.sql.SQLException;\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n \n-import com.google.common.collect.Iterators;\n-import org.apache.commons.cli.CommandLine;\n-import org.apache.commons.cli.CommandLineParser;\n-import org.apache.commons.cli.HelpFormatter;\n import org.apache.commons.cli.Options;\n import org.apache.commons.cli.ParseException;\n-import org.apache.commons.cli.PosixParser;\n-import org.dspace.content.Collection;\n-import org.dspace.content.Community;\n-import org.dspace.content.DSpaceObject;\n-import org.dspace.content.Item;\n-import org.dspace.content.factory.ContentServiceFactory;\n-import org.dspace.content.service.ItemService;\n-import org.dspace.core.Constants;\n+import org.dspace.content.service.MetadataDSpaceCsvExportService;\n import org.dspace.core.Context;\n-import org.dspace.handle.factory.HandleServiceFactory;\n+import org.dspace.eperson.service.EPersonService;\n+import org.dspace.scripts.DSpaceRunnable;\n+import org.springframework.beans.factory.annotation.Autowired;\n \n /**\n  * Metadata exporter to allow the batch export of metadata into a file\n  *\n  * @author Stuart Lewis\n  */\n-public class MetadataExport {\n-    /**\n-     * The items to export\n-     */\n-    protected Iterator<Item> toExport;\n+public class MetadataExport extends DSpaceRunnable {\n \n-    protected ItemService itemService;\n+    private Context context = null;\n+    private boolean help = false;\n+    private String filename = null;\n+    private String handle = null;\n+    private boolean exportAllMetadata = false;\n+    private boolean exportAllItems = false;\n \n-    protected Context context;\n+    @Autowired\n+    private MetadataDSpaceCsvExportService metadataDSpaceCsvExportService;\n \n-    /**\n-     * Whether to export all metadata, or just normally edited metadata\n-     */\n-    protected boolean exportAll;\n+    @Autowired\n+    private EPersonService ePersonService;\n \n-    protected MetadataExport() {\n-        itemService = ContentServiceFactory.getInstance().getItemService();\n+    private MetadataExport() {\n+        this.options = constructOptions();\n     }\n \n-    /**\n-     * Set up a new metadata export\n-     *\n-     * @param c         The Context\n-     * @param toExport  The ItemIterator of items to export\n-     * @param exportAll whether to export all metadata or not (include handle, provenance etc)\n-     */\n-    public MetadataExport(Context c, Iterator<Item> toExport, boolean exportAll) {\n-        itemService = ContentServiceFactory.getInstance().getItemService();\n-\n-        // Store the export settings\n-        this.toExport = toExport;\n-        this.exportAll = exportAll;\n-        this.context = c;\n-    }\n-\n-    /**\n-     * Method to export a community (and sub-communities and collections)\n-     *\n-     * @param c         The Context\n-     * @param toExport  The Community to export\n-     * @param exportAll whether to export all metadata or not (include handle, provenance etc)\n-     */\n-    public MetadataExport(Context c, Community toExport, boolean exportAll) {\n-        itemService = ContentServiceFactory.getInstance().getItemService();\n-\n-        try {\n-            // Try to export the community\n-            this.toExport = buildFromCommunity(c, toExport, 0);\n-            this.exportAll = exportAll;\n-            this.context = c;\n-        } catch (SQLException sqle) {\n-            // Something went wrong...\n-            System.err.println(\"Error running exporter:\");\n-            sqle.printStackTrace(System.err);\n-            System.exit(1);\n-        }\n-    }\n-\n-    /**\n-     * Build an array list of item ids that are in a community (include sub-communities and collections)\n-     *\n-     * @param context   DSpace context\n-     * @param community The community to build from\n-     * @param indent    How many spaces to use when writing out the names of items added\n-     * @return The list of item ids\n-     * @throws SQLException if database error\n-     */\n-    protected Iterator<Item> buildFromCommunity(Context context, Community community, int indent)\n-        throws SQLException {\n-        // Add all the collections\n-        List<Collection> collections = community.getCollections();\n-        Iterator<Item> result = null;\n-        for (Collection collection : collections) {\n-            for (int i = 0; i < indent; i++) {\n-                System.out.print(\" \");\n-            }\n-\n-            Iterator<Item> items = itemService.findByCollection(context, collection);\n-            result = addItemsToResult(result, items);\n-\n-        }\n-        // Add all the sub-communities\n-        List<Community> communities = community.getSubcommunities();\n-        for (Community subCommunity : communities) {\n-            for (int i = 0; i < indent; i++) {\n-                System.out.print(\" \");\n-            }\n-            Iterator<Item> items = buildFromCommunity(context, subCommunity, indent + 1);\n-            result = addItemsToResult(result, items);\n-        }\n-\n-        return result;\n-    }\n-\n-    private Iterator<Item> addItemsToResult(Iterator<Item> result, Iterator<Item> items) {\n-        if (result == null) {\n-            result = items;\n-        } else {\n-            result = Iterators.concat(result, items);\n-        }\n-\n-        return result;\n-    }\n-\n-    /**\n-     * Run the export\n-     *\n-     * @return the exported CSV lines\n-     */\n-    public DSpaceCSV export() {\n-        try {\n-            Context.Mode originalMode = context.getCurrentMode();\n-            context.setMode(Context.Mode.READ_ONLY);\n-\n-            // Process each item\n-            DSpaceCSV csv = new DSpaceCSV(exportAll);\n-            while (toExport.hasNext()) {\n-                Item item = toExport.next();\n-                csv.addItem(item);\n-                context.uncacheEntity(item);\n-            }\n-\n-            context.setMode(originalMode);\n-            // Return the results\n-            return csv;\n-        } catch (Exception e) {\n-            // Something went wrong...\n-            System.err.println(\"Error exporting to CSV:\");\n-            e.printStackTrace();\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * Print the help message\n-     *\n-     * @param options  The command line options the user gave\n-     * @param exitCode the system exit code to use\n-     */\n-    private static void printHelp(Options options, int exitCode) {\n-        // print the help message\n-        HelpFormatter myhelp = new HelpFormatter();\n-        myhelp.printHelp(\"MetadataExport\\n\", options);\n-        System.out.println(\"\\nfull export: metadataexport -f filename\");\n-        System.out.println(\"partial export: metadataexport -i handle -f filename\");\n-        System.exit(exitCode);\n-    }\n-\n-    /**\n-     * main method to run the metadata exporter\n-     *\n-     * @param argv the command line arguments given\n-     * @throws Exception if error occurs\n-     */\n-    public static void main(String[] argv) throws Exception {\n-        // Create an options object and populate it\n-        CommandLineParser parser = new PosixParser();\n-\n+    private Options constructOptions() {\n         Options options = new Options();\n \n         options.addOption(\"i\", \"id\", true, \"ID or handle of thing to export (item, collection, or community)\");\n+        options.getOption(\"i\").setType(String.class);\n         options.addOption(\"f\", \"file\", true, \"destination where you want file written\");\n+        options.getOption(\"f\").setType(OutputStream.class);\n+        options.getOption(\"f\").setRequired(true);\n         options.addOption(\"a\", \"all\", false,\n                           \"include all metadata fields that are not normally changed (e.g. provenance)\");\n+        options.getOption(\"a\").setType(boolean.class);\n         options.addOption(\"h\", \"help\", false, \"help\");\n+        options.getOption(\"h\").setType(boolean.class);\n \n-        CommandLine line = null;\n-\n-        try {\n-            line = parser.parse(options, argv);\n-        } catch (ParseException pe) {\n-            System.err.println(\"Error with commands.\");\n-            printHelp(options, 1);\n-            System.exit(0);\n-        }\n \n-        if (line.hasOption('h')) {\n-            printHelp(options, 0);\n-        }\n+        return options;\n+    }\n \n-        // Check a filename is given\n-        if (!line.hasOption('f')) {\n-            System.err.println(\"Required parameter -f missing!\");\n-            printHelp(options, 1);\n+    public void internalRun() throws Exception {\n+        if (help) {\n+            handler.logInfo(\"\\nfull export: metadata-export -f filename\");\n+            handler.logInfo(\"partial export: metadata-export -i handle -f filename\");\n+            printHelp();\n+            return;\n         }\n-        String filename = line.getOptionValue('f');\n \n-        // Create a context\n-        Context c = new Context(Context.Mode.READ_ONLY);\n-        c.turnOffAuthorisationSystem();\n-\n-        // The things we'll export\n-        Iterator<Item> toExport = null;\n-        MetadataExport exporter = null;\n+        DSpaceCSV dSpaceCSV = metadataDSpaceCsvExportService\n+            .handleExport(context, exportAllItems, exportAllMetadata, handle,\n+                          handler);\n+        handler.writeFilestream(context, filename, dSpaceCSV.getInputStream(), \"exportCSV\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDgwNjIxMg=="}, "originalCommit": {"oid": "5265ebd382097d221b9b9bfc2df708b5819f1fa0"}, "originalPosition": 260}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAzNjk2MA==", "bodyText": "Again, please resolve prior feedback here.", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r426036960", "createdAt": "2020-05-15T20:41:34Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/app/bulkedit/MetadataExport.java", "diffHunk": "@@ -7,272 +7,101 @@\n  */\n package org.dspace.app.bulkedit;\n \n+import java.io.OutputStream;\n import java.sql.SQLException;\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n \n-import com.google.common.collect.Iterators;\n-import org.apache.commons.cli.CommandLine;\n-import org.apache.commons.cli.CommandLineParser;\n-import org.apache.commons.cli.HelpFormatter;\n import org.apache.commons.cli.Options;\n import org.apache.commons.cli.ParseException;\n-import org.apache.commons.cli.PosixParser;\n-import org.dspace.content.Collection;\n-import org.dspace.content.Community;\n-import org.dspace.content.DSpaceObject;\n-import org.dspace.content.Item;\n-import org.dspace.content.factory.ContentServiceFactory;\n-import org.dspace.content.service.ItemService;\n-import org.dspace.core.Constants;\n+import org.dspace.content.service.MetadataDSpaceCsvExportService;\n import org.dspace.core.Context;\n-import org.dspace.handle.factory.HandleServiceFactory;\n+import org.dspace.eperson.service.EPersonService;\n+import org.dspace.scripts.DSpaceRunnable;\n+import org.springframework.beans.factory.annotation.Autowired;\n \n /**\n  * Metadata exporter to allow the batch export of metadata into a file\n  *\n  * @author Stuart Lewis\n  */\n-public class MetadataExport {\n-    /**\n-     * The items to export\n-     */\n-    protected Iterator<Item> toExport;\n+public class MetadataExport extends DSpaceRunnable {\n \n-    protected ItemService itemService;\n+    private Context context = null;\n+    private boolean help = false;\n+    private String filename = null;\n+    private String handle = null;\n+    private boolean exportAllMetadata = false;\n+    private boolean exportAllItems = false;\n \n-    protected Context context;\n+    @Autowired\n+    private MetadataDSpaceCsvExportService metadataDSpaceCsvExportService;\n \n-    /**\n-     * Whether to export all metadata, or just normally edited metadata\n-     */\n-    protected boolean exportAll;\n+    @Autowired\n+    private EPersonService ePersonService;\n \n-    protected MetadataExport() {\n-        itemService = ContentServiceFactory.getInstance().getItemService();\n+    private MetadataExport() {\n+        this.options = constructOptions();\n     }\n \n-    /**\n-     * Set up a new metadata export\n-     *\n-     * @param c         The Context\n-     * @param toExport  The ItemIterator of items to export\n-     * @param exportAll whether to export all metadata or not (include handle, provenance etc)\n-     */\n-    public MetadataExport(Context c, Iterator<Item> toExport, boolean exportAll) {\n-        itemService = ContentServiceFactory.getInstance().getItemService();\n-\n-        // Store the export settings\n-        this.toExport = toExport;\n-        this.exportAll = exportAll;\n-        this.context = c;\n-    }\n-\n-    /**\n-     * Method to export a community (and sub-communities and collections)\n-     *\n-     * @param c         The Context\n-     * @param toExport  The Community to export\n-     * @param exportAll whether to export all metadata or not (include handle, provenance etc)\n-     */\n-    public MetadataExport(Context c, Community toExport, boolean exportAll) {\n-        itemService = ContentServiceFactory.getInstance().getItemService();\n-\n-        try {\n-            // Try to export the community\n-            this.toExport = buildFromCommunity(c, toExport, 0);\n-            this.exportAll = exportAll;\n-            this.context = c;\n-        } catch (SQLException sqle) {\n-            // Something went wrong...\n-            System.err.println(\"Error running exporter:\");\n-            sqle.printStackTrace(System.err);\n-            System.exit(1);\n-        }\n-    }\n-\n-    /**\n-     * Build an array list of item ids that are in a community (include sub-communities and collections)\n-     *\n-     * @param context   DSpace context\n-     * @param community The community to build from\n-     * @param indent    How many spaces to use when writing out the names of items added\n-     * @return The list of item ids\n-     * @throws SQLException if database error\n-     */\n-    protected Iterator<Item> buildFromCommunity(Context context, Community community, int indent)\n-        throws SQLException {\n-        // Add all the collections\n-        List<Collection> collections = community.getCollections();\n-        Iterator<Item> result = null;\n-        for (Collection collection : collections) {\n-            for (int i = 0; i < indent; i++) {\n-                System.out.print(\" \");\n-            }\n-\n-            Iterator<Item> items = itemService.findByCollection(context, collection);\n-            result = addItemsToResult(result, items);\n-\n-        }\n-        // Add all the sub-communities\n-        List<Community> communities = community.getSubcommunities();\n-        for (Community subCommunity : communities) {\n-            for (int i = 0; i < indent; i++) {\n-                System.out.print(\" \");\n-            }\n-            Iterator<Item> items = buildFromCommunity(context, subCommunity, indent + 1);\n-            result = addItemsToResult(result, items);\n-        }\n-\n-        return result;\n-    }\n-\n-    private Iterator<Item> addItemsToResult(Iterator<Item> result, Iterator<Item> items) {\n-        if (result == null) {\n-            result = items;\n-        } else {\n-            result = Iterators.concat(result, items);\n-        }\n-\n-        return result;\n-    }\n-\n-    /**\n-     * Run the export\n-     *\n-     * @return the exported CSV lines\n-     */\n-    public DSpaceCSV export() {\n-        try {\n-            Context.Mode originalMode = context.getCurrentMode();\n-            context.setMode(Context.Mode.READ_ONLY);\n-\n-            // Process each item\n-            DSpaceCSV csv = new DSpaceCSV(exportAll);\n-            while (toExport.hasNext()) {\n-                Item item = toExport.next();\n-                csv.addItem(item);\n-                context.uncacheEntity(item);\n-            }\n-\n-            context.setMode(originalMode);\n-            // Return the results\n-            return csv;\n-        } catch (Exception e) {\n-            // Something went wrong...\n-            System.err.println(\"Error exporting to CSV:\");\n-            e.printStackTrace();\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * Print the help message\n-     *\n-     * @param options  The command line options the user gave\n-     * @param exitCode the system exit code to use\n-     */\n-    private static void printHelp(Options options, int exitCode) {\n-        // print the help message\n-        HelpFormatter myhelp = new HelpFormatter();\n-        myhelp.printHelp(\"MetadataExport\\n\", options);\n-        System.out.println(\"\\nfull export: metadataexport -f filename\");\n-        System.out.println(\"partial export: metadataexport -i handle -f filename\");\n-        System.exit(exitCode);\n-    }\n-\n-    /**\n-     * main method to run the metadata exporter\n-     *\n-     * @param argv the command line arguments given\n-     * @throws Exception if error occurs\n-     */\n-    public static void main(String[] argv) throws Exception {\n-        // Create an options object and populate it\n-        CommandLineParser parser = new PosixParser();\n-\n+    private Options constructOptions() {\n         Options options = new Options();\n \n         options.addOption(\"i\", \"id\", true, \"ID or handle of thing to export (item, collection, or community)\");\n+        options.getOption(\"i\").setType(String.class);\n         options.addOption(\"f\", \"file\", true, \"destination where you want file written\");\n+        options.getOption(\"f\").setType(OutputStream.class);\n+        options.getOption(\"f\").setRequired(true);\n         options.addOption(\"a\", \"all\", false,\n                           \"include all metadata fields that are not normally changed (e.g. provenance)\");\n+        options.getOption(\"a\").setType(boolean.class);\n         options.addOption(\"h\", \"help\", false, \"help\");\n+        options.getOption(\"h\").setType(boolean.class);\n \n-        CommandLine line = null;\n-\n-        try {\n-            line = parser.parse(options, argv);\n-        } catch (ParseException pe) {\n-            System.err.println(\"Error with commands.\");\n-            printHelp(options, 1);\n-            System.exit(0);\n-        }\n \n-        if (line.hasOption('h')) {\n-            printHelp(options, 0);\n-        }\n+        return options;\n+    }\n \n-        // Check a filename is given\n-        if (!line.hasOption('f')) {\n-            System.err.println(\"Required parameter -f missing!\");\n-            printHelp(options, 1);\n+    public void internalRun() throws Exception {\n+        if (help) {\n+            handler.logInfo(\"\\nfull export: metadata-export -f filename\");\n+            handler.logInfo(\"partial export: metadata-export -i handle -f filename\");\n+            printHelp();\n+            return;\n         }\n-        String filename = line.getOptionValue('f');\n \n-        // Create a context\n-        Context c = new Context(Context.Mode.READ_ONLY);\n-        c.turnOffAuthorisationSystem();\n-\n-        // The things we'll export\n-        Iterator<Item> toExport = null;\n-        MetadataExport exporter = null;\n+        DSpaceCSV dSpaceCSV = metadataDSpaceCsvExportService\n+            .handleExport(context, exportAllItems, exportAllMetadata, handle,\n+                          handler);\n+        handler.writeFilestream(context, filename, dSpaceCSV.getInputStream(), \"exportCSV\");\n+        context.restoreAuthSystemState();\n+        context.complete();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc4NDU2OQ=="}, "originalCommit": {"oid": "5265ebd382097d221b9b9bfc2df708b5819f1fa0"}, "originalPosition": 262}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAzNzA0MQ==", "bodyText": "Again, please resolve prior feedback here.", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r426037041", "createdAt": "2020-05-15T20:41:48Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/app/bulkedit/MetadataExport.java", "diffHunk": "@@ -7,272 +7,101 @@\n  */\n package org.dspace.app.bulkedit;\n \n+import java.io.OutputStream;\n import java.sql.SQLException;\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n \n-import com.google.common.collect.Iterators;\n-import org.apache.commons.cli.CommandLine;\n-import org.apache.commons.cli.CommandLineParser;\n-import org.apache.commons.cli.HelpFormatter;\n import org.apache.commons.cli.Options;\n import org.apache.commons.cli.ParseException;\n-import org.apache.commons.cli.PosixParser;\n-import org.dspace.content.Collection;\n-import org.dspace.content.Community;\n-import org.dspace.content.DSpaceObject;\n-import org.dspace.content.Item;\n-import org.dspace.content.factory.ContentServiceFactory;\n-import org.dspace.content.service.ItemService;\n-import org.dspace.core.Constants;\n+import org.dspace.content.service.MetadataDSpaceCsvExportService;\n import org.dspace.core.Context;\n-import org.dspace.handle.factory.HandleServiceFactory;\n+import org.dspace.eperson.service.EPersonService;\n+import org.dspace.scripts.DSpaceRunnable;\n+import org.springframework.beans.factory.annotation.Autowired;\n \n /**\n  * Metadata exporter to allow the batch export of metadata into a file\n  *\n  * @author Stuart Lewis\n  */\n-public class MetadataExport {\n-    /**\n-     * The items to export\n-     */\n-    protected Iterator<Item> toExport;\n+public class MetadataExport extends DSpaceRunnable {\n \n-    protected ItemService itemService;\n+    private Context context = null;\n+    private boolean help = false;\n+    private String filename = null;\n+    private String handle = null;\n+    private boolean exportAllMetadata = false;\n+    private boolean exportAllItems = false;\n \n-    protected Context context;\n+    @Autowired\n+    private MetadataDSpaceCsvExportService metadataDSpaceCsvExportService;\n \n-    /**\n-     * Whether to export all metadata, or just normally edited metadata\n-     */\n-    protected boolean exportAll;\n+    @Autowired\n+    private EPersonService ePersonService;\n \n-    protected MetadataExport() {\n-        itemService = ContentServiceFactory.getInstance().getItemService();\n+    private MetadataExport() {\n+        this.options = constructOptions();\n     }\n \n-    /**\n-     * Set up a new metadata export\n-     *\n-     * @param c         The Context\n-     * @param toExport  The ItemIterator of items to export\n-     * @param exportAll whether to export all metadata or not (include handle, provenance etc)\n-     */\n-    public MetadataExport(Context c, Iterator<Item> toExport, boolean exportAll) {\n-        itemService = ContentServiceFactory.getInstance().getItemService();\n-\n-        // Store the export settings\n-        this.toExport = toExport;\n-        this.exportAll = exportAll;\n-        this.context = c;\n-    }\n-\n-    /**\n-     * Method to export a community (and sub-communities and collections)\n-     *\n-     * @param c         The Context\n-     * @param toExport  The Community to export\n-     * @param exportAll whether to export all metadata or not (include handle, provenance etc)\n-     */\n-    public MetadataExport(Context c, Community toExport, boolean exportAll) {\n-        itemService = ContentServiceFactory.getInstance().getItemService();\n-\n-        try {\n-            // Try to export the community\n-            this.toExport = buildFromCommunity(c, toExport, 0);\n-            this.exportAll = exportAll;\n-            this.context = c;\n-        } catch (SQLException sqle) {\n-            // Something went wrong...\n-            System.err.println(\"Error running exporter:\");\n-            sqle.printStackTrace(System.err);\n-            System.exit(1);\n-        }\n-    }\n-\n-    /**\n-     * Build an array list of item ids that are in a community (include sub-communities and collections)\n-     *\n-     * @param context   DSpace context\n-     * @param community The community to build from\n-     * @param indent    How many spaces to use when writing out the names of items added\n-     * @return The list of item ids\n-     * @throws SQLException if database error\n-     */\n-    protected Iterator<Item> buildFromCommunity(Context context, Community community, int indent)\n-        throws SQLException {\n-        // Add all the collections\n-        List<Collection> collections = community.getCollections();\n-        Iterator<Item> result = null;\n-        for (Collection collection : collections) {\n-            for (int i = 0; i < indent; i++) {\n-                System.out.print(\" \");\n-            }\n-\n-            Iterator<Item> items = itemService.findByCollection(context, collection);\n-            result = addItemsToResult(result, items);\n-\n-        }\n-        // Add all the sub-communities\n-        List<Community> communities = community.getSubcommunities();\n-        for (Community subCommunity : communities) {\n-            for (int i = 0; i < indent; i++) {\n-                System.out.print(\" \");\n-            }\n-            Iterator<Item> items = buildFromCommunity(context, subCommunity, indent + 1);\n-            result = addItemsToResult(result, items);\n-        }\n-\n-        return result;\n-    }\n-\n-    private Iterator<Item> addItemsToResult(Iterator<Item> result, Iterator<Item> items) {\n-        if (result == null) {\n-            result = items;\n-        } else {\n-            result = Iterators.concat(result, items);\n-        }\n-\n-        return result;\n-    }\n-\n-    /**\n-     * Run the export\n-     *\n-     * @return the exported CSV lines\n-     */\n-    public DSpaceCSV export() {\n-        try {\n-            Context.Mode originalMode = context.getCurrentMode();\n-            context.setMode(Context.Mode.READ_ONLY);\n-\n-            // Process each item\n-            DSpaceCSV csv = new DSpaceCSV(exportAll);\n-            while (toExport.hasNext()) {\n-                Item item = toExport.next();\n-                csv.addItem(item);\n-                context.uncacheEntity(item);\n-            }\n-\n-            context.setMode(originalMode);\n-            // Return the results\n-            return csv;\n-        } catch (Exception e) {\n-            // Something went wrong...\n-            System.err.println(\"Error exporting to CSV:\");\n-            e.printStackTrace();\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * Print the help message\n-     *\n-     * @param options  The command line options the user gave\n-     * @param exitCode the system exit code to use\n-     */\n-    private static void printHelp(Options options, int exitCode) {\n-        // print the help message\n-        HelpFormatter myhelp = new HelpFormatter();\n-        myhelp.printHelp(\"MetadataExport\\n\", options);\n-        System.out.println(\"\\nfull export: metadataexport -f filename\");\n-        System.out.println(\"partial export: metadataexport -i handle -f filename\");\n-        System.exit(exitCode);\n-    }\n-\n-    /**\n-     * main method to run the metadata exporter\n-     *\n-     * @param argv the command line arguments given\n-     * @throws Exception if error occurs\n-     */\n-    public static void main(String[] argv) throws Exception {\n-        // Create an options object and populate it\n-        CommandLineParser parser = new PosixParser();\n-\n+    private Options constructOptions() {\n         Options options = new Options();\n \n         options.addOption(\"i\", \"id\", true, \"ID or handle of thing to export (item, collection, or community)\");\n+        options.getOption(\"i\").setType(String.class);\n         options.addOption(\"f\", \"file\", true, \"destination where you want file written\");\n+        options.getOption(\"f\").setType(OutputStream.class);\n+        options.getOption(\"f\").setRequired(true);\n         options.addOption(\"a\", \"all\", false,\n                           \"include all metadata fields that are not normally changed (e.g. provenance)\");\n+        options.getOption(\"a\").setType(boolean.class);\n         options.addOption(\"h\", \"help\", false, \"help\");\n+        options.getOption(\"h\").setType(boolean.class);\n \n-        CommandLine line = null;\n-\n-        try {\n-            line = parser.parse(options, argv);\n-        } catch (ParseException pe) {\n-            System.err.println(\"Error with commands.\");\n-            printHelp(options, 1);\n-            System.exit(0);\n-        }\n \n-        if (line.hasOption('h')) {\n-            printHelp(options, 0);\n-        }\n+        return options;\n+    }\n \n-        // Check a filename is given\n-        if (!line.hasOption('f')) {\n-            System.err.println(\"Required parameter -f missing!\");\n-            printHelp(options, 1);\n+    public void internalRun() throws Exception {\n+        if (help) {\n+            handler.logInfo(\"\\nfull export: metadata-export -f filename\");\n+            handler.logInfo(\"partial export: metadata-export -i handle -f filename\");\n+            printHelp();\n+            return;\n         }\n-        String filename = line.getOptionValue('f');\n \n-        // Create a context\n-        Context c = new Context(Context.Mode.READ_ONLY);\n-        c.turnOffAuthorisationSystem();\n-\n-        // The things we'll export\n-        Iterator<Item> toExport = null;\n-        MetadataExport exporter = null;\n+        DSpaceCSV dSpaceCSV = metadataDSpaceCsvExportService\n+            .handleExport(context, exportAllItems, exportAllMetadata, handle,\n+                          handler);\n+        handler.writeFilestream(context, filename, dSpaceCSV.getInputStream(), \"exportCSV\");\n+        context.restoreAuthSystemState();\n+        context.complete();\n+    }\n \n-        // Export everything?\n-        boolean exportAll = line.hasOption('a');\n+    public void setup() throws ParseException {\n+        context = new Context();\n+        context.turnOffAuthorisationSystem();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc4NTg1MQ=="}, "originalCommit": {"oid": "5265ebd382097d221b9b9bfc2df708b5819f1fa0"}, "originalPosition": 269}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAzODA2Nw==", "bodyText": "Again, please resolve prior feedback", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r426038067", "createdAt": "2020-05-15T20:44:32Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/app/bulkedit/MetadataImport.java", "diffHunk": "@@ -167,21 +178,201 @@\n      * @param c        The context\n      * @param toImport An array of CSV lines to examine\n      */\n-    public MetadataImport(Context c, DSpaceCSV toImport) {\n+    public void initMetadataImport(DSpaceCSV toImport) {\n         // Store the import settings\n-        this.c = c;\n-        csv = toImport;\n         this.toImport = toImport.getCSVLines();\n-        installItemService = ContentServiceFactory.getInstance().getInstallItemService();\n-        itemService = ContentServiceFactory.getInstance().getItemService();\n-        collectionService = ContentServiceFactory.getInstance().getCollectionService();\n-        handleService = HandleServiceFactory.getInstance().getHandleService();\n-        authorityValueService = AuthorityServiceFactory.getInstance().getAuthorityValueService();\n-        workspaceItemService = ContentServiceFactory.getInstance().getWorkspaceItemService();\n-        relationshipService = ContentServiceFactory.getInstance().getRelationshipService();\n-        relationshipTypeService = ContentServiceFactory.getInstance().getRelationshipTypeService();\n-        entityTypeService = ContentServiceFactory.getInstance().getEntityTypeService();\n-        entityService = ContentServiceFactory.getInstance().getEntityService();\n+    }\n+\n+    @Override\n+    public void internalRun() throws Exception {\n+        if (help) {\n+            printHelp();\n+            return;\n+        }\n+        // Read commandLines from the CSV file\n+        try {\n+\n+            Optional<InputStream> optionalFileStream = handler.getFileStream(c, filename);\n+            if (optionalFileStream.isPresent()) {\n+                csv = new DSpaceCSV(optionalFileStream.get(), c);\n+            } else {\n+                throw new IllegalArgumentException(\"Error reading file, the file couldn't be found for filename: \" +\n+                                                       filename);\n+            }\n+        } catch (MetadataImportInvalidHeadingException miihe) {\n+            throw miihe;\n+        } catch (Exception e) {\n+            throw new Exception(\"Error reading file: \" + e.getMessage(), e);\n+        }\n+\n+        // Perform the first import - just highlight differences\n+        initMetadataImport(csv);\n+        List<BulkEditChange> changes;\n+\n+        if (!commandLine.hasOption('s') || validateOnly) {\n+            // See what has changed\n+            try {\n+                changes = runImport(false, useWorkflow, workflowNotify, useTemplate);\n+            } catch (MetadataImportException mie) {\n+                throw mie;\n+            }\n+\n+            // Display the changes\n+            int changeCounter = displayChanges(changes, false);\n+\n+            // If there were changes, ask if we should execute them\n+            if (!validateOnly && changeCounter > 0) {\n+                try {\n+                    // Ask the user if they want to make the changes\n+                    handler.logInfo(\"\\n\" + changeCounter + \" item(s) will be changed\\n\");\n+                    change = determineChange(handler);\n+\n+                } catch (IOException ioe) {\n+                    throw new IOException(\"Error: \" + ioe.getMessage() + \", No changes have been made\", ioe);\n+                }\n+            } else {\n+                handler.logInfo(\"There were no changes detected\");\n+            }\n+        } else {\n+            change = true;\n+        }\n+\n+        try {\n+            // If required, make the change\n+            if (change && !validateOnly) {\n+                try {\n+                    // Make the changes\n+                    changes = runImport(true, useWorkflow, workflowNotify, useTemplate);\n+                } catch (MetadataImportException mie) {\n+                    throw mie;\n+                }\n+\n+                // Display the changes\n+                displayChanges(changes, true);\n+            }\n+\n+            // Finsh off and tidy up\n+            c.restoreAuthSystemState();\n+            c.complete();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc4NzgzMw=="}, "originalCommit": {"oid": "5265ebd382097d221b9b9bfc2df708b5819f1fa0"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAzODE4Mw==", "bodyText": "Again, please resolve prior feedback", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r426038183", "createdAt": "2020-05-15T20:44:51Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/app/bulkedit/MetadataImport.java", "diffHunk": "@@ -167,21 +178,201 @@\n      * @param c        The context\n      * @param toImport An array of CSV lines to examine\n      */\n-    public MetadataImport(Context c, DSpaceCSV toImport) {\n+    public void initMetadataImport(DSpaceCSV toImport) {\n         // Store the import settings\n-        this.c = c;\n-        csv = toImport;\n         this.toImport = toImport.getCSVLines();\n-        installItemService = ContentServiceFactory.getInstance().getInstallItemService();\n-        itemService = ContentServiceFactory.getInstance().getItemService();\n-        collectionService = ContentServiceFactory.getInstance().getCollectionService();\n-        handleService = HandleServiceFactory.getInstance().getHandleService();\n-        authorityValueService = AuthorityServiceFactory.getInstance().getAuthorityValueService();\n-        workspaceItemService = ContentServiceFactory.getInstance().getWorkspaceItemService();\n-        relationshipService = ContentServiceFactory.getInstance().getRelationshipService();\n-        relationshipTypeService = ContentServiceFactory.getInstance().getRelationshipTypeService();\n-        entityTypeService = ContentServiceFactory.getInstance().getEntityTypeService();\n-        entityService = ContentServiceFactory.getInstance().getEntityService();\n+    }\n+\n+    @Override\n+    public void internalRun() throws Exception {\n+        if (help) {\n+            printHelp();\n+            return;\n+        }\n+        // Read commandLines from the CSV file\n+        try {\n+\n+            Optional<InputStream> optionalFileStream = handler.getFileStream(c, filename);\n+            if (optionalFileStream.isPresent()) {\n+                csv = new DSpaceCSV(optionalFileStream.get(), c);\n+            } else {\n+                throw new IllegalArgumentException(\"Error reading file, the file couldn't be found for filename: \" +\n+                                                       filename);\n+            }\n+        } catch (MetadataImportInvalidHeadingException miihe) {\n+            throw miihe;\n+        } catch (Exception e) {\n+            throw new Exception(\"Error reading file: \" + e.getMessage(), e);\n+        }\n+\n+        // Perform the first import - just highlight differences\n+        initMetadataImport(csv);\n+        List<BulkEditChange> changes;\n+\n+        if (!commandLine.hasOption('s') || validateOnly) {\n+            // See what has changed\n+            try {\n+                changes = runImport(false, useWorkflow, workflowNotify, useTemplate);\n+            } catch (MetadataImportException mie) {\n+                throw mie;\n+            }\n+\n+            // Display the changes\n+            int changeCounter = displayChanges(changes, false);\n+\n+            // If there were changes, ask if we should execute them\n+            if (!validateOnly && changeCounter > 0) {\n+                try {\n+                    // Ask the user if they want to make the changes\n+                    handler.logInfo(\"\\n\" + changeCounter + \" item(s) will be changed\\n\");\n+                    change = determineChange(handler);\n+\n+                } catch (IOException ioe) {\n+                    throw new IOException(\"Error: \" + ioe.getMessage() + \", No changes have been made\", ioe);\n+                }\n+            } else {\n+                handler.logInfo(\"There were no changes detected\");\n+            }\n+        } else {\n+            change = true;\n+        }\n+\n+        try {\n+            // If required, make the change\n+            if (change && !validateOnly) {\n+                try {\n+                    // Make the changes\n+                    changes = runImport(true, useWorkflow, workflowNotify, useTemplate);\n+                } catch (MetadataImportException mie) {\n+                    throw mie;\n+                }\n+\n+                // Display the changes\n+                displayChanges(changes, true);\n+            }\n+\n+            // Finsh off and tidy up\n+            c.restoreAuthSystemState();\n+            c.complete();\n+        } catch (Exception e) {\n+            c.abort();\n+            throw new Exception(\n+                \"Error committing changes to database: \" + e.getMessage() + \", aborting most recent changes\", e);\n+        }\n+\n+    }\n+\n+    /**\n+     * This method determines whether the changes should be applied or not. This is default set to true for the REST\n+     * script as we don't want to interact with the caller. This will be overwritten in the CLI script to ask for\n+     * confirmation\n+     * @param handler   Applicable DSpaceRunnableHandler\n+     * @return boolean indicating the value\n+     * @throws IOException  If something goes wrong\n+     */\n+    protected boolean determineChange(DSpaceRunnableHandler handler) throws IOException {\n+        return true;\n+    }\n+\n+    public void setup() throws ParseException {\n+        useTemplate = false;\n+        filename = null;\n+        useWorkflow = false;\n+        workflowNotify = false;\n+\n+        if (commandLine.hasOption('h')) {\n+            help = true;\n+            return;\n+        }\n+\n+        // Check a filename is given\n+        if (!commandLine.hasOption('f')) {\n+            throw new ParseException(\"Required parameter -f missing!\");\n+        }\n+        filename = commandLine.getOptionValue('f');\n+\n+        // Option to apply template to new items\n+        if (commandLine.hasOption('t')) {\n+            useTemplate = true;\n+        }\n+\n+        // Options for workflows, and workflow notifications for new items\n+        if (commandLine.hasOption('w')) {\n+            useWorkflow = true;\n+            if (commandLine.hasOption('n')) {\n+                workflowNotify = true;\n+            }\n+        } else if (commandLine.hasOption('n')) {\n+            throw new ParseException(\n+                \"Invalid option 'n': (notify) can only be specified with the 'w' (workflow) option.\");\n+        }\n+        validateOnly = commandLine.hasOption('v');\n+\n+\n+        // Create a context\n+        try {\n+            c = new Context();\n+            c.turnOffAuthorisationSystem();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc4ODIyNw=="}, "originalCommit": {"oid": "5265ebd382097d221b9b9bfc2df708b5819f1fa0"}, "originalPosition": 272}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAzODk1Nw==", "bodyText": "Again, please resolve prior feedback", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r426038957", "createdAt": "2020-05-15T20:46:49Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/scripts/DSpaceRunnable.java", "diffHunk": "@@ -153,4 +170,32 @@ public boolean isAllowedToExecute(Context context) {\n         }\n         return false;\n     }\n+\n+    public void setBeanName(String beanName) {\n+        this.name = beanName;\n+    }\n+\n+    /**\n+     * Generic getter for the name\n+     * @return the name value of this DSpaceRunnable\n+     */\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     * Generic getter for the epersonIdentifier", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc5MjQ1NA=="}, "originalCommit": {"oid": "5265ebd382097d221b9b9bfc2df708b5819f1fa0"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAzOTg5Mg==", "bodyText": "I think this Controller can now be removed in favor of a LinkRestRepository (see other LinkRestRepository classes as examples).  I don't see a reason why we this needs to a custom Controller", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r426039892", "createdAt": "2020-05-15T20:49:09Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/ProcessRestController.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.springframework.hateoas.mvc.ControllerLinkBuilder.linkTo;\n+import static org.springframework.hateoas.mvc.ControllerLinkBuilder.methodOn;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.rest.link.HalLinkService;\n+import org.dspace.app.rest.link.process.ProcessResourceHalLinkFactory;\n+import org.dspace.app.rest.model.BitstreamRest;\n+import org.dspace.app.rest.model.ProcessRest;\n+import org.dspace.app.rest.model.hateoas.BitstreamResource;\n+import org.dspace.app.rest.model.hateoas.ProcessFileWrapperResource;\n+import org.dspace.app.rest.repository.ProcessRestRepository;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.authorize.AuthorizeException;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.data.web.PagedResourcesAssembler;\n+import org.springframework.hateoas.Link;\n+import org.springframework.hateoas.PagedResources;\n+import org.springframework.web.bind.annotation.PathVariable;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RequestMethod;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+@RestController\n+@RequestMapping(\"/api/\" + ProcessRest.CATEGORY + \"/\" + ProcessRest.PLURAL_NAME)\n+public class ProcessRestController {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc5OTYzMw=="}, "originalCommit": {"oid": "5265ebd382097d221b9b9bfc2df708b5819f1fa0"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA0MDEyNg==", "bodyText": "All methods will need a @PreAuthorize annotation once you turn this into a LinkRestRepository.", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r426040126", "createdAt": "2020-05-15T20:49:52Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/ProcessRestController.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.springframework.hateoas.mvc.ControllerLinkBuilder.linkTo;\n+import static org.springframework.hateoas.mvc.ControllerLinkBuilder.methodOn;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.rest.link.HalLinkService;\n+import org.dspace.app.rest.link.process.ProcessResourceHalLinkFactory;\n+import org.dspace.app.rest.model.BitstreamRest;\n+import org.dspace.app.rest.model.ProcessRest;\n+import org.dspace.app.rest.model.hateoas.BitstreamResource;\n+import org.dspace.app.rest.model.hateoas.ProcessFileWrapperResource;\n+import org.dspace.app.rest.repository.ProcessRestRepository;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.authorize.AuthorizeException;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.data.web.PagedResourcesAssembler;\n+import org.springframework.hateoas.Link;\n+import org.springframework.hateoas.PagedResources;\n+import org.springframework.web.bind.annotation.PathVariable;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RequestMethod;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+@RestController\n+@RequestMapping(\"/api/\" + ProcessRest.CATEGORY + \"/\" + ProcessRest.PLURAL_NAME)\n+public class ProcessRestController {\n+\n+    private static final Logger log = LogManager.getLogger();\n+\n+    @Autowired\n+    HalLinkService linkService;\n+\n+    @Autowired\n+    private ProcessRestRepository processRestRepository;\n+\n+    @Autowired\n+    private Utils utils;\n+\n+    @Autowired\n+    private HalLinkService halLinkService;\n+\n+    @Autowired\n+    ProcessResourceHalLinkFactory processResourceHalLinkFactory;\n+\n+    @RequestMapping(method = RequestMethod.GET, value = \"/{processId}/files\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDgwMDI5MQ=="}, "originalCommit": {"oid": "5265ebd382097d221b9b9bfc2df708b5819f1fa0"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA0MTYwMw==", "bodyText": "Needs JavaDocs to describe this abstract class.  This is especially important because it's an empty class, so we need to describe why it's needed.", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r426041603", "createdAt": "2020-05-15T20:53:38Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/link/process/ProcessHalLinkFactory.java", "diffHunk": "@@ -0,0 +1,14 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.link.process;\n+\n+import org.dspace.app.rest.ProcessRestController;\n+import org.dspace.app.rest.link.HalLinkFactory;\n+\n+public abstract class ProcessHalLinkFactory<T> extends HalLinkFactory<T, ProcessRestController> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "026c2308eccf07a5f60dbf9572c264c028598f48"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA0MTk2Mw==", "bodyText": "Again, please resolve prior feedback.", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r426041963", "createdAt": "2020-05-15T20:54:22Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/model/ProcessFileWrapperRest.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.model;\n+\n+import java.util.List;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+\n+public class ProcessFileWrapperRest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDgwMDY1MA=="}, "originalCommit": {"oid": "5265ebd382097d221b9b9bfc2df708b5819f1fa0"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA0MTk5OQ==", "bodyText": "Again, please resolve prior feedback.", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r426041999", "createdAt": "2020-05-15T20:54:28Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/model/hateoas/ProcessFileWrapperResource.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.model.hateoas;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.dspace.app.rest.model.BitstreamRest;\n+import org.dspace.app.rest.model.MetadataValueRest;\n+import org.dspace.app.rest.model.ProcessFileWrapperRest;\n+import org.dspace.app.rest.utils.Utils;\n+\n+\n+public class ProcessFileWrapperResource extends HALResource<ProcessFileWrapperRest> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDgwMDc3Ng=="}, "originalCommit": {"oid": "5265ebd382097d221b9b9bfc2df708b5819f1fa0"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA0MjAzNw==", "bodyText": "Again, please resolve prior feedback.", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r426042037", "createdAt": "2020-05-15T20:54:37Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/ProcessRestRepository.java", "diffHunk": "@@ -59,6 +77,64 @@ public ProcessRest findOne(Context context, Integer id) {\n         }\n     }\n \n+    public List<BitstreamRest> getProcessBitstreams(Integer processId) throws SQLException, AuthorizeException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDgwMTE0OA=="}, "originalCommit": {"oid": "5265ebd382097d221b9b9bfc2df708b5819f1fa0"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA0MjMzOQ==", "bodyText": "Again, please resolve prior feedback.  I'm unclear of the purpose of this field, but I still don't think we should be creating a schema with only one metadata field within it.  If we need this field, we should take this opportunity to create a \"dspace\" schema and call this \"dspace.process.type\"", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r426042339", "createdAt": "2020-05-15T20:55:16Z", "author": {"login": "tdonohue"}, "path": "dspace/config/registries/process-types.xml", "diffHunk": "@@ -0,0 +1,20 @@\n+<dspace-dc-types>\n+\n+    <dspace-header>\n+        <title>DSpace Process Types</title>\n+    </dspace-header>\n+\n+    <dc-schema>\n+        <name>process</name>\n+        <namespace>http://dspace.org/process</namespace>\n+    </dc-schema>\n+\n+    <dc-type>\n+        <schema>process</schema>\n+        <element>type</element>\n+        <qualifier></qualifier>\n+        <scope_note></scope_note>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDgwNDI3MQ=="}, "originalCommit": {"oid": "5265ebd382097d221b9b9bfc2df708b5819f1fa0"}, "originalPosition": 16}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa741eb188786c5019d737099b18d14382f04935", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/fa741eb188786c5019d737099b18d14382f04935", "committedDate": "2020-05-18T12:48:39Z", "message": "[Task 70911] applied feedback to the Scripts and Processes functionality"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5b0bf29fd40ddc2247c1d2867594bd257beb094d", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/5b0bf29fd40ddc2247c1d2867594bd257beb094d", "committedDate": "2020-05-18T12:52:13Z", "message": "Cleanup comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a554cbd141618dfc30fd792c00ffc6adb405e39", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/2a554cbd141618dfc30fd792c00ffc6adb405e39", "committedDate": "2020-05-28T07:23:19Z", "message": "Merge remote-tracking branch 'dspace/master' into w2p-64428_scripts-prototype-importing-and-exporting\n\nConflicts:\n\tdspace-server-webapp/src/main/java/org/dspace/app/rest/ScriptProcessesController.java\n\tdspace-server-webapp/src/main/java/org/dspace/app/rest/repository/ScriptRestRepository.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bc7cf1484cff1925e77be34b712dfc97f5fecdbc", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/bc7cf1484cff1925e77be34b712dfc97f5fecdbc", "committedDate": "2020-05-28T07:41:58Z", "message": "Fixes after master merge"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8045194cc38f637683405acae796a23b4f6107ef", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/8045194cc38f637683405acae796a23b4f6107ef", "committedDate": "2020-05-28T08:29:09Z", "message": "[Task 70911] applied feedback on the Process endpoints"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ce9ba1263b6ead1c3f337fac25d52e22785f5906", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/ce9ba1263b6ead1c3f337fac25d52e22785f5906", "committedDate": "2020-05-28T09:40:01Z", "message": "Added more descriptive log to the ProcessRestRepository#delete method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f19bf96bd2813a93a632512207e8cbcba8c9d936", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/f19bf96bd2813a93a632512207e8cbcba8c9d936", "committedDate": "2020-05-28T13:30:52Z", "message": "[Task 70911] applied feedback to the MetadataExport and MetadataImport scripts as well as general Process functionality feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8652e95686edf28f6431dd0f9e035e147ed01852", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/8652e95686edf28f6431dd0f9e035e147ed01852", "committedDate": "2020-05-28T13:48:03Z", "message": "[Task 70911] added required parameter e check in the MetadataImport setup and cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "47b75f313e543923997cbe8c2ae717323aea7170", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/47b75f313e543923997cbe8c2ae717323aea7170", "committedDate": "2020-05-29T13:52:09Z", "message": "Fixed checkstyle"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMjg5MTEz", "url": "https://github.com/DSpace/DSpace/pull/2648#pullrequestreview-420289113", "createdAt": "2020-05-28T16:29:54Z", "commit": {"oid": "8652e95686edf28f6431dd0f9e035e147ed01852"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNjoyOTo1NFrOGb9SeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNjowMDo1M1rOGci1AA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk2ODg4OQ==", "bodyText": "Please add Javadocs describing this implementation class", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r431968889", "createdAt": "2020-05-28T16:29:54Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/content/MetadataDSpaceCsvExportServiceImpl.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.content;\n+\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import com.google.common.collect.Iterators;\n+import org.dspace.app.bulkedit.DSpaceCSV;\n+import org.dspace.content.service.ItemService;\n+import org.dspace.content.service.MetadataDSpaceCsvExportService;\n+import org.dspace.core.Constants;\n+import org.dspace.core.Context;\n+import org.dspace.handle.factory.HandleServiceFactory;\n+import org.dspace.scripts.handler.DSpaceRunnableHandler;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+public class MetadataDSpaceCsvExportServiceImpl implements MetadataDSpaceCsvExportService {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8652e95686edf28f6431dd0f9e035e147ed01852"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk3MDgyMg==", "bodyText": "Tiny thing, we likely can remove this Try/Catch, as we usually don't do this when creating a new Context (see the code you wrote in MetadataExport).  If there's a need for it you've discovered, then I'd recommend we throw a RuntimeException here (not a ParseException), and also return the stacktrace, as e.getMessage() may not be enough info to know why the Context couldn't be created.  So, if you need the try/catch, this last line should be throw new RuntimeException(\"Unable to create a new DSpace Context\", e);", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r431970822", "createdAt": "2020-05-28T16:32:57Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/app/bulkedit/MetadataImport.java", "diffHunk": "@@ -143,45 +133,213 @@\n      */\n     protected Integer rowCount = 1;\n \n+    private boolean useTemplate = false;\n+    private String filename = null;\n+    private boolean useWorkflow = false;\n+    private boolean workflowNotify = false;\n+    private boolean change = false;\n+    private boolean help = false;\n+    protected boolean validateOnly;\n+\n     /**\n      * Logger\n      */\n     protected static final Logger log = org.apache.logging.log4j.LogManager.getLogger(MetadataImport.class);\n \n-    protected final AuthorityValueService authorityValueService;\n-\n-    protected final ItemService itemService;\n-    protected final InstallItemService installItemService;\n-    protected final CollectionService collectionService;\n-    protected final HandleService handleService;\n-    protected final WorkspaceItemService workspaceItemService;\n-    protected final RelationshipTypeService relationshipTypeService;\n-    protected final RelationshipService relationshipService;\n-    protected final EntityTypeService entityTypeService;\n-    protected final EntityService entityService;\n+    protected ItemService itemService = ContentServiceFactory.getInstance().getItemService();\n+    protected InstallItemService installItemService = ContentServiceFactory.getInstance().getInstallItemService();\n+    protected CollectionService collectionService = ContentServiceFactory.getInstance().getCollectionService();\n+    protected HandleService handleService = HandleServiceFactory.getInstance().getHandleService();\n+    protected WorkspaceItemService workspaceItemService = ContentServiceFactory.getInstance().getWorkspaceItemService();\n+    protected RelationshipTypeService relationshipTypeService = ContentServiceFactory.getInstance()\n+                                                                                     .getRelationshipTypeService();\n+    protected RelationshipService relationshipService = ContentServiceFactory.getInstance().getRelationshipService();\n+    protected EntityTypeService entityTypeService = ContentServiceFactory.getInstance().getEntityTypeService();\n+    protected EntityService entityService = ContentServiceFactory.getInstance().getEntityService();\n+    protected AuthorityValueService authorityValueService = AuthorityServiceFactory.getInstance()\n+                                                                                   .getAuthorityValueService();\n \n     /**\n      * Create an instance of the metadata importer. Requires a context and an array of CSV lines\n      * to examine.\n      *\n-     * @param c        The context\n      * @param toImport An array of CSV lines to examine\n      */\n-    public MetadataImport(Context c, DSpaceCSV toImport) {\n+    public void initMetadataImport(DSpaceCSV toImport) {\n         // Store the import settings\n-        this.c = c;\n-        csv = toImport;\n         this.toImport = toImport.getCSVLines();\n-        installItemService = ContentServiceFactory.getInstance().getInstallItemService();\n-        itemService = ContentServiceFactory.getInstance().getItemService();\n-        collectionService = ContentServiceFactory.getInstance().getCollectionService();\n-        handleService = HandleServiceFactory.getInstance().getHandleService();\n-        authorityValueService = AuthorityServiceFactory.getInstance().getAuthorityValueService();\n-        workspaceItemService = ContentServiceFactory.getInstance().getWorkspaceItemService();\n-        relationshipService = ContentServiceFactory.getInstance().getRelationshipService();\n-        relationshipTypeService = ContentServiceFactory.getInstance().getRelationshipTypeService();\n-        entityTypeService = ContentServiceFactory.getInstance().getEntityTypeService();\n-        entityService = ContentServiceFactory.getInstance().getEntityService();\n+    }\n+\n+    @Override\n+    public void internalRun() throws Exception {\n+        if (help) {\n+            printHelp();\n+            return;\n+        }\n+        // Create a context\n+        Context c = null;\n+        try {\n+            c = new Context();\n+            c.turnOffAuthorisationSystem();\n+        } catch (Exception e) {\n+            throw new ParseException(\"Unable to create a new DSpace Context: \" + e.getMessage());\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8652e95686edf28f6431dd0f9e035e147ed01852"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMjY3Nw==", "bodyText": "We've lost the JavaDocs on this class. It used to have some, but they may need updating anyways based on the changes to this class.  So, please add new JavaDocs.", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r432132677", "createdAt": "2020-05-28T21:25:14Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/scripts/DSpaceRunnable.java", "diffHunk": "@@ -7,70 +7,65 @@\n  */\n package org.dspace.scripts;\n \n-import java.sql.SQLException;\n+import java.io.InputStream;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.UUID;\n \n import org.apache.commons.cli.CommandLine;\n import org.apache.commons.cli.DefaultParser;\n+import org.apache.commons.cli.Option;\n import org.apache.commons.cli.Options;\n import org.apache.commons.cli.ParseException;\n-import org.dspace.authorize.service.AuthorizeService;\n-import org.dspace.core.Context;\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.scripts.configuration.ScriptConfiguration;\n import org.dspace.scripts.handler.DSpaceRunnableHandler;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.beans.factory.annotation.Required;\n \n-/**\n- * This abstract class is the class that should be extended by each script.\n- * it provides the basic variables to be hold by the script as well as the means to initialize, parse and run the script\n- * Every DSpaceRunnable that is implemented in this way should be defined in the scripts.xml config file as a bean\n- */\n-public abstract class DSpaceRunnable implements Runnable {\n+public abstract class DSpaceRunnable<T extends ScriptConfiguration> implements Runnable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8652e95686edf28f6431dd0f9e035e147ed01852"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzODY1Nw==", "bodyText": "Small thing, but I wonder if dspace.process.type should be a constant, so that we don't have to remember what this field is called.  This is not a required change though, the PR can proceed without it.", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r432138657", "createdAt": "2020-05-28T21:37:40Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/scripts/ProcessServiceImpl.java", "diffHunk": "@@ -141,6 +177,34 @@ public void update(Context context, Process process) throws SQLException {\n         return parameterList;\n     }\n \n+    @Override\n+    public Bitstream getBitstreamByName(Context context, Process process, String bitstreamName) {\n+        for (Bitstream bitstream : getBitstreams(context, process, null)) {\n+            if (StringUtils.equals(bitstream.getName(), bitstreamName)) {\n+                return bitstream;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public List<Bitstream> getBitstreams(Context context, Process process, String type) {\n+        List<Bitstream> allBitstreams = process.getBitstreams();\n+\n+        if (type == null) {\n+            return allBitstreams;\n+        } else {\n+            List<Bitstream> filteredBitstreams = new ArrayList<>();\n+            for (Bitstream bitstream : allBitstreams) {\n+                if (StringUtils.equals(bitstreamService.getMetadata(bitstream, \"dspace.process.type\"), type)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8652e95686edf28f6431dd0f9e035e147ed01852"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0MTcwOQ==", "bodyText": "Please add a context.restoreAuthSystemState(); call after test data is created.", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r432141709", "createdAt": "2020-05-28T21:44:48Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/test/java/org/dspace/app/bulkedit/MetadataExportTest.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.bulkedit;\n+\n+import static junit.framework.TestCase.assertTrue;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.nio.charset.StandardCharsets;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.dspace.AbstractIntegrationTest;\n+import org.dspace.app.launcher.ScriptLauncher;\n+import org.dspace.app.scripts.handler.impl.TestDSpaceRunnableHandler;\n+import org.dspace.content.Collection;\n+import org.dspace.content.Community;\n+import org.dspace.content.Item;\n+import org.dspace.content.WorkspaceItem;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.content.service.CollectionService;\n+import org.dspace.content.service.CommunityService;\n+import org.dspace.content.service.InstallItemService;\n+import org.dspace.content.service.ItemService;\n+import org.dspace.content.service.WorkspaceItemService;\n+import org.dspace.services.ConfigurationService;\n+import org.dspace.services.factory.DSpaceServicesFactory;\n+import org.junit.Test;\n+\n+public class MetadataExportTest extends AbstractIntegrationTest {\n+\n+    private ItemService itemService = ContentServiceFactory.getInstance().getItemService();\n+    private CollectionService collectionService = ContentServiceFactory.getInstance().getCollectionService();\n+    private CommunityService communityService = ContentServiceFactory.getInstance().getCommunityService();\n+    private WorkspaceItemService workspaceItemService = ContentServiceFactory.getInstance().getWorkspaceItemService();\n+    private InstallItemService installItemService = ContentServiceFactory.getInstance().getInstallItemService();\n+    private ConfigurationService configurationService = DSpaceServicesFactory.getInstance().getConfigurationService();\n+\n+    @Test\n+    public void metadataExportToCsvTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        Community community = communityService.create(null, context);\n+        Collection collection = collectionService.create(context, community);\n+        WorkspaceItem wi = workspaceItemService.create(context, collection, true);\n+        Item item = wi.getItem();\n+        itemService.addMetadata(context, item, \"dc\", \"contributor\", \"author\", null, \"Donald, Smith\");\n+        item = installItemService.installItem(context, wi);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8652e95686edf28f6431dd0f9e035e147ed01852"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0MjU1Ng==", "bodyText": "Again, please add a context.restoreAuthSystemState(); call after test data is created.", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r432142556", "createdAt": "2020-05-28T21:46:49Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/test/java/org/dspace/app/bulkedit/MetadataImportTest.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.bulkedit;\n+\n+import static junit.framework.TestCase.assertTrue;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.AbstractIntegrationTest;\n+import org.dspace.app.launcher.ScriptLauncher;\n+import org.dspace.app.scripts.handler.impl.TestDSpaceRunnableHandler;\n+import org.dspace.content.Community;\n+import org.dspace.content.Item;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.content.service.CollectionService;\n+import org.dspace.content.service.CommunityService;\n+import org.dspace.content.service.ItemService;\n+import org.dspace.services.ConfigurationService;\n+import org.dspace.services.factory.DSpaceServicesFactory;\n+import org.junit.Test;\n+\n+public class MetadataImportTest extends AbstractIntegrationTest {\n+\n+    private ItemService itemService = ContentServiceFactory.getInstance().getItemService();\n+    private CollectionService collectionService = ContentServiceFactory.getInstance().getCollectionService();\n+    private CommunityService communityService = ContentServiceFactory.getInstance().getCommunityService();\n+    private ConfigurationService configurationService = DSpaceServicesFactory.getInstance().getConfigurationService();\n+\n+    @Test\n+    public void metadataImportTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        Community community = communityService.create(null, context);\n+        collectionService.create(context, community);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8652e95686edf28f6431dd0f9e035e147ed01852"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0NDgwNg==", "bodyText": "This test does not appear to be cleaning up after itself.  Shouldn't we be deleting the test Community/Collection/Item at the end of this test?  Otherwise, they will remain in our test database and can impact any tests that run later.", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r432144806", "createdAt": "2020-05-28T21:52:17Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/test/java/org/dspace/app/bulkedit/MetadataExportTest.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.bulkedit;\n+\n+import static junit.framework.TestCase.assertTrue;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.nio.charset.StandardCharsets;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.dspace.AbstractIntegrationTest;\n+import org.dspace.app.launcher.ScriptLauncher;\n+import org.dspace.app.scripts.handler.impl.TestDSpaceRunnableHandler;\n+import org.dspace.content.Collection;\n+import org.dspace.content.Community;\n+import org.dspace.content.Item;\n+import org.dspace.content.WorkspaceItem;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.content.service.CollectionService;\n+import org.dspace.content.service.CommunityService;\n+import org.dspace.content.service.InstallItemService;\n+import org.dspace.content.service.ItemService;\n+import org.dspace.content.service.WorkspaceItemService;\n+import org.dspace.services.ConfigurationService;\n+import org.dspace.services.factory.DSpaceServicesFactory;\n+import org.junit.Test;\n+\n+public class MetadataExportTest extends AbstractIntegrationTest {\n+\n+    private ItemService itemService = ContentServiceFactory.getInstance().getItemService();\n+    private CollectionService collectionService = ContentServiceFactory.getInstance().getCollectionService();\n+    private CommunityService communityService = ContentServiceFactory.getInstance().getCommunityService();\n+    private WorkspaceItemService workspaceItemService = ContentServiceFactory.getInstance().getWorkspaceItemService();\n+    private InstallItemService installItemService = ContentServiceFactory.getInstance().getInstallItemService();\n+    private ConfigurationService configurationService = DSpaceServicesFactory.getInstance().getConfigurationService();\n+\n+    @Test\n+    public void metadataExportToCsvTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        Community community = communityService.create(null, context);\n+        Collection collection = collectionService.create(context, community);\n+        WorkspaceItem wi = workspaceItemService.create(context, collection, true);\n+        Item item = wi.getItem();\n+        itemService.addMetadata(context, item, \"dc\", \"contributor\", \"author\", null, \"Donald, Smith\");\n+        item = installItemService.installItem(context, wi);\n+        String fileLocation = configurationService.getProperty(\"dspace.dir\") + testProps.get(\"test.exportcsv\")\n+                                                                                        .toString();\n+\n+        String[] args = new String[] {\"metadata-export\", \"-i\", String.valueOf(item.getHandle()), \"-f\", fileLocation};\n+        TestDSpaceRunnableHandler testDSpaceRunnableHandler = new TestDSpaceRunnableHandler();\n+\n+        ScriptLauncher.handleScript(args, ScriptLauncher.getConfig(kernelImpl), testDSpaceRunnableHandler, kernelImpl);\n+        File file = new File(fileLocation);\n+        String fileContent = IOUtils.toString(new FileInputStream(file), StandardCharsets.UTF_8);\n+        assertTrue(fileContent.contains(\"Donald, Smith\"));\n+        assertTrue(fileContent.contains(String.valueOf(item.getID())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8652e95686edf28f6431dd0f9e035e147ed01852"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0ODM2Ng==", "bodyText": "This line seems potentially fragile to me (and not the best performance to load up all Items into memory only to find the \"next()\" one).  Is there no other way to parse out what Item was created from the output of the metadata-import script?   I'd prefer it if we could test that the output of the script is also correct here.", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r432148366", "createdAt": "2020-05-28T22:00:30Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/test/java/org/dspace/app/bulkedit/MetadataImportTest.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.bulkedit;\n+\n+import static junit.framework.TestCase.assertTrue;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.AbstractIntegrationTest;\n+import org.dspace.app.launcher.ScriptLauncher;\n+import org.dspace.app.scripts.handler.impl.TestDSpaceRunnableHandler;\n+import org.dspace.content.Community;\n+import org.dspace.content.Item;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.content.service.CollectionService;\n+import org.dspace.content.service.CommunityService;\n+import org.dspace.content.service.ItemService;\n+import org.dspace.services.ConfigurationService;\n+import org.dspace.services.factory.DSpaceServicesFactory;\n+import org.junit.Test;\n+\n+public class MetadataImportTest extends AbstractIntegrationTest {\n+\n+    private ItemService itemService = ContentServiceFactory.getInstance().getItemService();\n+    private CollectionService collectionService = ContentServiceFactory.getInstance().getCollectionService();\n+    private CommunityService communityService = ContentServiceFactory.getInstance().getCommunityService();\n+    private ConfigurationService configurationService = DSpaceServicesFactory.getInstance().getConfigurationService();\n+\n+    @Test\n+    public void metadataImportTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        Community community = communityService.create(null, context);\n+        collectionService.create(context, community);\n+\n+        String fileLocation = configurationService.getProperty(\"dspace.dir\") + testProps.get(\"test.importcsv\")\n+                                                                                        .toString();\n+        String[] args = new String[] {\"metadata-import\", \"-f\", fileLocation, \"-e\", eperson.getEmail(), \"-s\"};\n+        TestDSpaceRunnableHandler testDSpaceRunnableHandler = new TestDSpaceRunnableHandler();\n+\n+        ScriptLauncher.handleScript(args, ScriptLauncher.getConfig(kernelImpl), testDSpaceRunnableHandler, kernelImpl);\n+        Item importedItem = itemService.findAll(context).next();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8652e95686edf28f6431dd0f9e035e147ed01852"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0ODYwMw==", "bodyText": "Again, it looks like this test isn't cleaning up the data it creates.  It should be updated to cleanup any test data.", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r432148603", "createdAt": "2020-05-28T22:01:01Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/test/java/org/dspace/app/bulkedit/MetadataImportTest.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.bulkedit;\n+\n+import static junit.framework.TestCase.assertTrue;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.AbstractIntegrationTest;\n+import org.dspace.app.launcher.ScriptLauncher;\n+import org.dspace.app.scripts.handler.impl.TestDSpaceRunnableHandler;\n+import org.dspace.content.Community;\n+import org.dspace.content.Item;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.content.service.CollectionService;\n+import org.dspace.content.service.CommunityService;\n+import org.dspace.content.service.ItemService;\n+import org.dspace.services.ConfigurationService;\n+import org.dspace.services.factory.DSpaceServicesFactory;\n+import org.junit.Test;\n+\n+public class MetadataImportTest extends AbstractIntegrationTest {\n+\n+    private ItemService itemService = ContentServiceFactory.getInstance().getItemService();\n+    private CollectionService collectionService = ContentServiceFactory.getInstance().getCollectionService();\n+    private CommunityService communityService = ContentServiceFactory.getInstance().getCommunityService();\n+    private ConfigurationService configurationService = DSpaceServicesFactory.getInstance().getConfigurationService();\n+\n+    @Test\n+    public void metadataImportTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        Community community = communityService.create(null, context);\n+        collectionService.create(context, community);\n+\n+        String fileLocation = configurationService.getProperty(\"dspace.dir\") + testProps.get(\"test.importcsv\")\n+                                                                                        .toString();\n+        String[] args = new String[] {\"metadata-import\", \"-f\", fileLocation, \"-e\", eperson.getEmail(), \"-s\"};\n+        TestDSpaceRunnableHandler testDSpaceRunnableHandler = new TestDSpaceRunnableHandler();\n+\n+        ScriptLauncher.handleScript(args, ScriptLauncher.getConfig(kernelImpl), testDSpaceRunnableHandler, kernelImpl);\n+        Item importedItem = itemService.findAll(context).next();\n+        assertTrue(\n+            StringUtils.equals(\n+                itemService.getMetadata(importedItem, \"dc\", \"contributor\", \"author\", Item.ANY).get(0).getValue(),\n+                \"Donald, SmithImported\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8652e95686edf28f6431dd0f9e035e147ed01852"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0OTU0Mg==", "bodyText": "Silly thing, but it seems odd to me that these are absolute paths... I'd expect them to be the same as test.bitstream (which sits in the same directory).  So, I'd expect ./target/testing/dspace/assetstore/testImport.csv for example.  If this works as-is though, that's fine.", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r432149542", "createdAt": "2020-05-28T22:03:19Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/test/resources/test-config.properties", "diffHunk": "@@ -11,3 +11,5 @@ test.folder = ./target/testing/\n \n # Path of the test bitstream (to use in BitstreamTest and elsewhere)\n test.bitstream = ./target/testing/dspace/assetstore/ConstitutionofIreland.pdf\n+test.exportcsv = /assetstore/test.csv\n+test.importcsv = /assetstore/testImport.csv", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8652e95686edf28f6431dd0f9e035e147ed01852"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE1MTc5NA==", "bodyText": "Just as a reminder, we should not be creating Controllers unless absolutely required. Generally speaking, if you ever start to create a Controller for any type of  GET request, this is a sign that you should rethink your code to try and use either a RestRepository or LinkRestRepository.  More advice inline below.", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r432151794", "createdAt": "2020-05-28T22:08:41Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/ProcessFilesRestController.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.methodOn;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.rest.link.HalLinkService;\n+import org.dspace.app.rest.link.process.ProcessResourceHalLinkFactory;\n+import org.dspace.app.rest.model.BitstreamRest;\n+import org.dspace.app.rest.model.ProcessRest;\n+import org.dspace.app.rest.model.hateoas.BitstreamResource;\n+import org.dspace.app.rest.repository.ProcessRestRepository;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.authorize.AuthorizeException;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.data.web.PagedResourcesAssembler;\n+import org.springframework.hateoas.Link;\n+import org.springframework.hateoas.PagedModel;\n+import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.web.bind.annotation.PathVariable;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RequestMethod;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+@RestController\n+@RequestMapping(\"/api/\" + ProcessRest.CATEGORY + \"/\" + ProcessRest.PLURAL_NAME + \"/{processId}/files\")\n+public class ProcessFilesRestController {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8652e95686edf28f6431dd0f9e035e147ed01852"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjUyOTM2MQ==", "bodyText": "This endpoint looks to be acting like a /search of Bitstreams (https://github.com/DSpace/Rest7Contract/blob/master/search-rels.md).  I see that's the same feedback that @abollini gave you in the REST Contract, which it looks like wasn't addressed yet: DSpace/RestContract#99 (comment)\nMy recommendation is to redesign this (in the Contract and here) to be /api/core/bitstreams/search/byProcessAndType or similar. This would allow you to move this code into the BitstreamRestRepository class in a method annotated with @SearchRestMethod.", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r432529361", "createdAt": "2020-05-29T14:35:06Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/ProcessFilesRestController.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.methodOn;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.rest.link.HalLinkService;\n+import org.dspace.app.rest.link.process.ProcessResourceHalLinkFactory;\n+import org.dspace.app.rest.model.BitstreamRest;\n+import org.dspace.app.rest.model.ProcessRest;\n+import org.dspace.app.rest.model.hateoas.BitstreamResource;\n+import org.dspace.app.rest.repository.ProcessRestRepository;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.authorize.AuthorizeException;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.data.web.PagedResourcesAssembler;\n+import org.springframework.hateoas.Link;\n+import org.springframework.hateoas.PagedModel;\n+import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.web.bind.annotation.PathVariable;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RequestMethod;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+@RestController\n+@RequestMapping(\"/api/\" + ProcessRest.CATEGORY + \"/\" + ProcessRest.PLURAL_NAME + \"/{processId}/files\")\n+public class ProcessFilesRestController {\n+\n+    private static final Logger log = LogManager.getLogger();\n+\n+    @Autowired\n+    HalLinkService linkService;\n+\n+    @Autowired\n+    private ProcessRestRepository processRestRepository;\n+\n+    @Autowired\n+    private Utils utils;\n+\n+    @Autowired\n+    ProcessResourceHalLinkFactory processResourceHalLinkFactory;\n+\n+    @RequestMapping(method = RequestMethod.GET, value = \"/{fileType}\")\n+    @PreAuthorize(\"hasPermission(#processId, 'PROCESS', 'READ')\")\n+    public PagedModel<BitstreamResource> listFilesWithTypeFromProcess(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8652e95686edf28f6431dd0f9e035e147ed01852"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjUzMDI1NA==", "bodyText": "This endpoint seems to be missing from the original Rest Contract: DSpace/RestContract#99   So, I'm not sure of the use case here.  It might be implemented more like a /search as well (like above), but it seems like it's somehow implied to be a unique lookup, so it could also be a LinkRestRepository perhaps.", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r432530254", "createdAt": "2020-05-29T14:36:33Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/ProcessFilesRestController.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.methodOn;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.rest.link.HalLinkService;\n+import org.dspace.app.rest.link.process.ProcessResourceHalLinkFactory;\n+import org.dspace.app.rest.model.BitstreamRest;\n+import org.dspace.app.rest.model.ProcessRest;\n+import org.dspace.app.rest.model.hateoas.BitstreamResource;\n+import org.dspace.app.rest.repository.ProcessRestRepository;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.authorize.AuthorizeException;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.data.web.PagedResourcesAssembler;\n+import org.springframework.hateoas.Link;\n+import org.springframework.hateoas.PagedModel;\n+import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.web.bind.annotation.PathVariable;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RequestMethod;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+@RestController\n+@RequestMapping(\"/api/\" + ProcessRest.CATEGORY + \"/\" + ProcessRest.PLURAL_NAME + \"/{processId}/files\")\n+public class ProcessFilesRestController {\n+\n+    private static final Logger log = LogManager.getLogger();\n+\n+    @Autowired\n+    HalLinkService linkService;\n+\n+    @Autowired\n+    private ProcessRestRepository processRestRepository;\n+\n+    @Autowired\n+    private Utils utils;\n+\n+    @Autowired\n+    ProcessResourceHalLinkFactory processResourceHalLinkFactory;\n+\n+    @RequestMapping(method = RequestMethod.GET, value = \"/{fileType}\")\n+    @PreAuthorize(\"hasPermission(#processId, 'PROCESS', 'READ')\")\n+    public PagedModel<BitstreamResource> listFilesWithTypeFromProcess(\n+        @PathVariable(name = \"processId\") Integer processId,\n+        @PathVariable(name = \"fileType\") String fileType,\n+        Pageable pageable, PagedResourcesAssembler assembler) throws SQLException, AuthorizeException {\n+\n+        if (log.isTraceEnabled()) {\n+            log.trace(\"Retrieving Files with type \" + fileType + \" from Process with ID: \" + processId);\n+        }\n+\n+        List<BitstreamResource> bitstreamResources = processRestRepository\n+            .getProcessBitstreamsByType(processId, fileType).stream()\n+            .map(bitstreamRest -> new BitstreamResource(bitstreamRest, utils))\n+            .collect(Collectors.toList());\n+\n+        Page<BitstreamResource> page = utils.getPage(bitstreamResources, pageable);\n+\n+        Link link = WebMvcLinkBuilder.linkTo(\n+            methodOn(this.getClass()).listFilesWithTypeFromProcess(processId, fileType, pageable, assembler))\n+            .withSelfRel();\n+        PagedModel<BitstreamResource> result = assembler.toModel(page, link);\n+\n+        return result;\n+    }\n+\n+\n+    @RequestMapping(method = RequestMethod.GET, value = \"/name/{fileName:.+}\")\n+    @PreAuthorize(\"hasPermission(#processId, 'PROCESS', 'READ')\")\n+    public BitstreamResource getBitstreamByName(@PathVariable(name = \"processId\") Integer processId,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8652e95686edf28f6431dd0f9e035e147ed01852"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjUzNjMwMg==", "bodyText": "This is an undocumented change.  So, we need this to added/changed in the REST Contract.", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r432536302", "createdAt": "2020-05-29T14:45:47Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/BitstreamRestRepository.java", "diffHunk": "@@ -95,22 +91,7 @@ public BitstreamRest findOne(Context context, UUID id) {\n     @Override\n     @PreAuthorize(\"hasAuthority('ADMIN')\")\n     public Page<BitstreamRest> findAll(Context context, Pageable pageable) {\n-        List<Bitstream> bit = new ArrayList<Bitstream>();\n-        Iterator<Bitstream> it = null;\n-        int total = 0;\n-        try {\n-            total = bs.countTotal(context);\n-            it = bs.findAll(context, pageable.getPageSize(), Math.toIntExact(pageable.getOffset()));\n-            while (it.hasNext()) {\n-                bit.add(it.next());\n-            }\n-        } catch (SQLException e) {\n-            throw new RuntimeException(e.getMessage(), e);\n-        }\n-        Projection projection = utils.obtainProjection();\n-        Page<BitstreamRest> page = new PageImpl<>(bit, pageable, total)\n-                .map((bitstream) -> converter.toRest(bitstream, projection));\n-        return page;\n+        throw new RepositoryMethodNotImplementedException(BitstreamRest.NAME, \"findAll\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8652e95686edf28f6431dd0f9e035e147ed01852"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU2NTE5OA==", "bodyText": "I'm not sure I understand what a ProcessFileWrapper is, as this isn't explained in this JavaDocs.  However, it might make more sense once the REST Contract is updated with examples.", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r432565198", "createdAt": "2020-05-29T15:31:32Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/model/ProcessFileWrapperRest.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.model;\n+\n+import java.util.List;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+\n+\n+/**\n+ * The ProcessFileWrapper REST Resource\n+ *\n+ */\n+public class ProcessFileWrapperRest implements RestModel {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47b75f313e543923997cbe8c2ae717323aea7170"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU2NjcwNg==", "bodyText": "If we are changing the behavior to be a 405 response, we only need to test that once.  So, this test is now unneeded, as you already test that the endpoint returns a 405 above.", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r432566706", "createdAt": "2020-05-29T15:33:55Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/BitstreamRestRepositoryIT.java", "diffHunk": "@@ -162,33 +155,13 @@ public void findAllPaginationTest() throws Exception {\n         getClient(token).perform(get(\"/api/core/bitstreams/\")\n                    .param(\"size\", \"1\")\n                    .param(\"projection\", \"full\"))\n-                   .andExpect(status().isOk())\n-                   .andExpect(content().contentType(contentType))\n-                   .andExpect(jsonPath(\"$._embedded.bitstreams\", Matchers.contains(\n-                       BitstreamMatcher.matchBitstreamEntry(bitstream))\n-                   ))\n-                   .andExpect(jsonPath(\"$._embedded.bitstreams\", Matchers.not(\n-                       Matchers.contains(\n-                           BitstreamMatcher.matchBitstreamEntry(bitstream1))\n-                                       )\n-                   ))\n-\n-        ;\n+                   .andExpect(status().isMethodNotAllowed());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47b75f313e543923997cbe8c2ae717323aea7170"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU2NzA3Ng==", "bodyText": "Same here, this test can be removed, we already test for 405 response above.  Retesting with different params isn't really necessary.", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r432567076", "createdAt": "2020-05-29T15:34:36Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/BitstreamRestRepositoryIT.java", "diffHunk": "@@ -162,33 +155,13 @@ public void findAllPaginationTest() throws Exception {\n         getClient(token).perform(get(\"/api/core/bitstreams/\")\n                    .param(\"size\", \"1\")\n                    .param(\"projection\", \"full\"))\n-                   .andExpect(status().isOk())\n-                   .andExpect(content().contentType(contentType))\n-                   .andExpect(jsonPath(\"$._embedded.bitstreams\", Matchers.contains(\n-                       BitstreamMatcher.matchBitstreamEntry(bitstream))\n-                   ))\n-                   .andExpect(jsonPath(\"$._embedded.bitstreams\", Matchers.not(\n-                       Matchers.contains(\n-                           BitstreamMatcher.matchBitstreamEntry(bitstream1))\n-                                       )\n-                   ))\n-\n-        ;\n+                   .andExpect(status().isMethodNotAllowed());\n \n         getClient(token).perform(get(\"/api/core/bitstreams/\")\n                                 .param(\"size\", \"1\")\n                                 .param(\"page\", \"1\")\n                                 .param(\"projection\", \"full\"))\n-                   .andExpect(status().isOk())\n-                   .andExpect(content().contentType(contentType))\n-                   .andExpect(jsonPath(\"$._embedded.bitstreams\", Matchers.contains(\n-                       BitstreamMatcher.matchBitstreamEntry(bitstream1)\n-                   )))\n-                   .andExpect(jsonPath(\"$._embedded.bitstreams\", Matchers.not(\n-                       Matchers.contains(\n-                           BitstreamMatcher.matchBitstreamEntry(bitstream)\n-                       )\n-                   )));\n+                   .andExpect(status().isMethodNotAllowed());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47b75f313e543923997cbe8c2ae717323aea7170"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU3MTUwNw==", "bodyText": "Recently we've discovered this form of cleanup after a POST is incredibly inefficient (and sloooow).  The recommended way to do cleanup after a POST can be found in this recent PR: #2759.  Here's also a good example on master in the EPersonRestRepositoryIT:\n\nFirst use an andDo to capture the ID of the created object (which is more efficient then pulling down the entire response): https://github.com/DSpace/DSpace/blob/master/dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java#L107-L108\nThen, use (or create) a Builder deletion method in a finally block: https://github.com/DSpace/DSpace/blob/master/dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java#L119-L122\n\nPlease refactor this test to do something similar, as it'll help us retain consistency & speed up our tests. Thanks!", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r432571507", "createdAt": "2020-05-29T15:41:42Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/ScriptRestRepositoryIT.java", "diffHunk": "@@ -155,12 +178,22 @@ public void postProcessAdminWrongOptionsException() throws Exception {\n \n         String token = getAuthToken(admin.getEmail(), password);\n \n-        getClient(token).perform(post(\"/api/system/scripts/mock-script/processes\").contentType(\"multipart/form-data\"))\n-                        .andExpect(status().isAccepted())\n-                        .andExpect(jsonPath(\"$\", is(\n-                            ProcessMatcher.matchProcess(\"mock-script\",\n-                                                        String.valueOf(admin.getID()), new LinkedList<>(),\n-                                                        ProcessStatus.FAILED))));\n+        MvcResult mvcResult = getClient(token)\n+            .perform(post(\"/api/system/scripts/mock-script/processes\").contentType(\"multipart/form-data\"))\n+            .andExpect(status().isAccepted())\n+            .andExpect(jsonPath(\"$\", is(\n+                ProcessMatcher.matchProcess(\"mock-script\",\n+                                            String.valueOf(admin.getID()), new LinkedList<>(),\n+                                            ProcessStatus.FAILED)))).andReturn();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String content = mvcResult.getResponse().getContentAsString();\n+        Map<String, Object> map = mapper.readValue(content, Map.class);\n+        Integer processId = Integer.valueOf(String.valueOf(map.get(\"processId\")));\n+\n+        getClient(token).perform(delete(\"/api/system/processes/\" + processId));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47b75f313e543923997cbe8c2ae717323aea7170"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU4MDUyOQ==", "bodyText": "Same here, please refactor this cleanup after POST as described above.", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r432580529", "createdAt": "2020-05-29T15:55:19Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/ScriptRestRepositoryIT.java", "diffHunk": "@@ -182,19 +215,28 @@ public void postProcessAdminNoOptionsFailedStatus() throws Exception {\n         parameters.add(new DSpaceCommandLineParameter(\"-q\", null));\n \n         List<ParameterValueRest> list = parameters.stream()\n-                .map(dSpaceCommandLineParameter -> dSpaceRunnableParameterConverter\n-                        .convert(dSpaceCommandLineParameter, Projection.DEFAULT)).collect(Collectors.toList());\n+                                                  .map(dSpaceCommandLineParameter -> dSpaceRunnableParameterConverter\n+                                                      .convert(dSpaceCommandLineParameter, Projection.DEFAULT))\n+                                                  .collect(Collectors.toList());\n \n         String token = getAuthToken(admin.getEmail(), password);\n \n-        getClient(token).perform(post(\"/api/system/scripts/mock-script/processes\").contentType(\"multipart/form-data\")\n-                                                                                  .param(\"properties\",\n-                                                                                         new Gson().toJson(list)))\n-                        .andExpect(status().isAccepted())\n-                        .andExpect(jsonPath(\"$\", is(\n-                            ProcessMatcher.matchProcess(\"mock-script\",\n-                                                        String.valueOf(admin.getID()), parameters,\n-                                                        ProcessStatus.FAILED))));\n+        MvcResult mvcResult = getClient(token)\n+            .perform(post(\"/api/system/scripts/mock-script/processes\").contentType(\"multipart/form-data\")\n+                                                                      .param(\"properties\",\n+                                                                             new Gson().toJson(list)))\n+            .andExpect(status().isAccepted())\n+            .andExpect(jsonPath(\"$\", is(\n+                ProcessMatcher.matchProcess(\"mock-script\",\n+                                            String.valueOf(admin.getID()), parameters,\n+                                            ProcessStatus.FAILED)))).andReturn();\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String content = mvcResult.getResponse().getContentAsString();\n+        Map<String, Object> map = mapper.readValue(content, Map.class);\n+        Integer processId = Integer.valueOf(String.valueOf(map.get(\"processId\")));\n+\n+        getClient(token).perform(delete(\"/api/system/processes/\" + processId));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47b75f313e543923997cbe8c2ae717323aea7170"}, "originalPosition": 197}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU4MDY5OA==", "bodyText": "Same here, please refactor this cleanup after POST as described above.", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r432580698", "createdAt": "2020-05-29T15:55:37Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/ScriptRestRepositoryIT.java", "diffHunk": "@@ -214,24 +256,34 @@ public void postProcessAdminWithOptionsSuccess() throws Exception {\n         parameters.add(new DSpaceCommandLineParameter(\"-i\", null));\n \n         List<ParameterValueRest> list = parameters.stream()\n-                .map(dSpaceCommandLineParameter -> dSpaceRunnableParameterConverter\n-                        .convert(dSpaceCommandLineParameter, Projection.DEFAULT)).collect(Collectors.toList());\n+                                                  .map(dSpaceCommandLineParameter -> dSpaceRunnableParameterConverter\n+                                                      .convert(dSpaceCommandLineParameter, Projection.DEFAULT))\n+                                                  .collect(Collectors.toList());\n \n         String token = getAuthToken(admin.getEmail(), password);\n         List<ProcessStatus> acceptableProcessStatuses = new LinkedList<>();\n         acceptableProcessStatuses.addAll(Arrays.asList(ProcessStatus.SCHEDULED,\n                                                        ProcessStatus.RUNNING,\n                                                        ProcessStatus.COMPLETED));\n \n-        getClient(token).perform(post(\"/api/system/scripts/mock-script/processes\").contentType(\"multipart/form-data\")\n-                                                                                  .param(\"properties\",\n-                                                                                         new Gson().toJson(list)))\n-                        .andExpect(status().isAccepted())\n-                        .andExpect(jsonPath(\"$\", is(\n-                            ProcessMatcher.matchProcess(\"mock-script\",\n-                                                        String.valueOf(admin.getID()),\n-                                                        parameters,\n-                                                        acceptableProcessStatuses))));\n+        MvcResult mvcResult = getClient(token)\n+            .perform(post(\"/api/system/scripts/mock-script/processes\").contentType(\"multipart/form-data\")\n+                                                                      .param(\"properties\",\n+                                                                             new Gson().toJson(list)))\n+            .andExpect(status().isAccepted())\n+            .andExpect(jsonPath(\"$\", is(\n+                ProcessMatcher.matchProcess(\"mock-script\",\n+                                            String.valueOf(admin.getID()),\n+                                            parameters,\n+                                            acceptableProcessStatuses)))).andReturn();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String content = mvcResult.getResponse().getContentAsString();\n+        Map<String, Object> map = mapper.readValue(content, Map.class);\n+        Integer processId = Integer.valueOf(String.valueOf(map.get(\"processId\")));\n+\n+        getClient(token).perform(delete(\"/api/system/processes/\" + processId));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47b75f313e543923997cbe8c2ae717323aea7170"}, "originalPosition": 243}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU4MDk2Ng==", "bodyText": "Same here, please refactor this cleanup after POST as described above.", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r432580966", "createdAt": "2020-05-29T15:56:05Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/ScriptRestRepositoryIT.java", "diffHunk": "@@ -243,12 +295,78 @@ public void postProcessAdminWithWrongContentTypeBadRequestException() throws Exc\n                         .andExpect(status().isBadRequest());\n     }\n \n+    @Test\n+    public void postProcessAdminWithFileSuccess() throws Exception {\n+        LinkedList<DSpaceCommandLineParameter> parameters = new LinkedList<>();\n+\n+        parameters.add(new DSpaceCommandLineParameter(\"-r\", \"test\"));\n+        parameters.add(new DSpaceCommandLineParameter(\"-i\", null));\n+\n+\n+        context.turnOffAuthorisationSystem();\n+\n+        parentCommunity = CommunityBuilder.createCommunity(context)\n+                                          .withName(\"Parent Community\")\n+                                          .build();\n+        Community child1 = CommunityBuilder.createSubCommunity(context, parentCommunity)\n+                                           .withName(\"Sub Community\")\n+                                           .build();\n+        Collection col1 = CollectionBuilder.createCollection(context, child1).withName(\"Collection 1\").build();\n+        Collection col2 = CollectionBuilder.createCollection(context, child1).withName(\"Collection 2\").build();\n+\n+        //2. Three public items that are readable by Anonymous with different subjects\n+        Item publicItem1 = ItemBuilder.createItem(context, col1)\n+                                      .withTitle(\"Public item 1\")\n+                                      .withIssueDate(\"2017-10-17\")\n+                                      .withAuthor(\"Smith, Donald\").withAuthor(\"Doe, John\")\n+                                      .withSubject(\"ExtraEntry\")\n+                                      .build();\n+\n+        String bitstreamContent = \"Hello, World!\";\n+        MockMultipartFile bitstreamFile = new MockMultipartFile(\"file\",\n+                                                                \"helloProcessFile.txt\", MediaType.TEXT_PLAIN_VALUE,\n+                                                                bitstreamContent.getBytes());\n+        parameters.add(new DSpaceCommandLineParameter(\"-f\", \"helloProcessFile.txt\"));\n+\n+        List<ParameterValueRest> list = parameters.stream()\n+                                                  .map(dSpaceCommandLineParameter -> dSpaceRunnableParameterConverter\n+                                                      .convert(dSpaceCommandLineParameter, Projection.DEFAULT))\n+                                                  .collect(Collectors.toList());\n+\n+        String token = getAuthToken(admin.getEmail(), password);\n+        List<ProcessStatus> acceptableProcessStatuses = new LinkedList<>();\n+        acceptableProcessStatuses.addAll(Arrays.asList(ProcessStatus.SCHEDULED,\n+                                                       ProcessStatus.RUNNING,\n+                                                       ProcessStatus.COMPLETED));\n+\n+        MvcResult mvcResult = getClient(token)\n+            .perform(fileUpload(\"/api/system/scripts/mock-script/processes\").file(bitstreamFile)\n+                                                                            .param(\"properties\",\n+                                                                                   new Gson().toJson(list)))\n+            .andExpect(status().isAccepted())\n+            .andExpect(jsonPath(\"$\", is(\n+                ProcessMatcher.matchProcess(\"mock-script\",\n+                                            String.valueOf(admin.getID()),\n+                                            parameters,\n+                                            acceptableProcessStatuses)))).andReturn();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String content = mvcResult.getResponse().getContentAsString();\n+        Map<String, Object> map = mapper.readValue(content, Map.class);\n+        Integer processId = Integer.valueOf(String.valueOf(map.get(\"processId\")));\n+\n+        getClient(token).perform(delete(\"/api/system/processes/\" + processId));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47b75f313e543923997cbe8c2ae717323aea7170"}, "originalPosition": 312}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU4MzkzNg==", "bodyText": "Tiny thing, but I'd recommend we name this something like \"DSpace Internal Types Registry\" just to make it clear these are internal fields.  Plus that aligns well with the titles in other registries.", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r432583936", "createdAt": "2020-05-29T16:00:53Z", "author": {"login": "tdonohue"}, "path": "dspace/config/registries/dspace-types.xml", "diffHunk": "@@ -0,0 +1,20 @@\n+<dspace-dc-types>\n+\n+    <dspace-header>\n+        <title>DSpace Types</title>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47b75f313e543923997cbe8c2ae717323aea7170"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5d7524970cb63dc903f778fa5b248dad16758415", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/5d7524970cb63dc903f778fa5b248dad16758415", "committedDate": "2020-06-09T13:04:51Z", "message": "[Task 71272] applied feedback to the Scripts and Processes functionality"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e464ec0f8cfac7031dd0a15ff7b30ff2e50c8464", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/e464ec0f8cfac7031dd0a15ff7b30ff2e50c8464", "committedDate": "2020-06-09T13:06:39Z", "message": "[Task 71272] minor cleanup to the Scripts and Processes functionality"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5MjcxMDIx", "url": "https://github.com/DSpace/DSpace/pull/2648#pullrequestreview-429271021", "createdAt": "2020-06-11T20:36:36Z", "commit": {"oid": "e464ec0f8cfac7031dd0a15ff7b30ff2e50c8464"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b32c461006ecb8ae32222199891c0025e7b694ab", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/b32c461006ecb8ae32222199891c0025e7b694ab", "committedDate": "2020-06-15T12:58:11Z", "message": "[Task 71405] applied community feedback to the Scripts and Processes endpoints"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "31c87c2ba1d6771def879dd7d15eb03f59310984", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/31c87c2ba1d6771def879dd7d15eb03f59310984", "committedDate": "2020-06-16T07:46:01Z", "message": "[Task 71405] fixed the Process Files endpoints and added two tests for them"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "de357b581c3b70973000e2b4dd19428eba5d3377", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/de357b581c3b70973000e2b4dd19428eba5d3377", "committedDate": "2020-06-18T10:49:43Z", "message": "[Task 71441] altered the processFiles endpoint and added the process filetypes endpoint with tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "57d63c211eb53dd9c28fad1597c54b92516b3d63", "author": {"user": {"login": "Raf-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/57d63c211eb53dd9c28fad1597c54b92516b3d63", "committedDate": "2020-06-18T10:58:23Z", "message": "[Task 71441] added javadoc and minor cleanup"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1MTM2NjY1", "url": "https://github.com/DSpace/DSpace/pull/2648#pullrequestreview-435136665", "createdAt": "2020-06-22T17:33:32Z", "commit": {"oid": "57d63c211eb53dd9c28fad1597c54b92516b3d63"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1562, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}