{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI0MTU4Mzk0", "number": 2773, "reviewThreads": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMDoyODowMVrOEBr6bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMjoyODoxMlrOED2c3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMjAzNTAzOnYy", "diffSide": "RIGHT", "path": "dspace-api/src/main/java/org/dspace/app/sherpa/v2/SHERPAJournal.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMDoyODowMVrOGdrnIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMVQwMjoxNDo0NFrOGmpN9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc3NjQxOA==", "bodyText": "please add a basic javadoc here", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r433776418", "createdAt": "2020-06-02T10:28:01Z", "author": {"login": "abollini"}, "path": "dspace-api/src/main/java/org/dspace/app/sherpa/v2/SHERPAJournal.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.sherpa.v2;\n+\n+import java.util.List;\n+\n+public class SHERPAJournal {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE3NDM4OA==", "bodyText": "Done! See commit af615a37", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r443174388", "createdAt": "2020-06-21T02:14:44Z", "author": {"login": "kshepherd"}, "path": "dspace-api/src/main/java/org/dspace/app/sherpa/v2/SHERPAJournal.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.sherpa.v2;\n+\n+import java.util.List;\n+\n+public class SHERPAJournal {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc3NjQxOA=="}, "originalCommit": null, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMjA0NDE1OnYy", "diffSide": "RIGHT", "path": "dspace-api/src/main/java/org/dspace/app/sherpa/SHERPAService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMDozMToxMVrOGdrtIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMVQwNDowMjoxNVrOGmphBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc3Nzk1NA==", "bodyText": "should we rethrow the exception here?", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r433777954", "createdAt": "2020-06-02T10:31:11Z", "author": {"login": "abollini"}, "path": "dspace-api/src/main/java/org/dspace/app/sherpa/SHERPAService.java", "diffHunk": "@@ -91,12 +108,22 @@ public SHERPAResponse searchByJournalISSN(String query) {\n                 HttpEntity responseBody = response.getEntity();\n \n                 if (null != responseBody) {\n-                    sherpaResponse = new SHERPAResponse(responseBody.getContent());\n+                    InputStream content = null;\n+                    try {\n+                        content = responseBody.getContent();\n+                        sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                    } catch (IOException e) {\n+                        log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                    } finally {\n+                        if (content != null) {\n+                            content.close();\n+                        }\n+                    }\n                 } else {\n                     sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO returned no response\");\n                 }\n             } catch (Exception e) {\n-                log.warn(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE3OTI3MA==", "bodyText": "We have to handle at least 3 exception types here (Interrupted, for sleep, URISyntax, and IO) - and so I guess rethrow each type? Or is there a new exception type you think I should throw?\nUnlike the provider classes, this one is OK to change in terms of exception usage since it isn't currently used by anything (presumably the REST API can use it in future), and doesn't implement any superclasses.\nIf you want me to rethrow each exception type in its own catch, that's fine. If you want me to use Exception, that's fine too. There must be one that works best though... HttpResponseException?", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r443179270", "createdAt": "2020-06-21T04:02:15Z", "author": {"login": "kshepherd"}, "path": "dspace-api/src/main/java/org/dspace/app/sherpa/SHERPAService.java", "diffHunk": "@@ -91,12 +108,22 @@ public SHERPAResponse searchByJournalISSN(String query) {\n                 HttpEntity responseBody = response.getEntity();\n \n                 if (null != responseBody) {\n-                    sherpaResponse = new SHERPAResponse(responseBody.getContent());\n+                    InputStream content = null;\n+                    try {\n+                        content = responseBody.getContent();\n+                        sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                    } catch (IOException e) {\n+                        log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                    } finally {\n+                        if (content != null) {\n+                            content.close();\n+                        }\n+                    }\n                 } else {\n                     sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO returned no response\");\n                 }\n             } catch (Exception e) {\n-                log.warn(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc3Nzk1NA=="}, "originalCommit": null, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMjA0NzI1OnYy", "diffSide": "RIGHT", "path": "dspace-api/src/main/java/org/dspace/app/sherpa/SHERPAService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMDozMjoxOFrOGdrvGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMVQwNDoxOTowOVrOGmpkOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc3ODQ1Ng==", "bodyText": "should we rethrow the exception?", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r433778456", "createdAt": "2020-06-02T10:32:18Z", "author": {"login": "abollini"}, "path": "dspace-api/src/main/java/org/dspace/app/sherpa/SHERPAService.java", "diffHunk": "@@ -91,12 +108,22 @@ public SHERPAResponse searchByJournalISSN(String query) {\n                 HttpEntity responseBody = response.getEntity();\n \n                 if (null != responseBody) {\n-                    sherpaResponse = new SHERPAResponse(responseBody.getContent());\n+                    InputStream content = null;\n+                    try {\n+                        content = responseBody.getContent();\n+                        sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                    } catch (IOException e) {\n+                        log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE4MDA5MA==", "bodyText": "see earlier comment - i can rethrow the internal exceptions but if you want the whole method to throw an exception(s) i just have some questions as to which is the best. the v1 version of SHERPAService did not rethrow any exceptions so i didn't implement anything new for this refactor.", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r443180090", "createdAt": "2020-06-21T04:19:09Z", "author": {"login": "kshepherd"}, "path": "dspace-api/src/main/java/org/dspace/app/sherpa/SHERPAService.java", "diffHunk": "@@ -91,12 +108,22 @@ public SHERPAResponse searchByJournalISSN(String query) {\n                 HttpEntity responseBody = response.getEntity();\n \n                 if (null != responseBody) {\n-                    sherpaResponse = new SHERPAResponse(responseBody.getContent());\n+                    InputStream content = null;\n+                    try {\n+                        content = responseBody.getContent();\n+                        sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                    } catch (IOException e) {\n+                        log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc3ODQ1Ng=="}, "originalCommit": null, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMjA0OTA2OnYy", "diffSide": "RIGHT", "path": "dspace-api/src/main/java/org/dspace/app/sherpa/v2/SHERPAPermittedVersion.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMDozMjo1OFrOGdrwSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMVQwMjoxNTowM1rOGmpOCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc3ODc2MQ==", "bodyText": "please add a basic javadoc here", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r433778761", "createdAt": "2020-06-02T10:32:58Z", "author": {"login": "abollini"}, "path": "dspace-api/src/main/java/org/dspace/app/sherpa/v2/SHERPAPermittedVersion.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.sherpa.v2;\n+\n+import java.util.List;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE3NDQxMQ==", "bodyText": "Done! See commit af615a3", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r443174411", "createdAt": "2020-06-21T02:15:03Z", "author": {"login": "kshepherd"}, "path": "dspace-api/src/main/java/org/dspace/app/sherpa/v2/SHERPAPermittedVersion.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.sherpa.v2;\n+\n+import java.util.List;\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc3ODc2MQ=="}, "originalCommit": null, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMjA0OTk4OnYy", "diffSide": "RIGHT", "path": "dspace-api/src/main/java/org/dspace/app/sherpa/v2/SHERPAPublisher.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMDozMzoxM1rOGdrw2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMVQwMjoxNToxMFrOGmpODQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc3ODkwNQ==", "bodyText": "please add a basic javadoc here", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r433778905", "createdAt": "2020-06-02T10:33:13Z", "author": {"login": "abollini"}, "path": "dspace-api/src/main/java/org/dspace/app/sherpa/v2/SHERPAPublisher.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.sherpa.v2;\n+\n+public class SHERPAPublisher {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE3NDQxMw==", "bodyText": "Done! See commit af615a3", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r443174413", "createdAt": "2020-06-21T02:15:10Z", "author": {"login": "kshepherd"}, "path": "dspace-api/src/main/java/org/dspace/app/sherpa/v2/SHERPAPublisher.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.sherpa.v2;\n+\n+public class SHERPAPublisher {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc3ODkwNQ=="}, "originalCommit": null, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMjA1MzI5OnYy", "diffSide": "RIGHT", "path": "dspace-api/src/main/java/org/dspace/app/sherpa/v2/SHERPAPublisherPolicy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMDozNDoyN1rOGdrzHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMVQwMjoxNToxN1rOGmpOEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc3OTQ4NQ==", "bodyText": "please add basic javadoc here", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r433779485", "createdAt": "2020-06-02T10:34:27Z", "author": {"login": "abollini"}, "path": "dspace-api/src/main/java/org/dspace/app/sherpa/v2/SHERPAPublisherPolicy.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.sherpa.v2;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public class SHERPAPublisherPolicy {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE3NDQxNw==", "bodyText": "Done! See commit af615a3", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r443174417", "createdAt": "2020-06-21T02:15:17Z", "author": {"login": "kshepherd"}, "path": "dspace-api/src/main/java/org/dspace/app/sherpa/v2/SHERPAPublisherPolicy.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.sherpa.v2;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public class SHERPAPublisherPolicy {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc3OTQ4NQ=="}, "originalCommit": null, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMjA3MzU1OnYy", "diffSide": "RIGHT", "path": "dspace-api/src/main/java/org/dspace/app/sherpa/v2/SHERPAResponse.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMDo0MToxNlrOGdr_2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMVQwMzo1NDoxNVrOGmpftA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4Mjc0Ng==", "bodyText": "this seems to prevent us to support multiple language. If the i18n support must be provided on the backend side we should use the context object to understand which is the locale in use otherwise we should keep the \"key\" in the response to allow the UI to apply its own translation mechanism", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r433782746", "createdAt": "2020-06-02T10:41:16Z", "author": {"login": "abollini"}, "path": "dspace-api/src/main/java/org/dspace/app/sherpa/v2/SHERPAResponse.java", "diffHunk": "@@ -0,0 +1,533 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.sherpa.v2;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+import org.apache.log4j.Logger;\n+import org.dspace.core.I18nUtil;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.json.JSONTokener;\n+\n+/**\n+ * Model class for the SHERPAv2 API (JSON) response for a publication (journal) search\n+ * The structure and approached used is quite different to the simple v1 API used previously\n+ * \n+ * @author Kim Shepherd\n+ * \n+ */\n+public class SHERPAResponse {\n+    // Is this response to be treated as an error?\n+    private boolean error;\n+\n+    // Error message\n+    private String message;\n+\n+    // Parsed system metadata from search results\n+    private SHERPASystemMetadata metadata;\n+\n+    // List of parsed journal results\n+    private List<SHERPAJournal> journals;\n+\n+    // Internal Sherpa ID\n+    private int id;\n+\n+    // SHERPA URI (the human page version of this API response)\n+    private String uri;\n+\n+    // Format enum - currently only JSON is supported\n+    public enum SHERPAFormat {\n+        JSON, XML\n+    };\n+\n+    private static Logger log = Logger.getLogger(SHERPAResponse.class);\n+\n+    /**\n+     * Parse SHERPA v2 API for a given format\n+     * @param input - input stream from the HTTP response content\n+     * @param format - requested format\n+     * @throws IOException\n+     */\n+    public SHERPAResponse(InputStream input, SHERPAFormat format) throws IOException {\n+        if (format == SHERPAFormat.JSON) {\n+            parseJSON(input);\n+        }\n+    }\n+\n+    /**\n+     * Parse the SHERPA v2 API JSON and construct Romeo policy data for display\n+     * This method does not return a value, but rather populates the metadata and journals objects\n+     * with data parsed from the JSON.\n+     * @param jsonData - the JSON input stream from the API result response body\n+     */\n+    private void parseJSON(InputStream jsonData) throws IOException {\n+        InputStreamReader streamReader = new InputStreamReader(jsonData);\n+        JSONTokener jsonTokener = new JSONTokener(streamReader);\n+        JSONObject httpResponse;\n+        try {\n+            httpResponse = new JSONObject(jsonTokener);\n+            if (httpResponse.has(\"items\")) {\n+                JSONArray items = httpResponse.getJSONArray(\"items\");\n+\n+                // items array is search results, *not* journals or publishers - they are listed for each item\n+                // - however, we only ever want one result since we're passing an \"equals ISSN\" query\n+                if (items.length() > 0) {\n+                    metadata = new SHERPASystemMetadata();\n+                    this.journals = new LinkedList<>();\n+                    // Iterate search result items\n+                    for (int itemIndex = 0; itemIndex < items.length(); itemIndex++) {\n+                        List<SHERPAPublisher> sherpaPublishers = new LinkedList<>();\n+                        List<SHERPAPublisherPolicy> policies = new ArrayList<>();\n+                        SHERPAPublisher sherpaPublisher = new SHERPAPublisher();\n+                        SHERPAJournal sherpaJournal = new SHERPAJournal();\n+\n+                        JSONObject item = items.getJSONObject(0);\n+\n+                        // Parse system metadata (per-item / result information)\n+                        if (item.has(\"system_metadata\")) {\n+                            JSONObject systemMetadata = item.getJSONObject(\"system_metadata\");\n+                            metadata = parseSystemMetadata(systemMetadata);\n+                        }\n+\n+                        // Parse \"publisher policy\"\n+                        // note - most of the information that was previously under 'publisher' is now under here\n+                        if (item.has(\"publisher_policy\")) {\n+\n+                            // Parse main publisher policies node\n+                            JSONArray publisherPolicies = item.getJSONArray(\"publisher_policy\");\n+                            for (int i = 0; i < publisherPolicies.length(); i++) {\n+\n+                                JSONObject policy = publisherPolicies.getJSONObject(i);\n+\n+                                // Special case - quickly check the policy for the 'paid access' option\n+                                // and continue if found, then parse the rest of the policy\n+                                String moniker = null;\n+                                if (policy.has(\"internal_moniker\")) {\n+                                    moniker = policy.getString(\"internal_moniker\");\n+                                }\n+                                // This seems to be usually policy(ies) for the journal proper\n+                                // and then an \"Open access option\" which contains some of the info\n+                                // that the 'paidaccess' node in the old API used to contain\n+                                // Look for: internal_moniker = \"Open access option\"\n+                                // Check if this is OA options (Paid Access) or not\n+                                if (\"Open access option\".equalsIgnoreCase(moniker)) {\n+                                    log.debug(\"This is the Open access options policy - a special case\");\n+                                    if (policy.has(\"urls\")) {\n+                                        JSONArray urls = policy.getJSONArray(\"urls\");\n+                                        for (int u = 0; u < urls.length(); u++) {\n+                                            JSONObject url = urls.getJSONObject(u);\n+                                            if (url.has(\"description\") &&\n+                                                \"Open Access\".equalsIgnoreCase(url.getString(\"description\"))) {\n+                                                log.debug(\"Found OA paid access url: \" + url.getString(\"url\"));\n+                                                sherpaPublisher.setPaidAccessDescription(url.getString(\"description\"));\n+                                                sherpaPublisher.setPaidAccessUrl(url.getString(\"url\"));\n+                                                break;\n+                                            }\n+                                        }\n+                                    }\n+                                    // Continue the loop here - this \"policy\" is a bit different and we\n+                                    // don't want to add irrelevant conditions to the policy\n+                                    continue;\n+                                }\n+\n+                                // Parse the main publisher policy object and add to the list\n+                                SHERPAPublisherPolicy sherpaPublisherPolicy = parsePublisherPolicy(policy);\n+                                policies.add(sherpaPublisherPolicy);\n+                            }\n+\n+                            // set publisher name - note we're only looking for the first name here\n+                            // as per previous functionality (for simple display)\n+                            if (item.has(\"publishers\")) {\n+                                JSONArray publishers = item.getJSONArray(\"publishers\");\n+                                if (publishers.length() > 0) {\n+                                    JSONObject publisherElement = publishers.getJSONObject(0);\n+                                    if (publisherElement.has(\"publisher\")) {\n+                                        JSONObject publisher = publisherElement.getJSONObject(\"publisher\");\n+                                        sherpaPublisher.setName(parsePublisherName(publisher));\n+                                        sherpaPublisher.setUri(parsePublisherURL(publisher));\n+                                    }\n+                                }\n+                            }\n+\n+                            // Parse journal data\n+                            sherpaJournal = parseJournal(item, sherpaPublisher.getName());\n+                        }\n+\n+                        sherpaPublishers.add(sherpaPublisher);\n+                        sherpaJournal.setPublisher(sherpaPublisher);\n+                        sherpaJournal.setPublishers(sherpaPublishers);\n+                        sherpaJournal.setPolicies(policies);\n+                        this.journals.add(sherpaJournal);\n+                    }\n+\n+                } else {\n+                    error = true;\n+                    message = \"No results found\";\n+                }\n+            } else {\n+                error = true;\n+                message = \"No results found\";\n+            }\n+\n+        } catch (JSONException e) {\n+            log.error(\"Failed to parse SHERPA response\", e);\n+            error = true;\n+        } finally {\n+            streamReader.close();\n+        }\n+    }\n+\n+    /**\n+     * Parse system metadata and return populated SHERPASystemMetadata object\n+     * @param systemMetadata\n+     */\n+    private SHERPASystemMetadata parseSystemMetadata(JSONObject systemMetadata) {\n+\n+        SHERPASystemMetadata metadata = new SHERPASystemMetadata();\n+\n+        if (systemMetadata.has(\"uri\")) {\n+            this.uri = systemMetadata.getString(\"uri\");\n+            metadata.setUri(this.uri);\n+        } else {\n+            log.error(\"SHERPA URI missing for API response item\");\n+        }\n+        if (systemMetadata.has(\"id\")) {\n+            this.id = systemMetadata.getInt(\"id\");\n+            metadata.setId(this.id);\n+        } else {\n+            log.error(\"SHERPA internal ID missing for API response item\");\n+        }\n+        // Get date created and added - DSpace expects this in the publisher object, though\n+        if (systemMetadata.has(\"date_created\")) {\n+            metadata.setDateCreated(systemMetadata.getString(\"date_created\"));\n+        }\n+        if (systemMetadata.has(\"date_modified\")) {\n+            metadata.setDateModified(systemMetadata.getString(\"date_modified\"));\n+        }\n+        // Is this item publicly visible?\n+        if (systemMetadata.has(\"publicly_visible\")) {\n+            metadata.setPubliclyVisible (\"yes\".equals(systemMetadata\n+                .getString(\"publicly_visible\")));\n+        }\n+        // Is this item listed in the DOAJ?\n+        if (systemMetadata.has(\"listed_in_doaj\")) {\n+            metadata.setPubliclyVisible (\"yes\".equals(systemMetadata\n+                .getString(\"listed_in_doaj\")));\n+        }\n+\n+        return metadata;\n+    }\n+\n+    /**\n+     * Parse journal JSON data and return populated bean\n+     * This method also takes publisherName as a string to help construct some\n+     * legacy labels\n+     * @param item - the main result item JSON (which is the closest thing to an actual 'journal')\n+     * @param publisherName - the parsed publisher name\n+     * @return\n+     */\n+    private SHERPAJournal parseJournal(JSONObject item, String publisherName) {\n+\n+        SHERPAJournal sherpaJournal = new SHERPAJournal();\n+\n+        // set journal title\n+        if (item.has(\"title\")) {\n+            JSONArray titles = item.getJSONArray(\"title\");\n+            if (titles.length() > 0) {\n+                List<String> titleList = new ArrayList<>();\n+                for (int t = 0; t < titles.length(); t++) {\n+                    JSONObject title = titles.getJSONObject(t);\n+                    if (title.has(\"title\")) {\n+                        titleList.add(title.getString(\"title\").trim());\n+                    }\n+                }\n+                sherpaJournal.setTitles(titleList);\n+                if (titleList.size() > 0) {\n+                    // Faking this a bit based on what I'd seen - not in the API v2 data\n+                    sherpaJournal.setRomeoPub(publisherName + \": \"\n+                        + titleList.get(0));\n+                    sherpaJournal.setZetoPub(publisherName + \": \"\n+                        + titleList.get(0));\n+                }\n+            }\n+        }\n+\n+        // Journal URL\n+        if (item.has(\"url\")) {\n+            sherpaJournal.setUrl(item.getString(\"url\"));\n+        }\n+\n+        // set ISSNs\n+        if (item.has(\"issns\")) {\n+            JSONArray issns = item.getJSONArray(\"issns\");\n+            // just get first - DSpace data model only allows for one\n+            List<String> issnList = new ArrayList<>();\n+            for (int ii = 0; ii < issns.length(); ii++) {\n+                JSONObject issn = issns.getJSONObject(ii);\n+                issnList.add(issn.getString(\"issn\").trim());\n+            }\n+            sherpaJournal.setIssns(issnList);\n+        }\n+\n+        // Is the item in DOAJ?\n+        if (item.has(\"listed_in_doaj\")) {\n+            sherpaJournal.setInDOAJ((\"yes\".equals(item.getString(\"listed_in_doaj\"))));\n+        }\n+\n+        return sherpaJournal;\n+    }\n+\n+    /**\n+     * Parse a publisher_policy JSON data and return a populated bean\n+     * @param policy - each publisher policy node in the JSON array\n+     * @return populated SHERPAPublisherPolicy object\n+     */\n+    private SHERPAPublisherPolicy parsePublisherPolicy(JSONObject policy) {\n+\n+        SHERPAPublisherPolicy sherpaPublisherPolicy = new SHERPAPublisherPolicy();\n+\n+        // Get and set monikers\n+        String moniker = null;\n+        if (policy.has(\"internal_moniker\")) {\n+            moniker = policy.getString(\"internal_moniker\");\n+            sherpaPublisherPolicy.setInternalMoniker(moniker);\n+        }\n+\n+        // URLs (used to be Copyright Links)\n+        if (policy.has(\"urls\")) {\n+            JSONArray urls = policy.getJSONArray(\"urls\");\n+            Map<String, String> copyrightLinks = new TreeMap<>();\n+            for (int u = 0; u < urls.length(); u++) {\n+                JSONObject url = urls.getJSONObject(u);\n+                if (url.has(\"description\") && url.has(\"url\")) {\n+                    log.debug(\"Setting copyright URL: \" + url.getString(\"url\"));\n+                    copyrightLinks.put(url.getString(\"url\"), url.getString(\"description\"));\n+                }\n+            }\n+            sherpaPublisherPolicy.setUrls(copyrightLinks);\n+        }\n+\n+        // Permitted OA options\n+        int submittedOption = 0;\n+        int acceptedOption = 0;\n+        int publishedOption = 0;\n+        int currentOption = 0;\n+        if (policy.has(\"permitted_oa\")) {\n+            List<String> allowed = new ArrayList<>();\n+            JSONArray permittedOA = policy.getJSONArray(\"permitted_oa\");\n+            List<SHERPAPermittedVersion> permittedVersions = new ArrayList<>();\n+\n+            // Iterate each permitted OA version / option\n+            for (int p = 0; p < permittedOA.length(); p++) {\n+                JSONObject permitted = permittedOA.getJSONObject(p);\n+                SHERPAPermittedVersion permittedVersion = parsePermittedVersion(permitted);\n+\n+                // To determine which option # we are, inspect article versions and set\n+                allowed.add(permittedVersion.getArticleVersion());\n+                if (\"submitted\".equals(permittedVersion.getArticleVersion())) {\n+                    submittedOption++;\n+                    currentOption = submittedOption;\n+                } else if (\"accepted\".equals(permittedVersion.getArticleVersion())) {\n+                    acceptedOption++;\n+                    currentOption = acceptedOption;\n+                } else if (\"published\".equals(permittedVersion.getArticleVersion())) {\n+                    publishedOption++;\n+                    currentOption = publishedOption;\n+                }\n+                permittedVersion.setOption(currentOption);\n+                permittedVersions.add(permittedVersion);\n+\n+                // Populate the old indicators into the publisher policy object\n+                if (allowed.contains(\"submitted\")) {\n+                    sherpaPublisherPolicy.setPreArchiving(\"can\");\n+                }\n+                if (allowed.contains(\"accepted\")) {\n+                    sherpaPublisherPolicy.setPostArchiving(\"can\");\n+                }\n+                if (allowed.contains(\"published\")) {\n+                    sherpaPublisherPolicy.setPubArchiving(\"can\");\n+                }\n+\n+            }\n+            sherpaPublisherPolicy.setPermittedVersions(permittedVersions);\n+        }\n+\n+        return sherpaPublisherPolicy;\n+    }\n+\n+    /**\n+     * Parse permitted version JSON and populate new bean from the data\n+     * @param permitted - each 'permitted_oa' node in the JSON array\n+     * @return populated SHERPAPermittedVersion object\n+     */\n+    private SHERPAPermittedVersion parsePermittedVersion(JSONObject permitted) {\n+\n+        SHERPAPermittedVersion permittedVersion = new SHERPAPermittedVersion();\n+\n+        // Get the article version, which is ultimately used for the ticks / crosses\n+        // in the UI display. My assumptions around translation:\n+        // submitted = preprint\n+        // accepted = postprint\n+        // published = pdfversion\n+        String articleVersion = \"unknown\";\n+        String versionLabel = \"Unknown\";\n+\n+        if (permitted.has(\"article_version\")) {\n+            JSONArray versions = permitted.getJSONArray(\"article_version\");\n+            articleVersion = versions.getString(0);\n+            permittedVersion.setArticleVersion(articleVersion);\n+            log.debug(\"Added allowed version: \" + articleVersion + \" to list\");\n+        }\n+\n+        if (\"submitted\".equals(articleVersion)) {\n+            versionLabel = I18nUtil.getMessage(\"jsp.sherpa.submitted-version-label\");\n+        } else if (\"accepted\".equals(articleVersion)) {\n+            versionLabel = I18nUtil.getMessage(\"jsp.sherpa.accepted-version-label\");\n+        } else if (\"published\".equals(articleVersion)) {\n+            versionLabel = I18nUtil.getMessage(\"jsp.sherpa.published-version-label\");\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 402}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE3ODkzMg==", "bodyText": "This is a good point. Since the key ('submitted' or 'accepted' or 'published') is already stored in the articleVersion member variable and is available via a public getter as was the label, I have simply removed the versionLabel and its getters/setters to avoid any confusion.\nThe key can be used to build an i18n string.\nSee commit: 7cb1d1fa", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r443178932", "createdAt": "2020-06-21T03:54:15Z", "author": {"login": "kshepherd"}, "path": "dspace-api/src/main/java/org/dspace/app/sherpa/v2/SHERPAResponse.java", "diffHunk": "@@ -0,0 +1,533 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.sherpa.v2;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+import org.apache.log4j.Logger;\n+import org.dspace.core.I18nUtil;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.json.JSONTokener;\n+\n+/**\n+ * Model class for the SHERPAv2 API (JSON) response for a publication (journal) search\n+ * The structure and approached used is quite different to the simple v1 API used previously\n+ * \n+ * @author Kim Shepherd\n+ * \n+ */\n+public class SHERPAResponse {\n+    // Is this response to be treated as an error?\n+    private boolean error;\n+\n+    // Error message\n+    private String message;\n+\n+    // Parsed system metadata from search results\n+    private SHERPASystemMetadata metadata;\n+\n+    // List of parsed journal results\n+    private List<SHERPAJournal> journals;\n+\n+    // Internal Sherpa ID\n+    private int id;\n+\n+    // SHERPA URI (the human page version of this API response)\n+    private String uri;\n+\n+    // Format enum - currently only JSON is supported\n+    public enum SHERPAFormat {\n+        JSON, XML\n+    };\n+\n+    private static Logger log = Logger.getLogger(SHERPAResponse.class);\n+\n+    /**\n+     * Parse SHERPA v2 API for a given format\n+     * @param input - input stream from the HTTP response content\n+     * @param format - requested format\n+     * @throws IOException\n+     */\n+    public SHERPAResponse(InputStream input, SHERPAFormat format) throws IOException {\n+        if (format == SHERPAFormat.JSON) {\n+            parseJSON(input);\n+        }\n+    }\n+\n+    /**\n+     * Parse the SHERPA v2 API JSON and construct Romeo policy data for display\n+     * This method does not return a value, but rather populates the metadata and journals objects\n+     * with data parsed from the JSON.\n+     * @param jsonData - the JSON input stream from the API result response body\n+     */\n+    private void parseJSON(InputStream jsonData) throws IOException {\n+        InputStreamReader streamReader = new InputStreamReader(jsonData);\n+        JSONTokener jsonTokener = new JSONTokener(streamReader);\n+        JSONObject httpResponse;\n+        try {\n+            httpResponse = new JSONObject(jsonTokener);\n+            if (httpResponse.has(\"items\")) {\n+                JSONArray items = httpResponse.getJSONArray(\"items\");\n+\n+                // items array is search results, *not* journals or publishers - they are listed for each item\n+                // - however, we only ever want one result since we're passing an \"equals ISSN\" query\n+                if (items.length() > 0) {\n+                    metadata = new SHERPASystemMetadata();\n+                    this.journals = new LinkedList<>();\n+                    // Iterate search result items\n+                    for (int itemIndex = 0; itemIndex < items.length(); itemIndex++) {\n+                        List<SHERPAPublisher> sherpaPublishers = new LinkedList<>();\n+                        List<SHERPAPublisherPolicy> policies = new ArrayList<>();\n+                        SHERPAPublisher sherpaPublisher = new SHERPAPublisher();\n+                        SHERPAJournal sherpaJournal = new SHERPAJournal();\n+\n+                        JSONObject item = items.getJSONObject(0);\n+\n+                        // Parse system metadata (per-item / result information)\n+                        if (item.has(\"system_metadata\")) {\n+                            JSONObject systemMetadata = item.getJSONObject(\"system_metadata\");\n+                            metadata = parseSystemMetadata(systemMetadata);\n+                        }\n+\n+                        // Parse \"publisher policy\"\n+                        // note - most of the information that was previously under 'publisher' is now under here\n+                        if (item.has(\"publisher_policy\")) {\n+\n+                            // Parse main publisher policies node\n+                            JSONArray publisherPolicies = item.getJSONArray(\"publisher_policy\");\n+                            for (int i = 0; i < publisherPolicies.length(); i++) {\n+\n+                                JSONObject policy = publisherPolicies.getJSONObject(i);\n+\n+                                // Special case - quickly check the policy for the 'paid access' option\n+                                // and continue if found, then parse the rest of the policy\n+                                String moniker = null;\n+                                if (policy.has(\"internal_moniker\")) {\n+                                    moniker = policy.getString(\"internal_moniker\");\n+                                }\n+                                // This seems to be usually policy(ies) for the journal proper\n+                                // and then an \"Open access option\" which contains some of the info\n+                                // that the 'paidaccess' node in the old API used to contain\n+                                // Look for: internal_moniker = \"Open access option\"\n+                                // Check if this is OA options (Paid Access) or not\n+                                if (\"Open access option\".equalsIgnoreCase(moniker)) {\n+                                    log.debug(\"This is the Open access options policy - a special case\");\n+                                    if (policy.has(\"urls\")) {\n+                                        JSONArray urls = policy.getJSONArray(\"urls\");\n+                                        for (int u = 0; u < urls.length(); u++) {\n+                                            JSONObject url = urls.getJSONObject(u);\n+                                            if (url.has(\"description\") &&\n+                                                \"Open Access\".equalsIgnoreCase(url.getString(\"description\"))) {\n+                                                log.debug(\"Found OA paid access url: \" + url.getString(\"url\"));\n+                                                sherpaPublisher.setPaidAccessDescription(url.getString(\"description\"));\n+                                                sherpaPublisher.setPaidAccessUrl(url.getString(\"url\"));\n+                                                break;\n+                                            }\n+                                        }\n+                                    }\n+                                    // Continue the loop here - this \"policy\" is a bit different and we\n+                                    // don't want to add irrelevant conditions to the policy\n+                                    continue;\n+                                }\n+\n+                                // Parse the main publisher policy object and add to the list\n+                                SHERPAPublisherPolicy sherpaPublisherPolicy = parsePublisherPolicy(policy);\n+                                policies.add(sherpaPublisherPolicy);\n+                            }\n+\n+                            // set publisher name - note we're only looking for the first name here\n+                            // as per previous functionality (for simple display)\n+                            if (item.has(\"publishers\")) {\n+                                JSONArray publishers = item.getJSONArray(\"publishers\");\n+                                if (publishers.length() > 0) {\n+                                    JSONObject publisherElement = publishers.getJSONObject(0);\n+                                    if (publisherElement.has(\"publisher\")) {\n+                                        JSONObject publisher = publisherElement.getJSONObject(\"publisher\");\n+                                        sherpaPublisher.setName(parsePublisherName(publisher));\n+                                        sherpaPublisher.setUri(parsePublisherURL(publisher));\n+                                    }\n+                                }\n+                            }\n+\n+                            // Parse journal data\n+                            sherpaJournal = parseJournal(item, sherpaPublisher.getName());\n+                        }\n+\n+                        sherpaPublishers.add(sherpaPublisher);\n+                        sherpaJournal.setPublisher(sherpaPublisher);\n+                        sherpaJournal.setPublishers(sherpaPublishers);\n+                        sherpaJournal.setPolicies(policies);\n+                        this.journals.add(sherpaJournal);\n+                    }\n+\n+                } else {\n+                    error = true;\n+                    message = \"No results found\";\n+                }\n+            } else {\n+                error = true;\n+                message = \"No results found\";\n+            }\n+\n+        } catch (JSONException e) {\n+            log.error(\"Failed to parse SHERPA response\", e);\n+            error = true;\n+        } finally {\n+            streamReader.close();\n+        }\n+    }\n+\n+    /**\n+     * Parse system metadata and return populated SHERPASystemMetadata object\n+     * @param systemMetadata\n+     */\n+    private SHERPASystemMetadata parseSystemMetadata(JSONObject systemMetadata) {\n+\n+        SHERPASystemMetadata metadata = new SHERPASystemMetadata();\n+\n+        if (systemMetadata.has(\"uri\")) {\n+            this.uri = systemMetadata.getString(\"uri\");\n+            metadata.setUri(this.uri);\n+        } else {\n+            log.error(\"SHERPA URI missing for API response item\");\n+        }\n+        if (systemMetadata.has(\"id\")) {\n+            this.id = systemMetadata.getInt(\"id\");\n+            metadata.setId(this.id);\n+        } else {\n+            log.error(\"SHERPA internal ID missing for API response item\");\n+        }\n+        // Get date created and added - DSpace expects this in the publisher object, though\n+        if (systemMetadata.has(\"date_created\")) {\n+            metadata.setDateCreated(systemMetadata.getString(\"date_created\"));\n+        }\n+        if (systemMetadata.has(\"date_modified\")) {\n+            metadata.setDateModified(systemMetadata.getString(\"date_modified\"));\n+        }\n+        // Is this item publicly visible?\n+        if (systemMetadata.has(\"publicly_visible\")) {\n+            metadata.setPubliclyVisible (\"yes\".equals(systemMetadata\n+                .getString(\"publicly_visible\")));\n+        }\n+        // Is this item listed in the DOAJ?\n+        if (systemMetadata.has(\"listed_in_doaj\")) {\n+            metadata.setPubliclyVisible (\"yes\".equals(systemMetadata\n+                .getString(\"listed_in_doaj\")));\n+        }\n+\n+        return metadata;\n+    }\n+\n+    /**\n+     * Parse journal JSON data and return populated bean\n+     * This method also takes publisherName as a string to help construct some\n+     * legacy labels\n+     * @param item - the main result item JSON (which is the closest thing to an actual 'journal')\n+     * @param publisherName - the parsed publisher name\n+     * @return\n+     */\n+    private SHERPAJournal parseJournal(JSONObject item, String publisherName) {\n+\n+        SHERPAJournal sherpaJournal = new SHERPAJournal();\n+\n+        // set journal title\n+        if (item.has(\"title\")) {\n+            JSONArray titles = item.getJSONArray(\"title\");\n+            if (titles.length() > 0) {\n+                List<String> titleList = new ArrayList<>();\n+                for (int t = 0; t < titles.length(); t++) {\n+                    JSONObject title = titles.getJSONObject(t);\n+                    if (title.has(\"title\")) {\n+                        titleList.add(title.getString(\"title\").trim());\n+                    }\n+                }\n+                sherpaJournal.setTitles(titleList);\n+                if (titleList.size() > 0) {\n+                    // Faking this a bit based on what I'd seen - not in the API v2 data\n+                    sherpaJournal.setRomeoPub(publisherName + \": \"\n+                        + titleList.get(0));\n+                    sherpaJournal.setZetoPub(publisherName + \": \"\n+                        + titleList.get(0));\n+                }\n+            }\n+        }\n+\n+        // Journal URL\n+        if (item.has(\"url\")) {\n+            sherpaJournal.setUrl(item.getString(\"url\"));\n+        }\n+\n+        // set ISSNs\n+        if (item.has(\"issns\")) {\n+            JSONArray issns = item.getJSONArray(\"issns\");\n+            // just get first - DSpace data model only allows for one\n+            List<String> issnList = new ArrayList<>();\n+            for (int ii = 0; ii < issns.length(); ii++) {\n+                JSONObject issn = issns.getJSONObject(ii);\n+                issnList.add(issn.getString(\"issn\").trim());\n+            }\n+            sherpaJournal.setIssns(issnList);\n+        }\n+\n+        // Is the item in DOAJ?\n+        if (item.has(\"listed_in_doaj\")) {\n+            sherpaJournal.setInDOAJ((\"yes\".equals(item.getString(\"listed_in_doaj\"))));\n+        }\n+\n+        return sherpaJournal;\n+    }\n+\n+    /**\n+     * Parse a publisher_policy JSON data and return a populated bean\n+     * @param policy - each publisher policy node in the JSON array\n+     * @return populated SHERPAPublisherPolicy object\n+     */\n+    private SHERPAPublisherPolicy parsePublisherPolicy(JSONObject policy) {\n+\n+        SHERPAPublisherPolicy sherpaPublisherPolicy = new SHERPAPublisherPolicy();\n+\n+        // Get and set monikers\n+        String moniker = null;\n+        if (policy.has(\"internal_moniker\")) {\n+            moniker = policy.getString(\"internal_moniker\");\n+            sherpaPublisherPolicy.setInternalMoniker(moniker);\n+        }\n+\n+        // URLs (used to be Copyright Links)\n+        if (policy.has(\"urls\")) {\n+            JSONArray urls = policy.getJSONArray(\"urls\");\n+            Map<String, String> copyrightLinks = new TreeMap<>();\n+            for (int u = 0; u < urls.length(); u++) {\n+                JSONObject url = urls.getJSONObject(u);\n+                if (url.has(\"description\") && url.has(\"url\")) {\n+                    log.debug(\"Setting copyright URL: \" + url.getString(\"url\"));\n+                    copyrightLinks.put(url.getString(\"url\"), url.getString(\"description\"));\n+                }\n+            }\n+            sherpaPublisherPolicy.setUrls(copyrightLinks);\n+        }\n+\n+        // Permitted OA options\n+        int submittedOption = 0;\n+        int acceptedOption = 0;\n+        int publishedOption = 0;\n+        int currentOption = 0;\n+        if (policy.has(\"permitted_oa\")) {\n+            List<String> allowed = new ArrayList<>();\n+            JSONArray permittedOA = policy.getJSONArray(\"permitted_oa\");\n+            List<SHERPAPermittedVersion> permittedVersions = new ArrayList<>();\n+\n+            // Iterate each permitted OA version / option\n+            for (int p = 0; p < permittedOA.length(); p++) {\n+                JSONObject permitted = permittedOA.getJSONObject(p);\n+                SHERPAPermittedVersion permittedVersion = parsePermittedVersion(permitted);\n+\n+                // To determine which option # we are, inspect article versions and set\n+                allowed.add(permittedVersion.getArticleVersion());\n+                if (\"submitted\".equals(permittedVersion.getArticleVersion())) {\n+                    submittedOption++;\n+                    currentOption = submittedOption;\n+                } else if (\"accepted\".equals(permittedVersion.getArticleVersion())) {\n+                    acceptedOption++;\n+                    currentOption = acceptedOption;\n+                } else if (\"published\".equals(permittedVersion.getArticleVersion())) {\n+                    publishedOption++;\n+                    currentOption = publishedOption;\n+                }\n+                permittedVersion.setOption(currentOption);\n+                permittedVersions.add(permittedVersion);\n+\n+                // Populate the old indicators into the publisher policy object\n+                if (allowed.contains(\"submitted\")) {\n+                    sherpaPublisherPolicy.setPreArchiving(\"can\");\n+                }\n+                if (allowed.contains(\"accepted\")) {\n+                    sherpaPublisherPolicy.setPostArchiving(\"can\");\n+                }\n+                if (allowed.contains(\"published\")) {\n+                    sherpaPublisherPolicy.setPubArchiving(\"can\");\n+                }\n+\n+            }\n+            sherpaPublisherPolicy.setPermittedVersions(permittedVersions);\n+        }\n+\n+        return sherpaPublisherPolicy;\n+    }\n+\n+    /**\n+     * Parse permitted version JSON and populate new bean from the data\n+     * @param permitted - each 'permitted_oa' node in the JSON array\n+     * @return populated SHERPAPermittedVersion object\n+     */\n+    private SHERPAPermittedVersion parsePermittedVersion(JSONObject permitted) {\n+\n+        SHERPAPermittedVersion permittedVersion = new SHERPAPermittedVersion();\n+\n+        // Get the article version, which is ultimately used for the ticks / crosses\n+        // in the UI display. My assumptions around translation:\n+        // submitted = preprint\n+        // accepted = postprint\n+        // published = pdfversion\n+        String articleVersion = \"unknown\";\n+        String versionLabel = \"Unknown\";\n+\n+        if (permitted.has(\"article_version\")) {\n+            JSONArray versions = permitted.getJSONArray(\"article_version\");\n+            articleVersion = versions.getString(0);\n+            permittedVersion.setArticleVersion(articleVersion);\n+            log.debug(\"Added allowed version: \" + articleVersion + \" to list\");\n+        }\n+\n+        if (\"submitted\".equals(articleVersion)) {\n+            versionLabel = I18nUtil.getMessage(\"jsp.sherpa.submitted-version-label\");\n+        } else if (\"accepted\".equals(articleVersion)) {\n+            versionLabel = I18nUtil.getMessage(\"jsp.sherpa.accepted-version-label\");\n+        } else if (\"published\".equals(articleVersion)) {\n+            versionLabel = I18nUtil.getMessage(\"jsp.sherpa.published-version-label\");\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4Mjc0Ng=="}, "originalCommit": null, "originalPosition": 402}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMjA3NjA5OnYy", "diffSide": "RIGHT", "path": "dspace-api/src/main/java/org/dspace/app/sherpa/v2/SHERPASystemMetadata.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMDo0MjowN1rOGdsBaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMVQwMjoxNjozMlrOGmpOQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4MzE0Nw==", "bodyText": "please add basic javadoc here", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r433783147", "createdAt": "2020-06-02T10:42:07Z", "author": {"login": "abollini"}, "path": "dspace-api/src/main/java/org/dspace/app/sherpa/v2/SHERPASystemMetadata.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.sherpa.v2;\n+\n+public class SHERPASystemMetadata {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE3NDQ2NQ==", "bodyText": "Done! See commit af615a3", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r443174465", "createdAt": "2020-06-21T02:16:32Z", "author": {"login": "kshepherd"}, "path": "dspace-api/src/main/java/org/dspace/app/sherpa/v2/SHERPASystemMetadata.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.sherpa.v2;\n+\n+public class SHERPASystemMetadata {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4MzE0Nw=="}, "originalCommit": null, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMjA4MTI1OnYy", "diffSide": "RIGHT", "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2JournalDataProvider.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMDo0Mzo1MFrOGdsEhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMVQwMzoyNjowMVrOGmparg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4Mzk0MQ==", "bodyText": "should we escape some special chars here? maybe double quotes?", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r433783941", "createdAt": "2020-06-02T10:43:50Z", "author": {"login": "abollini"}, "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2JournalDataProvider.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URISyntaxException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.sherpa.v2.SHERPAJournal;\n+import org.dspace.app.sherpa.v2.SHERPAResponse;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+\n+/**\n+ * This class is the implementation of the ExternalDataProvider interface that will deal with SherpaJournal External\n+ * data lookups.\n+ * This provider is a refactored version of SherpaJournalDataPublisher, rewritten to work with SHERPA v2 API\n+ *\n+ * @author Kim Shepherd\n+ */\n+public class SHERPAv2JournalDataProvider implements ExternalDataProvider {\n+\n+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(SHERPAv2JournalDataProvider.class);\n+\n+    private String url;\n+    private String sourceIdentifier;\n+    private String apiKey;\n+\n+    private CloseableHttpClient client = null;\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * Initialise the client that we need to call the endpoint\n+     * @throws IOException  If something goes wrong\n+     */\n+    public void init() throws IOException {\n+        HttpClientBuilder builder = HttpClientBuilder.create();\n+        // httpclient 4.3+ doesn't appear to have any sensible defaults any more. Setting conservative defaults as\n+        // not to hammer the SHERPA service too much.\n+        client = builder\n+            .disableAutomaticRetries()\n+            .setMaxConnTotal(5)\n+            .build();\n+    }\n+\n+    /**\n+     * Get a single journal based on a \"title equals string\" query\n+     * @param id    The journal title which will be used as query string\n+     * @return external data object representing journal\n+     */\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+\n+        HttpGet method = null;\n+        SHERPAResponse sherpaResponse = null;\n+        int timeout = 5000;\n+        URIBuilder uriBuilder = null;\n+        try {\n+            // Construct URI for an exact match on journal title\n+            uriBuilder = new URIBuilder(url);\n+            uriBuilder.addParameter(\"item-type\", \"publication\");\n+            uriBuilder.addParameter(\"filter\", \"[[\\\"title\\\",\\\"equals\\\",\\\"\" + id + \"\\\"]]\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE3NzY0Ng==", "bodyText": "After talking to SHERPA devs I have done some simple stripping for valid URI / JSON parsing. Note, the URI Builder itself already escapes/encodes for URL\nSee commit a81fe58", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r443177646", "createdAt": "2020-06-21T03:26:01Z", "author": {"login": "kshepherd"}, "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2JournalDataProvider.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URISyntaxException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.sherpa.v2.SHERPAJournal;\n+import org.dspace.app.sherpa.v2.SHERPAResponse;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+\n+/**\n+ * This class is the implementation of the ExternalDataProvider interface that will deal with SherpaJournal External\n+ * data lookups.\n+ * This provider is a refactored version of SherpaJournalDataPublisher, rewritten to work with SHERPA v2 API\n+ *\n+ * @author Kim Shepherd\n+ */\n+public class SHERPAv2JournalDataProvider implements ExternalDataProvider {\n+\n+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(SHERPAv2JournalDataProvider.class);\n+\n+    private String url;\n+    private String sourceIdentifier;\n+    private String apiKey;\n+\n+    private CloseableHttpClient client = null;\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * Initialise the client that we need to call the endpoint\n+     * @throws IOException  If something goes wrong\n+     */\n+    public void init() throws IOException {\n+        HttpClientBuilder builder = HttpClientBuilder.create();\n+        // httpclient 4.3+ doesn't appear to have any sensible defaults any more. Setting conservative defaults as\n+        // not to hammer the SHERPA service too much.\n+        client = builder\n+            .disableAutomaticRetries()\n+            .setMaxConnTotal(5)\n+            .build();\n+    }\n+\n+    /**\n+     * Get a single journal based on a \"title equals string\" query\n+     * @param id    The journal title which will be used as query string\n+     * @return external data object representing journal\n+     */\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+\n+        HttpGet method = null;\n+        SHERPAResponse sherpaResponse = null;\n+        int timeout = 5000;\n+        URIBuilder uriBuilder = null;\n+        try {\n+            // Construct URI for an exact match on journal title\n+            uriBuilder = new URIBuilder(url);\n+            uriBuilder.addParameter(\"item-type\", \"publication\");\n+            uriBuilder.addParameter(\"filter\", \"[[\\\"title\\\",\\\"equals\\\",\\\"\" + id + \"\\\"]]\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4Mzk0MQ=="}, "originalCommit": null, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMjA4Mjc5OnYy", "diffSide": "RIGHT", "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2JournalDataProvider.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMDo0NDoyMVrOGdsFdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMVQwMzozOToxN1rOGmpdEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4NDE4MA==", "bodyText": "should we rethrow the exception?", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r433784180", "createdAt": "2020-06-02T10:44:21Z", "author": {"login": "abollini"}, "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2JournalDataProvider.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URISyntaxException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.sherpa.v2.SHERPAJournal;\n+import org.dspace.app.sherpa.v2.SHERPAResponse;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+\n+/**\n+ * This class is the implementation of the ExternalDataProvider interface that will deal with SherpaJournal External\n+ * data lookups.\n+ * This provider is a refactored version of SherpaJournalDataPublisher, rewritten to work with SHERPA v2 API\n+ *\n+ * @author Kim Shepherd\n+ */\n+public class SHERPAv2JournalDataProvider implements ExternalDataProvider {\n+\n+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(SHERPAv2JournalDataProvider.class);\n+\n+    private String url;\n+    private String sourceIdentifier;\n+    private String apiKey;\n+\n+    private CloseableHttpClient client = null;\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * Initialise the client that we need to call the endpoint\n+     * @throws IOException  If something goes wrong\n+     */\n+    public void init() throws IOException {\n+        HttpClientBuilder builder = HttpClientBuilder.create();\n+        // httpclient 4.3+ doesn't appear to have any sensible defaults any more. Setting conservative defaults as\n+        // not to hammer the SHERPA service too much.\n+        client = builder\n+            .disableAutomaticRetries()\n+            .setMaxConnTotal(5)\n+            .build();\n+    }\n+\n+    /**\n+     * Get a single journal based on a \"title equals string\" query\n+     * @param id    The journal title which will be used as query string\n+     * @return external data object representing journal\n+     */\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+\n+        HttpGet method = null;\n+        SHERPAResponse sherpaResponse = null;\n+        int timeout = 5000;\n+        URIBuilder uriBuilder = null;\n+        try {\n+            // Construct URI for an exact match on journal title\n+            uriBuilder = new URIBuilder(url);\n+            uriBuilder.addParameter(\"item-type\", \"publication\");\n+            uriBuilder.addParameter(\"filter\", \"[[\\\"title\\\",\\\"equals\\\",\\\"\" + id + \"\\\"]]\");\n+            uriBuilder.addParameter(\"format\", \"Json\");\n+            if (StringUtils.isNotBlank(apiKey)) {\n+                uriBuilder.addParameter(\"api-key\", apiKey);\n+            }\n+\n+            // Build HTTP method\n+            method = new HttpGet(uriBuilder.build());\n+            method.setConfig(RequestConfig.custom()\n+                                          .setConnectionRequestTimeout(timeout)\n+                                          .setConnectTimeout(timeout)\n+                                          .setSocketTimeout(timeout)\n+                                          .build());\n+\n+            // Execute the method\n+            HttpResponse response = client.execute(method);\n+            int statusCode = response.getStatusLine().getStatusCode();\n+\n+            if (statusCode != HttpStatus.SC_OK) {\n+                sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO return not OK status: \"\n+                                                        + statusCode);\n+            }\n+\n+            HttpEntity responseBody = response.getEntity();\n+\n+            // Get InputStream from API response and parse JSON\n+            if (null != responseBody) {\n+                InputStream content = null;\n+                try {\n+                    content = responseBody.getContent();\n+                    sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                } catch (IOException e) {\n+                    log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            } else {\n+                sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO returned no response\");\n+            }\n+        } catch (Exception e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE3ODI1OQ==", "bodyText": "I don't think we can.\nThis class and its methods implement ExternalDataService interface (via extending ExternalDataServiceImpl). The abstract methods don't have any throw statements in its signatures. I would be hesitant to include a refactor of this interface and abstract impl in this PR as it would have consequences for all other providers.", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r443178259", "createdAt": "2020-06-21T03:39:17Z", "author": {"login": "kshepherd"}, "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2JournalDataProvider.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URISyntaxException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.sherpa.v2.SHERPAJournal;\n+import org.dspace.app.sherpa.v2.SHERPAResponse;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+\n+/**\n+ * This class is the implementation of the ExternalDataProvider interface that will deal with SherpaJournal External\n+ * data lookups.\n+ * This provider is a refactored version of SherpaJournalDataPublisher, rewritten to work with SHERPA v2 API\n+ *\n+ * @author Kim Shepherd\n+ */\n+public class SHERPAv2JournalDataProvider implements ExternalDataProvider {\n+\n+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(SHERPAv2JournalDataProvider.class);\n+\n+    private String url;\n+    private String sourceIdentifier;\n+    private String apiKey;\n+\n+    private CloseableHttpClient client = null;\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * Initialise the client that we need to call the endpoint\n+     * @throws IOException  If something goes wrong\n+     */\n+    public void init() throws IOException {\n+        HttpClientBuilder builder = HttpClientBuilder.create();\n+        // httpclient 4.3+ doesn't appear to have any sensible defaults any more. Setting conservative defaults as\n+        // not to hammer the SHERPA service too much.\n+        client = builder\n+            .disableAutomaticRetries()\n+            .setMaxConnTotal(5)\n+            .build();\n+    }\n+\n+    /**\n+     * Get a single journal based on a \"title equals string\" query\n+     * @param id    The journal title which will be used as query string\n+     * @return external data object representing journal\n+     */\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+\n+        HttpGet method = null;\n+        SHERPAResponse sherpaResponse = null;\n+        int timeout = 5000;\n+        URIBuilder uriBuilder = null;\n+        try {\n+            // Construct URI for an exact match on journal title\n+            uriBuilder = new URIBuilder(url);\n+            uriBuilder.addParameter(\"item-type\", \"publication\");\n+            uriBuilder.addParameter(\"filter\", \"[[\\\"title\\\",\\\"equals\\\",\\\"\" + id + \"\\\"]]\");\n+            uriBuilder.addParameter(\"format\", \"Json\");\n+            if (StringUtils.isNotBlank(apiKey)) {\n+                uriBuilder.addParameter(\"api-key\", apiKey);\n+            }\n+\n+            // Build HTTP method\n+            method = new HttpGet(uriBuilder.build());\n+            method.setConfig(RequestConfig.custom()\n+                                          .setConnectionRequestTimeout(timeout)\n+                                          .setConnectTimeout(timeout)\n+                                          .setSocketTimeout(timeout)\n+                                          .build());\n+\n+            // Execute the method\n+            HttpResponse response = client.execute(method);\n+            int statusCode = response.getStatusLine().getStatusCode();\n+\n+            if (statusCode != HttpStatus.SC_OK) {\n+                sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO return not OK status: \"\n+                                                        + statusCode);\n+            }\n+\n+            HttpEntity responseBody = response.getEntity();\n+\n+            // Get InputStream from API response and parse JSON\n+            if (null != responseBody) {\n+                InputStream content = null;\n+                try {\n+                    content = responseBody.getContent();\n+                    sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                } catch (IOException e) {\n+                    log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            } else {\n+                sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO returned no response\");\n+            }\n+        } catch (Exception e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4NDE4MA=="}, "originalCommit": null, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMjA4NjM5OnYy", "diffSide": "RIGHT", "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2JournalDataProvider.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMDo0NTozMVrOGdsHww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMVQwMzoyNjoxMlrOGmpauQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4NDc3MQ==", "bodyText": "should we escape the query?", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r433784771", "createdAt": "2020-06-02T10:45:31Z", "author": {"login": "abollini"}, "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2JournalDataProvider.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URISyntaxException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.sherpa.v2.SHERPAJournal;\n+import org.dspace.app.sherpa.v2.SHERPAResponse;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+\n+/**\n+ * This class is the implementation of the ExternalDataProvider interface that will deal with SherpaJournal External\n+ * data lookups.\n+ * This provider is a refactored version of SherpaJournalDataPublisher, rewritten to work with SHERPA v2 API\n+ *\n+ * @author Kim Shepherd\n+ */\n+public class SHERPAv2JournalDataProvider implements ExternalDataProvider {\n+\n+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(SHERPAv2JournalDataProvider.class);\n+\n+    private String url;\n+    private String sourceIdentifier;\n+    private String apiKey;\n+\n+    private CloseableHttpClient client = null;\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * Initialise the client that we need to call the endpoint\n+     * @throws IOException  If something goes wrong\n+     */\n+    public void init() throws IOException {\n+        HttpClientBuilder builder = HttpClientBuilder.create();\n+        // httpclient 4.3+ doesn't appear to have any sensible defaults any more. Setting conservative defaults as\n+        // not to hammer the SHERPA service too much.\n+        client = builder\n+            .disableAutomaticRetries()\n+            .setMaxConnTotal(5)\n+            .build();\n+    }\n+\n+    /**\n+     * Get a single journal based on a \"title equals string\" query\n+     * @param id    The journal title which will be used as query string\n+     * @return external data object representing journal\n+     */\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+\n+        HttpGet method = null;\n+        SHERPAResponse sherpaResponse = null;\n+        int timeout = 5000;\n+        URIBuilder uriBuilder = null;\n+        try {\n+            // Construct URI for an exact match on journal title\n+            uriBuilder = new URIBuilder(url);\n+            uriBuilder.addParameter(\"item-type\", \"publication\");\n+            uriBuilder.addParameter(\"filter\", \"[[\\\"title\\\",\\\"equals\\\",\\\"\" + id + \"\\\"]]\");\n+            uriBuilder.addParameter(\"format\", \"Json\");\n+            if (StringUtils.isNotBlank(apiKey)) {\n+                uriBuilder.addParameter(\"api-key\", apiKey);\n+            }\n+\n+            // Build HTTP method\n+            method = new HttpGet(uriBuilder.build());\n+            method.setConfig(RequestConfig.custom()\n+                                          .setConnectionRequestTimeout(timeout)\n+                                          .setConnectTimeout(timeout)\n+                                          .setSocketTimeout(timeout)\n+                                          .build());\n+\n+            // Execute the method\n+            HttpResponse response = client.execute(method);\n+            int statusCode = response.getStatusLine().getStatusCode();\n+\n+            if (statusCode != HttpStatus.SC_OK) {\n+                sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO return not OK status: \"\n+                                                        + statusCode);\n+            }\n+\n+            HttpEntity responseBody = response.getEntity();\n+\n+            // Get InputStream from API response and parse JSON\n+            if (null != responseBody) {\n+                InputStream content = null;\n+                try {\n+                    content = responseBody.getContent();\n+                    sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                } catch (IOException e) {\n+                    log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            } else {\n+                sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO returned no response\");\n+            }\n+        } catch (Exception e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+        }\n+\n+        if (sherpaResponse == null) {\n+            sherpaResponse = new SHERPAResponse(\n+                \"Error processing the SHERPA/RoMEO answer\");\n+        }\n+        if (CollectionUtils.isNotEmpty(sherpaResponse.getJournals())) {\n+            SHERPAJournal sherpaJournal = sherpaResponse.getJournals().get(0);\n+\n+            ExternalDataObject externalDataObject = constructExternalDataObjectFromSherpaJournal(sherpaJournal);\n+            return Optional.of(externalDataObject);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Construct ExternalDataObject populated with journal metadata from the SHERPA v2 API response\n+     * @param sherpaJournal\n+     * @return external data object representing a journal\n+     */\n+    private ExternalDataObject constructExternalDataObjectFromSherpaJournal(SHERPAJournal sherpaJournal) {\n+        // Set up external object\n+        ExternalDataObject externalDataObject = new ExternalDataObject();\n+        externalDataObject.setSource(sourceIdentifier);\n+        // Set journal title in external object\n+        if (CollectionUtils.isNotEmpty(sherpaJournal.getTitles())) {\n+            String journalTitle = sherpaJournal.getTitles().get(0);\n+            externalDataObject.setId(sherpaJournal.getTitles().get(0));\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"title\", null, null, journalTitle));\n+            externalDataObject.setValue(journalTitle);\n+            externalDataObject.setDisplayValue(journalTitle);\n+        }\n+        // Set ISSNs in external object\n+        if (CollectionUtils.isNotEmpty(sherpaJournal.getIssns())) {\n+            String issn = sherpaJournal.getIssns().get(0);\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                    \"dc\", \"identifier\", \"issn\", null, issn));\n+\n+        }\n+\n+        return externalDataObject;\n+    }\n+\n+    /**\n+     * Search SHERPA v2 API for journal results based on a 'contains word' query\n+     * @param query The query for the search\n+     * @param start The start of the search\n+     * @param limit The max amount of records to be returned by the search\n+     * @return a list of external data objects\n+     */\n+    @Override\n+    public List<ExternalDataObject> searchExternalDataObjects(String query, int start, int limit) {\n+        // query args to add to SHERPA/RoMEO request URL\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query, start, limit);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Get response input stream and parse JSON into new SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAResponse sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getJournals())) {\n+                        List<ExternalDataObject> list = sherpaResponse.getJournals().stream().map(\n+                            sherpaJournal -> constructExternalDataObjectFromSherpaJournal(sherpaJournal)).collect(\n+                            Collectors.toList());\n+\n+                        // Unlike the previous API version we can request offset and limit, so no need to build a\n+                        // sublist from this list, we can just return the list.\n+                        return list;\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error parsing SHERPA response input stream: \" + e.getMessage());\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            }\n+        } catch (IOException | URISyntaxException e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+            return null;\n+        } finally {\n+            if (get != null) {\n+                get.releaseConnection();\n+            }\n+        }\n+        return Collections.emptyList();\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"title contains word\" query using default start/limit parameters\n+     * @param query a word or phrase to search for in journal title\n+     * @return HttpGet method which can then be executed by the client\n+     * @throws URISyntaxException if the URL build fails\n+     */\n+    private HttpGet constructHttpGet(String query) throws URISyntaxException {\n+        return constructHttpGet(query, -1, -1);\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"title contains word\" query\n+     * @param query the search query\n+     * @param start row offset\n+     * @param limit number of results to return\n+     * @return HttpGet object to be executed by the client\n+     * @throws URISyntaxException\n+     */\n+    private HttpGet constructHttpGet(String query, int start, int limit) throws URISyntaxException {\n+        // Build URL based on search query\n+        URIBuilder uriBuilder = new URIBuilder(url);\n+        uriBuilder.addParameter(\"item-type\", \"publication\");\n+        uriBuilder.addParameter(\"filter\", \"[[\\\"title\\\",\\\"contains word\\\",\\\"\" + query + \"\\\"]]\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 247}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE3NzY1Nw==", "bodyText": "After talking to SHERPA devs I have done some simple stripping for valid URI / JSON parsing. Note, the URI Builder itself already escapes/encodes for URL\nSee commit a81fe58", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r443177657", "createdAt": "2020-06-21T03:26:12Z", "author": {"login": "kshepherd"}, "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2JournalDataProvider.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URISyntaxException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.sherpa.v2.SHERPAJournal;\n+import org.dspace.app.sherpa.v2.SHERPAResponse;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+\n+/**\n+ * This class is the implementation of the ExternalDataProvider interface that will deal with SherpaJournal External\n+ * data lookups.\n+ * This provider is a refactored version of SherpaJournalDataPublisher, rewritten to work with SHERPA v2 API\n+ *\n+ * @author Kim Shepherd\n+ */\n+public class SHERPAv2JournalDataProvider implements ExternalDataProvider {\n+\n+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(SHERPAv2JournalDataProvider.class);\n+\n+    private String url;\n+    private String sourceIdentifier;\n+    private String apiKey;\n+\n+    private CloseableHttpClient client = null;\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * Initialise the client that we need to call the endpoint\n+     * @throws IOException  If something goes wrong\n+     */\n+    public void init() throws IOException {\n+        HttpClientBuilder builder = HttpClientBuilder.create();\n+        // httpclient 4.3+ doesn't appear to have any sensible defaults any more. Setting conservative defaults as\n+        // not to hammer the SHERPA service too much.\n+        client = builder\n+            .disableAutomaticRetries()\n+            .setMaxConnTotal(5)\n+            .build();\n+    }\n+\n+    /**\n+     * Get a single journal based on a \"title equals string\" query\n+     * @param id    The journal title which will be used as query string\n+     * @return external data object representing journal\n+     */\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+\n+        HttpGet method = null;\n+        SHERPAResponse sherpaResponse = null;\n+        int timeout = 5000;\n+        URIBuilder uriBuilder = null;\n+        try {\n+            // Construct URI for an exact match on journal title\n+            uriBuilder = new URIBuilder(url);\n+            uriBuilder.addParameter(\"item-type\", \"publication\");\n+            uriBuilder.addParameter(\"filter\", \"[[\\\"title\\\",\\\"equals\\\",\\\"\" + id + \"\\\"]]\");\n+            uriBuilder.addParameter(\"format\", \"Json\");\n+            if (StringUtils.isNotBlank(apiKey)) {\n+                uriBuilder.addParameter(\"api-key\", apiKey);\n+            }\n+\n+            // Build HTTP method\n+            method = new HttpGet(uriBuilder.build());\n+            method.setConfig(RequestConfig.custom()\n+                                          .setConnectionRequestTimeout(timeout)\n+                                          .setConnectTimeout(timeout)\n+                                          .setSocketTimeout(timeout)\n+                                          .build());\n+\n+            // Execute the method\n+            HttpResponse response = client.execute(method);\n+            int statusCode = response.getStatusLine().getStatusCode();\n+\n+            if (statusCode != HttpStatus.SC_OK) {\n+                sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO return not OK status: \"\n+                                                        + statusCode);\n+            }\n+\n+            HttpEntity responseBody = response.getEntity();\n+\n+            // Get InputStream from API response and parse JSON\n+            if (null != responseBody) {\n+                InputStream content = null;\n+                try {\n+                    content = responseBody.getContent();\n+                    sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                } catch (IOException e) {\n+                    log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            } else {\n+                sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO returned no response\");\n+            }\n+        } catch (Exception e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+        }\n+\n+        if (sherpaResponse == null) {\n+            sherpaResponse = new SHERPAResponse(\n+                \"Error processing the SHERPA/RoMEO answer\");\n+        }\n+        if (CollectionUtils.isNotEmpty(sherpaResponse.getJournals())) {\n+            SHERPAJournal sherpaJournal = sherpaResponse.getJournals().get(0);\n+\n+            ExternalDataObject externalDataObject = constructExternalDataObjectFromSherpaJournal(sherpaJournal);\n+            return Optional.of(externalDataObject);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Construct ExternalDataObject populated with journal metadata from the SHERPA v2 API response\n+     * @param sherpaJournal\n+     * @return external data object representing a journal\n+     */\n+    private ExternalDataObject constructExternalDataObjectFromSherpaJournal(SHERPAJournal sherpaJournal) {\n+        // Set up external object\n+        ExternalDataObject externalDataObject = new ExternalDataObject();\n+        externalDataObject.setSource(sourceIdentifier);\n+        // Set journal title in external object\n+        if (CollectionUtils.isNotEmpty(sherpaJournal.getTitles())) {\n+            String journalTitle = sherpaJournal.getTitles().get(0);\n+            externalDataObject.setId(sherpaJournal.getTitles().get(0));\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"title\", null, null, journalTitle));\n+            externalDataObject.setValue(journalTitle);\n+            externalDataObject.setDisplayValue(journalTitle);\n+        }\n+        // Set ISSNs in external object\n+        if (CollectionUtils.isNotEmpty(sherpaJournal.getIssns())) {\n+            String issn = sherpaJournal.getIssns().get(0);\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                    \"dc\", \"identifier\", \"issn\", null, issn));\n+\n+        }\n+\n+        return externalDataObject;\n+    }\n+\n+    /**\n+     * Search SHERPA v2 API for journal results based on a 'contains word' query\n+     * @param query The query for the search\n+     * @param start The start of the search\n+     * @param limit The max amount of records to be returned by the search\n+     * @return a list of external data objects\n+     */\n+    @Override\n+    public List<ExternalDataObject> searchExternalDataObjects(String query, int start, int limit) {\n+        // query args to add to SHERPA/RoMEO request URL\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query, start, limit);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Get response input stream and parse JSON into new SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAResponse sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getJournals())) {\n+                        List<ExternalDataObject> list = sherpaResponse.getJournals().stream().map(\n+                            sherpaJournal -> constructExternalDataObjectFromSherpaJournal(sherpaJournal)).collect(\n+                            Collectors.toList());\n+\n+                        // Unlike the previous API version we can request offset and limit, so no need to build a\n+                        // sublist from this list, we can just return the list.\n+                        return list;\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error parsing SHERPA response input stream: \" + e.getMessage());\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            }\n+        } catch (IOException | URISyntaxException e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+            return null;\n+        } finally {\n+            if (get != null) {\n+                get.releaseConnection();\n+            }\n+        }\n+        return Collections.emptyList();\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"title contains word\" query using default start/limit parameters\n+     * @param query a word or phrase to search for in journal title\n+     * @return HttpGet method which can then be executed by the client\n+     * @throws URISyntaxException if the URL build fails\n+     */\n+    private HttpGet constructHttpGet(String query) throws URISyntaxException {\n+        return constructHttpGet(query, -1, -1);\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"title contains word\" query\n+     * @param query the search query\n+     * @param start row offset\n+     * @param limit number of results to return\n+     * @return HttpGet object to be executed by the client\n+     * @throws URISyntaxException\n+     */\n+    private HttpGet constructHttpGet(String query, int start, int limit) throws URISyntaxException {\n+        // Build URL based on search query\n+        URIBuilder uriBuilder = new URIBuilder(url);\n+        uriBuilder.addParameter(\"item-type\", \"publication\");\n+        uriBuilder.addParameter(\"filter\", \"[[\\\"title\\\",\\\"contains word\\\",\\\"\" + query + \"\\\"]]\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4NDc3MQ=="}, "originalCommit": null, "originalPosition": 247}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMjA4OTczOnYy", "diffSide": "RIGHT", "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2JournalDataProvider.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMDo0NjozMVrOGdsJzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMVQwMzozOTozMlrOGmpdIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4NTI5Mw==", "bodyText": "should we rethrow the exception instead?", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r433785293", "createdAt": "2020-06-02T10:46:31Z", "author": {"login": "abollini"}, "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2JournalDataProvider.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URISyntaxException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.sherpa.v2.SHERPAJournal;\n+import org.dspace.app.sherpa.v2.SHERPAResponse;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+\n+/**\n+ * This class is the implementation of the ExternalDataProvider interface that will deal with SherpaJournal External\n+ * data lookups.\n+ * This provider is a refactored version of SherpaJournalDataPublisher, rewritten to work with SHERPA v2 API\n+ *\n+ * @author Kim Shepherd\n+ */\n+public class SHERPAv2JournalDataProvider implements ExternalDataProvider {\n+\n+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(SHERPAv2JournalDataProvider.class);\n+\n+    private String url;\n+    private String sourceIdentifier;\n+    private String apiKey;\n+\n+    private CloseableHttpClient client = null;\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * Initialise the client that we need to call the endpoint\n+     * @throws IOException  If something goes wrong\n+     */\n+    public void init() throws IOException {\n+        HttpClientBuilder builder = HttpClientBuilder.create();\n+        // httpclient 4.3+ doesn't appear to have any sensible defaults any more. Setting conservative defaults as\n+        // not to hammer the SHERPA service too much.\n+        client = builder\n+            .disableAutomaticRetries()\n+            .setMaxConnTotal(5)\n+            .build();\n+    }\n+\n+    /**\n+     * Get a single journal based on a \"title equals string\" query\n+     * @param id    The journal title which will be used as query string\n+     * @return external data object representing journal\n+     */\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+\n+        HttpGet method = null;\n+        SHERPAResponse sherpaResponse = null;\n+        int timeout = 5000;\n+        URIBuilder uriBuilder = null;\n+        try {\n+            // Construct URI for an exact match on journal title\n+            uriBuilder = new URIBuilder(url);\n+            uriBuilder.addParameter(\"item-type\", \"publication\");\n+            uriBuilder.addParameter(\"filter\", \"[[\\\"title\\\",\\\"equals\\\",\\\"\" + id + \"\\\"]]\");\n+            uriBuilder.addParameter(\"format\", \"Json\");\n+            if (StringUtils.isNotBlank(apiKey)) {\n+                uriBuilder.addParameter(\"api-key\", apiKey);\n+            }\n+\n+            // Build HTTP method\n+            method = new HttpGet(uriBuilder.build());\n+            method.setConfig(RequestConfig.custom()\n+                                          .setConnectionRequestTimeout(timeout)\n+                                          .setConnectTimeout(timeout)\n+                                          .setSocketTimeout(timeout)\n+                                          .build());\n+\n+            // Execute the method\n+            HttpResponse response = client.execute(method);\n+            int statusCode = response.getStatusLine().getStatusCode();\n+\n+            if (statusCode != HttpStatus.SC_OK) {\n+                sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO return not OK status: \"\n+                                                        + statusCode);\n+            }\n+\n+            HttpEntity responseBody = response.getEntity();\n+\n+            // Get InputStream from API response and parse JSON\n+            if (null != responseBody) {\n+                InputStream content = null;\n+                try {\n+                    content = responseBody.getContent();\n+                    sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                } catch (IOException e) {\n+                    log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            } else {\n+                sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO returned no response\");\n+            }\n+        } catch (Exception e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+        }\n+\n+        if (sherpaResponse == null) {\n+            sherpaResponse = new SHERPAResponse(\n+                \"Error processing the SHERPA/RoMEO answer\");\n+        }\n+        if (CollectionUtils.isNotEmpty(sherpaResponse.getJournals())) {\n+            SHERPAJournal sherpaJournal = sherpaResponse.getJournals().get(0);\n+\n+            ExternalDataObject externalDataObject = constructExternalDataObjectFromSherpaJournal(sherpaJournal);\n+            return Optional.of(externalDataObject);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Construct ExternalDataObject populated with journal metadata from the SHERPA v2 API response\n+     * @param sherpaJournal\n+     * @return external data object representing a journal\n+     */\n+    private ExternalDataObject constructExternalDataObjectFromSherpaJournal(SHERPAJournal sherpaJournal) {\n+        // Set up external object\n+        ExternalDataObject externalDataObject = new ExternalDataObject();\n+        externalDataObject.setSource(sourceIdentifier);\n+        // Set journal title in external object\n+        if (CollectionUtils.isNotEmpty(sherpaJournal.getTitles())) {\n+            String journalTitle = sherpaJournal.getTitles().get(0);\n+            externalDataObject.setId(sherpaJournal.getTitles().get(0));\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"title\", null, null, journalTitle));\n+            externalDataObject.setValue(journalTitle);\n+            externalDataObject.setDisplayValue(journalTitle);\n+        }\n+        // Set ISSNs in external object\n+        if (CollectionUtils.isNotEmpty(sherpaJournal.getIssns())) {\n+            String issn = sherpaJournal.getIssns().get(0);\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                    \"dc\", \"identifier\", \"issn\", null, issn));\n+\n+        }\n+\n+        return externalDataObject;\n+    }\n+\n+    /**\n+     * Search SHERPA v2 API for journal results based on a 'contains word' query\n+     * @param query The query for the search\n+     * @param start The start of the search\n+     * @param limit The max amount of records to be returned by the search\n+     * @return a list of external data objects\n+     */\n+    @Override\n+    public List<ExternalDataObject> searchExternalDataObjects(String query, int start, int limit) {\n+        // query args to add to SHERPA/RoMEO request URL\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query, start, limit);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Get response input stream and parse JSON into new SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAResponse sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getJournals())) {\n+                        List<ExternalDataObject> list = sherpaResponse.getJournals().stream().map(\n+                            sherpaJournal -> constructExternalDataObjectFromSherpaJournal(sherpaJournal)).collect(\n+                            Collectors.toList());\n+\n+                        // Unlike the previous API version we can request offset and limit, so no need to build a\n+                        // sublist from this list, we can just return the list.\n+                        return list;\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error parsing SHERPA response input stream: \" + e.getMessage());\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            }\n+        } catch (IOException | URISyntaxException e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+            return null;\n+        } finally {\n+            if (get != null) {\n+                get.releaseConnection();\n+            }\n+        }\n+        return Collections.emptyList();\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"title contains word\" query using default start/limit parameters\n+     * @param query a word or phrase to search for in journal title\n+     * @return HttpGet method which can then be executed by the client\n+     * @throws URISyntaxException if the URL build fails\n+     */\n+    private HttpGet constructHttpGet(String query) throws URISyntaxException {\n+        return constructHttpGet(query, -1, -1);\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"title contains word\" query\n+     * @param query the search query\n+     * @param start row offset\n+     * @param limit number of results to return\n+     * @return HttpGet object to be executed by the client\n+     * @throws URISyntaxException\n+     */\n+    private HttpGet constructHttpGet(String query, int start, int limit) throws URISyntaxException {\n+        // Build URL based on search query\n+        URIBuilder uriBuilder = new URIBuilder(url);\n+        uriBuilder.addParameter(\"item-type\", \"publication\");\n+        uriBuilder.addParameter(\"filter\", \"[[\\\"title\\\",\\\"contains word\\\",\\\"\" + query + \"\\\"]]\");\n+        uriBuilder.addParameter(\"format\", \"Json\");\n+        // Set optional start (offset) and limit parameters\n+        if (start >= 0) {\n+            uriBuilder.addParameter(\"offset\", String.valueOf(start));\n+        }\n+        if (limit > 0) {\n+            uriBuilder.addParameter(\"limit\", String.valueOf(limit));\n+        }\n+        if (StringUtils.isNotBlank(apiKey)) {\n+            uriBuilder.addParameter(\"api-key\", apiKey);\n+        }\n+\n+        // Create HTTP GET object\n+        HttpGet method = new HttpGet(uriBuilder.build());\n+\n+        // Set connection parameters\n+        int timeout = 5000;\n+        method.setConfig(RequestConfig.custom()\n+            .setConnectionRequestTimeout(timeout)\n+            .setConnectTimeout(timeout)\n+            .setSocketTimeout(timeout)\n+            .build());\n+        return new HttpGet(uriBuilder.build());\n+    }\n+\n+    @Override\n+    public boolean supports(String source) {\n+        return StringUtils.equalsIgnoreCase(sourceIdentifier, source);\n+    }\n+\n+    /**\n+     * Get number of results returned from a SHERPA v2 publication search\n+     * @param query The query to be search on and give the total amount of results\n+     * @return int representing number of journal results\n+     */\n+    @Override\n+    public int getNumberOfResults(String query) {\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Read response and parse as SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAResponse sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getJournals())) {\n+                        return sherpaResponse.getJournals().size();\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error reading input stream for SHERPAResponse: \" + e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 300}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE3ODI3Mg==", "bodyText": "I have now rethrown this exception in 3ef47da - this one I can do, as it is nested within a higher try/catch block.\nHowever, note that for the main catch in the method:\nThis class and its methods implement ExternalDataService interface (via extending ExternalDataServiceImpl). The abstract methods don't have any throw statements in its signatures. I would be hesitant to include a refactor of this interface and abstract impl in this PR as it would have consequences for all other providers.", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r443178272", "createdAt": "2020-06-21T03:39:32Z", "author": {"login": "kshepherd"}, "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2JournalDataProvider.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URISyntaxException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.sherpa.v2.SHERPAJournal;\n+import org.dspace.app.sherpa.v2.SHERPAResponse;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+\n+/**\n+ * This class is the implementation of the ExternalDataProvider interface that will deal with SherpaJournal External\n+ * data lookups.\n+ * This provider is a refactored version of SherpaJournalDataPublisher, rewritten to work with SHERPA v2 API\n+ *\n+ * @author Kim Shepherd\n+ */\n+public class SHERPAv2JournalDataProvider implements ExternalDataProvider {\n+\n+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(SHERPAv2JournalDataProvider.class);\n+\n+    private String url;\n+    private String sourceIdentifier;\n+    private String apiKey;\n+\n+    private CloseableHttpClient client = null;\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * Initialise the client that we need to call the endpoint\n+     * @throws IOException  If something goes wrong\n+     */\n+    public void init() throws IOException {\n+        HttpClientBuilder builder = HttpClientBuilder.create();\n+        // httpclient 4.3+ doesn't appear to have any sensible defaults any more. Setting conservative defaults as\n+        // not to hammer the SHERPA service too much.\n+        client = builder\n+            .disableAutomaticRetries()\n+            .setMaxConnTotal(5)\n+            .build();\n+    }\n+\n+    /**\n+     * Get a single journal based on a \"title equals string\" query\n+     * @param id    The journal title which will be used as query string\n+     * @return external data object representing journal\n+     */\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+\n+        HttpGet method = null;\n+        SHERPAResponse sherpaResponse = null;\n+        int timeout = 5000;\n+        URIBuilder uriBuilder = null;\n+        try {\n+            // Construct URI for an exact match on journal title\n+            uriBuilder = new URIBuilder(url);\n+            uriBuilder.addParameter(\"item-type\", \"publication\");\n+            uriBuilder.addParameter(\"filter\", \"[[\\\"title\\\",\\\"equals\\\",\\\"\" + id + \"\\\"]]\");\n+            uriBuilder.addParameter(\"format\", \"Json\");\n+            if (StringUtils.isNotBlank(apiKey)) {\n+                uriBuilder.addParameter(\"api-key\", apiKey);\n+            }\n+\n+            // Build HTTP method\n+            method = new HttpGet(uriBuilder.build());\n+            method.setConfig(RequestConfig.custom()\n+                                          .setConnectionRequestTimeout(timeout)\n+                                          .setConnectTimeout(timeout)\n+                                          .setSocketTimeout(timeout)\n+                                          .build());\n+\n+            // Execute the method\n+            HttpResponse response = client.execute(method);\n+            int statusCode = response.getStatusLine().getStatusCode();\n+\n+            if (statusCode != HttpStatus.SC_OK) {\n+                sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO return not OK status: \"\n+                                                        + statusCode);\n+            }\n+\n+            HttpEntity responseBody = response.getEntity();\n+\n+            // Get InputStream from API response and parse JSON\n+            if (null != responseBody) {\n+                InputStream content = null;\n+                try {\n+                    content = responseBody.getContent();\n+                    sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                } catch (IOException e) {\n+                    log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            } else {\n+                sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO returned no response\");\n+            }\n+        } catch (Exception e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+        }\n+\n+        if (sherpaResponse == null) {\n+            sherpaResponse = new SHERPAResponse(\n+                \"Error processing the SHERPA/RoMEO answer\");\n+        }\n+        if (CollectionUtils.isNotEmpty(sherpaResponse.getJournals())) {\n+            SHERPAJournal sherpaJournal = sherpaResponse.getJournals().get(0);\n+\n+            ExternalDataObject externalDataObject = constructExternalDataObjectFromSherpaJournal(sherpaJournal);\n+            return Optional.of(externalDataObject);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Construct ExternalDataObject populated with journal metadata from the SHERPA v2 API response\n+     * @param sherpaJournal\n+     * @return external data object representing a journal\n+     */\n+    private ExternalDataObject constructExternalDataObjectFromSherpaJournal(SHERPAJournal sherpaJournal) {\n+        // Set up external object\n+        ExternalDataObject externalDataObject = new ExternalDataObject();\n+        externalDataObject.setSource(sourceIdentifier);\n+        // Set journal title in external object\n+        if (CollectionUtils.isNotEmpty(sherpaJournal.getTitles())) {\n+            String journalTitle = sherpaJournal.getTitles().get(0);\n+            externalDataObject.setId(sherpaJournal.getTitles().get(0));\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"title\", null, null, journalTitle));\n+            externalDataObject.setValue(journalTitle);\n+            externalDataObject.setDisplayValue(journalTitle);\n+        }\n+        // Set ISSNs in external object\n+        if (CollectionUtils.isNotEmpty(sherpaJournal.getIssns())) {\n+            String issn = sherpaJournal.getIssns().get(0);\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                    \"dc\", \"identifier\", \"issn\", null, issn));\n+\n+        }\n+\n+        return externalDataObject;\n+    }\n+\n+    /**\n+     * Search SHERPA v2 API for journal results based on a 'contains word' query\n+     * @param query The query for the search\n+     * @param start The start of the search\n+     * @param limit The max amount of records to be returned by the search\n+     * @return a list of external data objects\n+     */\n+    @Override\n+    public List<ExternalDataObject> searchExternalDataObjects(String query, int start, int limit) {\n+        // query args to add to SHERPA/RoMEO request URL\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query, start, limit);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Get response input stream and parse JSON into new SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAResponse sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getJournals())) {\n+                        List<ExternalDataObject> list = sherpaResponse.getJournals().stream().map(\n+                            sherpaJournal -> constructExternalDataObjectFromSherpaJournal(sherpaJournal)).collect(\n+                            Collectors.toList());\n+\n+                        // Unlike the previous API version we can request offset and limit, so no need to build a\n+                        // sublist from this list, we can just return the list.\n+                        return list;\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error parsing SHERPA response input stream: \" + e.getMessage());\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            }\n+        } catch (IOException | URISyntaxException e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+            return null;\n+        } finally {\n+            if (get != null) {\n+                get.releaseConnection();\n+            }\n+        }\n+        return Collections.emptyList();\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"title contains word\" query using default start/limit parameters\n+     * @param query a word or phrase to search for in journal title\n+     * @return HttpGet method which can then be executed by the client\n+     * @throws URISyntaxException if the URL build fails\n+     */\n+    private HttpGet constructHttpGet(String query) throws URISyntaxException {\n+        return constructHttpGet(query, -1, -1);\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"title contains word\" query\n+     * @param query the search query\n+     * @param start row offset\n+     * @param limit number of results to return\n+     * @return HttpGet object to be executed by the client\n+     * @throws URISyntaxException\n+     */\n+    private HttpGet constructHttpGet(String query, int start, int limit) throws URISyntaxException {\n+        // Build URL based on search query\n+        URIBuilder uriBuilder = new URIBuilder(url);\n+        uriBuilder.addParameter(\"item-type\", \"publication\");\n+        uriBuilder.addParameter(\"filter\", \"[[\\\"title\\\",\\\"contains word\\\",\\\"\" + query + \"\\\"]]\");\n+        uriBuilder.addParameter(\"format\", \"Json\");\n+        // Set optional start (offset) and limit parameters\n+        if (start >= 0) {\n+            uriBuilder.addParameter(\"offset\", String.valueOf(start));\n+        }\n+        if (limit > 0) {\n+            uriBuilder.addParameter(\"limit\", String.valueOf(limit));\n+        }\n+        if (StringUtils.isNotBlank(apiKey)) {\n+            uriBuilder.addParameter(\"api-key\", apiKey);\n+        }\n+\n+        // Create HTTP GET object\n+        HttpGet method = new HttpGet(uriBuilder.build());\n+\n+        // Set connection parameters\n+        int timeout = 5000;\n+        method.setConfig(RequestConfig.custom()\n+            .setConnectionRequestTimeout(timeout)\n+            .setConnectTimeout(timeout)\n+            .setSocketTimeout(timeout)\n+            .build());\n+        return new HttpGet(uriBuilder.build());\n+    }\n+\n+    @Override\n+    public boolean supports(String source) {\n+        return StringUtils.equalsIgnoreCase(sourceIdentifier, source);\n+    }\n+\n+    /**\n+     * Get number of results returned from a SHERPA v2 publication search\n+     * @param query The query to be search on and give the total amount of results\n+     * @return int representing number of journal results\n+     */\n+    @Override\n+    public int getNumberOfResults(String query) {\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Read response and parse as SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAResponse sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getJournals())) {\n+                        return sherpaResponse.getJournals().size();\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error reading input stream for SHERPAResponse: \" + e.getMessage());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4NTI5Mw=="}, "originalCommit": null, "originalPosition": 300}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMjA4OTk4OnYy", "diffSide": "RIGHT", "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2JournalDataProvider.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMDo0NjozN1rOGdsJ-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMVQwMzozOTowNVrOGmpdBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4NTMzNw==", "bodyText": "should we rethrow the exception instead?", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r433785337", "createdAt": "2020-06-02T10:46:37Z", "author": {"login": "abollini"}, "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2JournalDataProvider.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URISyntaxException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.sherpa.v2.SHERPAJournal;\n+import org.dspace.app.sherpa.v2.SHERPAResponse;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+\n+/**\n+ * This class is the implementation of the ExternalDataProvider interface that will deal with SherpaJournal External\n+ * data lookups.\n+ * This provider is a refactored version of SherpaJournalDataPublisher, rewritten to work with SHERPA v2 API\n+ *\n+ * @author Kim Shepherd\n+ */\n+public class SHERPAv2JournalDataProvider implements ExternalDataProvider {\n+\n+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(SHERPAv2JournalDataProvider.class);\n+\n+    private String url;\n+    private String sourceIdentifier;\n+    private String apiKey;\n+\n+    private CloseableHttpClient client = null;\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * Initialise the client that we need to call the endpoint\n+     * @throws IOException  If something goes wrong\n+     */\n+    public void init() throws IOException {\n+        HttpClientBuilder builder = HttpClientBuilder.create();\n+        // httpclient 4.3+ doesn't appear to have any sensible defaults any more. Setting conservative defaults as\n+        // not to hammer the SHERPA service too much.\n+        client = builder\n+            .disableAutomaticRetries()\n+            .setMaxConnTotal(5)\n+            .build();\n+    }\n+\n+    /**\n+     * Get a single journal based on a \"title equals string\" query\n+     * @param id    The journal title which will be used as query string\n+     * @return external data object representing journal\n+     */\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+\n+        HttpGet method = null;\n+        SHERPAResponse sherpaResponse = null;\n+        int timeout = 5000;\n+        URIBuilder uriBuilder = null;\n+        try {\n+            // Construct URI for an exact match on journal title\n+            uriBuilder = new URIBuilder(url);\n+            uriBuilder.addParameter(\"item-type\", \"publication\");\n+            uriBuilder.addParameter(\"filter\", \"[[\\\"title\\\",\\\"equals\\\",\\\"\" + id + \"\\\"]]\");\n+            uriBuilder.addParameter(\"format\", \"Json\");\n+            if (StringUtils.isNotBlank(apiKey)) {\n+                uriBuilder.addParameter(\"api-key\", apiKey);\n+            }\n+\n+            // Build HTTP method\n+            method = new HttpGet(uriBuilder.build());\n+            method.setConfig(RequestConfig.custom()\n+                                          .setConnectionRequestTimeout(timeout)\n+                                          .setConnectTimeout(timeout)\n+                                          .setSocketTimeout(timeout)\n+                                          .build());\n+\n+            // Execute the method\n+            HttpResponse response = client.execute(method);\n+            int statusCode = response.getStatusLine().getStatusCode();\n+\n+            if (statusCode != HttpStatus.SC_OK) {\n+                sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO return not OK status: \"\n+                                                        + statusCode);\n+            }\n+\n+            HttpEntity responseBody = response.getEntity();\n+\n+            // Get InputStream from API response and parse JSON\n+            if (null != responseBody) {\n+                InputStream content = null;\n+                try {\n+                    content = responseBody.getContent();\n+                    sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                } catch (IOException e) {\n+                    log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            } else {\n+                sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO returned no response\");\n+            }\n+        } catch (Exception e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+        }\n+\n+        if (sherpaResponse == null) {\n+            sherpaResponse = new SHERPAResponse(\n+                \"Error processing the SHERPA/RoMEO answer\");\n+        }\n+        if (CollectionUtils.isNotEmpty(sherpaResponse.getJournals())) {\n+            SHERPAJournal sherpaJournal = sherpaResponse.getJournals().get(0);\n+\n+            ExternalDataObject externalDataObject = constructExternalDataObjectFromSherpaJournal(sherpaJournal);\n+            return Optional.of(externalDataObject);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Construct ExternalDataObject populated with journal metadata from the SHERPA v2 API response\n+     * @param sherpaJournal\n+     * @return external data object representing a journal\n+     */\n+    private ExternalDataObject constructExternalDataObjectFromSherpaJournal(SHERPAJournal sherpaJournal) {\n+        // Set up external object\n+        ExternalDataObject externalDataObject = new ExternalDataObject();\n+        externalDataObject.setSource(sourceIdentifier);\n+        // Set journal title in external object\n+        if (CollectionUtils.isNotEmpty(sherpaJournal.getTitles())) {\n+            String journalTitle = sherpaJournal.getTitles().get(0);\n+            externalDataObject.setId(sherpaJournal.getTitles().get(0));\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"title\", null, null, journalTitle));\n+            externalDataObject.setValue(journalTitle);\n+            externalDataObject.setDisplayValue(journalTitle);\n+        }\n+        // Set ISSNs in external object\n+        if (CollectionUtils.isNotEmpty(sherpaJournal.getIssns())) {\n+            String issn = sherpaJournal.getIssns().get(0);\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                    \"dc\", \"identifier\", \"issn\", null, issn));\n+\n+        }\n+\n+        return externalDataObject;\n+    }\n+\n+    /**\n+     * Search SHERPA v2 API for journal results based on a 'contains word' query\n+     * @param query The query for the search\n+     * @param start The start of the search\n+     * @param limit The max amount of records to be returned by the search\n+     * @return a list of external data objects\n+     */\n+    @Override\n+    public List<ExternalDataObject> searchExternalDataObjects(String query, int start, int limit) {\n+        // query args to add to SHERPA/RoMEO request URL\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query, start, limit);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Get response input stream and parse JSON into new SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAResponse sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getJournals())) {\n+                        List<ExternalDataObject> list = sherpaResponse.getJournals().stream().map(\n+                            sherpaJournal -> constructExternalDataObjectFromSherpaJournal(sherpaJournal)).collect(\n+                            Collectors.toList());\n+\n+                        // Unlike the previous API version we can request offset and limit, so no need to build a\n+                        // sublist from this list, we can just return the list.\n+                        return list;\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error parsing SHERPA response input stream: \" + e.getMessage());\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            }\n+        } catch (IOException | URISyntaxException e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+            return null;\n+        } finally {\n+            if (get != null) {\n+                get.releaseConnection();\n+            }\n+        }\n+        return Collections.emptyList();\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"title contains word\" query using default start/limit parameters\n+     * @param query a word or phrase to search for in journal title\n+     * @return HttpGet method which can then be executed by the client\n+     * @throws URISyntaxException if the URL build fails\n+     */\n+    private HttpGet constructHttpGet(String query) throws URISyntaxException {\n+        return constructHttpGet(query, -1, -1);\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"title contains word\" query\n+     * @param query the search query\n+     * @param start row offset\n+     * @param limit number of results to return\n+     * @return HttpGet object to be executed by the client\n+     * @throws URISyntaxException\n+     */\n+    private HttpGet constructHttpGet(String query, int start, int limit) throws URISyntaxException {\n+        // Build URL based on search query\n+        URIBuilder uriBuilder = new URIBuilder(url);\n+        uriBuilder.addParameter(\"item-type\", \"publication\");\n+        uriBuilder.addParameter(\"filter\", \"[[\\\"title\\\",\\\"contains word\\\",\\\"\" + query + \"\\\"]]\");\n+        uriBuilder.addParameter(\"format\", \"Json\");\n+        // Set optional start (offset) and limit parameters\n+        if (start >= 0) {\n+            uriBuilder.addParameter(\"offset\", String.valueOf(start));\n+        }\n+        if (limit > 0) {\n+            uriBuilder.addParameter(\"limit\", String.valueOf(limit));\n+        }\n+        if (StringUtils.isNotBlank(apiKey)) {\n+            uriBuilder.addParameter(\"api-key\", apiKey);\n+        }\n+\n+        // Create HTTP GET object\n+        HttpGet method = new HttpGet(uriBuilder.build());\n+\n+        // Set connection parameters\n+        int timeout = 5000;\n+        method.setConfig(RequestConfig.custom()\n+            .setConnectionRequestTimeout(timeout)\n+            .setConnectTimeout(timeout)\n+            .setSocketTimeout(timeout)\n+            .build());\n+        return new HttpGet(uriBuilder.build());\n+    }\n+\n+    @Override\n+    public boolean supports(String source) {\n+        return StringUtils.equalsIgnoreCase(sourceIdentifier, source);\n+    }\n+\n+    /**\n+     * Get number of results returned from a SHERPA v2 publication search\n+     * @param query The query to be search on and give the total amount of results\n+     * @return int representing number of journal results\n+     */\n+    @Override\n+    public int getNumberOfResults(String query) {\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Read response and parse as SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAResponse sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getJournals())) {\n+                        return sherpaResponse.getJournals().size();\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error reading input stream for SHERPAResponse: \" + e.getMessage());\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            }\n+        } catch (IOException | URISyntaxException e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 308}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE3ODI0Nw==", "bodyText": "I don't think we can.\nThis class and its methods implement ExternalDataService interface (via extending ExternalDataServiceImpl). The abstract methods don't have any throw statements in its signatures. I would be hesitant to include a refactor of this interface and abstract impl in this PR as it would have consequences for all other providers.", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r443178247", "createdAt": "2020-06-21T03:39:05Z", "author": {"login": "kshepherd"}, "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2JournalDataProvider.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URISyntaxException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.sherpa.v2.SHERPAJournal;\n+import org.dspace.app.sherpa.v2.SHERPAResponse;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+\n+/**\n+ * This class is the implementation of the ExternalDataProvider interface that will deal with SherpaJournal External\n+ * data lookups.\n+ * This provider is a refactored version of SherpaJournalDataPublisher, rewritten to work with SHERPA v2 API\n+ *\n+ * @author Kim Shepherd\n+ */\n+public class SHERPAv2JournalDataProvider implements ExternalDataProvider {\n+\n+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(SHERPAv2JournalDataProvider.class);\n+\n+    private String url;\n+    private String sourceIdentifier;\n+    private String apiKey;\n+\n+    private CloseableHttpClient client = null;\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * Initialise the client that we need to call the endpoint\n+     * @throws IOException  If something goes wrong\n+     */\n+    public void init() throws IOException {\n+        HttpClientBuilder builder = HttpClientBuilder.create();\n+        // httpclient 4.3+ doesn't appear to have any sensible defaults any more. Setting conservative defaults as\n+        // not to hammer the SHERPA service too much.\n+        client = builder\n+            .disableAutomaticRetries()\n+            .setMaxConnTotal(5)\n+            .build();\n+    }\n+\n+    /**\n+     * Get a single journal based on a \"title equals string\" query\n+     * @param id    The journal title which will be used as query string\n+     * @return external data object representing journal\n+     */\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+\n+        HttpGet method = null;\n+        SHERPAResponse sherpaResponse = null;\n+        int timeout = 5000;\n+        URIBuilder uriBuilder = null;\n+        try {\n+            // Construct URI for an exact match on journal title\n+            uriBuilder = new URIBuilder(url);\n+            uriBuilder.addParameter(\"item-type\", \"publication\");\n+            uriBuilder.addParameter(\"filter\", \"[[\\\"title\\\",\\\"equals\\\",\\\"\" + id + \"\\\"]]\");\n+            uriBuilder.addParameter(\"format\", \"Json\");\n+            if (StringUtils.isNotBlank(apiKey)) {\n+                uriBuilder.addParameter(\"api-key\", apiKey);\n+            }\n+\n+            // Build HTTP method\n+            method = new HttpGet(uriBuilder.build());\n+            method.setConfig(RequestConfig.custom()\n+                                          .setConnectionRequestTimeout(timeout)\n+                                          .setConnectTimeout(timeout)\n+                                          .setSocketTimeout(timeout)\n+                                          .build());\n+\n+            // Execute the method\n+            HttpResponse response = client.execute(method);\n+            int statusCode = response.getStatusLine().getStatusCode();\n+\n+            if (statusCode != HttpStatus.SC_OK) {\n+                sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO return not OK status: \"\n+                                                        + statusCode);\n+            }\n+\n+            HttpEntity responseBody = response.getEntity();\n+\n+            // Get InputStream from API response and parse JSON\n+            if (null != responseBody) {\n+                InputStream content = null;\n+                try {\n+                    content = responseBody.getContent();\n+                    sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                } catch (IOException e) {\n+                    log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            } else {\n+                sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO returned no response\");\n+            }\n+        } catch (Exception e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+        }\n+\n+        if (sherpaResponse == null) {\n+            sherpaResponse = new SHERPAResponse(\n+                \"Error processing the SHERPA/RoMEO answer\");\n+        }\n+        if (CollectionUtils.isNotEmpty(sherpaResponse.getJournals())) {\n+            SHERPAJournal sherpaJournal = sherpaResponse.getJournals().get(0);\n+\n+            ExternalDataObject externalDataObject = constructExternalDataObjectFromSherpaJournal(sherpaJournal);\n+            return Optional.of(externalDataObject);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Construct ExternalDataObject populated with journal metadata from the SHERPA v2 API response\n+     * @param sherpaJournal\n+     * @return external data object representing a journal\n+     */\n+    private ExternalDataObject constructExternalDataObjectFromSherpaJournal(SHERPAJournal sherpaJournal) {\n+        // Set up external object\n+        ExternalDataObject externalDataObject = new ExternalDataObject();\n+        externalDataObject.setSource(sourceIdentifier);\n+        // Set journal title in external object\n+        if (CollectionUtils.isNotEmpty(sherpaJournal.getTitles())) {\n+            String journalTitle = sherpaJournal.getTitles().get(0);\n+            externalDataObject.setId(sherpaJournal.getTitles().get(0));\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"title\", null, null, journalTitle));\n+            externalDataObject.setValue(journalTitle);\n+            externalDataObject.setDisplayValue(journalTitle);\n+        }\n+        // Set ISSNs in external object\n+        if (CollectionUtils.isNotEmpty(sherpaJournal.getIssns())) {\n+            String issn = sherpaJournal.getIssns().get(0);\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                    \"dc\", \"identifier\", \"issn\", null, issn));\n+\n+        }\n+\n+        return externalDataObject;\n+    }\n+\n+    /**\n+     * Search SHERPA v2 API for journal results based on a 'contains word' query\n+     * @param query The query for the search\n+     * @param start The start of the search\n+     * @param limit The max amount of records to be returned by the search\n+     * @return a list of external data objects\n+     */\n+    @Override\n+    public List<ExternalDataObject> searchExternalDataObjects(String query, int start, int limit) {\n+        // query args to add to SHERPA/RoMEO request URL\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query, start, limit);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Get response input stream and parse JSON into new SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAResponse sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getJournals())) {\n+                        List<ExternalDataObject> list = sherpaResponse.getJournals().stream().map(\n+                            sherpaJournal -> constructExternalDataObjectFromSherpaJournal(sherpaJournal)).collect(\n+                            Collectors.toList());\n+\n+                        // Unlike the previous API version we can request offset and limit, so no need to build a\n+                        // sublist from this list, we can just return the list.\n+                        return list;\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error parsing SHERPA response input stream: \" + e.getMessage());\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            }\n+        } catch (IOException | URISyntaxException e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+            return null;\n+        } finally {\n+            if (get != null) {\n+                get.releaseConnection();\n+            }\n+        }\n+        return Collections.emptyList();\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"title contains word\" query using default start/limit parameters\n+     * @param query a word or phrase to search for in journal title\n+     * @return HttpGet method which can then be executed by the client\n+     * @throws URISyntaxException if the URL build fails\n+     */\n+    private HttpGet constructHttpGet(String query) throws URISyntaxException {\n+        return constructHttpGet(query, -1, -1);\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"title contains word\" query\n+     * @param query the search query\n+     * @param start row offset\n+     * @param limit number of results to return\n+     * @return HttpGet object to be executed by the client\n+     * @throws URISyntaxException\n+     */\n+    private HttpGet constructHttpGet(String query, int start, int limit) throws URISyntaxException {\n+        // Build URL based on search query\n+        URIBuilder uriBuilder = new URIBuilder(url);\n+        uriBuilder.addParameter(\"item-type\", \"publication\");\n+        uriBuilder.addParameter(\"filter\", \"[[\\\"title\\\",\\\"contains word\\\",\\\"\" + query + \"\\\"]]\");\n+        uriBuilder.addParameter(\"format\", \"Json\");\n+        // Set optional start (offset) and limit parameters\n+        if (start >= 0) {\n+            uriBuilder.addParameter(\"offset\", String.valueOf(start));\n+        }\n+        if (limit > 0) {\n+            uriBuilder.addParameter(\"limit\", String.valueOf(limit));\n+        }\n+        if (StringUtils.isNotBlank(apiKey)) {\n+            uriBuilder.addParameter(\"api-key\", apiKey);\n+        }\n+\n+        // Create HTTP GET object\n+        HttpGet method = new HttpGet(uriBuilder.build());\n+\n+        // Set connection parameters\n+        int timeout = 5000;\n+        method.setConfig(RequestConfig.custom()\n+            .setConnectionRequestTimeout(timeout)\n+            .setConnectTimeout(timeout)\n+            .setSocketTimeout(timeout)\n+            .build());\n+        return new HttpGet(uriBuilder.build());\n+    }\n+\n+    @Override\n+    public boolean supports(String source) {\n+        return StringUtils.equalsIgnoreCase(sourceIdentifier, source);\n+    }\n+\n+    /**\n+     * Get number of results returned from a SHERPA v2 publication search\n+     * @param query The query to be search on and give the total amount of results\n+     * @return int representing number of journal results\n+     */\n+    @Override\n+    public int getNumberOfResults(String query) {\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Read response and parse as SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAResponse sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getJournals())) {\n+                        return sherpaResponse.getJournals().size();\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error reading input stream for SHERPAResponse: \" + e.getMessage());\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            }\n+        } catch (IOException | URISyntaxException e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4NTMzNw=="}, "originalCommit": null, "originalPosition": 308}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMjA5MTI1OnYy", "diffSide": "RIGHT", "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2PublisherDataProvider.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMDo0NzowN1rOGdsK2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMVQwMzozODo1MVrOGmpdAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4NTU2Mg==", "bodyText": "should we rethrow the exception instead?", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r433785562", "createdAt": "2020-06-02T10:47:07Z", "author": {"login": "abollini"}, "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2PublisherDataProvider.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URISyntaxException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.sherpa.v2.SHERPAPublisher;\n+import org.dspace.app.sherpa.v2.SHERPAPublisherResponse;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+\n+/**\n+ * This class is the implementation of the ExternalDataProvider interface that will deal with SHERPAPublisher External\n+ * data lookups.\n+ * This provider is a refactored version of SherpaPublisherDataPublisher, rewritten to work with SHERPA v2 API\n+ *\n+ * It uses a more simple response object than the normal publication / policy search\n+ *\n+ * @author Kim Shepherd\n+ */\n+public class SHERPAv2PublisherDataProvider implements ExternalDataProvider {\n+\n+    private static final Logger log =\n+        org.apache.logging.log4j.LogManager.getLogger(SHERPAv2PublisherDataProvider.class);\n+\n+    private String sourceIdentifier;\n+    private String url;\n+    private String apiKey;\n+\n+    private CloseableHttpClient client = null;\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * Initialise the client that we need to call the endpoint\n+     * @throws IOException  If something goes wrong\n+     */\n+    public void init() throws IOException {\n+        HttpClientBuilder builder = HttpClientBuilder.create();\n+        // httpclient 4.3+ doesn't appear to have any sensible defaults any more. Setting conservative defaults as\n+        // not to hammer the SHERPA service too much.\n+        client = builder\n+            .disableAutomaticRetries()\n+            .setMaxConnTotal(5)\n+            .build();\n+    }\n+\n+    /**\n+     * Get a single publisher based on a \"id equals string\" query\n+     * @param id    The publisher ID which will be used as query string\n+     * @return external data object representing publisher\n+     */\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+\n+        HttpGet method = null;\n+        SHERPAPublisherResponse sherpaResponse = null;\n+        int timeout = 5000;\n+        URIBuilder uriBuilder = null;\n+        try {\n+            // Construct URI for an exact match on journal title\n+            uriBuilder = new URIBuilder(url);\n+            uriBuilder.addParameter(\"item-type\", \"publisher\");\n+            uriBuilder.addParameter(\"filter\", \"[[\\\"id\\\",\\\"equals\\\",\\\"\" + id + \"\\\"]]\");\n+            uriBuilder.addParameter(\"format\", \"Json\");\n+            if (StringUtils.isNotBlank(apiKey)) {\n+                uriBuilder.addParameter(\"api-key\", apiKey);\n+            }\n+\n+            // Build HTTP method\n+            method = new HttpGet(uriBuilder.build());\n+            method.setConfig(RequestConfig.custom()\n+                .setConnectionRequestTimeout(timeout)\n+                .setConnectTimeout(timeout)\n+                .setSocketTimeout(timeout)\n+                .build());\n+\n+            // Execute the method\n+            HttpResponse response = client.execute(method);\n+            int statusCode = response.getStatusLine().getStatusCode();\n+\n+            if (statusCode != HttpStatus.SC_OK) {\n+                sherpaResponse = new SHERPAPublisherResponse(\"SHERPA/RoMEO return not OK status: \"\n+                    + statusCode);\n+            }\n+\n+            HttpEntity responseBody = response.getEntity();\n+\n+            // Get InputStream from API response and parse JSON\n+            if (null != responseBody) {\n+                InputStream content = null;\n+                try {\n+                    content = responseBody.getContent();\n+                    sherpaResponse = new SHERPAPublisherResponse(content, SHERPAPublisherResponse.SHERPAFormat.JSON);\n+                } catch (IOException e) {\n+                    log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            } else {\n+                sherpaResponse = new SHERPAPublisherResponse(\"SHERPA/RoMEO returned no response\");\n+            }\n+        } catch (Exception e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+        }\n+\n+        if (sherpaResponse == null) {\n+            sherpaResponse = new SHERPAPublisherResponse(\"Error processing the SHERPA/RoMEO answer\");\n+        }\n+        if (CollectionUtils.isNotEmpty(sherpaResponse.getPublishers())) {\n+            SHERPAPublisher sherpaPublisher = sherpaResponse.getPublishers().get(0);\n+            // Construct external data object from returned publisher\n+            ExternalDataObject externalDataObject = constructExternalDataObjectFromSherpaPublisher(sherpaPublisher);\n+            return Optional.of(externalDataObject);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Search SHERPA v2 API for publisher results based on a 'contains word' query for publisher name\n+     * @param query The query for the search\n+     * @param start The start of the search\n+     * @param limit The max amount of records to be returned by the search\n+     * @return a list of external data objects\n+     */\n+    @Override\n+    public List<ExternalDataObject> searchExternalDataObjects(String query, int start, int limit) {\n+        // query args to add to SHERPA/RoMEO request URL\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query, start, limit);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Get response input stream and parse JSON into new SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAPublisherResponse sherpaResponse =\n+                        new SHERPAPublisherResponse(content, SHERPAPublisherResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getPublishers())) {\n+                        List<ExternalDataObject> list = sherpaResponse.getPublishers().stream().map(\n+                            sherpaPublisher -> constructExternalDataObjectFromSherpaPublisher(sherpaPublisher)).collect(\n+                            Collectors.toList());\n+\n+                        // Unlike the previous API version we can request offset and limit, so no need to build a\n+                        // sublist from this list, we can just return the list.\n+                        return list;\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error parsing SHERPA response input stream: \" + e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE3ODI0Mg==", "bodyText": "I have now rethrown this exception in 3ef47dac - this one I can do, as it is nested within a higher try/catch block.\nHowever, note that for the main catch in the method:\nThis class and its methods implement ExternalDataService interface (via extending ExternalDataServiceImpl). The abstract methods don't have any throw statements in its signatures. I would be hesitant to include a refactor of this interface and abstract impl in this PR as it would have consequences for all other providers.", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r443178242", "createdAt": "2020-06-21T03:38:51Z", "author": {"login": "kshepherd"}, "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2PublisherDataProvider.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URISyntaxException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.sherpa.v2.SHERPAPublisher;\n+import org.dspace.app.sherpa.v2.SHERPAPublisherResponse;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+\n+/**\n+ * This class is the implementation of the ExternalDataProvider interface that will deal with SHERPAPublisher External\n+ * data lookups.\n+ * This provider is a refactored version of SherpaPublisherDataPublisher, rewritten to work with SHERPA v2 API\n+ *\n+ * It uses a more simple response object than the normal publication / policy search\n+ *\n+ * @author Kim Shepherd\n+ */\n+public class SHERPAv2PublisherDataProvider implements ExternalDataProvider {\n+\n+    private static final Logger log =\n+        org.apache.logging.log4j.LogManager.getLogger(SHERPAv2PublisherDataProvider.class);\n+\n+    private String sourceIdentifier;\n+    private String url;\n+    private String apiKey;\n+\n+    private CloseableHttpClient client = null;\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * Initialise the client that we need to call the endpoint\n+     * @throws IOException  If something goes wrong\n+     */\n+    public void init() throws IOException {\n+        HttpClientBuilder builder = HttpClientBuilder.create();\n+        // httpclient 4.3+ doesn't appear to have any sensible defaults any more. Setting conservative defaults as\n+        // not to hammer the SHERPA service too much.\n+        client = builder\n+            .disableAutomaticRetries()\n+            .setMaxConnTotal(5)\n+            .build();\n+    }\n+\n+    /**\n+     * Get a single publisher based on a \"id equals string\" query\n+     * @param id    The publisher ID which will be used as query string\n+     * @return external data object representing publisher\n+     */\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+\n+        HttpGet method = null;\n+        SHERPAPublisherResponse sherpaResponse = null;\n+        int timeout = 5000;\n+        URIBuilder uriBuilder = null;\n+        try {\n+            // Construct URI for an exact match on journal title\n+            uriBuilder = new URIBuilder(url);\n+            uriBuilder.addParameter(\"item-type\", \"publisher\");\n+            uriBuilder.addParameter(\"filter\", \"[[\\\"id\\\",\\\"equals\\\",\\\"\" + id + \"\\\"]]\");\n+            uriBuilder.addParameter(\"format\", \"Json\");\n+            if (StringUtils.isNotBlank(apiKey)) {\n+                uriBuilder.addParameter(\"api-key\", apiKey);\n+            }\n+\n+            // Build HTTP method\n+            method = new HttpGet(uriBuilder.build());\n+            method.setConfig(RequestConfig.custom()\n+                .setConnectionRequestTimeout(timeout)\n+                .setConnectTimeout(timeout)\n+                .setSocketTimeout(timeout)\n+                .build());\n+\n+            // Execute the method\n+            HttpResponse response = client.execute(method);\n+            int statusCode = response.getStatusLine().getStatusCode();\n+\n+            if (statusCode != HttpStatus.SC_OK) {\n+                sherpaResponse = new SHERPAPublisherResponse(\"SHERPA/RoMEO return not OK status: \"\n+                    + statusCode);\n+            }\n+\n+            HttpEntity responseBody = response.getEntity();\n+\n+            // Get InputStream from API response and parse JSON\n+            if (null != responseBody) {\n+                InputStream content = null;\n+                try {\n+                    content = responseBody.getContent();\n+                    sherpaResponse = new SHERPAPublisherResponse(content, SHERPAPublisherResponse.SHERPAFormat.JSON);\n+                } catch (IOException e) {\n+                    log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            } else {\n+                sherpaResponse = new SHERPAPublisherResponse(\"SHERPA/RoMEO returned no response\");\n+            }\n+        } catch (Exception e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+        }\n+\n+        if (sherpaResponse == null) {\n+            sherpaResponse = new SHERPAPublisherResponse(\"Error processing the SHERPA/RoMEO answer\");\n+        }\n+        if (CollectionUtils.isNotEmpty(sherpaResponse.getPublishers())) {\n+            SHERPAPublisher sherpaPublisher = sherpaResponse.getPublishers().get(0);\n+            // Construct external data object from returned publisher\n+            ExternalDataObject externalDataObject = constructExternalDataObjectFromSherpaPublisher(sherpaPublisher);\n+            return Optional.of(externalDataObject);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Search SHERPA v2 API for publisher results based on a 'contains word' query for publisher name\n+     * @param query The query for the search\n+     * @param start The start of the search\n+     * @param limit The max amount of records to be returned by the search\n+     * @return a list of external data objects\n+     */\n+    @Override\n+    public List<ExternalDataObject> searchExternalDataObjects(String query, int start, int limit) {\n+        // query args to add to SHERPA/RoMEO request URL\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query, start, limit);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Get response input stream and parse JSON into new SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAPublisherResponse sherpaResponse =\n+                        new SHERPAPublisherResponse(content, SHERPAPublisherResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getPublishers())) {\n+                        List<ExternalDataObject> list = sherpaResponse.getPublishers().stream().map(\n+                            sherpaPublisher -> constructExternalDataObjectFromSherpaPublisher(sherpaPublisher)).collect(\n+                            Collectors.toList());\n+\n+                        // Unlike the previous API version we can request offset and limit, so no need to build a\n+                        // sublist from this list, we can just return the list.\n+                        return list;\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error parsing SHERPA response input stream: \" + e.getMessage());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4NTU2Mg=="}, "originalCommit": null, "originalPosition": 181}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMjA5MjM1OnYy", "diffSide": "RIGHT", "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2PublisherDataProvider.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMDo0NzoyN1rOGdsLiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMVQwMzoyNTozOVrOGmpanA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4NTczNw==", "bodyText": "do we need to escape the query?", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r433785737", "createdAt": "2020-06-02T10:47:27Z", "author": {"login": "abollini"}, "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2PublisherDataProvider.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URISyntaxException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.sherpa.v2.SHERPAPublisher;\n+import org.dspace.app.sherpa.v2.SHERPAPublisherResponse;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+\n+/**\n+ * This class is the implementation of the ExternalDataProvider interface that will deal with SHERPAPublisher External\n+ * data lookups.\n+ * This provider is a refactored version of SherpaPublisherDataPublisher, rewritten to work with SHERPA v2 API\n+ *\n+ * It uses a more simple response object than the normal publication / policy search\n+ *\n+ * @author Kim Shepherd\n+ */\n+public class SHERPAv2PublisherDataProvider implements ExternalDataProvider {\n+\n+    private static final Logger log =\n+        org.apache.logging.log4j.LogManager.getLogger(SHERPAv2PublisherDataProvider.class);\n+\n+    private String sourceIdentifier;\n+    private String url;\n+    private String apiKey;\n+\n+    private CloseableHttpClient client = null;\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * Initialise the client that we need to call the endpoint\n+     * @throws IOException  If something goes wrong\n+     */\n+    public void init() throws IOException {\n+        HttpClientBuilder builder = HttpClientBuilder.create();\n+        // httpclient 4.3+ doesn't appear to have any sensible defaults any more. Setting conservative defaults as\n+        // not to hammer the SHERPA service too much.\n+        client = builder\n+            .disableAutomaticRetries()\n+            .setMaxConnTotal(5)\n+            .build();\n+    }\n+\n+    /**\n+     * Get a single publisher based on a \"id equals string\" query\n+     * @param id    The publisher ID which will be used as query string\n+     * @return external data object representing publisher\n+     */\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+\n+        HttpGet method = null;\n+        SHERPAPublisherResponse sherpaResponse = null;\n+        int timeout = 5000;\n+        URIBuilder uriBuilder = null;\n+        try {\n+            // Construct URI for an exact match on journal title\n+            uriBuilder = new URIBuilder(url);\n+            uriBuilder.addParameter(\"item-type\", \"publisher\");\n+            uriBuilder.addParameter(\"filter\", \"[[\\\"id\\\",\\\"equals\\\",\\\"\" + id + \"\\\"]]\");\n+            uriBuilder.addParameter(\"format\", \"Json\");\n+            if (StringUtils.isNotBlank(apiKey)) {\n+                uriBuilder.addParameter(\"api-key\", apiKey);\n+            }\n+\n+            // Build HTTP method\n+            method = new HttpGet(uriBuilder.build());\n+            method.setConfig(RequestConfig.custom()\n+                .setConnectionRequestTimeout(timeout)\n+                .setConnectTimeout(timeout)\n+                .setSocketTimeout(timeout)\n+                .build());\n+\n+            // Execute the method\n+            HttpResponse response = client.execute(method);\n+            int statusCode = response.getStatusLine().getStatusCode();\n+\n+            if (statusCode != HttpStatus.SC_OK) {\n+                sherpaResponse = new SHERPAPublisherResponse(\"SHERPA/RoMEO return not OK status: \"\n+                    + statusCode);\n+            }\n+\n+            HttpEntity responseBody = response.getEntity();\n+\n+            // Get InputStream from API response and parse JSON\n+            if (null != responseBody) {\n+                InputStream content = null;\n+                try {\n+                    content = responseBody.getContent();\n+                    sherpaResponse = new SHERPAPublisherResponse(content, SHERPAPublisherResponse.SHERPAFormat.JSON);\n+                } catch (IOException e) {\n+                    log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            } else {\n+                sherpaResponse = new SHERPAPublisherResponse(\"SHERPA/RoMEO returned no response\");\n+            }\n+        } catch (Exception e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+        }\n+\n+        if (sherpaResponse == null) {\n+            sherpaResponse = new SHERPAPublisherResponse(\"Error processing the SHERPA/RoMEO answer\");\n+        }\n+        if (CollectionUtils.isNotEmpty(sherpaResponse.getPublishers())) {\n+            SHERPAPublisher sherpaPublisher = sherpaResponse.getPublishers().get(0);\n+            // Construct external data object from returned publisher\n+            ExternalDataObject externalDataObject = constructExternalDataObjectFromSherpaPublisher(sherpaPublisher);\n+            return Optional.of(externalDataObject);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Search SHERPA v2 API for publisher results based on a 'contains word' query for publisher name\n+     * @param query The query for the search\n+     * @param start The start of the search\n+     * @param limit The max amount of records to be returned by the search\n+     * @return a list of external data objects\n+     */\n+    @Override\n+    public List<ExternalDataObject> searchExternalDataObjects(String query, int start, int limit) {\n+        // query args to add to SHERPA/RoMEO request URL\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query, start, limit);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Get response input stream and parse JSON into new SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAPublisherResponse sherpaResponse =\n+                        new SHERPAPublisherResponse(content, SHERPAPublisherResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getPublishers())) {\n+                        List<ExternalDataObject> list = sherpaResponse.getPublishers().stream().map(\n+                            sherpaPublisher -> constructExternalDataObjectFromSherpaPublisher(sherpaPublisher)).collect(\n+                            Collectors.toList());\n+\n+                        // Unlike the previous API version we can request offset and limit, so no need to build a\n+                        // sublist from this list, we can just return the list.\n+                        return list;\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error parsing SHERPA response input stream: \" + e.getMessage());\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            }\n+        } catch (IOException | URISyntaxException e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+            return null;\n+        } finally {\n+            if (get != null) {\n+                get.releaseConnection();\n+            }\n+        }\n+        return Collections.emptyList();\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"publisher name contains word\" query using default start/limit parameters\n+     * @param query a word or phrase to search for in publisher name\n+     * @return HttpGet method which can then be executed by the client\n+     * @throws URISyntaxException if the URL build fails\n+     */\n+    private HttpGet constructHttpGet(String query) throws URISyntaxException {\n+        return constructHttpGet(query, -1, -1);\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"publisher name contains word\" query\n+     * @param query the search query\n+     * @param start row offset\n+     * @param limit number of results to return\n+     * @return HttpGet object to be executed by the client\n+     * @throws URISyntaxException\n+     */\n+    private HttpGet constructHttpGet(String query, int start, int limit) throws URISyntaxException {\n+        // Build URL based on search query\n+        URIBuilder uriBuilder = new URIBuilder(url);\n+        uriBuilder.addParameter(\"item-type\", \"publisher\");\n+        uriBuilder.addParameter(\"filter\", \"[[\\\"name\\\",\\\"contains word\\\",\\\"\" + query + \"\\\"]]\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE3NzYyOA==", "bodyText": "After talking to SHERPA devs I have done some simple stripping for valid URI / JSON parsing. Note, the URI Builder itself already escapes/encodes for URL\nSee commit a81fe58", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r443177628", "createdAt": "2020-06-21T03:25:39Z", "author": {"login": "kshepherd"}, "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2PublisherDataProvider.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URISyntaxException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.sherpa.v2.SHERPAPublisher;\n+import org.dspace.app.sherpa.v2.SHERPAPublisherResponse;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+\n+/**\n+ * This class is the implementation of the ExternalDataProvider interface that will deal with SHERPAPublisher External\n+ * data lookups.\n+ * This provider is a refactored version of SherpaPublisherDataPublisher, rewritten to work with SHERPA v2 API\n+ *\n+ * It uses a more simple response object than the normal publication / policy search\n+ *\n+ * @author Kim Shepherd\n+ */\n+public class SHERPAv2PublisherDataProvider implements ExternalDataProvider {\n+\n+    private static final Logger log =\n+        org.apache.logging.log4j.LogManager.getLogger(SHERPAv2PublisherDataProvider.class);\n+\n+    private String sourceIdentifier;\n+    private String url;\n+    private String apiKey;\n+\n+    private CloseableHttpClient client = null;\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * Initialise the client that we need to call the endpoint\n+     * @throws IOException  If something goes wrong\n+     */\n+    public void init() throws IOException {\n+        HttpClientBuilder builder = HttpClientBuilder.create();\n+        // httpclient 4.3+ doesn't appear to have any sensible defaults any more. Setting conservative defaults as\n+        // not to hammer the SHERPA service too much.\n+        client = builder\n+            .disableAutomaticRetries()\n+            .setMaxConnTotal(5)\n+            .build();\n+    }\n+\n+    /**\n+     * Get a single publisher based on a \"id equals string\" query\n+     * @param id    The publisher ID which will be used as query string\n+     * @return external data object representing publisher\n+     */\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+\n+        HttpGet method = null;\n+        SHERPAPublisherResponse sherpaResponse = null;\n+        int timeout = 5000;\n+        URIBuilder uriBuilder = null;\n+        try {\n+            // Construct URI for an exact match on journal title\n+            uriBuilder = new URIBuilder(url);\n+            uriBuilder.addParameter(\"item-type\", \"publisher\");\n+            uriBuilder.addParameter(\"filter\", \"[[\\\"id\\\",\\\"equals\\\",\\\"\" + id + \"\\\"]]\");\n+            uriBuilder.addParameter(\"format\", \"Json\");\n+            if (StringUtils.isNotBlank(apiKey)) {\n+                uriBuilder.addParameter(\"api-key\", apiKey);\n+            }\n+\n+            // Build HTTP method\n+            method = new HttpGet(uriBuilder.build());\n+            method.setConfig(RequestConfig.custom()\n+                .setConnectionRequestTimeout(timeout)\n+                .setConnectTimeout(timeout)\n+                .setSocketTimeout(timeout)\n+                .build());\n+\n+            // Execute the method\n+            HttpResponse response = client.execute(method);\n+            int statusCode = response.getStatusLine().getStatusCode();\n+\n+            if (statusCode != HttpStatus.SC_OK) {\n+                sherpaResponse = new SHERPAPublisherResponse(\"SHERPA/RoMEO return not OK status: \"\n+                    + statusCode);\n+            }\n+\n+            HttpEntity responseBody = response.getEntity();\n+\n+            // Get InputStream from API response and parse JSON\n+            if (null != responseBody) {\n+                InputStream content = null;\n+                try {\n+                    content = responseBody.getContent();\n+                    sherpaResponse = new SHERPAPublisherResponse(content, SHERPAPublisherResponse.SHERPAFormat.JSON);\n+                } catch (IOException e) {\n+                    log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            } else {\n+                sherpaResponse = new SHERPAPublisherResponse(\"SHERPA/RoMEO returned no response\");\n+            }\n+        } catch (Exception e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+        }\n+\n+        if (sherpaResponse == null) {\n+            sherpaResponse = new SHERPAPublisherResponse(\"Error processing the SHERPA/RoMEO answer\");\n+        }\n+        if (CollectionUtils.isNotEmpty(sherpaResponse.getPublishers())) {\n+            SHERPAPublisher sherpaPublisher = sherpaResponse.getPublishers().get(0);\n+            // Construct external data object from returned publisher\n+            ExternalDataObject externalDataObject = constructExternalDataObjectFromSherpaPublisher(sherpaPublisher);\n+            return Optional.of(externalDataObject);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Search SHERPA v2 API for publisher results based on a 'contains word' query for publisher name\n+     * @param query The query for the search\n+     * @param start The start of the search\n+     * @param limit The max amount of records to be returned by the search\n+     * @return a list of external data objects\n+     */\n+    @Override\n+    public List<ExternalDataObject> searchExternalDataObjects(String query, int start, int limit) {\n+        // query args to add to SHERPA/RoMEO request URL\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query, start, limit);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Get response input stream and parse JSON into new SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAPublisherResponse sherpaResponse =\n+                        new SHERPAPublisherResponse(content, SHERPAPublisherResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getPublishers())) {\n+                        List<ExternalDataObject> list = sherpaResponse.getPublishers().stream().map(\n+                            sherpaPublisher -> constructExternalDataObjectFromSherpaPublisher(sherpaPublisher)).collect(\n+                            Collectors.toList());\n+\n+                        // Unlike the previous API version we can request offset and limit, so no need to build a\n+                        // sublist from this list, we can just return the list.\n+                        return list;\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error parsing SHERPA response input stream: \" + e.getMessage());\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            }\n+        } catch (IOException | URISyntaxException e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+            return null;\n+        } finally {\n+            if (get != null) {\n+                get.releaseConnection();\n+            }\n+        }\n+        return Collections.emptyList();\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"publisher name contains word\" query using default start/limit parameters\n+     * @param query a word or phrase to search for in publisher name\n+     * @return HttpGet method which can then be executed by the client\n+     * @throws URISyntaxException if the URL build fails\n+     */\n+    private HttpGet constructHttpGet(String query) throws URISyntaxException {\n+        return constructHttpGet(query, -1, -1);\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"publisher name contains word\" query\n+     * @param query the search query\n+     * @param start row offset\n+     * @param limit number of results to return\n+     * @return HttpGet object to be executed by the client\n+     * @throws URISyntaxException\n+     */\n+    private HttpGet constructHttpGet(String query, int start, int limit) throws URISyntaxException {\n+        // Build URL based on search query\n+        URIBuilder uriBuilder = new URIBuilder(url);\n+        uriBuilder.addParameter(\"item-type\", \"publisher\");\n+        uriBuilder.addParameter(\"filter\", \"[[\\\"name\\\",\\\"contains word\\\",\\\"\" + query + \"\\\"]]\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4NTczNw=="}, "originalCommit": null, "originalPosition": 221}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMjA5NTQ4OnYy", "diffSide": "RIGHT", "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2PublisherDataProvider.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMDo0ODoyMVrOGdsNaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMVQwMzozODozOFrOGmpc-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4NjIxNg==", "bodyText": "should we rethrow the exception instead?", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r433786216", "createdAt": "2020-06-02T10:48:21Z", "author": {"login": "abollini"}, "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2PublisherDataProvider.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URISyntaxException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.sherpa.v2.SHERPAPublisher;\n+import org.dspace.app.sherpa.v2.SHERPAPublisherResponse;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+\n+/**\n+ * This class is the implementation of the ExternalDataProvider interface that will deal with SHERPAPublisher External\n+ * data lookups.\n+ * This provider is a refactored version of SherpaPublisherDataPublisher, rewritten to work with SHERPA v2 API\n+ *\n+ * It uses a more simple response object than the normal publication / policy search\n+ *\n+ * @author Kim Shepherd\n+ */\n+public class SHERPAv2PublisherDataProvider implements ExternalDataProvider {\n+\n+    private static final Logger log =\n+        org.apache.logging.log4j.LogManager.getLogger(SHERPAv2PublisherDataProvider.class);\n+\n+    private String sourceIdentifier;\n+    private String url;\n+    private String apiKey;\n+\n+    private CloseableHttpClient client = null;\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * Initialise the client that we need to call the endpoint\n+     * @throws IOException  If something goes wrong\n+     */\n+    public void init() throws IOException {\n+        HttpClientBuilder builder = HttpClientBuilder.create();\n+        // httpclient 4.3+ doesn't appear to have any sensible defaults any more. Setting conservative defaults as\n+        // not to hammer the SHERPA service too much.\n+        client = builder\n+            .disableAutomaticRetries()\n+            .setMaxConnTotal(5)\n+            .build();\n+    }\n+\n+    /**\n+     * Get a single publisher based on a \"id equals string\" query\n+     * @param id    The publisher ID which will be used as query string\n+     * @return external data object representing publisher\n+     */\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+\n+        HttpGet method = null;\n+        SHERPAPublisherResponse sherpaResponse = null;\n+        int timeout = 5000;\n+        URIBuilder uriBuilder = null;\n+        try {\n+            // Construct URI for an exact match on journal title\n+            uriBuilder = new URIBuilder(url);\n+            uriBuilder.addParameter(\"item-type\", \"publisher\");\n+            uriBuilder.addParameter(\"filter\", \"[[\\\"id\\\",\\\"equals\\\",\\\"\" + id + \"\\\"]]\");\n+            uriBuilder.addParameter(\"format\", \"Json\");\n+            if (StringUtils.isNotBlank(apiKey)) {\n+                uriBuilder.addParameter(\"api-key\", apiKey);\n+            }\n+\n+            // Build HTTP method\n+            method = new HttpGet(uriBuilder.build());\n+            method.setConfig(RequestConfig.custom()\n+                .setConnectionRequestTimeout(timeout)\n+                .setConnectTimeout(timeout)\n+                .setSocketTimeout(timeout)\n+                .build());\n+\n+            // Execute the method\n+            HttpResponse response = client.execute(method);\n+            int statusCode = response.getStatusLine().getStatusCode();\n+\n+            if (statusCode != HttpStatus.SC_OK) {\n+                sherpaResponse = new SHERPAPublisherResponse(\"SHERPA/RoMEO return not OK status: \"\n+                    + statusCode);\n+            }\n+\n+            HttpEntity responseBody = response.getEntity();\n+\n+            // Get InputStream from API response and parse JSON\n+            if (null != responseBody) {\n+                InputStream content = null;\n+                try {\n+                    content = responseBody.getContent();\n+                    sherpaResponse = new SHERPAPublisherResponse(content, SHERPAPublisherResponse.SHERPAFormat.JSON);\n+                } catch (IOException e) {\n+                    log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            } else {\n+                sherpaResponse = new SHERPAPublisherResponse(\"SHERPA/RoMEO returned no response\");\n+            }\n+        } catch (Exception e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+        }\n+\n+        if (sherpaResponse == null) {\n+            sherpaResponse = new SHERPAPublisherResponse(\"Error processing the SHERPA/RoMEO answer\");\n+        }\n+        if (CollectionUtils.isNotEmpty(sherpaResponse.getPublishers())) {\n+            SHERPAPublisher sherpaPublisher = sherpaResponse.getPublishers().get(0);\n+            // Construct external data object from returned publisher\n+            ExternalDataObject externalDataObject = constructExternalDataObjectFromSherpaPublisher(sherpaPublisher);\n+            return Optional.of(externalDataObject);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Search SHERPA v2 API for publisher results based on a 'contains word' query for publisher name\n+     * @param query The query for the search\n+     * @param start The start of the search\n+     * @param limit The max amount of records to be returned by the search\n+     * @return a list of external data objects\n+     */\n+    @Override\n+    public List<ExternalDataObject> searchExternalDataObjects(String query, int start, int limit) {\n+        // query args to add to SHERPA/RoMEO request URL\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query, start, limit);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Get response input stream and parse JSON into new SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAPublisherResponse sherpaResponse =\n+                        new SHERPAPublisherResponse(content, SHERPAPublisherResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getPublishers())) {\n+                        List<ExternalDataObject> list = sherpaResponse.getPublishers().stream().map(\n+                            sherpaPublisher -> constructExternalDataObjectFromSherpaPublisher(sherpaPublisher)).collect(\n+                            Collectors.toList());\n+\n+                        // Unlike the previous API version we can request offset and limit, so no need to build a\n+                        // sublist from this list, we can just return the list.\n+                        return list;\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error parsing SHERPA response input stream: \" + e.getMessage());\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            }\n+        } catch (IOException | URISyntaxException e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+            return null;\n+        } finally {\n+            if (get != null) {\n+                get.releaseConnection();\n+            }\n+        }\n+        return Collections.emptyList();\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"publisher name contains word\" query using default start/limit parameters\n+     * @param query a word or phrase to search for in publisher name\n+     * @return HttpGet method which can then be executed by the client\n+     * @throws URISyntaxException if the URL build fails\n+     */\n+    private HttpGet constructHttpGet(String query) throws URISyntaxException {\n+        return constructHttpGet(query, -1, -1);\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"publisher name contains word\" query\n+     * @param query the search query\n+     * @param start row offset\n+     * @param limit number of results to return\n+     * @return HttpGet object to be executed by the client\n+     * @throws URISyntaxException\n+     */\n+    private HttpGet constructHttpGet(String query, int start, int limit) throws URISyntaxException {\n+        // Build URL based on search query\n+        URIBuilder uriBuilder = new URIBuilder(url);\n+        uriBuilder.addParameter(\"item-type\", \"publisher\");\n+        uriBuilder.addParameter(\"filter\", \"[[\\\"name\\\",\\\"contains word\\\",\\\"\" + query + \"\\\"]]\");\n+        uriBuilder.addParameter(\"format\", \"Json\");\n+        // Set optional start (offset) and limit parameters\n+        if (start >= 0) {\n+            uriBuilder.addParameter(\"offset\", String.valueOf(start));\n+        }\n+        if (limit > 0) {\n+            uriBuilder.addParameter(\"limit\", String.valueOf(limit));\n+        }\n+        if (StringUtils.isNotBlank(apiKey)) {\n+            uriBuilder.addParameter(\"api-key\", apiKey);\n+        }\n+\n+        // Create HTTP GET object\n+        HttpGet method = new HttpGet(uriBuilder.build());\n+\n+        // Set connection parameters\n+        int timeout = 5000;\n+        method.setConfig(RequestConfig.custom()\n+            .setConnectionRequestTimeout(timeout)\n+            .setConnectTimeout(timeout)\n+            .setSocketTimeout(timeout)\n+            .build());\n+        return new HttpGet(uriBuilder.build());\n+    }\n+\n+    private ExternalDataObject constructExternalDataObjectFromSherpaPublisher(SHERPAPublisher sherpaPublisher) {\n+        ExternalDataObject externalDataObject = new ExternalDataObject();\n+        externalDataObject.setSource(sourceIdentifier);\n+\n+        // Set publisher name\n+        if (StringUtils.isNotBlank(sherpaPublisher.getName())) {\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"title\", null, null, sherpaPublisher.getName()));\n+            externalDataObject.setDisplayValue(sherpaPublisher.getName());\n+            externalDataObject.setValue(sherpaPublisher.getName());\n+        }\n+        // Set publisher ID\n+        if (StringUtils.isNotBlank(sherpaPublisher.getIdentifier())) {\n+            externalDataObject.setId(sherpaPublisher.getIdentifier());\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"identifier\", \"sherpaPublisher\", null,\n+                sherpaPublisher.getIdentifier()));\n+        }\n+\n+        // Set home URL\n+        if (StringUtils.isNotBlank(sherpaPublisher.getUri())) {\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"identifier\", \"other\", null, sherpaPublisher.getUri()));\n+        }\n+\n+        return externalDataObject;\n+    }\n+\n+    @Override\n+    public boolean supports(String source) {\n+        return StringUtils.equalsIgnoreCase(sourceIdentifier, source);\n+    }\n+\n+    /**\n+     * Get number of results returned from a SHERPA v2 publication search\n+     * @param query The query to be search on and give the total amount of results\n+     * @return int representing number of publisher results\n+     */\n+    @Override\n+    public int getNumberOfResults(String query) {\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Read response and parse as SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAPublisherResponse sherpaResponse =\n+                        new SHERPAPublisherResponse(content, SHERPAPublisherResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getPublishers())) {\n+                        return sherpaResponse.getPublishers().size();\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error reading input stream for SHERPAResponse: \" + e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 303}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE3ODIzNA==", "bodyText": "I have now rethrown this exception in 3ef47dac - this one I can do, as it is nested within a higher try/catch block.\nHowever, note that for the main catch in the method:\nThis class and its methods implement ExternalDataService interface (via extending ExternalDataServiceImpl). The abstract methods don't have any throw statements in its signatures. I would be hesitant to include a refactor of this interface and abstract impl in this PR as it would have consequences for all other providers.", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r443178234", "createdAt": "2020-06-21T03:38:38Z", "author": {"login": "kshepherd"}, "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2PublisherDataProvider.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URISyntaxException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.sherpa.v2.SHERPAPublisher;\n+import org.dspace.app.sherpa.v2.SHERPAPublisherResponse;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+\n+/**\n+ * This class is the implementation of the ExternalDataProvider interface that will deal with SHERPAPublisher External\n+ * data lookups.\n+ * This provider is a refactored version of SherpaPublisherDataPublisher, rewritten to work with SHERPA v2 API\n+ *\n+ * It uses a more simple response object than the normal publication / policy search\n+ *\n+ * @author Kim Shepherd\n+ */\n+public class SHERPAv2PublisherDataProvider implements ExternalDataProvider {\n+\n+    private static final Logger log =\n+        org.apache.logging.log4j.LogManager.getLogger(SHERPAv2PublisherDataProvider.class);\n+\n+    private String sourceIdentifier;\n+    private String url;\n+    private String apiKey;\n+\n+    private CloseableHttpClient client = null;\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * Initialise the client that we need to call the endpoint\n+     * @throws IOException  If something goes wrong\n+     */\n+    public void init() throws IOException {\n+        HttpClientBuilder builder = HttpClientBuilder.create();\n+        // httpclient 4.3+ doesn't appear to have any sensible defaults any more. Setting conservative defaults as\n+        // not to hammer the SHERPA service too much.\n+        client = builder\n+            .disableAutomaticRetries()\n+            .setMaxConnTotal(5)\n+            .build();\n+    }\n+\n+    /**\n+     * Get a single publisher based on a \"id equals string\" query\n+     * @param id    The publisher ID which will be used as query string\n+     * @return external data object representing publisher\n+     */\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+\n+        HttpGet method = null;\n+        SHERPAPublisherResponse sherpaResponse = null;\n+        int timeout = 5000;\n+        URIBuilder uriBuilder = null;\n+        try {\n+            // Construct URI for an exact match on journal title\n+            uriBuilder = new URIBuilder(url);\n+            uriBuilder.addParameter(\"item-type\", \"publisher\");\n+            uriBuilder.addParameter(\"filter\", \"[[\\\"id\\\",\\\"equals\\\",\\\"\" + id + \"\\\"]]\");\n+            uriBuilder.addParameter(\"format\", \"Json\");\n+            if (StringUtils.isNotBlank(apiKey)) {\n+                uriBuilder.addParameter(\"api-key\", apiKey);\n+            }\n+\n+            // Build HTTP method\n+            method = new HttpGet(uriBuilder.build());\n+            method.setConfig(RequestConfig.custom()\n+                .setConnectionRequestTimeout(timeout)\n+                .setConnectTimeout(timeout)\n+                .setSocketTimeout(timeout)\n+                .build());\n+\n+            // Execute the method\n+            HttpResponse response = client.execute(method);\n+            int statusCode = response.getStatusLine().getStatusCode();\n+\n+            if (statusCode != HttpStatus.SC_OK) {\n+                sherpaResponse = new SHERPAPublisherResponse(\"SHERPA/RoMEO return not OK status: \"\n+                    + statusCode);\n+            }\n+\n+            HttpEntity responseBody = response.getEntity();\n+\n+            // Get InputStream from API response and parse JSON\n+            if (null != responseBody) {\n+                InputStream content = null;\n+                try {\n+                    content = responseBody.getContent();\n+                    sherpaResponse = new SHERPAPublisherResponse(content, SHERPAPublisherResponse.SHERPAFormat.JSON);\n+                } catch (IOException e) {\n+                    log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            } else {\n+                sherpaResponse = new SHERPAPublisherResponse(\"SHERPA/RoMEO returned no response\");\n+            }\n+        } catch (Exception e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+        }\n+\n+        if (sherpaResponse == null) {\n+            sherpaResponse = new SHERPAPublisherResponse(\"Error processing the SHERPA/RoMEO answer\");\n+        }\n+        if (CollectionUtils.isNotEmpty(sherpaResponse.getPublishers())) {\n+            SHERPAPublisher sherpaPublisher = sherpaResponse.getPublishers().get(0);\n+            // Construct external data object from returned publisher\n+            ExternalDataObject externalDataObject = constructExternalDataObjectFromSherpaPublisher(sherpaPublisher);\n+            return Optional.of(externalDataObject);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Search SHERPA v2 API for publisher results based on a 'contains word' query for publisher name\n+     * @param query The query for the search\n+     * @param start The start of the search\n+     * @param limit The max amount of records to be returned by the search\n+     * @return a list of external data objects\n+     */\n+    @Override\n+    public List<ExternalDataObject> searchExternalDataObjects(String query, int start, int limit) {\n+        // query args to add to SHERPA/RoMEO request URL\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query, start, limit);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Get response input stream and parse JSON into new SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAPublisherResponse sherpaResponse =\n+                        new SHERPAPublisherResponse(content, SHERPAPublisherResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getPublishers())) {\n+                        List<ExternalDataObject> list = sherpaResponse.getPublishers().stream().map(\n+                            sherpaPublisher -> constructExternalDataObjectFromSherpaPublisher(sherpaPublisher)).collect(\n+                            Collectors.toList());\n+\n+                        // Unlike the previous API version we can request offset and limit, so no need to build a\n+                        // sublist from this list, we can just return the list.\n+                        return list;\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error parsing SHERPA response input stream: \" + e.getMessage());\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            }\n+        } catch (IOException | URISyntaxException e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+            return null;\n+        } finally {\n+            if (get != null) {\n+                get.releaseConnection();\n+            }\n+        }\n+        return Collections.emptyList();\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"publisher name contains word\" query using default start/limit parameters\n+     * @param query a word or phrase to search for in publisher name\n+     * @return HttpGet method which can then be executed by the client\n+     * @throws URISyntaxException if the URL build fails\n+     */\n+    private HttpGet constructHttpGet(String query) throws URISyntaxException {\n+        return constructHttpGet(query, -1, -1);\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"publisher name contains word\" query\n+     * @param query the search query\n+     * @param start row offset\n+     * @param limit number of results to return\n+     * @return HttpGet object to be executed by the client\n+     * @throws URISyntaxException\n+     */\n+    private HttpGet constructHttpGet(String query, int start, int limit) throws URISyntaxException {\n+        // Build URL based on search query\n+        URIBuilder uriBuilder = new URIBuilder(url);\n+        uriBuilder.addParameter(\"item-type\", \"publisher\");\n+        uriBuilder.addParameter(\"filter\", \"[[\\\"name\\\",\\\"contains word\\\",\\\"\" + query + \"\\\"]]\");\n+        uriBuilder.addParameter(\"format\", \"Json\");\n+        // Set optional start (offset) and limit parameters\n+        if (start >= 0) {\n+            uriBuilder.addParameter(\"offset\", String.valueOf(start));\n+        }\n+        if (limit > 0) {\n+            uriBuilder.addParameter(\"limit\", String.valueOf(limit));\n+        }\n+        if (StringUtils.isNotBlank(apiKey)) {\n+            uriBuilder.addParameter(\"api-key\", apiKey);\n+        }\n+\n+        // Create HTTP GET object\n+        HttpGet method = new HttpGet(uriBuilder.build());\n+\n+        // Set connection parameters\n+        int timeout = 5000;\n+        method.setConfig(RequestConfig.custom()\n+            .setConnectionRequestTimeout(timeout)\n+            .setConnectTimeout(timeout)\n+            .setSocketTimeout(timeout)\n+            .build());\n+        return new HttpGet(uriBuilder.build());\n+    }\n+\n+    private ExternalDataObject constructExternalDataObjectFromSherpaPublisher(SHERPAPublisher sherpaPublisher) {\n+        ExternalDataObject externalDataObject = new ExternalDataObject();\n+        externalDataObject.setSource(sourceIdentifier);\n+\n+        // Set publisher name\n+        if (StringUtils.isNotBlank(sherpaPublisher.getName())) {\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"title\", null, null, sherpaPublisher.getName()));\n+            externalDataObject.setDisplayValue(sherpaPublisher.getName());\n+            externalDataObject.setValue(sherpaPublisher.getName());\n+        }\n+        // Set publisher ID\n+        if (StringUtils.isNotBlank(sherpaPublisher.getIdentifier())) {\n+            externalDataObject.setId(sherpaPublisher.getIdentifier());\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"identifier\", \"sherpaPublisher\", null,\n+                sherpaPublisher.getIdentifier()));\n+        }\n+\n+        // Set home URL\n+        if (StringUtils.isNotBlank(sherpaPublisher.getUri())) {\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"identifier\", \"other\", null, sherpaPublisher.getUri()));\n+        }\n+\n+        return externalDataObject;\n+    }\n+\n+    @Override\n+    public boolean supports(String source) {\n+        return StringUtils.equalsIgnoreCase(sourceIdentifier, source);\n+    }\n+\n+    /**\n+     * Get number of results returned from a SHERPA v2 publication search\n+     * @param query The query to be search on and give the total amount of results\n+     * @return int representing number of publisher results\n+     */\n+    @Override\n+    public int getNumberOfResults(String query) {\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Read response and parse as SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAPublisherResponse sherpaResponse =\n+                        new SHERPAPublisherResponse(content, SHERPAPublisherResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getPublishers())) {\n+                        return sherpaResponse.getPublishers().size();\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error reading input stream for SHERPAResponse: \" + e.getMessage());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4NjIxNg=="}, "originalCommit": null, "originalPosition": 303}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMjEwNjM2OnYy", "diffSide": "RIGHT", "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2JournalDataProvider.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMDo1MjoyNFrOGdsUwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMVQwMjoxNDowM1rOGmpN3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4ODA5Nw==", "bodyText": "I would prefer to get this information directly from the configuration service. Having this internal cache will prevent us to add the apikey later and auto-reload it without restart. Moreover, it makes a bit harder to create an Integration Test", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r433788097", "createdAt": "2020-06-02T10:52:24Z", "author": {"login": "abollini"}, "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2JournalDataProvider.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URISyntaxException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.sherpa.v2.SHERPAJournal;\n+import org.dspace.app.sherpa.v2.SHERPAResponse;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+\n+/**\n+ * This class is the implementation of the ExternalDataProvider interface that will deal with SherpaJournal External\n+ * data lookups.\n+ * This provider is a refactored version of SherpaJournalDataPublisher, rewritten to work with SHERPA v2 API\n+ *\n+ * @author Kim Shepherd\n+ */\n+public class SHERPAv2JournalDataProvider implements ExternalDataProvider {\n+\n+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(SHERPAv2JournalDataProvider.class);\n+\n+    private String url;\n+    private String sourceIdentifier;\n+    private String apiKey;\n+\n+    private CloseableHttpClient client = null;\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * Initialise the client that we need to call the endpoint\n+     * @throws IOException  If something goes wrong\n+     */\n+    public void init() throws IOException {\n+        HttpClientBuilder builder = HttpClientBuilder.create();\n+        // httpclient 4.3+ doesn't appear to have any sensible defaults any more. Setting conservative defaults as\n+        // not to hammer the SHERPA service too much.\n+        client = builder\n+            .disableAutomaticRetries()\n+            .setMaxConnTotal(5)\n+            .build();\n+    }\n+\n+    /**\n+     * Get a single journal based on a \"title equals string\" query\n+     * @param id    The journal title which will be used as query string\n+     * @return external data object representing journal\n+     */\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+\n+        HttpGet method = null;\n+        SHERPAResponse sherpaResponse = null;\n+        int timeout = 5000;\n+        URIBuilder uriBuilder = null;\n+        try {\n+            // Construct URI for an exact match on journal title\n+            uriBuilder = new URIBuilder(url);\n+            uriBuilder.addParameter(\"item-type\", \"publication\");\n+            uriBuilder.addParameter(\"filter\", \"[[\\\"title\\\",\\\"equals\\\",\\\"\" + id + \"\\\"]]\");\n+            uriBuilder.addParameter(\"format\", \"Json\");\n+            if (StringUtils.isNotBlank(apiKey)) {\n+                uriBuilder.addParameter(\"api-key\", apiKey);\n+            }\n+\n+            // Build HTTP method\n+            method = new HttpGet(uriBuilder.build());\n+            method.setConfig(RequestConfig.custom()\n+                                          .setConnectionRequestTimeout(timeout)\n+                                          .setConnectTimeout(timeout)\n+                                          .setSocketTimeout(timeout)\n+                                          .build());\n+\n+            // Execute the method\n+            HttpResponse response = client.execute(method);\n+            int statusCode = response.getStatusLine().getStatusCode();\n+\n+            if (statusCode != HttpStatus.SC_OK) {\n+                sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO return not OK status: \"\n+                                                        + statusCode);\n+            }\n+\n+            HttpEntity responseBody = response.getEntity();\n+\n+            // Get InputStream from API response and parse JSON\n+            if (null != responseBody) {\n+                InputStream content = null;\n+                try {\n+                    content = responseBody.getContent();\n+                    sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                } catch (IOException e) {\n+                    log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            } else {\n+                sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO returned no response\");\n+            }\n+        } catch (Exception e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+        }\n+\n+        if (sherpaResponse == null) {\n+            sherpaResponse = new SHERPAResponse(\n+                \"Error processing the SHERPA/RoMEO answer\");\n+        }\n+        if (CollectionUtils.isNotEmpty(sherpaResponse.getJournals())) {\n+            SHERPAJournal sherpaJournal = sherpaResponse.getJournals().get(0);\n+\n+            ExternalDataObject externalDataObject = constructExternalDataObjectFromSherpaJournal(sherpaJournal);\n+            return Optional.of(externalDataObject);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Construct ExternalDataObject populated with journal metadata from the SHERPA v2 API response\n+     * @param sherpaJournal\n+     * @return external data object representing a journal\n+     */\n+    private ExternalDataObject constructExternalDataObjectFromSherpaJournal(SHERPAJournal sherpaJournal) {\n+        // Set up external object\n+        ExternalDataObject externalDataObject = new ExternalDataObject();\n+        externalDataObject.setSource(sourceIdentifier);\n+        // Set journal title in external object\n+        if (CollectionUtils.isNotEmpty(sherpaJournal.getTitles())) {\n+            String journalTitle = sherpaJournal.getTitles().get(0);\n+            externalDataObject.setId(sherpaJournal.getTitles().get(0));\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"title\", null, null, journalTitle));\n+            externalDataObject.setValue(journalTitle);\n+            externalDataObject.setDisplayValue(journalTitle);\n+        }\n+        // Set ISSNs in external object\n+        if (CollectionUtils.isNotEmpty(sherpaJournal.getIssns())) {\n+            String issn = sherpaJournal.getIssns().get(0);\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                    \"dc\", \"identifier\", \"issn\", null, issn));\n+\n+        }\n+\n+        return externalDataObject;\n+    }\n+\n+    /**\n+     * Search SHERPA v2 API for journal results based on a 'contains word' query\n+     * @param query The query for the search\n+     * @param start The start of the search\n+     * @param limit The max amount of records to be returned by the search\n+     * @return a list of external data objects\n+     */\n+    @Override\n+    public List<ExternalDataObject> searchExternalDataObjects(String query, int start, int limit) {\n+        // query args to add to SHERPA/RoMEO request URL\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query, start, limit);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Get response input stream and parse JSON into new SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAResponse sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getJournals())) {\n+                        List<ExternalDataObject> list = sherpaResponse.getJournals().stream().map(\n+                            sherpaJournal -> constructExternalDataObjectFromSherpaJournal(sherpaJournal)).collect(\n+                            Collectors.toList());\n+\n+                        // Unlike the previous API version we can request offset and limit, so no need to build a\n+                        // sublist from this list, we can just return the list.\n+                        return list;\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error parsing SHERPA response input stream: \" + e.getMessage());\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            }\n+        } catch (IOException | URISyntaxException e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+            return null;\n+        } finally {\n+            if (get != null) {\n+                get.releaseConnection();\n+            }\n+        }\n+        return Collections.emptyList();\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"title contains word\" query using default start/limit parameters\n+     * @param query a word or phrase to search for in journal title\n+     * @return HttpGet method which can then be executed by the client\n+     * @throws URISyntaxException if the URL build fails\n+     */\n+    private HttpGet constructHttpGet(String query) throws URISyntaxException {\n+        return constructHttpGet(query, -1, -1);\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"title contains word\" query\n+     * @param query the search query\n+     * @param start row offset\n+     * @param limit number of results to return\n+     * @return HttpGet object to be executed by the client\n+     * @throws URISyntaxException\n+     */\n+    private HttpGet constructHttpGet(String query, int start, int limit) throws URISyntaxException {\n+        // Build URL based on search query\n+        URIBuilder uriBuilder = new URIBuilder(url);\n+        uriBuilder.addParameter(\"item-type\", \"publication\");\n+        uriBuilder.addParameter(\"filter\", \"[[\\\"title\\\",\\\"contains word\\\",\\\"\" + query + \"\\\"]]\");\n+        uriBuilder.addParameter(\"format\", \"Json\");\n+        // Set optional start (offset) and limit parameters\n+        if (start >= 0) {\n+            uriBuilder.addParameter(\"offset\", String.valueOf(start));\n+        }\n+        if (limit > 0) {\n+            uriBuilder.addParameter(\"limit\", String.valueOf(limit));\n+        }\n+        if (StringUtils.isNotBlank(apiKey)) {\n+            uriBuilder.addParameter(\"api-key\", apiKey);\n+        }\n+\n+        // Create HTTP GET object\n+        HttpGet method = new HttpGet(uriBuilder.build());\n+\n+        // Set connection parameters\n+        int timeout = 5000;\n+        method.setConfig(RequestConfig.custom()\n+            .setConnectionRequestTimeout(timeout)\n+            .setConnectTimeout(timeout)\n+            .setSocketTimeout(timeout)\n+            .build());\n+        return new HttpGet(uriBuilder.build());\n+    }\n+\n+    @Override\n+    public boolean supports(String source) {\n+        return StringUtils.equalsIgnoreCase(sourceIdentifier, source);\n+    }\n+\n+    /**\n+     * Get number of results returned from a SHERPA v2 publication search\n+     * @param query The query to be search on and give the total amount of results\n+     * @return int representing number of journal results\n+     */\n+    @Override\n+    public int getNumberOfResults(String query) {\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Read response and parse as SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAResponse sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getJournals())) {\n+                        return sherpaResponse.getJournals().size();\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error reading input stream for SHERPAResponse: \" + e.getMessage());\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            }\n+        } catch (IOException | URISyntaxException e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+            return 0;\n+        } finally {\n+            if (get != null) {\n+                get.releaseConnection();\n+            }\n+        }\n+        // If other checks have failed return 0\n+        return 0;\n+    }\n+\n+    /**\n+     * Generic setter for the sourceIdentifier\n+     * @param sourceIdentifier   The sourceIdentifier to be set on this SHERPAv2JournalDataProvider\n+     */\n+    public void setSourceIdentifier(String sourceIdentifier) {\n+        this.sourceIdentifier = sourceIdentifier;\n+    }\n+\n+    /**\n+     * Generic getter for the url\n+     * @return the url value of this SherpaJournalDataProvider\n+     */\n+    public String getUrl() {\n+        return url;\n+    }\n+\n+    /**\n+     * Generic setter for the url\n+     * @param url   The url to be set on this SHERPAv2JournalDataProvider\n+     */\n+    public void setUrl(String url) {\n+        this.url = url;\n+    }\n+\n+    /**\n+     * Generic getter for the apiKey\n+     * @return the apiKey value of this SHERPAv2JournalDataProvider\n+     */\n+    public String getApiKey() {\n+        return apiKey;\n+    }\n+\n+    /**\n+     * Generic setter for the apiKey\n+     * @param apiKey   The apiKey to be set on this SHERPAv2JournalDataProvider\n+     */\n+    public void setApiKey(String apiKey) {\n+        this.apiKey = apiKey;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 357}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE3NDM2NQ==", "bodyText": "Done! See commit 6ce9283e\nI also moved URL config for consistency", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r443174365", "createdAt": "2020-06-21T02:14:03Z", "author": {"login": "kshepherd"}, "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2JournalDataProvider.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URISyntaxException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.sherpa.v2.SHERPAJournal;\n+import org.dspace.app.sherpa.v2.SHERPAResponse;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+\n+/**\n+ * This class is the implementation of the ExternalDataProvider interface that will deal with SherpaJournal External\n+ * data lookups.\n+ * This provider is a refactored version of SherpaJournalDataPublisher, rewritten to work with SHERPA v2 API\n+ *\n+ * @author Kim Shepherd\n+ */\n+public class SHERPAv2JournalDataProvider implements ExternalDataProvider {\n+\n+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(SHERPAv2JournalDataProvider.class);\n+\n+    private String url;\n+    private String sourceIdentifier;\n+    private String apiKey;\n+\n+    private CloseableHttpClient client = null;\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * Initialise the client that we need to call the endpoint\n+     * @throws IOException  If something goes wrong\n+     */\n+    public void init() throws IOException {\n+        HttpClientBuilder builder = HttpClientBuilder.create();\n+        // httpclient 4.3+ doesn't appear to have any sensible defaults any more. Setting conservative defaults as\n+        // not to hammer the SHERPA service too much.\n+        client = builder\n+            .disableAutomaticRetries()\n+            .setMaxConnTotal(5)\n+            .build();\n+    }\n+\n+    /**\n+     * Get a single journal based on a \"title equals string\" query\n+     * @param id    The journal title which will be used as query string\n+     * @return external data object representing journal\n+     */\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+\n+        HttpGet method = null;\n+        SHERPAResponse sherpaResponse = null;\n+        int timeout = 5000;\n+        URIBuilder uriBuilder = null;\n+        try {\n+            // Construct URI for an exact match on journal title\n+            uriBuilder = new URIBuilder(url);\n+            uriBuilder.addParameter(\"item-type\", \"publication\");\n+            uriBuilder.addParameter(\"filter\", \"[[\\\"title\\\",\\\"equals\\\",\\\"\" + id + \"\\\"]]\");\n+            uriBuilder.addParameter(\"format\", \"Json\");\n+            if (StringUtils.isNotBlank(apiKey)) {\n+                uriBuilder.addParameter(\"api-key\", apiKey);\n+            }\n+\n+            // Build HTTP method\n+            method = new HttpGet(uriBuilder.build());\n+            method.setConfig(RequestConfig.custom()\n+                                          .setConnectionRequestTimeout(timeout)\n+                                          .setConnectTimeout(timeout)\n+                                          .setSocketTimeout(timeout)\n+                                          .build());\n+\n+            // Execute the method\n+            HttpResponse response = client.execute(method);\n+            int statusCode = response.getStatusLine().getStatusCode();\n+\n+            if (statusCode != HttpStatus.SC_OK) {\n+                sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO return not OK status: \"\n+                                                        + statusCode);\n+            }\n+\n+            HttpEntity responseBody = response.getEntity();\n+\n+            // Get InputStream from API response and parse JSON\n+            if (null != responseBody) {\n+                InputStream content = null;\n+                try {\n+                    content = responseBody.getContent();\n+                    sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                } catch (IOException e) {\n+                    log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            } else {\n+                sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO returned no response\");\n+            }\n+        } catch (Exception e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+        }\n+\n+        if (sherpaResponse == null) {\n+            sherpaResponse = new SHERPAResponse(\n+                \"Error processing the SHERPA/RoMEO answer\");\n+        }\n+        if (CollectionUtils.isNotEmpty(sherpaResponse.getJournals())) {\n+            SHERPAJournal sherpaJournal = sherpaResponse.getJournals().get(0);\n+\n+            ExternalDataObject externalDataObject = constructExternalDataObjectFromSherpaJournal(sherpaJournal);\n+            return Optional.of(externalDataObject);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Construct ExternalDataObject populated with journal metadata from the SHERPA v2 API response\n+     * @param sherpaJournal\n+     * @return external data object representing a journal\n+     */\n+    private ExternalDataObject constructExternalDataObjectFromSherpaJournal(SHERPAJournal sherpaJournal) {\n+        // Set up external object\n+        ExternalDataObject externalDataObject = new ExternalDataObject();\n+        externalDataObject.setSource(sourceIdentifier);\n+        // Set journal title in external object\n+        if (CollectionUtils.isNotEmpty(sherpaJournal.getTitles())) {\n+            String journalTitle = sherpaJournal.getTitles().get(0);\n+            externalDataObject.setId(sherpaJournal.getTitles().get(0));\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"title\", null, null, journalTitle));\n+            externalDataObject.setValue(journalTitle);\n+            externalDataObject.setDisplayValue(journalTitle);\n+        }\n+        // Set ISSNs in external object\n+        if (CollectionUtils.isNotEmpty(sherpaJournal.getIssns())) {\n+            String issn = sherpaJournal.getIssns().get(0);\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                    \"dc\", \"identifier\", \"issn\", null, issn));\n+\n+        }\n+\n+        return externalDataObject;\n+    }\n+\n+    /**\n+     * Search SHERPA v2 API for journal results based on a 'contains word' query\n+     * @param query The query for the search\n+     * @param start The start of the search\n+     * @param limit The max amount of records to be returned by the search\n+     * @return a list of external data objects\n+     */\n+    @Override\n+    public List<ExternalDataObject> searchExternalDataObjects(String query, int start, int limit) {\n+        // query args to add to SHERPA/RoMEO request URL\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query, start, limit);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Get response input stream and parse JSON into new SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAResponse sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getJournals())) {\n+                        List<ExternalDataObject> list = sherpaResponse.getJournals().stream().map(\n+                            sherpaJournal -> constructExternalDataObjectFromSherpaJournal(sherpaJournal)).collect(\n+                            Collectors.toList());\n+\n+                        // Unlike the previous API version we can request offset and limit, so no need to build a\n+                        // sublist from this list, we can just return the list.\n+                        return list;\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error parsing SHERPA response input stream: \" + e.getMessage());\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            }\n+        } catch (IOException | URISyntaxException e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+            return null;\n+        } finally {\n+            if (get != null) {\n+                get.releaseConnection();\n+            }\n+        }\n+        return Collections.emptyList();\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"title contains word\" query using default start/limit parameters\n+     * @param query a word or phrase to search for in journal title\n+     * @return HttpGet method which can then be executed by the client\n+     * @throws URISyntaxException if the URL build fails\n+     */\n+    private HttpGet constructHttpGet(String query) throws URISyntaxException {\n+        return constructHttpGet(query, -1, -1);\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"title contains word\" query\n+     * @param query the search query\n+     * @param start row offset\n+     * @param limit number of results to return\n+     * @return HttpGet object to be executed by the client\n+     * @throws URISyntaxException\n+     */\n+    private HttpGet constructHttpGet(String query, int start, int limit) throws URISyntaxException {\n+        // Build URL based on search query\n+        URIBuilder uriBuilder = new URIBuilder(url);\n+        uriBuilder.addParameter(\"item-type\", \"publication\");\n+        uriBuilder.addParameter(\"filter\", \"[[\\\"title\\\",\\\"contains word\\\",\\\"\" + query + \"\\\"]]\");\n+        uriBuilder.addParameter(\"format\", \"Json\");\n+        // Set optional start (offset) and limit parameters\n+        if (start >= 0) {\n+            uriBuilder.addParameter(\"offset\", String.valueOf(start));\n+        }\n+        if (limit > 0) {\n+            uriBuilder.addParameter(\"limit\", String.valueOf(limit));\n+        }\n+        if (StringUtils.isNotBlank(apiKey)) {\n+            uriBuilder.addParameter(\"api-key\", apiKey);\n+        }\n+\n+        // Create HTTP GET object\n+        HttpGet method = new HttpGet(uriBuilder.build());\n+\n+        // Set connection parameters\n+        int timeout = 5000;\n+        method.setConfig(RequestConfig.custom()\n+            .setConnectionRequestTimeout(timeout)\n+            .setConnectTimeout(timeout)\n+            .setSocketTimeout(timeout)\n+            .build());\n+        return new HttpGet(uriBuilder.build());\n+    }\n+\n+    @Override\n+    public boolean supports(String source) {\n+        return StringUtils.equalsIgnoreCase(sourceIdentifier, source);\n+    }\n+\n+    /**\n+     * Get number of results returned from a SHERPA v2 publication search\n+     * @param query The query to be search on and give the total amount of results\n+     * @return int representing number of journal results\n+     */\n+    @Override\n+    public int getNumberOfResults(String query) {\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Read response and parse as SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAResponse sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getJournals())) {\n+                        return sherpaResponse.getJournals().size();\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error reading input stream for SHERPAResponse: \" + e.getMessage());\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            }\n+        } catch (IOException | URISyntaxException e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+            return 0;\n+        } finally {\n+            if (get != null) {\n+                get.releaseConnection();\n+            }\n+        }\n+        // If other checks have failed return 0\n+        return 0;\n+    }\n+\n+    /**\n+     * Generic setter for the sourceIdentifier\n+     * @param sourceIdentifier   The sourceIdentifier to be set on this SHERPAv2JournalDataProvider\n+     */\n+    public void setSourceIdentifier(String sourceIdentifier) {\n+        this.sourceIdentifier = sourceIdentifier;\n+    }\n+\n+    /**\n+     * Generic getter for the url\n+     * @return the url value of this SherpaJournalDataProvider\n+     */\n+    public String getUrl() {\n+        return url;\n+    }\n+\n+    /**\n+     * Generic setter for the url\n+     * @param url   The url to be set on this SHERPAv2JournalDataProvider\n+     */\n+    public void setUrl(String url) {\n+        this.url = url;\n+    }\n+\n+    /**\n+     * Generic getter for the apiKey\n+     * @return the apiKey value of this SHERPAv2JournalDataProvider\n+     */\n+    public String getApiKey() {\n+        return apiKey;\n+    }\n+\n+    /**\n+     * Generic setter for the apiKey\n+     * @param apiKey   The apiKey to be set on this SHERPAv2JournalDataProvider\n+     */\n+    public void setApiKey(String apiKey) {\n+        this.apiKey = apiKey;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4ODA5Nw=="}, "originalCommit": null, "originalPosition": 357}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMjEwODA0OnYy", "diffSide": "RIGHT", "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2PublisherDataProvider.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMDo1MzowMVrOGdsV3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMVQwMjoxMzo1N1rOGmpN2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4ODM4MA==", "bodyText": "I would prefer to get this information directly from the configuration service. Having this internal cache will prevent us to add the apikey later and auto-reload it without restart. Moreover, it makes a bit harder to create an Integration Test", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r433788380", "createdAt": "2020-06-02T10:53:01Z", "author": {"login": "abollini"}, "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2PublisherDataProvider.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URISyntaxException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.sherpa.v2.SHERPAPublisher;\n+import org.dspace.app.sherpa.v2.SHERPAPublisherResponse;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+\n+/**\n+ * This class is the implementation of the ExternalDataProvider interface that will deal with SHERPAPublisher External\n+ * data lookups.\n+ * This provider is a refactored version of SherpaPublisherDataPublisher, rewritten to work with SHERPA v2 API\n+ *\n+ * It uses a more simple response object than the normal publication / policy search\n+ *\n+ * @author Kim Shepherd\n+ */\n+public class SHERPAv2PublisherDataProvider implements ExternalDataProvider {\n+\n+    private static final Logger log =\n+        org.apache.logging.log4j.LogManager.getLogger(SHERPAv2PublisherDataProvider.class);\n+\n+    private String sourceIdentifier;\n+    private String url;\n+    private String apiKey;\n+\n+    private CloseableHttpClient client = null;\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * Initialise the client that we need to call the endpoint\n+     * @throws IOException  If something goes wrong\n+     */\n+    public void init() throws IOException {\n+        HttpClientBuilder builder = HttpClientBuilder.create();\n+        // httpclient 4.3+ doesn't appear to have any sensible defaults any more. Setting conservative defaults as\n+        // not to hammer the SHERPA service too much.\n+        client = builder\n+            .disableAutomaticRetries()\n+            .setMaxConnTotal(5)\n+            .build();\n+    }\n+\n+    /**\n+     * Get a single publisher based on a \"id equals string\" query\n+     * @param id    The publisher ID which will be used as query string\n+     * @return external data object representing publisher\n+     */\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+\n+        HttpGet method = null;\n+        SHERPAPublisherResponse sherpaResponse = null;\n+        int timeout = 5000;\n+        URIBuilder uriBuilder = null;\n+        try {\n+            // Construct URI for an exact match on journal title\n+            uriBuilder = new URIBuilder(url);\n+            uriBuilder.addParameter(\"item-type\", \"publisher\");\n+            uriBuilder.addParameter(\"filter\", \"[[\\\"id\\\",\\\"equals\\\",\\\"\" + id + \"\\\"]]\");\n+            uriBuilder.addParameter(\"format\", \"Json\");\n+            if (StringUtils.isNotBlank(apiKey)) {\n+                uriBuilder.addParameter(\"api-key\", apiKey);\n+            }\n+\n+            // Build HTTP method\n+            method = new HttpGet(uriBuilder.build());\n+            method.setConfig(RequestConfig.custom()\n+                .setConnectionRequestTimeout(timeout)\n+                .setConnectTimeout(timeout)\n+                .setSocketTimeout(timeout)\n+                .build());\n+\n+            // Execute the method\n+            HttpResponse response = client.execute(method);\n+            int statusCode = response.getStatusLine().getStatusCode();\n+\n+            if (statusCode != HttpStatus.SC_OK) {\n+                sherpaResponse = new SHERPAPublisherResponse(\"SHERPA/RoMEO return not OK status: \"\n+                    + statusCode);\n+            }\n+\n+            HttpEntity responseBody = response.getEntity();\n+\n+            // Get InputStream from API response and parse JSON\n+            if (null != responseBody) {\n+                InputStream content = null;\n+                try {\n+                    content = responseBody.getContent();\n+                    sherpaResponse = new SHERPAPublisherResponse(content, SHERPAPublisherResponse.SHERPAFormat.JSON);\n+                } catch (IOException e) {\n+                    log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            } else {\n+                sherpaResponse = new SHERPAPublisherResponse(\"SHERPA/RoMEO returned no response\");\n+            }\n+        } catch (Exception e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+        }\n+\n+        if (sherpaResponse == null) {\n+            sherpaResponse = new SHERPAPublisherResponse(\"Error processing the SHERPA/RoMEO answer\");\n+        }\n+        if (CollectionUtils.isNotEmpty(sherpaResponse.getPublishers())) {\n+            SHERPAPublisher sherpaPublisher = sherpaResponse.getPublishers().get(0);\n+            // Construct external data object from returned publisher\n+            ExternalDataObject externalDataObject = constructExternalDataObjectFromSherpaPublisher(sherpaPublisher);\n+            return Optional.of(externalDataObject);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Search SHERPA v2 API for publisher results based on a 'contains word' query for publisher name\n+     * @param query The query for the search\n+     * @param start The start of the search\n+     * @param limit The max amount of records to be returned by the search\n+     * @return a list of external data objects\n+     */\n+    @Override\n+    public List<ExternalDataObject> searchExternalDataObjects(String query, int start, int limit) {\n+        // query args to add to SHERPA/RoMEO request URL\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query, start, limit);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Get response input stream and parse JSON into new SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAPublisherResponse sherpaResponse =\n+                        new SHERPAPublisherResponse(content, SHERPAPublisherResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getPublishers())) {\n+                        List<ExternalDataObject> list = sherpaResponse.getPublishers().stream().map(\n+                            sherpaPublisher -> constructExternalDataObjectFromSherpaPublisher(sherpaPublisher)).collect(\n+                            Collectors.toList());\n+\n+                        // Unlike the previous API version we can request offset and limit, so no need to build a\n+                        // sublist from this list, we can just return the list.\n+                        return list;\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error parsing SHERPA response input stream: \" + e.getMessage());\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            }\n+        } catch (IOException | URISyntaxException e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+            return null;\n+        } finally {\n+            if (get != null) {\n+                get.releaseConnection();\n+            }\n+        }\n+        return Collections.emptyList();\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"publisher name contains word\" query using default start/limit parameters\n+     * @param query a word or phrase to search for in publisher name\n+     * @return HttpGet method which can then be executed by the client\n+     * @throws URISyntaxException if the URL build fails\n+     */\n+    private HttpGet constructHttpGet(String query) throws URISyntaxException {\n+        return constructHttpGet(query, -1, -1);\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"publisher name contains word\" query\n+     * @param query the search query\n+     * @param start row offset\n+     * @param limit number of results to return\n+     * @return HttpGet object to be executed by the client\n+     * @throws URISyntaxException\n+     */\n+    private HttpGet constructHttpGet(String query, int start, int limit) throws URISyntaxException {\n+        // Build URL based on search query\n+        URIBuilder uriBuilder = new URIBuilder(url);\n+        uriBuilder.addParameter(\"item-type\", \"publisher\");\n+        uriBuilder.addParameter(\"filter\", \"[[\\\"name\\\",\\\"contains word\\\",\\\"\" + query + \"\\\"]]\");\n+        uriBuilder.addParameter(\"format\", \"Json\");\n+        // Set optional start (offset) and limit parameters\n+        if (start >= 0) {\n+            uriBuilder.addParameter(\"offset\", String.valueOf(start));\n+        }\n+        if (limit > 0) {\n+            uriBuilder.addParameter(\"limit\", String.valueOf(limit));\n+        }\n+        if (StringUtils.isNotBlank(apiKey)) {\n+            uriBuilder.addParameter(\"api-key\", apiKey);\n+        }\n+\n+        // Create HTTP GET object\n+        HttpGet method = new HttpGet(uriBuilder.build());\n+\n+        // Set connection parameters\n+        int timeout = 5000;\n+        method.setConfig(RequestConfig.custom()\n+            .setConnectionRequestTimeout(timeout)\n+            .setConnectTimeout(timeout)\n+            .setSocketTimeout(timeout)\n+            .build());\n+        return new HttpGet(uriBuilder.build());\n+    }\n+\n+    private ExternalDataObject constructExternalDataObjectFromSherpaPublisher(SHERPAPublisher sherpaPublisher) {\n+        ExternalDataObject externalDataObject = new ExternalDataObject();\n+        externalDataObject.setSource(sourceIdentifier);\n+\n+        // Set publisher name\n+        if (StringUtils.isNotBlank(sherpaPublisher.getName())) {\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"title\", null, null, sherpaPublisher.getName()));\n+            externalDataObject.setDisplayValue(sherpaPublisher.getName());\n+            externalDataObject.setValue(sherpaPublisher.getName());\n+        }\n+        // Set publisher ID\n+        if (StringUtils.isNotBlank(sherpaPublisher.getIdentifier())) {\n+            externalDataObject.setId(sherpaPublisher.getIdentifier());\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"identifier\", \"sherpaPublisher\", null,\n+                sherpaPublisher.getIdentifier()));\n+        }\n+\n+        // Set home URL\n+        if (StringUtils.isNotBlank(sherpaPublisher.getUri())) {\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"identifier\", \"other\", null, sherpaPublisher.getUri()));\n+        }\n+\n+        return externalDataObject;\n+    }\n+\n+    @Override\n+    public boolean supports(String source) {\n+        return StringUtils.equalsIgnoreCase(sourceIdentifier, source);\n+    }\n+\n+    /**\n+     * Get number of results returned from a SHERPA v2 publication search\n+     * @param query The query to be search on and give the total amount of results\n+     * @return int representing number of publisher results\n+     */\n+    @Override\n+    public int getNumberOfResults(String query) {\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Read response and parse as SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAPublisherResponse sherpaResponse =\n+                        new SHERPAPublisherResponse(content, SHERPAPublisherResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getPublishers())) {\n+                        return sherpaResponse.getPublishers().size();\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error reading input stream for SHERPAResponse: \" + e.getMessage());\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            }\n+        } catch (IOException | URISyntaxException e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+            return 0;\n+        } finally {\n+            if (get != null) {\n+                get.releaseConnection();\n+            }\n+        }\n+        // If other checks have failed return 0\n+        return 0;\n+    }\n+\n+    /**\n+     * Generic setter for the sourceIdentifier\n+     * @param sourceIdentifier   The sourceIdentifier to be set on this SHERPAv2PublisherDataProvider\n+     */\n+    public void setSourceIdentifier(String sourceIdentifier) {\n+        this.sourceIdentifier = sourceIdentifier;\n+    }\n+\n+    /**\n+     * Generic getter for the url\n+     * @return the url value of this SHERPAv2PublisherDataProvider\n+     */\n+    public String getUrl() {\n+        return url;\n+    }\n+\n+    /**\n+     * Generic setter for the url\n+     * @param url   The url to be set on this SHERPAv2PublisherDataProvider\n+     */\n+    public void setUrl(String url) {\n+        this.url = url;\n+    }\n+\n+    /**\n+     * Generic getter for the apiKey\n+     * @return the apiKey value of this SHERPAv2PublisherDataProvider\n+     */\n+    public String getApiKey() {\n+        return apiKey;\n+    }\n+\n+    /**\n+     * Generic setter for the apiKey\n+     * @param apiKey   The apiKey to be set on this SHERPAv2PublisherDataProvider\n+     */\n+    public void setApiKey(String apiKey) {\n+        this.apiKey = apiKey;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 360}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE3NDM2Mg==", "bodyText": "Done! See commit 6ce9283e\nI also moved URL config for consistency", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r443174362", "createdAt": "2020-06-21T02:13:57Z", "author": {"login": "kshepherd"}, "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2PublisherDataProvider.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URISyntaxException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.sherpa.v2.SHERPAPublisher;\n+import org.dspace.app.sherpa.v2.SHERPAPublisherResponse;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+\n+/**\n+ * This class is the implementation of the ExternalDataProvider interface that will deal with SHERPAPublisher External\n+ * data lookups.\n+ * This provider is a refactored version of SherpaPublisherDataPublisher, rewritten to work with SHERPA v2 API\n+ *\n+ * It uses a more simple response object than the normal publication / policy search\n+ *\n+ * @author Kim Shepherd\n+ */\n+public class SHERPAv2PublisherDataProvider implements ExternalDataProvider {\n+\n+    private static final Logger log =\n+        org.apache.logging.log4j.LogManager.getLogger(SHERPAv2PublisherDataProvider.class);\n+\n+    private String sourceIdentifier;\n+    private String url;\n+    private String apiKey;\n+\n+    private CloseableHttpClient client = null;\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * Initialise the client that we need to call the endpoint\n+     * @throws IOException  If something goes wrong\n+     */\n+    public void init() throws IOException {\n+        HttpClientBuilder builder = HttpClientBuilder.create();\n+        // httpclient 4.3+ doesn't appear to have any sensible defaults any more. Setting conservative defaults as\n+        // not to hammer the SHERPA service too much.\n+        client = builder\n+            .disableAutomaticRetries()\n+            .setMaxConnTotal(5)\n+            .build();\n+    }\n+\n+    /**\n+     * Get a single publisher based on a \"id equals string\" query\n+     * @param id    The publisher ID which will be used as query string\n+     * @return external data object representing publisher\n+     */\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+\n+        HttpGet method = null;\n+        SHERPAPublisherResponse sherpaResponse = null;\n+        int timeout = 5000;\n+        URIBuilder uriBuilder = null;\n+        try {\n+            // Construct URI for an exact match on journal title\n+            uriBuilder = new URIBuilder(url);\n+            uriBuilder.addParameter(\"item-type\", \"publisher\");\n+            uriBuilder.addParameter(\"filter\", \"[[\\\"id\\\",\\\"equals\\\",\\\"\" + id + \"\\\"]]\");\n+            uriBuilder.addParameter(\"format\", \"Json\");\n+            if (StringUtils.isNotBlank(apiKey)) {\n+                uriBuilder.addParameter(\"api-key\", apiKey);\n+            }\n+\n+            // Build HTTP method\n+            method = new HttpGet(uriBuilder.build());\n+            method.setConfig(RequestConfig.custom()\n+                .setConnectionRequestTimeout(timeout)\n+                .setConnectTimeout(timeout)\n+                .setSocketTimeout(timeout)\n+                .build());\n+\n+            // Execute the method\n+            HttpResponse response = client.execute(method);\n+            int statusCode = response.getStatusLine().getStatusCode();\n+\n+            if (statusCode != HttpStatus.SC_OK) {\n+                sherpaResponse = new SHERPAPublisherResponse(\"SHERPA/RoMEO return not OK status: \"\n+                    + statusCode);\n+            }\n+\n+            HttpEntity responseBody = response.getEntity();\n+\n+            // Get InputStream from API response and parse JSON\n+            if (null != responseBody) {\n+                InputStream content = null;\n+                try {\n+                    content = responseBody.getContent();\n+                    sherpaResponse = new SHERPAPublisherResponse(content, SHERPAPublisherResponse.SHERPAFormat.JSON);\n+                } catch (IOException e) {\n+                    log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            } else {\n+                sherpaResponse = new SHERPAPublisherResponse(\"SHERPA/RoMEO returned no response\");\n+            }\n+        } catch (Exception e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+        }\n+\n+        if (sherpaResponse == null) {\n+            sherpaResponse = new SHERPAPublisherResponse(\"Error processing the SHERPA/RoMEO answer\");\n+        }\n+        if (CollectionUtils.isNotEmpty(sherpaResponse.getPublishers())) {\n+            SHERPAPublisher sherpaPublisher = sherpaResponse.getPublishers().get(0);\n+            // Construct external data object from returned publisher\n+            ExternalDataObject externalDataObject = constructExternalDataObjectFromSherpaPublisher(sherpaPublisher);\n+            return Optional.of(externalDataObject);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Search SHERPA v2 API for publisher results based on a 'contains word' query for publisher name\n+     * @param query The query for the search\n+     * @param start The start of the search\n+     * @param limit The max amount of records to be returned by the search\n+     * @return a list of external data objects\n+     */\n+    @Override\n+    public List<ExternalDataObject> searchExternalDataObjects(String query, int start, int limit) {\n+        // query args to add to SHERPA/RoMEO request URL\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query, start, limit);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Get response input stream and parse JSON into new SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAPublisherResponse sherpaResponse =\n+                        new SHERPAPublisherResponse(content, SHERPAPublisherResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getPublishers())) {\n+                        List<ExternalDataObject> list = sherpaResponse.getPublishers().stream().map(\n+                            sherpaPublisher -> constructExternalDataObjectFromSherpaPublisher(sherpaPublisher)).collect(\n+                            Collectors.toList());\n+\n+                        // Unlike the previous API version we can request offset and limit, so no need to build a\n+                        // sublist from this list, we can just return the list.\n+                        return list;\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error parsing SHERPA response input stream: \" + e.getMessage());\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            }\n+        } catch (IOException | URISyntaxException e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+            return null;\n+        } finally {\n+            if (get != null) {\n+                get.releaseConnection();\n+            }\n+        }\n+        return Collections.emptyList();\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"publisher name contains word\" query using default start/limit parameters\n+     * @param query a word or phrase to search for in publisher name\n+     * @return HttpGet method which can then be executed by the client\n+     * @throws URISyntaxException if the URL build fails\n+     */\n+    private HttpGet constructHttpGet(String query) throws URISyntaxException {\n+        return constructHttpGet(query, -1, -1);\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"publisher name contains word\" query\n+     * @param query the search query\n+     * @param start row offset\n+     * @param limit number of results to return\n+     * @return HttpGet object to be executed by the client\n+     * @throws URISyntaxException\n+     */\n+    private HttpGet constructHttpGet(String query, int start, int limit) throws URISyntaxException {\n+        // Build URL based on search query\n+        URIBuilder uriBuilder = new URIBuilder(url);\n+        uriBuilder.addParameter(\"item-type\", \"publisher\");\n+        uriBuilder.addParameter(\"filter\", \"[[\\\"name\\\",\\\"contains word\\\",\\\"\" + query + \"\\\"]]\");\n+        uriBuilder.addParameter(\"format\", \"Json\");\n+        // Set optional start (offset) and limit parameters\n+        if (start >= 0) {\n+            uriBuilder.addParameter(\"offset\", String.valueOf(start));\n+        }\n+        if (limit > 0) {\n+            uriBuilder.addParameter(\"limit\", String.valueOf(limit));\n+        }\n+        if (StringUtils.isNotBlank(apiKey)) {\n+            uriBuilder.addParameter(\"api-key\", apiKey);\n+        }\n+\n+        // Create HTTP GET object\n+        HttpGet method = new HttpGet(uriBuilder.build());\n+\n+        // Set connection parameters\n+        int timeout = 5000;\n+        method.setConfig(RequestConfig.custom()\n+            .setConnectionRequestTimeout(timeout)\n+            .setConnectTimeout(timeout)\n+            .setSocketTimeout(timeout)\n+            .build());\n+        return new HttpGet(uriBuilder.build());\n+    }\n+\n+    private ExternalDataObject constructExternalDataObjectFromSherpaPublisher(SHERPAPublisher sherpaPublisher) {\n+        ExternalDataObject externalDataObject = new ExternalDataObject();\n+        externalDataObject.setSource(sourceIdentifier);\n+\n+        // Set publisher name\n+        if (StringUtils.isNotBlank(sherpaPublisher.getName())) {\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"title\", null, null, sherpaPublisher.getName()));\n+            externalDataObject.setDisplayValue(sherpaPublisher.getName());\n+            externalDataObject.setValue(sherpaPublisher.getName());\n+        }\n+        // Set publisher ID\n+        if (StringUtils.isNotBlank(sherpaPublisher.getIdentifier())) {\n+            externalDataObject.setId(sherpaPublisher.getIdentifier());\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"identifier\", \"sherpaPublisher\", null,\n+                sherpaPublisher.getIdentifier()));\n+        }\n+\n+        // Set home URL\n+        if (StringUtils.isNotBlank(sherpaPublisher.getUri())) {\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"identifier\", \"other\", null, sherpaPublisher.getUri()));\n+        }\n+\n+        return externalDataObject;\n+    }\n+\n+    @Override\n+    public boolean supports(String source) {\n+        return StringUtils.equalsIgnoreCase(sourceIdentifier, source);\n+    }\n+\n+    /**\n+     * Get number of results returned from a SHERPA v2 publication search\n+     * @param query The query to be search on and give the total amount of results\n+     * @return int representing number of publisher results\n+     */\n+    @Override\n+    public int getNumberOfResults(String query) {\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Read response and parse as SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAPublisherResponse sherpaResponse =\n+                        new SHERPAPublisherResponse(content, SHERPAPublisherResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getPublishers())) {\n+                        return sherpaResponse.getPublishers().size();\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error reading input stream for SHERPAResponse: \" + e.getMessage());\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            }\n+        } catch (IOException | URISyntaxException e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+            return 0;\n+        } finally {\n+            if (get != null) {\n+                get.releaseConnection();\n+            }\n+        }\n+        // If other checks have failed return 0\n+        return 0;\n+    }\n+\n+    /**\n+     * Generic setter for the sourceIdentifier\n+     * @param sourceIdentifier   The sourceIdentifier to be set on this SHERPAv2PublisherDataProvider\n+     */\n+    public void setSourceIdentifier(String sourceIdentifier) {\n+        this.sourceIdentifier = sourceIdentifier;\n+    }\n+\n+    /**\n+     * Generic getter for the url\n+     * @return the url value of this SHERPAv2PublisherDataProvider\n+     */\n+    public String getUrl() {\n+        return url;\n+    }\n+\n+    /**\n+     * Generic setter for the url\n+     * @param url   The url to be set on this SHERPAv2PublisherDataProvider\n+     */\n+    public void setUrl(String url) {\n+        this.url = url;\n+    }\n+\n+    /**\n+     * Generic getter for the apiKey\n+     * @return the apiKey value of this SHERPAv2PublisherDataProvider\n+     */\n+    public String getApiKey() {\n+        return apiKey;\n+    }\n+\n+    /**\n+     * Generic setter for the apiKey\n+     * @param apiKey   The apiKey to be set on this SHERPAv2PublisherDataProvider\n+     */\n+    public void setApiKey(String apiKey) {\n+        this.apiKey = apiKey;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4ODM4MA=="}, "originalCommit": null, "originalPosition": 360}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNDcwMjU5OnYy", "diffSide": "RIGHT", "path": "dspace-api/src/main/java/org/dspace/app/sherpa/submit/SHERPASubmitService.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMjoyMzoyNVrOGhGxPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMzoyNjozOVrOHIQTHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM2NzEwMg==", "bodyText": "Did the lookup \"fail\", it could be that there are no responses ?", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r437367102", "createdAt": "2020-06-09T12:23:25Z", "author": {"login": "KevinVdV"}, "path": "dspace-api/src/main/java/org/dspace/app/sherpa/submit/SHERPASubmitService.java", "diffHunk": "@@ -37,12 +38,28 @@ public void setSherpaService(SHERPAService sherpaService) {\n         this.sherpaService = sherpaService;\n     }\n \n-    public SHERPAResponse searchRelatedJournals(Context context, Item item) {\n+    public List<SHERPAResponse> searchRelatedJournals(Context context, Item item) {\n         Set<String> issns = getISSNs(context, item);\n         if (issns == null || issns.size() == 0) {\n             return null;\n         } else {\n-            return sherpaService.searchByJournalISSN(StringUtils.join(issns, \",\"));\n+            // SHERPA v2 API no longer supports \"OR'd\" ISSN search, perform individual searches instead\n+            Iterator<String> issnIterator = issns.iterator();\n+            List<SHERPAResponse> responses = new LinkedList<>();\n+            while (issnIterator.hasNext()) {\n+                String issn = issnIterator.next();\n+                SHERPAResponse response = sherpaService.searchByJournalISSN(issn);\n+                if (response.isError()) {\n+                    // Continue with loop\n+                    log.warn(\"Failed to look up SHERPA ROMeO result for ISSN: \" + issn);\n+                }\n+                // Store this response, even if it has an error (useful for UI reporting)\n+                responses.add(response);\n+            }\n+            if (responses.isEmpty()) {\n+                responses.add(new SHERPAResponse(\"SHERPA ROMeO lookup failed\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE3OTQzOA==", "bodyText": "This is a true \"failure\" in the sense of an unexpected error. In this case \"responses\" is a linked list of each individual SHERPAResponse objects, not the list of items included in the JSON response. (because we're chaining some queries for multiple ISSNs).\nEven an \"empty\" API response should still be represented in a valid SHERPAResponse object.", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r443179438", "createdAt": "2020-06-21T04:06:19Z", "author": {"login": "kshepherd"}, "path": "dspace-api/src/main/java/org/dspace/app/sherpa/submit/SHERPASubmitService.java", "diffHunk": "@@ -37,12 +38,28 @@ public void setSherpaService(SHERPAService sherpaService) {\n         this.sherpaService = sherpaService;\n     }\n \n-    public SHERPAResponse searchRelatedJournals(Context context, Item item) {\n+    public List<SHERPAResponse> searchRelatedJournals(Context context, Item item) {\n         Set<String> issns = getISSNs(context, item);\n         if (issns == null || issns.size() == 0) {\n             return null;\n         } else {\n-            return sherpaService.searchByJournalISSN(StringUtils.join(issns, \",\"));\n+            // SHERPA v2 API no longer supports \"OR'd\" ISSN search, perform individual searches instead\n+            Iterator<String> issnIterator = issns.iterator();\n+            List<SHERPAResponse> responses = new LinkedList<>();\n+            while (issnIterator.hasNext()) {\n+                String issn = issnIterator.next();\n+                SHERPAResponse response = sherpaService.searchByJournalISSN(issn);\n+                if (response.isError()) {\n+                    // Continue with loop\n+                    log.warn(\"Failed to look up SHERPA ROMeO result for ISSN: \" + issn);\n+                }\n+                // Store this response, even if it has an error (useful for UI reporting)\n+                responses.add(response);\n+            }\n+            if (responses.isEmpty()) {\n+                responses.add(new SHERPAResponse(\"SHERPA ROMeO lookup failed\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM2NzEwMg=="}, "originalCommit": null, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQxNzY5Mg==", "bodyText": "You are correct, resolving.", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r478417692", "createdAt": "2020-08-27T13:26:39Z", "author": {"login": "KevinVdV"}, "path": "dspace-api/src/main/java/org/dspace/app/sherpa/submit/SHERPASubmitService.java", "diffHunk": "@@ -37,12 +38,28 @@ public void setSherpaService(SHERPAService sherpaService) {\n         this.sherpaService = sherpaService;\n     }\n \n-    public SHERPAResponse searchRelatedJournals(Context context, Item item) {\n+    public List<SHERPAResponse> searchRelatedJournals(Context context, Item item) {\n         Set<String> issns = getISSNs(context, item);\n         if (issns == null || issns.size() == 0) {\n             return null;\n         } else {\n-            return sherpaService.searchByJournalISSN(StringUtils.join(issns, \",\"));\n+            // SHERPA v2 API no longer supports \"OR'd\" ISSN search, perform individual searches instead\n+            Iterator<String> issnIterator = issns.iterator();\n+            List<SHERPAResponse> responses = new LinkedList<>();\n+            while (issnIterator.hasNext()) {\n+                String issn = issnIterator.next();\n+                SHERPAResponse response = sherpaService.searchByJournalISSN(issn);\n+                if (response.isError()) {\n+                    // Continue with loop\n+                    log.warn(\"Failed to look up SHERPA ROMeO result for ISSN: \" + issn);\n+                }\n+                // Store this response, even if it has an error (useful for UI reporting)\n+                responses.add(response);\n+            }\n+            if (responses.isEmpty()) {\n+                responses.add(new SHERPAResponse(\"SHERPA ROMeO lookup failed\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM2NzEwMg=="}, "originalCommit": null, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNDcwNDUwOnYy", "diffSide": "RIGHT", "path": "dspace-api/src/main/java/org/dspace/app/sherpa/submit/SHERPASubmitService.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMjoyMzo0M1rOGhGyUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMzoyNzoxMlrOHIQUdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM2NzM3OQ==", "bodyText": "Would it be possible to log the response body as well ? (Not sure if this possible)", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r437367379", "createdAt": "2020-06-09T12:23:43Z", "author": {"login": "KevinVdV"}, "path": "dspace-api/src/main/java/org/dspace/app/sherpa/submit/SHERPASubmitService.java", "diffHunk": "@@ -37,12 +38,28 @@ public void setSherpaService(SHERPAService sherpaService) {\n         this.sherpaService = sherpaService;\n     }\n \n-    public SHERPAResponse searchRelatedJournals(Context context, Item item) {\n+    public List<SHERPAResponse> searchRelatedJournals(Context context, Item item) {\n         Set<String> issns = getISSNs(context, item);\n         if (issns == null || issns.size() == 0) {\n             return null;\n         } else {\n-            return sherpaService.searchByJournalISSN(StringUtils.join(issns, \",\"));\n+            // SHERPA v2 API no longer supports \"OR'd\" ISSN search, perform individual searches instead\n+            Iterator<String> issnIterator = issns.iterator();\n+            List<SHERPAResponse> responses = new LinkedList<>();\n+            while (issnIterator.hasNext()) {\n+                String issn = issnIterator.next();\n+                SHERPAResponse response = sherpaService.searchByJournalISSN(issn);\n+                if (response.isError()) {\n+                    // Continue with loop\n+                    log.warn(\"Failed to look up SHERPA ROMeO result for ISSN: \" + issn);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE3OTk4MA==", "bodyText": "It's not easily possible here, but what I've done is logged the error message (created upstream when error was set to true in the SHERPAResponse object), and also logged the response body in the SHERPAService and Data Providers if they ever encounter a response code that isn't HttpStatus.SC_OK\nSee commit: fdc5a3f2", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r443179980", "createdAt": "2020-06-21T04:17:30Z", "author": {"login": "kshepherd"}, "path": "dspace-api/src/main/java/org/dspace/app/sherpa/submit/SHERPASubmitService.java", "diffHunk": "@@ -37,12 +38,28 @@ public void setSherpaService(SHERPAService sherpaService) {\n         this.sherpaService = sherpaService;\n     }\n \n-    public SHERPAResponse searchRelatedJournals(Context context, Item item) {\n+    public List<SHERPAResponse> searchRelatedJournals(Context context, Item item) {\n         Set<String> issns = getISSNs(context, item);\n         if (issns == null || issns.size() == 0) {\n             return null;\n         } else {\n-            return sherpaService.searchByJournalISSN(StringUtils.join(issns, \",\"));\n+            // SHERPA v2 API no longer supports \"OR'd\" ISSN search, perform individual searches instead\n+            Iterator<String> issnIterator = issns.iterator();\n+            List<SHERPAResponse> responses = new LinkedList<>();\n+            while (issnIterator.hasNext()) {\n+                String issn = issnIterator.next();\n+                SHERPAResponse response = sherpaService.searchByJournalISSN(issn);\n+                if (response.isError()) {\n+                    // Continue with loop\n+                    log.warn(\"Failed to look up SHERPA ROMeO result for ISSN: \" + issn);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM2NzM3OQ=="}, "originalCommit": null, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQxODAzOQ==", "bodyText": "Ok", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r478418039", "createdAt": "2020-08-27T13:27:12Z", "author": {"login": "KevinVdV"}, "path": "dspace-api/src/main/java/org/dspace/app/sherpa/submit/SHERPASubmitService.java", "diffHunk": "@@ -37,12 +38,28 @@ public void setSherpaService(SHERPAService sherpaService) {\n         this.sherpaService = sherpaService;\n     }\n \n-    public SHERPAResponse searchRelatedJournals(Context context, Item item) {\n+    public List<SHERPAResponse> searchRelatedJournals(Context context, Item item) {\n         Set<String> issns = getISSNs(context, item);\n         if (issns == null || issns.size() == 0) {\n             return null;\n         } else {\n-            return sherpaService.searchByJournalISSN(StringUtils.join(issns, \",\"));\n+            // SHERPA v2 API no longer supports \"OR'd\" ISSN search, perform individual searches instead\n+            Iterator<String> issnIterator = issns.iterator();\n+            List<SHERPAResponse> responses = new LinkedList<>();\n+            while (issnIterator.hasNext()) {\n+                String issn = issnIterator.next();\n+                SHERPAResponse response = sherpaService.searchByJournalISSN(issn);\n+                if (response.isError()) {\n+                    // Continue with loop\n+                    log.warn(\"Failed to look up SHERPA ROMeO result for ISSN: \" + issn);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM2NzM3OQ=="}, "originalCommit": null, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNDcyODAzOnYy", "diffSide": "RIGHT", "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2PublisherDataProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMjoyNzoyNFrOGhG_Xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMVQwMjoxMjoyNlrOGmpNrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM3MDcxOQ==", "bodyText": "Can we use \"HttpStatus.SC_OK\" instead of 200 ?", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r437370719", "createdAt": "2020-06-09T12:27:24Z", "author": {"login": "KevinVdV"}, "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2PublisherDataProvider.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URISyntaxException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.sherpa.v2.SHERPAPublisher;\n+import org.dspace.app.sherpa.v2.SHERPAPublisherResponse;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+\n+/**\n+ * This class is the implementation of the ExternalDataProvider interface that will deal with SHERPAPublisher External\n+ * data lookups.\n+ * This provider is a refactored version of SherpaPublisherDataPublisher, rewritten to work with SHERPA v2 API\n+ *\n+ * It uses a more simple response object than the normal publication / policy search\n+ *\n+ * @author Kim Shepherd\n+ */\n+public class SHERPAv2PublisherDataProvider implements ExternalDataProvider {\n+\n+    private static final Logger log =\n+        org.apache.logging.log4j.LogManager.getLogger(SHERPAv2PublisherDataProvider.class);\n+\n+    private String sourceIdentifier;\n+    private String url;\n+    private String apiKey;\n+\n+    private CloseableHttpClient client = null;\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * Initialise the client that we need to call the endpoint\n+     * @throws IOException  If something goes wrong\n+     */\n+    public void init() throws IOException {\n+        HttpClientBuilder builder = HttpClientBuilder.create();\n+        // httpclient 4.3+ doesn't appear to have any sensible defaults any more. Setting conservative defaults as\n+        // not to hammer the SHERPA service too much.\n+        client = builder\n+            .disableAutomaticRetries()\n+            .setMaxConnTotal(5)\n+            .build();\n+    }\n+\n+    /**\n+     * Get a single publisher based on a \"id equals string\" query\n+     * @param id    The publisher ID which will be used as query string\n+     * @return external data object representing publisher\n+     */\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+\n+        HttpGet method = null;\n+        SHERPAPublisherResponse sherpaResponse = null;\n+        int timeout = 5000;\n+        URIBuilder uriBuilder = null;\n+        try {\n+            // Construct URI for an exact match on journal title\n+            uriBuilder = new URIBuilder(url);\n+            uriBuilder.addParameter(\"item-type\", \"publisher\");\n+            uriBuilder.addParameter(\"filter\", \"[[\\\"id\\\",\\\"equals\\\",\\\"\" + id + \"\\\"]]\");\n+            uriBuilder.addParameter(\"format\", \"Json\");\n+            if (StringUtils.isNotBlank(apiKey)) {\n+                uriBuilder.addParameter(\"api-key\", apiKey);\n+            }\n+\n+            // Build HTTP method\n+            method = new HttpGet(uriBuilder.build());\n+            method.setConfig(RequestConfig.custom()\n+                .setConnectionRequestTimeout(timeout)\n+                .setConnectTimeout(timeout)\n+                .setSocketTimeout(timeout)\n+                .build());\n+\n+            // Execute the method\n+            HttpResponse response = client.execute(method);\n+            int statusCode = response.getStatusLine().getStatusCode();\n+\n+            if (statusCode != HttpStatus.SC_OK) {\n+                sherpaResponse = new SHERPAPublisherResponse(\"SHERPA/RoMEO return not OK status: \"\n+                    + statusCode);\n+            }\n+\n+            HttpEntity responseBody = response.getEntity();\n+\n+            // Get InputStream from API response and parse JSON\n+            if (null != responseBody) {\n+                InputStream content = null;\n+                try {\n+                    content = responseBody.getContent();\n+                    sherpaResponse = new SHERPAPublisherResponse(content, SHERPAPublisherResponse.SHERPAFormat.JSON);\n+                } catch (IOException e) {\n+                    log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            } else {\n+                sherpaResponse = new SHERPAPublisherResponse(\"SHERPA/RoMEO returned no response\");\n+            }\n+        } catch (Exception e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+        }\n+\n+        if (sherpaResponse == null) {\n+            sherpaResponse = new SHERPAPublisherResponse(\"Error processing the SHERPA/RoMEO answer\");\n+        }\n+        if (CollectionUtils.isNotEmpty(sherpaResponse.getPublishers())) {\n+            SHERPAPublisher sherpaPublisher = sherpaResponse.getPublishers().get(0);\n+            // Construct external data object from returned publisher\n+            ExternalDataObject externalDataObject = constructExternalDataObjectFromSherpaPublisher(sherpaPublisher);\n+            return Optional.of(externalDataObject);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Search SHERPA v2 API for publisher results based on a 'contains word' query for publisher name\n+     * @param query The query for the search\n+     * @param start The start of the search\n+     * @param limit The max amount of records to be returned by the search\n+     * @return a list of external data objects\n+     */\n+    @Override\n+    public List<ExternalDataObject> searchExternalDataObjects(String query, int start, int limit) {\n+        // query args to add to SHERPA/RoMEO request URL\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query, start, limit);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Get response input stream and parse JSON into new SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAPublisherResponse sherpaResponse =\n+                        new SHERPAPublisherResponse(content, SHERPAPublisherResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getPublishers())) {\n+                        List<ExternalDataObject> list = sherpaResponse.getPublishers().stream().map(\n+                            sherpaPublisher -> constructExternalDataObjectFromSherpaPublisher(sherpaPublisher)).collect(\n+                            Collectors.toList());\n+\n+                        // Unlike the previous API version we can request offset and limit, so no need to build a\n+                        // sublist from this list, we can just return the list.\n+                        return list;\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error parsing SHERPA response input stream: \" + e.getMessage());\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            }\n+        } catch (IOException | URISyntaxException e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+            return null;\n+        } finally {\n+            if (get != null) {\n+                get.releaseConnection();\n+            }\n+        }\n+        return Collections.emptyList();\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"publisher name contains word\" query using default start/limit parameters\n+     * @param query a word or phrase to search for in publisher name\n+     * @return HttpGet method which can then be executed by the client\n+     * @throws URISyntaxException if the URL build fails\n+     */\n+    private HttpGet constructHttpGet(String query) throws URISyntaxException {\n+        return constructHttpGet(query, -1, -1);\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"publisher name contains word\" query\n+     * @param query the search query\n+     * @param start row offset\n+     * @param limit number of results to return\n+     * @return HttpGet object to be executed by the client\n+     * @throws URISyntaxException\n+     */\n+    private HttpGet constructHttpGet(String query, int start, int limit) throws URISyntaxException {\n+        // Build URL based on search query\n+        URIBuilder uriBuilder = new URIBuilder(url);\n+        uriBuilder.addParameter(\"item-type\", \"publisher\");\n+        uriBuilder.addParameter(\"filter\", \"[[\\\"name\\\",\\\"contains word\\\",\\\"\" + query + \"\\\"]]\");\n+        uriBuilder.addParameter(\"format\", \"Json\");\n+        // Set optional start (offset) and limit parameters\n+        if (start >= 0) {\n+            uriBuilder.addParameter(\"offset\", String.valueOf(start));\n+        }\n+        if (limit > 0) {\n+            uriBuilder.addParameter(\"limit\", String.valueOf(limit));\n+        }\n+        if (StringUtils.isNotBlank(apiKey)) {\n+            uriBuilder.addParameter(\"api-key\", apiKey);\n+        }\n+\n+        // Create HTTP GET object\n+        HttpGet method = new HttpGet(uriBuilder.build());\n+\n+        // Set connection parameters\n+        int timeout = 5000;\n+        method.setConfig(RequestConfig.custom()\n+            .setConnectionRequestTimeout(timeout)\n+            .setConnectTimeout(timeout)\n+            .setSocketTimeout(timeout)\n+            .build());\n+        return new HttpGet(uriBuilder.build());\n+    }\n+\n+    private ExternalDataObject constructExternalDataObjectFromSherpaPublisher(SHERPAPublisher sherpaPublisher) {\n+        ExternalDataObject externalDataObject = new ExternalDataObject();\n+        externalDataObject.setSource(sourceIdentifier);\n+\n+        // Set publisher name\n+        if (StringUtils.isNotBlank(sherpaPublisher.getName())) {\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"title\", null, null, sherpaPublisher.getName()));\n+            externalDataObject.setDisplayValue(sherpaPublisher.getName());\n+            externalDataObject.setValue(sherpaPublisher.getName());\n+        }\n+        // Set publisher ID\n+        if (StringUtils.isNotBlank(sherpaPublisher.getIdentifier())) {\n+            externalDataObject.setId(sherpaPublisher.getIdentifier());\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"identifier\", \"sherpaPublisher\", null,\n+                sherpaPublisher.getIdentifier()));\n+        }\n+\n+        // Set home URL\n+        if (StringUtils.isNotBlank(sherpaPublisher.getUri())) {\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"identifier\", \"other\", null, sherpaPublisher.getUri()));\n+        }\n+\n+        return externalDataObject;\n+    }\n+\n+    @Override\n+    public boolean supports(String source) {\n+        return StringUtils.equalsIgnoreCase(sourceIdentifier, source);\n+    }\n+\n+    /**\n+     * Get number of results returned from a SHERPA v2 publication search\n+     * @param query The query to be search on and give the total amount of results\n+     * @return int representing number of publisher results\n+     */\n+    @Override\n+    public int getNumberOfResults(String query) {\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 292}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE3NDMxOQ==", "bodyText": "Done! See commit# 839159b", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r443174319", "createdAt": "2020-06-21T02:12:26Z", "author": {"login": "kshepherd"}, "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2PublisherDataProvider.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URISyntaxException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.sherpa.v2.SHERPAPublisher;\n+import org.dspace.app.sherpa.v2.SHERPAPublisherResponse;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+\n+/**\n+ * This class is the implementation of the ExternalDataProvider interface that will deal with SHERPAPublisher External\n+ * data lookups.\n+ * This provider is a refactored version of SherpaPublisherDataPublisher, rewritten to work with SHERPA v2 API\n+ *\n+ * It uses a more simple response object than the normal publication / policy search\n+ *\n+ * @author Kim Shepherd\n+ */\n+public class SHERPAv2PublisherDataProvider implements ExternalDataProvider {\n+\n+    private static final Logger log =\n+        org.apache.logging.log4j.LogManager.getLogger(SHERPAv2PublisherDataProvider.class);\n+\n+    private String sourceIdentifier;\n+    private String url;\n+    private String apiKey;\n+\n+    private CloseableHttpClient client = null;\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * Initialise the client that we need to call the endpoint\n+     * @throws IOException  If something goes wrong\n+     */\n+    public void init() throws IOException {\n+        HttpClientBuilder builder = HttpClientBuilder.create();\n+        // httpclient 4.3+ doesn't appear to have any sensible defaults any more. Setting conservative defaults as\n+        // not to hammer the SHERPA service too much.\n+        client = builder\n+            .disableAutomaticRetries()\n+            .setMaxConnTotal(5)\n+            .build();\n+    }\n+\n+    /**\n+     * Get a single publisher based on a \"id equals string\" query\n+     * @param id    The publisher ID which will be used as query string\n+     * @return external data object representing publisher\n+     */\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+\n+        HttpGet method = null;\n+        SHERPAPublisherResponse sherpaResponse = null;\n+        int timeout = 5000;\n+        URIBuilder uriBuilder = null;\n+        try {\n+            // Construct URI for an exact match on journal title\n+            uriBuilder = new URIBuilder(url);\n+            uriBuilder.addParameter(\"item-type\", \"publisher\");\n+            uriBuilder.addParameter(\"filter\", \"[[\\\"id\\\",\\\"equals\\\",\\\"\" + id + \"\\\"]]\");\n+            uriBuilder.addParameter(\"format\", \"Json\");\n+            if (StringUtils.isNotBlank(apiKey)) {\n+                uriBuilder.addParameter(\"api-key\", apiKey);\n+            }\n+\n+            // Build HTTP method\n+            method = new HttpGet(uriBuilder.build());\n+            method.setConfig(RequestConfig.custom()\n+                .setConnectionRequestTimeout(timeout)\n+                .setConnectTimeout(timeout)\n+                .setSocketTimeout(timeout)\n+                .build());\n+\n+            // Execute the method\n+            HttpResponse response = client.execute(method);\n+            int statusCode = response.getStatusLine().getStatusCode();\n+\n+            if (statusCode != HttpStatus.SC_OK) {\n+                sherpaResponse = new SHERPAPublisherResponse(\"SHERPA/RoMEO return not OK status: \"\n+                    + statusCode);\n+            }\n+\n+            HttpEntity responseBody = response.getEntity();\n+\n+            // Get InputStream from API response and parse JSON\n+            if (null != responseBody) {\n+                InputStream content = null;\n+                try {\n+                    content = responseBody.getContent();\n+                    sherpaResponse = new SHERPAPublisherResponse(content, SHERPAPublisherResponse.SHERPAFormat.JSON);\n+                } catch (IOException e) {\n+                    log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            } else {\n+                sherpaResponse = new SHERPAPublisherResponse(\"SHERPA/RoMEO returned no response\");\n+            }\n+        } catch (Exception e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+        }\n+\n+        if (sherpaResponse == null) {\n+            sherpaResponse = new SHERPAPublisherResponse(\"Error processing the SHERPA/RoMEO answer\");\n+        }\n+        if (CollectionUtils.isNotEmpty(sherpaResponse.getPublishers())) {\n+            SHERPAPublisher sherpaPublisher = sherpaResponse.getPublishers().get(0);\n+            // Construct external data object from returned publisher\n+            ExternalDataObject externalDataObject = constructExternalDataObjectFromSherpaPublisher(sherpaPublisher);\n+            return Optional.of(externalDataObject);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Search SHERPA v2 API for publisher results based on a 'contains word' query for publisher name\n+     * @param query The query for the search\n+     * @param start The start of the search\n+     * @param limit The max amount of records to be returned by the search\n+     * @return a list of external data objects\n+     */\n+    @Override\n+    public List<ExternalDataObject> searchExternalDataObjects(String query, int start, int limit) {\n+        // query args to add to SHERPA/RoMEO request URL\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query, start, limit);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Get response input stream and parse JSON into new SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAPublisherResponse sherpaResponse =\n+                        new SHERPAPublisherResponse(content, SHERPAPublisherResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getPublishers())) {\n+                        List<ExternalDataObject> list = sherpaResponse.getPublishers().stream().map(\n+                            sherpaPublisher -> constructExternalDataObjectFromSherpaPublisher(sherpaPublisher)).collect(\n+                            Collectors.toList());\n+\n+                        // Unlike the previous API version we can request offset and limit, so no need to build a\n+                        // sublist from this list, we can just return the list.\n+                        return list;\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error parsing SHERPA response input stream: \" + e.getMessage());\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            }\n+        } catch (IOException | URISyntaxException e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+            return null;\n+        } finally {\n+            if (get != null) {\n+                get.releaseConnection();\n+            }\n+        }\n+        return Collections.emptyList();\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"publisher name contains word\" query using default start/limit parameters\n+     * @param query a word or phrase to search for in publisher name\n+     * @return HttpGet method which can then be executed by the client\n+     * @throws URISyntaxException if the URL build fails\n+     */\n+    private HttpGet constructHttpGet(String query) throws URISyntaxException {\n+        return constructHttpGet(query, -1, -1);\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"publisher name contains word\" query\n+     * @param query the search query\n+     * @param start row offset\n+     * @param limit number of results to return\n+     * @return HttpGet object to be executed by the client\n+     * @throws URISyntaxException\n+     */\n+    private HttpGet constructHttpGet(String query, int start, int limit) throws URISyntaxException {\n+        // Build URL based on search query\n+        URIBuilder uriBuilder = new URIBuilder(url);\n+        uriBuilder.addParameter(\"item-type\", \"publisher\");\n+        uriBuilder.addParameter(\"filter\", \"[[\\\"name\\\",\\\"contains word\\\",\\\"\" + query + \"\\\"]]\");\n+        uriBuilder.addParameter(\"format\", \"Json\");\n+        // Set optional start (offset) and limit parameters\n+        if (start >= 0) {\n+            uriBuilder.addParameter(\"offset\", String.valueOf(start));\n+        }\n+        if (limit > 0) {\n+            uriBuilder.addParameter(\"limit\", String.valueOf(limit));\n+        }\n+        if (StringUtils.isNotBlank(apiKey)) {\n+            uriBuilder.addParameter(\"api-key\", apiKey);\n+        }\n+\n+        // Create HTTP GET object\n+        HttpGet method = new HttpGet(uriBuilder.build());\n+\n+        // Set connection parameters\n+        int timeout = 5000;\n+        method.setConfig(RequestConfig.custom()\n+            .setConnectionRequestTimeout(timeout)\n+            .setConnectTimeout(timeout)\n+            .setSocketTimeout(timeout)\n+            .build());\n+        return new HttpGet(uriBuilder.build());\n+    }\n+\n+    private ExternalDataObject constructExternalDataObjectFromSherpaPublisher(SHERPAPublisher sherpaPublisher) {\n+        ExternalDataObject externalDataObject = new ExternalDataObject();\n+        externalDataObject.setSource(sourceIdentifier);\n+\n+        // Set publisher name\n+        if (StringUtils.isNotBlank(sherpaPublisher.getName())) {\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"title\", null, null, sherpaPublisher.getName()));\n+            externalDataObject.setDisplayValue(sherpaPublisher.getName());\n+            externalDataObject.setValue(sherpaPublisher.getName());\n+        }\n+        // Set publisher ID\n+        if (StringUtils.isNotBlank(sherpaPublisher.getIdentifier())) {\n+            externalDataObject.setId(sherpaPublisher.getIdentifier());\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"identifier\", \"sherpaPublisher\", null,\n+                sherpaPublisher.getIdentifier()));\n+        }\n+\n+        // Set home URL\n+        if (StringUtils.isNotBlank(sherpaPublisher.getUri())) {\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"identifier\", \"other\", null, sherpaPublisher.getUri()));\n+        }\n+\n+        return externalDataObject;\n+    }\n+\n+    @Override\n+    public boolean supports(String source) {\n+        return StringUtils.equalsIgnoreCase(sourceIdentifier, source);\n+    }\n+\n+    /**\n+     * Get number of results returned from a SHERPA v2 publication search\n+     * @param query The query to be search on and give the total amount of results\n+     * @return int representing number of publisher results\n+     */\n+    @Override\n+    public int getNumberOfResults(String query) {\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM3MDcxOQ=="}, "originalCommit": null, "originalPosition": 292}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNDczMTQ5OnYy", "diffSide": "RIGHT", "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2JournalDataProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMjoyNzo1OVrOGhHBbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMVQwMjoxMjoyMFrOGmpNpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM3MTI0Nw==", "bodyText": "Can we use \"HttpStatus.SC_OK\" instead of 200 ?", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r437371247", "createdAt": "2020-06-09T12:27:59Z", "author": {"login": "KevinVdV"}, "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2JournalDataProvider.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URISyntaxException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.sherpa.v2.SHERPAJournal;\n+import org.dspace.app.sherpa.v2.SHERPAResponse;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+\n+/**\n+ * This class is the implementation of the ExternalDataProvider interface that will deal with SherpaJournal External\n+ * data lookups.\n+ * This provider is a refactored version of SherpaJournalDataPublisher, rewritten to work with SHERPA v2 API\n+ *\n+ * @author Kim Shepherd\n+ */\n+public class SHERPAv2JournalDataProvider implements ExternalDataProvider {\n+\n+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(SHERPAv2JournalDataProvider.class);\n+\n+    private String url;\n+    private String sourceIdentifier;\n+    private String apiKey;\n+\n+    private CloseableHttpClient client = null;\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * Initialise the client that we need to call the endpoint\n+     * @throws IOException  If something goes wrong\n+     */\n+    public void init() throws IOException {\n+        HttpClientBuilder builder = HttpClientBuilder.create();\n+        // httpclient 4.3+ doesn't appear to have any sensible defaults any more. Setting conservative defaults as\n+        // not to hammer the SHERPA service too much.\n+        client = builder\n+            .disableAutomaticRetries()\n+            .setMaxConnTotal(5)\n+            .build();\n+    }\n+\n+    /**\n+     * Get a single journal based on a \"title equals string\" query\n+     * @param id    The journal title which will be used as query string\n+     * @return external data object representing journal\n+     */\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+\n+        HttpGet method = null;\n+        SHERPAResponse sherpaResponse = null;\n+        int timeout = 5000;\n+        URIBuilder uriBuilder = null;\n+        try {\n+            // Construct URI for an exact match on journal title\n+            uriBuilder = new URIBuilder(url);\n+            uriBuilder.addParameter(\"item-type\", \"publication\");\n+            uriBuilder.addParameter(\"filter\", \"[[\\\"title\\\",\\\"equals\\\",\\\"\" + id + \"\\\"]]\");\n+            uriBuilder.addParameter(\"format\", \"Json\");\n+            if (StringUtils.isNotBlank(apiKey)) {\n+                uriBuilder.addParameter(\"api-key\", apiKey);\n+            }\n+\n+            // Build HTTP method\n+            method = new HttpGet(uriBuilder.build());\n+            method.setConfig(RequestConfig.custom()\n+                                          .setConnectionRequestTimeout(timeout)\n+                                          .setConnectTimeout(timeout)\n+                                          .setSocketTimeout(timeout)\n+                                          .build());\n+\n+            // Execute the method\n+            HttpResponse response = client.execute(method);\n+            int statusCode = response.getStatusLine().getStatusCode();\n+\n+            if (statusCode != HttpStatus.SC_OK) {\n+                sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO return not OK status: \"\n+                                                        + statusCode);\n+            }\n+\n+            HttpEntity responseBody = response.getEntity();\n+\n+            // Get InputStream from API response and parse JSON\n+            if (null != responseBody) {\n+                InputStream content = null;\n+                try {\n+                    content = responseBody.getContent();\n+                    sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                } catch (IOException e) {\n+                    log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            } else {\n+                sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO returned no response\");\n+            }\n+        } catch (Exception e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+        }\n+\n+        if (sherpaResponse == null) {\n+            sherpaResponse = new SHERPAResponse(\n+                \"Error processing the SHERPA/RoMEO answer\");\n+        }\n+        if (CollectionUtils.isNotEmpty(sherpaResponse.getJournals())) {\n+            SHERPAJournal sherpaJournal = sherpaResponse.getJournals().get(0);\n+\n+            ExternalDataObject externalDataObject = constructExternalDataObjectFromSherpaJournal(sherpaJournal);\n+            return Optional.of(externalDataObject);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Construct ExternalDataObject populated with journal metadata from the SHERPA v2 API response\n+     * @param sherpaJournal\n+     * @return external data object representing a journal\n+     */\n+    private ExternalDataObject constructExternalDataObjectFromSherpaJournal(SHERPAJournal sherpaJournal) {\n+        // Set up external object\n+        ExternalDataObject externalDataObject = new ExternalDataObject();\n+        externalDataObject.setSource(sourceIdentifier);\n+        // Set journal title in external object\n+        if (CollectionUtils.isNotEmpty(sherpaJournal.getTitles())) {\n+            String journalTitle = sherpaJournal.getTitles().get(0);\n+            externalDataObject.setId(sherpaJournal.getTitles().get(0));\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"title\", null, null, journalTitle));\n+            externalDataObject.setValue(journalTitle);\n+            externalDataObject.setDisplayValue(journalTitle);\n+        }\n+        // Set ISSNs in external object\n+        if (CollectionUtils.isNotEmpty(sherpaJournal.getIssns())) {\n+            String issn = sherpaJournal.getIssns().get(0);\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                    \"dc\", \"identifier\", \"issn\", null, issn));\n+\n+        }\n+\n+        return externalDataObject;\n+    }\n+\n+    /**\n+     * Search SHERPA v2 API for journal results based on a 'contains word' query\n+     * @param query The query for the search\n+     * @param start The start of the search\n+     * @param limit The max amount of records to be returned by the search\n+     * @return a list of external data objects\n+     */\n+    @Override\n+    public List<ExternalDataObject> searchExternalDataObjects(String query, int start, int limit) {\n+        // query args to add to SHERPA/RoMEO request URL\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query, start, limit);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE3NDMwOA==", "bodyText": "Done! See commit# 839159b", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r443174308", "createdAt": "2020-06-21T02:12:20Z", "author": {"login": "kshepherd"}, "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2JournalDataProvider.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URISyntaxException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.sherpa.v2.SHERPAJournal;\n+import org.dspace.app.sherpa.v2.SHERPAResponse;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+\n+/**\n+ * This class is the implementation of the ExternalDataProvider interface that will deal with SherpaJournal External\n+ * data lookups.\n+ * This provider is a refactored version of SherpaJournalDataPublisher, rewritten to work with SHERPA v2 API\n+ *\n+ * @author Kim Shepherd\n+ */\n+public class SHERPAv2JournalDataProvider implements ExternalDataProvider {\n+\n+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(SHERPAv2JournalDataProvider.class);\n+\n+    private String url;\n+    private String sourceIdentifier;\n+    private String apiKey;\n+\n+    private CloseableHttpClient client = null;\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * Initialise the client that we need to call the endpoint\n+     * @throws IOException  If something goes wrong\n+     */\n+    public void init() throws IOException {\n+        HttpClientBuilder builder = HttpClientBuilder.create();\n+        // httpclient 4.3+ doesn't appear to have any sensible defaults any more. Setting conservative defaults as\n+        // not to hammer the SHERPA service too much.\n+        client = builder\n+            .disableAutomaticRetries()\n+            .setMaxConnTotal(5)\n+            .build();\n+    }\n+\n+    /**\n+     * Get a single journal based on a \"title equals string\" query\n+     * @param id    The journal title which will be used as query string\n+     * @return external data object representing journal\n+     */\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+\n+        HttpGet method = null;\n+        SHERPAResponse sherpaResponse = null;\n+        int timeout = 5000;\n+        URIBuilder uriBuilder = null;\n+        try {\n+            // Construct URI for an exact match on journal title\n+            uriBuilder = new URIBuilder(url);\n+            uriBuilder.addParameter(\"item-type\", \"publication\");\n+            uriBuilder.addParameter(\"filter\", \"[[\\\"title\\\",\\\"equals\\\",\\\"\" + id + \"\\\"]]\");\n+            uriBuilder.addParameter(\"format\", \"Json\");\n+            if (StringUtils.isNotBlank(apiKey)) {\n+                uriBuilder.addParameter(\"api-key\", apiKey);\n+            }\n+\n+            // Build HTTP method\n+            method = new HttpGet(uriBuilder.build());\n+            method.setConfig(RequestConfig.custom()\n+                                          .setConnectionRequestTimeout(timeout)\n+                                          .setConnectTimeout(timeout)\n+                                          .setSocketTimeout(timeout)\n+                                          .build());\n+\n+            // Execute the method\n+            HttpResponse response = client.execute(method);\n+            int statusCode = response.getStatusLine().getStatusCode();\n+\n+            if (statusCode != HttpStatus.SC_OK) {\n+                sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO return not OK status: \"\n+                                                        + statusCode);\n+            }\n+\n+            HttpEntity responseBody = response.getEntity();\n+\n+            // Get InputStream from API response and parse JSON\n+            if (null != responseBody) {\n+                InputStream content = null;\n+                try {\n+                    content = responseBody.getContent();\n+                    sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                } catch (IOException e) {\n+                    log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            } else {\n+                sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO returned no response\");\n+            }\n+        } catch (Exception e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+        }\n+\n+        if (sherpaResponse == null) {\n+            sherpaResponse = new SHERPAResponse(\n+                \"Error processing the SHERPA/RoMEO answer\");\n+        }\n+        if (CollectionUtils.isNotEmpty(sherpaResponse.getJournals())) {\n+            SHERPAJournal sherpaJournal = sherpaResponse.getJournals().get(0);\n+\n+            ExternalDataObject externalDataObject = constructExternalDataObjectFromSherpaJournal(sherpaJournal);\n+            return Optional.of(externalDataObject);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Construct ExternalDataObject populated with journal metadata from the SHERPA v2 API response\n+     * @param sherpaJournal\n+     * @return external data object representing a journal\n+     */\n+    private ExternalDataObject constructExternalDataObjectFromSherpaJournal(SHERPAJournal sherpaJournal) {\n+        // Set up external object\n+        ExternalDataObject externalDataObject = new ExternalDataObject();\n+        externalDataObject.setSource(sourceIdentifier);\n+        // Set journal title in external object\n+        if (CollectionUtils.isNotEmpty(sherpaJournal.getTitles())) {\n+            String journalTitle = sherpaJournal.getTitles().get(0);\n+            externalDataObject.setId(sherpaJournal.getTitles().get(0));\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"title\", null, null, journalTitle));\n+            externalDataObject.setValue(journalTitle);\n+            externalDataObject.setDisplayValue(journalTitle);\n+        }\n+        // Set ISSNs in external object\n+        if (CollectionUtils.isNotEmpty(sherpaJournal.getIssns())) {\n+            String issn = sherpaJournal.getIssns().get(0);\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                    \"dc\", \"identifier\", \"issn\", null, issn));\n+\n+        }\n+\n+        return externalDataObject;\n+    }\n+\n+    /**\n+     * Search SHERPA v2 API for journal results based on a 'contains word' query\n+     * @param query The query for the search\n+     * @param start The start of the search\n+     * @param limit The max amount of records to be returned by the search\n+     * @return a list of external data objects\n+     */\n+    @Override\n+    public List<ExternalDataObject> searchExternalDataObjects(String query, int start, int limit) {\n+        // query args to add to SHERPA/RoMEO request URL\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query, start, limit);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM3MTI0Nw=="}, "originalCommit": null, "originalPosition": 191}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNDczMjMwOnYy", "diffSide": "RIGHT", "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2JournalDataProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMjoyODowNlrOGhHB3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMVQwMjoxMTo1MlrOGmpNkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM3MTM1Ng==", "bodyText": "Can we use \"HttpStatus.SC_OK\" instead of 200 ?", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r437371356", "createdAt": "2020-06-09T12:28:06Z", "author": {"login": "KevinVdV"}, "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2JournalDataProvider.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URISyntaxException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.sherpa.v2.SHERPAJournal;\n+import org.dspace.app.sherpa.v2.SHERPAResponse;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+\n+/**\n+ * This class is the implementation of the ExternalDataProvider interface that will deal with SherpaJournal External\n+ * data lookups.\n+ * This provider is a refactored version of SherpaJournalDataPublisher, rewritten to work with SHERPA v2 API\n+ *\n+ * @author Kim Shepherd\n+ */\n+public class SHERPAv2JournalDataProvider implements ExternalDataProvider {\n+\n+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(SHERPAv2JournalDataProvider.class);\n+\n+    private String url;\n+    private String sourceIdentifier;\n+    private String apiKey;\n+\n+    private CloseableHttpClient client = null;\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * Initialise the client that we need to call the endpoint\n+     * @throws IOException  If something goes wrong\n+     */\n+    public void init() throws IOException {\n+        HttpClientBuilder builder = HttpClientBuilder.create();\n+        // httpclient 4.3+ doesn't appear to have any sensible defaults any more. Setting conservative defaults as\n+        // not to hammer the SHERPA service too much.\n+        client = builder\n+            .disableAutomaticRetries()\n+            .setMaxConnTotal(5)\n+            .build();\n+    }\n+\n+    /**\n+     * Get a single journal based on a \"title equals string\" query\n+     * @param id    The journal title which will be used as query string\n+     * @return external data object representing journal\n+     */\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+\n+        HttpGet method = null;\n+        SHERPAResponse sherpaResponse = null;\n+        int timeout = 5000;\n+        URIBuilder uriBuilder = null;\n+        try {\n+            // Construct URI for an exact match on journal title\n+            uriBuilder = new URIBuilder(url);\n+            uriBuilder.addParameter(\"item-type\", \"publication\");\n+            uriBuilder.addParameter(\"filter\", \"[[\\\"title\\\",\\\"equals\\\",\\\"\" + id + \"\\\"]]\");\n+            uriBuilder.addParameter(\"format\", \"Json\");\n+            if (StringUtils.isNotBlank(apiKey)) {\n+                uriBuilder.addParameter(\"api-key\", apiKey);\n+            }\n+\n+            // Build HTTP method\n+            method = new HttpGet(uriBuilder.build());\n+            method.setConfig(RequestConfig.custom()\n+                                          .setConnectionRequestTimeout(timeout)\n+                                          .setConnectTimeout(timeout)\n+                                          .setSocketTimeout(timeout)\n+                                          .build());\n+\n+            // Execute the method\n+            HttpResponse response = client.execute(method);\n+            int statusCode = response.getStatusLine().getStatusCode();\n+\n+            if (statusCode != HttpStatus.SC_OK) {\n+                sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO return not OK status: \"\n+                                                        + statusCode);\n+            }\n+\n+            HttpEntity responseBody = response.getEntity();\n+\n+            // Get InputStream from API response and parse JSON\n+            if (null != responseBody) {\n+                InputStream content = null;\n+                try {\n+                    content = responseBody.getContent();\n+                    sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                } catch (IOException e) {\n+                    log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            } else {\n+                sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO returned no response\");\n+            }\n+        } catch (Exception e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+        }\n+\n+        if (sherpaResponse == null) {\n+            sherpaResponse = new SHERPAResponse(\n+                \"Error processing the SHERPA/RoMEO answer\");\n+        }\n+        if (CollectionUtils.isNotEmpty(sherpaResponse.getJournals())) {\n+            SHERPAJournal sherpaJournal = sherpaResponse.getJournals().get(0);\n+\n+            ExternalDataObject externalDataObject = constructExternalDataObjectFromSherpaJournal(sherpaJournal);\n+            return Optional.of(externalDataObject);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Construct ExternalDataObject populated with journal metadata from the SHERPA v2 API response\n+     * @param sherpaJournal\n+     * @return external data object representing a journal\n+     */\n+    private ExternalDataObject constructExternalDataObjectFromSherpaJournal(SHERPAJournal sherpaJournal) {\n+        // Set up external object\n+        ExternalDataObject externalDataObject = new ExternalDataObject();\n+        externalDataObject.setSource(sourceIdentifier);\n+        // Set journal title in external object\n+        if (CollectionUtils.isNotEmpty(sherpaJournal.getTitles())) {\n+            String journalTitle = sherpaJournal.getTitles().get(0);\n+            externalDataObject.setId(sherpaJournal.getTitles().get(0));\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"title\", null, null, journalTitle));\n+            externalDataObject.setValue(journalTitle);\n+            externalDataObject.setDisplayValue(journalTitle);\n+        }\n+        // Set ISSNs in external object\n+        if (CollectionUtils.isNotEmpty(sherpaJournal.getIssns())) {\n+            String issn = sherpaJournal.getIssns().get(0);\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                    \"dc\", \"identifier\", \"issn\", null, issn));\n+\n+        }\n+\n+        return externalDataObject;\n+    }\n+\n+    /**\n+     * Search SHERPA v2 API for journal results based on a 'contains word' query\n+     * @param query The query for the search\n+     * @param start The start of the search\n+     * @param limit The max amount of records to be returned by the search\n+     * @return a list of external data objects\n+     */\n+    @Override\n+    public List<ExternalDataObject> searchExternalDataObjects(String query, int start, int limit) {\n+        // query args to add to SHERPA/RoMEO request URL\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query, start, limit);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Get response input stream and parse JSON into new SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAResponse sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getJournals())) {\n+                        List<ExternalDataObject> list = sherpaResponse.getJournals().stream().map(\n+                            sherpaJournal -> constructExternalDataObjectFromSherpaJournal(sherpaJournal)).collect(\n+                            Collectors.toList());\n+\n+                        // Unlike the previous API version we can request offset and limit, so no need to build a\n+                        // sublist from this list, we can just return the list.\n+                        return list;\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error parsing SHERPA response input stream: \" + e.getMessage());\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            }\n+        } catch (IOException | URISyntaxException e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+            return null;\n+        } finally {\n+            if (get != null) {\n+                get.releaseConnection();\n+            }\n+        }\n+        return Collections.emptyList();\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"title contains word\" query using default start/limit parameters\n+     * @param query a word or phrase to search for in journal title\n+     * @return HttpGet method which can then be executed by the client\n+     * @throws URISyntaxException if the URL build fails\n+     */\n+    private HttpGet constructHttpGet(String query) throws URISyntaxException {\n+        return constructHttpGet(query, -1, -1);\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"title contains word\" query\n+     * @param query the search query\n+     * @param start row offset\n+     * @param limit number of results to return\n+     * @return HttpGet object to be executed by the client\n+     * @throws URISyntaxException\n+     */\n+    private HttpGet constructHttpGet(String query, int start, int limit) throws URISyntaxException {\n+        // Build URL based on search query\n+        URIBuilder uriBuilder = new URIBuilder(url);\n+        uriBuilder.addParameter(\"item-type\", \"publication\");\n+        uriBuilder.addParameter(\"filter\", \"[[\\\"title\\\",\\\"contains word\\\",\\\"\" + query + \"\\\"]]\");\n+        uriBuilder.addParameter(\"format\", \"Json\");\n+        // Set optional start (offset) and limit parameters\n+        if (start >= 0) {\n+            uriBuilder.addParameter(\"offset\", String.valueOf(start));\n+        }\n+        if (limit > 0) {\n+            uriBuilder.addParameter(\"limit\", String.valueOf(limit));\n+        }\n+        if (StringUtils.isNotBlank(apiKey)) {\n+            uriBuilder.addParameter(\"api-key\", apiKey);\n+        }\n+\n+        // Create HTTP GET object\n+        HttpGet method = new HttpGet(uriBuilder.build());\n+\n+        // Set connection parameters\n+        int timeout = 5000;\n+        method.setConfig(RequestConfig.custom()\n+            .setConnectionRequestTimeout(timeout)\n+            .setConnectTimeout(timeout)\n+            .setSocketTimeout(timeout)\n+            .build());\n+        return new HttpGet(uriBuilder.build());\n+    }\n+\n+    @Override\n+    public boolean supports(String source) {\n+        return StringUtils.equalsIgnoreCase(sourceIdentifier, source);\n+    }\n+\n+    /**\n+     * Get number of results returned from a SHERPA v2 publication search\n+     * @param query The query to be search on and give the total amount of results\n+     * @return int representing number of journal results\n+     */\n+    @Override\n+    public int getNumberOfResults(String query) {\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 290}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE3NDI5MQ==", "bodyText": "Done! See commit# 839159b:\n839159b", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r443174291", "createdAt": "2020-06-21T02:11:52Z", "author": {"login": "kshepherd"}, "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2JournalDataProvider.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URISyntaxException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.sherpa.v2.SHERPAJournal;\n+import org.dspace.app.sherpa.v2.SHERPAResponse;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+\n+/**\n+ * This class is the implementation of the ExternalDataProvider interface that will deal with SherpaJournal External\n+ * data lookups.\n+ * This provider is a refactored version of SherpaJournalDataPublisher, rewritten to work with SHERPA v2 API\n+ *\n+ * @author Kim Shepherd\n+ */\n+public class SHERPAv2JournalDataProvider implements ExternalDataProvider {\n+\n+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(SHERPAv2JournalDataProvider.class);\n+\n+    private String url;\n+    private String sourceIdentifier;\n+    private String apiKey;\n+\n+    private CloseableHttpClient client = null;\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * Initialise the client that we need to call the endpoint\n+     * @throws IOException  If something goes wrong\n+     */\n+    public void init() throws IOException {\n+        HttpClientBuilder builder = HttpClientBuilder.create();\n+        // httpclient 4.3+ doesn't appear to have any sensible defaults any more. Setting conservative defaults as\n+        // not to hammer the SHERPA service too much.\n+        client = builder\n+            .disableAutomaticRetries()\n+            .setMaxConnTotal(5)\n+            .build();\n+    }\n+\n+    /**\n+     * Get a single journal based on a \"title equals string\" query\n+     * @param id    The journal title which will be used as query string\n+     * @return external data object representing journal\n+     */\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+\n+        HttpGet method = null;\n+        SHERPAResponse sherpaResponse = null;\n+        int timeout = 5000;\n+        URIBuilder uriBuilder = null;\n+        try {\n+            // Construct URI for an exact match on journal title\n+            uriBuilder = new URIBuilder(url);\n+            uriBuilder.addParameter(\"item-type\", \"publication\");\n+            uriBuilder.addParameter(\"filter\", \"[[\\\"title\\\",\\\"equals\\\",\\\"\" + id + \"\\\"]]\");\n+            uriBuilder.addParameter(\"format\", \"Json\");\n+            if (StringUtils.isNotBlank(apiKey)) {\n+                uriBuilder.addParameter(\"api-key\", apiKey);\n+            }\n+\n+            // Build HTTP method\n+            method = new HttpGet(uriBuilder.build());\n+            method.setConfig(RequestConfig.custom()\n+                                          .setConnectionRequestTimeout(timeout)\n+                                          .setConnectTimeout(timeout)\n+                                          .setSocketTimeout(timeout)\n+                                          .build());\n+\n+            // Execute the method\n+            HttpResponse response = client.execute(method);\n+            int statusCode = response.getStatusLine().getStatusCode();\n+\n+            if (statusCode != HttpStatus.SC_OK) {\n+                sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO return not OK status: \"\n+                                                        + statusCode);\n+            }\n+\n+            HttpEntity responseBody = response.getEntity();\n+\n+            // Get InputStream from API response and parse JSON\n+            if (null != responseBody) {\n+                InputStream content = null;\n+                try {\n+                    content = responseBody.getContent();\n+                    sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                } catch (IOException e) {\n+                    log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            } else {\n+                sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO returned no response\");\n+            }\n+        } catch (Exception e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+        }\n+\n+        if (sherpaResponse == null) {\n+            sherpaResponse = new SHERPAResponse(\n+                \"Error processing the SHERPA/RoMEO answer\");\n+        }\n+        if (CollectionUtils.isNotEmpty(sherpaResponse.getJournals())) {\n+            SHERPAJournal sherpaJournal = sherpaResponse.getJournals().get(0);\n+\n+            ExternalDataObject externalDataObject = constructExternalDataObjectFromSherpaJournal(sherpaJournal);\n+            return Optional.of(externalDataObject);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Construct ExternalDataObject populated with journal metadata from the SHERPA v2 API response\n+     * @param sherpaJournal\n+     * @return external data object representing a journal\n+     */\n+    private ExternalDataObject constructExternalDataObjectFromSherpaJournal(SHERPAJournal sherpaJournal) {\n+        // Set up external object\n+        ExternalDataObject externalDataObject = new ExternalDataObject();\n+        externalDataObject.setSource(sourceIdentifier);\n+        // Set journal title in external object\n+        if (CollectionUtils.isNotEmpty(sherpaJournal.getTitles())) {\n+            String journalTitle = sherpaJournal.getTitles().get(0);\n+            externalDataObject.setId(sherpaJournal.getTitles().get(0));\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"title\", null, null, journalTitle));\n+            externalDataObject.setValue(journalTitle);\n+            externalDataObject.setDisplayValue(journalTitle);\n+        }\n+        // Set ISSNs in external object\n+        if (CollectionUtils.isNotEmpty(sherpaJournal.getIssns())) {\n+            String issn = sherpaJournal.getIssns().get(0);\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                    \"dc\", \"identifier\", \"issn\", null, issn));\n+\n+        }\n+\n+        return externalDataObject;\n+    }\n+\n+    /**\n+     * Search SHERPA v2 API for journal results based on a 'contains word' query\n+     * @param query The query for the search\n+     * @param start The start of the search\n+     * @param limit The max amount of records to be returned by the search\n+     * @return a list of external data objects\n+     */\n+    @Override\n+    public List<ExternalDataObject> searchExternalDataObjects(String query, int start, int limit) {\n+        // query args to add to SHERPA/RoMEO request URL\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query, start, limit);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Get response input stream and parse JSON into new SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAResponse sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getJournals())) {\n+                        List<ExternalDataObject> list = sherpaResponse.getJournals().stream().map(\n+                            sherpaJournal -> constructExternalDataObjectFromSherpaJournal(sherpaJournal)).collect(\n+                            Collectors.toList());\n+\n+                        // Unlike the previous API version we can request offset and limit, so no need to build a\n+                        // sublist from this list, we can just return the list.\n+                        return list;\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error parsing SHERPA response input stream: \" + e.getMessage());\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            }\n+        } catch (IOException | URISyntaxException e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+            return null;\n+        } finally {\n+            if (get != null) {\n+                get.releaseConnection();\n+            }\n+        }\n+        return Collections.emptyList();\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"title contains word\" query using default start/limit parameters\n+     * @param query a word or phrase to search for in journal title\n+     * @return HttpGet method which can then be executed by the client\n+     * @throws URISyntaxException if the URL build fails\n+     */\n+    private HttpGet constructHttpGet(String query) throws URISyntaxException {\n+        return constructHttpGet(query, -1, -1);\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"title contains word\" query\n+     * @param query the search query\n+     * @param start row offset\n+     * @param limit number of results to return\n+     * @return HttpGet object to be executed by the client\n+     * @throws URISyntaxException\n+     */\n+    private HttpGet constructHttpGet(String query, int start, int limit) throws URISyntaxException {\n+        // Build URL based on search query\n+        URIBuilder uriBuilder = new URIBuilder(url);\n+        uriBuilder.addParameter(\"item-type\", \"publication\");\n+        uriBuilder.addParameter(\"filter\", \"[[\\\"title\\\",\\\"contains word\\\",\\\"\" + query + \"\\\"]]\");\n+        uriBuilder.addParameter(\"format\", \"Json\");\n+        // Set optional start (offset) and limit parameters\n+        if (start >= 0) {\n+            uriBuilder.addParameter(\"offset\", String.valueOf(start));\n+        }\n+        if (limit > 0) {\n+            uriBuilder.addParameter(\"limit\", String.valueOf(limit));\n+        }\n+        if (StringUtils.isNotBlank(apiKey)) {\n+            uriBuilder.addParameter(\"api-key\", apiKey);\n+        }\n+\n+        // Create HTTP GET object\n+        HttpGet method = new HttpGet(uriBuilder.build());\n+\n+        // Set connection parameters\n+        int timeout = 5000;\n+        method.setConfig(RequestConfig.custom()\n+            .setConnectionRequestTimeout(timeout)\n+            .setConnectTimeout(timeout)\n+            .setSocketTimeout(timeout)\n+            .build());\n+        return new HttpGet(uriBuilder.build());\n+    }\n+\n+    @Override\n+    public boolean supports(String source) {\n+        return StringUtils.equalsIgnoreCase(sourceIdentifier, source);\n+    }\n+\n+    /**\n+     * Get number of results returned from a SHERPA v2 publication search\n+     * @param query The query to be search on and give the total amount of results\n+     * @return int representing number of journal results\n+     */\n+    @Override\n+    public int getNumberOfResults(String query) {\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM3MTM1Ng=="}, "originalCommit": null, "originalPosition": 290}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNDczMzEwOnYy", "diffSide": "RIGHT", "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2PublisherDataProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMjoyODoxMlrOGhHCQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMVQwMjoxMjowN1rOGmpNlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM3MTQ1OA==", "bodyText": "Can we use \"HttpStatus.SC_OK\" instead of 200 ?", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r437371458", "createdAt": "2020-06-09T12:28:12Z", "author": {"login": "KevinVdV"}, "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2PublisherDataProvider.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URISyntaxException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.sherpa.v2.SHERPAPublisher;\n+import org.dspace.app.sherpa.v2.SHERPAPublisherResponse;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+\n+/**\n+ * This class is the implementation of the ExternalDataProvider interface that will deal with SHERPAPublisher External\n+ * data lookups.\n+ * This provider is a refactored version of SherpaPublisherDataPublisher, rewritten to work with SHERPA v2 API\n+ *\n+ * It uses a more simple response object than the normal publication / policy search\n+ *\n+ * @author Kim Shepherd\n+ */\n+public class SHERPAv2PublisherDataProvider implements ExternalDataProvider {\n+\n+    private static final Logger log =\n+        org.apache.logging.log4j.LogManager.getLogger(SHERPAv2PublisherDataProvider.class);\n+\n+    private String sourceIdentifier;\n+    private String url;\n+    private String apiKey;\n+\n+    private CloseableHttpClient client = null;\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * Initialise the client that we need to call the endpoint\n+     * @throws IOException  If something goes wrong\n+     */\n+    public void init() throws IOException {\n+        HttpClientBuilder builder = HttpClientBuilder.create();\n+        // httpclient 4.3+ doesn't appear to have any sensible defaults any more. Setting conservative defaults as\n+        // not to hammer the SHERPA service too much.\n+        client = builder\n+            .disableAutomaticRetries()\n+            .setMaxConnTotal(5)\n+            .build();\n+    }\n+\n+    /**\n+     * Get a single publisher based on a \"id equals string\" query\n+     * @param id    The publisher ID which will be used as query string\n+     * @return external data object representing publisher\n+     */\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+\n+        HttpGet method = null;\n+        SHERPAPublisherResponse sherpaResponse = null;\n+        int timeout = 5000;\n+        URIBuilder uriBuilder = null;\n+        try {\n+            // Construct URI for an exact match on journal title\n+            uriBuilder = new URIBuilder(url);\n+            uriBuilder.addParameter(\"item-type\", \"publisher\");\n+            uriBuilder.addParameter(\"filter\", \"[[\\\"id\\\",\\\"equals\\\",\\\"\" + id + \"\\\"]]\");\n+            uriBuilder.addParameter(\"format\", \"Json\");\n+            if (StringUtils.isNotBlank(apiKey)) {\n+                uriBuilder.addParameter(\"api-key\", apiKey);\n+            }\n+\n+            // Build HTTP method\n+            method = new HttpGet(uriBuilder.build());\n+            method.setConfig(RequestConfig.custom()\n+                .setConnectionRequestTimeout(timeout)\n+                .setConnectTimeout(timeout)\n+                .setSocketTimeout(timeout)\n+                .build());\n+\n+            // Execute the method\n+            HttpResponse response = client.execute(method);\n+            int statusCode = response.getStatusLine().getStatusCode();\n+\n+            if (statusCode != HttpStatus.SC_OK) {\n+                sherpaResponse = new SHERPAPublisherResponse(\"SHERPA/RoMEO return not OK status: \"\n+                    + statusCode);\n+            }\n+\n+            HttpEntity responseBody = response.getEntity();\n+\n+            // Get InputStream from API response and parse JSON\n+            if (null != responseBody) {\n+                InputStream content = null;\n+                try {\n+                    content = responseBody.getContent();\n+                    sherpaResponse = new SHERPAPublisherResponse(content, SHERPAPublisherResponse.SHERPAFormat.JSON);\n+                } catch (IOException e) {\n+                    log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            } else {\n+                sherpaResponse = new SHERPAPublisherResponse(\"SHERPA/RoMEO returned no response\");\n+            }\n+        } catch (Exception e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+        }\n+\n+        if (sherpaResponse == null) {\n+            sherpaResponse = new SHERPAPublisherResponse(\"Error processing the SHERPA/RoMEO answer\");\n+        }\n+        if (CollectionUtils.isNotEmpty(sherpaResponse.getPublishers())) {\n+            SHERPAPublisher sherpaPublisher = sherpaResponse.getPublishers().get(0);\n+            // Construct external data object from returned publisher\n+            ExternalDataObject externalDataObject = constructExternalDataObjectFromSherpaPublisher(sherpaPublisher);\n+            return Optional.of(externalDataObject);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Search SHERPA v2 API for publisher results based on a 'contains word' query for publisher name\n+     * @param query The query for the search\n+     * @param start The start of the search\n+     * @param limit The max amount of records to be returned by the search\n+     * @return a list of external data objects\n+     */\n+    @Override\n+    public List<ExternalDataObject> searchExternalDataObjects(String query, int start, int limit) {\n+        // query args to add to SHERPA/RoMEO request URL\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query, start, limit);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE3NDI5NQ==", "bodyText": "Done! See commit# 839159b", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r443174295", "createdAt": "2020-06-21T02:12:07Z", "author": {"login": "kshepherd"}, "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2PublisherDataProvider.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URISyntaxException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.sherpa.v2.SHERPAPublisher;\n+import org.dspace.app.sherpa.v2.SHERPAPublisherResponse;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+\n+/**\n+ * This class is the implementation of the ExternalDataProvider interface that will deal with SHERPAPublisher External\n+ * data lookups.\n+ * This provider is a refactored version of SherpaPublisherDataPublisher, rewritten to work with SHERPA v2 API\n+ *\n+ * It uses a more simple response object than the normal publication / policy search\n+ *\n+ * @author Kim Shepherd\n+ */\n+public class SHERPAv2PublisherDataProvider implements ExternalDataProvider {\n+\n+    private static final Logger log =\n+        org.apache.logging.log4j.LogManager.getLogger(SHERPAv2PublisherDataProvider.class);\n+\n+    private String sourceIdentifier;\n+    private String url;\n+    private String apiKey;\n+\n+    private CloseableHttpClient client = null;\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * Initialise the client that we need to call the endpoint\n+     * @throws IOException  If something goes wrong\n+     */\n+    public void init() throws IOException {\n+        HttpClientBuilder builder = HttpClientBuilder.create();\n+        // httpclient 4.3+ doesn't appear to have any sensible defaults any more. Setting conservative defaults as\n+        // not to hammer the SHERPA service too much.\n+        client = builder\n+            .disableAutomaticRetries()\n+            .setMaxConnTotal(5)\n+            .build();\n+    }\n+\n+    /**\n+     * Get a single publisher based on a \"id equals string\" query\n+     * @param id    The publisher ID which will be used as query string\n+     * @return external data object representing publisher\n+     */\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+\n+        HttpGet method = null;\n+        SHERPAPublisherResponse sherpaResponse = null;\n+        int timeout = 5000;\n+        URIBuilder uriBuilder = null;\n+        try {\n+            // Construct URI for an exact match on journal title\n+            uriBuilder = new URIBuilder(url);\n+            uriBuilder.addParameter(\"item-type\", \"publisher\");\n+            uriBuilder.addParameter(\"filter\", \"[[\\\"id\\\",\\\"equals\\\",\\\"\" + id + \"\\\"]]\");\n+            uriBuilder.addParameter(\"format\", \"Json\");\n+            if (StringUtils.isNotBlank(apiKey)) {\n+                uriBuilder.addParameter(\"api-key\", apiKey);\n+            }\n+\n+            // Build HTTP method\n+            method = new HttpGet(uriBuilder.build());\n+            method.setConfig(RequestConfig.custom()\n+                .setConnectionRequestTimeout(timeout)\n+                .setConnectTimeout(timeout)\n+                .setSocketTimeout(timeout)\n+                .build());\n+\n+            // Execute the method\n+            HttpResponse response = client.execute(method);\n+            int statusCode = response.getStatusLine().getStatusCode();\n+\n+            if (statusCode != HttpStatus.SC_OK) {\n+                sherpaResponse = new SHERPAPublisherResponse(\"SHERPA/RoMEO return not OK status: \"\n+                    + statusCode);\n+            }\n+\n+            HttpEntity responseBody = response.getEntity();\n+\n+            // Get InputStream from API response and parse JSON\n+            if (null != responseBody) {\n+                InputStream content = null;\n+                try {\n+                    content = responseBody.getContent();\n+                    sherpaResponse = new SHERPAPublisherResponse(content, SHERPAPublisherResponse.SHERPAFormat.JSON);\n+                } catch (IOException e) {\n+                    log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            } else {\n+                sherpaResponse = new SHERPAPublisherResponse(\"SHERPA/RoMEO returned no response\");\n+            }\n+        } catch (Exception e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+        }\n+\n+        if (sherpaResponse == null) {\n+            sherpaResponse = new SHERPAPublisherResponse(\"Error processing the SHERPA/RoMEO answer\");\n+        }\n+        if (CollectionUtils.isNotEmpty(sherpaResponse.getPublishers())) {\n+            SHERPAPublisher sherpaPublisher = sherpaResponse.getPublishers().get(0);\n+            // Construct external data object from returned publisher\n+            ExternalDataObject externalDataObject = constructExternalDataObjectFromSherpaPublisher(sherpaPublisher);\n+            return Optional.of(externalDataObject);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Search SHERPA v2 API for publisher results based on a 'contains word' query for publisher name\n+     * @param query The query for the search\n+     * @param start The start of the search\n+     * @param limit The max amount of records to be returned by the search\n+     * @return a list of external data objects\n+     */\n+    @Override\n+    public List<ExternalDataObject> searchExternalDataObjects(String query, int start, int limit) {\n+        // query args to add to SHERPA/RoMEO request URL\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query, start, limit);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM3MTQ1OA=="}, "originalCommit": null, "originalPosition": 164}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1535, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}