{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU1NjI5MDQw", "number": 2899, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNzowMTowNVrOES54kQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNzoxODoxNlrOES6Rkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MjU4MTkzOnYy", "diffSide": "RIGHT", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/MetadataFieldNameRestController.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNzowMTowNVrOG4WA0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwNjozODozN1rOG_99_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTczNDA5Nw==", "bodyText": "This Controller isn't needed as we don't have a /api/core/metdatafields/name/[:metadata-field-full-name] path in the Contract: https://github.com/DSpace/Rest7Contract/blob/main/metadatafields.md\nInstead, this endpoint is at /api/core/metadatafields/search/byFieldName and you've already implemented that endpoint in the MetadataFieldRestRepository in this same PR.  So, this entire Controller can be removed.", "url": "https://github.com/DSpace/DSpace/pull/2899#discussion_r461734097", "createdAt": "2020-07-28T17:01:05Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/MetadataFieldNameRestController.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import java.sql.SQLException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.model.MetadataFieldRest;\n+import org.dspace.app.rest.utils.ContextUtil;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.content.MetadataField;\n+import org.dspace.content.service.MetadataFieldService;\n+import org.dspace.core.Context;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.rest.webmvc.ResourceNotFoundException;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.PathVariable;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+/**\n+ * This controller will handle all the incoming calls on the /api/core/metadatafields/name/<:metadata-field-full-name>\n+ * endpoint where the metadata-field-full-name parameter can be filled in to match a specific metadata field by name\n+ * There's always at most one metadata field per name.\n+ * <p>\n+ * It responds with:\n+ * <p>\n+ * The single metadata field if there's a match\n+ * 404 if the metadata field doesn't exist\n+ *\n+ * @author Maria Verdonck (Atmire) on 17/07/2020\n+ */\n+@RestController\n+@RequestMapping(\"/api/\" + MetadataFieldRest.CATEGORY + \"/\" + MetadataFieldRest.NAME_PLURAL)\n+public class MetadataFieldNameRestController {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEzNTkyMA==", "bodyText": "@tdonohue A quick overview for the 'need' of this MetadataFieldNameRestController class:\nFor the front end validation on whether or not a filled in mdField is valid (on the edit item > metadata page) an exact retrieval of a mdField is needed, where either exactly one matching mdField is given or none if it doesn\u2019t exist. While this could be done by the findByName endpoint, this would require:\n\nFor mdFields without a qualifier > Index a null/unknown value in solr\nIn frontend add &qualifier=null along to the restend when searching for an mdField without a qualifier\nExample: You want to validate whether or not dc.title that the user has filled in is a valid mdField\n\nSo you use searchByName?schema=dc&element=title which returns multiple results (dc.title, dc.title.other, dc.title.en, \u2026).\nBut if for example dc.title does not exist, this search would still return multiple (other) results.\n\n\n\nAnother solution might be to go over these results in the frontend and look for an exact match, but is not a frontend responsibility.\nThis same endpoint however is used to give the list of suggestions while the user is typing, so it would be hard to know when to add that &qualifier=null, because the user could just still be typing, and has yet to add the qualifier.\nEither way for a single exact match a search in general is not recommended, hence the new /api/core/metadatafields/name/ endpoint. Which doesn\u2019t return an array or embed, but a single field or a 404 if no matching field is found, which uses the DB and not the Solr indexed mdFields.\nPrevious implementation of suggestion/validation on the edit item page disabled this here: DSpace/dspace-angular@09f1b7e\nWe are currently in the process of creating the validator related to DSpace/dspace-angular#750 and that was the reason that this has come up.\nThe related PR for this updated rest contract can be found here: DSpace/RestContract#145", "url": "https://github.com/DSpace/DSpace/pull/2899#discussion_r462135920", "createdAt": "2020-07-29T08:39:58Z", "author": {"login": "jonas-atmire"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/MetadataFieldNameRestController.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import java.sql.SQLException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.model.MetadataFieldRest;\n+import org.dspace.app.rest.utils.ContextUtil;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.content.MetadataField;\n+import org.dspace.content.service.MetadataFieldService;\n+import org.dspace.core.Context;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.rest.webmvc.ResourceNotFoundException;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.PathVariable;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+/**\n+ * This controller will handle all the incoming calls on the /api/core/metadatafields/name/<:metadata-field-full-name>\n+ * endpoint where the metadata-field-full-name parameter can be filled in to match a specific metadata field by name\n+ * There's always at most one metadata field per name.\n+ * <p>\n+ * It responds with:\n+ * <p>\n+ * The single metadata field if there's a match\n+ * 404 if the metadata field doesn't exist\n+ *\n+ * @author Maria Verdonck (Atmire) on 17/07/2020\n+ */\n+@RestController\n+@RequestMapping(\"/api/\" + MetadataFieldRest.CATEGORY + \"/\" + MetadataFieldRest.NAME_PLURAL)\n+public class MetadataFieldNameRestController {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTczNDA5Nw=="}, "originalCommit": null, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTcyODc2Nw==", "bodyText": "@tdonohue As per described in DSpace/RestContract#145,\nThe code has now been altered to remove this search functionality for a single field, with the complete name, in the separate MetadataFieldNameRestController, and it has moved to the more general search in MetadataFieldRestRepository\nThe unrelated tests are still failing here because of the MetadataField being indexing on add/edit/deletes now.\nThis will need to be looked into further to make sure the solr changes don't have any effect on other tests.", "url": "https://github.com/DSpace/DSpace/pull/2899#discussion_r469728767", "createdAt": "2020-08-13T06:38:37Z", "author": {"login": "jonas-atmire"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/MetadataFieldNameRestController.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import java.sql.SQLException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.model.MetadataFieldRest;\n+import org.dspace.app.rest.utils.ContextUtil;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.content.MetadataField;\n+import org.dspace.content.service.MetadataFieldService;\n+import org.dspace.core.Context;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.rest.webmvc.ResourceNotFoundException;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.PathVariable;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+/**\n+ * This controller will handle all the incoming calls on the /api/core/metadatafields/name/<:metadata-field-full-name>\n+ * endpoint where the metadata-field-full-name parameter can be filled in to match a specific metadata field by name\n+ * There's always at most one metadata field per name.\n+ * <p>\n+ * It responds with:\n+ * <p>\n+ * The single metadata field if there's a match\n+ * 404 if the metadata field doesn't exist\n+ *\n+ * @author Maria Verdonck (Atmire) on 17/07/2020\n+ */\n+@RestController\n+@RequestMapping(\"/api/\" + MetadataFieldRest.CATEGORY + \"/\" + MetadataFieldRest.NAME_PLURAL)\n+public class MetadataFieldNameRestController {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTczNDA5Nw=="}, "originalCommit": null, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MjU5MDIyOnYy", "diffSide": "RIGHT", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/MetadataFieldNameRestControllerIT.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNzowMzoyMlrOG4WGBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNzowMzoyMlrOG4WGBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTczNTQyOQ==", "bodyText": "These tests can also be removed when the Controller is removed", "url": "https://github.com/DSpace/DSpace/pull/2899#discussion_r461735429", "createdAt": "2020-07-28T17:03:22Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/MetadataFieldNameRestControllerIT.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.hamcrest.Matchers.is;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import org.dspace.app.rest.builder.MetadataFieldBuilder;\n+import org.dspace.app.rest.builder.MetadataSchemaBuilder;\n+import org.dspace.app.rest.test.AbstractEntityIntegrationTest;\n+import org.dspace.content.MetadataField;\n+import org.dspace.content.MetadataSchema;\n+import org.junit.Test;\n+\n+/**\n+ * Integration tests for the {@link org.dspace.app.rest.MetadataFieldNameRestController} controlled endpoints\n+ *\n+ * @author Maria Verdonck (Atmire) on 17/07/2020\n+ */\n+public class MetadataFieldNameRestControllerIT extends AbstractEntityIntegrationTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MjYzMDQ4OnYy", "diffSide": "RIGHT", "path": "dspace-api/src/test/java/org/dspace/discovery/MetadataFieldIndexFactoryImplTest.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNzoxNDoyMlrOG4WfLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNToxMzowN1rOHExH7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc0MTg2OQ==", "bodyText": "Would it be possible to add a test (either here or in a separate test file) that proves that newly added or updated MetadataField objects will be automatically reindexed?\nI should know the answer to this, but I'm worried that our MetadataField index might not be automatically updated.  Is it being updated whenever a new field is added (or an existing field is updated)?", "url": "https://github.com/DSpace/DSpace/pull/2899#discussion_r461741869", "createdAt": "2020-07-28T17:14:22Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/test/java/org/dspace/discovery/MetadataFieldIndexFactoryImplTest.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.discovery;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+import org.apache.solr.common.SolrInputDocument;\n+import org.dspace.AbstractUnitTest;\n+import org.dspace.content.MetadataField;\n+import org.dspace.content.MetadataSchema;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.content.service.MetadataFieldService;\n+import org.dspace.content.service.MetadataSchemaService;\n+import org.dspace.discovery.indexobject.IndexableMetadataField;\n+import org.dspace.discovery.indexobject.MetadataFieldIndexFactoryImpl;\n+import org.junit.Test;\n+\n+/**\n+ * Test class for {@link MetadataFieldIndexFactoryImpl}\n+ *\n+ * @author Maria Verdonck (Atmire) on 23/07/2020\n+ */\n+public class MetadataFieldIndexFactoryImplTest extends AbstractUnitTest {\n+    private MetadataSchemaService metadataSchemaService =\n+        ContentServiceFactory.getInstance().getMetadataSchemaService();\n+    private MetadataFieldService metadataFieldService = ContentServiceFactory.getInstance().getMetadataFieldService();\n+\n+    private String schemaName = \"schema1\";\n+    private String elemName1 = \"elem1\";\n+    private String elemName2 = \"elem2\";\n+    private String qualName1 = \"qual1\";\n+\n+    private MetadataSchema schema;\n+    private MetadataField field1;\n+    private MetadataField field2;\n+\n+    @Test\n+    public void test_buildDocument_withQualifier() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk0MjIzNQ==", "bodyText": "@tdonohue Good call that we did not have a test for this. This indeed was not automatically updated on updates of the metadata fields. The tests have been updated to make sure that the index-discovery isn't run during the test (Which was the case previously, making sure that the fields were indexed).\nUpdates of the metafataFields trigger the indexing of those fields. (As you might have noticed, this now fails the build because of hibernate problems, which will need to be looked into)\nTo make sure only metadatafields are updated, the following method is called\nThat being said, we would need to find a more generic solution to make sure that, when an indexable object has been changed, that it is also actually indexed automatically.\nBy default, the consumers catch/handle these events, but that does not take into account that more IndexableObject implementation are created in the future.", "url": "https://github.com/DSpace/DSpace/pull/2899#discussion_r462942235", "createdAt": "2020-07-30T11:52:06Z", "author": {"login": "jonas-atmire"}, "path": "dspace-api/src/test/java/org/dspace/discovery/MetadataFieldIndexFactoryImplTest.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.discovery;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+import org.apache.solr.common.SolrInputDocument;\n+import org.dspace.AbstractUnitTest;\n+import org.dspace.content.MetadataField;\n+import org.dspace.content.MetadataSchema;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.content.service.MetadataFieldService;\n+import org.dspace.content.service.MetadataSchemaService;\n+import org.dspace.discovery.indexobject.IndexableMetadataField;\n+import org.dspace.discovery.indexobject.MetadataFieldIndexFactoryImpl;\n+import org.junit.Test;\n+\n+/**\n+ * Test class for {@link MetadataFieldIndexFactoryImpl}\n+ *\n+ * @author Maria Verdonck (Atmire) on 23/07/2020\n+ */\n+public class MetadataFieldIndexFactoryImplTest extends AbstractUnitTest {\n+    private MetadataSchemaService metadataSchemaService =\n+        ContentServiceFactory.getInstance().getMetadataSchemaService();\n+    private MetadataFieldService metadataFieldService = ContentServiceFactory.getInstance().getMetadataFieldService();\n+\n+    private String schemaName = \"schema1\";\n+    private String elemName1 = \"elem1\";\n+    private String elemName2 = \"elem2\";\n+    private String qualName1 = \"qual1\";\n+\n+    private MetadataSchema schema;\n+    private MetadataField field1;\n+    private MetadataField field2;\n+\n+    @Test\n+    public void test_buildDocument_withQualifier() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc0MTg2OQ=="}, "originalCommit": null, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAwNDg0MQ==", "bodyText": "this is a very nice PR but I worry if we are adding a too risky change compared to the benefit of the feature itself. I don't like the idea to index things in two different way, a sync call here and the event consumer for all the other stuff.\nMaybe a solution could be to raise an Event about the SiteObject and have the consumer to process such event. This would be similar to how the workflow/tasks are indexed due to an event on the underline Item. In the detailed information we could eventually decide to pass the information METADATAFIELD:ID to allow a more granular control instead than force to reindex all the metadata each time", "url": "https://github.com/DSpace/DSpace/pull/2899#discussion_r474004841", "createdAt": "2020-08-20T13:58:52Z", "author": {"login": "abollini"}, "path": "dspace-api/src/test/java/org/dspace/discovery/MetadataFieldIndexFactoryImplTest.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.discovery;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+import org.apache.solr.common.SolrInputDocument;\n+import org.dspace.AbstractUnitTest;\n+import org.dspace.content.MetadataField;\n+import org.dspace.content.MetadataSchema;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.content.service.MetadataFieldService;\n+import org.dspace.content.service.MetadataSchemaService;\n+import org.dspace.discovery.indexobject.IndexableMetadataField;\n+import org.dspace.discovery.indexobject.MetadataFieldIndexFactoryImpl;\n+import org.junit.Test;\n+\n+/**\n+ * Test class for {@link MetadataFieldIndexFactoryImpl}\n+ *\n+ * @author Maria Verdonck (Atmire) on 23/07/2020\n+ */\n+public class MetadataFieldIndexFactoryImplTest extends AbstractUnitTest {\n+    private MetadataSchemaService metadataSchemaService =\n+        ContentServiceFactory.getInstance().getMetadataSchemaService();\n+    private MetadataFieldService metadataFieldService = ContentServiceFactory.getInstance().getMetadataFieldService();\n+\n+    private String schemaName = \"schema1\";\n+    private String elemName1 = \"elem1\";\n+    private String elemName2 = \"elem2\";\n+    private String qualName1 = \"qual1\";\n+\n+    private MetadataSchema schema;\n+    private MetadataField field1;\n+    private MetadataField field2;\n+\n+    @Test\n+    public void test_buildDocument_withQualifier() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc0MTg2OQ=="}, "originalCommit": null, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEzMjcwNQ==", "bodyText": "@jonas-atmire : I agree with @abollini's notes above.  Rather than trying to find a new way to automatically update the MetadataField index each time a field is added/removed/updated, let's try to rework this to use the existing consumer-based approach.\nSo, as @abollini suggested, we could consider this a Site-level event (as Metadata Fields and Schemas arguably \"belong\" to the entire Site, and not an individual object in the Site).  So, that may mean we need to either create a new SiteConsumer which can be notified of MetadataField changes... or, perhaps we just update the existing IndexEventConsumer to support the Site object as well.  If we choose the latter, we may be able to trigger a Event.MODIFY or Event.MODIFY_METADATA on the Site object, passing it the METADATAFIELD:[ID] to trigger a reindex of that single field, or perhaps METADATASCHEMA:[ID] to reindex all fields in a schema.", "url": "https://github.com/DSpace/DSpace/pull/2899#discussion_r474132705", "createdAt": "2020-08-20T16:48:42Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/test/java/org/dspace/discovery/MetadataFieldIndexFactoryImplTest.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.discovery;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+import org.apache.solr.common.SolrInputDocument;\n+import org.dspace.AbstractUnitTest;\n+import org.dspace.content.MetadataField;\n+import org.dspace.content.MetadataSchema;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.content.service.MetadataFieldService;\n+import org.dspace.content.service.MetadataSchemaService;\n+import org.dspace.discovery.indexobject.IndexableMetadataField;\n+import org.dspace.discovery.indexobject.MetadataFieldIndexFactoryImpl;\n+import org.junit.Test;\n+\n+/**\n+ * Test class for {@link MetadataFieldIndexFactoryImpl}\n+ *\n+ * @author Maria Verdonck (Atmire) on 23/07/2020\n+ */\n+public class MetadataFieldIndexFactoryImplTest extends AbstractUnitTest {\n+    private MetadataSchemaService metadataSchemaService =\n+        ContentServiceFactory.getInstance().getMetadataSchemaService();\n+    private MetadataFieldService metadataFieldService = ContentServiceFactory.getInstance().getMetadataFieldService();\n+\n+    private String schemaName = \"schema1\";\n+    private String elemName1 = \"elem1\";\n+    private String elemName2 = \"elem2\";\n+    private String qualName1 = \"qual1\";\n+\n+    private MetadataSchema schema;\n+    private MetadataField field1;\n+    private MetadataField field2;\n+\n+    @Test\n+    public void test_buildDocument_withQualifier() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc0MTg2OQ=="}, "originalCommit": null, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc2MTE5OA==", "bodyText": "@abollini , @tdonohue : I refactored the indexing of the metadata fields via a SITE MODIFY event => IndexEventConsumer as you suggested (see latest commit), which has fortunately resolved the hibernate issues.\nEach create/update/delete of metadata field calls a MODIFY SITE event with the identifier of the changed mdField, so it can be indexed in the consumer, with type of IndexableObject in Event.detail and the identifier of the changed mdField in Event.identifiers", "url": "https://github.com/DSpace/DSpace/pull/2899#discussion_r474761198", "createdAt": "2020-08-21T15:13:07Z", "author": {"login": "MarieVerdonck"}, "path": "dspace-api/src/test/java/org/dspace/discovery/MetadataFieldIndexFactoryImplTest.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.discovery;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+import org.apache.solr.common.SolrInputDocument;\n+import org.dspace.AbstractUnitTest;\n+import org.dspace.content.MetadataField;\n+import org.dspace.content.MetadataSchema;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.content.service.MetadataFieldService;\n+import org.dspace.content.service.MetadataSchemaService;\n+import org.dspace.discovery.indexobject.IndexableMetadataField;\n+import org.dspace.discovery.indexobject.MetadataFieldIndexFactoryImpl;\n+import org.junit.Test;\n+\n+/**\n+ * Test class for {@link MetadataFieldIndexFactoryImpl}\n+ *\n+ * @author Maria Verdonck (Atmire) on 23/07/2020\n+ */\n+public class MetadataFieldIndexFactoryImplTest extends AbstractUnitTest {\n+    private MetadataSchemaService metadataSchemaService =\n+        ContentServiceFactory.getInstance().getMetadataSchemaService();\n+    private MetadataFieldService metadataFieldService = ContentServiceFactory.getInstance().getMetadataFieldService();\n+\n+    private String schemaName = \"schema1\";\n+    private String elemName1 = \"elem1\";\n+    private String elemName2 = \"elem2\";\n+    private String qualName1 = \"qual1\";\n+\n+    private MetadataSchema schema;\n+    private MetadataField field1;\n+    private MetadataField field2;\n+\n+    @Test\n+    public void test_buildDocument_withQualifier() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc0MTg2OQ=="}, "originalCommit": null, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MjY0NTk1OnYy", "diffSide": "RIGHT", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/MetadatafieldRestRepositoryIT.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNzoxODoxNlrOG4Wotw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNzoxODoxNlrOG4Wotw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc0NDMxMQ==", "bodyText": "It looks like we're missing a test that uses schema, element and qualifier together to select a single unique MetadataField.  Could you add that in as well?", "url": "https://github.com/DSpace/DSpace/pull/2899#discussion_r461744311", "createdAt": "2020-07-28T17:18:16Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/MetadatafieldRestRepositoryIT.java", "diffHunk": "@@ -168,6 +172,261 @@ public void findByNullSchema() throws Exception {\n                    .andExpect(status().isBadRequest());\n     }\n \n+    @Test\n+    public void findByFieldName_schema() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        MetadataSchema schema = MetadataSchemaBuilder.createMetadataSchema(context, \"ASchema\",\n+            \"http://www.dspace.org/ns/aschema\").build();\n+\n+        MetadataField metadataField = MetadataFieldBuilder\n+            .createMetadataField(context, schema, \"AnElement\", \"AQualifier\", \"AScopeNote\").build();\n+\n+        context.restoreAuthSystemState();\n+\n+        super.runDSpaceScript(\"index-discovery\", \"-b\");\n+\n+        getClient().perform(get(SEARCH_BYFIELDNAME_ENDPOINT)\n+            .param(\"schema\", schema.getName()))\n+                   .andExpect(status().isOk())\n+                   .andExpect(content().contentType(contentType))\n+                   .andExpect(jsonPath(\"$._embedded.metadatafields\", Matchers.hasItem(\n+                       MetadataFieldMatcher.matchMetadataField(metadataField))\n+                                      ))\n+                   .andExpect(jsonPath(\"$.page.size\", is(20)))\n+                   .andExpect(jsonPath(\"$.page.totalElements\", is(1)));\n+    }\n+\n+    @Test\n+    public void findByFieldName_element() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        MetadataSchema schema = MetadataSchemaBuilder.createMetadataSchema(context, \"ASchema\",\n+            \"http://www.dspace.org/ns/aschema\").build();\n+        MetadataSchema schema2 = MetadataSchemaBuilder.createMetadataSchema(context, \"ASchema2\",\n+            \"http://www.dspace.org/ns/aschema2\").build();\n+\n+        MetadataField metadataField = MetadataFieldBuilder\n+            .createMetadataField(context, schema, \"AnElement\", \"AQualifier\", \"AScopeNote\").build();\n+\n+        MetadataField metadataField2 = MetadataFieldBuilder\n+            .createMetadataField(context, schema2, \"AnElement\", \"AQualifier2\", \"AScopeNote2\").build();\n+\n+        context.restoreAuthSystemState();\n+\n+        super.runDSpaceScript(\"index-discovery\", \"-b\");\n+\n+        getClient().perform(get(SEARCH_BYFIELDNAME_ENDPOINT)\n+            .param(\"element\", \"AnElement\"))\n+                   .andExpect(status().isOk())\n+                   .andExpect(content().contentType(contentType))\n+                   .andExpect(jsonPath(\"$._embedded.metadatafields\", Matchers.hasItem(\n+                       MetadataFieldMatcher.matchMetadataField(metadataField))\n+                                      ))\n+                   .andExpect(jsonPath(\"$._embedded.metadatafields\", Matchers.hasItem(\n+                       MetadataFieldMatcher.matchMetadataField(metadataField2))\n+                                      ))\n+                   .andExpect(jsonPath(\"$.page.size\", is(20)))\n+                   .andExpect(jsonPath(\"$.page.totalElements\", is(2)));\n+    }\n+\n+    @Test\n+    public void findByFieldName_elementAndQualifier() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        MetadataSchema schema = MetadataSchemaBuilder.createMetadataSchema(context, \"ASchema\",\n+            \"http://www.dspace.org/ns/aschema\").build();\n+        MetadataSchema schema2 = MetadataSchemaBuilder.createMetadataSchema(context, \"ASchema2\",\n+            \"http://www.dspace.org/ns/aschema2\").build();\n+\n+        MetadataField metadataField = MetadataFieldBuilder\n+            .createMetadataField(context, schema, \"AnElement1\", \"AQualifier\", \"AScopeNote\").build();\n+\n+        MetadataField metadataField2 = MetadataFieldBuilder\n+            .createMetadataField(context, schema2, \"AnElement2\", \"AQualifier\", \"AScopeNote2\").build();\n+\n+        MetadataField metadataField3 = MetadataFieldBuilder\n+            .createMetadataField(context, schema, \"AnElement2\", \"AQualifier\", \"AScopeNote2\").build();\n+\n+        context.restoreAuthSystemState();\n+\n+        super.runDSpaceScript(\"index-discovery\", \"-b\");\n+\n+        getClient().perform(get(SEARCH_BYFIELDNAME_ENDPOINT)\n+            .param(\"element\", \"AnElement2\")\n+            .param(\"qualifier\", \"AQualifier\"))\n+                   .andExpect(status().isOk())\n+                   .andExpect(content().contentType(contentType))\n+                   .andExpect(jsonPath(\"$._embedded.metadatafields\", Matchers.hasItem(\n+                       MetadataFieldMatcher.matchMetadataField(metadataField2))\n+                                      ))\n+                   .andExpect(jsonPath(\"$._embedded.metadatafields\", Matchers.hasItem(\n+                       MetadataFieldMatcher.matchMetadataField(metadataField3))\n+                                      ))\n+                   .andExpect(jsonPath(\"$._embedded.metadatafields\", Matchers.not(hasItem(\n+                       MetadataFieldMatcher.matchMetadataField(metadataField))\n+                                                                                 )))\n+                   .andExpect(jsonPath(\"$.page.size\", is(20)))\n+                   .andExpect(jsonPath(\"$.page.totalElements\", is(2)));\n+    }\n+\n+    @Test\n+    public void findByFieldName_schemaAndQualifier() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        MetadataSchema schema = MetadataSchemaBuilder.createMetadataSchema(context, \"ASchema\",\n+            \"http://www.dspace.org/ns/aschema\").build();\n+        MetadataSchema schema2 = MetadataSchemaBuilder.createMetadataSchema(context, \"ASchema2\",\n+            \"http://www.dspace.org/ns/aschema2\").build();\n+\n+        MetadataField metadataField = MetadataFieldBuilder\n+            .createMetadataField(context, schema, \"AnElement1\", \"AQualifier\", \"AScopeNote\").build();\n+\n+        MetadataField metadataField2 = MetadataFieldBuilder\n+            .createMetadataField(context, schema2, \"AnElement2\", \"AQualifier\", \"AScopeNote2\").build();\n+\n+        MetadataField metadataField3 = MetadataFieldBuilder\n+            .createMetadataField(context, schema, \"AnElement3\", \"AQualifier\", \"AScopeNote3\").build();\n+\n+        context.restoreAuthSystemState();\n+\n+        super.runDSpaceScript(\"index-discovery\", \"-b\");\n+\n+        getClient().perform(get(SEARCH_BYFIELDNAME_ENDPOINT)\n+            .param(\"schema\", schema.getName())\n+            .param(\"qualifier\", \"AQualifier\"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 215}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1587, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}