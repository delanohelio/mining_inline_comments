{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDczOTYyODI4", "number": 2940, "title": "Features endpoint - Edit item permissions in REST", "bodyText": "References\n\nFixes GitHub issue\n\nDescription\nThis PR implements the features:\n\ncanManagePolicies\ncanEditMetadata\ncanMove\ncanMakePrivate\ncanMakeDiscoverable\ncanDelete\ncanReorderBitstreams\ncanCreateBitstream\ncanCreateBundle\n\nThe permissions have been determined based on what's verified in DSpace 6.\nThis also fixes an error with the difference between REMOVE and DELETE policies. REMOVE is based on the parent's permission and DELETE is based on the current DSO's permission, which in itself was implemented correctly. But the ADMIN rights were not consistent with this setup.\nInstructions for Reviewers\nThe code outside the ITs is limited to making the authorizations accessible and fixing some bugs in the API.\nFor the ITs, we created a setup with 2 communities, each with a sub-community, each with a collection, each with an item, each with a bundle, each with a bitstream, e.g. (not displaying bundle and bitstream in the sample below)\n\ncommunity A\n\ncommunity AA\n\ncollection X\n\nitem 1\n\n\n\n\n\n\ncommunity B\n\ncommunity BB\n\ncollection Y\n\nitem 2\n\n\n\n\n\n\n\nWe also created the following users in the setup:\n\ncommunity A admin (in the admin group of this community)\ncollection X admin (in the admin group of this collection)\nitem 1 admin (in the admin group of this item)\ncommunity A write (with write permissions on this community)\ncollection X write (with write permissions on this collection)\nitem 1 write (with write permissions on this item)\n\nTo ease the tests, we created a few common methods to verify whether admins have permissions for a specific feature, and to verify whether people with WRITE access have permissions for a specific feature.\nChecklist\nThis checklist provides a reminder of what we are going to look for when reviewing your PR. You need not complete this checklist prior to creating your PR (draft PRs are always welcome). If you are unsure about an item in the checklist, don't hesitate to ask. We're here to help!\n\n My PR is small in size (e.g. less than 1,000 lines of code, not including comments & integration tests). Exceptions may be made if previously agreed upon.\n My PR passes Checkstyle validation based on the Code Style Guide.\n My PR includes Javadoc for all new (or modified) public methods and classes. It also includes Javadoc for large or complex private methods.\n My PR passes all tests and includes new/updated Unit or Integration Tests based on the Code Testing Guide.\n If my PR includes new, third-party dependencies (in any pom.xml), I've made sure their licenses align with the DSpace BSD License based on the Licensing of Contributions documentation.\n If my PR modifies the REST API, I've linked to the REST Contract page (or open PR) related to this change.", "createdAt": "2020-08-26T14:52:47Z", "url": "https://github.com/DSpace/DSpace/pull/2940", "merged": true, "mergeCommit": {"oid": "afb78e1e0377464a559785fbe1312fdc7df77ec1"}, "closed": true, "closedAt": "2020-09-23T21:40:51Z", "author": {"login": "benbosman"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc-hX1KgH2gAyNDczOTYyODI4OmZhMmQyOGJiMjY4OGJhOTZiM2NiMzZlZjZhOTI2NjkwNGNiZGE1YzY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdLzoXXgFqTQ5NTA2ODAzOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "fa2d28bb2688ba96b3cb36ef6a9266904cbda5c6", "author": {"user": {"login": "peter-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/fa2d28bb2688ba96b3cb36ef6a9266904cbda5c6", "committedDate": "2020-08-13T15:02:17Z", "message": "72492: Implement authorization features for edit item in REST"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1e19c9e1ab26714458d6dcaa4582a297cf0d77c1", "author": {"user": {"login": "peter-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/1e19c9e1ab26714458d6dcaa4582a297cf0d77c1", "committedDate": "2020-08-18T16:24:48Z", "message": "72492: Implement authorization features for edit item in REST"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d83f43f017a43e6389e4b1fb3d94dc2e08f97ec8", "author": {"user": {"login": "peter-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/d83f43f017a43e6389e4b1fb3d94dc2e08f97ec8", "committedDate": "2020-08-24T08:12:49Z", "message": "72516: ITs for authorization features for edit item in REST"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fae212d281fa5694343e44f08587d1fb6a708abd", "author": {"user": {"login": "peter-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/fae212d281fa5694343e44f08587d1fb6a708abd", "committedDate": "2020-08-25T15:39:50Z", "message": "72517: ITs for authorization features for edit item in REST\n\n- Fix for getItemObject() in ItemServiceImpl and CommunityServiceImpl for DELETE actions"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMjU1MTEz", "url": "https://github.com/DSpace/DSpace/pull/2940#pullrequestreview-481255113", "createdAt": "2020-09-02T19:59:08Z", "commit": {"oid": "fae212d281fa5694343e44f08587d1fb6a708abd"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxOTo1OTowOFrOHMCI2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMTowMjoyNlrOHMHUiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjM3OTk5NA==", "bodyText": "Could we add an inline comment to describe this if?  I'm not sure I understand why we are checking if the permission check is on an Item, but not a READ and Item is not archived and not withdrawn.  What is the scenario we are validating here?", "url": "https://github.com/DSpace/DSpace/pull/2940#discussion_r482379994", "createdAt": "2020-09-02T19:59:08Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/authorization/AuthorizeServiceRestUtil.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.authorization;\n+\n+import java.sql.SQLException;\n+\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.app.rest.security.DSpaceRestPermission;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.authorize.service.AuthorizeService;\n+import org.dspace.content.DSpaceObject;\n+import org.dspace.content.Item;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.content.service.DSpaceObjectService;\n+import org.dspace.core.Context;\n+import org.dspace.eperson.EPerson;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+\n+/**\n+ * This class is a wrapper around the AuthorizationService which takes Rest objects instead of dspace objects\n+ */\n+@Component\n+public class AuthorizeServiceRestUtil {\n+    @Autowired\n+    private AuthorizeService authorizeService;\n+    @Autowired\n+    private Utils utils;\n+    @Autowired\n+    private ContentServiceFactory contentServiceFactory;\n+\n+    /**\n+     * Checks that the specified eperson can perform the given action on the rest given object.\n+     *\n+     * @param context               DSpace context\n+     * @param object                The Rest object to test the action against\n+     * @param dSpaceRestPermission  The permission to check\n+     * @return A boolean indicating if the action is allowed by the logged in ePerson on the given object\n+     * @throws SQLException\n+     */\n+    public boolean authorizeActionBoolean(Context context, BaseObjectRest object,\n+                                          DSpaceRestPermission dSpaceRestPermission)\n+        throws SQLException {\n+\n+        DSpaceObject dSpaceObject = (DSpaceObject)utils.getDSpaceAPIObjectFromRest(context, object);\n+        if (dSpaceObject == null) {\n+            return false;\n+        }\n+\n+        DSpaceObjectService<DSpaceObject> dSpaceObjectService =\n+            contentServiceFactory.getDSpaceObjectService(dSpaceObject.getType());\n+\n+        EPerson ePerson = context.getCurrentUser();\n+\n+        if (dSpaceObjectService != null) {\n+            if (dSpaceObject instanceof Item) {\n+                if (!DSpaceRestPermission.READ.equals(dSpaceRestPermission)\n+                    && !((Item) dSpaceObject).isArchived() && !((Item) dSpaceObject).isWithdrawn()) {\n+                    return false;\n+                }\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fae212d281fa5694343e44f08587d1fb6a708abd"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjM4ODI1MQ==", "bodyText": "I'd appreciate it if we could add Comments either to the method or the Feature Class to describe what permissions are required for the Feature to return true.\nSo, for this one, it looks like in order to Create a Bitstream..You MUST have both WRITE and ADD on the Bundle which the Item is being added to, AND have WRITE and ADD on the Item.", "url": "https://github.com/DSpace/DSpace/pull/2940#discussion_r482388251", "createdAt": "2020-09-02T20:05:21Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/authorization/impl/CreateBitstreamFeature.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.authorization.impl;\n+\n+import java.sql.SQLException;\n+\n+import org.apache.log4j.Logger;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureDocumentation;\n+import org.dspace.app.rest.authorization.AuthorizeServiceRestUtil;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.app.rest.model.BundleRest;\n+import org.dspace.app.rest.security.DSpaceRestPermission;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.authorize.service.AuthorizeService;\n+import org.dspace.content.Bundle;\n+import org.dspace.content.DSpaceObject;\n+import org.dspace.content.Item;\n+import org.dspace.content.service.BundleService;\n+import org.dspace.core.Constants;\n+import org.dspace.core.Context;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+\n+/**\n+ * The create bitstream feature. It can be used to verify if bitstreams can be created in a specific bundle.\n+ */\n+@Component\n+@AuthorizationFeatureDocumentation(name = CreateBitstreamFeature.NAME,\n+    description = \"It can be used to verify if bitstreams can be created in a specific bundle\")\n+public class CreateBitstreamFeature implements AuthorizationFeature {\n+\n+    Logger log = Logger.getLogger(CreateBitstreamFeature.class);\n+\n+    public final static String NAME = \"canCreateBitstream\";\n+\n+    @Autowired\n+    private AuthorizeServiceRestUtil authorizeServiceRestUtil;\n+    @Autowired\n+    private BundleService bundleService;\n+    @Autowired\n+    private Utils utils;\n+    @Autowired\n+    private AuthorizeService authorizeService;\n+\n+    @Override\n+    public boolean isAuthorized(Context context, BaseObjectRest object) throws SQLException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fae212d281fa5694343e44f08587d1fb6a708abd"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjM5NDM1Mg==", "bodyText": "I don't understand this scenario (sidenote, there's a misspelling here: \"partent\").  Isn't a Bundle always under an Item?\nIs this just some sort of safety check to verify we never have an \"unattached\" Bundle?  If there's a scenario I'm not thinking of, then maybe we should add an inline comment here (or again, describe above the method or class what scenarios/permissions this Feature is checking for)", "url": "https://github.com/DSpace/DSpace/pull/2940#discussion_r482394352", "createdAt": "2020-09-02T20:09:46Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/authorization/impl/CreateBitstreamFeature.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.authorization.impl;\n+\n+import java.sql.SQLException;\n+\n+import org.apache.log4j.Logger;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureDocumentation;\n+import org.dspace.app.rest.authorization.AuthorizeServiceRestUtil;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.app.rest.model.BundleRest;\n+import org.dspace.app.rest.security.DSpaceRestPermission;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.authorize.service.AuthorizeService;\n+import org.dspace.content.Bundle;\n+import org.dspace.content.DSpaceObject;\n+import org.dspace.content.Item;\n+import org.dspace.content.service.BundleService;\n+import org.dspace.core.Constants;\n+import org.dspace.core.Context;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+\n+/**\n+ * The create bitstream feature. It can be used to verify if bitstreams can be created in a specific bundle.\n+ */\n+@Component\n+@AuthorizationFeatureDocumentation(name = CreateBitstreamFeature.NAME,\n+    description = \"It can be used to verify if bitstreams can be created in a specific bundle\")\n+public class CreateBitstreamFeature implements AuthorizationFeature {\n+\n+    Logger log = Logger.getLogger(CreateBitstreamFeature.class);\n+\n+    public final static String NAME = \"canCreateBitstream\";\n+\n+    @Autowired\n+    private AuthorizeServiceRestUtil authorizeServiceRestUtil;\n+    @Autowired\n+    private BundleService bundleService;\n+    @Autowired\n+    private Utils utils;\n+    @Autowired\n+    private AuthorizeService authorizeService;\n+\n+    @Override\n+    public boolean isAuthorized(Context context, BaseObjectRest object) throws SQLException {\n+        if (object instanceof BundleRest) {\n+            if (!authorizeServiceRestUtil.authorizeActionBoolean(context, object, DSpaceRestPermission.WRITE)) {\n+                return false;\n+            }\n+            if (!authorizeServiceRestUtil.authorizeActionBoolean(context, object, DSpaceRestPermission.ADD)) {\n+                return false;\n+            }\n+\n+            DSpaceObject owningObject = bundleService.getParentObject(context,\n+                (Bundle)utils.getDSpaceAPIObjectFromRest(context, object));\n+\n+            if (!(owningObject instanceof Item)) {\n+                log.error(\"The partent object of bundle \" + object.getType() + \" is not an item\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fae212d281fa5694343e44f08587d1fb6a708abd"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjM5NzA2OQ==", "bodyText": "Again, would be good to add a comment to describe. In this scenario, it looks like you can Create a Bundle as long as you have WRITE and ADD on the Item.", "url": "https://github.com/DSpace/DSpace/pull/2940#discussion_r482397069", "createdAt": "2020-09-02T20:11:50Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/authorization/impl/CreateBundleFeature.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.authorization.impl;\n+\n+import java.sql.SQLException;\n+\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureDocumentation;\n+import org.dspace.app.rest.authorization.AuthorizeServiceRestUtil;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.app.rest.model.ItemRest;\n+import org.dspace.app.rest.security.DSpaceRestPermission;\n+import org.dspace.core.Context;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+\n+/**\n+ * The create bundle feature. It can be used to verify if bundles can be created in a specific item.\n+ */\n+@Component\n+@AuthorizationFeatureDocumentation(name = CreateBundleFeature.NAME,\n+    description = \"It can be used to verify if bundles can be created in a specific item\")\n+public class CreateBundleFeature implements AuthorizationFeature {\n+\n+    public final static String NAME = \"canCreateBundle\";\n+\n+    @Autowired\n+    private AuthorizeServiceRestUtil authorizeServiceRestUtil;\n+\n+    @Override\n+    public boolean isAuthorized(Context context, BaseObjectRest object) throws SQLException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fae212d281fa5694343e44f08587d1fb6a708abd"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjM5OTAxMg==", "bodyText": "Again, adding comments on how this returns true would be useful. In this case, since the method is bigger (and it manages several object types), you could just add them inline.\n(I'll stop adding this same comment now... it applies to all these new Feature classes though)", "url": "https://github.com/DSpace/DSpace/pull/2940#discussion_r482399012", "createdAt": "2020-09-02T20:13:21Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/authorization/impl/DeleteFeature.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.authorization.impl;\n+\n+import java.sql.SQLException;\n+\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureDocumentation;\n+import org.dspace.app.rest.authorization.AuthorizeServiceRestUtil;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.app.rest.model.BitstreamRest;\n+import org.dspace.app.rest.model.BundleRest;\n+import org.dspace.app.rest.model.CollectionRest;\n+import org.dspace.app.rest.model.CommunityRest;\n+import org.dspace.app.rest.model.EPersonRest;\n+import org.dspace.app.rest.model.GroupRest;\n+import org.dspace.app.rest.model.ItemRest;\n+import org.dspace.app.rest.model.WorkspaceItemRest;\n+import org.dspace.app.rest.security.DSpaceRestPermission;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.authorize.service.AuthorizeService;\n+import org.dspace.content.DSpaceObject;\n+import org.dspace.content.Item;\n+import org.dspace.content.WorkspaceItem;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.core.Constants;\n+import org.dspace.core.Context;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+\n+/**\n+ * The delete feature. It can be used to verify if specific content can be deleted/expunged.\n+ */\n+@Component\n+@AuthorizationFeatureDocumentation(name = DeleteFeature.NAME,\n+    description = \"It can be used to verify if specific content can be deleted/expunged\")\n+public class DeleteFeature implements AuthorizationFeature {\n+\n+    public final static String NAME = \"canDelete\";\n+\n+    @Autowired\n+    private AuthorizeServiceRestUtil authorizeServiceRestUtil;\n+    @Autowired\n+    private Utils utils;\n+    @Autowired\n+    private AuthorizeService authorizeService;\n+    @Autowired\n+    private ContentServiceFactory contentServiceFactory;\n+\n+    @Override\n+    public boolean isAuthorized(Context context, BaseObjectRest object) throws SQLException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fae212d281fa5694343e44f08587d1fb6a708abd"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQwMzM2MA==", "bodyText": "You don't need to save the old value of the configuration and reset it.  The entire ConfigurationService should auto-reload between tests, thus resetting all configs back to the defaults.  So, you can remove this destroy and the global originalAlwaysThrowException variable", "url": "https://github.com/DSpace/DSpace/pull/2940#discussion_r482403360", "createdAt": "2020-09-02T20:16:42Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/authorization/GenericAuthorizationFeatureIT.java", "diffHunk": "@@ -0,0 +1,1709 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.authorization;\n+\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.io.InputStream;\n+\n+import org.apache.commons.codec.CharEncoding;\n+import org.apache.commons.io.IOUtils;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.authorize.ResourcePolicy;\n+import org.dspace.builder.BitstreamBuilder;\n+import org.dspace.builder.BundleBuilder;\n+import org.dspace.builder.CollectionBuilder;\n+import org.dspace.builder.CommunityBuilder;\n+import org.dspace.builder.EPersonBuilder;\n+import org.dspace.builder.GroupBuilder;\n+import org.dspace.builder.ItemBuilder;\n+import org.dspace.builder.ResourcePolicyBuilder;\n+import org.dspace.content.Bitstream;\n+import org.dspace.content.Bundle;\n+import org.dspace.content.Collection;\n+import org.dspace.content.Community;\n+import org.dspace.content.Item;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.core.Constants;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.Group;\n+import org.dspace.services.ConfigurationService;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+/**\n+ * Test for the following authorization features:\n+ *     canManagePolicies\n+ *     canEditMetadata\n+ *     canMove\n+ *     canMakePrivate\n+ *     canMakeDiscoverable\n+ *     canDelete\n+ *     canReorderBitstreams\n+ *     canCreateBitstream\n+ *     canCreateBundle\n+ */\n+public class GenericAuthorizationFeatureIT extends AbstractControllerIntegrationTest {\n+\n+    @Autowired\n+    ConfigurationService configurationService;\n+\n+    private Community communityA;\n+    private Community communityAA;\n+    private Community communityB;\n+    private Community communityBB;\n+    private Collection collectionX;\n+    private Collection collectionY;\n+    private Item item1;\n+    private Item item2;\n+    private Bundle bundle1;\n+    private Bundle bundle2;\n+    private Bitstream bitstream1;\n+    private Bitstream bitstream2;\n+\n+    private Group item1AdminGroup;\n+\n+    private EPerson communityAAdmin;\n+    private EPerson collectionXAdmin;\n+    private EPerson item1Admin;\n+    private EPerson communityAWriter;\n+    private EPerson collectionXWriter;\n+    private EPerson item1Writer;\n+\n+    boolean originalAlwaysThrowException;\n+\n+    @Override\n+    @Before\n+    public void setUp() throws Exception {\n+        super.setUp();\n+\n+        context.turnOffAuthorisationSystem();\n+\n+        communityAAdmin = EPersonBuilder.createEPerson(context)\n+            .withNameInMetadata(\"Jhon\", \"Brown\")\n+            .withEmail(\"communityAAdmin@my.edu\")\n+            .withPassword(password)\n+            .build();\n+        collectionXAdmin = EPersonBuilder.createEPerson(context)\n+            .withNameInMetadata(\"Jhon\", \"Brown\")\n+            .withEmail(\"collectionXAdmin@my.edu\")\n+            .withPassword(password)\n+            .build();\n+        item1Admin = EPersonBuilder.createEPerson(context)\n+            .withNameInMetadata(\"Jhon\", \"Brown\")\n+            .withEmail(\"item1Admin@my.edu\")\n+            .withPassword(password)\n+            .build();\n+        communityAWriter = EPersonBuilder.createEPerson(context)\n+            .withNameInMetadata(\"Jhon\", \"Brown\")\n+            .withEmail(\"communityAWriter@my.edu\")\n+            .withPassword(password)\n+            .build();\n+        collectionXWriter = EPersonBuilder.createEPerson(context)\n+            .withNameInMetadata(\"Jhon\", \"Brown\")\n+            .withEmail(\"collectionXWriter@my.edu\")\n+            .withPassword(password)\n+            .build();\n+        item1Writer = EPersonBuilder.createEPerson(context)\n+            .withNameInMetadata(\"Jhon\", \"Brown\")\n+            .withEmail(\"item1Writer@my.edu\")\n+            .withPassword(password)\n+            .build();\n+\n+        communityA = CommunityBuilder.createCommunity(context)\n+            .withName(\"communityA\")\n+            .withAdminGroup(communityAAdmin)\n+            .build();\n+        communityAA = CommunityBuilder.createCommunity(context)\n+            .withName(\"communityAA\")\n+            .addParentCommunity(context, communityA)\n+            .build();\n+        collectionX = CollectionBuilder.createCollection(context, communityAA)\n+            .withName(\"collectionX\")\n+            .withAdminGroup(collectionXAdmin)\n+            .build();\n+        item1 = ItemBuilder.createItem(context, collectionX)\n+            .withTitle(\"item1\")\n+            .withIssueDate(\"2020-07-08\")\n+            .withAuthor(\"Smith, Donald\").withAuthor(\"Doe, John\")\n+            .withSubject(\"item1Entry\")\n+            .build();\n+        bundle1 = BundleBuilder.createBundle(context, item1)\n+            .withName(\"bundle1\")\n+            .build();\n+        try (InputStream is = IOUtils.toInputStream(\"randomContent\", CharEncoding.UTF_8)) {\n+            bitstream1 = BitstreamBuilder.createBitstream(context, bundle1, is)\n+                .withName(\"bitstream1\")\n+                .withMimeType(\"text/plain\")\n+                .build();\n+        }\n+\n+        item1AdminGroup = GroupBuilder.createGroup(context)\n+            .withName(\"item1AdminGroup\")\n+            .addMember(item1Admin)\n+            .build();\n+        ResourcePolicyBuilder.createResourcePolicy(context)\n+            .withDspaceObject(item1)\n+            .withAction(Constants.ADMIN)\n+            .withGroup(item1AdminGroup)\n+            .build();\n+        ResourcePolicyBuilder.createResourcePolicy(context)\n+            .withDspaceObject(communityA)\n+            .withAction(Constants.WRITE)\n+            .withUser(communityAWriter)\n+            .build();\n+        ResourcePolicyBuilder.createResourcePolicy(context)\n+            .withDspaceObject(collectionX)\n+            .withAction(Constants.WRITE)\n+            .withUser(collectionXWriter)\n+            .build();\n+        ResourcePolicyBuilder.createResourcePolicy(context)\n+            .withDspaceObject(item1)\n+            .withAction(Constants.WRITE)\n+            .withUser(item1Writer)\n+            .build();\n+\n+        communityB = CommunityBuilder.createCommunity(context)\n+            .withName(\"communityB\")\n+            .build();\n+        communityBB = CommunityBuilder.createCommunity(context)\n+            .withName(\"communityBB\")\n+            .addParentCommunity(context, communityB)\n+            .build();\n+        collectionY = CollectionBuilder.createCollection(context, communityBB)\n+            .withName(\"collectionY\")\n+            .build();\n+        item2 = ItemBuilder.createItem(context, collectionY)\n+            .withTitle(\"item2\")\n+            .withIssueDate(\"2020-07-08\")\n+            .withAuthor(\"Smith, Donald\").withAuthor(\"Doe, John\")\n+            .withSubject(\"item2Entry\")\n+            .build();\n+        bundle2 = BundleBuilder.createBundle(context, item2)\n+            .withName(\"bundle2\")\n+            .build();\n+        try (InputStream is = IOUtils.toInputStream(\"randomContent\", CharEncoding.UTF_8)) {\n+            bitstream2 = BitstreamBuilder.createBitstream(context, bundle2, is)\n+                .withName(\"bitstream2\")\n+                .withMimeType(\"text/plain\")\n+                .build();\n+        }\n+\n+        context.restoreAuthSystemState();\n+\n+        originalAlwaysThrowException = configurationService.getBooleanProperty(\n+            \"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", false);\n+        configurationService.setProperty(\n+            \"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", \"true\");\n+    }\n+\n+    @Override\n+    @After\n+    public void destroy() throws Exception {\n+        configurationService.setProperty(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fae212d281fa5694343e44f08587d1fb6a708abd"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQ2NDM5OQ==", "bodyText": "I don't think you need these lines. Since you created removePermission from ResourcePolicyBuilder, it should be cleaned up automatically.", "url": "https://github.com/DSpace/DSpace/pull/2940#discussion_r482464399", "createdAt": "2020-09-02T21:02:03Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/authorization/GenericAuthorizationFeatureIT.java", "diffHunk": "@@ -0,0 +1,1709 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.authorization;\n+\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.io.InputStream;\n+\n+import org.apache.commons.codec.CharEncoding;\n+import org.apache.commons.io.IOUtils;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.authorize.ResourcePolicy;\n+import org.dspace.builder.BitstreamBuilder;\n+import org.dspace.builder.BundleBuilder;\n+import org.dspace.builder.CollectionBuilder;\n+import org.dspace.builder.CommunityBuilder;\n+import org.dspace.builder.EPersonBuilder;\n+import org.dspace.builder.GroupBuilder;\n+import org.dspace.builder.ItemBuilder;\n+import org.dspace.builder.ResourcePolicyBuilder;\n+import org.dspace.content.Bitstream;\n+import org.dspace.content.Bundle;\n+import org.dspace.content.Collection;\n+import org.dspace.content.Community;\n+import org.dspace.content.Item;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.core.Constants;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.Group;\n+import org.dspace.services.ConfigurationService;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+/**\n+ * Test for the following authorization features:\n+ *     canManagePolicies\n+ *     canEditMetadata\n+ *     canMove\n+ *     canMakePrivate\n+ *     canMakeDiscoverable\n+ *     canDelete\n+ *     canReorderBitstreams\n+ *     canCreateBitstream\n+ *     canCreateBundle\n+ */\n+public class GenericAuthorizationFeatureIT extends AbstractControllerIntegrationTest {\n+\n+    @Autowired\n+    ConfigurationService configurationService;\n+\n+    private Community communityA;\n+    private Community communityAA;\n+    private Community communityB;\n+    private Community communityBB;\n+    private Collection collectionX;\n+    private Collection collectionY;\n+    private Item item1;\n+    private Item item2;\n+    private Bundle bundle1;\n+    private Bundle bundle2;\n+    private Bitstream bitstream1;\n+    private Bitstream bitstream2;\n+\n+    private Group item1AdminGroup;\n+\n+    private EPerson communityAAdmin;\n+    private EPerson collectionXAdmin;\n+    private EPerson item1Admin;\n+    private EPerson communityAWriter;\n+    private EPerson collectionXWriter;\n+    private EPerson item1Writer;\n+\n+    boolean originalAlwaysThrowException;\n+\n+    @Override\n+    @Before\n+    public void setUp() throws Exception {\n+        super.setUp();\n+\n+        context.turnOffAuthorisationSystem();\n+\n+        communityAAdmin = EPersonBuilder.createEPerson(context)\n+            .withNameInMetadata(\"Jhon\", \"Brown\")\n+            .withEmail(\"communityAAdmin@my.edu\")\n+            .withPassword(password)\n+            .build();\n+        collectionXAdmin = EPersonBuilder.createEPerson(context)\n+            .withNameInMetadata(\"Jhon\", \"Brown\")\n+            .withEmail(\"collectionXAdmin@my.edu\")\n+            .withPassword(password)\n+            .build();\n+        item1Admin = EPersonBuilder.createEPerson(context)\n+            .withNameInMetadata(\"Jhon\", \"Brown\")\n+            .withEmail(\"item1Admin@my.edu\")\n+            .withPassword(password)\n+            .build();\n+        communityAWriter = EPersonBuilder.createEPerson(context)\n+            .withNameInMetadata(\"Jhon\", \"Brown\")\n+            .withEmail(\"communityAWriter@my.edu\")\n+            .withPassword(password)\n+            .build();\n+        collectionXWriter = EPersonBuilder.createEPerson(context)\n+            .withNameInMetadata(\"Jhon\", \"Brown\")\n+            .withEmail(\"collectionXWriter@my.edu\")\n+            .withPassword(password)\n+            .build();\n+        item1Writer = EPersonBuilder.createEPerson(context)\n+            .withNameInMetadata(\"Jhon\", \"Brown\")\n+            .withEmail(\"item1Writer@my.edu\")\n+            .withPassword(password)\n+            .build();\n+\n+        communityA = CommunityBuilder.createCommunity(context)\n+            .withName(\"communityA\")\n+            .withAdminGroup(communityAAdmin)\n+            .build();\n+        communityAA = CommunityBuilder.createCommunity(context)\n+            .withName(\"communityAA\")\n+            .addParentCommunity(context, communityA)\n+            .build();\n+        collectionX = CollectionBuilder.createCollection(context, communityAA)\n+            .withName(\"collectionX\")\n+            .withAdminGroup(collectionXAdmin)\n+            .build();\n+        item1 = ItemBuilder.createItem(context, collectionX)\n+            .withTitle(\"item1\")\n+            .withIssueDate(\"2020-07-08\")\n+            .withAuthor(\"Smith, Donald\").withAuthor(\"Doe, John\")\n+            .withSubject(\"item1Entry\")\n+            .build();\n+        bundle1 = BundleBuilder.createBundle(context, item1)\n+            .withName(\"bundle1\")\n+            .build();\n+        try (InputStream is = IOUtils.toInputStream(\"randomContent\", CharEncoding.UTF_8)) {\n+            bitstream1 = BitstreamBuilder.createBitstream(context, bundle1, is)\n+                .withName(\"bitstream1\")\n+                .withMimeType(\"text/plain\")\n+                .build();\n+        }\n+\n+        item1AdminGroup = GroupBuilder.createGroup(context)\n+            .withName(\"item1AdminGroup\")\n+            .addMember(item1Admin)\n+            .build();\n+        ResourcePolicyBuilder.createResourcePolicy(context)\n+            .withDspaceObject(item1)\n+            .withAction(Constants.ADMIN)\n+            .withGroup(item1AdminGroup)\n+            .build();\n+        ResourcePolicyBuilder.createResourcePolicy(context)\n+            .withDspaceObject(communityA)\n+            .withAction(Constants.WRITE)\n+            .withUser(communityAWriter)\n+            .build();\n+        ResourcePolicyBuilder.createResourcePolicy(context)\n+            .withDspaceObject(collectionX)\n+            .withAction(Constants.WRITE)\n+            .withUser(collectionXWriter)\n+            .build();\n+        ResourcePolicyBuilder.createResourcePolicy(context)\n+            .withDspaceObject(item1)\n+            .withAction(Constants.WRITE)\n+            .withUser(item1Writer)\n+            .build();\n+\n+        communityB = CommunityBuilder.createCommunity(context)\n+            .withName(\"communityB\")\n+            .build();\n+        communityBB = CommunityBuilder.createCommunity(context)\n+            .withName(\"communityBB\")\n+            .addParentCommunity(context, communityB)\n+            .build();\n+        collectionY = CollectionBuilder.createCollection(context, communityBB)\n+            .withName(\"collectionY\")\n+            .build();\n+        item2 = ItemBuilder.createItem(context, collectionY)\n+            .withTitle(\"item2\")\n+            .withIssueDate(\"2020-07-08\")\n+            .withAuthor(\"Smith, Donald\").withAuthor(\"Doe, John\")\n+            .withSubject(\"item2Entry\")\n+            .build();\n+        bundle2 = BundleBuilder.createBundle(context, item2)\n+            .withName(\"bundle2\")\n+            .build();\n+        try (InputStream is = IOUtils.toInputStream(\"randomContent\", CharEncoding.UTF_8)) {\n+            bitstream2 = BitstreamBuilder.createBitstream(context, bundle2, is)\n+                .withName(\"bitstream2\")\n+                .withMimeType(\"text/plain\")\n+                .build();\n+        }\n+\n+        context.restoreAuthSystemState();\n+\n+        originalAlwaysThrowException = configurationService.getBooleanProperty(\n+            \"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", false);\n+        configurationService.setProperty(\n+            \"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", \"true\");\n+    }\n+\n+    @Override\n+    @After\n+    public void destroy() throws Exception {\n+        configurationService.setProperty(\n+            \"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", originalAlwaysThrowException);\n+        super.destroy();\n+    }\n+\n+    private void testAdminsHavePermissionsAllDso(String feature) throws Exception {\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        String communityAAdminToken = getAuthToken(communityAAdmin.getEmail(), password);\n+        String collectionXAdminToken = getAuthToken(collectionXAdmin.getEmail(), password);\n+        String item1AdminToken = getAuthToken(item1Admin.getEmail(), password);\n+        String siteId = ContentServiceFactory.getInstance().getSiteService().findSite(context).getID().toString();\n+\n+        // Verify the general admin has this feature on the site\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+            + \"http://localhost/api/core/sites/\" + siteId))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify community A admin doesn\u2019t have this feature on the site\n+        getClient(communityAAdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/sites/\" + siteId))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify the general admin has this feature on community A\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+            + \"http://localhost/api/core/communities/\" + communityA.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify community A admin has this feature on community A\n+        getClient(communityAAdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/communities/\" + communityA.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify community A admin has this feature on community AA\n+        getClient(communityAAdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/communities/\" + communityAA.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify collection X admin doesn\u2019t have this feature on community A\n+        getClient(collectionXAdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/communities/\" + communityA.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify community A admin doesn\u2019t have this feature on community B\n+        getClient(communityAAdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/communities/\" + communityB.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify the general admin has this feature on collection X\n+        getClient(adminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/collections/\" + collectionX.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify community A admin has this feature on collection X\n+        getClient(communityAAdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/collections/\" + collectionX.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify collection X admin has this feature on collection X\n+        getClient(collectionXAdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/collections/\" + collectionX.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify item 1 admin doesn\u2019t have this feature on collection X\n+        getClient(item1AdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/collections/\" + collectionX.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify collection X admin doesn\u2019t have this feature on collection Y\n+        getClient(collectionXAdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/collections/\" + collectionY.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify the general admin has this feature on item 1\n+        getClient(adminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify community A admin has this feature on item 1\n+        getClient(communityAAdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify collection X admin has this feature on item 1\n+        getClient(collectionXAdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify item 1 admin has this feature on item 1\n+        getClient(item1AdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify item 1 admin doesn\u2019t have this feature on item 2\n+        getClient(item1AdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item2.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify the general admin has this feature on the bundle in item 1\n+        getClient(adminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/bundles/\" + bundle1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify community A admin has this feature on the bundle in item 1\n+        getClient(communityAAdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/bundles/\" + bundle1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify collection X admin has this feature on the bundle in item 1\n+        getClient(collectionXAdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/bundles/\" + bundle1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify item 1 admin has this feature on the bundle in item 1\n+        getClient(item1AdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/bundles/\" + bundle1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify item 1 admin doesn\u2019t have this feature on the bundle in item 2\n+        getClient(item1AdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/bundles/\" + bundle2.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify the general admin has this feature on the bitstream in item 1\n+        getClient(adminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/bitstreams/\" + bitstream1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify community A admin has this feature on the bitstream in item 1\n+        getClient(communityAAdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/bitstreams/\" + bitstream1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify collection X admin has this feature on the bitstream in item 1\n+        getClient(collectionXAdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/bitstreams/\" + bitstream1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify item 1 admin has this feature on the bitstream in item 1\n+        getClient(item1AdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/bitstreams/\" + bitstream1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify item 1 admin doesn\u2019t have this feature on the bitstream in item 2\n+        getClient(item1AdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/bitstreams/\" + bitstream2.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+    }\n+\n+    private void testAdminsHavePermissionsItem(String feature) throws Exception {\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        String communityAAdminToken = getAuthToken(communityAAdmin.getEmail(), password);\n+        String collectionXAdminToken = getAuthToken(collectionXAdmin.getEmail(), password);\n+        String item1AdminToken = getAuthToken(item1Admin.getEmail(), password);\n+\n+        // Verify the general admin has this feature on item 1\n+        getClient(adminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify community A admin has this feature on item 1\n+        getClient(communityAAdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify collection X admin has this feature on item 1\n+        getClient(collectionXAdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify item 1 admin has this feature on item 1\n+        getClient(item1AdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify community A admin doesn\u2019t have this feature on item 2\n+        getClient(communityAAdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item2.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+    }\n+\n+    private void testWriteUsersHavePermissionsAllDso(String feature, boolean hasDSOAccess) throws Exception {\n+        String communityAWriterToken = getAuthToken(communityAWriter.getEmail(), password);\n+        String collectionXWriterToken = getAuthToken(collectionXWriter.getEmail(), password);\n+        String item1WriterToken = getAuthToken(item1Writer.getEmail(), password);\n+\n+        // Verify community A write has this feature on community A if the boolean parameter is true\n+        // (or doesn\u2019t have access otherwise)\n+        if (hasDSOAccess) {\n+            getClient(communityAWriterToken).perform(\n+                get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                    + \"http://localhost/api/core/communities/\" + communityA.getID()))\n+                .andExpect(status().isOk())\n+                .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                    + feature + \"')]\").exists());\n+        } else {\n+            getClient(communityAWriterToken).perform(\n+                get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                    + \"http://localhost/api/core/communities/\" + communityA.getID()))\n+                .andExpect(status().isOk())\n+                .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                    + feature + \"')]\").doesNotExist());\n+        }\n+\n+        // Verify community A write doesn\u2019t have this feature on community AA\n+        getClient(communityAWriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/communities/\" + communityAA.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify community A write doesn\u2019t have this feature on collection X\n+        getClient(communityAWriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/collections/\" + collectionX.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify community A write doesn\u2019t have this feature on item 1\n+        getClient(communityAWriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify community A write doesn\u2019t have this feature on the bundle in item 1\n+        getClient(communityAWriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/bundles/\" + bundle1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify community A write doesn\u2019t have this feature on the bitstream in item 1\n+        getClient(communityAWriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify collection X write doesn\u2019t have this feature on community A\n+        getClient(collectionXWriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/communities/\" + communityA.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify collection X write doesn\u2019t have this feature on community AA\n+        getClient(collectionXWriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/communities/\" + communityAA.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify collection X write has this feature on collection X if the boolean parameter is true\n+        // (or doesn\u2019t have access otherwise)\n+        if (hasDSOAccess) {\n+            getClient(collectionXWriterToken).perform(\n+                get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                    + \"http://localhost/api/core/collections/\" + collectionX.getID()))\n+                .andExpect(status().isOk())\n+                .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                    + feature + \"')]\").exists());\n+        } else {\n+            getClient(collectionXWriterToken).perform(\n+                get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                    + \"http://localhost/api/core/collections/\" + collectionX.getID()))\n+                .andExpect(status().isOk())\n+                .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                    + feature + \"')]\").doesNotExist());\n+        }\n+\n+        // Verify collection X write doesn\u2019t have this feature on item 1\n+        getClient(collectionXWriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify collection X write doesn\u2019t have this feature on the bundle in item 1\n+        getClient(collectionXWriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/bundles/\" + bundle1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify collection X write doesn\u2019t have this feature on the bitstream in item 1\n+        getClient(collectionXWriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/bitstreams/\" + bitstream1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify item 1 write doesn\u2019t have this feature on community A\n+        getClient(item1WriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/communities/\" + communityA.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify item 1 write doesn\u2019t have this feature on community AA\n+        getClient(item1WriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/communities/\" + communityAA.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify item 1 write doesn\u2019t have this feature on collection X\n+        getClient(item1WriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/collections/\" + collectionX.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify item 1 write has this feature on item 1 if the boolean parameter is true\n+        // (or doesn\u2019t have access otherwise)\n+        if (hasDSOAccess) {\n+            getClient(item1WriterToken).perform(\n+                get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                    + \"http://localhost/api/core/items/\" + item1.getID()))\n+                .andExpect(status().isOk())\n+                .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                    + feature + \"')]\").exists());\n+        } else {\n+            getClient(item1WriterToken).perform(\n+                get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                    + \"http://localhost/api/core/items/\" + item1.getID()))\n+                .andExpect(status().isOk())\n+                .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                    + feature + \"')]\").doesNotExist());\n+        }\n+\n+        // Verify item 1 write doesn\u2019t have this feature on the bundle in item 1\n+        getClient(item1WriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/bundles/\" + bundle1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify item 1 write doesn\u2019t have this feature on the bitstream in item 1\n+        getClient(item1WriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/bitstreams/\" + bitstream1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify community A write doesn\u2019t have this feature on community B\n+        getClient(communityAWriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/communities/\" + communityB.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify collection X write doesn\u2019t have this feature on collection Y\n+        getClient(collectionXWriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/collections/\" + collectionY.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify item 1 write doesn\u2019t have this feature on item 2\n+        getClient(item1WriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item2.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+    }\n+\n+    private void testWriteUsersHavePermissionsItem(String feature, boolean hasDSOAccess) throws Exception {\n+        String communityAWriterToken = getAuthToken(communityAWriter.getEmail(), password);\n+        String collectionXWriterToken = getAuthToken(collectionXWriter.getEmail(), password);\n+        String item1WriterToken = getAuthToken(item1Writer.getEmail(), password);\n+\n+        // Verify community A write doesn\u2019t have this feature on item 1\n+        getClient(communityAWriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify collection X write doesn\u2019t have this feature on item 1\n+        getClient(collectionXWriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify item 1 write has this feature on item 1 if the boolean parameter is true\n+        // (or doesn\u2019t have access otherwise)\n+        if (hasDSOAccess) {\n+            getClient(item1WriterToken).perform(\n+                get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                    + \"http://localhost/api/core/items/\" + item1.getID()))\n+                .andExpect(status().isOk())\n+                .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                    + feature + \"')]\").exists());\n+        } else {\n+            getClient(item1WriterToken).perform(\n+                get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                    + \"http://localhost/api/core/items/\" + item1.getID()))\n+                .andExpect(status().isOk())\n+                .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                    + feature + \"')]\").doesNotExist());\n+        }\n+\n+        // Verify item 1 write doesn\u2019t have this feature on item 2\n+        getClient(item1WriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item2.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+    }\n+\n+    @Test\n+    public void testCanManagePoliciesAdmin() throws Exception {\n+        testWriteUsersHavePermissionsAllDso(\"canManagePolicies\", false);\n+    }\n+\n+    @Test\n+    public void testCanManagePoliciesWriter() throws Exception {\n+        testWriteUsersHavePermissionsAllDso(\"canManagePolicies\", false);\n+    }\n+\n+\n+    @Test\n+    public void testCanEditMetadataAdmin() throws Exception {\n+        testAdminsHavePermissionsAllDso(\"canEditMetadata\");\n+    }\n+\n+    @Test\n+    public void testCanEditMetadataWriter() throws Exception {\n+        testWriteUsersHavePermissionsAllDso(\"canEditMetadata\", true);\n+    }\n+\n+    @Test\n+    public void testCanMoveAdmin() throws Exception {\n+        String item1WriterToken = getAuthToken(item1Writer.getEmail(), password);\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        String communityAAdminToken = getAuthToken(communityAAdmin.getEmail(), password);\n+        String collectionXAdminToken = getAuthToken(collectionXAdmin.getEmail(), password);\n+        String item1AdminToken = getAuthToken(item1Admin.getEmail(), password);\n+        final String feature = \"canMove\";\n+\n+        // Verify the general admin has this feature on item 1\n+        getClient(adminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify community A admin has this feature on item 1\n+        getClient(communityAAdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify collection X admin has this feature on item 1\n+        getClient(collectionXAdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify item 1 admin doesn\u2019t have this feature on item 1\n+        getClient(item1AdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify community A admin doesn\u2019t have this feature on item 2\n+        getClient(communityAAdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item2.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+\n+        // grant item 1 admin REMOVE permissions on the item\u2019s owning collection\n+        // verify item 1 admin has this feature on item 1\n+        context.turnOffAuthorisationSystem();\n+        ResourcePolicy removePermission = ResourcePolicyBuilder.createResourcePolicy(context)\n+            .withDspaceObject(collectionX)\n+            .withAction(Constants.REMOVE)\n+            .withUser(item1Writer)\n+            .build();\n+        context.restoreAuthSystemState();\n+\n+        // verify item 1 write has this feature on item 1\n+        getClient(item1WriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='canMove')]\")\n+                .exists());\n+\n+        context.turnOffAuthorisationSystem();\n+        ResourcePolicyBuilder.delete(removePermission.getID());\n+        context.restoreAuthSystemState();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fae212d281fa5694343e44f08587d1fb6a708abd"}, "originalPosition": 831}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQ2NDkwNQ==", "bodyText": "Same here, these lines shouldn't be needed.", "url": "https://github.com/DSpace/DSpace/pull/2940#discussion_r482464905", "createdAt": "2020-09-02T21:02:26Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/authorization/GenericAuthorizationFeatureIT.java", "diffHunk": "@@ -0,0 +1,1709 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.authorization;\n+\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.io.InputStream;\n+\n+import org.apache.commons.codec.CharEncoding;\n+import org.apache.commons.io.IOUtils;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.authorize.ResourcePolicy;\n+import org.dspace.builder.BitstreamBuilder;\n+import org.dspace.builder.BundleBuilder;\n+import org.dspace.builder.CollectionBuilder;\n+import org.dspace.builder.CommunityBuilder;\n+import org.dspace.builder.EPersonBuilder;\n+import org.dspace.builder.GroupBuilder;\n+import org.dspace.builder.ItemBuilder;\n+import org.dspace.builder.ResourcePolicyBuilder;\n+import org.dspace.content.Bitstream;\n+import org.dspace.content.Bundle;\n+import org.dspace.content.Collection;\n+import org.dspace.content.Community;\n+import org.dspace.content.Item;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.core.Constants;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.Group;\n+import org.dspace.services.ConfigurationService;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+/**\n+ * Test for the following authorization features:\n+ *     canManagePolicies\n+ *     canEditMetadata\n+ *     canMove\n+ *     canMakePrivate\n+ *     canMakeDiscoverable\n+ *     canDelete\n+ *     canReorderBitstreams\n+ *     canCreateBitstream\n+ *     canCreateBundle\n+ */\n+public class GenericAuthorizationFeatureIT extends AbstractControllerIntegrationTest {\n+\n+    @Autowired\n+    ConfigurationService configurationService;\n+\n+    private Community communityA;\n+    private Community communityAA;\n+    private Community communityB;\n+    private Community communityBB;\n+    private Collection collectionX;\n+    private Collection collectionY;\n+    private Item item1;\n+    private Item item2;\n+    private Bundle bundle1;\n+    private Bundle bundle2;\n+    private Bitstream bitstream1;\n+    private Bitstream bitstream2;\n+\n+    private Group item1AdminGroup;\n+\n+    private EPerson communityAAdmin;\n+    private EPerson collectionXAdmin;\n+    private EPerson item1Admin;\n+    private EPerson communityAWriter;\n+    private EPerson collectionXWriter;\n+    private EPerson item1Writer;\n+\n+    boolean originalAlwaysThrowException;\n+\n+    @Override\n+    @Before\n+    public void setUp() throws Exception {\n+        super.setUp();\n+\n+        context.turnOffAuthorisationSystem();\n+\n+        communityAAdmin = EPersonBuilder.createEPerson(context)\n+            .withNameInMetadata(\"Jhon\", \"Brown\")\n+            .withEmail(\"communityAAdmin@my.edu\")\n+            .withPassword(password)\n+            .build();\n+        collectionXAdmin = EPersonBuilder.createEPerson(context)\n+            .withNameInMetadata(\"Jhon\", \"Brown\")\n+            .withEmail(\"collectionXAdmin@my.edu\")\n+            .withPassword(password)\n+            .build();\n+        item1Admin = EPersonBuilder.createEPerson(context)\n+            .withNameInMetadata(\"Jhon\", \"Brown\")\n+            .withEmail(\"item1Admin@my.edu\")\n+            .withPassword(password)\n+            .build();\n+        communityAWriter = EPersonBuilder.createEPerson(context)\n+            .withNameInMetadata(\"Jhon\", \"Brown\")\n+            .withEmail(\"communityAWriter@my.edu\")\n+            .withPassword(password)\n+            .build();\n+        collectionXWriter = EPersonBuilder.createEPerson(context)\n+            .withNameInMetadata(\"Jhon\", \"Brown\")\n+            .withEmail(\"collectionXWriter@my.edu\")\n+            .withPassword(password)\n+            .build();\n+        item1Writer = EPersonBuilder.createEPerson(context)\n+            .withNameInMetadata(\"Jhon\", \"Brown\")\n+            .withEmail(\"item1Writer@my.edu\")\n+            .withPassword(password)\n+            .build();\n+\n+        communityA = CommunityBuilder.createCommunity(context)\n+            .withName(\"communityA\")\n+            .withAdminGroup(communityAAdmin)\n+            .build();\n+        communityAA = CommunityBuilder.createCommunity(context)\n+            .withName(\"communityAA\")\n+            .addParentCommunity(context, communityA)\n+            .build();\n+        collectionX = CollectionBuilder.createCollection(context, communityAA)\n+            .withName(\"collectionX\")\n+            .withAdminGroup(collectionXAdmin)\n+            .build();\n+        item1 = ItemBuilder.createItem(context, collectionX)\n+            .withTitle(\"item1\")\n+            .withIssueDate(\"2020-07-08\")\n+            .withAuthor(\"Smith, Donald\").withAuthor(\"Doe, John\")\n+            .withSubject(\"item1Entry\")\n+            .build();\n+        bundle1 = BundleBuilder.createBundle(context, item1)\n+            .withName(\"bundle1\")\n+            .build();\n+        try (InputStream is = IOUtils.toInputStream(\"randomContent\", CharEncoding.UTF_8)) {\n+            bitstream1 = BitstreamBuilder.createBitstream(context, bundle1, is)\n+                .withName(\"bitstream1\")\n+                .withMimeType(\"text/plain\")\n+                .build();\n+        }\n+\n+        item1AdminGroup = GroupBuilder.createGroup(context)\n+            .withName(\"item1AdminGroup\")\n+            .addMember(item1Admin)\n+            .build();\n+        ResourcePolicyBuilder.createResourcePolicy(context)\n+            .withDspaceObject(item1)\n+            .withAction(Constants.ADMIN)\n+            .withGroup(item1AdminGroup)\n+            .build();\n+        ResourcePolicyBuilder.createResourcePolicy(context)\n+            .withDspaceObject(communityA)\n+            .withAction(Constants.WRITE)\n+            .withUser(communityAWriter)\n+            .build();\n+        ResourcePolicyBuilder.createResourcePolicy(context)\n+            .withDspaceObject(collectionX)\n+            .withAction(Constants.WRITE)\n+            .withUser(collectionXWriter)\n+            .build();\n+        ResourcePolicyBuilder.createResourcePolicy(context)\n+            .withDspaceObject(item1)\n+            .withAction(Constants.WRITE)\n+            .withUser(item1Writer)\n+            .build();\n+\n+        communityB = CommunityBuilder.createCommunity(context)\n+            .withName(\"communityB\")\n+            .build();\n+        communityBB = CommunityBuilder.createCommunity(context)\n+            .withName(\"communityBB\")\n+            .addParentCommunity(context, communityB)\n+            .build();\n+        collectionY = CollectionBuilder.createCollection(context, communityBB)\n+            .withName(\"collectionY\")\n+            .build();\n+        item2 = ItemBuilder.createItem(context, collectionY)\n+            .withTitle(\"item2\")\n+            .withIssueDate(\"2020-07-08\")\n+            .withAuthor(\"Smith, Donald\").withAuthor(\"Doe, John\")\n+            .withSubject(\"item2Entry\")\n+            .build();\n+        bundle2 = BundleBuilder.createBundle(context, item2)\n+            .withName(\"bundle2\")\n+            .build();\n+        try (InputStream is = IOUtils.toInputStream(\"randomContent\", CharEncoding.UTF_8)) {\n+            bitstream2 = BitstreamBuilder.createBitstream(context, bundle2, is)\n+                .withName(\"bitstream2\")\n+                .withMimeType(\"text/plain\")\n+                .build();\n+        }\n+\n+        context.restoreAuthSystemState();\n+\n+        originalAlwaysThrowException = configurationService.getBooleanProperty(\n+            \"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", false);\n+        configurationService.setProperty(\n+            \"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", \"true\");\n+    }\n+\n+    @Override\n+    @After\n+    public void destroy() throws Exception {\n+        configurationService.setProperty(\n+            \"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", originalAlwaysThrowException);\n+        super.destroy();\n+    }\n+\n+    private void testAdminsHavePermissionsAllDso(String feature) throws Exception {\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        String communityAAdminToken = getAuthToken(communityAAdmin.getEmail(), password);\n+        String collectionXAdminToken = getAuthToken(collectionXAdmin.getEmail(), password);\n+        String item1AdminToken = getAuthToken(item1Admin.getEmail(), password);\n+        String siteId = ContentServiceFactory.getInstance().getSiteService().findSite(context).getID().toString();\n+\n+        // Verify the general admin has this feature on the site\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+            + \"http://localhost/api/core/sites/\" + siteId))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify community A admin doesn\u2019t have this feature on the site\n+        getClient(communityAAdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/sites/\" + siteId))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify the general admin has this feature on community A\n+        getClient(adminToken).perform(get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+            + \"http://localhost/api/core/communities/\" + communityA.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify community A admin has this feature on community A\n+        getClient(communityAAdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/communities/\" + communityA.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify community A admin has this feature on community AA\n+        getClient(communityAAdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/communities/\" + communityAA.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify collection X admin doesn\u2019t have this feature on community A\n+        getClient(collectionXAdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/communities/\" + communityA.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify community A admin doesn\u2019t have this feature on community B\n+        getClient(communityAAdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/communities/\" + communityB.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify the general admin has this feature on collection X\n+        getClient(adminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/collections/\" + collectionX.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify community A admin has this feature on collection X\n+        getClient(communityAAdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/collections/\" + collectionX.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify collection X admin has this feature on collection X\n+        getClient(collectionXAdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/collections/\" + collectionX.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify item 1 admin doesn\u2019t have this feature on collection X\n+        getClient(item1AdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/collections/\" + collectionX.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify collection X admin doesn\u2019t have this feature on collection Y\n+        getClient(collectionXAdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/collections/\" + collectionY.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify the general admin has this feature on item 1\n+        getClient(adminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify community A admin has this feature on item 1\n+        getClient(communityAAdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify collection X admin has this feature on item 1\n+        getClient(collectionXAdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify item 1 admin has this feature on item 1\n+        getClient(item1AdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify item 1 admin doesn\u2019t have this feature on item 2\n+        getClient(item1AdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item2.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify the general admin has this feature on the bundle in item 1\n+        getClient(adminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/bundles/\" + bundle1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify community A admin has this feature on the bundle in item 1\n+        getClient(communityAAdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/bundles/\" + bundle1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify collection X admin has this feature on the bundle in item 1\n+        getClient(collectionXAdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/bundles/\" + bundle1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify item 1 admin has this feature on the bundle in item 1\n+        getClient(item1AdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/bundles/\" + bundle1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify item 1 admin doesn\u2019t have this feature on the bundle in item 2\n+        getClient(item1AdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/bundles/\" + bundle2.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify the general admin has this feature on the bitstream in item 1\n+        getClient(adminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/bitstreams/\" + bitstream1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify community A admin has this feature on the bitstream in item 1\n+        getClient(communityAAdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/bitstreams/\" + bitstream1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify collection X admin has this feature on the bitstream in item 1\n+        getClient(collectionXAdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/bitstreams/\" + bitstream1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify item 1 admin has this feature on the bitstream in item 1\n+        getClient(item1AdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/bitstreams/\" + bitstream1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify item 1 admin doesn\u2019t have this feature on the bitstream in item 2\n+        getClient(item1AdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/bitstreams/\" + bitstream2.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+    }\n+\n+    private void testAdminsHavePermissionsItem(String feature) throws Exception {\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        String communityAAdminToken = getAuthToken(communityAAdmin.getEmail(), password);\n+        String collectionXAdminToken = getAuthToken(collectionXAdmin.getEmail(), password);\n+        String item1AdminToken = getAuthToken(item1Admin.getEmail(), password);\n+\n+        // Verify the general admin has this feature on item 1\n+        getClient(adminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify community A admin has this feature on item 1\n+        getClient(communityAAdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify collection X admin has this feature on item 1\n+        getClient(collectionXAdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify item 1 admin has this feature on item 1\n+        getClient(item1AdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify community A admin doesn\u2019t have this feature on item 2\n+        getClient(communityAAdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item2.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+    }\n+\n+    private void testWriteUsersHavePermissionsAllDso(String feature, boolean hasDSOAccess) throws Exception {\n+        String communityAWriterToken = getAuthToken(communityAWriter.getEmail(), password);\n+        String collectionXWriterToken = getAuthToken(collectionXWriter.getEmail(), password);\n+        String item1WriterToken = getAuthToken(item1Writer.getEmail(), password);\n+\n+        // Verify community A write has this feature on community A if the boolean parameter is true\n+        // (or doesn\u2019t have access otherwise)\n+        if (hasDSOAccess) {\n+            getClient(communityAWriterToken).perform(\n+                get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                    + \"http://localhost/api/core/communities/\" + communityA.getID()))\n+                .andExpect(status().isOk())\n+                .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                    + feature + \"')]\").exists());\n+        } else {\n+            getClient(communityAWriterToken).perform(\n+                get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                    + \"http://localhost/api/core/communities/\" + communityA.getID()))\n+                .andExpect(status().isOk())\n+                .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                    + feature + \"')]\").doesNotExist());\n+        }\n+\n+        // Verify community A write doesn\u2019t have this feature on community AA\n+        getClient(communityAWriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/communities/\" + communityAA.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify community A write doesn\u2019t have this feature on collection X\n+        getClient(communityAWriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/collections/\" + collectionX.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify community A write doesn\u2019t have this feature on item 1\n+        getClient(communityAWriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify community A write doesn\u2019t have this feature on the bundle in item 1\n+        getClient(communityAWriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/bundles/\" + bundle1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify community A write doesn\u2019t have this feature on the bitstream in item 1\n+        getClient(communityAWriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify collection X write doesn\u2019t have this feature on community A\n+        getClient(collectionXWriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/communities/\" + communityA.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify collection X write doesn\u2019t have this feature on community AA\n+        getClient(collectionXWriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/communities/\" + communityAA.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify collection X write has this feature on collection X if the boolean parameter is true\n+        // (or doesn\u2019t have access otherwise)\n+        if (hasDSOAccess) {\n+            getClient(collectionXWriterToken).perform(\n+                get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                    + \"http://localhost/api/core/collections/\" + collectionX.getID()))\n+                .andExpect(status().isOk())\n+                .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                    + feature + \"')]\").exists());\n+        } else {\n+            getClient(collectionXWriterToken).perform(\n+                get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                    + \"http://localhost/api/core/collections/\" + collectionX.getID()))\n+                .andExpect(status().isOk())\n+                .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                    + feature + \"')]\").doesNotExist());\n+        }\n+\n+        // Verify collection X write doesn\u2019t have this feature on item 1\n+        getClient(collectionXWriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify collection X write doesn\u2019t have this feature on the bundle in item 1\n+        getClient(collectionXWriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/bundles/\" + bundle1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify collection X write doesn\u2019t have this feature on the bitstream in item 1\n+        getClient(collectionXWriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/bitstreams/\" + bitstream1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify item 1 write doesn\u2019t have this feature on community A\n+        getClient(item1WriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/communities/\" + communityA.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify item 1 write doesn\u2019t have this feature on community AA\n+        getClient(item1WriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/communities/\" + communityAA.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify item 1 write doesn\u2019t have this feature on collection X\n+        getClient(item1WriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/collections/\" + collectionX.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify item 1 write has this feature on item 1 if the boolean parameter is true\n+        // (or doesn\u2019t have access otherwise)\n+        if (hasDSOAccess) {\n+            getClient(item1WriterToken).perform(\n+                get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                    + \"http://localhost/api/core/items/\" + item1.getID()))\n+                .andExpect(status().isOk())\n+                .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                    + feature + \"')]\").exists());\n+        } else {\n+            getClient(item1WriterToken).perform(\n+                get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                    + \"http://localhost/api/core/items/\" + item1.getID()))\n+                .andExpect(status().isOk())\n+                .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                    + feature + \"')]\").doesNotExist());\n+        }\n+\n+        // Verify item 1 write doesn\u2019t have this feature on the bundle in item 1\n+        getClient(item1WriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/bundles/\" + bundle1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify item 1 write doesn\u2019t have this feature on the bitstream in item 1\n+        getClient(item1WriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/bitstreams/\" + bitstream1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify community A write doesn\u2019t have this feature on community B\n+        getClient(communityAWriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/communities/\" + communityB.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify collection X write doesn\u2019t have this feature on collection Y\n+        getClient(collectionXWriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/collections/\" + collectionY.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify item 1 write doesn\u2019t have this feature on item 2\n+        getClient(item1WriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item2.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+    }\n+\n+    private void testWriteUsersHavePermissionsItem(String feature, boolean hasDSOAccess) throws Exception {\n+        String communityAWriterToken = getAuthToken(communityAWriter.getEmail(), password);\n+        String collectionXWriterToken = getAuthToken(collectionXWriter.getEmail(), password);\n+        String item1WriterToken = getAuthToken(item1Writer.getEmail(), password);\n+\n+        // Verify community A write doesn\u2019t have this feature on item 1\n+        getClient(communityAWriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify collection X write doesn\u2019t have this feature on item 1\n+        getClient(collectionXWriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify item 1 write has this feature on item 1 if the boolean parameter is true\n+        // (or doesn\u2019t have access otherwise)\n+        if (hasDSOAccess) {\n+            getClient(item1WriterToken).perform(\n+                get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                    + \"http://localhost/api/core/items/\" + item1.getID()))\n+                .andExpect(status().isOk())\n+                .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                    + feature + \"')]\").exists());\n+        } else {\n+            getClient(item1WriterToken).perform(\n+                get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                    + \"http://localhost/api/core/items/\" + item1.getID()))\n+                .andExpect(status().isOk())\n+                .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                    + feature + \"')]\").doesNotExist());\n+        }\n+\n+        // Verify item 1 write doesn\u2019t have this feature on item 2\n+        getClient(item1WriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item2.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+    }\n+\n+    @Test\n+    public void testCanManagePoliciesAdmin() throws Exception {\n+        testWriteUsersHavePermissionsAllDso(\"canManagePolicies\", false);\n+    }\n+\n+    @Test\n+    public void testCanManagePoliciesWriter() throws Exception {\n+        testWriteUsersHavePermissionsAllDso(\"canManagePolicies\", false);\n+    }\n+\n+\n+    @Test\n+    public void testCanEditMetadataAdmin() throws Exception {\n+        testAdminsHavePermissionsAllDso(\"canEditMetadata\");\n+    }\n+\n+    @Test\n+    public void testCanEditMetadataWriter() throws Exception {\n+        testWriteUsersHavePermissionsAllDso(\"canEditMetadata\", true);\n+    }\n+\n+    @Test\n+    public void testCanMoveAdmin() throws Exception {\n+        String item1WriterToken = getAuthToken(item1Writer.getEmail(), password);\n+        String adminToken = getAuthToken(admin.getEmail(), password);\n+        String communityAAdminToken = getAuthToken(communityAAdmin.getEmail(), password);\n+        String collectionXAdminToken = getAuthToken(collectionXAdmin.getEmail(), password);\n+        String item1AdminToken = getAuthToken(item1Admin.getEmail(), password);\n+        final String feature = \"canMove\";\n+\n+        // Verify the general admin has this feature on item 1\n+        getClient(adminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify community A admin has this feature on item 1\n+        getClient(communityAAdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify collection X admin has this feature on item 1\n+        getClient(collectionXAdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").exists());\n+\n+        // Verify item 1 admin doesn\u2019t have this feature on item 1\n+        getClient(item1AdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+        // Verify community A admin doesn\u2019t have this feature on item 2\n+        getClient(communityAAdminToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item2.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='\"\n+                + feature + \"')]\").doesNotExist());\n+\n+\n+        // grant item 1 admin REMOVE permissions on the item\u2019s owning collection\n+        // verify item 1 admin has this feature on item 1\n+        context.turnOffAuthorisationSystem();\n+        ResourcePolicy removePermission = ResourcePolicyBuilder.createResourcePolicy(context)\n+            .withDspaceObject(collectionX)\n+            .withAction(Constants.REMOVE)\n+            .withUser(item1Writer)\n+            .build();\n+        context.restoreAuthSystemState();\n+\n+        // verify item 1 write has this feature on item 1\n+        getClient(item1WriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='canMove')]\")\n+                .exists());\n+\n+        context.turnOffAuthorisationSystem();\n+        ResourcePolicyBuilder.delete(removePermission.getID());\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void testCanMoveWriter() throws Exception {\n+        testWriteUsersHavePermissionsItem(\"canMove\", false);\n+\n+        // grant item 1 write REMOVE permissions on the item\u2019s owning collection\n+        context.turnOffAuthorisationSystem();\n+        ResourcePolicy removePermission = ResourcePolicyBuilder.createResourcePolicy(context)\n+            .withDspaceObject(collectionX)\n+            .withAction(Constants.REMOVE)\n+            .withUser(item1Writer)\n+            .build();\n+        context.restoreAuthSystemState();\n+\n+        String item1WriterToken = getAuthToken(item1Writer.getEmail(), password);\n+        // verify item 1 write has this feature on item 1\n+        getClient(item1WriterToken).perform(\n+            get(\"/api/authz/authorizations/search/object?embed=feature&uri=\"\n+                + \"http://localhost/api/core/items/\" + item1.getID()))\n+            .andExpect(status().isOk())\n+            .andExpect(jsonPath(\"$._embedded.authorizations[?(@._embedded.feature.id=='canMove')]\")\n+                .exists());\n+\n+        context.turnOffAuthorisationSystem();\n+        ResourcePolicyBuilder.delete(removePermission.getID());\n+        context.restoreAuthSystemState();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fae212d281fa5694343e44f08587d1fb6a708abd"}, "originalPosition": 858}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxODk1MjEw", "url": "https://github.com/DSpace/DSpace/pull/2940#pullrequestreview-481895210", "createdAt": "2020-09-03T14:26:51Z", "commit": {"oid": "fae212d281fa5694343e44f08587d1fb6a708abd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNDoyNjo1MVrOHMpM8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNDoyNjo1MVrOHMpM8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAyMDAxNg==", "bodyText": "not necessary a bad thing but this is a change of the current behavior. Top communities can be removed only by general administrator", "url": "https://github.com/DSpace/DSpace/pull/2940#discussion_r483020016", "createdAt": "2020-09-03T14:26:51Z", "author": {"login": "abollini"}, "path": "dspace-api/src/main/java/org/dspace/content/CommunityServiceImpl.java", "diffHunk": "@@ -629,6 +629,10 @@ public DSpaceObject getAdminObject(Context context, Community community, int act\n             case Constants.DELETE:\n                 if (AuthorizeConfiguration.canCommunityAdminPerformSubelementDeletion()) {\n                     adminObject = getParentObject(context, community);\n+                    if (adminObject == null) {\n+                        //top-level community, has to be admin of the current communitu\n+                        adminObject = community;\n+                    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fae212d281fa5694343e44f08587d1fb6a708abd"}, "originalPosition": 7}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad9913986cbc69d3c91f001f6efca3cd2c2573c1", "author": {"user": {"login": "peter-atmire", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/ad9913986cbc69d3c91f001f6efca3cd2c2573c1", "committedDate": "2020-09-15T15:45:08Z", "message": "73011: Edit item permissions community feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1MDY4MDM5", "url": "https://github.com/DSpace/DSpace/pull/2940#pullrequestreview-495068039", "createdAt": "2020-09-23T21:39:40Z", "commit": {"oid": "ad9913986cbc69d3c91f001f6efca3cd2c2573c1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1330, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}