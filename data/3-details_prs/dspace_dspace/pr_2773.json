{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI0MTU4Mzk0", "number": 2773, "title": "DS-3940 SHERPA v2 API (main port)", "bodyText": "Developed by The Library Code with the support of Technische Universit\u00e4t Hamburg TUHH.\nReferences\n\nJIRA link: DS-3940\nSHERPA API key registration: https://v2.sherpa.ac.uk/romeo/api.html\nDSpace 6 PR: #2739\nThe REST Contract entry for this is External Authority Services, and is unchanged (though, neither SHERPA source is used as an example in this doc -- it could be added if requested)\nNo Angular changes are made as part of this work, it is a refactor of external sources\n\nDescription\nThis is a master port of #2739 to introduce new SHERPA v2 API data models and integrations, and to refactor existing work in external source providers (for journal and publisher lookups) to make use of these new classes. No Angular changes or REST changes are made.\nIt is not an exact port of 6.x as the XMLUI and JSPUI changes are irrelevant, tests have been added, and the default API key is not commented out in dspace.cfg but is instead left blank (as it is required as a placeholder by spring bean configuration). Everything else should be the same (the DSpace 6 version was updated to use DSpace 7 code style rules).\nInstructions for Reviewers\nList of changes in this PR:\n\nRemoved old SHERPA model and integration classes and replaced with classes to work with SHERPA v2 API\nRefactored and renamed SherpaJournalDataProvider and SherpaPublisherDataProvider provider classes, to work with the new SHERPA v2 API\nWrote two unit tests (one for Publisher, one for Journal) to ensure that JSON is parsed correctly. The JSON is taken from raw API responses and supplied as static files in the tests resources bundle\n\nTo test this PR:\n\nRegister for a SHERPA API v2 key and configure it in local.cfg: sherpa.romeo.apikey\nVisit the external sources page in the rest HAL explorer: http://${server.url}/server/api/integration/externalsources\nThe external sources sherpaJournal and sherpaPublisher should be listed (as they were previously with the v1 API code)\nFor the sherpaJournal source, a search can be tested with a query for a journal name, eg. \"PLOS\" should return ~7 results.\nFor the sherpaPublisher source, a search can be tested with a query for a publisher name, eg. \"New Zealand\" should return ~15 results\nThe \"get external object\" query (exact title match) can be tested with eg. http://${server.url}/server/api/integration/externalsources/sherpaJournal/entryValues/PLoS%20Computational%20Biology\n\nChecklist\n\n\n My PR is small in size (e.g. less than 1,000 lines of code, not including comments & integration tests). Exceptions may be made if previously agreed upon.\n(My PR is longer, at around ~2000 including comments so probably ~1800-1900 without, but a lot of these changes seem longer since the refactor involves lots of files being replaced / renamed. The changes are isolated just to SHERPA integration and do not impact any other part of the DSpace codebase, so I am hoping this work can still be approved for review)\n\n\n My PR passes Checkstyle validation based on the Code Style Guide\n\n\n My PR includes Javadoc for all new (or modified) public methods and classes. It also includes Javadoc for large or complex private methods.\n\n\n My PR passes all tests and includes new/updated Unit or Integration Tests for any bug fixes, improvements or new features. A few reminders about what constitutes good tests:\n\nInclude tests for different user types, including: (1) Anonymous user, (2) Logged in user (non-admin), and (3) Administrator.\nInclude tests for known error scenarios and error codes (e.g. 400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found, etc)\nFor bug fixes, include a test that reproduces the bug and proves it is fixed. For clarity, it may be useful to provide the test in a separate commit from the bug fix.\n\n\n\n If my PR includes new, third-party dependencies (in any pom.xml), I've made sure their licenses align with the DSpace BSD License based on the Licensing of Contributions documentation.\n(It does not include any new dependencies)\n\n\n If my PR modifies the REST API, I've linked to the REST Contract page (or open PR) related to this change.\n(It does not modify the REST API, but I have linked to the relevant contract page)", "createdAt": "2020-05-27T23:08:09Z", "url": "https://github.com/DSpace/DSpace/pull/2773", "merged": true, "mergeCommit": {"oid": "80c3f98447dfe1ca6977faebb774ac406532a29e"}, "closed": true, "closedAt": "2021-02-18T19:30:22Z", "author": {"login": "kshepherd"}, "timelineItems": {"totalCount": 30, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcnSw2xgFqTQyMjU0NTUwMQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABd7aeoCgFqTU5MzU3MzAyNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyNTQ1NTAx", "url": "https://github.com/DSpace/DSpace/pull/2773#pullrequestreview-422545501", "createdAt": "2020-06-02T10:28:01Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMDoyODowMVrOGdrnIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMDo1MzowMVrOGdsV3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc3NjQxOA==", "bodyText": "please add a basic javadoc here", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r433776418", "createdAt": "2020-06-02T10:28:01Z", "author": {"login": "abollini"}, "path": "dspace-api/src/main/java/org/dspace/app/sherpa/v2/SHERPAJournal.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.sherpa.v2;\n+\n+import java.util.List;\n+\n+public class SHERPAJournal {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc3Nzk1NA==", "bodyText": "should we rethrow the exception here?", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r433777954", "createdAt": "2020-06-02T10:31:11Z", "author": {"login": "abollini"}, "path": "dspace-api/src/main/java/org/dspace/app/sherpa/SHERPAService.java", "diffHunk": "@@ -91,12 +108,22 @@ public SHERPAResponse searchByJournalISSN(String query) {\n                 HttpEntity responseBody = response.getEntity();\n \n                 if (null != responseBody) {\n-                    sherpaResponse = new SHERPAResponse(responseBody.getContent());\n+                    InputStream content = null;\n+                    try {\n+                        content = responseBody.getContent();\n+                        sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                    } catch (IOException e) {\n+                        log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                    } finally {\n+                        if (content != null) {\n+                            content.close();\n+                        }\n+                    }\n                 } else {\n                     sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO returned no response\");\n                 }\n             } catch (Exception e) {\n-                log.warn(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc3ODQ1Ng==", "bodyText": "should we rethrow the exception?", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r433778456", "createdAt": "2020-06-02T10:32:18Z", "author": {"login": "abollini"}, "path": "dspace-api/src/main/java/org/dspace/app/sherpa/SHERPAService.java", "diffHunk": "@@ -91,12 +108,22 @@ public SHERPAResponse searchByJournalISSN(String query) {\n                 HttpEntity responseBody = response.getEntity();\n \n                 if (null != responseBody) {\n-                    sherpaResponse = new SHERPAResponse(responseBody.getContent());\n+                    InputStream content = null;\n+                    try {\n+                        content = responseBody.getContent();\n+                        sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                    } catch (IOException e) {\n+                        log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc3ODc2MQ==", "bodyText": "please add a basic javadoc here", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r433778761", "createdAt": "2020-06-02T10:32:58Z", "author": {"login": "abollini"}, "path": "dspace-api/src/main/java/org/dspace/app/sherpa/v2/SHERPAPermittedVersion.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.sherpa.v2;\n+\n+import java.util.List;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc3ODkwNQ==", "bodyText": "please add a basic javadoc here", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r433778905", "createdAt": "2020-06-02T10:33:13Z", "author": {"login": "abollini"}, "path": "dspace-api/src/main/java/org/dspace/app/sherpa/v2/SHERPAPublisher.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.sherpa.v2;\n+\n+public class SHERPAPublisher {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc3OTQ4NQ==", "bodyText": "please add basic javadoc here", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r433779485", "createdAt": "2020-06-02T10:34:27Z", "author": {"login": "abollini"}, "path": "dspace-api/src/main/java/org/dspace/app/sherpa/v2/SHERPAPublisherPolicy.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.sherpa.v2;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public class SHERPAPublisherPolicy {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4Mjc0Ng==", "bodyText": "this seems to prevent us to support multiple language. If the i18n support must be provided on the backend side we should use the context object to understand which is the locale in use otherwise we should keep the \"key\" in the response to allow the UI to apply its own translation mechanism", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r433782746", "createdAt": "2020-06-02T10:41:16Z", "author": {"login": "abollini"}, "path": "dspace-api/src/main/java/org/dspace/app/sherpa/v2/SHERPAResponse.java", "diffHunk": "@@ -0,0 +1,533 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.sherpa.v2;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+import org.apache.log4j.Logger;\n+import org.dspace.core.I18nUtil;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.json.JSONTokener;\n+\n+/**\n+ * Model class for the SHERPAv2 API (JSON) response for a publication (journal) search\n+ * The structure and approached used is quite different to the simple v1 API used previously\n+ * \n+ * @author Kim Shepherd\n+ * \n+ */\n+public class SHERPAResponse {\n+    // Is this response to be treated as an error?\n+    private boolean error;\n+\n+    // Error message\n+    private String message;\n+\n+    // Parsed system metadata from search results\n+    private SHERPASystemMetadata metadata;\n+\n+    // List of parsed journal results\n+    private List<SHERPAJournal> journals;\n+\n+    // Internal Sherpa ID\n+    private int id;\n+\n+    // SHERPA URI (the human page version of this API response)\n+    private String uri;\n+\n+    // Format enum - currently only JSON is supported\n+    public enum SHERPAFormat {\n+        JSON, XML\n+    };\n+\n+    private static Logger log = Logger.getLogger(SHERPAResponse.class);\n+\n+    /**\n+     * Parse SHERPA v2 API for a given format\n+     * @param input - input stream from the HTTP response content\n+     * @param format - requested format\n+     * @throws IOException\n+     */\n+    public SHERPAResponse(InputStream input, SHERPAFormat format) throws IOException {\n+        if (format == SHERPAFormat.JSON) {\n+            parseJSON(input);\n+        }\n+    }\n+\n+    /**\n+     * Parse the SHERPA v2 API JSON and construct Romeo policy data for display\n+     * This method does not return a value, but rather populates the metadata and journals objects\n+     * with data parsed from the JSON.\n+     * @param jsonData - the JSON input stream from the API result response body\n+     */\n+    private void parseJSON(InputStream jsonData) throws IOException {\n+        InputStreamReader streamReader = new InputStreamReader(jsonData);\n+        JSONTokener jsonTokener = new JSONTokener(streamReader);\n+        JSONObject httpResponse;\n+        try {\n+            httpResponse = new JSONObject(jsonTokener);\n+            if (httpResponse.has(\"items\")) {\n+                JSONArray items = httpResponse.getJSONArray(\"items\");\n+\n+                // items array is search results, *not* journals or publishers - they are listed for each item\n+                // - however, we only ever want one result since we're passing an \"equals ISSN\" query\n+                if (items.length() > 0) {\n+                    metadata = new SHERPASystemMetadata();\n+                    this.journals = new LinkedList<>();\n+                    // Iterate search result items\n+                    for (int itemIndex = 0; itemIndex < items.length(); itemIndex++) {\n+                        List<SHERPAPublisher> sherpaPublishers = new LinkedList<>();\n+                        List<SHERPAPublisherPolicy> policies = new ArrayList<>();\n+                        SHERPAPublisher sherpaPublisher = new SHERPAPublisher();\n+                        SHERPAJournal sherpaJournal = new SHERPAJournal();\n+\n+                        JSONObject item = items.getJSONObject(0);\n+\n+                        // Parse system metadata (per-item / result information)\n+                        if (item.has(\"system_metadata\")) {\n+                            JSONObject systemMetadata = item.getJSONObject(\"system_metadata\");\n+                            metadata = parseSystemMetadata(systemMetadata);\n+                        }\n+\n+                        // Parse \"publisher policy\"\n+                        // note - most of the information that was previously under 'publisher' is now under here\n+                        if (item.has(\"publisher_policy\")) {\n+\n+                            // Parse main publisher policies node\n+                            JSONArray publisherPolicies = item.getJSONArray(\"publisher_policy\");\n+                            for (int i = 0; i < publisherPolicies.length(); i++) {\n+\n+                                JSONObject policy = publisherPolicies.getJSONObject(i);\n+\n+                                // Special case - quickly check the policy for the 'paid access' option\n+                                // and continue if found, then parse the rest of the policy\n+                                String moniker = null;\n+                                if (policy.has(\"internal_moniker\")) {\n+                                    moniker = policy.getString(\"internal_moniker\");\n+                                }\n+                                // This seems to be usually policy(ies) for the journal proper\n+                                // and then an \"Open access option\" which contains some of the info\n+                                // that the 'paidaccess' node in the old API used to contain\n+                                // Look for: internal_moniker = \"Open access option\"\n+                                // Check if this is OA options (Paid Access) or not\n+                                if (\"Open access option\".equalsIgnoreCase(moniker)) {\n+                                    log.debug(\"This is the Open access options policy - a special case\");\n+                                    if (policy.has(\"urls\")) {\n+                                        JSONArray urls = policy.getJSONArray(\"urls\");\n+                                        for (int u = 0; u < urls.length(); u++) {\n+                                            JSONObject url = urls.getJSONObject(u);\n+                                            if (url.has(\"description\") &&\n+                                                \"Open Access\".equalsIgnoreCase(url.getString(\"description\"))) {\n+                                                log.debug(\"Found OA paid access url: \" + url.getString(\"url\"));\n+                                                sherpaPublisher.setPaidAccessDescription(url.getString(\"description\"));\n+                                                sherpaPublisher.setPaidAccessUrl(url.getString(\"url\"));\n+                                                break;\n+                                            }\n+                                        }\n+                                    }\n+                                    // Continue the loop here - this \"policy\" is a bit different and we\n+                                    // don't want to add irrelevant conditions to the policy\n+                                    continue;\n+                                }\n+\n+                                // Parse the main publisher policy object and add to the list\n+                                SHERPAPublisherPolicy sherpaPublisherPolicy = parsePublisherPolicy(policy);\n+                                policies.add(sherpaPublisherPolicy);\n+                            }\n+\n+                            // set publisher name - note we're only looking for the first name here\n+                            // as per previous functionality (for simple display)\n+                            if (item.has(\"publishers\")) {\n+                                JSONArray publishers = item.getJSONArray(\"publishers\");\n+                                if (publishers.length() > 0) {\n+                                    JSONObject publisherElement = publishers.getJSONObject(0);\n+                                    if (publisherElement.has(\"publisher\")) {\n+                                        JSONObject publisher = publisherElement.getJSONObject(\"publisher\");\n+                                        sherpaPublisher.setName(parsePublisherName(publisher));\n+                                        sherpaPublisher.setUri(parsePublisherURL(publisher));\n+                                    }\n+                                }\n+                            }\n+\n+                            // Parse journal data\n+                            sherpaJournal = parseJournal(item, sherpaPublisher.getName());\n+                        }\n+\n+                        sherpaPublishers.add(sherpaPublisher);\n+                        sherpaJournal.setPublisher(sherpaPublisher);\n+                        sherpaJournal.setPublishers(sherpaPublishers);\n+                        sherpaJournal.setPolicies(policies);\n+                        this.journals.add(sherpaJournal);\n+                    }\n+\n+                } else {\n+                    error = true;\n+                    message = \"No results found\";\n+                }\n+            } else {\n+                error = true;\n+                message = \"No results found\";\n+            }\n+\n+        } catch (JSONException e) {\n+            log.error(\"Failed to parse SHERPA response\", e);\n+            error = true;\n+        } finally {\n+            streamReader.close();\n+        }\n+    }\n+\n+    /**\n+     * Parse system metadata and return populated SHERPASystemMetadata object\n+     * @param systemMetadata\n+     */\n+    private SHERPASystemMetadata parseSystemMetadata(JSONObject systemMetadata) {\n+\n+        SHERPASystemMetadata metadata = new SHERPASystemMetadata();\n+\n+        if (systemMetadata.has(\"uri\")) {\n+            this.uri = systemMetadata.getString(\"uri\");\n+            metadata.setUri(this.uri);\n+        } else {\n+            log.error(\"SHERPA URI missing for API response item\");\n+        }\n+        if (systemMetadata.has(\"id\")) {\n+            this.id = systemMetadata.getInt(\"id\");\n+            metadata.setId(this.id);\n+        } else {\n+            log.error(\"SHERPA internal ID missing for API response item\");\n+        }\n+        // Get date created and added - DSpace expects this in the publisher object, though\n+        if (systemMetadata.has(\"date_created\")) {\n+            metadata.setDateCreated(systemMetadata.getString(\"date_created\"));\n+        }\n+        if (systemMetadata.has(\"date_modified\")) {\n+            metadata.setDateModified(systemMetadata.getString(\"date_modified\"));\n+        }\n+        // Is this item publicly visible?\n+        if (systemMetadata.has(\"publicly_visible\")) {\n+            metadata.setPubliclyVisible (\"yes\".equals(systemMetadata\n+                .getString(\"publicly_visible\")));\n+        }\n+        // Is this item listed in the DOAJ?\n+        if (systemMetadata.has(\"listed_in_doaj\")) {\n+            metadata.setPubliclyVisible (\"yes\".equals(systemMetadata\n+                .getString(\"listed_in_doaj\")));\n+        }\n+\n+        return metadata;\n+    }\n+\n+    /**\n+     * Parse journal JSON data and return populated bean\n+     * This method also takes publisherName as a string to help construct some\n+     * legacy labels\n+     * @param item - the main result item JSON (which is the closest thing to an actual 'journal')\n+     * @param publisherName - the parsed publisher name\n+     * @return\n+     */\n+    private SHERPAJournal parseJournal(JSONObject item, String publisherName) {\n+\n+        SHERPAJournal sherpaJournal = new SHERPAJournal();\n+\n+        // set journal title\n+        if (item.has(\"title\")) {\n+            JSONArray titles = item.getJSONArray(\"title\");\n+            if (titles.length() > 0) {\n+                List<String> titleList = new ArrayList<>();\n+                for (int t = 0; t < titles.length(); t++) {\n+                    JSONObject title = titles.getJSONObject(t);\n+                    if (title.has(\"title\")) {\n+                        titleList.add(title.getString(\"title\").trim());\n+                    }\n+                }\n+                sherpaJournal.setTitles(titleList);\n+                if (titleList.size() > 0) {\n+                    // Faking this a bit based on what I'd seen - not in the API v2 data\n+                    sherpaJournal.setRomeoPub(publisherName + \": \"\n+                        + titleList.get(0));\n+                    sherpaJournal.setZetoPub(publisherName + \": \"\n+                        + titleList.get(0));\n+                }\n+            }\n+        }\n+\n+        // Journal URL\n+        if (item.has(\"url\")) {\n+            sherpaJournal.setUrl(item.getString(\"url\"));\n+        }\n+\n+        // set ISSNs\n+        if (item.has(\"issns\")) {\n+            JSONArray issns = item.getJSONArray(\"issns\");\n+            // just get first - DSpace data model only allows for one\n+            List<String> issnList = new ArrayList<>();\n+            for (int ii = 0; ii < issns.length(); ii++) {\n+                JSONObject issn = issns.getJSONObject(ii);\n+                issnList.add(issn.getString(\"issn\").trim());\n+            }\n+            sherpaJournal.setIssns(issnList);\n+        }\n+\n+        // Is the item in DOAJ?\n+        if (item.has(\"listed_in_doaj\")) {\n+            sherpaJournal.setInDOAJ((\"yes\".equals(item.getString(\"listed_in_doaj\"))));\n+        }\n+\n+        return sherpaJournal;\n+    }\n+\n+    /**\n+     * Parse a publisher_policy JSON data and return a populated bean\n+     * @param policy - each publisher policy node in the JSON array\n+     * @return populated SHERPAPublisherPolicy object\n+     */\n+    private SHERPAPublisherPolicy parsePublisherPolicy(JSONObject policy) {\n+\n+        SHERPAPublisherPolicy sherpaPublisherPolicy = new SHERPAPublisherPolicy();\n+\n+        // Get and set monikers\n+        String moniker = null;\n+        if (policy.has(\"internal_moniker\")) {\n+            moniker = policy.getString(\"internal_moniker\");\n+            sherpaPublisherPolicy.setInternalMoniker(moniker);\n+        }\n+\n+        // URLs (used to be Copyright Links)\n+        if (policy.has(\"urls\")) {\n+            JSONArray urls = policy.getJSONArray(\"urls\");\n+            Map<String, String> copyrightLinks = new TreeMap<>();\n+            for (int u = 0; u < urls.length(); u++) {\n+                JSONObject url = urls.getJSONObject(u);\n+                if (url.has(\"description\") && url.has(\"url\")) {\n+                    log.debug(\"Setting copyright URL: \" + url.getString(\"url\"));\n+                    copyrightLinks.put(url.getString(\"url\"), url.getString(\"description\"));\n+                }\n+            }\n+            sherpaPublisherPolicy.setUrls(copyrightLinks);\n+        }\n+\n+        // Permitted OA options\n+        int submittedOption = 0;\n+        int acceptedOption = 0;\n+        int publishedOption = 0;\n+        int currentOption = 0;\n+        if (policy.has(\"permitted_oa\")) {\n+            List<String> allowed = new ArrayList<>();\n+            JSONArray permittedOA = policy.getJSONArray(\"permitted_oa\");\n+            List<SHERPAPermittedVersion> permittedVersions = new ArrayList<>();\n+\n+            // Iterate each permitted OA version / option\n+            for (int p = 0; p < permittedOA.length(); p++) {\n+                JSONObject permitted = permittedOA.getJSONObject(p);\n+                SHERPAPermittedVersion permittedVersion = parsePermittedVersion(permitted);\n+\n+                // To determine which option # we are, inspect article versions and set\n+                allowed.add(permittedVersion.getArticleVersion());\n+                if (\"submitted\".equals(permittedVersion.getArticleVersion())) {\n+                    submittedOption++;\n+                    currentOption = submittedOption;\n+                } else if (\"accepted\".equals(permittedVersion.getArticleVersion())) {\n+                    acceptedOption++;\n+                    currentOption = acceptedOption;\n+                } else if (\"published\".equals(permittedVersion.getArticleVersion())) {\n+                    publishedOption++;\n+                    currentOption = publishedOption;\n+                }\n+                permittedVersion.setOption(currentOption);\n+                permittedVersions.add(permittedVersion);\n+\n+                // Populate the old indicators into the publisher policy object\n+                if (allowed.contains(\"submitted\")) {\n+                    sherpaPublisherPolicy.setPreArchiving(\"can\");\n+                }\n+                if (allowed.contains(\"accepted\")) {\n+                    sherpaPublisherPolicy.setPostArchiving(\"can\");\n+                }\n+                if (allowed.contains(\"published\")) {\n+                    sherpaPublisherPolicy.setPubArchiving(\"can\");\n+                }\n+\n+            }\n+            sherpaPublisherPolicy.setPermittedVersions(permittedVersions);\n+        }\n+\n+        return sherpaPublisherPolicy;\n+    }\n+\n+    /**\n+     * Parse permitted version JSON and populate new bean from the data\n+     * @param permitted - each 'permitted_oa' node in the JSON array\n+     * @return populated SHERPAPermittedVersion object\n+     */\n+    private SHERPAPermittedVersion parsePermittedVersion(JSONObject permitted) {\n+\n+        SHERPAPermittedVersion permittedVersion = new SHERPAPermittedVersion();\n+\n+        // Get the article version, which is ultimately used for the ticks / crosses\n+        // in the UI display. My assumptions around translation:\n+        // submitted = preprint\n+        // accepted = postprint\n+        // published = pdfversion\n+        String articleVersion = \"unknown\";\n+        String versionLabel = \"Unknown\";\n+\n+        if (permitted.has(\"article_version\")) {\n+            JSONArray versions = permitted.getJSONArray(\"article_version\");\n+            articleVersion = versions.getString(0);\n+            permittedVersion.setArticleVersion(articleVersion);\n+            log.debug(\"Added allowed version: \" + articleVersion + \" to list\");\n+        }\n+\n+        if (\"submitted\".equals(articleVersion)) {\n+            versionLabel = I18nUtil.getMessage(\"jsp.sherpa.submitted-version-label\");\n+        } else if (\"accepted\".equals(articleVersion)) {\n+            versionLabel = I18nUtil.getMessage(\"jsp.sherpa.accepted-version-label\");\n+        } else if (\"published\".equals(articleVersion)) {\n+            versionLabel = I18nUtil.getMessage(\"jsp.sherpa.published-version-label\");\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 402}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4MzE0Nw==", "bodyText": "please add basic javadoc here", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r433783147", "createdAt": "2020-06-02T10:42:07Z", "author": {"login": "abollini"}, "path": "dspace-api/src/main/java/org/dspace/app/sherpa/v2/SHERPASystemMetadata.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.sherpa.v2;\n+\n+public class SHERPASystemMetadata {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4Mzk0MQ==", "bodyText": "should we escape some special chars here? maybe double quotes?", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r433783941", "createdAt": "2020-06-02T10:43:50Z", "author": {"login": "abollini"}, "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2JournalDataProvider.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URISyntaxException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.sherpa.v2.SHERPAJournal;\n+import org.dspace.app.sherpa.v2.SHERPAResponse;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+\n+/**\n+ * This class is the implementation of the ExternalDataProvider interface that will deal with SherpaJournal External\n+ * data lookups.\n+ * This provider is a refactored version of SherpaJournalDataPublisher, rewritten to work with SHERPA v2 API\n+ *\n+ * @author Kim Shepherd\n+ */\n+public class SHERPAv2JournalDataProvider implements ExternalDataProvider {\n+\n+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(SHERPAv2JournalDataProvider.class);\n+\n+    private String url;\n+    private String sourceIdentifier;\n+    private String apiKey;\n+\n+    private CloseableHttpClient client = null;\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * Initialise the client that we need to call the endpoint\n+     * @throws IOException  If something goes wrong\n+     */\n+    public void init() throws IOException {\n+        HttpClientBuilder builder = HttpClientBuilder.create();\n+        // httpclient 4.3+ doesn't appear to have any sensible defaults any more. Setting conservative defaults as\n+        // not to hammer the SHERPA service too much.\n+        client = builder\n+            .disableAutomaticRetries()\n+            .setMaxConnTotal(5)\n+            .build();\n+    }\n+\n+    /**\n+     * Get a single journal based on a \"title equals string\" query\n+     * @param id    The journal title which will be used as query string\n+     * @return external data object representing journal\n+     */\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+\n+        HttpGet method = null;\n+        SHERPAResponse sherpaResponse = null;\n+        int timeout = 5000;\n+        URIBuilder uriBuilder = null;\n+        try {\n+            // Construct URI for an exact match on journal title\n+            uriBuilder = new URIBuilder(url);\n+            uriBuilder.addParameter(\"item-type\", \"publication\");\n+            uriBuilder.addParameter(\"filter\", \"[[\\\"title\\\",\\\"equals\\\",\\\"\" + id + \"\\\"]]\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4NDE4MA==", "bodyText": "should we rethrow the exception?", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r433784180", "createdAt": "2020-06-02T10:44:21Z", "author": {"login": "abollini"}, "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2JournalDataProvider.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URISyntaxException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.sherpa.v2.SHERPAJournal;\n+import org.dspace.app.sherpa.v2.SHERPAResponse;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+\n+/**\n+ * This class is the implementation of the ExternalDataProvider interface that will deal with SherpaJournal External\n+ * data lookups.\n+ * This provider is a refactored version of SherpaJournalDataPublisher, rewritten to work with SHERPA v2 API\n+ *\n+ * @author Kim Shepherd\n+ */\n+public class SHERPAv2JournalDataProvider implements ExternalDataProvider {\n+\n+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(SHERPAv2JournalDataProvider.class);\n+\n+    private String url;\n+    private String sourceIdentifier;\n+    private String apiKey;\n+\n+    private CloseableHttpClient client = null;\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * Initialise the client that we need to call the endpoint\n+     * @throws IOException  If something goes wrong\n+     */\n+    public void init() throws IOException {\n+        HttpClientBuilder builder = HttpClientBuilder.create();\n+        // httpclient 4.3+ doesn't appear to have any sensible defaults any more. Setting conservative defaults as\n+        // not to hammer the SHERPA service too much.\n+        client = builder\n+            .disableAutomaticRetries()\n+            .setMaxConnTotal(5)\n+            .build();\n+    }\n+\n+    /**\n+     * Get a single journal based on a \"title equals string\" query\n+     * @param id    The journal title which will be used as query string\n+     * @return external data object representing journal\n+     */\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+\n+        HttpGet method = null;\n+        SHERPAResponse sherpaResponse = null;\n+        int timeout = 5000;\n+        URIBuilder uriBuilder = null;\n+        try {\n+            // Construct URI for an exact match on journal title\n+            uriBuilder = new URIBuilder(url);\n+            uriBuilder.addParameter(\"item-type\", \"publication\");\n+            uriBuilder.addParameter(\"filter\", \"[[\\\"title\\\",\\\"equals\\\",\\\"\" + id + \"\\\"]]\");\n+            uriBuilder.addParameter(\"format\", \"Json\");\n+            if (StringUtils.isNotBlank(apiKey)) {\n+                uriBuilder.addParameter(\"api-key\", apiKey);\n+            }\n+\n+            // Build HTTP method\n+            method = new HttpGet(uriBuilder.build());\n+            method.setConfig(RequestConfig.custom()\n+                                          .setConnectionRequestTimeout(timeout)\n+                                          .setConnectTimeout(timeout)\n+                                          .setSocketTimeout(timeout)\n+                                          .build());\n+\n+            // Execute the method\n+            HttpResponse response = client.execute(method);\n+            int statusCode = response.getStatusLine().getStatusCode();\n+\n+            if (statusCode != HttpStatus.SC_OK) {\n+                sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO return not OK status: \"\n+                                                        + statusCode);\n+            }\n+\n+            HttpEntity responseBody = response.getEntity();\n+\n+            // Get InputStream from API response and parse JSON\n+            if (null != responseBody) {\n+                InputStream content = null;\n+                try {\n+                    content = responseBody.getContent();\n+                    sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                } catch (IOException e) {\n+                    log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            } else {\n+                sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO returned no response\");\n+            }\n+        } catch (Exception e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4NDc3MQ==", "bodyText": "should we escape the query?", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r433784771", "createdAt": "2020-06-02T10:45:31Z", "author": {"login": "abollini"}, "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2JournalDataProvider.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URISyntaxException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.sherpa.v2.SHERPAJournal;\n+import org.dspace.app.sherpa.v2.SHERPAResponse;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+\n+/**\n+ * This class is the implementation of the ExternalDataProvider interface that will deal with SherpaJournal External\n+ * data lookups.\n+ * This provider is a refactored version of SherpaJournalDataPublisher, rewritten to work with SHERPA v2 API\n+ *\n+ * @author Kim Shepherd\n+ */\n+public class SHERPAv2JournalDataProvider implements ExternalDataProvider {\n+\n+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(SHERPAv2JournalDataProvider.class);\n+\n+    private String url;\n+    private String sourceIdentifier;\n+    private String apiKey;\n+\n+    private CloseableHttpClient client = null;\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * Initialise the client that we need to call the endpoint\n+     * @throws IOException  If something goes wrong\n+     */\n+    public void init() throws IOException {\n+        HttpClientBuilder builder = HttpClientBuilder.create();\n+        // httpclient 4.3+ doesn't appear to have any sensible defaults any more. Setting conservative defaults as\n+        // not to hammer the SHERPA service too much.\n+        client = builder\n+            .disableAutomaticRetries()\n+            .setMaxConnTotal(5)\n+            .build();\n+    }\n+\n+    /**\n+     * Get a single journal based on a \"title equals string\" query\n+     * @param id    The journal title which will be used as query string\n+     * @return external data object representing journal\n+     */\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+\n+        HttpGet method = null;\n+        SHERPAResponse sherpaResponse = null;\n+        int timeout = 5000;\n+        URIBuilder uriBuilder = null;\n+        try {\n+            // Construct URI for an exact match on journal title\n+            uriBuilder = new URIBuilder(url);\n+            uriBuilder.addParameter(\"item-type\", \"publication\");\n+            uriBuilder.addParameter(\"filter\", \"[[\\\"title\\\",\\\"equals\\\",\\\"\" + id + \"\\\"]]\");\n+            uriBuilder.addParameter(\"format\", \"Json\");\n+            if (StringUtils.isNotBlank(apiKey)) {\n+                uriBuilder.addParameter(\"api-key\", apiKey);\n+            }\n+\n+            // Build HTTP method\n+            method = new HttpGet(uriBuilder.build());\n+            method.setConfig(RequestConfig.custom()\n+                                          .setConnectionRequestTimeout(timeout)\n+                                          .setConnectTimeout(timeout)\n+                                          .setSocketTimeout(timeout)\n+                                          .build());\n+\n+            // Execute the method\n+            HttpResponse response = client.execute(method);\n+            int statusCode = response.getStatusLine().getStatusCode();\n+\n+            if (statusCode != HttpStatus.SC_OK) {\n+                sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO return not OK status: \"\n+                                                        + statusCode);\n+            }\n+\n+            HttpEntity responseBody = response.getEntity();\n+\n+            // Get InputStream from API response and parse JSON\n+            if (null != responseBody) {\n+                InputStream content = null;\n+                try {\n+                    content = responseBody.getContent();\n+                    sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                } catch (IOException e) {\n+                    log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            } else {\n+                sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO returned no response\");\n+            }\n+        } catch (Exception e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+        }\n+\n+        if (sherpaResponse == null) {\n+            sherpaResponse = new SHERPAResponse(\n+                \"Error processing the SHERPA/RoMEO answer\");\n+        }\n+        if (CollectionUtils.isNotEmpty(sherpaResponse.getJournals())) {\n+            SHERPAJournal sherpaJournal = sherpaResponse.getJournals().get(0);\n+\n+            ExternalDataObject externalDataObject = constructExternalDataObjectFromSherpaJournal(sherpaJournal);\n+            return Optional.of(externalDataObject);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Construct ExternalDataObject populated with journal metadata from the SHERPA v2 API response\n+     * @param sherpaJournal\n+     * @return external data object representing a journal\n+     */\n+    private ExternalDataObject constructExternalDataObjectFromSherpaJournal(SHERPAJournal sherpaJournal) {\n+        // Set up external object\n+        ExternalDataObject externalDataObject = new ExternalDataObject();\n+        externalDataObject.setSource(sourceIdentifier);\n+        // Set journal title in external object\n+        if (CollectionUtils.isNotEmpty(sherpaJournal.getTitles())) {\n+            String journalTitle = sherpaJournal.getTitles().get(0);\n+            externalDataObject.setId(sherpaJournal.getTitles().get(0));\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"title\", null, null, journalTitle));\n+            externalDataObject.setValue(journalTitle);\n+            externalDataObject.setDisplayValue(journalTitle);\n+        }\n+        // Set ISSNs in external object\n+        if (CollectionUtils.isNotEmpty(sherpaJournal.getIssns())) {\n+            String issn = sherpaJournal.getIssns().get(0);\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                    \"dc\", \"identifier\", \"issn\", null, issn));\n+\n+        }\n+\n+        return externalDataObject;\n+    }\n+\n+    /**\n+     * Search SHERPA v2 API for journal results based on a 'contains word' query\n+     * @param query The query for the search\n+     * @param start The start of the search\n+     * @param limit The max amount of records to be returned by the search\n+     * @return a list of external data objects\n+     */\n+    @Override\n+    public List<ExternalDataObject> searchExternalDataObjects(String query, int start, int limit) {\n+        // query args to add to SHERPA/RoMEO request URL\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query, start, limit);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Get response input stream and parse JSON into new SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAResponse sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getJournals())) {\n+                        List<ExternalDataObject> list = sherpaResponse.getJournals().stream().map(\n+                            sherpaJournal -> constructExternalDataObjectFromSherpaJournal(sherpaJournal)).collect(\n+                            Collectors.toList());\n+\n+                        // Unlike the previous API version we can request offset and limit, so no need to build a\n+                        // sublist from this list, we can just return the list.\n+                        return list;\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error parsing SHERPA response input stream: \" + e.getMessage());\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            }\n+        } catch (IOException | URISyntaxException e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+            return null;\n+        } finally {\n+            if (get != null) {\n+                get.releaseConnection();\n+            }\n+        }\n+        return Collections.emptyList();\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"title contains word\" query using default start/limit parameters\n+     * @param query a word or phrase to search for in journal title\n+     * @return HttpGet method which can then be executed by the client\n+     * @throws URISyntaxException if the URL build fails\n+     */\n+    private HttpGet constructHttpGet(String query) throws URISyntaxException {\n+        return constructHttpGet(query, -1, -1);\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"title contains word\" query\n+     * @param query the search query\n+     * @param start row offset\n+     * @param limit number of results to return\n+     * @return HttpGet object to be executed by the client\n+     * @throws URISyntaxException\n+     */\n+    private HttpGet constructHttpGet(String query, int start, int limit) throws URISyntaxException {\n+        // Build URL based on search query\n+        URIBuilder uriBuilder = new URIBuilder(url);\n+        uriBuilder.addParameter(\"item-type\", \"publication\");\n+        uriBuilder.addParameter(\"filter\", \"[[\\\"title\\\",\\\"contains word\\\",\\\"\" + query + \"\\\"]]\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 247}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4NTI5Mw==", "bodyText": "should we rethrow the exception instead?", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r433785293", "createdAt": "2020-06-02T10:46:31Z", "author": {"login": "abollini"}, "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2JournalDataProvider.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URISyntaxException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.sherpa.v2.SHERPAJournal;\n+import org.dspace.app.sherpa.v2.SHERPAResponse;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+\n+/**\n+ * This class is the implementation of the ExternalDataProvider interface that will deal with SherpaJournal External\n+ * data lookups.\n+ * This provider is a refactored version of SherpaJournalDataPublisher, rewritten to work with SHERPA v2 API\n+ *\n+ * @author Kim Shepherd\n+ */\n+public class SHERPAv2JournalDataProvider implements ExternalDataProvider {\n+\n+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(SHERPAv2JournalDataProvider.class);\n+\n+    private String url;\n+    private String sourceIdentifier;\n+    private String apiKey;\n+\n+    private CloseableHttpClient client = null;\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * Initialise the client that we need to call the endpoint\n+     * @throws IOException  If something goes wrong\n+     */\n+    public void init() throws IOException {\n+        HttpClientBuilder builder = HttpClientBuilder.create();\n+        // httpclient 4.3+ doesn't appear to have any sensible defaults any more. Setting conservative defaults as\n+        // not to hammer the SHERPA service too much.\n+        client = builder\n+            .disableAutomaticRetries()\n+            .setMaxConnTotal(5)\n+            .build();\n+    }\n+\n+    /**\n+     * Get a single journal based on a \"title equals string\" query\n+     * @param id    The journal title which will be used as query string\n+     * @return external data object representing journal\n+     */\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+\n+        HttpGet method = null;\n+        SHERPAResponse sherpaResponse = null;\n+        int timeout = 5000;\n+        URIBuilder uriBuilder = null;\n+        try {\n+            // Construct URI for an exact match on journal title\n+            uriBuilder = new URIBuilder(url);\n+            uriBuilder.addParameter(\"item-type\", \"publication\");\n+            uriBuilder.addParameter(\"filter\", \"[[\\\"title\\\",\\\"equals\\\",\\\"\" + id + \"\\\"]]\");\n+            uriBuilder.addParameter(\"format\", \"Json\");\n+            if (StringUtils.isNotBlank(apiKey)) {\n+                uriBuilder.addParameter(\"api-key\", apiKey);\n+            }\n+\n+            // Build HTTP method\n+            method = new HttpGet(uriBuilder.build());\n+            method.setConfig(RequestConfig.custom()\n+                                          .setConnectionRequestTimeout(timeout)\n+                                          .setConnectTimeout(timeout)\n+                                          .setSocketTimeout(timeout)\n+                                          .build());\n+\n+            // Execute the method\n+            HttpResponse response = client.execute(method);\n+            int statusCode = response.getStatusLine().getStatusCode();\n+\n+            if (statusCode != HttpStatus.SC_OK) {\n+                sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO return not OK status: \"\n+                                                        + statusCode);\n+            }\n+\n+            HttpEntity responseBody = response.getEntity();\n+\n+            // Get InputStream from API response and parse JSON\n+            if (null != responseBody) {\n+                InputStream content = null;\n+                try {\n+                    content = responseBody.getContent();\n+                    sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                } catch (IOException e) {\n+                    log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            } else {\n+                sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO returned no response\");\n+            }\n+        } catch (Exception e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+        }\n+\n+        if (sherpaResponse == null) {\n+            sherpaResponse = new SHERPAResponse(\n+                \"Error processing the SHERPA/RoMEO answer\");\n+        }\n+        if (CollectionUtils.isNotEmpty(sherpaResponse.getJournals())) {\n+            SHERPAJournal sherpaJournal = sherpaResponse.getJournals().get(0);\n+\n+            ExternalDataObject externalDataObject = constructExternalDataObjectFromSherpaJournal(sherpaJournal);\n+            return Optional.of(externalDataObject);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Construct ExternalDataObject populated with journal metadata from the SHERPA v2 API response\n+     * @param sherpaJournal\n+     * @return external data object representing a journal\n+     */\n+    private ExternalDataObject constructExternalDataObjectFromSherpaJournal(SHERPAJournal sherpaJournal) {\n+        // Set up external object\n+        ExternalDataObject externalDataObject = new ExternalDataObject();\n+        externalDataObject.setSource(sourceIdentifier);\n+        // Set journal title in external object\n+        if (CollectionUtils.isNotEmpty(sherpaJournal.getTitles())) {\n+            String journalTitle = sherpaJournal.getTitles().get(0);\n+            externalDataObject.setId(sherpaJournal.getTitles().get(0));\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"title\", null, null, journalTitle));\n+            externalDataObject.setValue(journalTitle);\n+            externalDataObject.setDisplayValue(journalTitle);\n+        }\n+        // Set ISSNs in external object\n+        if (CollectionUtils.isNotEmpty(sherpaJournal.getIssns())) {\n+            String issn = sherpaJournal.getIssns().get(0);\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                    \"dc\", \"identifier\", \"issn\", null, issn));\n+\n+        }\n+\n+        return externalDataObject;\n+    }\n+\n+    /**\n+     * Search SHERPA v2 API for journal results based on a 'contains word' query\n+     * @param query The query for the search\n+     * @param start The start of the search\n+     * @param limit The max amount of records to be returned by the search\n+     * @return a list of external data objects\n+     */\n+    @Override\n+    public List<ExternalDataObject> searchExternalDataObjects(String query, int start, int limit) {\n+        // query args to add to SHERPA/RoMEO request URL\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query, start, limit);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Get response input stream and parse JSON into new SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAResponse sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getJournals())) {\n+                        List<ExternalDataObject> list = sherpaResponse.getJournals().stream().map(\n+                            sherpaJournal -> constructExternalDataObjectFromSherpaJournal(sherpaJournal)).collect(\n+                            Collectors.toList());\n+\n+                        // Unlike the previous API version we can request offset and limit, so no need to build a\n+                        // sublist from this list, we can just return the list.\n+                        return list;\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error parsing SHERPA response input stream: \" + e.getMessage());\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            }\n+        } catch (IOException | URISyntaxException e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+            return null;\n+        } finally {\n+            if (get != null) {\n+                get.releaseConnection();\n+            }\n+        }\n+        return Collections.emptyList();\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"title contains word\" query using default start/limit parameters\n+     * @param query a word or phrase to search for in journal title\n+     * @return HttpGet method which can then be executed by the client\n+     * @throws URISyntaxException if the URL build fails\n+     */\n+    private HttpGet constructHttpGet(String query) throws URISyntaxException {\n+        return constructHttpGet(query, -1, -1);\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"title contains word\" query\n+     * @param query the search query\n+     * @param start row offset\n+     * @param limit number of results to return\n+     * @return HttpGet object to be executed by the client\n+     * @throws URISyntaxException\n+     */\n+    private HttpGet constructHttpGet(String query, int start, int limit) throws URISyntaxException {\n+        // Build URL based on search query\n+        URIBuilder uriBuilder = new URIBuilder(url);\n+        uriBuilder.addParameter(\"item-type\", \"publication\");\n+        uriBuilder.addParameter(\"filter\", \"[[\\\"title\\\",\\\"contains word\\\",\\\"\" + query + \"\\\"]]\");\n+        uriBuilder.addParameter(\"format\", \"Json\");\n+        // Set optional start (offset) and limit parameters\n+        if (start >= 0) {\n+            uriBuilder.addParameter(\"offset\", String.valueOf(start));\n+        }\n+        if (limit > 0) {\n+            uriBuilder.addParameter(\"limit\", String.valueOf(limit));\n+        }\n+        if (StringUtils.isNotBlank(apiKey)) {\n+            uriBuilder.addParameter(\"api-key\", apiKey);\n+        }\n+\n+        // Create HTTP GET object\n+        HttpGet method = new HttpGet(uriBuilder.build());\n+\n+        // Set connection parameters\n+        int timeout = 5000;\n+        method.setConfig(RequestConfig.custom()\n+            .setConnectionRequestTimeout(timeout)\n+            .setConnectTimeout(timeout)\n+            .setSocketTimeout(timeout)\n+            .build());\n+        return new HttpGet(uriBuilder.build());\n+    }\n+\n+    @Override\n+    public boolean supports(String source) {\n+        return StringUtils.equalsIgnoreCase(sourceIdentifier, source);\n+    }\n+\n+    /**\n+     * Get number of results returned from a SHERPA v2 publication search\n+     * @param query The query to be search on and give the total amount of results\n+     * @return int representing number of journal results\n+     */\n+    @Override\n+    public int getNumberOfResults(String query) {\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Read response and parse as SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAResponse sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getJournals())) {\n+                        return sherpaResponse.getJournals().size();\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error reading input stream for SHERPAResponse: \" + e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 300}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4NTMzNw==", "bodyText": "should we rethrow the exception instead?", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r433785337", "createdAt": "2020-06-02T10:46:37Z", "author": {"login": "abollini"}, "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2JournalDataProvider.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URISyntaxException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.sherpa.v2.SHERPAJournal;\n+import org.dspace.app.sherpa.v2.SHERPAResponse;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+\n+/**\n+ * This class is the implementation of the ExternalDataProvider interface that will deal with SherpaJournal External\n+ * data lookups.\n+ * This provider is a refactored version of SherpaJournalDataPublisher, rewritten to work with SHERPA v2 API\n+ *\n+ * @author Kim Shepherd\n+ */\n+public class SHERPAv2JournalDataProvider implements ExternalDataProvider {\n+\n+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(SHERPAv2JournalDataProvider.class);\n+\n+    private String url;\n+    private String sourceIdentifier;\n+    private String apiKey;\n+\n+    private CloseableHttpClient client = null;\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * Initialise the client that we need to call the endpoint\n+     * @throws IOException  If something goes wrong\n+     */\n+    public void init() throws IOException {\n+        HttpClientBuilder builder = HttpClientBuilder.create();\n+        // httpclient 4.3+ doesn't appear to have any sensible defaults any more. Setting conservative defaults as\n+        // not to hammer the SHERPA service too much.\n+        client = builder\n+            .disableAutomaticRetries()\n+            .setMaxConnTotal(5)\n+            .build();\n+    }\n+\n+    /**\n+     * Get a single journal based on a \"title equals string\" query\n+     * @param id    The journal title which will be used as query string\n+     * @return external data object representing journal\n+     */\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+\n+        HttpGet method = null;\n+        SHERPAResponse sherpaResponse = null;\n+        int timeout = 5000;\n+        URIBuilder uriBuilder = null;\n+        try {\n+            // Construct URI for an exact match on journal title\n+            uriBuilder = new URIBuilder(url);\n+            uriBuilder.addParameter(\"item-type\", \"publication\");\n+            uriBuilder.addParameter(\"filter\", \"[[\\\"title\\\",\\\"equals\\\",\\\"\" + id + \"\\\"]]\");\n+            uriBuilder.addParameter(\"format\", \"Json\");\n+            if (StringUtils.isNotBlank(apiKey)) {\n+                uriBuilder.addParameter(\"api-key\", apiKey);\n+            }\n+\n+            // Build HTTP method\n+            method = new HttpGet(uriBuilder.build());\n+            method.setConfig(RequestConfig.custom()\n+                                          .setConnectionRequestTimeout(timeout)\n+                                          .setConnectTimeout(timeout)\n+                                          .setSocketTimeout(timeout)\n+                                          .build());\n+\n+            // Execute the method\n+            HttpResponse response = client.execute(method);\n+            int statusCode = response.getStatusLine().getStatusCode();\n+\n+            if (statusCode != HttpStatus.SC_OK) {\n+                sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO return not OK status: \"\n+                                                        + statusCode);\n+            }\n+\n+            HttpEntity responseBody = response.getEntity();\n+\n+            // Get InputStream from API response and parse JSON\n+            if (null != responseBody) {\n+                InputStream content = null;\n+                try {\n+                    content = responseBody.getContent();\n+                    sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                } catch (IOException e) {\n+                    log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            } else {\n+                sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO returned no response\");\n+            }\n+        } catch (Exception e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+        }\n+\n+        if (sherpaResponse == null) {\n+            sherpaResponse = new SHERPAResponse(\n+                \"Error processing the SHERPA/RoMEO answer\");\n+        }\n+        if (CollectionUtils.isNotEmpty(sherpaResponse.getJournals())) {\n+            SHERPAJournal sherpaJournal = sherpaResponse.getJournals().get(0);\n+\n+            ExternalDataObject externalDataObject = constructExternalDataObjectFromSherpaJournal(sherpaJournal);\n+            return Optional.of(externalDataObject);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Construct ExternalDataObject populated with journal metadata from the SHERPA v2 API response\n+     * @param sherpaJournal\n+     * @return external data object representing a journal\n+     */\n+    private ExternalDataObject constructExternalDataObjectFromSherpaJournal(SHERPAJournal sherpaJournal) {\n+        // Set up external object\n+        ExternalDataObject externalDataObject = new ExternalDataObject();\n+        externalDataObject.setSource(sourceIdentifier);\n+        // Set journal title in external object\n+        if (CollectionUtils.isNotEmpty(sherpaJournal.getTitles())) {\n+            String journalTitle = sherpaJournal.getTitles().get(0);\n+            externalDataObject.setId(sherpaJournal.getTitles().get(0));\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"title\", null, null, journalTitle));\n+            externalDataObject.setValue(journalTitle);\n+            externalDataObject.setDisplayValue(journalTitle);\n+        }\n+        // Set ISSNs in external object\n+        if (CollectionUtils.isNotEmpty(sherpaJournal.getIssns())) {\n+            String issn = sherpaJournal.getIssns().get(0);\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                    \"dc\", \"identifier\", \"issn\", null, issn));\n+\n+        }\n+\n+        return externalDataObject;\n+    }\n+\n+    /**\n+     * Search SHERPA v2 API for journal results based on a 'contains word' query\n+     * @param query The query for the search\n+     * @param start The start of the search\n+     * @param limit The max amount of records to be returned by the search\n+     * @return a list of external data objects\n+     */\n+    @Override\n+    public List<ExternalDataObject> searchExternalDataObjects(String query, int start, int limit) {\n+        // query args to add to SHERPA/RoMEO request URL\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query, start, limit);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Get response input stream and parse JSON into new SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAResponse sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getJournals())) {\n+                        List<ExternalDataObject> list = sherpaResponse.getJournals().stream().map(\n+                            sherpaJournal -> constructExternalDataObjectFromSherpaJournal(sherpaJournal)).collect(\n+                            Collectors.toList());\n+\n+                        // Unlike the previous API version we can request offset and limit, so no need to build a\n+                        // sublist from this list, we can just return the list.\n+                        return list;\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error parsing SHERPA response input stream: \" + e.getMessage());\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            }\n+        } catch (IOException | URISyntaxException e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+            return null;\n+        } finally {\n+            if (get != null) {\n+                get.releaseConnection();\n+            }\n+        }\n+        return Collections.emptyList();\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"title contains word\" query using default start/limit parameters\n+     * @param query a word or phrase to search for in journal title\n+     * @return HttpGet method which can then be executed by the client\n+     * @throws URISyntaxException if the URL build fails\n+     */\n+    private HttpGet constructHttpGet(String query) throws URISyntaxException {\n+        return constructHttpGet(query, -1, -1);\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"title contains word\" query\n+     * @param query the search query\n+     * @param start row offset\n+     * @param limit number of results to return\n+     * @return HttpGet object to be executed by the client\n+     * @throws URISyntaxException\n+     */\n+    private HttpGet constructHttpGet(String query, int start, int limit) throws URISyntaxException {\n+        // Build URL based on search query\n+        URIBuilder uriBuilder = new URIBuilder(url);\n+        uriBuilder.addParameter(\"item-type\", \"publication\");\n+        uriBuilder.addParameter(\"filter\", \"[[\\\"title\\\",\\\"contains word\\\",\\\"\" + query + \"\\\"]]\");\n+        uriBuilder.addParameter(\"format\", \"Json\");\n+        // Set optional start (offset) and limit parameters\n+        if (start >= 0) {\n+            uriBuilder.addParameter(\"offset\", String.valueOf(start));\n+        }\n+        if (limit > 0) {\n+            uriBuilder.addParameter(\"limit\", String.valueOf(limit));\n+        }\n+        if (StringUtils.isNotBlank(apiKey)) {\n+            uriBuilder.addParameter(\"api-key\", apiKey);\n+        }\n+\n+        // Create HTTP GET object\n+        HttpGet method = new HttpGet(uriBuilder.build());\n+\n+        // Set connection parameters\n+        int timeout = 5000;\n+        method.setConfig(RequestConfig.custom()\n+            .setConnectionRequestTimeout(timeout)\n+            .setConnectTimeout(timeout)\n+            .setSocketTimeout(timeout)\n+            .build());\n+        return new HttpGet(uriBuilder.build());\n+    }\n+\n+    @Override\n+    public boolean supports(String source) {\n+        return StringUtils.equalsIgnoreCase(sourceIdentifier, source);\n+    }\n+\n+    /**\n+     * Get number of results returned from a SHERPA v2 publication search\n+     * @param query The query to be search on and give the total amount of results\n+     * @return int representing number of journal results\n+     */\n+    @Override\n+    public int getNumberOfResults(String query) {\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Read response and parse as SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAResponse sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getJournals())) {\n+                        return sherpaResponse.getJournals().size();\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error reading input stream for SHERPAResponse: \" + e.getMessage());\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            }\n+        } catch (IOException | URISyntaxException e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 308}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4NTU2Mg==", "bodyText": "should we rethrow the exception instead?", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r433785562", "createdAt": "2020-06-02T10:47:07Z", "author": {"login": "abollini"}, "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2PublisherDataProvider.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URISyntaxException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.sherpa.v2.SHERPAPublisher;\n+import org.dspace.app.sherpa.v2.SHERPAPublisherResponse;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+\n+/**\n+ * This class is the implementation of the ExternalDataProvider interface that will deal with SHERPAPublisher External\n+ * data lookups.\n+ * This provider is a refactored version of SherpaPublisherDataPublisher, rewritten to work with SHERPA v2 API\n+ *\n+ * It uses a more simple response object than the normal publication / policy search\n+ *\n+ * @author Kim Shepherd\n+ */\n+public class SHERPAv2PublisherDataProvider implements ExternalDataProvider {\n+\n+    private static final Logger log =\n+        org.apache.logging.log4j.LogManager.getLogger(SHERPAv2PublisherDataProvider.class);\n+\n+    private String sourceIdentifier;\n+    private String url;\n+    private String apiKey;\n+\n+    private CloseableHttpClient client = null;\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * Initialise the client that we need to call the endpoint\n+     * @throws IOException  If something goes wrong\n+     */\n+    public void init() throws IOException {\n+        HttpClientBuilder builder = HttpClientBuilder.create();\n+        // httpclient 4.3+ doesn't appear to have any sensible defaults any more. Setting conservative defaults as\n+        // not to hammer the SHERPA service too much.\n+        client = builder\n+            .disableAutomaticRetries()\n+            .setMaxConnTotal(5)\n+            .build();\n+    }\n+\n+    /**\n+     * Get a single publisher based on a \"id equals string\" query\n+     * @param id    The publisher ID which will be used as query string\n+     * @return external data object representing publisher\n+     */\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+\n+        HttpGet method = null;\n+        SHERPAPublisherResponse sherpaResponse = null;\n+        int timeout = 5000;\n+        URIBuilder uriBuilder = null;\n+        try {\n+            // Construct URI for an exact match on journal title\n+            uriBuilder = new URIBuilder(url);\n+            uriBuilder.addParameter(\"item-type\", \"publisher\");\n+            uriBuilder.addParameter(\"filter\", \"[[\\\"id\\\",\\\"equals\\\",\\\"\" + id + \"\\\"]]\");\n+            uriBuilder.addParameter(\"format\", \"Json\");\n+            if (StringUtils.isNotBlank(apiKey)) {\n+                uriBuilder.addParameter(\"api-key\", apiKey);\n+            }\n+\n+            // Build HTTP method\n+            method = new HttpGet(uriBuilder.build());\n+            method.setConfig(RequestConfig.custom()\n+                .setConnectionRequestTimeout(timeout)\n+                .setConnectTimeout(timeout)\n+                .setSocketTimeout(timeout)\n+                .build());\n+\n+            // Execute the method\n+            HttpResponse response = client.execute(method);\n+            int statusCode = response.getStatusLine().getStatusCode();\n+\n+            if (statusCode != HttpStatus.SC_OK) {\n+                sherpaResponse = new SHERPAPublisherResponse(\"SHERPA/RoMEO return not OK status: \"\n+                    + statusCode);\n+            }\n+\n+            HttpEntity responseBody = response.getEntity();\n+\n+            // Get InputStream from API response and parse JSON\n+            if (null != responseBody) {\n+                InputStream content = null;\n+                try {\n+                    content = responseBody.getContent();\n+                    sherpaResponse = new SHERPAPublisherResponse(content, SHERPAPublisherResponse.SHERPAFormat.JSON);\n+                } catch (IOException e) {\n+                    log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            } else {\n+                sherpaResponse = new SHERPAPublisherResponse(\"SHERPA/RoMEO returned no response\");\n+            }\n+        } catch (Exception e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+        }\n+\n+        if (sherpaResponse == null) {\n+            sherpaResponse = new SHERPAPublisherResponse(\"Error processing the SHERPA/RoMEO answer\");\n+        }\n+        if (CollectionUtils.isNotEmpty(sherpaResponse.getPublishers())) {\n+            SHERPAPublisher sherpaPublisher = sherpaResponse.getPublishers().get(0);\n+            // Construct external data object from returned publisher\n+            ExternalDataObject externalDataObject = constructExternalDataObjectFromSherpaPublisher(sherpaPublisher);\n+            return Optional.of(externalDataObject);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Search SHERPA v2 API for publisher results based on a 'contains word' query for publisher name\n+     * @param query The query for the search\n+     * @param start The start of the search\n+     * @param limit The max amount of records to be returned by the search\n+     * @return a list of external data objects\n+     */\n+    @Override\n+    public List<ExternalDataObject> searchExternalDataObjects(String query, int start, int limit) {\n+        // query args to add to SHERPA/RoMEO request URL\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query, start, limit);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Get response input stream and parse JSON into new SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAPublisherResponse sherpaResponse =\n+                        new SHERPAPublisherResponse(content, SHERPAPublisherResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getPublishers())) {\n+                        List<ExternalDataObject> list = sherpaResponse.getPublishers().stream().map(\n+                            sherpaPublisher -> constructExternalDataObjectFromSherpaPublisher(sherpaPublisher)).collect(\n+                            Collectors.toList());\n+\n+                        // Unlike the previous API version we can request offset and limit, so no need to build a\n+                        // sublist from this list, we can just return the list.\n+                        return list;\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error parsing SHERPA response input stream: \" + e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4NTczNw==", "bodyText": "do we need to escape the query?", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r433785737", "createdAt": "2020-06-02T10:47:27Z", "author": {"login": "abollini"}, "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2PublisherDataProvider.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URISyntaxException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.sherpa.v2.SHERPAPublisher;\n+import org.dspace.app.sherpa.v2.SHERPAPublisherResponse;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+\n+/**\n+ * This class is the implementation of the ExternalDataProvider interface that will deal with SHERPAPublisher External\n+ * data lookups.\n+ * This provider is a refactored version of SherpaPublisherDataPublisher, rewritten to work with SHERPA v2 API\n+ *\n+ * It uses a more simple response object than the normal publication / policy search\n+ *\n+ * @author Kim Shepherd\n+ */\n+public class SHERPAv2PublisherDataProvider implements ExternalDataProvider {\n+\n+    private static final Logger log =\n+        org.apache.logging.log4j.LogManager.getLogger(SHERPAv2PublisherDataProvider.class);\n+\n+    private String sourceIdentifier;\n+    private String url;\n+    private String apiKey;\n+\n+    private CloseableHttpClient client = null;\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * Initialise the client that we need to call the endpoint\n+     * @throws IOException  If something goes wrong\n+     */\n+    public void init() throws IOException {\n+        HttpClientBuilder builder = HttpClientBuilder.create();\n+        // httpclient 4.3+ doesn't appear to have any sensible defaults any more. Setting conservative defaults as\n+        // not to hammer the SHERPA service too much.\n+        client = builder\n+            .disableAutomaticRetries()\n+            .setMaxConnTotal(5)\n+            .build();\n+    }\n+\n+    /**\n+     * Get a single publisher based on a \"id equals string\" query\n+     * @param id    The publisher ID which will be used as query string\n+     * @return external data object representing publisher\n+     */\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+\n+        HttpGet method = null;\n+        SHERPAPublisherResponse sherpaResponse = null;\n+        int timeout = 5000;\n+        URIBuilder uriBuilder = null;\n+        try {\n+            // Construct URI for an exact match on journal title\n+            uriBuilder = new URIBuilder(url);\n+            uriBuilder.addParameter(\"item-type\", \"publisher\");\n+            uriBuilder.addParameter(\"filter\", \"[[\\\"id\\\",\\\"equals\\\",\\\"\" + id + \"\\\"]]\");\n+            uriBuilder.addParameter(\"format\", \"Json\");\n+            if (StringUtils.isNotBlank(apiKey)) {\n+                uriBuilder.addParameter(\"api-key\", apiKey);\n+            }\n+\n+            // Build HTTP method\n+            method = new HttpGet(uriBuilder.build());\n+            method.setConfig(RequestConfig.custom()\n+                .setConnectionRequestTimeout(timeout)\n+                .setConnectTimeout(timeout)\n+                .setSocketTimeout(timeout)\n+                .build());\n+\n+            // Execute the method\n+            HttpResponse response = client.execute(method);\n+            int statusCode = response.getStatusLine().getStatusCode();\n+\n+            if (statusCode != HttpStatus.SC_OK) {\n+                sherpaResponse = new SHERPAPublisherResponse(\"SHERPA/RoMEO return not OK status: \"\n+                    + statusCode);\n+            }\n+\n+            HttpEntity responseBody = response.getEntity();\n+\n+            // Get InputStream from API response and parse JSON\n+            if (null != responseBody) {\n+                InputStream content = null;\n+                try {\n+                    content = responseBody.getContent();\n+                    sherpaResponse = new SHERPAPublisherResponse(content, SHERPAPublisherResponse.SHERPAFormat.JSON);\n+                } catch (IOException e) {\n+                    log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            } else {\n+                sherpaResponse = new SHERPAPublisherResponse(\"SHERPA/RoMEO returned no response\");\n+            }\n+        } catch (Exception e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+        }\n+\n+        if (sherpaResponse == null) {\n+            sherpaResponse = new SHERPAPublisherResponse(\"Error processing the SHERPA/RoMEO answer\");\n+        }\n+        if (CollectionUtils.isNotEmpty(sherpaResponse.getPublishers())) {\n+            SHERPAPublisher sherpaPublisher = sherpaResponse.getPublishers().get(0);\n+            // Construct external data object from returned publisher\n+            ExternalDataObject externalDataObject = constructExternalDataObjectFromSherpaPublisher(sherpaPublisher);\n+            return Optional.of(externalDataObject);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Search SHERPA v2 API for publisher results based on a 'contains word' query for publisher name\n+     * @param query The query for the search\n+     * @param start The start of the search\n+     * @param limit The max amount of records to be returned by the search\n+     * @return a list of external data objects\n+     */\n+    @Override\n+    public List<ExternalDataObject> searchExternalDataObjects(String query, int start, int limit) {\n+        // query args to add to SHERPA/RoMEO request URL\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query, start, limit);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Get response input stream and parse JSON into new SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAPublisherResponse sherpaResponse =\n+                        new SHERPAPublisherResponse(content, SHERPAPublisherResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getPublishers())) {\n+                        List<ExternalDataObject> list = sherpaResponse.getPublishers().stream().map(\n+                            sherpaPublisher -> constructExternalDataObjectFromSherpaPublisher(sherpaPublisher)).collect(\n+                            Collectors.toList());\n+\n+                        // Unlike the previous API version we can request offset and limit, so no need to build a\n+                        // sublist from this list, we can just return the list.\n+                        return list;\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error parsing SHERPA response input stream: \" + e.getMessage());\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            }\n+        } catch (IOException | URISyntaxException e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+            return null;\n+        } finally {\n+            if (get != null) {\n+                get.releaseConnection();\n+            }\n+        }\n+        return Collections.emptyList();\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"publisher name contains word\" query using default start/limit parameters\n+     * @param query a word or phrase to search for in publisher name\n+     * @return HttpGet method which can then be executed by the client\n+     * @throws URISyntaxException if the URL build fails\n+     */\n+    private HttpGet constructHttpGet(String query) throws URISyntaxException {\n+        return constructHttpGet(query, -1, -1);\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"publisher name contains word\" query\n+     * @param query the search query\n+     * @param start row offset\n+     * @param limit number of results to return\n+     * @return HttpGet object to be executed by the client\n+     * @throws URISyntaxException\n+     */\n+    private HttpGet constructHttpGet(String query, int start, int limit) throws URISyntaxException {\n+        // Build URL based on search query\n+        URIBuilder uriBuilder = new URIBuilder(url);\n+        uriBuilder.addParameter(\"item-type\", \"publisher\");\n+        uriBuilder.addParameter(\"filter\", \"[[\\\"name\\\",\\\"contains word\\\",\\\"\" + query + \"\\\"]]\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4NjIxNg==", "bodyText": "should we rethrow the exception instead?", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r433786216", "createdAt": "2020-06-02T10:48:21Z", "author": {"login": "abollini"}, "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2PublisherDataProvider.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URISyntaxException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.sherpa.v2.SHERPAPublisher;\n+import org.dspace.app.sherpa.v2.SHERPAPublisherResponse;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+\n+/**\n+ * This class is the implementation of the ExternalDataProvider interface that will deal with SHERPAPublisher External\n+ * data lookups.\n+ * This provider is a refactored version of SherpaPublisherDataPublisher, rewritten to work with SHERPA v2 API\n+ *\n+ * It uses a more simple response object than the normal publication / policy search\n+ *\n+ * @author Kim Shepherd\n+ */\n+public class SHERPAv2PublisherDataProvider implements ExternalDataProvider {\n+\n+    private static final Logger log =\n+        org.apache.logging.log4j.LogManager.getLogger(SHERPAv2PublisherDataProvider.class);\n+\n+    private String sourceIdentifier;\n+    private String url;\n+    private String apiKey;\n+\n+    private CloseableHttpClient client = null;\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * Initialise the client that we need to call the endpoint\n+     * @throws IOException  If something goes wrong\n+     */\n+    public void init() throws IOException {\n+        HttpClientBuilder builder = HttpClientBuilder.create();\n+        // httpclient 4.3+ doesn't appear to have any sensible defaults any more. Setting conservative defaults as\n+        // not to hammer the SHERPA service too much.\n+        client = builder\n+            .disableAutomaticRetries()\n+            .setMaxConnTotal(5)\n+            .build();\n+    }\n+\n+    /**\n+     * Get a single publisher based on a \"id equals string\" query\n+     * @param id    The publisher ID which will be used as query string\n+     * @return external data object representing publisher\n+     */\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+\n+        HttpGet method = null;\n+        SHERPAPublisherResponse sherpaResponse = null;\n+        int timeout = 5000;\n+        URIBuilder uriBuilder = null;\n+        try {\n+            // Construct URI for an exact match on journal title\n+            uriBuilder = new URIBuilder(url);\n+            uriBuilder.addParameter(\"item-type\", \"publisher\");\n+            uriBuilder.addParameter(\"filter\", \"[[\\\"id\\\",\\\"equals\\\",\\\"\" + id + \"\\\"]]\");\n+            uriBuilder.addParameter(\"format\", \"Json\");\n+            if (StringUtils.isNotBlank(apiKey)) {\n+                uriBuilder.addParameter(\"api-key\", apiKey);\n+            }\n+\n+            // Build HTTP method\n+            method = new HttpGet(uriBuilder.build());\n+            method.setConfig(RequestConfig.custom()\n+                .setConnectionRequestTimeout(timeout)\n+                .setConnectTimeout(timeout)\n+                .setSocketTimeout(timeout)\n+                .build());\n+\n+            // Execute the method\n+            HttpResponse response = client.execute(method);\n+            int statusCode = response.getStatusLine().getStatusCode();\n+\n+            if (statusCode != HttpStatus.SC_OK) {\n+                sherpaResponse = new SHERPAPublisherResponse(\"SHERPA/RoMEO return not OK status: \"\n+                    + statusCode);\n+            }\n+\n+            HttpEntity responseBody = response.getEntity();\n+\n+            // Get InputStream from API response and parse JSON\n+            if (null != responseBody) {\n+                InputStream content = null;\n+                try {\n+                    content = responseBody.getContent();\n+                    sherpaResponse = new SHERPAPublisherResponse(content, SHERPAPublisherResponse.SHERPAFormat.JSON);\n+                } catch (IOException e) {\n+                    log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            } else {\n+                sherpaResponse = new SHERPAPublisherResponse(\"SHERPA/RoMEO returned no response\");\n+            }\n+        } catch (Exception e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+        }\n+\n+        if (sherpaResponse == null) {\n+            sherpaResponse = new SHERPAPublisherResponse(\"Error processing the SHERPA/RoMEO answer\");\n+        }\n+        if (CollectionUtils.isNotEmpty(sherpaResponse.getPublishers())) {\n+            SHERPAPublisher sherpaPublisher = sherpaResponse.getPublishers().get(0);\n+            // Construct external data object from returned publisher\n+            ExternalDataObject externalDataObject = constructExternalDataObjectFromSherpaPublisher(sherpaPublisher);\n+            return Optional.of(externalDataObject);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Search SHERPA v2 API for publisher results based on a 'contains word' query for publisher name\n+     * @param query The query for the search\n+     * @param start The start of the search\n+     * @param limit The max amount of records to be returned by the search\n+     * @return a list of external data objects\n+     */\n+    @Override\n+    public List<ExternalDataObject> searchExternalDataObjects(String query, int start, int limit) {\n+        // query args to add to SHERPA/RoMEO request URL\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query, start, limit);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Get response input stream and parse JSON into new SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAPublisherResponse sherpaResponse =\n+                        new SHERPAPublisherResponse(content, SHERPAPublisherResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getPublishers())) {\n+                        List<ExternalDataObject> list = sherpaResponse.getPublishers().stream().map(\n+                            sherpaPublisher -> constructExternalDataObjectFromSherpaPublisher(sherpaPublisher)).collect(\n+                            Collectors.toList());\n+\n+                        // Unlike the previous API version we can request offset and limit, so no need to build a\n+                        // sublist from this list, we can just return the list.\n+                        return list;\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error parsing SHERPA response input stream: \" + e.getMessage());\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            }\n+        } catch (IOException | URISyntaxException e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+            return null;\n+        } finally {\n+            if (get != null) {\n+                get.releaseConnection();\n+            }\n+        }\n+        return Collections.emptyList();\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"publisher name contains word\" query using default start/limit parameters\n+     * @param query a word or phrase to search for in publisher name\n+     * @return HttpGet method which can then be executed by the client\n+     * @throws URISyntaxException if the URL build fails\n+     */\n+    private HttpGet constructHttpGet(String query) throws URISyntaxException {\n+        return constructHttpGet(query, -1, -1);\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"publisher name contains word\" query\n+     * @param query the search query\n+     * @param start row offset\n+     * @param limit number of results to return\n+     * @return HttpGet object to be executed by the client\n+     * @throws URISyntaxException\n+     */\n+    private HttpGet constructHttpGet(String query, int start, int limit) throws URISyntaxException {\n+        // Build URL based on search query\n+        URIBuilder uriBuilder = new URIBuilder(url);\n+        uriBuilder.addParameter(\"item-type\", \"publisher\");\n+        uriBuilder.addParameter(\"filter\", \"[[\\\"name\\\",\\\"contains word\\\",\\\"\" + query + \"\\\"]]\");\n+        uriBuilder.addParameter(\"format\", \"Json\");\n+        // Set optional start (offset) and limit parameters\n+        if (start >= 0) {\n+            uriBuilder.addParameter(\"offset\", String.valueOf(start));\n+        }\n+        if (limit > 0) {\n+            uriBuilder.addParameter(\"limit\", String.valueOf(limit));\n+        }\n+        if (StringUtils.isNotBlank(apiKey)) {\n+            uriBuilder.addParameter(\"api-key\", apiKey);\n+        }\n+\n+        // Create HTTP GET object\n+        HttpGet method = new HttpGet(uriBuilder.build());\n+\n+        // Set connection parameters\n+        int timeout = 5000;\n+        method.setConfig(RequestConfig.custom()\n+            .setConnectionRequestTimeout(timeout)\n+            .setConnectTimeout(timeout)\n+            .setSocketTimeout(timeout)\n+            .build());\n+        return new HttpGet(uriBuilder.build());\n+    }\n+\n+    private ExternalDataObject constructExternalDataObjectFromSherpaPublisher(SHERPAPublisher sherpaPublisher) {\n+        ExternalDataObject externalDataObject = new ExternalDataObject();\n+        externalDataObject.setSource(sourceIdentifier);\n+\n+        // Set publisher name\n+        if (StringUtils.isNotBlank(sherpaPublisher.getName())) {\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"title\", null, null, sherpaPublisher.getName()));\n+            externalDataObject.setDisplayValue(sherpaPublisher.getName());\n+            externalDataObject.setValue(sherpaPublisher.getName());\n+        }\n+        // Set publisher ID\n+        if (StringUtils.isNotBlank(sherpaPublisher.getIdentifier())) {\n+            externalDataObject.setId(sherpaPublisher.getIdentifier());\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"identifier\", \"sherpaPublisher\", null,\n+                sherpaPublisher.getIdentifier()));\n+        }\n+\n+        // Set home URL\n+        if (StringUtils.isNotBlank(sherpaPublisher.getUri())) {\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"identifier\", \"other\", null, sherpaPublisher.getUri()));\n+        }\n+\n+        return externalDataObject;\n+    }\n+\n+    @Override\n+    public boolean supports(String source) {\n+        return StringUtils.equalsIgnoreCase(sourceIdentifier, source);\n+    }\n+\n+    /**\n+     * Get number of results returned from a SHERPA v2 publication search\n+     * @param query The query to be search on and give the total amount of results\n+     * @return int representing number of publisher results\n+     */\n+    @Override\n+    public int getNumberOfResults(String query) {\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Read response and parse as SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAPublisherResponse sherpaResponse =\n+                        new SHERPAPublisherResponse(content, SHERPAPublisherResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getPublishers())) {\n+                        return sherpaResponse.getPublishers().size();\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error reading input stream for SHERPAResponse: \" + e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 303}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4ODA5Nw==", "bodyText": "I would prefer to get this information directly from the configuration service. Having this internal cache will prevent us to add the apikey later and auto-reload it without restart. Moreover, it makes a bit harder to create an Integration Test", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r433788097", "createdAt": "2020-06-02T10:52:24Z", "author": {"login": "abollini"}, "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2JournalDataProvider.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URISyntaxException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.sherpa.v2.SHERPAJournal;\n+import org.dspace.app.sherpa.v2.SHERPAResponse;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+\n+/**\n+ * This class is the implementation of the ExternalDataProvider interface that will deal with SherpaJournal External\n+ * data lookups.\n+ * This provider is a refactored version of SherpaJournalDataPublisher, rewritten to work with SHERPA v2 API\n+ *\n+ * @author Kim Shepherd\n+ */\n+public class SHERPAv2JournalDataProvider implements ExternalDataProvider {\n+\n+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(SHERPAv2JournalDataProvider.class);\n+\n+    private String url;\n+    private String sourceIdentifier;\n+    private String apiKey;\n+\n+    private CloseableHttpClient client = null;\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * Initialise the client that we need to call the endpoint\n+     * @throws IOException  If something goes wrong\n+     */\n+    public void init() throws IOException {\n+        HttpClientBuilder builder = HttpClientBuilder.create();\n+        // httpclient 4.3+ doesn't appear to have any sensible defaults any more. Setting conservative defaults as\n+        // not to hammer the SHERPA service too much.\n+        client = builder\n+            .disableAutomaticRetries()\n+            .setMaxConnTotal(5)\n+            .build();\n+    }\n+\n+    /**\n+     * Get a single journal based on a \"title equals string\" query\n+     * @param id    The journal title which will be used as query string\n+     * @return external data object representing journal\n+     */\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+\n+        HttpGet method = null;\n+        SHERPAResponse sherpaResponse = null;\n+        int timeout = 5000;\n+        URIBuilder uriBuilder = null;\n+        try {\n+            // Construct URI for an exact match on journal title\n+            uriBuilder = new URIBuilder(url);\n+            uriBuilder.addParameter(\"item-type\", \"publication\");\n+            uriBuilder.addParameter(\"filter\", \"[[\\\"title\\\",\\\"equals\\\",\\\"\" + id + \"\\\"]]\");\n+            uriBuilder.addParameter(\"format\", \"Json\");\n+            if (StringUtils.isNotBlank(apiKey)) {\n+                uriBuilder.addParameter(\"api-key\", apiKey);\n+            }\n+\n+            // Build HTTP method\n+            method = new HttpGet(uriBuilder.build());\n+            method.setConfig(RequestConfig.custom()\n+                                          .setConnectionRequestTimeout(timeout)\n+                                          .setConnectTimeout(timeout)\n+                                          .setSocketTimeout(timeout)\n+                                          .build());\n+\n+            // Execute the method\n+            HttpResponse response = client.execute(method);\n+            int statusCode = response.getStatusLine().getStatusCode();\n+\n+            if (statusCode != HttpStatus.SC_OK) {\n+                sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO return not OK status: \"\n+                                                        + statusCode);\n+            }\n+\n+            HttpEntity responseBody = response.getEntity();\n+\n+            // Get InputStream from API response and parse JSON\n+            if (null != responseBody) {\n+                InputStream content = null;\n+                try {\n+                    content = responseBody.getContent();\n+                    sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                } catch (IOException e) {\n+                    log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            } else {\n+                sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO returned no response\");\n+            }\n+        } catch (Exception e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+        }\n+\n+        if (sherpaResponse == null) {\n+            sherpaResponse = new SHERPAResponse(\n+                \"Error processing the SHERPA/RoMEO answer\");\n+        }\n+        if (CollectionUtils.isNotEmpty(sherpaResponse.getJournals())) {\n+            SHERPAJournal sherpaJournal = sherpaResponse.getJournals().get(0);\n+\n+            ExternalDataObject externalDataObject = constructExternalDataObjectFromSherpaJournal(sherpaJournal);\n+            return Optional.of(externalDataObject);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Construct ExternalDataObject populated with journal metadata from the SHERPA v2 API response\n+     * @param sherpaJournal\n+     * @return external data object representing a journal\n+     */\n+    private ExternalDataObject constructExternalDataObjectFromSherpaJournal(SHERPAJournal sherpaJournal) {\n+        // Set up external object\n+        ExternalDataObject externalDataObject = new ExternalDataObject();\n+        externalDataObject.setSource(sourceIdentifier);\n+        // Set journal title in external object\n+        if (CollectionUtils.isNotEmpty(sherpaJournal.getTitles())) {\n+            String journalTitle = sherpaJournal.getTitles().get(0);\n+            externalDataObject.setId(sherpaJournal.getTitles().get(0));\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"title\", null, null, journalTitle));\n+            externalDataObject.setValue(journalTitle);\n+            externalDataObject.setDisplayValue(journalTitle);\n+        }\n+        // Set ISSNs in external object\n+        if (CollectionUtils.isNotEmpty(sherpaJournal.getIssns())) {\n+            String issn = sherpaJournal.getIssns().get(0);\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                    \"dc\", \"identifier\", \"issn\", null, issn));\n+\n+        }\n+\n+        return externalDataObject;\n+    }\n+\n+    /**\n+     * Search SHERPA v2 API for journal results based on a 'contains word' query\n+     * @param query The query for the search\n+     * @param start The start of the search\n+     * @param limit The max amount of records to be returned by the search\n+     * @return a list of external data objects\n+     */\n+    @Override\n+    public List<ExternalDataObject> searchExternalDataObjects(String query, int start, int limit) {\n+        // query args to add to SHERPA/RoMEO request URL\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query, start, limit);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Get response input stream and parse JSON into new SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAResponse sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getJournals())) {\n+                        List<ExternalDataObject> list = sherpaResponse.getJournals().stream().map(\n+                            sherpaJournal -> constructExternalDataObjectFromSherpaJournal(sherpaJournal)).collect(\n+                            Collectors.toList());\n+\n+                        // Unlike the previous API version we can request offset and limit, so no need to build a\n+                        // sublist from this list, we can just return the list.\n+                        return list;\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error parsing SHERPA response input stream: \" + e.getMessage());\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            }\n+        } catch (IOException | URISyntaxException e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+            return null;\n+        } finally {\n+            if (get != null) {\n+                get.releaseConnection();\n+            }\n+        }\n+        return Collections.emptyList();\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"title contains word\" query using default start/limit parameters\n+     * @param query a word or phrase to search for in journal title\n+     * @return HttpGet method which can then be executed by the client\n+     * @throws URISyntaxException if the URL build fails\n+     */\n+    private HttpGet constructHttpGet(String query) throws URISyntaxException {\n+        return constructHttpGet(query, -1, -1);\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"title contains word\" query\n+     * @param query the search query\n+     * @param start row offset\n+     * @param limit number of results to return\n+     * @return HttpGet object to be executed by the client\n+     * @throws URISyntaxException\n+     */\n+    private HttpGet constructHttpGet(String query, int start, int limit) throws URISyntaxException {\n+        // Build URL based on search query\n+        URIBuilder uriBuilder = new URIBuilder(url);\n+        uriBuilder.addParameter(\"item-type\", \"publication\");\n+        uriBuilder.addParameter(\"filter\", \"[[\\\"title\\\",\\\"contains word\\\",\\\"\" + query + \"\\\"]]\");\n+        uriBuilder.addParameter(\"format\", \"Json\");\n+        // Set optional start (offset) and limit parameters\n+        if (start >= 0) {\n+            uriBuilder.addParameter(\"offset\", String.valueOf(start));\n+        }\n+        if (limit > 0) {\n+            uriBuilder.addParameter(\"limit\", String.valueOf(limit));\n+        }\n+        if (StringUtils.isNotBlank(apiKey)) {\n+            uriBuilder.addParameter(\"api-key\", apiKey);\n+        }\n+\n+        // Create HTTP GET object\n+        HttpGet method = new HttpGet(uriBuilder.build());\n+\n+        // Set connection parameters\n+        int timeout = 5000;\n+        method.setConfig(RequestConfig.custom()\n+            .setConnectionRequestTimeout(timeout)\n+            .setConnectTimeout(timeout)\n+            .setSocketTimeout(timeout)\n+            .build());\n+        return new HttpGet(uriBuilder.build());\n+    }\n+\n+    @Override\n+    public boolean supports(String source) {\n+        return StringUtils.equalsIgnoreCase(sourceIdentifier, source);\n+    }\n+\n+    /**\n+     * Get number of results returned from a SHERPA v2 publication search\n+     * @param query The query to be search on and give the total amount of results\n+     * @return int representing number of journal results\n+     */\n+    @Override\n+    public int getNumberOfResults(String query) {\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Read response and parse as SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAResponse sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getJournals())) {\n+                        return sherpaResponse.getJournals().size();\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error reading input stream for SHERPAResponse: \" + e.getMessage());\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            }\n+        } catch (IOException | URISyntaxException e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+            return 0;\n+        } finally {\n+            if (get != null) {\n+                get.releaseConnection();\n+            }\n+        }\n+        // If other checks have failed return 0\n+        return 0;\n+    }\n+\n+    /**\n+     * Generic setter for the sourceIdentifier\n+     * @param sourceIdentifier   The sourceIdentifier to be set on this SHERPAv2JournalDataProvider\n+     */\n+    public void setSourceIdentifier(String sourceIdentifier) {\n+        this.sourceIdentifier = sourceIdentifier;\n+    }\n+\n+    /**\n+     * Generic getter for the url\n+     * @return the url value of this SherpaJournalDataProvider\n+     */\n+    public String getUrl() {\n+        return url;\n+    }\n+\n+    /**\n+     * Generic setter for the url\n+     * @param url   The url to be set on this SHERPAv2JournalDataProvider\n+     */\n+    public void setUrl(String url) {\n+        this.url = url;\n+    }\n+\n+    /**\n+     * Generic getter for the apiKey\n+     * @return the apiKey value of this SHERPAv2JournalDataProvider\n+     */\n+    public String getApiKey() {\n+        return apiKey;\n+    }\n+\n+    /**\n+     * Generic setter for the apiKey\n+     * @param apiKey   The apiKey to be set on this SHERPAv2JournalDataProvider\n+     */\n+    public void setApiKey(String apiKey) {\n+        this.apiKey = apiKey;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 357}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4ODM4MA==", "bodyText": "I would prefer to get this information directly from the configuration service. Having this internal cache will prevent us to add the apikey later and auto-reload it without restart. Moreover, it makes a bit harder to create an Integration Test", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r433788380", "createdAt": "2020-06-02T10:53:01Z", "author": {"login": "abollini"}, "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2PublisherDataProvider.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URISyntaxException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.sherpa.v2.SHERPAPublisher;\n+import org.dspace.app.sherpa.v2.SHERPAPublisherResponse;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+\n+/**\n+ * This class is the implementation of the ExternalDataProvider interface that will deal with SHERPAPublisher External\n+ * data lookups.\n+ * This provider is a refactored version of SherpaPublisherDataPublisher, rewritten to work with SHERPA v2 API\n+ *\n+ * It uses a more simple response object than the normal publication / policy search\n+ *\n+ * @author Kim Shepherd\n+ */\n+public class SHERPAv2PublisherDataProvider implements ExternalDataProvider {\n+\n+    private static final Logger log =\n+        org.apache.logging.log4j.LogManager.getLogger(SHERPAv2PublisherDataProvider.class);\n+\n+    private String sourceIdentifier;\n+    private String url;\n+    private String apiKey;\n+\n+    private CloseableHttpClient client = null;\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * Initialise the client that we need to call the endpoint\n+     * @throws IOException  If something goes wrong\n+     */\n+    public void init() throws IOException {\n+        HttpClientBuilder builder = HttpClientBuilder.create();\n+        // httpclient 4.3+ doesn't appear to have any sensible defaults any more. Setting conservative defaults as\n+        // not to hammer the SHERPA service too much.\n+        client = builder\n+            .disableAutomaticRetries()\n+            .setMaxConnTotal(5)\n+            .build();\n+    }\n+\n+    /**\n+     * Get a single publisher based on a \"id equals string\" query\n+     * @param id    The publisher ID which will be used as query string\n+     * @return external data object representing publisher\n+     */\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+\n+        HttpGet method = null;\n+        SHERPAPublisherResponse sherpaResponse = null;\n+        int timeout = 5000;\n+        URIBuilder uriBuilder = null;\n+        try {\n+            // Construct URI for an exact match on journal title\n+            uriBuilder = new URIBuilder(url);\n+            uriBuilder.addParameter(\"item-type\", \"publisher\");\n+            uriBuilder.addParameter(\"filter\", \"[[\\\"id\\\",\\\"equals\\\",\\\"\" + id + \"\\\"]]\");\n+            uriBuilder.addParameter(\"format\", \"Json\");\n+            if (StringUtils.isNotBlank(apiKey)) {\n+                uriBuilder.addParameter(\"api-key\", apiKey);\n+            }\n+\n+            // Build HTTP method\n+            method = new HttpGet(uriBuilder.build());\n+            method.setConfig(RequestConfig.custom()\n+                .setConnectionRequestTimeout(timeout)\n+                .setConnectTimeout(timeout)\n+                .setSocketTimeout(timeout)\n+                .build());\n+\n+            // Execute the method\n+            HttpResponse response = client.execute(method);\n+            int statusCode = response.getStatusLine().getStatusCode();\n+\n+            if (statusCode != HttpStatus.SC_OK) {\n+                sherpaResponse = new SHERPAPublisherResponse(\"SHERPA/RoMEO return not OK status: \"\n+                    + statusCode);\n+            }\n+\n+            HttpEntity responseBody = response.getEntity();\n+\n+            // Get InputStream from API response and parse JSON\n+            if (null != responseBody) {\n+                InputStream content = null;\n+                try {\n+                    content = responseBody.getContent();\n+                    sherpaResponse = new SHERPAPublisherResponse(content, SHERPAPublisherResponse.SHERPAFormat.JSON);\n+                } catch (IOException e) {\n+                    log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            } else {\n+                sherpaResponse = new SHERPAPublisherResponse(\"SHERPA/RoMEO returned no response\");\n+            }\n+        } catch (Exception e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+        }\n+\n+        if (sherpaResponse == null) {\n+            sherpaResponse = new SHERPAPublisherResponse(\"Error processing the SHERPA/RoMEO answer\");\n+        }\n+        if (CollectionUtils.isNotEmpty(sherpaResponse.getPublishers())) {\n+            SHERPAPublisher sherpaPublisher = sherpaResponse.getPublishers().get(0);\n+            // Construct external data object from returned publisher\n+            ExternalDataObject externalDataObject = constructExternalDataObjectFromSherpaPublisher(sherpaPublisher);\n+            return Optional.of(externalDataObject);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Search SHERPA v2 API for publisher results based on a 'contains word' query for publisher name\n+     * @param query The query for the search\n+     * @param start The start of the search\n+     * @param limit The max amount of records to be returned by the search\n+     * @return a list of external data objects\n+     */\n+    @Override\n+    public List<ExternalDataObject> searchExternalDataObjects(String query, int start, int limit) {\n+        // query args to add to SHERPA/RoMEO request URL\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query, start, limit);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Get response input stream and parse JSON into new SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAPublisherResponse sherpaResponse =\n+                        new SHERPAPublisherResponse(content, SHERPAPublisherResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getPublishers())) {\n+                        List<ExternalDataObject> list = sherpaResponse.getPublishers().stream().map(\n+                            sherpaPublisher -> constructExternalDataObjectFromSherpaPublisher(sherpaPublisher)).collect(\n+                            Collectors.toList());\n+\n+                        // Unlike the previous API version we can request offset and limit, so no need to build a\n+                        // sublist from this list, we can just return the list.\n+                        return list;\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error parsing SHERPA response input stream: \" + e.getMessage());\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            }\n+        } catch (IOException | URISyntaxException e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+            return null;\n+        } finally {\n+            if (get != null) {\n+                get.releaseConnection();\n+            }\n+        }\n+        return Collections.emptyList();\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"publisher name contains word\" query using default start/limit parameters\n+     * @param query a word or phrase to search for in publisher name\n+     * @return HttpGet method which can then be executed by the client\n+     * @throws URISyntaxException if the URL build fails\n+     */\n+    private HttpGet constructHttpGet(String query) throws URISyntaxException {\n+        return constructHttpGet(query, -1, -1);\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"publisher name contains word\" query\n+     * @param query the search query\n+     * @param start row offset\n+     * @param limit number of results to return\n+     * @return HttpGet object to be executed by the client\n+     * @throws URISyntaxException\n+     */\n+    private HttpGet constructHttpGet(String query, int start, int limit) throws URISyntaxException {\n+        // Build URL based on search query\n+        URIBuilder uriBuilder = new URIBuilder(url);\n+        uriBuilder.addParameter(\"item-type\", \"publisher\");\n+        uriBuilder.addParameter(\"filter\", \"[[\\\"name\\\",\\\"contains word\\\",\\\"\" + query + \"\\\"]]\");\n+        uriBuilder.addParameter(\"format\", \"Json\");\n+        // Set optional start (offset) and limit parameters\n+        if (start >= 0) {\n+            uriBuilder.addParameter(\"offset\", String.valueOf(start));\n+        }\n+        if (limit > 0) {\n+            uriBuilder.addParameter(\"limit\", String.valueOf(limit));\n+        }\n+        if (StringUtils.isNotBlank(apiKey)) {\n+            uriBuilder.addParameter(\"api-key\", apiKey);\n+        }\n+\n+        // Create HTTP GET object\n+        HttpGet method = new HttpGet(uriBuilder.build());\n+\n+        // Set connection parameters\n+        int timeout = 5000;\n+        method.setConfig(RequestConfig.custom()\n+            .setConnectionRequestTimeout(timeout)\n+            .setConnectTimeout(timeout)\n+            .setSocketTimeout(timeout)\n+            .build());\n+        return new HttpGet(uriBuilder.build());\n+    }\n+\n+    private ExternalDataObject constructExternalDataObjectFromSherpaPublisher(SHERPAPublisher sherpaPublisher) {\n+        ExternalDataObject externalDataObject = new ExternalDataObject();\n+        externalDataObject.setSource(sourceIdentifier);\n+\n+        // Set publisher name\n+        if (StringUtils.isNotBlank(sherpaPublisher.getName())) {\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"title\", null, null, sherpaPublisher.getName()));\n+            externalDataObject.setDisplayValue(sherpaPublisher.getName());\n+            externalDataObject.setValue(sherpaPublisher.getName());\n+        }\n+        // Set publisher ID\n+        if (StringUtils.isNotBlank(sherpaPublisher.getIdentifier())) {\n+            externalDataObject.setId(sherpaPublisher.getIdentifier());\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"identifier\", \"sherpaPublisher\", null,\n+                sherpaPublisher.getIdentifier()));\n+        }\n+\n+        // Set home URL\n+        if (StringUtils.isNotBlank(sherpaPublisher.getUri())) {\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"identifier\", \"other\", null, sherpaPublisher.getUri()));\n+        }\n+\n+        return externalDataObject;\n+    }\n+\n+    @Override\n+    public boolean supports(String source) {\n+        return StringUtils.equalsIgnoreCase(sourceIdentifier, source);\n+    }\n+\n+    /**\n+     * Get number of results returned from a SHERPA v2 publication search\n+     * @param query The query to be search on and give the total amount of results\n+     * @return int representing number of publisher results\n+     */\n+    @Override\n+    public int getNumberOfResults(String query) {\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Read response and parse as SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAPublisherResponse sherpaResponse =\n+                        new SHERPAPublisherResponse(content, SHERPAPublisherResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getPublishers())) {\n+                        return sherpaResponse.getPublishers().size();\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error reading input stream for SHERPAResponse: \" + e.getMessage());\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            }\n+        } catch (IOException | URISyntaxException e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+            return 0;\n+        } finally {\n+            if (get != null) {\n+                get.releaseConnection();\n+            }\n+        }\n+        // If other checks have failed return 0\n+        return 0;\n+    }\n+\n+    /**\n+     * Generic setter for the sourceIdentifier\n+     * @param sourceIdentifier   The sourceIdentifier to be set on this SHERPAv2PublisherDataProvider\n+     */\n+    public void setSourceIdentifier(String sourceIdentifier) {\n+        this.sourceIdentifier = sourceIdentifier;\n+    }\n+\n+    /**\n+     * Generic getter for the url\n+     * @return the url value of this SHERPAv2PublisherDataProvider\n+     */\n+    public String getUrl() {\n+        return url;\n+    }\n+\n+    /**\n+     * Generic setter for the url\n+     * @param url   The url to be set on this SHERPAv2PublisherDataProvider\n+     */\n+    public void setUrl(String url) {\n+        this.url = url;\n+    }\n+\n+    /**\n+     * Generic getter for the apiKey\n+     * @return the apiKey value of this SHERPAv2PublisherDataProvider\n+     */\n+    public String getApiKey() {\n+        return apiKey;\n+    }\n+\n+    /**\n+     * Generic setter for the apiKey\n+     * @param apiKey   The apiKey to be set on this SHERPAv2PublisherDataProvider\n+     */\n+    public void setApiKey(String apiKey) {\n+        this.apiKey = apiKey;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 360}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3MDg1NTcw", "url": "https://github.com/DSpace/DSpace/pull/2773#pullrequestreview-427085570", "createdAt": "2020-06-09T12:23:25Z", "commit": null, "state": "DISMISSED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMjoyMzoyNVrOGhGxPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMjoyODoxMlrOGhHCQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM2NzEwMg==", "bodyText": "Did the lookup \"fail\", it could be that there are no responses ?", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r437367102", "createdAt": "2020-06-09T12:23:25Z", "author": {"login": "KevinVdV"}, "path": "dspace-api/src/main/java/org/dspace/app/sherpa/submit/SHERPASubmitService.java", "diffHunk": "@@ -37,12 +38,28 @@ public void setSherpaService(SHERPAService sherpaService) {\n         this.sherpaService = sherpaService;\n     }\n \n-    public SHERPAResponse searchRelatedJournals(Context context, Item item) {\n+    public List<SHERPAResponse> searchRelatedJournals(Context context, Item item) {\n         Set<String> issns = getISSNs(context, item);\n         if (issns == null || issns.size() == 0) {\n             return null;\n         } else {\n-            return sherpaService.searchByJournalISSN(StringUtils.join(issns, \",\"));\n+            // SHERPA v2 API no longer supports \"OR'd\" ISSN search, perform individual searches instead\n+            Iterator<String> issnIterator = issns.iterator();\n+            List<SHERPAResponse> responses = new LinkedList<>();\n+            while (issnIterator.hasNext()) {\n+                String issn = issnIterator.next();\n+                SHERPAResponse response = sherpaService.searchByJournalISSN(issn);\n+                if (response.isError()) {\n+                    // Continue with loop\n+                    log.warn(\"Failed to look up SHERPA ROMeO result for ISSN: \" + issn);\n+                }\n+                // Store this response, even if it has an error (useful for UI reporting)\n+                responses.add(response);\n+            }\n+            if (responses.isEmpty()) {\n+                responses.add(new SHERPAResponse(\"SHERPA ROMeO lookup failed\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM2NzM3OQ==", "bodyText": "Would it be possible to log the response body as well ? (Not sure if this possible)", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r437367379", "createdAt": "2020-06-09T12:23:43Z", "author": {"login": "KevinVdV"}, "path": "dspace-api/src/main/java/org/dspace/app/sherpa/submit/SHERPASubmitService.java", "diffHunk": "@@ -37,12 +38,28 @@ public void setSherpaService(SHERPAService sherpaService) {\n         this.sherpaService = sherpaService;\n     }\n \n-    public SHERPAResponse searchRelatedJournals(Context context, Item item) {\n+    public List<SHERPAResponse> searchRelatedJournals(Context context, Item item) {\n         Set<String> issns = getISSNs(context, item);\n         if (issns == null || issns.size() == 0) {\n             return null;\n         } else {\n-            return sherpaService.searchByJournalISSN(StringUtils.join(issns, \",\"));\n+            // SHERPA v2 API no longer supports \"OR'd\" ISSN search, perform individual searches instead\n+            Iterator<String> issnIterator = issns.iterator();\n+            List<SHERPAResponse> responses = new LinkedList<>();\n+            while (issnIterator.hasNext()) {\n+                String issn = issnIterator.next();\n+                SHERPAResponse response = sherpaService.searchByJournalISSN(issn);\n+                if (response.isError()) {\n+                    // Continue with loop\n+                    log.warn(\"Failed to look up SHERPA ROMeO result for ISSN: \" + issn);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM3MDcxOQ==", "bodyText": "Can we use \"HttpStatus.SC_OK\" instead of 200 ?", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r437370719", "createdAt": "2020-06-09T12:27:24Z", "author": {"login": "KevinVdV"}, "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2PublisherDataProvider.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URISyntaxException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.sherpa.v2.SHERPAPublisher;\n+import org.dspace.app.sherpa.v2.SHERPAPublisherResponse;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+\n+/**\n+ * This class is the implementation of the ExternalDataProvider interface that will deal with SHERPAPublisher External\n+ * data lookups.\n+ * This provider is a refactored version of SherpaPublisherDataPublisher, rewritten to work with SHERPA v2 API\n+ *\n+ * It uses a more simple response object than the normal publication / policy search\n+ *\n+ * @author Kim Shepherd\n+ */\n+public class SHERPAv2PublisherDataProvider implements ExternalDataProvider {\n+\n+    private static final Logger log =\n+        org.apache.logging.log4j.LogManager.getLogger(SHERPAv2PublisherDataProvider.class);\n+\n+    private String sourceIdentifier;\n+    private String url;\n+    private String apiKey;\n+\n+    private CloseableHttpClient client = null;\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * Initialise the client that we need to call the endpoint\n+     * @throws IOException  If something goes wrong\n+     */\n+    public void init() throws IOException {\n+        HttpClientBuilder builder = HttpClientBuilder.create();\n+        // httpclient 4.3+ doesn't appear to have any sensible defaults any more. Setting conservative defaults as\n+        // not to hammer the SHERPA service too much.\n+        client = builder\n+            .disableAutomaticRetries()\n+            .setMaxConnTotal(5)\n+            .build();\n+    }\n+\n+    /**\n+     * Get a single publisher based on a \"id equals string\" query\n+     * @param id    The publisher ID which will be used as query string\n+     * @return external data object representing publisher\n+     */\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+\n+        HttpGet method = null;\n+        SHERPAPublisherResponse sherpaResponse = null;\n+        int timeout = 5000;\n+        URIBuilder uriBuilder = null;\n+        try {\n+            // Construct URI for an exact match on journal title\n+            uriBuilder = new URIBuilder(url);\n+            uriBuilder.addParameter(\"item-type\", \"publisher\");\n+            uriBuilder.addParameter(\"filter\", \"[[\\\"id\\\",\\\"equals\\\",\\\"\" + id + \"\\\"]]\");\n+            uriBuilder.addParameter(\"format\", \"Json\");\n+            if (StringUtils.isNotBlank(apiKey)) {\n+                uriBuilder.addParameter(\"api-key\", apiKey);\n+            }\n+\n+            // Build HTTP method\n+            method = new HttpGet(uriBuilder.build());\n+            method.setConfig(RequestConfig.custom()\n+                .setConnectionRequestTimeout(timeout)\n+                .setConnectTimeout(timeout)\n+                .setSocketTimeout(timeout)\n+                .build());\n+\n+            // Execute the method\n+            HttpResponse response = client.execute(method);\n+            int statusCode = response.getStatusLine().getStatusCode();\n+\n+            if (statusCode != HttpStatus.SC_OK) {\n+                sherpaResponse = new SHERPAPublisherResponse(\"SHERPA/RoMEO return not OK status: \"\n+                    + statusCode);\n+            }\n+\n+            HttpEntity responseBody = response.getEntity();\n+\n+            // Get InputStream from API response and parse JSON\n+            if (null != responseBody) {\n+                InputStream content = null;\n+                try {\n+                    content = responseBody.getContent();\n+                    sherpaResponse = new SHERPAPublisherResponse(content, SHERPAPublisherResponse.SHERPAFormat.JSON);\n+                } catch (IOException e) {\n+                    log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            } else {\n+                sherpaResponse = new SHERPAPublisherResponse(\"SHERPA/RoMEO returned no response\");\n+            }\n+        } catch (Exception e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+        }\n+\n+        if (sherpaResponse == null) {\n+            sherpaResponse = new SHERPAPublisherResponse(\"Error processing the SHERPA/RoMEO answer\");\n+        }\n+        if (CollectionUtils.isNotEmpty(sherpaResponse.getPublishers())) {\n+            SHERPAPublisher sherpaPublisher = sherpaResponse.getPublishers().get(0);\n+            // Construct external data object from returned publisher\n+            ExternalDataObject externalDataObject = constructExternalDataObjectFromSherpaPublisher(sherpaPublisher);\n+            return Optional.of(externalDataObject);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Search SHERPA v2 API for publisher results based on a 'contains word' query for publisher name\n+     * @param query The query for the search\n+     * @param start The start of the search\n+     * @param limit The max amount of records to be returned by the search\n+     * @return a list of external data objects\n+     */\n+    @Override\n+    public List<ExternalDataObject> searchExternalDataObjects(String query, int start, int limit) {\n+        // query args to add to SHERPA/RoMEO request URL\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query, start, limit);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Get response input stream and parse JSON into new SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAPublisherResponse sherpaResponse =\n+                        new SHERPAPublisherResponse(content, SHERPAPublisherResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getPublishers())) {\n+                        List<ExternalDataObject> list = sherpaResponse.getPublishers().stream().map(\n+                            sherpaPublisher -> constructExternalDataObjectFromSherpaPublisher(sherpaPublisher)).collect(\n+                            Collectors.toList());\n+\n+                        // Unlike the previous API version we can request offset and limit, so no need to build a\n+                        // sublist from this list, we can just return the list.\n+                        return list;\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error parsing SHERPA response input stream: \" + e.getMessage());\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            }\n+        } catch (IOException | URISyntaxException e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+            return null;\n+        } finally {\n+            if (get != null) {\n+                get.releaseConnection();\n+            }\n+        }\n+        return Collections.emptyList();\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"publisher name contains word\" query using default start/limit parameters\n+     * @param query a word or phrase to search for in publisher name\n+     * @return HttpGet method which can then be executed by the client\n+     * @throws URISyntaxException if the URL build fails\n+     */\n+    private HttpGet constructHttpGet(String query) throws URISyntaxException {\n+        return constructHttpGet(query, -1, -1);\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"publisher name contains word\" query\n+     * @param query the search query\n+     * @param start row offset\n+     * @param limit number of results to return\n+     * @return HttpGet object to be executed by the client\n+     * @throws URISyntaxException\n+     */\n+    private HttpGet constructHttpGet(String query, int start, int limit) throws URISyntaxException {\n+        // Build URL based on search query\n+        URIBuilder uriBuilder = new URIBuilder(url);\n+        uriBuilder.addParameter(\"item-type\", \"publisher\");\n+        uriBuilder.addParameter(\"filter\", \"[[\\\"name\\\",\\\"contains word\\\",\\\"\" + query + \"\\\"]]\");\n+        uriBuilder.addParameter(\"format\", \"Json\");\n+        // Set optional start (offset) and limit parameters\n+        if (start >= 0) {\n+            uriBuilder.addParameter(\"offset\", String.valueOf(start));\n+        }\n+        if (limit > 0) {\n+            uriBuilder.addParameter(\"limit\", String.valueOf(limit));\n+        }\n+        if (StringUtils.isNotBlank(apiKey)) {\n+            uriBuilder.addParameter(\"api-key\", apiKey);\n+        }\n+\n+        // Create HTTP GET object\n+        HttpGet method = new HttpGet(uriBuilder.build());\n+\n+        // Set connection parameters\n+        int timeout = 5000;\n+        method.setConfig(RequestConfig.custom()\n+            .setConnectionRequestTimeout(timeout)\n+            .setConnectTimeout(timeout)\n+            .setSocketTimeout(timeout)\n+            .build());\n+        return new HttpGet(uriBuilder.build());\n+    }\n+\n+    private ExternalDataObject constructExternalDataObjectFromSherpaPublisher(SHERPAPublisher sherpaPublisher) {\n+        ExternalDataObject externalDataObject = new ExternalDataObject();\n+        externalDataObject.setSource(sourceIdentifier);\n+\n+        // Set publisher name\n+        if (StringUtils.isNotBlank(sherpaPublisher.getName())) {\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"title\", null, null, sherpaPublisher.getName()));\n+            externalDataObject.setDisplayValue(sherpaPublisher.getName());\n+            externalDataObject.setValue(sherpaPublisher.getName());\n+        }\n+        // Set publisher ID\n+        if (StringUtils.isNotBlank(sherpaPublisher.getIdentifier())) {\n+            externalDataObject.setId(sherpaPublisher.getIdentifier());\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"identifier\", \"sherpaPublisher\", null,\n+                sherpaPublisher.getIdentifier()));\n+        }\n+\n+        // Set home URL\n+        if (StringUtils.isNotBlank(sherpaPublisher.getUri())) {\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"identifier\", \"other\", null, sherpaPublisher.getUri()));\n+        }\n+\n+        return externalDataObject;\n+    }\n+\n+    @Override\n+    public boolean supports(String source) {\n+        return StringUtils.equalsIgnoreCase(sourceIdentifier, source);\n+    }\n+\n+    /**\n+     * Get number of results returned from a SHERPA v2 publication search\n+     * @param query The query to be search on and give the total amount of results\n+     * @return int representing number of publisher results\n+     */\n+    @Override\n+    public int getNumberOfResults(String query) {\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 292}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM3MTI0Nw==", "bodyText": "Can we use \"HttpStatus.SC_OK\" instead of 200 ?", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r437371247", "createdAt": "2020-06-09T12:27:59Z", "author": {"login": "KevinVdV"}, "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2JournalDataProvider.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URISyntaxException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.sherpa.v2.SHERPAJournal;\n+import org.dspace.app.sherpa.v2.SHERPAResponse;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+\n+/**\n+ * This class is the implementation of the ExternalDataProvider interface that will deal with SherpaJournal External\n+ * data lookups.\n+ * This provider is a refactored version of SherpaJournalDataPublisher, rewritten to work with SHERPA v2 API\n+ *\n+ * @author Kim Shepherd\n+ */\n+public class SHERPAv2JournalDataProvider implements ExternalDataProvider {\n+\n+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(SHERPAv2JournalDataProvider.class);\n+\n+    private String url;\n+    private String sourceIdentifier;\n+    private String apiKey;\n+\n+    private CloseableHttpClient client = null;\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * Initialise the client that we need to call the endpoint\n+     * @throws IOException  If something goes wrong\n+     */\n+    public void init() throws IOException {\n+        HttpClientBuilder builder = HttpClientBuilder.create();\n+        // httpclient 4.3+ doesn't appear to have any sensible defaults any more. Setting conservative defaults as\n+        // not to hammer the SHERPA service too much.\n+        client = builder\n+            .disableAutomaticRetries()\n+            .setMaxConnTotal(5)\n+            .build();\n+    }\n+\n+    /**\n+     * Get a single journal based on a \"title equals string\" query\n+     * @param id    The journal title which will be used as query string\n+     * @return external data object representing journal\n+     */\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+\n+        HttpGet method = null;\n+        SHERPAResponse sherpaResponse = null;\n+        int timeout = 5000;\n+        URIBuilder uriBuilder = null;\n+        try {\n+            // Construct URI for an exact match on journal title\n+            uriBuilder = new URIBuilder(url);\n+            uriBuilder.addParameter(\"item-type\", \"publication\");\n+            uriBuilder.addParameter(\"filter\", \"[[\\\"title\\\",\\\"equals\\\",\\\"\" + id + \"\\\"]]\");\n+            uriBuilder.addParameter(\"format\", \"Json\");\n+            if (StringUtils.isNotBlank(apiKey)) {\n+                uriBuilder.addParameter(\"api-key\", apiKey);\n+            }\n+\n+            // Build HTTP method\n+            method = new HttpGet(uriBuilder.build());\n+            method.setConfig(RequestConfig.custom()\n+                                          .setConnectionRequestTimeout(timeout)\n+                                          .setConnectTimeout(timeout)\n+                                          .setSocketTimeout(timeout)\n+                                          .build());\n+\n+            // Execute the method\n+            HttpResponse response = client.execute(method);\n+            int statusCode = response.getStatusLine().getStatusCode();\n+\n+            if (statusCode != HttpStatus.SC_OK) {\n+                sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO return not OK status: \"\n+                                                        + statusCode);\n+            }\n+\n+            HttpEntity responseBody = response.getEntity();\n+\n+            // Get InputStream from API response and parse JSON\n+            if (null != responseBody) {\n+                InputStream content = null;\n+                try {\n+                    content = responseBody.getContent();\n+                    sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                } catch (IOException e) {\n+                    log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            } else {\n+                sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO returned no response\");\n+            }\n+        } catch (Exception e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+        }\n+\n+        if (sherpaResponse == null) {\n+            sherpaResponse = new SHERPAResponse(\n+                \"Error processing the SHERPA/RoMEO answer\");\n+        }\n+        if (CollectionUtils.isNotEmpty(sherpaResponse.getJournals())) {\n+            SHERPAJournal sherpaJournal = sherpaResponse.getJournals().get(0);\n+\n+            ExternalDataObject externalDataObject = constructExternalDataObjectFromSherpaJournal(sherpaJournal);\n+            return Optional.of(externalDataObject);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Construct ExternalDataObject populated with journal metadata from the SHERPA v2 API response\n+     * @param sherpaJournal\n+     * @return external data object representing a journal\n+     */\n+    private ExternalDataObject constructExternalDataObjectFromSherpaJournal(SHERPAJournal sherpaJournal) {\n+        // Set up external object\n+        ExternalDataObject externalDataObject = new ExternalDataObject();\n+        externalDataObject.setSource(sourceIdentifier);\n+        // Set journal title in external object\n+        if (CollectionUtils.isNotEmpty(sherpaJournal.getTitles())) {\n+            String journalTitle = sherpaJournal.getTitles().get(0);\n+            externalDataObject.setId(sherpaJournal.getTitles().get(0));\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"title\", null, null, journalTitle));\n+            externalDataObject.setValue(journalTitle);\n+            externalDataObject.setDisplayValue(journalTitle);\n+        }\n+        // Set ISSNs in external object\n+        if (CollectionUtils.isNotEmpty(sherpaJournal.getIssns())) {\n+            String issn = sherpaJournal.getIssns().get(0);\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                    \"dc\", \"identifier\", \"issn\", null, issn));\n+\n+        }\n+\n+        return externalDataObject;\n+    }\n+\n+    /**\n+     * Search SHERPA v2 API for journal results based on a 'contains word' query\n+     * @param query The query for the search\n+     * @param start The start of the search\n+     * @param limit The max amount of records to be returned by the search\n+     * @return a list of external data objects\n+     */\n+    @Override\n+    public List<ExternalDataObject> searchExternalDataObjects(String query, int start, int limit) {\n+        // query args to add to SHERPA/RoMEO request URL\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query, start, limit);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM3MTM1Ng==", "bodyText": "Can we use \"HttpStatus.SC_OK\" instead of 200 ?", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r437371356", "createdAt": "2020-06-09T12:28:06Z", "author": {"login": "KevinVdV"}, "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2JournalDataProvider.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URISyntaxException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.sherpa.v2.SHERPAJournal;\n+import org.dspace.app.sherpa.v2.SHERPAResponse;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+\n+/**\n+ * This class is the implementation of the ExternalDataProvider interface that will deal with SherpaJournal External\n+ * data lookups.\n+ * This provider is a refactored version of SherpaJournalDataPublisher, rewritten to work with SHERPA v2 API\n+ *\n+ * @author Kim Shepherd\n+ */\n+public class SHERPAv2JournalDataProvider implements ExternalDataProvider {\n+\n+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(SHERPAv2JournalDataProvider.class);\n+\n+    private String url;\n+    private String sourceIdentifier;\n+    private String apiKey;\n+\n+    private CloseableHttpClient client = null;\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * Initialise the client that we need to call the endpoint\n+     * @throws IOException  If something goes wrong\n+     */\n+    public void init() throws IOException {\n+        HttpClientBuilder builder = HttpClientBuilder.create();\n+        // httpclient 4.3+ doesn't appear to have any sensible defaults any more. Setting conservative defaults as\n+        // not to hammer the SHERPA service too much.\n+        client = builder\n+            .disableAutomaticRetries()\n+            .setMaxConnTotal(5)\n+            .build();\n+    }\n+\n+    /**\n+     * Get a single journal based on a \"title equals string\" query\n+     * @param id    The journal title which will be used as query string\n+     * @return external data object representing journal\n+     */\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+\n+        HttpGet method = null;\n+        SHERPAResponse sherpaResponse = null;\n+        int timeout = 5000;\n+        URIBuilder uriBuilder = null;\n+        try {\n+            // Construct URI for an exact match on journal title\n+            uriBuilder = new URIBuilder(url);\n+            uriBuilder.addParameter(\"item-type\", \"publication\");\n+            uriBuilder.addParameter(\"filter\", \"[[\\\"title\\\",\\\"equals\\\",\\\"\" + id + \"\\\"]]\");\n+            uriBuilder.addParameter(\"format\", \"Json\");\n+            if (StringUtils.isNotBlank(apiKey)) {\n+                uriBuilder.addParameter(\"api-key\", apiKey);\n+            }\n+\n+            // Build HTTP method\n+            method = new HttpGet(uriBuilder.build());\n+            method.setConfig(RequestConfig.custom()\n+                                          .setConnectionRequestTimeout(timeout)\n+                                          .setConnectTimeout(timeout)\n+                                          .setSocketTimeout(timeout)\n+                                          .build());\n+\n+            // Execute the method\n+            HttpResponse response = client.execute(method);\n+            int statusCode = response.getStatusLine().getStatusCode();\n+\n+            if (statusCode != HttpStatus.SC_OK) {\n+                sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO return not OK status: \"\n+                                                        + statusCode);\n+            }\n+\n+            HttpEntity responseBody = response.getEntity();\n+\n+            // Get InputStream from API response and parse JSON\n+            if (null != responseBody) {\n+                InputStream content = null;\n+                try {\n+                    content = responseBody.getContent();\n+                    sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                } catch (IOException e) {\n+                    log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            } else {\n+                sherpaResponse = new SHERPAResponse(\"SHERPA/RoMEO returned no response\");\n+            }\n+        } catch (Exception e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+        }\n+\n+        if (sherpaResponse == null) {\n+            sherpaResponse = new SHERPAResponse(\n+                \"Error processing the SHERPA/RoMEO answer\");\n+        }\n+        if (CollectionUtils.isNotEmpty(sherpaResponse.getJournals())) {\n+            SHERPAJournal sherpaJournal = sherpaResponse.getJournals().get(0);\n+\n+            ExternalDataObject externalDataObject = constructExternalDataObjectFromSherpaJournal(sherpaJournal);\n+            return Optional.of(externalDataObject);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Construct ExternalDataObject populated with journal metadata from the SHERPA v2 API response\n+     * @param sherpaJournal\n+     * @return external data object representing a journal\n+     */\n+    private ExternalDataObject constructExternalDataObjectFromSherpaJournal(SHERPAJournal sherpaJournal) {\n+        // Set up external object\n+        ExternalDataObject externalDataObject = new ExternalDataObject();\n+        externalDataObject.setSource(sourceIdentifier);\n+        // Set journal title in external object\n+        if (CollectionUtils.isNotEmpty(sherpaJournal.getTitles())) {\n+            String journalTitle = sherpaJournal.getTitles().get(0);\n+            externalDataObject.setId(sherpaJournal.getTitles().get(0));\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                \"dc\", \"title\", null, null, journalTitle));\n+            externalDataObject.setValue(journalTitle);\n+            externalDataObject.setDisplayValue(journalTitle);\n+        }\n+        // Set ISSNs in external object\n+        if (CollectionUtils.isNotEmpty(sherpaJournal.getIssns())) {\n+            String issn = sherpaJournal.getIssns().get(0);\n+            externalDataObject.addMetadata(new MetadataValueDTO(\n+                    \"dc\", \"identifier\", \"issn\", null, issn));\n+\n+        }\n+\n+        return externalDataObject;\n+    }\n+\n+    /**\n+     * Search SHERPA v2 API for journal results based on a 'contains word' query\n+     * @param query The query for the search\n+     * @param start The start of the search\n+     * @param limit The max amount of records to be returned by the search\n+     * @return a list of external data objects\n+     */\n+    @Override\n+    public List<ExternalDataObject> searchExternalDataObjects(String query, int start, int limit) {\n+        // query args to add to SHERPA/RoMEO request URL\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query, start, limit);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {\n+                // Get response input stream and parse JSON into new SHERPAResponse object\n+                InputStream content = null;\n+                try {\n+                    content = response.getEntity().getContent();\n+                    SHERPAResponse sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                    if (CollectionUtils.isNotEmpty(sherpaResponse.getJournals())) {\n+                        List<ExternalDataObject> list = sherpaResponse.getJournals().stream().map(\n+                            sherpaJournal -> constructExternalDataObjectFromSherpaJournal(sherpaJournal)).collect(\n+                            Collectors.toList());\n+\n+                        // Unlike the previous API version we can request offset and limit, so no need to build a\n+                        // sublist from this list, we can just return the list.\n+                        return list;\n+                    }\n+                } catch (IOException e) {\n+                    log.error(\"Error parsing SHERPA response input stream: \" + e.getMessage());\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            }\n+        } catch (IOException | URISyntaxException e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+            return null;\n+        } finally {\n+            if (get != null) {\n+                get.releaseConnection();\n+            }\n+        }\n+        return Collections.emptyList();\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"title contains word\" query using default start/limit parameters\n+     * @param query a word or phrase to search for in journal title\n+     * @return HttpGet method which can then be executed by the client\n+     * @throws URISyntaxException if the URL build fails\n+     */\n+    private HttpGet constructHttpGet(String query) throws URISyntaxException {\n+        return constructHttpGet(query, -1, -1);\n+    }\n+\n+    /**\n+     * Construct HTTP GET object for a \"title contains word\" query\n+     * @param query the search query\n+     * @param start row offset\n+     * @param limit number of results to return\n+     * @return HttpGet object to be executed by the client\n+     * @throws URISyntaxException\n+     */\n+    private HttpGet constructHttpGet(String query, int start, int limit) throws URISyntaxException {\n+        // Build URL based on search query\n+        URIBuilder uriBuilder = new URIBuilder(url);\n+        uriBuilder.addParameter(\"item-type\", \"publication\");\n+        uriBuilder.addParameter(\"filter\", \"[[\\\"title\\\",\\\"contains word\\\",\\\"\" + query + \"\\\"]]\");\n+        uriBuilder.addParameter(\"format\", \"Json\");\n+        // Set optional start (offset) and limit parameters\n+        if (start >= 0) {\n+            uriBuilder.addParameter(\"offset\", String.valueOf(start));\n+        }\n+        if (limit > 0) {\n+            uriBuilder.addParameter(\"limit\", String.valueOf(limit));\n+        }\n+        if (StringUtils.isNotBlank(apiKey)) {\n+            uriBuilder.addParameter(\"api-key\", apiKey);\n+        }\n+\n+        // Create HTTP GET object\n+        HttpGet method = new HttpGet(uriBuilder.build());\n+\n+        // Set connection parameters\n+        int timeout = 5000;\n+        method.setConfig(RequestConfig.custom()\n+            .setConnectionRequestTimeout(timeout)\n+            .setConnectTimeout(timeout)\n+            .setSocketTimeout(timeout)\n+            .build());\n+        return new HttpGet(uriBuilder.build());\n+    }\n+\n+    @Override\n+    public boolean supports(String source) {\n+        return StringUtils.equalsIgnoreCase(sourceIdentifier, source);\n+    }\n+\n+    /**\n+     * Get number of results returned from a SHERPA v2 publication search\n+     * @param query The query to be search on and give the total amount of results\n+     * @return int representing number of journal results\n+     */\n+    @Override\n+    public int getNumberOfResults(String query) {\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 290}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM3MTQ1OA==", "bodyText": "Can we use \"HttpStatus.SC_OK\" instead of 200 ?", "url": "https://github.com/DSpace/DSpace/pull/2773#discussion_r437371458", "createdAt": "2020-06-09T12:28:12Z", "author": {"login": "KevinVdV"}, "path": "dspace-api/src/main/java/org/dspace/external/provider/impl/SHERPAv2PublisherDataProvider.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.external.provider.impl;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URISyntaxException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.sherpa.v2.SHERPAPublisher;\n+import org.dspace.app.sherpa.v2.SHERPAPublisherResponse;\n+import org.dspace.content.dto.MetadataValueDTO;\n+import org.dspace.external.model.ExternalDataObject;\n+import org.dspace.external.provider.ExternalDataProvider;\n+\n+/**\n+ * This class is the implementation of the ExternalDataProvider interface that will deal with SHERPAPublisher External\n+ * data lookups.\n+ * This provider is a refactored version of SherpaPublisherDataPublisher, rewritten to work with SHERPA v2 API\n+ *\n+ * It uses a more simple response object than the normal publication / policy search\n+ *\n+ * @author Kim Shepherd\n+ */\n+public class SHERPAv2PublisherDataProvider implements ExternalDataProvider {\n+\n+    private static final Logger log =\n+        org.apache.logging.log4j.LogManager.getLogger(SHERPAv2PublisherDataProvider.class);\n+\n+    private String sourceIdentifier;\n+    private String url;\n+    private String apiKey;\n+\n+    private CloseableHttpClient client = null;\n+\n+    @Override\n+    public String getSourceIdentifier() {\n+        return sourceIdentifier;\n+    }\n+\n+    /**\n+     * Initialise the client that we need to call the endpoint\n+     * @throws IOException  If something goes wrong\n+     */\n+    public void init() throws IOException {\n+        HttpClientBuilder builder = HttpClientBuilder.create();\n+        // httpclient 4.3+ doesn't appear to have any sensible defaults any more. Setting conservative defaults as\n+        // not to hammer the SHERPA service too much.\n+        client = builder\n+            .disableAutomaticRetries()\n+            .setMaxConnTotal(5)\n+            .build();\n+    }\n+\n+    /**\n+     * Get a single publisher based on a \"id equals string\" query\n+     * @param id    The publisher ID which will be used as query string\n+     * @return external data object representing publisher\n+     */\n+    @Override\n+    public Optional<ExternalDataObject> getExternalDataObject(String id) {\n+\n+        HttpGet method = null;\n+        SHERPAPublisherResponse sherpaResponse = null;\n+        int timeout = 5000;\n+        URIBuilder uriBuilder = null;\n+        try {\n+            // Construct URI for an exact match on journal title\n+            uriBuilder = new URIBuilder(url);\n+            uriBuilder.addParameter(\"item-type\", \"publisher\");\n+            uriBuilder.addParameter(\"filter\", \"[[\\\"id\\\",\\\"equals\\\",\\\"\" + id + \"\\\"]]\");\n+            uriBuilder.addParameter(\"format\", \"Json\");\n+            if (StringUtils.isNotBlank(apiKey)) {\n+                uriBuilder.addParameter(\"api-key\", apiKey);\n+            }\n+\n+            // Build HTTP method\n+            method = new HttpGet(uriBuilder.build());\n+            method.setConfig(RequestConfig.custom()\n+                .setConnectionRequestTimeout(timeout)\n+                .setConnectTimeout(timeout)\n+                .setSocketTimeout(timeout)\n+                .build());\n+\n+            // Execute the method\n+            HttpResponse response = client.execute(method);\n+            int statusCode = response.getStatusLine().getStatusCode();\n+\n+            if (statusCode != HttpStatus.SC_OK) {\n+                sherpaResponse = new SHERPAPublisherResponse(\"SHERPA/RoMEO return not OK status: \"\n+                    + statusCode);\n+            }\n+\n+            HttpEntity responseBody = response.getEntity();\n+\n+            // Get InputStream from API response and parse JSON\n+            if (null != responseBody) {\n+                InputStream content = null;\n+                try {\n+                    content = responseBody.getContent();\n+                    sherpaResponse = new SHERPAPublisherResponse(content, SHERPAPublisherResponse.SHERPAFormat.JSON);\n+                } catch (IOException e) {\n+                    log.error(\"Encountered exception while contacting SHERPA/RoMEO: \" + e.getMessage(), e);\n+                } finally {\n+                    if (content != null) {\n+                        content.close();\n+                    }\n+                }\n+            } else {\n+                sherpaResponse = new SHERPAPublisherResponse(\"SHERPA/RoMEO returned no response\");\n+            }\n+        } catch (Exception e) {\n+            log.error(\"SHERPA/RoMEO query failed: \", e);\n+        }\n+\n+        if (sherpaResponse == null) {\n+            sherpaResponse = new SHERPAPublisherResponse(\"Error processing the SHERPA/RoMEO answer\");\n+        }\n+        if (CollectionUtils.isNotEmpty(sherpaResponse.getPublishers())) {\n+            SHERPAPublisher sherpaPublisher = sherpaResponse.getPublishers().get(0);\n+            // Construct external data object from returned publisher\n+            ExternalDataObject externalDataObject = constructExternalDataObjectFromSherpaPublisher(sherpaPublisher);\n+            return Optional.of(externalDataObject);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Search SHERPA v2 API for publisher results based on a 'contains word' query for publisher name\n+     * @param query The query for the search\n+     * @param start The start of the search\n+     * @param limit The max amount of records to be returned by the search\n+     * @return a list of external data objects\n+     */\n+    @Override\n+    public List<ExternalDataObject> searchExternalDataObjects(String query, int start, int limit) {\n+        // query args to add to SHERPA/RoMEO request URL\n+        HttpGet get = null;\n+        try {\n+            get = constructHttpGet(query, start, limit);\n+            HttpClient hc = new DefaultHttpClient();\n+            HttpResponse response = hc.execute(get);\n+            if (response.getStatusLine().getStatusCode() == 200) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 164}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NzI0MDE4", "url": "https://github.com/DSpace/DSpace/pull/2773#pullrequestreview-476724018", "createdAt": "2020-08-27T13:32:56Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dd10104661ce9cf6887093674c684852c9ad167f", "author": {"user": {"login": "kshepherd", "name": "kshepherd"}}, "url": "https://github.com/DSpace/DSpace/commit/dd10104661ce9cf6887093674c684852c9ad167f", "committedDate": "2021-01-22T02:38:30Z", "message": "[DS-3940](master) Port base SHERPA v2 changes from 6.x version"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dcca10c91a5e6e65f13047f8fc769a878e82c4eb", "author": {"user": {"login": "kshepherd", "name": "kshepherd"}}, "url": "https://github.com/DSpace/DSpace/commit/dcca10c91a5e6e65f13047f8fc769a878e82c4eb", "committedDate": "2021-01-22T02:38:30Z", "message": "[DS-3940](master) Refactor external providers for journals, publishers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6abb1d96f7699dbff1d55834cafae4be69393cf7", "author": {"user": {"login": "kshepherd", "name": "kshepherd"}}, "url": "https://github.com/DSpace/DSpace/commit/6abb1d96f7699dbff1d55834cafae4be69393cf7", "committedDate": "2021-01-22T02:38:30Z", "message": "[DS-3940](master) Unit tests for SHERPAResponse, SHERPAPublisherResponse"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d14699b0daa0450c41d2f2618334cb44f1195c6d", "author": {"user": {"login": "kshepherd", "name": "kshepherd"}}, "url": "https://github.com/DSpace/DSpace/commit/d14699b0daa0450c41d2f2618334cb44f1195c6d", "committedDate": "2021-01-22T02:38:30Z", "message": "[DS-3940](master) Configuration changes for new API key, URL, external svcs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c2b2545f88c4e35ac08c5a4aa162eec274ef24ac", "author": {"user": {"login": "kshepherd", "name": "kshepherd"}}, "url": "https://github.com/DSpace/DSpace/commit/c2b2545f88c4e35ac08c5a4aa162eec274ef24ac", "committedDate": "2021-01-22T02:39:54Z", "message": "[DS-3940](master) Removal of legacy v1 SHERPA classes and data providers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b10f1971b825d1d9c8d232f043c05be17539931", "author": {"user": {"login": "kshepherd", "name": "kshepherd"}}, "url": "https://github.com/DSpace/DSpace/commit/0b10f1971b825d1d9c8d232f043c05be17539931", "committedDate": "2021-01-22T02:39:54Z", "message": "[DS-3940](master) Better handling of empty / null results in providers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54ec03d0a1595fec621416c0e637f6842750ff18", "author": {"user": {"login": "kshepherd", "name": "kshepherd"}}, "url": "https://github.com/DSpace/DSpace/commit/54ec03d0a1595fec621416c0e637f6842750ff18", "committedDate": "2021-01-22T02:39:54Z", "message": "[DS-3940](master) Ensure sherpa.romeo.apikey placeholder always exists\n\nSpring bean configuration (external-sources.xml) requires the placeholder,\neven if it is null, so this change reverts the commented out api key\nintroduced with other v2 refactor work"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7fffe96a6ab0207b573b2874acc00aa44fedfeee", "author": {"user": {"login": "kshepherd", "name": "kshepherd"}}, "url": "https://github.com/DSpace/DSpace/commit/7fffe96a6ab0207b573b2874acc00aa44fedfeee", "committedDate": "2021-01-22T02:39:54Z", "message": "[DS-3940](master) Add license headers to unit test classes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e2f38fb25764a7394ee4054db007e6d226d4cd90", "author": {"user": {"login": "kshepherd", "name": "kshepherd"}}, "url": "https://github.com/DSpace/DSpace/commit/e2f38fb25764a7394ee4054db007e6d226d4cd90", "committedDate": "2021-01-22T02:39:54Z", "message": "[DS-3940](master) Fixes for Checkstyle failures in unit tests\n(imports, whitespace after catch)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b40dff96aa9554f82ee11080562044a217fa29a", "author": {"user": {"login": "kshepherd", "name": "kshepherd"}}, "url": "https://github.com/DSpace/DSpace/commit/1b40dff96aa9554f82ee11080562044a217fa29a", "committedDate": "2021-01-22T02:39:54Z", "message": "[DS-3940](main) Replace '200' with HttpStatus.SC_OK in data providers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a8bdc5f09a43851eaf1b8c4f445530b90f456374", "author": {"user": {"login": "kshepherd", "name": "kshepherd"}}, "url": "https://github.com/DSpace/DSpace/commit/a8bdc5f09a43851eaf1b8c4f445530b90f456374", "committedDate": "2021-01-22T02:39:54Z", "message": "[DS-3940](main) Add basic javadoc for new SHERPA data classes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "43d7c20fd2474f5bea953911d595e25f01aca983", "author": {"user": {"login": "kshepherd", "name": "kshepherd"}}, "url": "https://github.com/DSpace/DSpace/commit/43d7c20fd2474f5bea953911d595e25f01aca983", "committedDate": "2021-01-22T02:39:54Z", "message": "[DS-3940](main) Shift spring config to DSpace config service for providers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b53d14eeaee3fd023b4019f10ec189d0873e7ebe", "author": {"user": {"login": "kshepherd", "name": "kshepherd"}}, "url": "https://github.com/DSpace/DSpace/commit/b53d14eeaee3fd023b4019f10ec189d0873e7ebe", "committedDate": "2021-01-22T02:39:54Z", "message": "[DS-3940](main) Sanitise query strings for SHERPA v2 API calls"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6bed0894594e162c5616f14660bafee8d32db701", "author": {"user": {"login": "kshepherd", "name": "kshepherd"}}, "url": "https://github.com/DSpace/DSpace/commit/6bed0894594e162c5616f14660bafee8d32db701", "committedDate": "2021-01-22T02:39:54Z", "message": "[DS-3940](main) Sanitise query string (bugfix for bad method name in Pub)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "50612a8334042044356ec5c72122a1dd2161fa9a", "author": {"user": {"login": "kshepherd", "name": "kshepherd"}}, "url": "https://github.com/DSpace/DSpace/commit/50612a8334042044356ec5c72122a1dd2161fa9a", "committedDate": "2021-01-22T02:39:54Z", "message": "[DS-3940](main) Rethrow IOExceptions that are caught within main try block"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "038500b77260fbe6580cabfdd45eae8d24aaf640", "author": {"user": {"login": "kshepherd", "name": "kshepherd"}}, "url": "https://github.com/DSpace/DSpace/commit/038500b77260fbe6580cabfdd45eae8d24aaf640", "committedDate": "2021-01-22T02:39:54Z", "message": "[DS-3940](main) Remove versionLabel from permittedVersion - just store key"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f25bd96dafcf73011afe51c324e3c605b7001fd", "author": {"user": {"login": "kshepherd", "name": "kshepherd"}}, "url": "https://github.com/DSpace/DSpace/commit/0f25bd96dafcf73011afe51c324e3c605b7001fd", "committedDate": "2021-01-22T02:39:54Z", "message": "[DS-3940](main) Log response body in HTTP errors, err msg in submit service"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b01dcf822d3fc32f6bc1a245fad3933086b245f", "author": {"user": {"login": "kshepherd", "name": "kshepherd"}}, "url": "https://github.com/DSpace/DSpace/commit/7b01dcf822d3fc32f6bc1a245fad3933086b245f", "committedDate": "2021-01-22T02:39:54Z", "message": "[DS-3940](main) Remove version label, getter, setter from PermittedVersion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fdabd643f0eb3620612aad6ba08758f3a1629275", "author": {"user": {"login": "kshepherd", "name": "kshepherd"}}, "url": "https://github.com/DSpace/DSpace/commit/fdabd643f0eb3620612aad6ba08758f3a1629275", "committedDate": "2021-01-22T02:44:05Z", "message": "[DS-3940] Additional javadoc, integration and unit tests, service refactor"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "fdabd643f0eb3620612aad6ba08758f3a1629275", "author": {"user": {"login": "kshepherd", "name": "kshepherd"}}, "url": "https://github.com/DSpace/DSpace/commit/fdabd643f0eb3620612aad6ba08758f3a1629275", "committedDate": "2021-01-22T02:44:05Z", "message": "[DS-3940] Additional javadoc, integration and unit tests, service refactor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8fc804a8362095c268d0045570103528ec0bdbbd", "author": {"user": {"login": "kshepherd", "name": "kshepherd"}}, "url": "https://github.com/DSpace/DSpace/commit/8fc804a8362095c268d0045570103528ec0bdbbd", "committedDate": "2021-01-22T03:10:16Z", "message": "[DS-3940] Remove unused import in SHERPAv2JournalDataProvider"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa16ef717934c2e524c4183f91ed4193d544ceb2", "author": {"user": {"login": "kshepherd", "name": "kshepherd"}}, "url": "https://github.com/DSpace/DSpace/commit/aa16ef717934c2e524c4183f91ed4193d544ceb2", "committedDate": "2021-01-22T03:57:09Z", "message": "[DS-3940] Update ExternalSourcesRestControllerIT to count for new external sources"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1d9b9c6c41116fbfd16a9ba0cab938dd54c2b5c3", "author": {"user": {"login": "kshepherd", "name": "kshepherd"}}, "url": "https://github.com/DSpace/DSpace/commit/1d9b9c6c41116fbfd16a9ba0cab938dd54c2b5c3", "committedDate": "2021-01-22T06:02:55Z", "message": "[DS-3940] Correct typo in ExternalSourcesRestControllerIT"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTg4NjQ4OTQy", "url": "https://github.com/DSpace/DSpace/pull/2773#pullrequestreview-588648942", "createdAt": "2021-02-11T14:59:35Z", "commit": {"oid": "1d9b9c6c41116fbfd16a9ba0cab938dd54c2b5c3"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkzNTczMDI3", "url": "https://github.com/DSpace/DSpace/pull/2773#pullrequestreview-593573027", "createdAt": "2021-02-18T19:29:46Z", "commit": {"oid": "1d9b9c6c41116fbfd16a9ba0cab938dd54c2b5c3"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1482, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}