{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY3MzUxNDA5", "number": 2928, "title": "[DS-4036] Delete EPersons even if they are referenced", "bodyText": "References\n\nReplaces REST PR\nFixes JIRA ticket\nFixes #2803\n\nDescription\nThis PR:\n\nIncludes #2229\nIt's updated with the latest master\nThe broken tests have been fixed\nTests for the workflow behavior have been created\n\nThis PR doesn't include tests for the submission yet. We'd first want to verify whether the approach taken here is approved.\nThis PR is focussed on denying creation of an inconsistent state of your repository/items. This implies:\n\nIf there's a workflow group with items assigned and only one member => removing that member from the group is not allowed. This is because the item would otherwise remain assigned to the workflow group but no-one can claim it\nIf there's a workflow group with items assigned and multiple members => removing a member from the group is no problem\nIf there's a workflow group without items and only one member => removing that member from the group is no problem (new items will skip this step)\nIf the user has claimed a task, the task will be returned to the pool when deleting the user. This should not pose any issues because the pool will contain other users which are not deleted\n\nInstructions for Reviewers\nThere's a large amount of scenarios in EPersonInWorkflowTest.java. Please read them to see how this has been approached.\nThe general principle is to avoid an inconsistent state. If deleting the user would bring the system to an inconsistent state, that will need to be solved first, and the delete is refused.\nChecklist\nThis checklist provides a reminder of what we are going to look for when reviewing your PR. You need not complete this checklist prior to creating your PR (draft PRs are always welcome). If you are unsure about an item in the checklist, don't hesitate to ask. We're here to help!\n\n My PR is small in size (e.g. less than 1,000 lines of code, not including comments & integration tests). Exceptions may be made if previously agreed upon.\n My PR passes Checkstyle validation based on the Code Style Guide.\n My PR includes Javadoc for all new (or modified) public methods and classes. It also includes Javadoc for large or complex private methods.\n My PR passes all tests and includes new/updated Unit or Integration Tests based on the Code Testing Guide.\n If my PR includes new, third-party dependencies (in any pom.xml), I've made sure their licenses align with the DSpace BSD License based on the Licensing of Contributions documentation.\n If my PR modifies the REST API, I've linked to the REST Contract page (or open PR) related to this change.", "createdAt": "2020-08-13T12:25:24Z", "url": "https://github.com/DSpace/DSpace/pull/2928", "merged": true, "mergeCommit": {"oid": "d645ec30e6efbc185ec6088308c69db5ce898e89"}, "closed": true, "closedAt": "2020-10-08T17:06:47Z", "author": {"login": "benbosman"}, "timelineItems": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABZ2Q3CmAH2gAyNDY3MzUxNDA5OjlhNDFlNmZlY2UwZWUyZDQyODA2MGNjNmRkNDJhMDBiZTQ0ZTJhMTc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdQhZw_AFqTUwMTY0NjU5Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "9a41e6fece0ee2d428060cc6dd42a00be44e2a17", "author": {"user": {"login": "marsaoua", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/9a41e6fece0ee2d428060cc6dd42a00be44e2a17", "committedDate": "2018-11-30T10:43:08Z", "message": "[DS-4036] Delete EPersons even if they are referenced\n\nDSpace references EPersons in different database tables like the\nsubmitter of an item or like the EPerson that gets special rights\ngranted in the resourcepolicy table. This PR changes DSpace so it can\nhandle references that are set null instead of referencing an actual\nEPerson. This is important to be able to delete EPersons which is\ndemanded by several data protection laws like GDPR in the European\nUnion."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3d37c3b5b9946e89de0ed8b2cca7bdd3f38d3ff", "author": {"user": {"login": "pnbecker", "name": "Pascal-Nicolas Becker"}}, "url": "https://github.com/DSpace/DSpace/commit/a3d37c3b5b9946e89de0ed8b2cca7bdd3f38d3ff", "committedDate": "2018-11-30T12:04:50Z", "message": "[DS-4036] Resolving changes requested enduring review."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3890c11bf7ab28dc465f3a24dc6296b466b67fa4", "author": {"user": {"login": "pnbecker", "name": "Pascal-Nicolas Becker"}}, "url": "https://github.com/DSpace/DSpace/commit/3890c11bf7ab28dc465f3a24dc6296b466b67fa4", "committedDate": "2018-11-30T12:05:03Z", "message": "[DS-4036] Resolving merge conflicts."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "435235abe48e8fba56ac0592de2b40d5d97522b8", "author": {"user": {"login": "YanaDePauw", "name": "Yana De Pauw"}}, "url": "https://github.com/DSpace/DSpace/commit/435235abe48e8fba56ac0592de2b40d5d97522b8", "committedDate": "2020-08-11T08:30:04Z", "message": "Merge remote-tracking branch 'upstream/main' into w2p-72472_Delete-eperson"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "705b2b544f5106785e211a2999b4a6a32280f551", "author": {"user": {"login": "YanaDePauw", "name": "Yana De Pauw"}}, "url": "https://github.com/DSpace/DSpace/commit/705b2b544f5106785e211a2999b4a6a32280f551", "committedDate": "2020-08-13T08:25:06Z", "message": "Delete eperson when in workflow"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxOTA3Mjkz", "url": "https://github.com/DSpace/DSpace/pull/2928#pullrequestreview-471907293", "createdAt": "2020-08-20T19:13:23Z", "commit": {"oid": "705b2b544f5106785e211a2999b4a6a32280f551"}, "state": "COMMENTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxOToxMzoyM1rOHEPkqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQyMDowODoyMVrOHERi9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxMTQ5Nw==", "bodyText": "Tiny thing...not sure I understand this rename of the i18n key.  It no longer matches the package/classname where it is used.  However, if you want it renamed, we could change it to something like itemRequest.helpdeskname as I see there are a number of other keys starting with itemRequest.*", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r474211497", "createdAt": "2020-08-20T19:13:23Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/app/requestitem/RequestItemHelpdeskStrategy.java", "diffHunk": "@@ -74,8 +74,7 @@ public RequestItemAuthor getHelpDeskPerson(Context context, String helpDeskEmail\n             return new RequestItemAuthor(helpdeskEPerson);\n         } else {\n             String helpdeskName = I18nUtil.getMessage(\n-                \"org.dspace.app.requestitem.RequestItemHelpdeskStrategy.helpdeskname\",\n-                context);\n+                \"org.dspace.app.requestitem.helpdeskname\", context);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "705b2b544f5106785e211a2999b4a6a32280f551"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxNDA1Ng==", "bodyText": "I don't believe we have an admin.name configuration.  That said, I'm OK with adding one, but I'd recommend we name it mail.admin.name, as it looks (to me) like it will correspond to the mail.admin property.\nSimilarly, just above this, we could add a mail.helpdesk.name instead of storing that value in i18n.  That said, we should treat these similarly. Either put them both in Configuration or both in i18n.", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r474214056", "createdAt": "2020-08-20T19:17:57Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/app/requestitem/RequestItemMetadataStrategy.java", "diffHunk": "@@ -49,19 +51,37 @@ public RequestItemAuthor getRequestItemAuthor(Context context, Item item)\n                         fullname = nameVals.iterator().next().getValue();\n                     }\n                 }\n-\n                 if (StringUtils.isBlank(fullname)) {\n                     fullname = I18nUtil\n-                        .getMessage(\n-                            \"org.dspace.app.requestitem.RequestItemMetadataStrategy.unnamed\",\n-                            context);\n+                            .getMessage(\n+                                    \"org.dspace.app.requestitem.RequestItemMetadataStrategy.unnamed\",\n+                                    context);\n                 }\n-                RequestItemAuthor author = new RequestItemAuthor(\n-                    fullname, email);\n+                author = new RequestItemAuthor(fullname, email);\n                 return author;\n             }\n+        } else {\n+            // Uses the basic strategy to look for the original submitter\n+            author = super.getRequestItemAuthor(context, item);\n+            // Is the author or his email  null, so get the help desk or admin name and email\n+            if (null == author || null == author.getEmail()) {\n+                String email = null;\n+                String name = null;\n+                //First get help desk name and email\n+                email = DSpaceServicesFactory.getInstance()\n+                        .getConfigurationService().getProperty(\"mail.helpdesk\");\n+                name = I18nUtil.getMessage(\"org.dspace.app.requestitem.helpdeskname\", context);\n+                // If help desk mail is null get the mail and name of admin\n+                if (email == null) {\n+                    email = DSpaceServicesFactory.getInstance()\n+                            .getConfigurationService().getProperty(\"mail.admin\");\n+                    name = DSpaceServicesFactory.getInstance()\n+                            .getConfigurationService().getProperty(\"admin.name\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "705b2b544f5106785e211a2999b4a6a32280f551"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxNDk5OA==", "bodyText": "probably should be renamed deleteByEPerson() to match the other deleteBy* methods in this same DAO.  We should also take this opportunity to add Javadocs here & to the new findByEPerson() method above.", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r474214998", "createdAt": "2020-08-20T19:19:49Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/authorize/dao/ResourcePolicyDAO.java", "diffHunk": "@@ -66,6 +68,8 @@\n \n     public void deleteByDsoEPersonPolicies(Context context, DSpaceObject dso, EPerson ePerson) throws SQLException;\n \n+    public void deleteAllEPersonPolicies(Context context, EPerson ePerson) throws SQLException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "705b2b544f5106785e211a2999b4a6a32280f551"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxNjI3NA==", "bodyText": "Typo here. Should be \"Deletion\"", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r474216274", "createdAt": "2020-08-20T19:22:09Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/eperson/EPersonCLITool.java", "diffHunk": "@@ -259,16 +262,27 @@ private static int cmdDelete(Context context, String[] argv) {\n         }\n \n         try {\n-            ePersonService.delete(context, eperson);\n-            context.complete();\n-            System.out.printf(\"Deleted EPerson %s\\n\", eperson.getID().toString());\n-        } catch (SQLException ex) {\n-            System.err.println(ex.getMessage());\n-            return 1;\n-        } catch (AuthorizeException ex) {\n-            System.err.println(ex.getMessage());\n-            return 1;\n-        } catch (IOException ex) {\n+            List<String> tableList = ePersonService.getDeleteConstraints(context, eperson);\n+            if (!tableList.isEmpty()) {\n+                System.out.printf(\"This EPerson with ID: %s is referring to this tables:%n \",\n+                        eperson.getID().toString());\n+                tableList.forEach((s) -> {\n+                    System.out.println(s);\n+                });\n+            }\n+            System.out.printf(\"Are you sure you want to delete this EPerson with ID: %s? (y or n): \",\n+                    eperson.getID().toString());\n+            BufferedReader input = new BufferedReader(new InputStreamReader(System.in));\n+            System.out.flush();\n+            String s = input.readLine();\n+            if (s != null && s.trim().toLowerCase().startsWith(\"y\")) {\n+                ePersonService.delete(context, eperson);\n+                context.complete();\n+                System.out.printf(\"%nDeleted EPerson with ID: %s\", eperson.getID().toString());\n+            } else {\n+                System.out.printf(\"%nAbort Deletetion of EPerson with ID: %s %n\", eperson.getID().toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "705b2b544f5106785e211a2999b4a6a32280f551"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxNzE5OQ==", "bodyText": "Should not call context.complete() here as the Context is being managed in the main method and is already calling complete() there.  We should never close/complete a Context that is passed into a method, as it can result in odd behaviors.", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r474217199", "createdAt": "2020-08-20T19:24:05Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/eperson/EPersonCLITool.java", "diffHunk": "@@ -259,16 +262,27 @@ private static int cmdDelete(Context context, String[] argv) {\n         }\n \n         try {\n-            ePersonService.delete(context, eperson);\n-            context.complete();\n-            System.out.printf(\"Deleted EPerson %s\\n\", eperson.getID().toString());\n-        } catch (SQLException ex) {\n-            System.err.println(ex.getMessage());\n-            return 1;\n-        } catch (AuthorizeException ex) {\n-            System.err.println(ex.getMessage());\n-            return 1;\n-        } catch (IOException ex) {\n+            List<String> tableList = ePersonService.getDeleteConstraints(context, eperson);\n+            if (!tableList.isEmpty()) {\n+                System.out.printf(\"This EPerson with ID: %s is referring to this tables:%n \",\n+                        eperson.getID().toString());\n+                tableList.forEach((s) -> {\n+                    System.out.println(s);\n+                });\n+            }\n+            System.out.printf(\"Are you sure you want to delete this EPerson with ID: %s? (y or n): \",\n+                    eperson.getID().toString());\n+            BufferedReader input = new BufferedReader(new InputStreamReader(System.in));\n+            System.out.flush();\n+            String s = input.readLine();\n+            if (s != null && s.trim().toLowerCase().startsWith(\"y\")) {\n+                ePersonService.delete(context, eperson);\n+                context.complete();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "705b2b544f5106785e211a2999b4a6a32280f551"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxODEwNQ==", "bodyText": "Reword to say something like \"The EPerson with ID: %s is referenced by the following database tables:%n\"   This aligns better with the EPersonDeletionException error message you wrote below.", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r474218105", "createdAt": "2020-08-20T19:25:49Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/eperson/EPersonCLITool.java", "diffHunk": "@@ -259,16 +262,27 @@ private static int cmdDelete(Context context, String[] argv) {\n         }\n \n         try {\n-            ePersonService.delete(context, eperson);\n-            context.complete();\n-            System.out.printf(\"Deleted EPerson %s\\n\", eperson.getID().toString());\n-        } catch (SQLException ex) {\n-            System.err.println(ex.getMessage());\n-            return 1;\n-        } catch (AuthorizeException ex) {\n-            System.err.println(ex.getMessage());\n-            return 1;\n-        } catch (IOException ex) {\n+            List<String> tableList = ePersonService.getDeleteConstraints(context, eperson);\n+            if (!tableList.isEmpty()) {\n+                System.out.printf(\"This EPerson with ID: %s is referring to this tables:%n \",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "705b2b544f5106785e211a2999b4a6a32280f551"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxOTM1NA==", "bodyText": "I think this should say simply throw ex;  I'm not sure why we'd need to wrap an AuthorizeException in another AuthorizeException.", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r474219354", "createdAt": "2020-08-20T19:28:19Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/eperson/EPersonServiceImpl.java", "diffHunk": "@@ -179,45 +222,202 @@ public EPerson create(Context context) throws SQLException, AuthorizeException {\n         // authorized?\n         if (!authorizeService.isAdmin(context)) {\n             throw new AuthorizeException(\n-                \"You must be an admin to create an EPerson\");\n+                    \"You must be an admin to create an EPerson\");\n         }\n \n         // Create a table row\n         EPerson e = ePersonDAO.create(context, new EPerson());\n \n         log.info(LogManager.getHeader(context, \"create_eperson\", \"eperson_id=\"\n-            + e.getID()));\n+                + e.getID()));\n \n         context.addEvent(new Event(Event.CREATE, Constants.EPERSON, e.getID(),\n-                                   null, getIdentifiers(context, e)));\n+                null, getIdentifiers(context, e)));\n \n         return e;\n     }\n \n     @Override\n     public void delete(Context context, EPerson ePerson) throws SQLException, AuthorizeException {\n+        try {\n+            delete(context, ePerson, true);\n+        } catch (AuthorizeException ex) {\n+            log.error(\"This AuthorizeException: \" + ex + \" occured while deleting Eperson with the ID: \" +\n+                      ePerson.getID());\n+            throw new AuthorizeException(ex.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "705b2b544f5106785e211a2999b4a6a32280f551"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxOTgxMA==", "bodyText": "This thrown error no longer has the details of the IOException.  We'd probably want a way to ensure those details are kept, as they may provide important info.", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r474219810", "createdAt": "2020-08-20T19:29:11Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/eperson/EPersonServiceImpl.java", "diffHunk": "@@ -179,45 +222,202 @@ public EPerson create(Context context) throws SQLException, AuthorizeException {\n         // authorized?\n         if (!authorizeService.isAdmin(context)) {\n             throw new AuthorizeException(\n-                \"You must be an admin to create an EPerson\");\n+                    \"You must be an admin to create an EPerson\");\n         }\n \n         // Create a table row\n         EPerson e = ePersonDAO.create(context, new EPerson());\n \n         log.info(LogManager.getHeader(context, \"create_eperson\", \"eperson_id=\"\n-            + e.getID()));\n+                + e.getID()));\n \n         context.addEvent(new Event(Event.CREATE, Constants.EPERSON, e.getID(),\n-                                   null, getIdentifiers(context, e)));\n+                null, getIdentifiers(context, e)));\n \n         return e;\n     }\n \n     @Override\n     public void delete(Context context, EPerson ePerson) throws SQLException, AuthorizeException {\n+        try {\n+            delete(context, ePerson, true);\n+        } catch (AuthorizeException ex) {\n+            log.error(\"This AuthorizeException: \" + ex + \" occured while deleting Eperson with the ID: \" +\n+                      ePerson.getID());\n+            throw new AuthorizeException(ex.getMessage());\n+        } catch (IOException ex) {\n+            log.error(\"This IOException: \" + ex + \" occured while deleting Eperson with the ID: \" + ePerson.getID());\n+            throw new AuthorizeException(new EPersonDeletionException());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "705b2b544f5106785e211a2999b4a6a32280f551"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIyMDM4OQ==", "bodyText": "I think this should be throw new IllegalStateException(e); so that it keeps the stacktrace info, etc.", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r474220389", "createdAt": "2020-08-20T19:30:16Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/eperson/EPersonServiceImpl.java", "diffHunk": "@@ -179,45 +222,202 @@ public EPerson create(Context context) throws SQLException, AuthorizeException {\n         // authorized?\n         if (!authorizeService.isAdmin(context)) {\n             throw new AuthorizeException(\n-                \"You must be an admin to create an EPerson\");\n+                    \"You must be an admin to create an EPerson\");\n         }\n \n         // Create a table row\n         EPerson e = ePersonDAO.create(context, new EPerson());\n \n         log.info(LogManager.getHeader(context, \"create_eperson\", \"eperson_id=\"\n-            + e.getID()));\n+                + e.getID()));\n \n         context.addEvent(new Event(Event.CREATE, Constants.EPERSON, e.getID(),\n-                                   null, getIdentifiers(context, e)));\n+                null, getIdentifiers(context, e)));\n \n         return e;\n     }\n \n     @Override\n     public void delete(Context context, EPerson ePerson) throws SQLException, AuthorizeException {\n+        try {\n+            delete(context, ePerson, true);\n+        } catch (AuthorizeException ex) {\n+            log.error(\"This AuthorizeException: \" + ex + \" occured while deleting Eperson with the ID: \" +\n+                      ePerson.getID());\n+            throw new AuthorizeException(ex.getMessage());\n+        } catch (IOException ex) {\n+            log.error(\"This IOException: \" + ex + \" occured while deleting Eperson with the ID: \" + ePerson.getID());\n+            throw new AuthorizeException(new EPersonDeletionException());\n+        } catch (EPersonDeletionException e) {\n+            throw new IllegalStateException(e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "705b2b544f5106785e211a2999b4a6a32280f551"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIyMzk1NQ==", "bodyText": "The word \"it's\" in this message looks like it has special backtick character instead of a normal apostrophe.   It's likely not a big deal, but I wanted to point it out as we might want to fix it just in case it'd case issues.", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r474223955", "createdAt": "2020-08-20T19:34:40Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/eperson/EPersonServiceImpl.java", "diffHunk": "@@ -179,45 +222,202 @@ public EPerson create(Context context) throws SQLException, AuthorizeException {\n         // authorized?\n         if (!authorizeService.isAdmin(context)) {\n             throw new AuthorizeException(\n-                \"You must be an admin to create an EPerson\");\n+                    \"You must be an admin to create an EPerson\");\n         }\n \n         // Create a table row\n         EPerson e = ePersonDAO.create(context, new EPerson());\n \n         log.info(LogManager.getHeader(context, \"create_eperson\", \"eperson_id=\"\n-            + e.getID()));\n+                + e.getID()));\n \n         context.addEvent(new Event(Event.CREATE, Constants.EPERSON, e.getID(),\n-                                   null, getIdentifiers(context, e)));\n+                null, getIdentifiers(context, e)));\n \n         return e;\n     }\n \n     @Override\n     public void delete(Context context, EPerson ePerson) throws SQLException, AuthorizeException {\n+        try {\n+            delete(context, ePerson, true);\n+        } catch (AuthorizeException ex) {\n+            log.error(\"This AuthorizeException: \" + ex + \" occured while deleting Eperson with the ID: \" +\n+                      ePerson.getID());\n+            throw new AuthorizeException(ex.getMessage());\n+        } catch (IOException ex) {\n+            log.error(\"This IOException: \" + ex + \" occured while deleting Eperson with the ID: \" + ePerson.getID());\n+            throw new AuthorizeException(new EPersonDeletionException());\n+        } catch (EPersonDeletionException e) {\n+            throw new IllegalStateException(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Deletes an EPerson. The argument cascade defines whether all references\n+     * on an EPerson should be deleted as well (by either deleting the\n+     * referencing object - e.g. WorkspaceItem, ResourcePolicy - or by setting\n+     * the foreign key null - e.g. archived Items). If cascade is set to false\n+     * and the EPerson is referenced somewhere, this leads to an\n+     * AuthorizeException. EPersons may be referenced by Items, ResourcePolicies\n+     * and workflow tasks.\n+     *\n+     * @param context DSpace context\n+     * @param ePerson The EPerson to delete.\n+     * @param cascade Whether to delete references on the EPerson (cascade =\n+     * true) or to abort the deletion (cascade = false) if the EPerson is\n+     * referenced within DSpace.\n+     *\n+     * @throws SQLException\n+     * @throws AuthorizeException\n+     * @throws IOException\n+     */\n+    public void delete(Context context, EPerson ePerson, boolean cascade)\n+            throws SQLException, AuthorizeException, IOException, EPersonDeletionException {\n         // authorized?\n         if (!authorizeService.isAdmin(context)) {\n             throw new AuthorizeException(\n-                \"You must be an admin to delete an EPerson\");\n+                    \"You must be an admin to delete an EPerson\");\n+        }\n+        Set<Group> workFlowGroups = getAllWorkFlowGroups(context, ePerson);\n+        for (Group group: workFlowGroups) {\n+            List<EPerson> ePeople = groupService.allMembers(context, group);\n+            if (ePeople.size() == 1 && ePeople.contains(ePerson)) {\n+                throw new IllegalStateException(\n+                        \"Refused to delete user \" + ePerson.getID() + \" because it\u2019s part of the group \" + group", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "705b2b544f5106785e211a2999b4a6a32280f551"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIyODUwNg==", "bodyText": "I don't understand the logic of this code (maybe it needs inline comments here).  Why would we refuse to remove the last member of a group?  Are empty Groups not allowed here?  I have the same questions about the other removeMember() method in this same class.", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r474228506", "createdAt": "2020-08-20T19:39:46Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/eperson/GroupServiceImpl.java", "diffHunk": "@@ -144,7 +152,20 @@ public void addMember(Context context, Group groupParent, Group groupChild) thro\n     }\n \n     @Override\n-    public void removeMember(Context context, Group group, EPerson ePerson) {\n+    public void removeMember(Context context, Group group, EPerson ePerson) throws SQLException {\n+        List<CollectionRole> collectionRoles = collectionRoleService.findByGroup(context, group);\n+        if (!collectionRoles.isEmpty()) {\n+            List<PoolTask> poolTasks = poolTaskService.findByGroup(context, group);\n+            if (!poolTasks.isEmpty()) {\n+                List<EPerson> ePeople = allMembers(context, group);\n+                if (ePeople.size() == 1 && ePeople.contains(ePerson)) {\n+                    throw new IllegalStateException(\n+                            \"Refused to remove user \" + ePerson\n+                                    .getID() + \" from workflow group because the group \" + group\n+                                    .getID() + \" has no other members\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "705b2b544f5106785e211a2999b4a6a32280f551"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIzNDc3Ng==", "bodyText": "I'm not entirely sure that we need to update the org.dspace.workflowbasic.* classes in this PR.  I thought these were all only used by the old, Traditional Workflow system.  Remember that old system no longer works with DSpace 7..only the Configurable Workflow works.  So, I think we can remove all these old classes, unless I'm missing something?  See https://jira.lyrasis.org/browse/DS-3041\nThat doesn't need to be part of this PR...but, if you agree, I can create a separate task/ticket to remove these old classes.", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r474234776", "createdAt": "2020-08-20T19:50:13Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/workflowbasic/BasicWorkflowServiceImpl.java", "diffHunk": "@@ -798,33 +798,37 @@ protected void notifyOfArchive(Context context, Item item, Collection coll)\n         try {\n             // Get submitter\n             EPerson ep = item.getSubmitter();\n-            // Get the Locale\n-            Locale supportedLocale = I18nUtil.getEPersonLocale(ep);\n-            Email email = Email.getEmail(I18nUtil.getEmailFilename(supportedLocale, \"submit_archive\"));\n \n-            // Get the item handle to email to user\n-            String handle = handleService.findHandle(context, item);\n-\n-            // Get title\n-            String title = item.getName();\n-            if (StringUtils.isBlank(title)) {\n-                try {\n-                    title = I18nUtil.getMessage(\"org.dspace.workflow.WorkflowManager.untitled\");\n-                } catch (MissingResourceException e) {\n-                    title = \"Untitled\";\n+            // send the notification to the submitter unless the submitter eperson has been deleted\n+            if (ep != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "705b2b544f5106785e211a2999b4a6a32280f551"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDI0MzgzMA==", "bodyText": "@benbosman : The scenario above doesn't make total sense to me. I don't see why deletion of user B must fail until they are removed from both approval groups?   Why wouldn't a deletion just remove them from those approval groups (and let the approval proceed with other users in those groups)?\nDoes this have to do with whether a EPerson is the only member of a workflow role Group?\nSimply put, I think we need to think about this more:\n\nIf an EPerson is only one (of many) member of a workflow role Group, then it seems like deleting them should just remove them from the group.  I.e. no error should occur.\nIf an EPerson is the only member of a workflow role Group, then we have two options:\n\nWe delete both the EPerson & the Workflow Role Group (i.e. you are deleting that workflow step by deleting the only member of it).  We could warn an Admin here if needed by saying: \"By deleting this person, you will also remove these workflow steps of which they are the only member: \"\nWe refuse to delete the EPerson until they are removed from each of the Workflow Role Groups.  This is easier for us, but potentially more work for the DSpace Admin, who may have to go in and edit/delete the EPerson from a number of Groups one by one.", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r474243830", "createdAt": "2020-08-20T20:08:21Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/test/java/org/dspace/eperson/EPersonInWorkflowTest.java", "diffHunk": "@@ -0,0 +1,1477 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.eperson;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+import javax.servlet.http.HttpServletRequest;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.AbstractIntegrationTestWithDatabase;\n+import org.dspace.builder.CollectionBuilder;\n+import org.dspace.builder.CommunityBuilder;\n+import org.dspace.builder.EPersonBuilder;\n+import org.dspace.builder.WorkspaceItemBuilder;\n+import org.dspace.content.Collection;\n+import org.dspace.content.Community;\n+import org.dspace.content.WorkspaceItem;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.content.service.CollectionService;\n+import org.dspace.content.service.CommunityService;\n+import org.dspace.content.service.InstallItemService;\n+import org.dspace.content.service.ItemService;\n+import org.dspace.content.service.WorkspaceItemService;\n+import org.dspace.eperson.factory.EPersonServiceFactory;\n+import org.dspace.eperson.service.EPersonService;\n+import org.dspace.eperson.service.GroupService;\n+import org.dspace.workflow.WorkflowItemService;\n+import org.dspace.workflow.WorkflowService;\n+import org.dspace.workflow.factory.WorkflowServiceFactory;\n+import org.dspace.xmlworkflow.factory.XmlWorkflowServiceFactory;\n+import org.dspace.xmlworkflow.service.XmlWorkflowService;\n+import org.dspace.xmlworkflow.state.Workflow;\n+import org.dspace.xmlworkflow.storedcomponents.CollectionRole;\n+import org.dspace.xmlworkflow.storedcomponents.XmlWorkflowItem;\n+import org.dspace.xmlworkflow.storedcomponents.service.ClaimedTaskService;\n+import org.dspace.xmlworkflow.storedcomponents.service.CollectionRoleService;\n+import org.dspace.xmlworkflow.storedcomponents.service.PoolTaskService;\n+import org.dspace.xmlworkflow.storedcomponents.service.XmlWorkflowItemService;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.springframework.mock.web.MockHttpServletRequest;\n+\n+/**\n+ * Class to test interaction between EPerson deletion and tasks present in the workflow\n+ */\n+public class EPersonInWorkflowTest extends AbstractIntegrationTestWithDatabase {\n+\n+    private final String REVIEW_STEP = \"reviewstep\";\n+    private final String CLAIM_ACTION = \"claimaction\";\n+    private final String REVIEW_ACTION = \"reviewaction\";\n+    private final String REVIEW_ROLE = \"reviewer\";\n+    private final String EDIT_STEP = \"editstep\";\n+    private final String EDIT_ACTION = \"editaction\";\n+    private final String FINAL_EDIT_ROLE = \"finaleditor\";\n+    private final String FINAL_EDIT_STEP = \"finaleditstep\";\n+    private final String FINAL_EDIT_ACTION = \"finaleditaction\";\n+    private final String EDIT_ROLE = \"editor\";\n+    protected EPersonService ePersonService = EPersonServiceFactory.getInstance().getEPersonService();\n+    protected GroupService groupService = EPersonServiceFactory.getInstance().getGroupService();\n+    protected CommunityService communityService = ContentServiceFactory.getInstance().getCommunityService();\n+    protected CollectionService collectionService = ContentServiceFactory.getInstance().getCollectionService();\n+    protected ItemService itemService = ContentServiceFactory.getInstance().getItemService();\n+    protected InstallItemService installItemService = ContentServiceFactory.getInstance().getInstallItemService();\n+    protected WorkflowItemService workflowItemService = WorkflowServiceFactory.getInstance().getWorkflowItemService();\n+    protected XmlWorkflowItemService xmlWorkflowItemService = XmlWorkflowServiceFactory.getInstance()\n+                                                                                       .getXmlWorkflowItemService();\n+    protected WorkflowService workflowService = WorkflowServiceFactory.getInstance().getWorkflowService();\n+    protected WorkspaceItemService workspaceItemService = ContentServiceFactory.getInstance()\n+                                                                               .getWorkspaceItemService();\n+    protected ClaimedTaskService claimedTaskService = XmlWorkflowServiceFactory.getInstance().getClaimedTaskService();\n+    protected PoolTaskService poolTaskService = XmlWorkflowServiceFactory.getInstance().getPoolTaskService();\n+\n+    protected XmlWorkflowService xmlWorkflowService = XmlWorkflowServiceFactory.getInstance().getXmlWorkflowService();\n+    protected CollectionRoleService collectionRoleService = XmlWorkflowServiceFactory.getInstance()\n+                                                                                     .getCollectionRoleService();\n+\n+\n+    private EPerson workflowUserA;\n+    private EPerson workflowUserB;\n+    private EPerson workflowUserC;\n+    private EPerson workflowUserD;\n+\n+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(EPersonInWorkflowTest.class);\n+\n+    /**\n+     * This method will be run before every test as per @Before. It will\n+     * initialize resources required for the tests.\n+     *\n+     * Other methods can be annotated with @Before here or in subclasses but no\n+     * execution order is guaranteed\n+     */\n+    @Before\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+\n+        context.turnOffAuthorisationSystem();\n+\n+        workflowUserA = EPersonBuilder.createEPerson(context).withEmail(\"workflowUserA@example.org\").build();\n+        workflowUserB = EPersonBuilder.createEPerson(context).withEmail(\"workflowUserB@example.org\").build();\n+        workflowUserC = EPersonBuilder.createEPerson(context).withEmail(\"workflowUserC@example.org\").build();\n+        workflowUserD = EPersonBuilder.createEPerson(context).withEmail(\"workflowUserD@example.org\").build();\n+\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+\n+    /**\n+     * This test has the following setup:\n+     * - Step 1: user B\n+     * - Step 2: user C\n+     * - Step 3: user B\n+     *\n+     * This test will perform the following checks:\n+     * - create a workspace item, and let it move to step 1\n+     * - approve it by user B\n+     * - verify that the item moved to step 2\n+     * - Claim it by user C\n+     * - delete user B\n+     * - verify the delete is refused\n+     * - remove user B from step 3\n+     * - approve it by user C\n+     * - verify that the item is archived without any actions apart from removing user B\n+     * - delete user B\n+     * - verify the delete is refused\n+     * - remove user B from step 1\n+     * - delete user B\n+     * - verify the delete succeeds", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "705b2b544f5106785e211a2999b4a6a32280f551"}, "originalPosition": 142}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e25cea2bb000a2118eccd250f61a60386f6c3f1b", "author": {"user": {"login": "YanaDePauw", "name": "Yana De Pauw"}}, "url": "https://github.com/DSpace/DSpace/commit/e25cea2bb000a2118eccd250f61a60386f6c3f1b", "committedDate": "2020-08-27T13:00:11Z", "message": "72750: Finalize Delete eperson: workflow"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "548e0355eff403ae0d729759a75929fe2195d0c1", "author": {"user": {"login": "YanaDePauw", "name": "Yana De Pauw"}}, "url": "https://github.com/DSpace/DSpace/commit/548e0355eff403ae0d729759a75929fe2195d0c1", "committedDate": "2020-09-01T09:41:17Z", "message": "72774: Delete eperson: workspace"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "81f58b473f56d92e53f36393efb0531d321dcbff", "author": {"user": {"login": "benbosman", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/81f58b473f56d92e53f36393efb0531d321dcbff", "committedDate": "2020-09-16T10:44:15Z", "message": "Merge pull request #32 from atmire/w2p-72774_Delete-eperson-workspace\n\n72774: Delete eperson: workspace"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3977fe72c815083d7f821a2fc3aa19f55ed582c1", "author": {"user": {"login": "YanaDePauw", "name": "Yana De Pauw"}}, "url": "https://github.com/DSpace/DSpace/commit/3977fe72c815083d7f821a2fc3aa19f55ed582c1", "committedDate": "2020-09-17T12:03:44Z", "message": "Merge remote-tracking branch 'upstream/main' into w2p-72472_Delete-eperson"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f71202c8c33475888e2ef10bbf22881637bcc592", "author": {"user": {"login": "YanaDePauw", "name": "Yana De Pauw"}}, "url": "https://github.com/DSpace/DSpace/commit/f71202c8c33475888e2ef10bbf22881637bcc592", "committedDate": "2020-09-17T12:03:50Z", "message": "Fix to tests post merge"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1MDc0MDgy", "url": "https://github.com/DSpace/DSpace/pull/2928#pullrequestreview-495074082", "createdAt": "2020-09-23T21:50:56Z", "commit": {"oid": "f71202c8c33475888e2ef10bbf22881637bcc592"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QyMTo1MDo1NlrOHXCOuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QyMTo1NTozNlrOHXCXKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkxNTgzMw==", "bodyText": "This feedback hasn't been addressed yet.", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r493915833", "createdAt": "2020-09-23T21:50:56Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/app/requestitem/RequestItemHelpdeskStrategy.java", "diffHunk": "@@ -74,8 +74,7 @@ public RequestItemAuthor getHelpDeskPerson(Context context, String helpDeskEmail\n             return new RequestItemAuthor(helpdeskEPerson);\n         } else {\n             String helpdeskName = I18nUtil.getMessage(\n-                \"org.dspace.app.requestitem.RequestItemHelpdeskStrategy.helpdeskname\",\n-                context);\n+                \"org.dspace.app.requestitem.helpdeskname\", context);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxMTQ5Nw=="}, "originalCommit": {"oid": "705b2b544f5106785e211a2999b4a6a32280f551"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkxNTkyMQ==", "bodyText": "This feedback hasn't been addressed yet", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r493915921", "createdAt": "2020-09-23T21:51:09Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/app/requestitem/RequestItemMetadataStrategy.java", "diffHunk": "@@ -49,19 +51,37 @@ public RequestItemAuthor getRequestItemAuthor(Context context, Item item)\n                         fullname = nameVals.iterator().next().getValue();\n                     }\n                 }\n-\n                 if (StringUtils.isBlank(fullname)) {\n                     fullname = I18nUtil\n-                        .getMessage(\n-                            \"org.dspace.app.requestitem.RequestItemMetadataStrategy.unnamed\",\n-                            context);\n+                            .getMessage(\n+                                    \"org.dspace.app.requestitem.RequestItemMetadataStrategy.unnamed\",\n+                                    context);\n                 }\n-                RequestItemAuthor author = new RequestItemAuthor(\n-                    fullname, email);\n+                author = new RequestItemAuthor(fullname, email);\n                 return author;\n             }\n+        } else {\n+            // Uses the basic strategy to look for the original submitter\n+            author = super.getRequestItemAuthor(context, item);\n+            // Is the author or his email  null, so get the help desk or admin name and email\n+            if (null == author || null == author.getEmail()) {\n+                String email = null;\n+                String name = null;\n+                //First get help desk name and email\n+                email = DSpaceServicesFactory.getInstance()\n+                        .getConfigurationService().getProperty(\"mail.helpdesk\");\n+                name = I18nUtil.getMessage(\"org.dspace.app.requestitem.helpdeskname\", context);\n+                // If help desk mail is null get the mail and name of admin\n+                if (email == null) {\n+                    email = DSpaceServicesFactory.getInstance()\n+                            .getConfigurationService().getProperty(\"mail.admin\");\n+                    name = DSpaceServicesFactory.getInstance()\n+                            .getConfigurationService().getProperty(\"admin.name\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxNDA1Ng=="}, "originalCommit": {"oid": "705b2b544f5106785e211a2999b4a6a32280f551"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkxNjAyOA==", "bodyText": "This feedback hasn't been addressed yet", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r493916028", "createdAt": "2020-09-23T21:51:26Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/authorize/dao/ResourcePolicyDAO.java", "diffHunk": "@@ -66,6 +68,8 @@\n \n     public void deleteByDsoEPersonPolicies(Context context, DSpaceObject dso, EPerson ePerson) throws SQLException;\n \n+    public void deleteAllEPersonPolicies(Context context, EPerson ePerson) throws SQLException;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxNDk5OA=="}, "originalCommit": {"oid": "705b2b544f5106785e211a2999b4a6a32280f551"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkxNjEzNQ==", "bodyText": "This feedback hasn't been addressed yet", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r493916135", "createdAt": "2020-09-23T21:51:39Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/eperson/EPersonCLITool.java", "diffHunk": "@@ -259,16 +262,27 @@ private static int cmdDelete(Context context, String[] argv) {\n         }\n \n         try {\n-            ePersonService.delete(context, eperson);\n-            context.complete();\n-            System.out.printf(\"Deleted EPerson %s\\n\", eperson.getID().toString());\n-        } catch (SQLException ex) {\n-            System.err.println(ex.getMessage());\n-            return 1;\n-        } catch (AuthorizeException ex) {\n-            System.err.println(ex.getMessage());\n-            return 1;\n-        } catch (IOException ex) {\n+            List<String> tableList = ePersonService.getDeleteConstraints(context, eperson);\n+            if (!tableList.isEmpty()) {\n+                System.out.printf(\"This EPerson with ID: %s is referring to this tables:%n \",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxODEwNQ=="}, "originalCommit": {"oid": "705b2b544f5106785e211a2999b4a6a32280f551"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkxNjIxNQ==", "bodyText": "This feedback hasn't been addressed yet", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r493916215", "createdAt": "2020-09-23T21:51:51Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/eperson/EPersonCLITool.java", "diffHunk": "@@ -259,16 +262,27 @@ private static int cmdDelete(Context context, String[] argv) {\n         }\n \n         try {\n-            ePersonService.delete(context, eperson);\n-            context.complete();\n-            System.out.printf(\"Deleted EPerson %s\\n\", eperson.getID().toString());\n-        } catch (SQLException ex) {\n-            System.err.println(ex.getMessage());\n-            return 1;\n-        } catch (AuthorizeException ex) {\n-            System.err.println(ex.getMessage());\n-            return 1;\n-        } catch (IOException ex) {\n+            List<String> tableList = ePersonService.getDeleteConstraints(context, eperson);\n+            if (!tableList.isEmpty()) {\n+                System.out.printf(\"This EPerson with ID: %s is referring to this tables:%n \",\n+                        eperson.getID().toString());\n+                tableList.forEach((s) -> {\n+                    System.out.println(s);\n+                });\n+            }\n+            System.out.printf(\"Are you sure you want to delete this EPerson with ID: %s? (y or n): \",\n+                    eperson.getID().toString());\n+            BufferedReader input = new BufferedReader(new InputStreamReader(System.in));\n+            System.out.flush();\n+            String s = input.readLine();\n+            if (s != null && s.trim().toLowerCase().startsWith(\"y\")) {\n+                ePersonService.delete(context, eperson);\n+                context.complete();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxNzE5OQ=="}, "originalCommit": {"oid": "705b2b544f5106785e211a2999b4a6a32280f551"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkxNjI3NQ==", "bodyText": "This feedback hasn't been addressed yet", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r493916275", "createdAt": "2020-09-23T21:51:59Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/eperson/EPersonCLITool.java", "diffHunk": "@@ -259,16 +262,27 @@ private static int cmdDelete(Context context, String[] argv) {\n         }\n \n         try {\n-            ePersonService.delete(context, eperson);\n-            context.complete();\n-            System.out.printf(\"Deleted EPerson %s\\n\", eperson.getID().toString());\n-        } catch (SQLException ex) {\n-            System.err.println(ex.getMessage());\n-            return 1;\n-        } catch (AuthorizeException ex) {\n-            System.err.println(ex.getMessage());\n-            return 1;\n-        } catch (IOException ex) {\n+            List<String> tableList = ePersonService.getDeleteConstraints(context, eperson);\n+            if (!tableList.isEmpty()) {\n+                System.out.printf(\"This EPerson with ID: %s is referring to this tables:%n \",\n+                        eperson.getID().toString());\n+                tableList.forEach((s) -> {\n+                    System.out.println(s);\n+                });\n+            }\n+            System.out.printf(\"Are you sure you want to delete this EPerson with ID: %s? (y or n): \",\n+                    eperson.getID().toString());\n+            BufferedReader input = new BufferedReader(new InputStreamReader(System.in));\n+            System.out.flush();\n+            String s = input.readLine();\n+            if (s != null && s.trim().toLowerCase().startsWith(\"y\")) {\n+                ePersonService.delete(context, eperson);\n+                context.complete();\n+                System.out.printf(\"%nDeleted EPerson with ID: %s\", eperson.getID().toString());\n+            } else {\n+                System.out.printf(\"%nAbort Deletetion of EPerson with ID: %s %n\", eperson.getID().toString());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxNjI3NA=="}, "originalCommit": {"oid": "705b2b544f5106785e211a2999b4a6a32280f551"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkxNjM4Nw==", "bodyText": "This feedback hasn't been addressed yet", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r493916387", "createdAt": "2020-09-23T21:52:13Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/eperson/EPersonServiceImpl.java", "diffHunk": "@@ -179,45 +222,202 @@ public EPerson create(Context context) throws SQLException, AuthorizeException {\n         // authorized?\n         if (!authorizeService.isAdmin(context)) {\n             throw new AuthorizeException(\n-                \"You must be an admin to create an EPerson\");\n+                    \"You must be an admin to create an EPerson\");\n         }\n \n         // Create a table row\n         EPerson e = ePersonDAO.create(context, new EPerson());\n \n         log.info(LogManager.getHeader(context, \"create_eperson\", \"eperson_id=\"\n-            + e.getID()));\n+                + e.getID()));\n \n         context.addEvent(new Event(Event.CREATE, Constants.EPERSON, e.getID(),\n-                                   null, getIdentifiers(context, e)));\n+                null, getIdentifiers(context, e)));\n \n         return e;\n     }\n \n     @Override\n     public void delete(Context context, EPerson ePerson) throws SQLException, AuthorizeException {\n+        try {\n+            delete(context, ePerson, true);\n+        } catch (AuthorizeException ex) {\n+            log.error(\"This AuthorizeException: \" + ex + \" occured while deleting Eperson with the ID: \" +\n+                      ePerson.getID());\n+            throw new AuthorizeException(ex.getMessage());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxOTM1NA=="}, "originalCommit": {"oid": "705b2b544f5106785e211a2999b4a6a32280f551"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkxNjQ3Mw==", "bodyText": "This feedback hasn't been addressed yet", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r493916473", "createdAt": "2020-09-23T21:52:25Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/eperson/EPersonServiceImpl.java", "diffHunk": "@@ -179,45 +222,202 @@ public EPerson create(Context context) throws SQLException, AuthorizeException {\n         // authorized?\n         if (!authorizeService.isAdmin(context)) {\n             throw new AuthorizeException(\n-                \"You must be an admin to create an EPerson\");\n+                    \"You must be an admin to create an EPerson\");\n         }\n \n         // Create a table row\n         EPerson e = ePersonDAO.create(context, new EPerson());\n \n         log.info(LogManager.getHeader(context, \"create_eperson\", \"eperson_id=\"\n-            + e.getID()));\n+                + e.getID()));\n \n         context.addEvent(new Event(Event.CREATE, Constants.EPERSON, e.getID(),\n-                                   null, getIdentifiers(context, e)));\n+                null, getIdentifiers(context, e)));\n \n         return e;\n     }\n \n     @Override\n     public void delete(Context context, EPerson ePerson) throws SQLException, AuthorizeException {\n+        try {\n+            delete(context, ePerson, true);\n+        } catch (AuthorizeException ex) {\n+            log.error(\"This AuthorizeException: \" + ex + \" occured while deleting Eperson with the ID: \" +\n+                      ePerson.getID());\n+            throw new AuthorizeException(ex.getMessage());\n+        } catch (IOException ex) {\n+            log.error(\"This IOException: \" + ex + \" occured while deleting Eperson with the ID: \" + ePerson.getID());\n+            throw new AuthorizeException(new EPersonDeletionException());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxOTgxMA=="}, "originalCommit": {"oid": "705b2b544f5106785e211a2999b4a6a32280f551"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkxNjg4MQ==", "bodyText": "This feedback hasn't been addressed (or maybe just answered) yet.  Not sure what approach you think is better.", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r493916881", "createdAt": "2020-09-23T21:53:21Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/workflowbasic/BasicWorkflowServiceImpl.java", "diffHunk": "@@ -798,33 +798,37 @@ protected void notifyOfArchive(Context context, Item item, Collection coll)\n         try {\n             // Get submitter\n             EPerson ep = item.getSubmitter();\n-            // Get the Locale\n-            Locale supportedLocale = I18nUtil.getEPersonLocale(ep);\n-            Email email = Email.getEmail(I18nUtil.getEmailFilename(supportedLocale, \"submit_archive\"));\n \n-            // Get the item handle to email to user\n-            String handle = handleService.findHandle(context, item);\n-\n-            // Get title\n-            String title = item.getName();\n-            if (StringUtils.isBlank(title)) {\n-                try {\n-                    title = I18nUtil.getMessage(\"org.dspace.workflow.WorkflowManager.untitled\");\n-                } catch (MissingResourceException e) {\n-                    title = \"Untitled\";\n+            // send the notification to the submitter unless the submitter eperson has been deleted\n+            if (ep != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIzNDc3Ng=="}, "originalCommit": {"oid": "705b2b544f5106785e211a2999b4a6a32280f551"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkxNzk5NQ==", "bodyText": "Most of this prior feedback can be ignored, except as noted, it'd be useful to update the comments above these tests to simply summarize the scenario that each test is attempting to verify.  The detailed list of steps is sometimes confusing to follow.  So, I think this test could say something like: This test verifies that an EPerson cannot be removed if they are the only member of a Workflow Group that has tasks currently assigned to it.\nThe same is true for all tests in this class...it's sometimes hard to follow exactly why they are performing the steps they are performing. So, a simple summary sentence would help describe the scenario much more clearly.", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r493917995", "createdAt": "2020-09-23T21:55:36Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/test/java/org/dspace/eperson/EPersonInWorkflowTest.java", "diffHunk": "@@ -0,0 +1,1477 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.eperson;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+import javax.servlet.http.HttpServletRequest;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.AbstractIntegrationTestWithDatabase;\n+import org.dspace.builder.CollectionBuilder;\n+import org.dspace.builder.CommunityBuilder;\n+import org.dspace.builder.EPersonBuilder;\n+import org.dspace.builder.WorkspaceItemBuilder;\n+import org.dspace.content.Collection;\n+import org.dspace.content.Community;\n+import org.dspace.content.WorkspaceItem;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.content.service.CollectionService;\n+import org.dspace.content.service.CommunityService;\n+import org.dspace.content.service.InstallItemService;\n+import org.dspace.content.service.ItemService;\n+import org.dspace.content.service.WorkspaceItemService;\n+import org.dspace.eperson.factory.EPersonServiceFactory;\n+import org.dspace.eperson.service.EPersonService;\n+import org.dspace.eperson.service.GroupService;\n+import org.dspace.workflow.WorkflowItemService;\n+import org.dspace.workflow.WorkflowService;\n+import org.dspace.workflow.factory.WorkflowServiceFactory;\n+import org.dspace.xmlworkflow.factory.XmlWorkflowServiceFactory;\n+import org.dspace.xmlworkflow.service.XmlWorkflowService;\n+import org.dspace.xmlworkflow.state.Workflow;\n+import org.dspace.xmlworkflow.storedcomponents.CollectionRole;\n+import org.dspace.xmlworkflow.storedcomponents.XmlWorkflowItem;\n+import org.dspace.xmlworkflow.storedcomponents.service.ClaimedTaskService;\n+import org.dspace.xmlworkflow.storedcomponents.service.CollectionRoleService;\n+import org.dspace.xmlworkflow.storedcomponents.service.PoolTaskService;\n+import org.dspace.xmlworkflow.storedcomponents.service.XmlWorkflowItemService;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.springframework.mock.web.MockHttpServletRequest;\n+\n+/**\n+ * Class to test interaction between EPerson deletion and tasks present in the workflow\n+ */\n+public class EPersonInWorkflowTest extends AbstractIntegrationTestWithDatabase {\n+\n+    private final String REVIEW_STEP = \"reviewstep\";\n+    private final String CLAIM_ACTION = \"claimaction\";\n+    private final String REVIEW_ACTION = \"reviewaction\";\n+    private final String REVIEW_ROLE = \"reviewer\";\n+    private final String EDIT_STEP = \"editstep\";\n+    private final String EDIT_ACTION = \"editaction\";\n+    private final String FINAL_EDIT_ROLE = \"finaleditor\";\n+    private final String FINAL_EDIT_STEP = \"finaleditstep\";\n+    private final String FINAL_EDIT_ACTION = \"finaleditaction\";\n+    private final String EDIT_ROLE = \"editor\";\n+    protected EPersonService ePersonService = EPersonServiceFactory.getInstance().getEPersonService();\n+    protected GroupService groupService = EPersonServiceFactory.getInstance().getGroupService();\n+    protected CommunityService communityService = ContentServiceFactory.getInstance().getCommunityService();\n+    protected CollectionService collectionService = ContentServiceFactory.getInstance().getCollectionService();\n+    protected ItemService itemService = ContentServiceFactory.getInstance().getItemService();\n+    protected InstallItemService installItemService = ContentServiceFactory.getInstance().getInstallItemService();\n+    protected WorkflowItemService workflowItemService = WorkflowServiceFactory.getInstance().getWorkflowItemService();\n+    protected XmlWorkflowItemService xmlWorkflowItemService = XmlWorkflowServiceFactory.getInstance()\n+                                                                                       .getXmlWorkflowItemService();\n+    protected WorkflowService workflowService = WorkflowServiceFactory.getInstance().getWorkflowService();\n+    protected WorkspaceItemService workspaceItemService = ContentServiceFactory.getInstance()\n+                                                                               .getWorkspaceItemService();\n+    protected ClaimedTaskService claimedTaskService = XmlWorkflowServiceFactory.getInstance().getClaimedTaskService();\n+    protected PoolTaskService poolTaskService = XmlWorkflowServiceFactory.getInstance().getPoolTaskService();\n+\n+    protected XmlWorkflowService xmlWorkflowService = XmlWorkflowServiceFactory.getInstance().getXmlWorkflowService();\n+    protected CollectionRoleService collectionRoleService = XmlWorkflowServiceFactory.getInstance()\n+                                                                                     .getCollectionRoleService();\n+\n+\n+    private EPerson workflowUserA;\n+    private EPerson workflowUserB;\n+    private EPerson workflowUserC;\n+    private EPerson workflowUserD;\n+\n+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(EPersonInWorkflowTest.class);\n+\n+    /**\n+     * This method will be run before every test as per @Before. It will\n+     * initialize resources required for the tests.\n+     *\n+     * Other methods can be annotated with @Before here or in subclasses but no\n+     * execution order is guaranteed\n+     */\n+    @Before\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+\n+        context.turnOffAuthorisationSystem();\n+\n+        workflowUserA = EPersonBuilder.createEPerson(context).withEmail(\"workflowUserA@example.org\").build();\n+        workflowUserB = EPersonBuilder.createEPerson(context).withEmail(\"workflowUserB@example.org\").build();\n+        workflowUserC = EPersonBuilder.createEPerson(context).withEmail(\"workflowUserC@example.org\").build();\n+        workflowUserD = EPersonBuilder.createEPerson(context).withEmail(\"workflowUserD@example.org\").build();\n+\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+\n+    /**\n+     * This test has the following setup:\n+     * - Step 1: user B\n+     * - Step 2: user C\n+     * - Step 3: user B\n+     *\n+     * This test will perform the following checks:\n+     * - create a workspace item, and let it move to step 1\n+     * - approve it by user B\n+     * - verify that the item moved to step 2\n+     * - Claim it by user C\n+     * - delete user B\n+     * - verify the delete is refused\n+     * - remove user B from step 3\n+     * - approve it by user C\n+     * - verify that the item is archived without any actions apart from removing user B\n+     * - delete user B\n+     * - verify the delete is refused\n+     * - remove user B from step 1\n+     * - delete user B\n+     * - verify the delete succeeds", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDI0MzgzMA=="}, "originalCommit": {"oid": "705b2b544f5106785e211a2999b4a6a32280f551"}, "originalPosition": 142}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b563e4906100a1b7632269043df46a97a3e237b", "author": {"user": {"login": "YanaDePauw", "name": "Yana De Pauw"}}, "url": "https://github.com/DSpace/DSpace/commit/3b563e4906100a1b7632269043df46a97a3e237b", "committedDate": "2020-09-28T15:31:00Z", "message": "73422: Delete eperson: community feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4ODM0MjY4", "url": "https://github.com/DSpace/DSpace/pull/2928#pullrequestreview-498834268", "createdAt": "2020-09-29T20:00:22Z", "commit": {"oid": "3b563e4906100a1b7632269043df46a97a3e237b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQyMDowMDoyMlrOHZ_CIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQyMjowMjoyNFrOHaDwlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAwOTE4NQ==", "bodyText": "Yes, reverting this change seems reasonable. I don't see a reason to rename this at this time.  If we find a reason at a later date, we can give it a better name then.", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r497009185", "createdAt": "2020-09-29T20:00:22Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/app/requestitem/RequestItemHelpdeskStrategy.java", "diffHunk": "@@ -74,8 +74,7 @@ public RequestItemAuthor getHelpDeskPerson(Context context, String helpDeskEmail\n             return new RequestItemAuthor(helpdeskEPerson);\n         } else {\n             String helpdeskName = I18nUtil.getMessage(\n-                \"org.dspace.app.requestitem.RequestItemHelpdeskStrategy.helpdeskname\",\n-                context);\n+                \"org.dspace.app.requestitem.helpdeskname\", context);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxMTQ5Nw=="}, "originalCommit": {"oid": "705b2b544f5106785e211a2999b4a6a32280f551"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAxMDM4NA==", "bodyText": "Please add JavaDocs to describe this new method so that it's clear what retrieveAllItems does when true or false.\nUPDATE: I realized you do describe this in ItemService.findBySubmitter().  But, I'd recommend copying the same JavaDocs over here as well, just to document this method.", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r497010384", "createdAt": "2020-09-29T20:02:32Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/content/dao/ItemDAO.java", "diffHunk": "@@ -47,6 +47,9 @@\n \n     public Iterator<Item> findBySubmitter(Context context, EPerson eperson) throws SQLException;\n \n+    public Iterator<Item> findBySubmitter(Context context, EPerson eperson, boolean retrieveAllItems)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b563e4906100a1b7632269043df46a97a3e237b"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAxMDc1MQ==", "bodyText": "JavaDocs please.  Also, please add them to the new find() method in this same class", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r497010751", "createdAt": "2020-09-29T20:03:18Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/authorize/service/ResourcePolicyService.java", "diffHunk": "@@ -72,6 +74,8 @@ public void removeDsoGroupPolicies(Context context, DSpaceObject dso, Group grou\n     public void removeDsoEPersonPolicies(Context context, DSpaceObject dso, EPerson ePerson)\n         throws SQLException, AuthorizeException;\n \n+    public void removeAllEPersonPolicies(Context context, EPerson ePerson) throws SQLException, AuthorizeException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b563e4906100a1b7632269043df46a97a3e237b"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAxMTUwNw==", "bodyText": "We likely shouldn't be building the Query object until after this if statement.  It seems odd to build the Query only to throw it out if retrieveAllItems=false", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r497011507", "createdAt": "2020-09-29T20:04:48Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/content/dao/impl/ItemDAOImpl.java", "diffHunk": "@@ -108,6 +108,17 @@ protected ItemDAOImpl() {\n         return iterate(query);\n     }\n \n+    @Override\n+    public Iterator<Item> findBySubmitter(Context context, EPerson eperson, boolean retrieveAllItems)\n+        throws SQLException {\n+        Query query = createQuery(context, \"FROM Item WHERE submitter= :submitter\");\n+        if (!retrieveAllItems) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b563e4906100a1b7632269043df46a97a3e237b"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAxMzEyNw==", "bodyText": "Not sure I understand this description.  If retrieveAllItems=true, does that mean you are retrieving both archived and unarchived items?  I'm assuming so.  If that's the case, we could reword this to say something like:\nIf true, all items (regardless of status) are returned. If false, only archived items will be returned.", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r497013127", "createdAt": "2020-09-29T20:07:56Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/content/service/ItemService.java", "diffHunk": "@@ -113,6 +113,19 @@\n     public Iterator<Item> findBySubmitter(Context context, EPerson eperson)\n         throws SQLException;\n \n+    /**\n+     * Find all the items by a given submitter. The order is\n+     * indeterminate. All items are included.\n+     *\n+     * @param context DSpace context object\n+     * @param eperson the submitter\n+     * @param retrieveAllItems flag to determine if only archive should be returned", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b563e4906100a1b7632269043df46a97a3e237b"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAxNDgyMQ==", "bodyText": "Again, this needs addressing.  We seem to be throwing away the entire stacktrace in this statement.  Shouldn't this be replaced with something simple like throw ex;?", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r497014821", "createdAt": "2020-09-29T20:11:16Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/eperson/EPersonServiceImpl.java", "diffHunk": "@@ -179,45 +222,202 @@ public EPerson create(Context context) throws SQLException, AuthorizeException {\n         // authorized?\n         if (!authorizeService.isAdmin(context)) {\n             throw new AuthorizeException(\n-                \"You must be an admin to create an EPerson\");\n+                    \"You must be an admin to create an EPerson\");\n         }\n \n         // Create a table row\n         EPerson e = ePersonDAO.create(context, new EPerson());\n \n         log.info(LogManager.getHeader(context, \"create_eperson\", \"eperson_id=\"\n-            + e.getID()));\n+                + e.getID()));\n \n         context.addEvent(new Event(Event.CREATE, Constants.EPERSON, e.getID(),\n-                                   null, getIdentifiers(context, e)));\n+                null, getIdentifiers(context, e)));\n \n         return e;\n     }\n \n     @Override\n     public void delete(Context context, EPerson ePerson) throws SQLException, AuthorizeException {\n+        try {\n+            delete(context, ePerson, true);\n+        } catch (AuthorizeException ex) {\n+            log.error(\"This AuthorizeException: \" + ex + \" occured while deleting Eperson with the ID: \" +\n+                      ePerson.getID());\n+            throw new AuthorizeException(ex.getMessage());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxOTM1NA=="}, "originalCommit": {"oid": "705b2b544f5106785e211a2999b4a6a32280f551"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAxNTgxNg==", "bodyText": "I'd recommend we cleanup this error message (as it's a bit inaccurate...the problem is that this person is the only member of the group).  It likely should say:\n\"Refused to delete user \" + ePerson.getID() + \" because it the only member of the group \" + group.getID() + \". Delete the group first if you want to remove this user.\"", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r497015816", "createdAt": "2020-09-29T20:13:16Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/main/java/org/dspace/eperson/EPersonServiceImpl.java", "diffHunk": "@@ -179,45 +222,202 @@ public EPerson create(Context context) throws SQLException, AuthorizeException {\n         // authorized?\n         if (!authorizeService.isAdmin(context)) {\n             throw new AuthorizeException(\n-                \"You must be an admin to create an EPerson\");\n+                    \"You must be an admin to create an EPerson\");\n         }\n \n         // Create a table row\n         EPerson e = ePersonDAO.create(context, new EPerson());\n \n         log.info(LogManager.getHeader(context, \"create_eperson\", \"eperson_id=\"\n-            + e.getID()));\n+                + e.getID()));\n \n         context.addEvent(new Event(Event.CREATE, Constants.EPERSON, e.getID(),\n-                                   null, getIdentifiers(context, e)));\n+                null, getIdentifiers(context, e)));\n \n         return e;\n     }\n \n     @Override\n     public void delete(Context context, EPerson ePerson) throws SQLException, AuthorizeException {\n+        try {\n+            delete(context, ePerson, true);\n+        } catch (AuthorizeException ex) {\n+            log.error(\"This AuthorizeException: \" + ex + \" occured while deleting Eperson with the ID: \" +\n+                      ePerson.getID());\n+            throw new AuthorizeException(ex.getMessage());\n+        } catch (IOException ex) {\n+            log.error(\"This IOException: \" + ex + \" occured while deleting Eperson with the ID: \" + ePerson.getID());\n+            throw new AuthorizeException(ex);\n+        } catch (EPersonDeletionException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    /**\n+     * Deletes an EPerson. The argument cascade defines whether all references\n+     * on an EPerson should be deleted as well (by either deleting the\n+     * referencing object - e.g. WorkspaceItem, ResourcePolicy - or by setting\n+     * the foreign key null - e.g. archived Items). If cascade is set to false\n+     * and the EPerson is referenced somewhere, this leads to an\n+     * AuthorizeException. EPersons may be referenced by Items, ResourcePolicies\n+     * and workflow tasks.\n+     *\n+     * @param context DSpace context\n+     * @param ePerson The EPerson to delete.\n+     * @param cascade Whether to delete references on the EPerson (cascade =\n+     * true) or to abort the deletion (cascade = false) if the EPerson is\n+     * referenced within DSpace.\n+     *\n+     * @throws SQLException\n+     * @throws AuthorizeException\n+     * @throws IOException\n+     */\n+    public void delete(Context context, EPerson ePerson, boolean cascade)\n+            throws SQLException, AuthorizeException, IOException, EPersonDeletionException {\n         // authorized?\n         if (!authorizeService.isAdmin(context)) {\n             throw new AuthorizeException(\n-                \"You must be an admin to delete an EPerson\");\n+                    \"You must be an admin to delete an EPerson\");\n+        }\n+        Set<Group> workFlowGroups = getAllWorkFlowGroups(context, ePerson);\n+        for (Group group: workFlowGroups) {\n+            List<EPerson> ePeople = groupService.allMembers(context, group);\n+            if (ePeople.size() == 1 && ePeople.contains(ePerson)) {\n+                throw new IllegalStateException(\n+                        \"Refused to delete user \" + ePerson.getID() + \" because it is part of the group \" + group", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b563e4906100a1b7632269043df46a97a3e237b"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4NjYxNA==", "bodyText": "I'd still appreciate simple summary notes at the beginning of each of these tests.  It's very hard to follow these tests & the detailed \"This test will perform the following checks:\" does not always make it clear which scenario is being tested for.\nAs I noted previously, I think this test method can be easily summarized as \"This test verifies that an EPerson cannot be removed if they are the only member of a Workflow Group that has tasks currently assigned to it.\"  However, I'm not sure that's accurate, as it also seems like it might be testing that a user with claimed tasks cannot be deleted?\nI think these tests would be a lot easier to understand if the JavaDocs just had a brief summary of the scenarios tested, and you moved the step-by-step summary into inline comments.  Otherwise, I'm stuck reading a line and then having to scroll up to the JavaDocs to see which step it might be referencing, then reading the next line, and scroll back up, etc.\nIt's also extremely difficult determining the differences between  testDeleteUserWhenOnlyUserInGroup1, testDeleteUserWhenOnlyUserInGroup2, ``testDeleteUserWhenOnlyUserInGroup3`...all the way to 7.  Again, I think it'd be easier to understand if the JavaDocs had a simple summary of what makes this tests unique, and you move more of the details to inline (to describe what each line is doing).\nI realize this would take work, but without these changes, this test class is very hard to review.  I've taken 30mins to just check the first method looks correct (it does). But, I don't know how it differs from all the rest yet.  (And, at a glance many of these test methods look like they run the same check over and over again...for instance, each one keeps checking that User B cannot be deleted if they are the last member of the first step group... it seems like we only need to make that check once)", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r497086614", "createdAt": "2020-09-29T22:02:24Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/test/java/org/dspace/eperson/EPersonInWorkflowTest.java", "diffHunk": "@@ -0,0 +1,1477 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.eperson;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+import javax.servlet.http.HttpServletRequest;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.AbstractIntegrationTestWithDatabase;\n+import org.dspace.builder.CollectionBuilder;\n+import org.dspace.builder.CommunityBuilder;\n+import org.dspace.builder.EPersonBuilder;\n+import org.dspace.builder.WorkspaceItemBuilder;\n+import org.dspace.content.Collection;\n+import org.dspace.content.Community;\n+import org.dspace.content.WorkspaceItem;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.content.service.CollectionService;\n+import org.dspace.content.service.CommunityService;\n+import org.dspace.content.service.InstallItemService;\n+import org.dspace.content.service.ItemService;\n+import org.dspace.content.service.WorkspaceItemService;\n+import org.dspace.eperson.factory.EPersonServiceFactory;\n+import org.dspace.eperson.service.EPersonService;\n+import org.dspace.eperson.service.GroupService;\n+import org.dspace.workflow.WorkflowItemService;\n+import org.dspace.workflow.WorkflowService;\n+import org.dspace.workflow.factory.WorkflowServiceFactory;\n+import org.dspace.xmlworkflow.factory.XmlWorkflowServiceFactory;\n+import org.dspace.xmlworkflow.service.XmlWorkflowService;\n+import org.dspace.xmlworkflow.state.Workflow;\n+import org.dspace.xmlworkflow.storedcomponents.CollectionRole;\n+import org.dspace.xmlworkflow.storedcomponents.XmlWorkflowItem;\n+import org.dspace.xmlworkflow.storedcomponents.service.ClaimedTaskService;\n+import org.dspace.xmlworkflow.storedcomponents.service.CollectionRoleService;\n+import org.dspace.xmlworkflow.storedcomponents.service.PoolTaskService;\n+import org.dspace.xmlworkflow.storedcomponents.service.XmlWorkflowItemService;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.springframework.mock.web.MockHttpServletRequest;\n+\n+/**\n+ * Class to test interaction between EPerson deletion and tasks present in the workflow\n+ */\n+public class EPersonInWorkflowTest extends AbstractIntegrationTestWithDatabase {\n+\n+    private final String REVIEW_STEP = \"reviewstep\";\n+    private final String CLAIM_ACTION = \"claimaction\";\n+    private final String REVIEW_ACTION = \"reviewaction\";\n+    private final String REVIEW_ROLE = \"reviewer\";\n+    private final String EDIT_STEP = \"editstep\";\n+    private final String EDIT_ACTION = \"editaction\";\n+    private final String FINAL_EDIT_ROLE = \"finaleditor\";\n+    private final String FINAL_EDIT_STEP = \"finaleditstep\";\n+    private final String FINAL_EDIT_ACTION = \"finaleditaction\";\n+    private final String EDIT_ROLE = \"editor\";\n+    protected EPersonService ePersonService = EPersonServiceFactory.getInstance().getEPersonService();\n+    protected GroupService groupService = EPersonServiceFactory.getInstance().getGroupService();\n+    protected CommunityService communityService = ContentServiceFactory.getInstance().getCommunityService();\n+    protected CollectionService collectionService = ContentServiceFactory.getInstance().getCollectionService();\n+    protected ItemService itemService = ContentServiceFactory.getInstance().getItemService();\n+    protected InstallItemService installItemService = ContentServiceFactory.getInstance().getInstallItemService();\n+    protected WorkflowItemService workflowItemService = WorkflowServiceFactory.getInstance().getWorkflowItemService();\n+    protected XmlWorkflowItemService xmlWorkflowItemService = XmlWorkflowServiceFactory.getInstance()\n+                                                                                       .getXmlWorkflowItemService();\n+    protected WorkflowService workflowService = WorkflowServiceFactory.getInstance().getWorkflowService();\n+    protected WorkspaceItemService workspaceItemService = ContentServiceFactory.getInstance()\n+                                                                               .getWorkspaceItemService();\n+    protected ClaimedTaskService claimedTaskService = XmlWorkflowServiceFactory.getInstance().getClaimedTaskService();\n+    protected PoolTaskService poolTaskService = XmlWorkflowServiceFactory.getInstance().getPoolTaskService();\n+\n+    protected XmlWorkflowService xmlWorkflowService = XmlWorkflowServiceFactory.getInstance().getXmlWorkflowService();\n+    protected CollectionRoleService collectionRoleService = XmlWorkflowServiceFactory.getInstance()\n+                                                                                     .getCollectionRoleService();\n+\n+\n+    private EPerson workflowUserA;\n+    private EPerson workflowUserB;\n+    private EPerson workflowUserC;\n+    private EPerson workflowUserD;\n+\n+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(EPersonInWorkflowTest.class);\n+\n+    /**\n+     * This method will be run before every test as per @Before. It will\n+     * initialize resources required for the tests.\n+     *\n+     * Other methods can be annotated with @Before here or in subclasses but no\n+     * execution order is guaranteed\n+     */\n+    @Before\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+\n+        context.turnOffAuthorisationSystem();\n+\n+        workflowUserA = EPersonBuilder.createEPerson(context).withEmail(\"workflowUserA@example.org\").build();\n+        workflowUserB = EPersonBuilder.createEPerson(context).withEmail(\"workflowUserB@example.org\").build();\n+        workflowUserC = EPersonBuilder.createEPerson(context).withEmail(\"workflowUserC@example.org\").build();\n+        workflowUserD = EPersonBuilder.createEPerson(context).withEmail(\"workflowUserD@example.org\").build();\n+\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+\n+    /**\n+     * This test has the following setup:\n+     * - Step 1: user B\n+     * - Step 2: user C\n+     * - Step 3: user B\n+     *\n+     * This test will perform the following checks:\n+     * - create a workspace item, and let it move to step 1\n+     * - approve it by user B\n+     * - verify that the item moved to step 2\n+     * - Claim it by user C\n+     * - delete user B\n+     * - verify the delete is refused\n+     * - remove user B from step 3\n+     * - approve it by user C\n+     * - verify that the item is archived without any actions apart from removing user B\n+     * - delete user B\n+     * - verify the delete is refused\n+     * - remove user B from step 1\n+     * - delete user B\n+     * - verify the delete succeeds", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDI0MzgzMA=="}, "originalCommit": {"oid": "705b2b544f5106785e211a2999b4a6a32280f551"}, "originalPosition": 142}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9b169afd3544b31cec4298bb49d6459ac876519d", "author": {"user": {"login": "YanaDePauw", "name": "Yana De Pauw"}}, "url": "https://github.com/DSpace/DSpace/commit/9b169afd3544b31cec4298bb49d6459ac876519d", "committedDate": "2020-10-01T08:48:46Z", "message": "73783: Delete eperson: community feedback part 2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d5e28e8a7c5d207bba920193415dcc10c1caf0c4", "author": {"user": {"login": "YanaDePauw", "name": "Yana De Pauw"}}, "url": "https://github.com/DSpace/DSpace/commit/d5e28e8a7c5d207bba920193415dcc10c1caf0c4", "committedDate": "2020-10-01T08:49:10Z", "message": "Merge remote-tracking branch 'upstream/main' into w2p-72472_Delete-eperson"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNzQwNTEw", "url": "https://github.com/DSpace/DSpace/pull/2928#pullrequestreview-500740510", "createdAt": "2020-10-01T21:45:55Z", "commit": {"oid": "d5e28e8a7c5d207bba920193415dcc10c1caf0c4"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMTo0NTo1NlrOHbbzoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMTo1ODoyNVrOHbcFNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUyOTE4NQ==", "bodyText": "How does this differ from testDeleteUserWhenOnlyUserInGroup1()?  I'm not seeing clear differences in why we need a second test here & the description doesn't describe any differences...both methods are described identically as:  This test verifies that an EPerson cannot be removed if they are the only member of a Workflow Group that has tasks currently assigned to it. This test also verifies that after user has been removed from the workflow group and the task has been passed, the EPerson can be removed.\nIt's very hard to tell the differences between these methods, and (to me) it looks like we are running some of the same tests as in  testDeleteUserWhenOnlyUserInGroup1().  Duplicative tests are not really necessary, as they just take up more time (and will cause this overall Test class to take longer to complete/pass).  It's possible I'm misunderstanding the purpose of these test methods...but the purpose is just not clear to me as a reviewer, so I'm finding these test methods very difficult to review.\nThis same comment applies to all the other testDeleteUserWhenOnlyUserInGroup() tests below (numbered 2-7).  They all have had the exact same summary added to them, & the code is similar but not exactly the same.  So, I'd like to understand why they are all needed. Are there different scenarios here that you are trying to test are not causing a different behavior?  If so, we need to describe those different scenarios better in the comments, so that it's easier for reviewers to understand what they are attempting to test for.", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r498529185", "createdAt": "2020-10-01T21:45:56Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/test/java/org/dspace/eperson/EPersonInWorkflowTest.java", "diffHunk": "@@ -0,0 +1,1498 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.eperson;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+import javax.servlet.http.HttpServletRequest;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.AbstractIntegrationTestWithDatabase;\n+import org.dspace.builder.CollectionBuilder;\n+import org.dspace.builder.CommunityBuilder;\n+import org.dspace.builder.EPersonBuilder;\n+import org.dspace.builder.WorkspaceItemBuilder;\n+import org.dspace.content.Collection;\n+import org.dspace.content.Community;\n+import org.dspace.content.WorkspaceItem;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.content.service.CollectionService;\n+import org.dspace.content.service.CommunityService;\n+import org.dspace.content.service.InstallItemService;\n+import org.dspace.content.service.ItemService;\n+import org.dspace.content.service.WorkspaceItemService;\n+import org.dspace.eperson.factory.EPersonServiceFactory;\n+import org.dspace.eperson.service.EPersonService;\n+import org.dspace.eperson.service.GroupService;\n+import org.dspace.workflow.WorkflowItemService;\n+import org.dspace.workflow.WorkflowService;\n+import org.dspace.workflow.factory.WorkflowServiceFactory;\n+import org.dspace.xmlworkflow.factory.XmlWorkflowServiceFactory;\n+import org.dspace.xmlworkflow.service.XmlWorkflowService;\n+import org.dspace.xmlworkflow.state.Workflow;\n+import org.dspace.xmlworkflow.storedcomponents.CollectionRole;\n+import org.dspace.xmlworkflow.storedcomponents.XmlWorkflowItem;\n+import org.dspace.xmlworkflow.storedcomponents.service.ClaimedTaskService;\n+import org.dspace.xmlworkflow.storedcomponents.service.CollectionRoleService;\n+import org.dspace.xmlworkflow.storedcomponents.service.PoolTaskService;\n+import org.dspace.xmlworkflow.storedcomponents.service.XmlWorkflowItemService;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.springframework.mock.web.MockHttpServletRequest;\n+\n+/**\n+ * Class to test interaction between EPerson deletion and tasks present in the workflow\n+ */\n+public class EPersonInWorkflowTest extends AbstractIntegrationTestWithDatabase {\n+\n+    private final String REVIEW_STEP = \"reviewstep\";\n+    private final String CLAIM_ACTION = \"claimaction\";\n+    private final String REVIEW_ACTION = \"reviewaction\";\n+    private final String REVIEW_ROLE = \"reviewer\";\n+    private final String EDIT_STEP = \"editstep\";\n+    private final String EDIT_ACTION = \"editaction\";\n+    private final String FINAL_EDIT_ROLE = \"finaleditor\";\n+    private final String FINAL_EDIT_STEP = \"finaleditstep\";\n+    private final String FINAL_EDIT_ACTION = \"finaleditaction\";\n+    private final String EDIT_ROLE = \"editor\";\n+    protected EPersonService ePersonService = EPersonServiceFactory.getInstance().getEPersonService();\n+    protected GroupService groupService = EPersonServiceFactory.getInstance().getGroupService();\n+    protected CommunityService communityService = ContentServiceFactory.getInstance().getCommunityService();\n+    protected CollectionService collectionService = ContentServiceFactory.getInstance().getCollectionService();\n+    protected ItemService itemService = ContentServiceFactory.getInstance().getItemService();\n+    protected InstallItemService installItemService = ContentServiceFactory.getInstance().getInstallItemService();\n+    protected WorkflowItemService workflowItemService = WorkflowServiceFactory.getInstance().getWorkflowItemService();\n+    protected XmlWorkflowItemService xmlWorkflowItemService = XmlWorkflowServiceFactory.getInstance()\n+                                                                                       .getXmlWorkflowItemService();\n+    protected WorkflowService workflowService = WorkflowServiceFactory.getInstance().getWorkflowService();\n+    protected WorkspaceItemService workspaceItemService = ContentServiceFactory.getInstance()\n+                                                                               .getWorkspaceItemService();\n+    protected ClaimedTaskService claimedTaskService = XmlWorkflowServiceFactory.getInstance().getClaimedTaskService();\n+    protected PoolTaskService poolTaskService = XmlWorkflowServiceFactory.getInstance().getPoolTaskService();\n+\n+    protected XmlWorkflowService xmlWorkflowService = XmlWorkflowServiceFactory.getInstance().getXmlWorkflowService();\n+    protected CollectionRoleService collectionRoleService = XmlWorkflowServiceFactory.getInstance()\n+                                                                                     .getCollectionRoleService();\n+\n+\n+    private EPerson workflowUserA;\n+    private EPerson workflowUserB;\n+    private EPerson workflowUserC;\n+    private EPerson workflowUserD;\n+\n+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(EPersonInWorkflowTest.class);\n+\n+    /**\n+     * This method will be run before every test as per @Before. It will\n+     * initialize resources required for the tests.\n+     *\n+     * Other methods can be annotated with @Before here or in subclasses but no\n+     * execution order is guaranteed\n+     */\n+    @Before\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+\n+        context.turnOffAuthorisationSystem();\n+\n+        workflowUserA = EPersonBuilder.createEPerson(context).withEmail(\"workflowUserA@example.org\").build();\n+        workflowUserB = EPersonBuilder.createEPerson(context).withEmail(\"workflowUserB@example.org\").build();\n+        workflowUserC = EPersonBuilder.createEPerson(context).withEmail(\"workflowUserC@example.org\").build();\n+        workflowUserD = EPersonBuilder.createEPerson(context).withEmail(\"workflowUserD@example.org\").build();\n+\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+\n+    /**\n+     * This test verifies that an EPerson cannot be removed if they are the only member of a Workflow Group that has\n+     * tasks currently assigned to it. This test also verifies that after user has been removed from the workflow\n+     * group and the task has been passed, the EPerson can be removed.\n+     *\n+     * This test has the following setup:\n+     * - Step 1: user B\n+     * - Step 2: user C\n+     * - Step 3: user B\n+     *\n+     * This test will perform the following checks:\n+     * - create a workspace item, and let it move to step 1\n+     * - claim it by user B\n+     * - delete user B\n+     * - verify the delete is refused\n+     * - remove user B from step 1\n+     * - verify that the removal is refused due to B being the last member in the workflow group and the group having\n+     * a claimed item\n+     * - approve it by user B and let it move to step 2\n+     * - remove user B from step 3\n+     * - approve it by user C\n+     * - verify that the item is archived without any actions apart from removing user B\n+     * - delete user B\n+     * - verify the delete succeeds\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testDeleteUserWhenOnlyUserInGroup1() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        Community parent = CommunityBuilder.createCommunity(context).build();\n+        Collection collection = CollectionBuilder.createCollection(context, parent)\n+                                                 .withWorkflowGroup(1, workflowUserB)\n+                                                 .withWorkflowGroup(2, workflowUserC)\n+                                                 .withWorkflowGroup(3, workflowUserB)\n+                                                 .build();\n+\n+        WorkspaceItem wsi = WorkspaceItemBuilder.createWorkspaceItem(context, collection)\n+                                                .withSubmitter(workflowUserA)\n+                                                .withTitle(\"Test item full workflow\")\n+                                                .withIssueDate(\"2019-03-06\")\n+                                                .withSubject(\"ExtraEntry\")\n+                                                .build();\n+\n+        Workflow workflow = XmlWorkflowServiceFactory.getInstance().getWorkflowFactory().getWorkflow(collection);\n+\n+        XmlWorkflowItem workflowItem = xmlWorkflowService.startWithoutNotify(context, wsi);\n+        MockHttpServletRequest httpServletRequest = new MockHttpServletRequest();\n+        httpServletRequest.setParameter(\"submit_approve\", \"submit_approve\");\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, REVIEW_STEP, CLAIM_ACTION);\n+        assertRemovalOfEpersonFromWorkflowGroup(workflowUserB, collection, REVIEW_ROLE, false);\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, REVIEW_STEP, REVIEW_ACTION);\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserC, workflow, workflowItem, EDIT_STEP, CLAIM_ACTION);\n+\n+\n+        assertDeletionOfEperson(workflowUserB, false);\n+\n+        assertRemovalOfEpersonFromWorkflowGroup(workflowUserB, collection, FINAL_EDIT_ROLE, true);\n+        assertRemovalOfEpersonFromWorkflowGroup(workflowUserB, collection, REVIEW_ROLE, true);\n+\n+        assertDeletionOfEperson(workflowUserB, true);\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserC, workflow, workflowItem, EDIT_STEP, EDIT_ACTION);\n+\n+        assertTrue(workflowItem.getItem().isArchived());\n+\n+    }\n+\n+    /**\n+     * This test verifies that an EPerson cannot be removed if they are the only member of a Workflow Group that has\n+     * tasks currently assigned to it. This test also verifies that after user has been removed from the workflow\n+     * group and the task has been passed, the EPerson can be removed.\n+     *\n+     * This test has the following setup:\n+     * - Step 1: user B\n+     * - Step 2: user C\n+     * - Step 3: user B\n+     *\n+     * This test will perform the following checks:\n+     * - create a workspace item, and let it move to step 1\n+     * - delete user B\n+     * - verify the delete is refused\n+     * - remove user B from step 1\n+     * - verify that the removal is refused due to B being the last member in the workflow group and the group having a\n+     * pool task\n+     * - approve it by user B and let it move to step 2\n+     * - remove user B from step 3\n+     * - delete user B\n+     * - verify the delete succeeds\n+     * - Approve it by user C\n+     * - verify that the item is archived without any actions apart from the approving in step 2\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testDeleteUserWhenOnlyUserInGroup2() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5e28e8a7c5d207bba920193415dcc10c1caf0c4"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUzMzY4NQ==", "bodyText": "The same questions above apply to these methods.  I'm finding it hard to determine the differences between testDeleteUserAfterReplacingUser2() and testDeleteUserAfterReplacingUser1().  I can see the descriptions are identical & the setup is identical.  The steps seem like they are very similar but in a slightly different order.  And, why does this test need to verify that the Item can be archived after approvals occur? It seems like it that's beyond the scope of testing whether User B can be deleted after another user is added?\nSo, again, this is confusing to me to review as I'm not understanding what this test is attempting to test for that is different from the prior test.  It also seems like these tests are doing more than they need to, as I don't think they need to complete the entire workflow process (unless I'm misunderstanding the goals of these tests)\nThis same comment applies to the other tests named testDeleteUserAfterReplacingUser*() as they are all quite similar in nature.", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r498533685", "createdAt": "2020-10-01T21:58:25Z", "author": {"login": "tdonohue"}, "path": "dspace-api/src/test/java/org/dspace/eperson/EPersonInWorkflowTest.java", "diffHunk": "@@ -0,0 +1,1498 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.eperson;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+import javax.servlet.http.HttpServletRequest;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.AbstractIntegrationTestWithDatabase;\n+import org.dspace.builder.CollectionBuilder;\n+import org.dspace.builder.CommunityBuilder;\n+import org.dspace.builder.EPersonBuilder;\n+import org.dspace.builder.WorkspaceItemBuilder;\n+import org.dspace.content.Collection;\n+import org.dspace.content.Community;\n+import org.dspace.content.WorkspaceItem;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.content.service.CollectionService;\n+import org.dspace.content.service.CommunityService;\n+import org.dspace.content.service.InstallItemService;\n+import org.dspace.content.service.ItemService;\n+import org.dspace.content.service.WorkspaceItemService;\n+import org.dspace.eperson.factory.EPersonServiceFactory;\n+import org.dspace.eperson.service.EPersonService;\n+import org.dspace.eperson.service.GroupService;\n+import org.dspace.workflow.WorkflowItemService;\n+import org.dspace.workflow.WorkflowService;\n+import org.dspace.workflow.factory.WorkflowServiceFactory;\n+import org.dspace.xmlworkflow.factory.XmlWorkflowServiceFactory;\n+import org.dspace.xmlworkflow.service.XmlWorkflowService;\n+import org.dspace.xmlworkflow.state.Workflow;\n+import org.dspace.xmlworkflow.storedcomponents.CollectionRole;\n+import org.dspace.xmlworkflow.storedcomponents.XmlWorkflowItem;\n+import org.dspace.xmlworkflow.storedcomponents.service.ClaimedTaskService;\n+import org.dspace.xmlworkflow.storedcomponents.service.CollectionRoleService;\n+import org.dspace.xmlworkflow.storedcomponents.service.PoolTaskService;\n+import org.dspace.xmlworkflow.storedcomponents.service.XmlWorkflowItemService;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.springframework.mock.web.MockHttpServletRequest;\n+\n+/**\n+ * Class to test interaction between EPerson deletion and tasks present in the workflow\n+ */\n+public class EPersonInWorkflowTest extends AbstractIntegrationTestWithDatabase {\n+\n+    private final String REVIEW_STEP = \"reviewstep\";\n+    private final String CLAIM_ACTION = \"claimaction\";\n+    private final String REVIEW_ACTION = \"reviewaction\";\n+    private final String REVIEW_ROLE = \"reviewer\";\n+    private final String EDIT_STEP = \"editstep\";\n+    private final String EDIT_ACTION = \"editaction\";\n+    private final String FINAL_EDIT_ROLE = \"finaleditor\";\n+    private final String FINAL_EDIT_STEP = \"finaleditstep\";\n+    private final String FINAL_EDIT_ACTION = \"finaleditaction\";\n+    private final String EDIT_ROLE = \"editor\";\n+    protected EPersonService ePersonService = EPersonServiceFactory.getInstance().getEPersonService();\n+    protected GroupService groupService = EPersonServiceFactory.getInstance().getGroupService();\n+    protected CommunityService communityService = ContentServiceFactory.getInstance().getCommunityService();\n+    protected CollectionService collectionService = ContentServiceFactory.getInstance().getCollectionService();\n+    protected ItemService itemService = ContentServiceFactory.getInstance().getItemService();\n+    protected InstallItemService installItemService = ContentServiceFactory.getInstance().getInstallItemService();\n+    protected WorkflowItemService workflowItemService = WorkflowServiceFactory.getInstance().getWorkflowItemService();\n+    protected XmlWorkflowItemService xmlWorkflowItemService = XmlWorkflowServiceFactory.getInstance()\n+                                                                                       .getXmlWorkflowItemService();\n+    protected WorkflowService workflowService = WorkflowServiceFactory.getInstance().getWorkflowService();\n+    protected WorkspaceItemService workspaceItemService = ContentServiceFactory.getInstance()\n+                                                                               .getWorkspaceItemService();\n+    protected ClaimedTaskService claimedTaskService = XmlWorkflowServiceFactory.getInstance().getClaimedTaskService();\n+    protected PoolTaskService poolTaskService = XmlWorkflowServiceFactory.getInstance().getPoolTaskService();\n+\n+    protected XmlWorkflowService xmlWorkflowService = XmlWorkflowServiceFactory.getInstance().getXmlWorkflowService();\n+    protected CollectionRoleService collectionRoleService = XmlWorkflowServiceFactory.getInstance()\n+                                                                                     .getCollectionRoleService();\n+\n+\n+    private EPerson workflowUserA;\n+    private EPerson workflowUserB;\n+    private EPerson workflowUserC;\n+    private EPerson workflowUserD;\n+\n+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(EPersonInWorkflowTest.class);\n+\n+    /**\n+     * This method will be run before every test as per @Before. It will\n+     * initialize resources required for the tests.\n+     *\n+     * Other methods can be annotated with @Before here or in subclasses but no\n+     * execution order is guaranteed\n+     */\n+    @Before\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+\n+        context.turnOffAuthorisationSystem();\n+\n+        workflowUserA = EPersonBuilder.createEPerson(context).withEmail(\"workflowUserA@example.org\").build();\n+        workflowUserB = EPersonBuilder.createEPerson(context).withEmail(\"workflowUserB@example.org\").build();\n+        workflowUserC = EPersonBuilder.createEPerson(context).withEmail(\"workflowUserC@example.org\").build();\n+        workflowUserD = EPersonBuilder.createEPerson(context).withEmail(\"workflowUserD@example.org\").build();\n+\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+\n+    /**\n+     * This test verifies that an EPerson cannot be removed if they are the only member of a Workflow Group that has\n+     * tasks currently assigned to it. This test also verifies that after user has been removed from the workflow\n+     * group and the task has been passed, the EPerson can be removed.\n+     *\n+     * This test has the following setup:\n+     * - Step 1: user B\n+     * - Step 2: user C\n+     * - Step 3: user B\n+     *\n+     * This test will perform the following checks:\n+     * - create a workspace item, and let it move to step 1\n+     * - claim it by user B\n+     * - delete user B\n+     * - verify the delete is refused\n+     * - remove user B from step 1\n+     * - verify that the removal is refused due to B being the last member in the workflow group and the group having\n+     * a claimed item\n+     * - approve it by user B and let it move to step 2\n+     * - remove user B from step 3\n+     * - approve it by user C\n+     * - verify that the item is archived without any actions apart from removing user B\n+     * - delete user B\n+     * - verify the delete succeeds\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testDeleteUserWhenOnlyUserInGroup1() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        Community parent = CommunityBuilder.createCommunity(context).build();\n+        Collection collection = CollectionBuilder.createCollection(context, parent)\n+                                                 .withWorkflowGroup(1, workflowUserB)\n+                                                 .withWorkflowGroup(2, workflowUserC)\n+                                                 .withWorkflowGroup(3, workflowUserB)\n+                                                 .build();\n+\n+        WorkspaceItem wsi = WorkspaceItemBuilder.createWorkspaceItem(context, collection)\n+                                                .withSubmitter(workflowUserA)\n+                                                .withTitle(\"Test item full workflow\")\n+                                                .withIssueDate(\"2019-03-06\")\n+                                                .withSubject(\"ExtraEntry\")\n+                                                .build();\n+\n+        Workflow workflow = XmlWorkflowServiceFactory.getInstance().getWorkflowFactory().getWorkflow(collection);\n+\n+        XmlWorkflowItem workflowItem = xmlWorkflowService.startWithoutNotify(context, wsi);\n+        MockHttpServletRequest httpServletRequest = new MockHttpServletRequest();\n+        httpServletRequest.setParameter(\"submit_approve\", \"submit_approve\");\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, REVIEW_STEP, CLAIM_ACTION);\n+        assertRemovalOfEpersonFromWorkflowGroup(workflowUserB, collection, REVIEW_ROLE, false);\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, REVIEW_STEP, REVIEW_ACTION);\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserC, workflow, workflowItem, EDIT_STEP, CLAIM_ACTION);\n+\n+\n+        assertDeletionOfEperson(workflowUserB, false);\n+\n+        assertRemovalOfEpersonFromWorkflowGroup(workflowUserB, collection, FINAL_EDIT_ROLE, true);\n+        assertRemovalOfEpersonFromWorkflowGroup(workflowUserB, collection, REVIEW_ROLE, true);\n+\n+        assertDeletionOfEperson(workflowUserB, true);\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserC, workflow, workflowItem, EDIT_STEP, EDIT_ACTION);\n+\n+        assertTrue(workflowItem.getItem().isArchived());\n+\n+    }\n+\n+    /**\n+     * This test verifies that an EPerson cannot be removed if they are the only member of a Workflow Group that has\n+     * tasks currently assigned to it. This test also verifies that after user has been removed from the workflow\n+     * group and the task has been passed, the EPerson can be removed.\n+     *\n+     * This test has the following setup:\n+     * - Step 1: user B\n+     * - Step 2: user C\n+     * - Step 3: user B\n+     *\n+     * This test will perform the following checks:\n+     * - create a workspace item, and let it move to step 1\n+     * - delete user B\n+     * - verify the delete is refused\n+     * - remove user B from step 1\n+     * - verify that the removal is refused due to B being the last member in the workflow group and the group having a\n+     * pool task\n+     * - approve it by user B and let it move to step 2\n+     * - remove user B from step 3\n+     * - delete user B\n+     * - verify the delete succeeds\n+     * - Approve it by user C\n+     * - verify that the item is archived without any actions apart from the approving in step 2\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testDeleteUserWhenOnlyUserInGroup2() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        Community parent = CommunityBuilder.createCommunity(context).build();\n+        Collection collection = CollectionBuilder.createCollection(context, parent)\n+                                                 .withWorkflowGroup(1, workflowUserB)\n+                                                 .withWorkflowGroup(2, workflowUserC)\n+                                                 .withWorkflowGroup(3, workflowUserB)\n+                                                 .build();\n+\n+        WorkspaceItem wsi = WorkspaceItemBuilder.createWorkspaceItem(context, collection)\n+                                                .withSubmitter(workflowUserA)\n+                                                .withTitle(\"Test item full workflow\")\n+                                                .withIssueDate(\"2019-03-06\")\n+                                                .withSubject(\"ExtraEntry\")\n+                                                .build();\n+\n+        Workflow workflow = XmlWorkflowServiceFactory.getInstance().getWorkflowFactory().getWorkflow(collection);\n+\n+        XmlWorkflowItem workflowItem = xmlWorkflowService.startWithoutNotify(context, wsi);\n+        MockHttpServletRequest httpServletRequest = new MockHttpServletRequest();\n+        httpServletRequest.setParameter(\"submit_approve\", \"submit_approve\");\n+\n+        assertDeletionOfEperson(workflowUserB, false);\n+        assertRemovalOfEpersonFromWorkflowGroup(workflowUserB, collection, REVIEW_ROLE, false);\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, REVIEW_STEP, CLAIM_ACTION);\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, REVIEW_STEP, REVIEW_ACTION);\n+\n+        assertRemovalOfEpersonFromWorkflowGroup(workflowUserB, collection, REVIEW_ROLE, true);\n+        assertRemovalOfEpersonFromWorkflowGroup(workflowUserB, collection, \"finaleditor\", true);\n+\n+        assertDeletionOfEperson(workflowUserB, true);\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserC, workflow, workflowItem, EDIT_STEP, CLAIM_ACTION);\n+        executeWorkflowAction(httpServletRequest, workflowUserC, workflow, workflowItem, EDIT_STEP, EDIT_ACTION);\n+\n+        assertTrue(workflowItem.getItem().isArchived());\n+\n+    }\n+\n+\n+    /**\n+     * This test verifies that an EPerson cannot be removed if they are the only member of a Workflow Group that has\n+     * tasks currently assigned to it. This test also verifies that after user has been removed from the workflow\n+     * group and the task has been passed, the EPerson can be removed.\n+     *\n+     * This test has the following setup:\n+     * - Step 1: user B\n+     * - Step 2: user C\n+     * - Step 3: user B\n+     *\n+     * This test will perform the following checks:\n+     * - create a workspace item, and let it move to step 1\n+     * - delete user C\n+     * - verify the delete is refused\n+     * - remove user C from step 2\n+     * - delete user C\n+     * - verify the delete succeeds\n+     * - Approve it by user B\n+     * - verify that the item moved to step 3 without any actions apart from the approving in step 1\n+     * - Approve it by user B\n+     * - verify that the item is archived\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testDeleteUserWhenOnlyUserInGroup3() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        Community parent = CommunityBuilder.createCommunity(context).build();\n+        Collection collection = CollectionBuilder.createCollection(context, parent)\n+                                                 .withWorkflowGroup(1, workflowUserB)\n+                                                 .withWorkflowGroup(2, workflowUserC)\n+                                                 .withWorkflowGroup(3, workflowUserB)\n+                                                 .build();\n+\n+        WorkspaceItem wsi = WorkspaceItemBuilder.createWorkspaceItem(context, collection)\n+                                                .withSubmitter(workflowUserA)\n+                                                .withTitle(\"Test item full workflow\")\n+                                                .withIssueDate(\"2019-03-06\")\n+                                                .withSubject(\"ExtraEntry\")\n+                                                .build();\n+\n+        Workflow workflow = XmlWorkflowServiceFactory.getInstance().getWorkflowFactory().getWorkflow(collection);\n+\n+        XmlWorkflowItem workflowItem = xmlWorkflowService.startWithoutNotify(context, wsi);\n+        MockHttpServletRequest httpServletRequest = new MockHttpServletRequest();\n+        httpServletRequest.setParameter(\"submit_approve\", \"submit_approve\");\n+\n+        assertDeletionOfEperson(workflowUserC, false);\n+\n+        assertRemovalOfEpersonFromWorkflowGroup(workflowUserC, collection, EDIT_ROLE, true);\n+\n+        assertDeletionOfEperson(workflowUserC, true);\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, REVIEW_STEP, CLAIM_ACTION);\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, REVIEW_STEP, REVIEW_ACTION);\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, FINAL_EDIT_STEP,\n+                              CLAIM_ACTION);\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, FINAL_EDIT_STEP,\n+                              FINAL_EDIT_ACTION);\n+\n+        assertTrue(workflowItem.getItem().isArchived());\n+\n+    }\n+\n+    /**\n+     * This test verifies that an EPerson cannot be removed if they are the only member of a Workflow Group that has\n+     * tasks currently assigned to it. This test also verifies that after user has been removed from the workflow\n+     * group and the task has been passed, the EPerson can be removed.\n+     *\n+     * This test has the following setup:\n+     * - Step 1: user B\n+     * - Step 2: user C\n+     * - Step 3: user B\n+     *\n+     * This test will perform the following checks:\n+     * - create a workspace item, and let it move to step 1\n+     * - approve it by user B, and let it move to step 2\n+     * - approve it by user C, and let it move to step 3\n+     * - claim it by user B\n+     * - remove user B from step 1\n+     * - delete user B\n+     * - verify the delete is refused\n+     * - remove user B from step 3, verify that the removal is refused due to user B having a claimed task and there\n+     * being no other members in step 3\n+     * - approve it by user B\n+     * - delete user B\n+     * - verify the delete suceeds\n+     * - verify that the item is archived\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testDeleteUserWhenOnlyUserInGroup4() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        Community parent = CommunityBuilder.createCommunity(context).build();\n+        Collection collection = CollectionBuilder.createCollection(context, parent)\n+                                                 .withWorkflowGroup(1, workflowUserB)\n+                                                 .withWorkflowGroup(2, workflowUserC)\n+                                                 .withWorkflowGroup(3, workflowUserB)\n+                                                 .build();\n+\n+        WorkspaceItem wsi = WorkspaceItemBuilder.createWorkspaceItem(context, collection)\n+                                                .withSubmitter(workflowUserA)\n+                                                .withTitle(\"Test item full workflow\")\n+                                                .withIssueDate(\"2019-03-06\")\n+                                                .withSubject(\"ExtraEntry\")\n+                                                .build();\n+\n+        Workflow workflow = XmlWorkflowServiceFactory.getInstance().getWorkflowFactory().getWorkflow(collection);\n+\n+        XmlWorkflowItem workflowItem = xmlWorkflowService.startWithoutNotify(context, wsi);\n+        MockHttpServletRequest httpServletRequest = new MockHttpServletRequest();\n+        httpServletRequest.setParameter(\"submit_approve\", \"submit_approve\");\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, REVIEW_STEP, CLAIM_ACTION);\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, REVIEW_STEP, REVIEW_ACTION);\n+        executeWorkflowAction(httpServletRequest, workflowUserC, workflow, workflowItem, EDIT_STEP, CLAIM_ACTION);\n+        executeWorkflowAction(httpServletRequest, workflowUserC, workflow, workflowItem, EDIT_STEP, EDIT_ACTION);\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, FINAL_EDIT_STEP, CLAIM_ACTION);\n+\n+        assertDeletionOfEperson(workflowUserB, false);\n+        assertRemovalOfEpersonFromWorkflowGroup(workflowUserB, collection, REVIEW_ROLE, true);\n+        assertRemovalOfEpersonFromWorkflowGroup(workflowUserB, collection, FINAL_EDIT_ROLE, false);\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, FINAL_EDIT_STEP,\n+                              FINAL_EDIT_ACTION);\n+\n+        assertRemovalOfEpersonFromWorkflowGroup(workflowUserB, collection, FINAL_EDIT_ROLE, true);\n+        assertDeletionOfEperson(workflowUserB, true);\n+\n+        assertTrue(workflowItem.getItem().isArchived());\n+\n+    }\n+\n+    /**\n+     * This test verifies that an EPerson cannot be removed if they are the only member of a Workflow Group that has\n+     * tasks currently assigned to it. This test also verifies that after user has been removed from the workflow\n+     * group and the task has been passed, the EPerson can be removed.\n+     *\n+     * This test has the following setup:\n+     * - Collection A - Step 1: user B\n+     * - Collection A - Step 2: user C\n+     * - Collection A - Step 3: user B\n+     *\n+     * - Collection B - Step 1: user B\n+     *\n+     * This test will perform the following checks:\n+     * - create a workspace item in Collection A, and let it move to step 1\n+     * - claim it by user B\n+     * - delete user B\n+     * - verify the delete is refused\n+     * - remove user B from Col A - step 3\n+     * - remove user B from Col B - step 1\n+     * - remove user B from Col A - step 1\n+     * - Verify that the removal from Col A - step 1 is refused because user B has a claimed task in that collection and\n+     * no other user is present\n+     * - approve it by user B, and let it move to step 2\n+     * - remove user B from Col A - step 1\n+     * - verify it succeeds\n+     * - delete user B\n+     * - verify it succeeds\n+     * - approve it by user C\n+     * - verify that the item is archived\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testDeleteUserWhenOnlyUserInGroup5() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        Community parent = CommunityBuilder.createCommunity(context).build();\n+        Collection collectionA = CollectionBuilder.createCollection(context, parent)\n+                                                  .withWorkflowGroup(1, workflowUserB)\n+                                                  .withWorkflowGroup(2, workflowUserC)\n+                                                  .withWorkflowGroup(3, workflowUserB)\n+                                                  .build();\n+\n+        Collection collectionB = CollectionBuilder.createCollection(context, parent)\n+                                                  .withWorkflowGroup(1, workflowUserB)\n+                                                  .build();\n+\n+        WorkspaceItem wsi = WorkspaceItemBuilder.createWorkspaceItem(context, collectionA)\n+                                                .withSubmitter(workflowUserA)\n+                                                .withTitle(\"Test item full workflow\")\n+                                                .withIssueDate(\"2019-03-06\")\n+                                                .withSubject(\"ExtraEntry\")\n+                                                .build();\n+\n+        Workflow workflow = XmlWorkflowServiceFactory.getInstance().getWorkflowFactory().getWorkflow(collectionA);\n+\n+        XmlWorkflowItem workflowItem = xmlWorkflowService.startWithoutNotify(context, wsi);\n+        MockHttpServletRequest httpServletRequest = new MockHttpServletRequest();\n+        httpServletRequest.setParameter(\"submit_approve\", \"submit_approve\");\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, REVIEW_STEP, CLAIM_ACTION);\n+\n+        assertRemovalOfEpersonFromWorkflowGroup(workflowUserB, collectionA, FINAL_EDIT_ROLE, true);\n+        assertRemovalOfEpersonFromWorkflowGroup(workflowUserB, collectionB, REVIEW_ROLE, true);\n+        assertRemovalOfEpersonFromWorkflowGroup(workflowUserB, collectionA, REVIEW_ROLE, false);\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, REVIEW_STEP, REVIEW_ACTION);\n+\n+        assertRemovalOfEpersonFromWorkflowGroup(workflowUserB, collectionA, REVIEW_ROLE, true);\n+        assertDeletionOfEperson(workflowUserB, true);\n+\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserC, workflow, workflowItem, EDIT_STEP, CLAIM_ACTION);\n+        executeWorkflowAction(httpServletRequest, workflowUserC, workflow, workflowItem, EDIT_STEP, EDIT_ACTION);\n+\n+        assertTrue(workflowItem.getItem().isArchived());\n+\n+    }\n+\n+    /**\n+     * This test verifies that an EPerson cannot be removed if they are the only member of a Workflow Group that has\n+     * tasks currently assigned to it. This test also verifies that after user has been removed from the workflow\n+     * group and the task has been passed, the EPerson can be removed.\n+     *\n+     * This test has the following setup:\n+     * - Step 1: user B\n+     * - Step 2: user C\n+     * - Step 3: user B\n+     *\n+     * - create a workspace item, and let it move to step 1\n+     * - Approve it by user B\n+     * - verify that the item moved to step 2\n+     * - claim it by user C, but don\u2019t approve it\n+     * - delete user C\n+     * - verify the delete is refused\n+     * - remove user C from step 2\n+     * - delete user C\n+     * - verify the delete succeeds\n+     * - verify that the item moved to step 3 without any actions apart from deleting user C\n+     * - Approve it by user B\n+     * - verify that the item is archived\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testDeleteUserWhenOnlyUserInGroup6() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        Community parent = CommunityBuilder.createCommunity(context).build();\n+        Collection collection = CollectionBuilder.createCollection(context, parent)\n+                                                 .withWorkflowGroup(1, workflowUserB)\n+                                                 .withWorkflowGroup(2, workflowUserC)\n+                                                 .withWorkflowGroup(3, workflowUserB)\n+                                                 .build();\n+\n+        WorkspaceItem wsi = WorkspaceItemBuilder.createWorkspaceItem(context, collection)\n+                                                .withSubmitter(workflowUserA)\n+                                                .withTitle(\"Test item full workflow\")\n+                                                .withIssueDate(\"2019-03-06\")\n+                                                .withSubject(\"ExtraEntry\")\n+                                                .build();\n+\n+        Workflow workflow = XmlWorkflowServiceFactory.getInstance().getWorkflowFactory().getWorkflow(collection);\n+\n+        XmlWorkflowItem workflowItem = xmlWorkflowService.startWithoutNotify(context, wsi);\n+        MockHttpServletRequest httpServletRequest = new MockHttpServletRequest();\n+        httpServletRequest.setParameter(\"submit_approve\", \"submit_approve\");\n+\n+        assertDeletionOfEperson(workflowUserA, true);\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, REVIEW_STEP, CLAIM_ACTION);\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, REVIEW_STEP, REVIEW_ACTION);\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserC, workflow, workflowItem, EDIT_STEP, CLAIM_ACTION);\n+        executeWorkflowAction(httpServletRequest, workflowUserC, workflow, workflowItem, EDIT_STEP, EDIT_ACTION);\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, FINAL_EDIT_STEP, CLAIM_ACTION);\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, FINAL_EDIT_STEP,\n+                              FINAL_EDIT_ACTION);\n+\n+        assertTrue(workflowItem.getItem().isArchived());\n+\n+    }\n+\n+    /**\n+     * This test verifies that an EPerson cannot be removed if they are the only member of a Workflow Group that has\n+     * tasks currently assigned to it. This test also verifies that after user has been removed from the workflow\n+     * group and the task has been passed, the EPerson can be removed.\n+     *\n+     * This test has the following setup:\n+     * - Step 1: user B\n+     * - Step 2: user C\n+     * - Step 3: user B\n+     *\n+     * This test will perform the following checks:\n+     * - create a workspace item, and let it move to step 1\n+     * - delete user B\n+     * - verify the delete is refused\n+     * - remove user B from step 1\n+     * - verify the removal is refused\n+     * - remove user B from step 3\n+     * - verify the removal succeeds\n+     * - approve it by user B\n+     * - verify that the item moved to step 2\n+     * - remove user B from step 1\n+     * - delete user B\n+     * - verify the delete succeeds\n+     * - approve it by user C\n+     * - verify that the item is archived without any actions apart from removing user B\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testDeleteUserWhenOnlyUserInGroup7() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        Community parent = CommunityBuilder.createCommunity(context).build();\n+        Collection collection = CollectionBuilder.createCollection(context, parent)\n+                                                 .withWorkflowGroup(1, workflowUserB)\n+                                                 .withWorkflowGroup(2, workflowUserC)\n+                                                 .withWorkflowGroup(3, workflowUserB)\n+                                                 .build();\n+\n+        WorkspaceItem wsi = WorkspaceItemBuilder.createWorkspaceItem(context, collection)\n+                                                .withSubmitter(workflowUserA)\n+                                                .withTitle(\"Test item full workflow\")\n+                                                .withIssueDate(\"2019-03-06\")\n+                                                .withSubject(\"ExtraEntry\")\n+                                                .build();\n+\n+        Workflow workflow = XmlWorkflowServiceFactory.getInstance().getWorkflowFactory().getWorkflow(collection);\n+\n+        XmlWorkflowItem workflowItem = xmlWorkflowService.startWithoutNotify(context, wsi);\n+        MockHttpServletRequest httpServletRequest = new MockHttpServletRequest();\n+        httpServletRequest.setParameter(\"submit_approve\", \"submit_approve\");\n+\n+        assertDeletionOfEperson(workflowUserB, false);\n+        assertRemovalOfEpersonFromWorkflowGroup(workflowUserB, collection, REVIEW_ROLE, false);\n+        assertRemovalOfEpersonFromWorkflowGroup(workflowUserB, collection, FINAL_EDIT_ROLE, true);\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, REVIEW_STEP, CLAIM_ACTION);\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, REVIEW_STEP, REVIEW_ACTION);\n+\n+        assertRemovalOfEpersonFromWorkflowGroup(workflowUserB, collection, REVIEW_ROLE, true);\n+        assertDeletionOfEperson(workflowUserB, true);\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserC, workflow, workflowItem, EDIT_STEP, CLAIM_ACTION);\n+        executeWorkflowAction(httpServletRequest, workflowUserC, workflow, workflowItem, EDIT_STEP, EDIT_ACTION);\n+\n+        assertTrue(workflowItem.getItem().isArchived());\n+\n+    }\n+\n+\n+    /**\n+     * This test verifies that an EPerson cannot be removed if they are the only member of a Workflow Group that has\n+     * tasks currently assigned to it. This test also verifies that after another user has been added to the workflow\n+     * group, the EPerson can be removed.\n+     *\n+     * This test has the following setup:\n+     * - Step 1: user B\n+     * - Step 2: user C\n+     * - Step 3: user B\n+     *\n+     * This test will perform the following checks:\n+     * - create a workspace item, and let it move to step 1\n+     * - approve it by user B\n+     * - verify that the item moved to step 2\n+     * - Approve it by user C\n+     * - delete user B\n+     * - verify the delete is refused\n+     * - add user D to workflow step 3\n+     * - delete user B\n+     * - verify the delete is refused\n+     * - add user D to workflow step 1\n+     * - delete user B\n+     * - verify the delete succeeds\n+     * - Approve it by user D\n+     * - verify that the item is archived\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testDeleteUserAfterReplacingUser1() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        Community parent = CommunityBuilder.createCommunity(context).build();\n+        Collection collection = CollectionBuilder.createCollection(context, parent)\n+                                                 .withWorkflowGroup(1, workflowUserB)\n+                                                 .withWorkflowGroup(2, workflowUserC)\n+                                                 .withWorkflowGroup(3, workflowUserB)\n+                                                 .build();\n+\n+        WorkspaceItem wsi = WorkspaceItemBuilder.createWorkspaceItem(context, collection)\n+                                                .withSubmitter(workflowUserA)\n+                                                .withTitle(\"Test item full workflow\")\n+                                                .withIssueDate(\"2019-03-06\")\n+                                                .withSubject(\"ExtraEntry\")\n+                                                .build();\n+\n+        Workflow workflow = XmlWorkflowServiceFactory.getInstance().getWorkflowFactory().getWorkflow(collection);\n+\n+        XmlWorkflowItem workflowItem = xmlWorkflowService.startWithoutNotify(context, wsi);\n+        MockHttpServletRequest httpServletRequest = new MockHttpServletRequest();\n+        httpServletRequest.setParameter(\"submit_approve\", \"submit_approve\");\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, REVIEW_STEP, CLAIM_ACTION);\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, REVIEW_STEP, REVIEW_ACTION);\n+\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserC, workflow, workflowItem, EDIT_STEP, CLAIM_ACTION);\n+        executeWorkflowAction(httpServletRequest, workflowUserC, workflow, workflowItem, EDIT_STEP, EDIT_ACTION);\n+\n+        assertDeletionOfEperson(workflowUserB, false);\n+\n+        addUserToWorkflowGroup(workflowUserD, collection, FINAL_EDIT_ROLE);\n+        assertDeletionOfEperson(workflowUserB, false);\n+        addUserToWorkflowGroup(workflowUserD, collection, REVIEW_ROLE);\n+\n+        assertDeletionOfEperson(workflowUserB, true);\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserD, workflow, workflowItem, FINAL_EDIT_STEP, CLAIM_ACTION);\n+        executeWorkflowAction(httpServletRequest, workflowUserD, workflow, workflowItem, FINAL_EDIT_STEP,\n+                              FINAL_EDIT_ACTION);\n+\n+        assertTrue(workflowItem.getItem().isArchived());\n+\n+    }\n+\n+    /**\n+     * This test verifies that an EPerson cannot be removed if they are the only member of a Workflow Group that has\n+     * tasks currently assigned to it. This test also verifies that after another user has been added to the workflow\n+     * group, the EPerson can be removed.\n+     *\n+     * This test has the following setup:\n+     * - Step 1: user B\n+     * - Step 2: user C\n+     * - Step 3: user B\n+     *\n+     * This test will perform the following checks:\n+     * - create a workspace item, and let it move to step 1\n+     * - delete user B\n+     * - verify the delete is refused\n+     * - add user D to workflow step 1\n+     * - add user D to workflow step 3\n+     * - delete user B\n+     * - verify the delete succeeds\n+     * - Approve it by user D\n+     * - verify that the item moved to step 2\n+     * - Approve it by user C\n+     * - Approve it by user D\n+     * - verify that the item is archived\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testDeleteUserAfterReplacingUser2() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5e28e8a7c5d207bba920193415dcc10c1caf0c4"}, "originalPosition": 715}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMzA0Mzgw", "url": "https://github.com/DSpace/DSpace/pull/2928#pullrequestreview-501304380", "createdAt": "2020-10-02T17:05:58Z", "commit": {"oid": "d5e28e8a7c5d207bba920193415dcc10c1caf0c4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNzowNTo1OFrOHb1GTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNzowNTo1OFrOHb1GTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk0MzU2NA==", "bodyText": "If this class is an AbstractIntegrationTestWithDatabase then it is not a unit test and should be named EPersonInWorkflowIT.\nBeing an IT would help to explain why it runs so long.  Actually, as our ITs go, its execution is rather brief.", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r498943564", "createdAt": "2020-10-02T17:05:58Z", "author": {"login": "mwoodiupui"}, "path": "dspace-api/src/test/java/org/dspace/eperson/EPersonInWorkflowTest.java", "diffHunk": "@@ -0,0 +1,1498 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.eperson;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+import javax.servlet.http.HttpServletRequest;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.AbstractIntegrationTestWithDatabase;\n+import org.dspace.builder.CollectionBuilder;\n+import org.dspace.builder.CommunityBuilder;\n+import org.dspace.builder.EPersonBuilder;\n+import org.dspace.builder.WorkspaceItemBuilder;\n+import org.dspace.content.Collection;\n+import org.dspace.content.Community;\n+import org.dspace.content.WorkspaceItem;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.content.service.CollectionService;\n+import org.dspace.content.service.CommunityService;\n+import org.dspace.content.service.InstallItemService;\n+import org.dspace.content.service.ItemService;\n+import org.dspace.content.service.WorkspaceItemService;\n+import org.dspace.eperson.factory.EPersonServiceFactory;\n+import org.dspace.eperson.service.EPersonService;\n+import org.dspace.eperson.service.GroupService;\n+import org.dspace.workflow.WorkflowItemService;\n+import org.dspace.workflow.WorkflowService;\n+import org.dspace.workflow.factory.WorkflowServiceFactory;\n+import org.dspace.xmlworkflow.factory.XmlWorkflowServiceFactory;\n+import org.dspace.xmlworkflow.service.XmlWorkflowService;\n+import org.dspace.xmlworkflow.state.Workflow;\n+import org.dspace.xmlworkflow.storedcomponents.CollectionRole;\n+import org.dspace.xmlworkflow.storedcomponents.XmlWorkflowItem;\n+import org.dspace.xmlworkflow.storedcomponents.service.ClaimedTaskService;\n+import org.dspace.xmlworkflow.storedcomponents.service.CollectionRoleService;\n+import org.dspace.xmlworkflow.storedcomponents.service.PoolTaskService;\n+import org.dspace.xmlworkflow.storedcomponents.service.XmlWorkflowItemService;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.springframework.mock.web.MockHttpServletRequest;\n+\n+/**\n+ * Class to test interaction between EPerson deletion and tasks present in the workflow\n+ */\n+public class EPersonInWorkflowTest extends AbstractIntegrationTestWithDatabase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5e28e8a7c5d207bba920193415dcc10c1caf0c4"}, "originalPosition": 58}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d6046dc7ffa0e49ade99e8d39a6aecfb34e7432c", "author": {"user": {"login": "benbosman", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/d6046dc7ffa0e49ade99e8d39a6aecfb34e7432c", "committedDate": "2020-10-05T07:51:22Z", "message": "updated JavaDocs to explain the goal of the tests in more detail"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "01cc8560675059cc74838d914a3b965166f1bde5", "author": {"user": {"login": "benbosman", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/01cc8560675059cc74838d914a3b965166f1bde5", "committedDate": "2020-10-05T08:35:23Z", "message": "checkstyle"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyMjQ0NDUy", "url": "https://github.com/DSpace/DSpace/pull/2928#pullrequestreview-502244452", "createdAt": "2020-10-05T16:52:49Z", "commit": {"oid": "01cc8560675059cc74838d914a3b965166f1bde5"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4103b016ec100ba1fadfe36c979cf6cd2bc4a9bb", "author": {"user": {"login": "YanaDePauw", "name": "Yana De Pauw"}}, "url": "https://github.com/DSpace/DSpace/commit/4103b016ec100ba1fadfe36c979cf6cd2bc4a9bb", "committedDate": "2020-10-06T15:16:38Z", "message": "73977: Delete eperson: community feedback part 3"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzMTYyMDU1", "url": "https://github.com/DSpace/DSpace/pull/2928#pullrequestreview-503162055", "createdAt": "2020-10-06T16:43:28Z", "commit": {"oid": "4103b016ec100ba1fadfe36c979cf6cd2bc4a9bb"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNjo0MzoyOFrOHdQu3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNjo0MzoyOFrOHdQu3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ0NDg5NA==", "bodyText": "Minor thing.  This test seems to have an @Ignore.  Is there a reason for that?  If so, we should add a TODO comment here.\nAlso, I think this test may be incorrect.  In EPersonTest.testCascadingDeleteSubmitterPreservesWorkflowItems(), the test proves that a WorkflowItem is kept even if the Submitter is deleted.  This test seems to be trying to prove the opposite as the final line in this method is trying to prove that the WorkflowItem isNotFound() after the Submitter is deleted.  I suspect that last line should be changed to isOk(), as the WorkflowItem should still exist even if the Submitter is deleted.", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r500444894", "createdAt": "2020-10-06T16:43:28Z", "author": {"login": "tdonohue"}, "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/eperson/DeleteEPersonSubmitterIT.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.eperson;\n+\n+import static com.jayway.jsonpath.JsonPath.read;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.fail;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.delete;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.patch;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.ws.rs.core.MediaType;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.requestitem.RequestItemAuthor;\n+import org.dspace.app.requestitem.RequestItemAuthorExtractor;\n+import org.dspace.app.rest.model.patch.Operation;\n+import org.dspace.app.rest.model.patch.ReplaceOperation;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.builder.CollectionBuilder;\n+import org.dspace.builder.CommunityBuilder;\n+import org.dspace.builder.EPersonBuilder;\n+import org.dspace.builder.WorkspaceItemBuilder;\n+import org.dspace.content.Collection;\n+import org.dspace.content.Community;\n+import org.dspace.content.Item;\n+import org.dspace.content.WorkspaceItem;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.content.service.InstallItemService;\n+import org.dspace.content.service.ItemService;\n+import org.dspace.content.service.WorkspaceItemService;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.factory.EPersonServiceFactory;\n+import org.dspace.eperson.service.EPersonService;\n+import org.dspace.services.factory.DSpaceServicesFactory;\n+import org.dspace.versioning.Version;\n+import org.dspace.versioning.factory.VersionServiceFactory;\n+import org.dspace.versioning.service.VersioningService;\n+import org.dspace.xmlworkflow.factory.XmlWorkflowServiceFactory;\n+import org.dspace.xmlworkflow.service.XmlWorkflowService;\n+import org.dspace.xmlworkflow.storedcomponents.XmlWorkflowItem;\n+import org.hamcrest.Matchers;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n+/**\n+ * Class to test interaction between EPerson deletion and tasks present in the workflow\n+ */\n+public class DeleteEPersonSubmitterIT extends AbstractControllerIntegrationTest {\n+\n+    protected EPersonService ePersonService = EPersonServiceFactory.getInstance().getEPersonService();\n+    protected ItemService itemService = ContentServiceFactory.getInstance().getItemService();\n+    protected InstallItemService installItemService = ContentServiceFactory.getInstance().getInstallItemService();\n+    protected WorkspaceItemService workspaceItemService = ContentServiceFactory.getInstance()\n+                                                                               .getWorkspaceItemService();\n+    protected XmlWorkflowService xmlWorkflowService = XmlWorkflowServiceFactory.getInstance().getXmlWorkflowService();\n+    protected VersioningService versioningService = VersionServiceFactory.getInstance().getVersionService();\n+\n+    protected RequestItemAuthorExtractor requestItemAuthorExtractor =\n+            DSpaceServicesFactory.getInstance()\n+                                 .getServiceManager()\n+                                 .getServiceByName(\"org.dspace.app.requestitem.RequestItemAuthorExtractor\",\n+                                         RequestItemAuthorExtractor.class);\n+\n+\n+    private EPerson submitter;\n+    private EPerson submitterForVersion1;\n+    private EPerson submitterForVersion2;\n+    private EPerson workflowUser;\n+\n+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(DeleteEPersonSubmitterIT.class);\n+\n+    /**\n+     * This method will be run before every test as per @Before. It will\n+     * initialize resources required for the tests.\n+     *\n+     * Other methods can be annotated with @Before here or in subclasses but no\n+     * execution order is guaranteed\n+     */\n+    @Before\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+\n+        context.turnOffAuthorisationSystem();\n+\n+        submitter = EPersonBuilder.createEPerson(context).withEmail(\"submitter@example.org\").build();\n+        workflowUser = EPersonBuilder.createEPerson(context).withEmail(\"workflowUser@example.org\").build();\n+        submitterForVersion1 = EPersonBuilder.createEPerson(context).withEmail(\"submitterForVersion1@example.org\")\n+                                             .build();\n+        submitterForVersion2 = EPersonBuilder.createEPerson(context).withEmail(\"submitterForVersion2@example.org\")\n+                                             .build();\n+\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+\n+    /**\n+     * This test verifies that when the submitter Eperson is deleted, the delete succeeds and the item will have\n+     * 'null' as submitter\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testArchivedItemSubmitterDelete() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        Community parent = CommunityBuilder.createCommunity(context).build();\n+        Collection collection = CollectionBuilder.createCollection(context, parent)\n+                                                 .build();\n+\n+        WorkspaceItem wsi = WorkspaceItemBuilder.createWorkspaceItem(context, collection)\n+                                                .withSubmitter(submitter)\n+                                                .withTitle(\"Test Item\")\n+                                                .withIssueDate(\"2019-03-06\")\n+                                                .withSubject(\"ExtraEntry\")\n+                                                .build();\n+\n+        Item installItem = installItemService.installItem(context, wsi);\n+\n+        assertDeletionOfEperson(submitter);\n+\n+        assertNull(retrieveItemSubmitter(installItem.getID()));\n+\n+\n+        Item item = itemService.find(context, installItem.getID());\n+        RequestItemAuthor requestItemAuthor = requestItemAuthorExtractor.getRequestItemAuthor(context, item);\n+\n+        assertEquals(\"Help Desk\", requestItemAuthor.getFullName());\n+        assertEquals(\"dspace-help@myu.edu\", requestItemAuthor.getEmail());\n+    }\n+\n+    /**\n+     * This test verifies that when the submitter Eperson is deleted, the delete succeeds and the item will have\n+     * 'null' as submitter\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testWIthdrawnItemSubmitterDelete() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        Community parent = CommunityBuilder.createCommunity(context).build();\n+        Collection collection = CollectionBuilder.createCollection(context, parent)\n+                                                 .build();\n+\n+        WorkspaceItem wsi = WorkspaceItemBuilder.createWorkspaceItem(context, collection)\n+                                                .withSubmitter(submitter)\n+                                                .withTitle(\"Test Item\")\n+                                                .withIssueDate(\"2019-03-06\")\n+                                                .withSubject(\"ExtraEntry\")\n+                                                .build();\n+\n+        Item item = installItemService.installItem(context, wsi);\n+\n+        List<Operation> opsToWithDraw = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperationToWithDraw = new ReplaceOperation(\"/withdrawn\", true);\n+        opsToWithDraw.add(replaceOperationToWithDraw);\n+        String patchBodyToWithdraw = getPatchContent(opsToWithDraw);\n+\n+        // withdraw item\n+        String token = getAuthToken(admin.getEmail(), password);\n+        getClient(token).perform(patch(\"/api/core/items/\" + item.getID())\n+                                         .content(patchBodyToWithdraw)\n+                                         .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))\n+                        .andExpect(status().isOk())\n+                        .andExpect(jsonPath(\"$.uuid\", Matchers.is(item.getID().toString())))\n+                        .andExpect(jsonPath(\"$.withdrawn\", Matchers.is(true)))\n+                        .andExpect(jsonPath(\"$.inArchive\", Matchers.is(false)));\n+\n+\n+        assertDeletionOfEperson(submitter);\n+\n+        assertNull(retrieveItemSubmitter(item.getID()));\n+\n+        List<Operation> opsToReinstate = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperationToReinstate = new ReplaceOperation(\"/withdrawn\", false);\n+        opsToReinstate.add(replaceOperationToReinstate);\n+        String patchBodyToReinstate = getPatchContent(opsToReinstate);\n+\n+        // reinstate item\n+        getClient(token).perform(patch(\"/api/core/items/\" + item.getID())\n+                                         .content(patchBodyToReinstate)\n+                                         .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))\n+                        .andExpect(status().isOk())\n+                        .andExpect(jsonPath(\"$.uuid\", Matchers.is(item.getID().toString())))\n+                        .andExpect(jsonPath(\"$.withdrawn\", Matchers.is(false)))\n+                        .andExpect(jsonPath(\"$.inArchive\", Matchers.is(true)));\n+\n+        assertNull(retrieveItemSubmitter(item.getID()));\n+\n+\n+        // withdraw item again\n+        getClient(token).perform(patch(\"/api/core/items/\" + item.getID())\n+                                         .content(patchBodyToWithdraw)\n+                                         .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))\n+                        .andExpect(status().isOk())\n+                        .andExpect(jsonPath(\"$.uuid\", Matchers.is(item.getID().toString())))\n+                        .andExpect(jsonPath(\"$.withdrawn\", Matchers.is(true)))\n+                        .andExpect(jsonPath(\"$.inArchive\", Matchers.is(false)));\n+\n+        assertNull(retrieveItemSubmitter(item.getID()));\n+\n+    }\n+\n+    @Test\n+    public void testVersionItemSubmitterDelete() throws Exception {\n+        String token = getAuthToken(admin.getEmail(), password);\n+\n+        context.turnOffAuthorisationSystem();\n+\n+        Community parent = CommunityBuilder.createCommunity(context).build();\n+        Collection collection = CollectionBuilder.createCollection(context, parent)\n+                                                 .build();\n+\n+        WorkspaceItem wsi = WorkspaceItemBuilder.createWorkspaceItem(context, collection)\n+                                                .withSubmitter(submitter)\n+                                                .withTitle(\"Test Item\")\n+                                                .withIssueDate(\"2019-03-06\")\n+                                                .withSubject(\"ExtraEntry\")\n+                                                .build();\n+\n+        Item item = installItemService.installItem(context, wsi);\n+\n+        context.setCurrentUser(submitter);\n+        //TODO: Replace this with a REST call when possible\n+        Version version1 = versioningService.createNewVersion(context, item);\n+        Integer version1ID = version1.getID();\n+        WorkspaceItem version1WorkspaceItem = workspaceItemService.findByItem(context, version1.getItem());\n+        installItemService.installItem(context, version1WorkspaceItem);\n+\n+        assertDeletionOfEperson(submitter);\n+        assertNull(retrieveItemSubmitter(item.getID()));\n+\n+        Item version1Item = retrieveVersionItem(version1ID);\n+        assertNull(retrieveItemSubmitter(version1Item.getID()));\n+\n+\n+        context.setCurrentUser(submitterForVersion1);\n+\n+        Version version2 = versioningService.createNewVersion(context, item);\n+        Integer version2ID = version2.getID();\n+        WorkspaceItem version2WorkspaceItem = workspaceItemService.findByItem(context, version2.getItem());\n+        installItemService.installItem(context, version2WorkspaceItem);\n+        Item version2Item = retrieveVersionItem(version2ID);\n+        assertEquals(submitterForVersion1.getID(), retrieveItemSubmitter(version2Item.getID()).getID());\n+\n+        context.setCurrentUser(submitterForVersion2);\n+        Version version3 = versioningService.createNewVersion(context, version2Item);\n+        Integer version3ID = version3.getID();\n+        assertDeletionOfEperson(submitterForVersion2);\n+\n+        getClient(token).perform(get(\"/api/versioning/versions/\" + version3ID + \"/item\"))\n+                        .andExpect(status().isNoContent());\n+\n+\n+        // Clean up versions\n+        cleanupVersion(version1ID);\n+        cleanupVersion(version2ID);\n+        cleanupVersion(version3ID);\n+\n+    }\n+\n+\n+    @Test\n+    public void testWorkspaceItemSubmitterDelete() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        Community parent = CommunityBuilder.createCommunity(context).build();\n+        Collection collection = CollectionBuilder.createCollection(context, parent)\n+                                                 .build();\n+\n+        WorkspaceItem wsi = WorkspaceItemBuilder.createWorkspaceItem(context, collection)\n+                                                .withSubmitter(submitter)\n+                                                .withTitle(\"Test Item\")\n+                                                .withIssueDate(\"2019-03-06\")\n+                                                .withSubject(\"ExtraEntry\")\n+                                                .build();\n+\n+\n+        String token = getAuthToken(admin.getEmail(), password);\n+        getClient(token).perform(get(\"/api/submission/workspaceitems/\" + wsi.getID()))\n+                        .andExpect(status().isOk());\n+\n+        assertDeletionOfEperson(submitter);\n+\n+        getClient(token).perform(get(\"/api/submission/workspaceitems/\" + wsi.getID()))\n+                        .andExpect(status().isNotFound());\n+    }\n+\n+    @Ignore\n+    @Test\n+    public void testWorkflowItemSubmitterDelete() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4103b016ec100ba1fadfe36c979cf6cd2bc4a9bb"}, "originalPosition": 308}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ae42397bf8ee8ab24201c3ef824c8d99e49306b", "author": {"user": {"login": "benbosman", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/9ae42397bf8ee8ab24201c3ef824c8d99e49306b", "committedDate": "2020-10-07T07:52:21Z", "message": "add TODO message"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "9ae42397bf8ee8ab24201c3ef824c8d99e49306b", "author": {"user": {"login": "benbosman", "name": null}}, "url": "https://github.com/DSpace/DSpace/commit/9ae42397bf8ee8ab24201c3ef824c8d99e49306b", "committedDate": "2020-10-07T07:52:21Z", "message": "add TODO message"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNjQ2NTkz", "url": "https://github.com/DSpace/DSpace/pull/2928#pullrequestreview-501646593", "createdAt": "2020-10-04T18:15:07Z", "commit": {"oid": "d5e28e8a7c5d207bba920193415dcc10c1caf0c4"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxODoxNTowN1rOHcJPVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwNjoxNzo0OFrOHePb-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI3MzU1OA==", "bodyText": "nothing serious, basic javadoc is missing", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r499273558", "createdAt": "2020-10-04T18:15:07Z", "author": {"login": "abollini"}, "path": "dspace-api/src/main/java/org/dspace/authorize/dao/ResourcePolicyDAO.java", "diffHunk": "@@ -33,6 +33,8 @@\n     public List<ResourcePolicy> findByDsoAndType(Context context, DSpaceObject dSpaceObject, String type)\n         throws SQLException;\n \n+    public List<ResourcePolicy> findByEPerson(Context context, EPerson ePerson) throws SQLException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5e28e8a7c5d207bba920193415dcc10c1caf0c4"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ2OTkzMw==", "bodyText": "this seems to be not fully accurate. In the code below there are scenario where the EPersonDeletionException is thrown directly (btw it should be also added to the list of throws in the javadoc) and in another case it is wrapped inside an IllegalArgumentException. Can we always return it directly? any reason to wrap it in another exception?", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r501469933", "createdAt": "2020-10-08T06:11:23Z", "author": {"login": "abollini"}, "path": "dspace-api/src/main/java/org/dspace/eperson/EPersonServiceImpl.java", "diffHunk": "@@ -179,45 +222,202 @@ public EPerson create(Context context) throws SQLException, AuthorizeException {\n         // authorized?\n         if (!authorizeService.isAdmin(context)) {\n             throw new AuthorizeException(\n-                \"You must be an admin to create an EPerson\");\n+                    \"You must be an admin to create an EPerson\");\n         }\n \n         // Create a table row\n         EPerson e = ePersonDAO.create(context, new EPerson());\n \n         log.info(LogManager.getHeader(context, \"create_eperson\", \"eperson_id=\"\n-            + e.getID()));\n+                + e.getID()));\n \n         context.addEvent(new Event(Event.CREATE, Constants.EPERSON, e.getID(),\n-                                   null, getIdentifiers(context, e)));\n+                null, getIdentifiers(context, e)));\n \n         return e;\n     }\n \n     @Override\n     public void delete(Context context, EPerson ePerson) throws SQLException, AuthorizeException {\n+        try {\n+            delete(context, ePerson, true);\n+        } catch (AuthorizeException ex) {\n+            log.error(\"This AuthorizeException: \" + ex + \" occured while deleting Eperson with the ID: \" +\n+                      ePerson.getID());\n+            throw new AuthorizeException(ex);\n+        } catch (IOException ex) {\n+            log.error(\"This IOException: \" + ex + \" occured while deleting Eperson with the ID: \" + ePerson.getID());\n+            throw new AuthorizeException(ex);\n+        } catch (EPersonDeletionException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    /**\n+     * Deletes an EPerson. The argument cascade defines whether all references\n+     * on an EPerson should be deleted as well (by either deleting the\n+     * referencing object - e.g. WorkspaceItem, ResourcePolicy - or by setting\n+     * the foreign key null - e.g. archived Items). If cascade is set to false\n+     * and the EPerson is referenced somewhere, this leads to an\n+     * AuthorizeException. EPersons may be referenced by Items, ResourcePolicies", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ae42397bf8ee8ab24201c3ef824c8d99e49306b"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ3MjI1MQ==", "bodyText": "The basic workflow must be removed in dspace 7 as we switched to the configurable workflow and this cannot be reverted... anyway as the basic workflow code is still here I looked to this code as well\nI doubt that this code is never executed. It could stay to deal with inconsistent data but it would be useful to add a note in the comment to say that the claimed tasks are normally processed by the code in the previous if (L377-L388) and turned into pool tasks)", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r501472251", "createdAt": "2020-10-08T06:17:48Z", "author": {"login": "abollini"}, "path": "dspace-api/src/main/java/org/dspace/eperson/EPersonServiceImpl.java", "diffHunk": "@@ -179,45 +222,202 @@ public EPerson create(Context context) throws SQLException, AuthorizeException {\n         // authorized?\n         if (!authorizeService.isAdmin(context)) {\n             throw new AuthorizeException(\n-                \"You must be an admin to create an EPerson\");\n+                    \"You must be an admin to create an EPerson\");\n         }\n \n         // Create a table row\n         EPerson e = ePersonDAO.create(context, new EPerson());\n \n         log.info(LogManager.getHeader(context, \"create_eperson\", \"eperson_id=\"\n-            + e.getID()));\n+                + e.getID()));\n \n         context.addEvent(new Event(Event.CREATE, Constants.EPERSON, e.getID(),\n-                                   null, getIdentifiers(context, e)));\n+                null, getIdentifiers(context, e)));\n \n         return e;\n     }\n \n     @Override\n     public void delete(Context context, EPerson ePerson) throws SQLException, AuthorizeException {\n+        try {\n+            delete(context, ePerson, true);\n+        } catch (AuthorizeException ex) {\n+            log.error(\"This AuthorizeException: \" + ex + \" occured while deleting Eperson with the ID: \" +\n+                      ePerson.getID());\n+            throw new AuthorizeException(ex);\n+        } catch (IOException ex) {\n+            log.error(\"This IOException: \" + ex + \" occured while deleting Eperson with the ID: \" + ePerson.getID());\n+            throw new AuthorizeException(ex);\n+        } catch (EPersonDeletionException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    /**\n+     * Deletes an EPerson. The argument cascade defines whether all references\n+     * on an EPerson should be deleted as well (by either deleting the\n+     * referencing object - e.g. WorkspaceItem, ResourcePolicy - or by setting\n+     * the foreign key null - e.g. archived Items). If cascade is set to false\n+     * and the EPerson is referenced somewhere, this leads to an\n+     * AuthorizeException. EPersons may be referenced by Items, ResourcePolicies\n+     * and workflow tasks.\n+     *\n+     * @param context DSpace context\n+     * @param ePerson The EPerson to delete.\n+     * @param cascade Whether to delete references on the EPerson (cascade =\n+     * true) or to abort the deletion (cascade = false) if the EPerson is\n+     * referenced within DSpace.\n+     *\n+     * @throws SQLException\n+     * @throws AuthorizeException\n+     * @throws IOException\n+     */\n+    public void delete(Context context, EPerson ePerson, boolean cascade)\n+            throws SQLException, AuthorizeException, IOException, EPersonDeletionException {\n         // authorized?\n         if (!authorizeService.isAdmin(context)) {\n             throw new AuthorizeException(\n-                \"You must be an admin to delete an EPerson\");\n+                    \"You must be an admin to delete an EPerson\");\n+        }\n+        Set<Group> workFlowGroups = getAllWorkFlowGroups(context, ePerson);\n+        for (Group group: workFlowGroups) {\n+            List<EPerson> ePeople = groupService.allMembers(context, group);\n+            if (ePeople.size() == 1 && ePeople.contains(ePerson)) {\n+                throw new IllegalStateException(\n+                    \"Refused to delete user \" + ePerson.getID() + \" because it the only member of the workflow group\"\n+                    + group.getID() + \". Delete the tasks and group first if you want to remove this user.\");\n+            }\n         }\n-\n         // check for presence of eperson in tables that\n         // have constraints on eperson_id\n         List<String> constraintList = getDeleteConstraints(context, ePerson);\n-\n-        // if eperson exists in tables that have constraints\n-        // on eperson, throw an exception\n         if (constraintList.size() > 0) {\n-            throw new AuthorizeException(new EPersonDeletionException(constraintList));\n+            // Check if the constraints we found should be deleted\n+            if (cascade) {\n+                boolean isBasicFramework = WorkflowServiceFactory.getInstance().getWorkflowService()\n+                                           instanceof BasicWorkflowService;\n+                boolean isXmlFramework = WorkflowServiceFactory.getInstance().getWorkflowService()\n+                                         instanceof XmlWorkflowService;\n+                Iterator<String> constraintsIterator = constraintList.iterator();\n+\n+                while (constraintsIterator.hasNext()) {\n+                    String tableName = constraintsIterator.next();\n+                    if (StringUtils.equals(tableName, \"item\") || StringUtils.equals(tableName, \"workspaceitem\")) {\n+                        Iterator<Item> itemIterator = itemService.findBySubmitter(context, ePerson, true);\n+\n+                        VersionHistoryService versionHistoryService = VersionServiceFactory.getInstance()\n+                                                                      .getVersionHistoryService();\n+                        VersioningService versioningService = VersionServiceFactory.getInstance().getVersionService();\n+\n+                        while (itemIterator.hasNext()) {\n+                            Item item = itemIterator.next();\n+\n+                            VersionHistory versionHistory = versionHistoryService.findByItem(context, item);\n+                            if (null != versionHistory) {\n+                                for (Version version : versioningService.getVersionsByHistory(context,\n+                                                                                              versionHistory)) {\n+                                    version.setePerson(null);\n+                                    versionDAO.save(context, version);\n+                                }\n+                            }\n+                            WorkspaceItemService workspaceItemService = ContentServiceFactory.getInstance()\n+                                                                        .getWorkspaceItemService();\n+                            WorkspaceItem wsi = workspaceItemService.findByItem(context, item);\n+\n+                            if (null != wsi) {\n+                                workspaceItemService.deleteAll(context, wsi);\n+                            } else {\n+                                // we can do that as dc.provenance still contains\n+                                // information about who submitted and who\n+                                // archived an item.\n+                                item.setSubmitter(null);\n+                                itemService.update(context, item);\n+                            }\n+                        }\n+                    } else if (StringUtils.equals(tableName, \"cwf_claimtask\") && isXmlFramework) {\n+                         // Unclaim all XmlWorkflow tasks\n+                        XmlWorkflowItemService xmlWorkflowItemService = XmlWorkflowServiceFactory\n+                                                                        .getInstance().getXmlWorkflowItemService();\n+                        ClaimedTaskService claimedTaskService = XmlWorkflowServiceFactory\n+                                                                .getInstance().getClaimedTaskService();\n+                        XmlWorkflowService xmlWorkflowService = XmlWorkflowServiceFactory\n+                                                                .getInstance().getXmlWorkflowService();\n+                        WorkflowRequirementsService workflowRequirementsService = XmlWorkflowServiceFactory\n+                                                                       .getInstance().getWorkflowRequirementsService();\n+\n+                        List<XmlWorkflowItem> xmlWorkflowItems = xmlWorkflowItemService\n+                                                                 .findBySubmitter(context, ePerson);\n+                        List<ClaimedTask> claimedTasks = claimedTaskService.findByEperson(context, ePerson);\n+\n+                        for (ClaimedTask task : claimedTasks) {\n+                            xmlWorkflowService.deleteClaimedTask(context, task.getWorkflowItem(), task);\n+\n+                            try {\n+                                workflowRequirementsService.removeClaimedUser(context, task.getWorkflowItem(),\n+                                                                              ePerson, task.getStepID());\n+                            } catch (WorkflowConfigurationException ex) {\n+                                log.error(\"This WorkflowConfigurationException: \" + ex +\n+                                          \" occured while deleting Eperson with the ID: \" + ePerson.getID());\n+                                throw new AuthorizeException(new EPersonDeletionException(Collections\n+                                                                                          .singletonList(tableName)));\n+                            }\n+                        }\n+                    } else if (StringUtils.equals(tableName, \"workflowitem\") && isBasicFramework) {\n+                        // Remove basicWorkflow workflowitem and unclaim them\n+                        BasicWorkflowItemService basicWorkflowItemService = BasicWorkflowServiceFactory.getInstance()\n+                                                                            .getBasicWorkflowItemService();\n+                        BasicWorkflowService basicWorkflowService = BasicWorkflowServiceFactory.getInstance()\n+                                                                    .getBasicWorkflowService();\n+                        TaskListItemService taskListItemService = BasicWorkflowServiceFactory.getInstance()\n+                                                                  .getTaskListItemService();\n+                        List<BasicWorkflowItem> workflowItems = basicWorkflowItemService.findByOwner(context, ePerson);\n+                        for (BasicWorkflowItem workflowItem : workflowItems) {\n+                            int state = workflowItem.getState();\n+                            // unclaim tasks that are in the pool.\n+                            if (state == BasicWorkflowServiceImpl.WFSTATE_STEP1\n+                                    || state == BasicWorkflowServiceImpl.WFSTATE_STEP2\n+                                    || state == BasicWorkflowServiceImpl.WFSTATE_STEP3) {\n+                                log.info(LogManager.getHeader(context, \"unclaim_workflow\",\n+                                        \"workflow_id=\" + workflowItem.getID() + \", claiming EPerson is deleted\"));\n+                                basicWorkflowService.unclaim(context, workflowItem, context.getCurrentUser());\n+                                // remove the EPerson from the list of persons that can (re-)claim the task\n+                                // while we are doing it below, we must do this here as well as the previously\n+                                // unclaimed tasks was put back into pool and we do not know the order the tables\n+                                // are checked.\n+                                taskListItemService.deleteByWorkflowItemAndEPerson(context, workflowItem, ePerson);\n+                            }\n+                        }\n+                    } else if (StringUtils.equals(tableName, \"resourcepolicy\")) {\n+                        // we delete the EPerson, it won't need any rights anymore.\n+                        authorizeService.removeAllEPersonPolicies(context, ePerson);\n+                    } else if (StringUtils.equals(tableName, \"tasklistitem\") && isBasicFramework) {\n+                        // remove EPerson from the list of EPersons that may claim some specific workflow tasks.\n+                        TaskListItemService taskListItemService = BasicWorkflowServiceFactory.getInstance()\n+                                                                  .getTaskListItemService();\n+                        taskListItemService.deleteByEPerson(context, ePerson);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ae42397bf8ee8ab24201c3ef824c8d99e49306b"}, "originalPosition": 285}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1313, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}