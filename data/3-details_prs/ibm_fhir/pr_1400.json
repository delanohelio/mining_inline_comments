{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYyODM3NjQx", "number": 1400, "title": "issue #1352 - introduce fhir-smart component", "bodyText": "in this initial version, fhir-smart includes a single PersistenceInterceptor which uses java-jwt to decode\na passed token, parses the patient context from a \"patient_id\" claim, parses the granted scope string,\nand checks these values against the interaction being performed.\nSigned-off-by: Lee Surprenant lmsurpre@us.ibm.com", "createdAt": "2020-08-04T15:22:55Z", "url": "https://github.com/IBM/FHIR/pull/1400", "merged": true, "mergeCommit": {"oid": "3002d746ffaa0b89a1257ea8980842ed90f6609d"}, "closed": true, "closedAt": "2020-08-07T17:30:48Z", "author": {"login": "lmsurpre"}, "timelineItems": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc7oTiAgBqjM2MjA3ODA3NTk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc7qnxUABqjM2MjE0MDYxMzI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f8e89efb88f4c7f4eebbdeede06002d0b8c44c3c", "author": {"user": {"login": "lmsurpre", "name": "Lee Surprenant"}}, "url": "https://github.com/IBM/FHIR/commit/f8e89efb88f4c7f4eebbdeede06002d0b8c44c3c", "committedDate": "2020-08-04T15:20:03Z", "message": "issue #1352 - introduce fhir-smart component\n\nin this initial version, fhir-smart includes a single PersistenceInterceptor which uses java-jwt to decode\nthe token, parses the patient context from a \"patient_id\" claim and parses the granted scope string,\nand checks these values against the interaction being performed.\n\nSigned-off-by: Lee Surprenant <lmsurpre@us.ibm.com>"}, "afterCommit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48", "author": {"user": {"login": "lmsurpre", "name": "Lee Surprenant"}}, "url": "https://github.com/IBM/FHIR/commit/232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48", "committedDate": "2020-08-04T15:24:59Z", "message": "issue #1352 - introduce fhir-smart component\n\nin this initial version, fhir-smart includes a single\nPersistenceInterceptor which uses java-jwt to decode\nthe token, parses the patient context from a \"patient_id\" claim and\nparses the granted scope string,\nand checks these values against the interaction being performed.\n\nSigned-off-by: Lee Surprenant <lmsurpre@us.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwOTI0NTk1", "url": "https://github.com/IBM/FHIR/pull/1400#pullrequestreview-460924595", "createdAt": "2020-08-04T15:27:11Z", "commit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNToyNzoxMVrOG7lpqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNToyNzoxMVrOG7lpqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzNjA0Mg==", "bodyText": "Copyright?", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465136042", "createdAt": "2020-08-04T15:27:11Z", "author": {"login": "prb112"}, "path": "fhir-smart/pom.xml", "diffHunk": "@@ -0,0 +1,77 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!-- THIS PRODUCT CONTAINS RESTRICTED MATERIALS OF IBM 5724-H88, 5724-J08,\n+    5724-I63, 5655-W65, COPYRIGHT International Business Machines Corp., 2014\n+    All Rights Reserved * Licensed Materials - Property of IBM US Government\n+    Users Restricted Rights - Use, duplication or disclosure restricted by GSA\n+    ADP Schedule Contract with IBM Corp. -->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "originalPosition": 6}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwOTI1MDg5", "url": "https://github.com/IBM/FHIR/pull/1400#pullrequestreview-460925089", "createdAt": "2020-08-04T15:27:42Z", "commit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNToyNzo0MlrOG7lrAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNToyNzo0MlrOG7lrAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzNjM4Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    <version>4.3.2-SNAPSHOT</version>\n          \n          \n            \n                    <version>4.4.0-SNAPSHOT</version>", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465136387", "createdAt": "2020-08-04T15:27:42Z", "author": {"login": "prb112"}, "path": "fhir-smart/pom.xml", "diffHunk": "@@ -0,0 +1,77 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!-- THIS PRODUCT CONTAINS RESTRICTED MATERIALS OF IBM 5724-H88, 5724-J08,\n+    5724-I63, 5655-W65, COPYRIGHT International Business Machines Corp., 2014\n+    All Rights Reserved * Licensed Materials - Property of IBM US Government\n+    Users Restricted Rights - Use, duplication or disclosure restricted by GSA\n+    ADP Schedule Contract with IBM Corp. -->\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <parent>\n+        <groupId>com.ibm.fhir</groupId>\n+        <artifactId>fhir-parent</artifactId>\n+        <version>4.3.2-SNAPSHOT</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "originalPosition": 16}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwOTI2NjIy", "url": "https://github.com/IBM/FHIR/pull/1400#pullrequestreview-460926622", "createdAt": "2020-08-04T15:29:23Z", "commit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNToyOToyM1rOG7lvvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNToyOToyM1rOG7lvvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzNzU5Ng==", "bodyText": "copyright", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465137596", "createdAt": "2020-08-04T15:29:23Z", "author": {"login": "prb112"}, "path": "fhir-smart/src/test/java/com/ibm/fhir/smart/test/AuthzPolicyBackupEnforcementTest.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package com.ibm.fhir.smart.test;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwOTI2ODMy", "url": "https://github.com/IBM/FHIR/pull/1400#pullrequestreview-460926832", "createdAt": "2020-08-04T15:29:36Z", "commit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNToyOTozNlrOG7lwXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNToyOTozNlrOG7lwXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzNzc1OA==", "bodyText": "Negative test too?", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465137758", "createdAt": "2020-08-04T15:29:36Z", "author": {"login": "prb112"}, "path": "fhir-smart/src/test/java/com/ibm/fhir/smart/test/AuthzPolicyBackupEnforcementTest.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package com.ibm.fhir.smart.test;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.test.TestUtil;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceEvent;\n+import com.ibm.fhir.smart.AuthzPolicyEnforcementPersistenceInterceptor;\n+\n+public class AuthzPolicyBackupEnforcementTest {\n+    AuthzPolicyEnforcementPersistenceInterceptor interceptor;\n+    Patient patient;\n+\n+    @BeforeClass\n+    public void setup() throws Exception {\n+        interceptor = new AuthzPolicyEnforcementPersistenceInterceptor();\n+\n+        patient = TestUtil.readExampleResource(\"json/ibm/minimal/Patient-1.json\");\n+        patient = patient.toBuilder()\n+                .id(\"11111111-1111-1111-1111-111111111111\")\n+                .build();\n+    }\n+\n+    @Test\n+    public void testUserInfoHeader() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "originalPosition": 33}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwOTI5NzM5", "url": "https://github.com/IBM/FHIR/pull/1400#pullrequestreview-460929739", "createdAt": "2020-08-04T15:32:52Z", "commit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNTozMjo1MlrOG7l5gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNTozMjo1MlrOG7l5gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0MDA5OA==", "bodyText": "Given John's issues with streams, how does this perform?", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465140098", "createdAt": "2020-08-04T15:32:52Z", "author": {"login": "prb112"}, "path": "fhir-smart/src/main/java/com/ibm/fhir/smart/AuthzPolicyEnforcementPersistenceInterceptor.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019, 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.smart;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import com.auth0.jwt.JWT;\n+import com.auth0.jwt.interfaces.Claim;\n+import com.auth0.jwt.interfaces.DecodedJWT;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Resource;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.code.CompartmentType;\n+import com.ibm.fhir.model.type.code.IssueType;\n+import com.ibm.fhir.model.type.code.ResourceType;\n+import com.ibm.fhir.model.util.FHIRUtil;\n+import com.ibm.fhir.path.FHIRPathNode;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator.EvaluationContext;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceEvent;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceInterceptor;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceInterceptorException;\n+import com.ibm.fhir.search.compartment.CompartmentUtil;\n+import com.ibm.fhir.search.exception.FHIRSearchException;\n+import com.ibm.fhir.search.util.SearchUtil;\n+import com.ibm.fhir.smart.Scope.ContextType;\n+import com.ibm.fhir.smart.Scope.Permission;\n+\n+public class AuthzPolicyEnforcementPersistenceInterceptor implements FHIRPersistenceInterceptor {\n+    private static final Logger log = Logger.getLogger(AuthzPolicyEnforcementPersistenceInterceptor.class.getName());\n+\n+    private static final String BEARER_TOKEN_PREFIX = \"Bearer\";\n+    private static final String PATIENT_REF_PREFIX = \"Patient/\";\n+\n+    @Override\n+    public void beforeCreate(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void beforeDelete(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getPrevFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void beforeUpdate(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        // TODO: do we need to check READ permission on the prevFhirResource as well?\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterRead(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterVread(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterHistory(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        if (event.getFhirResource() instanceof Bundle) {\n+            for ( Bundle.Entry entry : ((Bundle) event.getFhirResource()).getEntry()) {\n+                if (entry.getResource() != null) {\n+                    enforce(entry.getResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+                }\n+            }\n+        } else {\n+            throw new IllegalStateException(\"Expected event resource of type Bundle but found \" +\n+                    event.getFhirResource().getClass().getSimpleName());\n+        }\n+    }\n+\n+    @Override\n+    public void afterSearch(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        if (event.getFhirResource() instanceof Bundle) {\n+            for ( Bundle.Entry entry : ((Bundle) event.getFhirResource()).getEntry()) {\n+                if (entry.getResource() != null) {\n+                    enforce(entry.getResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+                }\n+            }\n+        } else {\n+            throw new IllegalStateException(\"Expected event resource of type Bundle but found \" +\n+                    event.getFhirResource().getClass().getSimpleName());\n+        }\n+    }\n+\n+    /**\n+     * @param event\n+     * @param contextIds\n+     * @param collect\n+     * @throws FHIRPersistenceInterceptorException\n+     */\n+    private void enforce(Resource resource, List<String> contextIds, Permission requiredPermission, List<Scope> approvedScopes)\n+            throws FHIRPersistenceInterceptorException {\n+        Objects.requireNonNull(resource, \"resource\");\n+        Objects.requireNonNull(contextIds, \"contextIds\");\n+\n+        String resourceType = resource.getClass().getSimpleName();\n+        Map<ContextType, List<Scope>> approvedScopeMap = approvedScopes.stream()\n+                // First filter the list to only scopes which grant the required permissions on the passed resourceType\n+                .filter(s -> s.getResourceType() == ResourceType.ValueSet.RESOURCE ||\n+                        s.getResourceType().value().equals(resourceType))\n+                .filter(s -> hasPermission(s.getPermission(),requiredPermission))\n+                // Then group the scopes by their context type\n+                .collect(Collectors.groupingBy(s -> s.getContextType()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "originalPosition": 128}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwOTMwNDg1", "url": "https://github.com/IBM/FHIR/pull/1400#pullrequestreview-460930485", "createdAt": "2020-08-04T15:33:42Z", "commit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNTozMzo0M1rOG7l7uQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNTozMzo0M1rOG7l7uQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0MDY2NQ==", "bodyText": "FHIRSearchException... shouldn't this be an operation exception?", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465140665", "createdAt": "2020-08-04T15:33:43Z", "author": {"login": "prb112"}, "path": "fhir-smart/src/main/java/com/ibm/fhir/smart/AuthzPolicyEnforcementPersistenceInterceptor.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019, 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.smart;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import com.auth0.jwt.JWT;\n+import com.auth0.jwt.interfaces.Claim;\n+import com.auth0.jwt.interfaces.DecodedJWT;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Resource;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.code.CompartmentType;\n+import com.ibm.fhir.model.type.code.IssueType;\n+import com.ibm.fhir.model.type.code.ResourceType;\n+import com.ibm.fhir.model.util.FHIRUtil;\n+import com.ibm.fhir.path.FHIRPathNode;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator.EvaluationContext;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceEvent;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceInterceptor;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceInterceptorException;\n+import com.ibm.fhir.search.compartment.CompartmentUtil;\n+import com.ibm.fhir.search.exception.FHIRSearchException;\n+import com.ibm.fhir.search.util.SearchUtil;\n+import com.ibm.fhir.smart.Scope.ContextType;\n+import com.ibm.fhir.smart.Scope.Permission;\n+\n+public class AuthzPolicyEnforcementPersistenceInterceptor implements FHIRPersistenceInterceptor {\n+    private static final Logger log = Logger.getLogger(AuthzPolicyEnforcementPersistenceInterceptor.class.getName());\n+\n+    private static final String BEARER_TOKEN_PREFIX = \"Bearer\";\n+    private static final String PATIENT_REF_PREFIX = \"Patient/\";\n+\n+    @Override\n+    public void beforeCreate(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void beforeDelete(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getPrevFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void beforeUpdate(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        // TODO: do we need to check READ permission on the prevFhirResource as well?\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterRead(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterVread(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterHistory(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        if (event.getFhirResource() instanceof Bundle) {\n+            for ( Bundle.Entry entry : ((Bundle) event.getFhirResource()).getEntry()) {\n+                if (entry.getResource() != null) {\n+                    enforce(entry.getResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+                }\n+            }\n+        } else {\n+            throw new IllegalStateException(\"Expected event resource of type Bundle but found \" +\n+                    event.getFhirResource().getClass().getSimpleName());\n+        }\n+    }\n+\n+    @Override\n+    public void afterSearch(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        if (event.getFhirResource() instanceof Bundle) {\n+            for ( Bundle.Entry entry : ((Bundle) event.getFhirResource()).getEntry()) {\n+                if (entry.getResource() != null) {\n+                    enforce(entry.getResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+                }\n+            }\n+        } else {\n+            throw new IllegalStateException(\"Expected event resource of type Bundle but found \" +\n+                    event.getFhirResource().getClass().getSimpleName());\n+        }\n+    }\n+\n+    /**\n+     * @param event\n+     * @param contextIds\n+     * @param collect\n+     * @throws FHIRPersistenceInterceptorException\n+     */\n+    private void enforce(Resource resource, List<String> contextIds, Permission requiredPermission, List<Scope> approvedScopes)\n+            throws FHIRPersistenceInterceptorException {\n+        Objects.requireNonNull(resource, \"resource\");\n+        Objects.requireNonNull(contextIds, \"contextIds\");\n+\n+        String resourceType = resource.getClass().getSimpleName();\n+        Map<ContextType, List<Scope>> approvedScopeMap = approvedScopes.stream()\n+                // First filter the list to only scopes which grant the required permissions on the passed resourceType\n+                .filter(s -> s.getResourceType() == ResourceType.ValueSet.RESOURCE ||\n+                        s.getResourceType().value().equals(resourceType))\n+                .filter(s -> hasPermission(s.getPermission(),requiredPermission))\n+                // Then group the scopes by their context type\n+                .collect(Collectors.groupingBy(s -> s.getContextType()));\n+\n+        if (approvedScopeMap.containsKey(ContextType.PATIENT)) {\n+\n+            // If the target resource is the Patient resource which matches the in-context patient, allow it\n+            if (resource instanceof Patient && resource.getId() != null && contextIds.contains(resource.getId())) {\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Interaction is permitted via scope \" + approvedScopeMap.get(ContextType.PATIENT) +\n+                        \" with patient context '\" + resource.getId() + \"'\");\n+                }\n+                return;\n+            }\n+\n+            // Else, see if the target resource belongs to the Patient compartment of the in-context patient\n+            try {\n+                List<String> inclusionCriteria = CompartmentUtil\n+                        .getCompartmentResourceTypeInclusionCriteria(CompartmentType.PATIENT.getValue(), resourceType);\n+\n+                EvaluationContext resourceContext = new FHIRPathEvaluator.EvaluationContext(resource);\n+\n+                for (String searchParm : inclusionCriteria) {\n+                    try {\n+                        String expression = SearchUtil.getSearchParameter(resourceType, searchParm).getExpression().getValue();\n+                        Collection<FHIRPathNode> nodes = FHIRPathEvaluator.evaluator().evaluate(resourceContext, expression);\n+                        for (FHIRPathNode node : nodes) {\n+                            String patientRefVal = getPatientRefVal(node);\n+                            if (patientRefVal != null && contextIds.contains(patientRefVal)) {\n+                                if (log.isLoggable(Level.FINE)) {\n+                                    log.fine(\"Interaction is permitted via scope \" + approvedScopeMap.get(ContextType.PATIENT) +\n+                                        \" with patient context '\" + patientRefVal + \"'\");\n+                                }\n+                                return;\n+                            }\n+                        }\n+                    } catch (Exception e) {\n+                        log.log(Level.WARNING, \"Unexpected exception while processing inclusionCriteria '\" + searchParm +\n+                                \"' in the Patient compartment for resource type \" + resourceType);\n+                    }\n+                }\n+            } catch (FHIRSearchException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "originalPosition": 167}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwOTMxODI1", "url": "https://github.com/IBM/FHIR/pull/1400#pullrequestreview-460931825", "createdAt": "2020-08-04T15:35:15Z", "commit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNTozNToxNVrOG7mACA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNTozNToxNVrOG7mACA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0MTc2OA==", "bodyText": "interesting check...", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465141768", "createdAt": "2020-08-04T15:35:15Z", "author": {"login": "prb112"}, "path": "fhir-smart/src/main/java/com/ibm/fhir/smart/AuthzPolicyEnforcementPersistenceInterceptor.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019, 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.smart;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import com.auth0.jwt.JWT;\n+import com.auth0.jwt.interfaces.Claim;\n+import com.auth0.jwt.interfaces.DecodedJWT;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Resource;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.code.CompartmentType;\n+import com.ibm.fhir.model.type.code.IssueType;\n+import com.ibm.fhir.model.type.code.ResourceType;\n+import com.ibm.fhir.model.util.FHIRUtil;\n+import com.ibm.fhir.path.FHIRPathNode;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator.EvaluationContext;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceEvent;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceInterceptor;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceInterceptorException;\n+import com.ibm.fhir.search.compartment.CompartmentUtil;\n+import com.ibm.fhir.search.exception.FHIRSearchException;\n+import com.ibm.fhir.search.util.SearchUtil;\n+import com.ibm.fhir.smart.Scope.ContextType;\n+import com.ibm.fhir.smart.Scope.Permission;\n+\n+public class AuthzPolicyEnforcementPersistenceInterceptor implements FHIRPersistenceInterceptor {\n+    private static final Logger log = Logger.getLogger(AuthzPolicyEnforcementPersistenceInterceptor.class.getName());\n+\n+    private static final String BEARER_TOKEN_PREFIX = \"Bearer\";\n+    private static final String PATIENT_REF_PREFIX = \"Patient/\";\n+\n+    @Override\n+    public void beforeCreate(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void beforeDelete(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getPrevFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void beforeUpdate(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        // TODO: do we need to check READ permission on the prevFhirResource as well?\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterRead(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterVread(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterHistory(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        if (event.getFhirResource() instanceof Bundle) {\n+            for ( Bundle.Entry entry : ((Bundle) event.getFhirResource()).getEntry()) {\n+                if (entry.getResource() != null) {\n+                    enforce(entry.getResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+                }\n+            }\n+        } else {\n+            throw new IllegalStateException(\"Expected event resource of type Bundle but found \" +\n+                    event.getFhirResource().getClass().getSimpleName());\n+        }\n+    }\n+\n+    @Override\n+    public void afterSearch(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        if (event.getFhirResource() instanceof Bundle) {\n+            for ( Bundle.Entry entry : ((Bundle) event.getFhirResource()).getEntry()) {\n+                if (entry.getResource() != null) {\n+                    enforce(entry.getResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+                }\n+            }\n+        } else {\n+            throw new IllegalStateException(\"Expected event resource of type Bundle but found \" +\n+                    event.getFhirResource().getClass().getSimpleName());\n+        }\n+    }\n+\n+    /**\n+     * @param event\n+     * @param contextIds\n+     * @param collect\n+     * @throws FHIRPersistenceInterceptorException\n+     */\n+    private void enforce(Resource resource, List<String> contextIds, Permission requiredPermission, List<Scope> approvedScopes)\n+            throws FHIRPersistenceInterceptorException {\n+        Objects.requireNonNull(resource, \"resource\");\n+        Objects.requireNonNull(contextIds, \"contextIds\");\n+\n+        String resourceType = resource.getClass().getSimpleName();\n+        Map<ContextType, List<Scope>> approvedScopeMap = approvedScopes.stream()\n+                // First filter the list to only scopes which grant the required permissions on the passed resourceType\n+                .filter(s -> s.getResourceType() == ResourceType.ValueSet.RESOURCE ||\n+                        s.getResourceType().value().equals(resourceType))\n+                .filter(s -> hasPermission(s.getPermission(),requiredPermission))\n+                // Then group the scopes by their context type\n+                .collect(Collectors.groupingBy(s -> s.getContextType()));\n+\n+        if (approvedScopeMap.containsKey(ContextType.PATIENT)) {\n+\n+            // If the target resource is the Patient resource which matches the in-context patient, allow it\n+            if (resource instanceof Patient && resource.getId() != null && contextIds.contains(resource.getId())) {\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Interaction is permitted via scope \" + approvedScopeMap.get(ContextType.PATIENT) +\n+                        \" with patient context '\" + resource.getId() + \"'\");\n+                }\n+                return;\n+            }\n+\n+            // Else, see if the target resource belongs to the Patient compartment of the in-context patient\n+            try {\n+                List<String> inclusionCriteria = CompartmentUtil\n+                        .getCompartmentResourceTypeInclusionCriteria(CompartmentType.PATIENT.getValue(), resourceType);\n+\n+                EvaluationContext resourceContext = new FHIRPathEvaluator.EvaluationContext(resource);\n+\n+                for (String searchParm : inclusionCriteria) {\n+                    try {\n+                        String expression = SearchUtil.getSearchParameter(resourceType, searchParm).getExpression().getValue();\n+                        Collection<FHIRPathNode> nodes = FHIRPathEvaluator.evaluator().evaluate(resourceContext, expression);\n+                        for (FHIRPathNode node : nodes) {\n+                            String patientRefVal = getPatientRefVal(node);\n+                            if (patientRefVal != null && contextIds.contains(patientRefVal)) {\n+                                if (log.isLoggable(Level.FINE)) {\n+                                    log.fine(\"Interaction is permitted via scope \" + approvedScopeMap.get(ContextType.PATIENT) +\n+                                        \" with patient context '\" + patientRefVal + \"'\");\n+                                }\n+                                return;\n+                            }\n+                        }\n+                    } catch (Exception e) {\n+                        log.log(Level.WARNING, \"Unexpected exception while processing inclusionCriteria '\" + searchParm +\n+                                \"' in the Patient compartment for resource type \" + resourceType);\n+                    }\n+                }\n+            } catch (FHIRSearchException e) {\n+                log.log(Level.WARNING, \"Unexpected exception while enforcing authorization policy in the Patient compartment\"\n+                        + \" for resource type \" + resourceType);\n+            }\n+        }\n+\n+        if (approvedScopeMap.containsKey(ContextType.USER)) {\n+            throw new UnsupportedOperationException(\"SMART scopes with context type 'user' are not yet supported.\");\n+        }\n+\n+\n+        String msg = \"Requested interaction is not permitted by any of the passed scopes.\";\n+        throw new FHIRPersistenceInterceptorException(msg)\n+                .withIssue(FHIRUtil.buildOperationOutcomeIssue(msg, IssueType.FORBIDDEN));\n+    }\n+\n+    /**\n+     * @param node\n+     * @return the id to the Patient resource referenced by this node (assuming it is a Reference with a valid\n+     *         reference value); otherwise null\n+     */\n+    private String getPatientRefVal(FHIRPathNode node) {\n+        if (!node.isElementNode() || !node.asElementNode().element().is(Reference.class)) {\n+            throw new IllegalStateException(\"Patient compartment inclusionCriteria expression has returned a non-Reference\");\n+        }\n+        Reference reference = node.asElementNode().element().as(Reference.class);\n+        if (reference.getReference() != null && reference.getReference().hasValue()) {\n+            String refVal = reference.getReference().getValue();\n+            if (refVal != null && refVal.startsWith(PATIENT_REF_PREFIX)) {\n+                return refVal.substring(PATIENT_REF_PREFIX.length());\n+            }\n+        } else if (log.isLoggable(Level.FINE)){\n+            log.fine(\"Skipping non-patient / non-relative reference: '\" + reference + \"'\");\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * @param permission\n+     * @param requiredPermission\n+     * @return true if the grantedPermission includes the requiredPermission; otherwise false\n+     */\n+    private boolean hasPermission(Permission grantedPermission, Permission requiredPermission) {\n+        if (grantedPermission == Permission.ALL) {\n+            return true;\n+        } else {\n+            return grantedPermission == requiredPermission;\n+        }\n+    }\n+\n+    private String getAccessToken() throws FHIRPersistenceInterceptorException {\n+        List<String> list = FHIRRequestContext.get().getHttpHeaders().get(\"Authorization\");\n+        if (list.size() != 1) {\n+            throw new FHIRPersistenceInterceptorException(\"Request must contain exactly one Authorization header.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "originalPosition": 221}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwOTMyNzA0", "url": "https://github.com/IBM/FHIR/pull/1400#pullrequestreview-460932704", "createdAt": "2020-08-04T15:36:16Z", "commit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNTozNjoxNlrOG7mCyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNTozNjoxNlrOG7mCyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0MjQ3Mg==", "bodyText": "should this perhaps go in a not top-level folder?\nor should this be fhir-auth-smart?\nIs it just going to be scoped to auth intercepting", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465142472", "createdAt": "2020-08-04T15:36:16Z", "author": {"login": "prb112"}, "path": "fhir-smart/.gitignore", "diffHunk": "@@ -0,0 +1,6 @@\n+/.apt_generated/\n+/.settings/\n+/target/\n+/test-output/\n+.factorypath\n+*.log", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "originalPosition": 6}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwOTMzOTcy", "url": "https://github.com/IBM/FHIR/pull/1400#pullrequestreview-460933972", "createdAt": "2020-08-04T15:37:39Z", "commit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNTozNzozOVrOG7mGrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNTozNzozOVrOG7mGrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0MzQ3MA==", "bodyText": "small set may be best to have a for loop.... same performance question", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465143470", "createdAt": "2020-08-04T15:37:39Z", "author": {"login": "prb112"}, "path": "fhir-smart/src/main/java/com/ibm/fhir/smart/AuthzPolicyEnforcementPersistenceInterceptor.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019, 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.smart;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import com.auth0.jwt.JWT;\n+import com.auth0.jwt.interfaces.Claim;\n+import com.auth0.jwt.interfaces.DecodedJWT;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Resource;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.code.CompartmentType;\n+import com.ibm.fhir.model.type.code.IssueType;\n+import com.ibm.fhir.model.type.code.ResourceType;\n+import com.ibm.fhir.model.util.FHIRUtil;\n+import com.ibm.fhir.path.FHIRPathNode;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator.EvaluationContext;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceEvent;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceInterceptor;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceInterceptorException;\n+import com.ibm.fhir.search.compartment.CompartmentUtil;\n+import com.ibm.fhir.search.exception.FHIRSearchException;\n+import com.ibm.fhir.search.util.SearchUtil;\n+import com.ibm.fhir.smart.Scope.ContextType;\n+import com.ibm.fhir.smart.Scope.Permission;\n+\n+public class AuthzPolicyEnforcementPersistenceInterceptor implements FHIRPersistenceInterceptor {\n+    private static final Logger log = Logger.getLogger(AuthzPolicyEnforcementPersistenceInterceptor.class.getName());\n+\n+    private static final String BEARER_TOKEN_PREFIX = \"Bearer\";\n+    private static final String PATIENT_REF_PREFIX = \"Patient/\";\n+\n+    @Override\n+    public void beforeCreate(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void beforeDelete(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getPrevFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void beforeUpdate(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        // TODO: do we need to check READ permission on the prevFhirResource as well?\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterRead(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterVread(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterHistory(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        if (event.getFhirResource() instanceof Bundle) {\n+            for ( Bundle.Entry entry : ((Bundle) event.getFhirResource()).getEntry()) {\n+                if (entry.getResource() != null) {\n+                    enforce(entry.getResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+                }\n+            }\n+        } else {\n+            throw new IllegalStateException(\"Expected event resource of type Bundle but found \" +\n+                    event.getFhirResource().getClass().getSimpleName());\n+        }\n+    }\n+\n+    @Override\n+    public void afterSearch(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        if (event.getFhirResource() instanceof Bundle) {\n+            for ( Bundle.Entry entry : ((Bundle) event.getFhirResource()).getEntry()) {\n+                if (entry.getResource() != null) {\n+                    enforce(entry.getResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+                }\n+            }\n+        } else {\n+            throw new IllegalStateException(\"Expected event resource of type Bundle but found \" +\n+                    event.getFhirResource().getClass().getSimpleName());\n+        }\n+    }\n+\n+    /**\n+     * @param event\n+     * @param contextIds\n+     * @param collect\n+     * @throws FHIRPersistenceInterceptorException\n+     */\n+    private void enforce(Resource resource, List<String> contextIds, Permission requiredPermission, List<Scope> approvedScopes)\n+            throws FHIRPersistenceInterceptorException {\n+        Objects.requireNonNull(resource, \"resource\");\n+        Objects.requireNonNull(contextIds, \"contextIds\");\n+\n+        String resourceType = resource.getClass().getSimpleName();\n+        Map<ContextType, List<Scope>> approvedScopeMap = approvedScopes.stream()\n+                // First filter the list to only scopes which grant the required permissions on the passed resourceType\n+                .filter(s -> s.getResourceType() == ResourceType.ValueSet.RESOURCE ||\n+                        s.getResourceType().value().equals(resourceType))\n+                .filter(s -> hasPermission(s.getPermission(),requiredPermission))\n+                // Then group the scopes by their context type\n+                .collect(Collectors.groupingBy(s -> s.getContextType()));\n+\n+        if (approvedScopeMap.containsKey(ContextType.PATIENT)) {\n+\n+            // If the target resource is the Patient resource which matches the in-context patient, allow it\n+            if (resource instanceof Patient && resource.getId() != null && contextIds.contains(resource.getId())) {\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Interaction is permitted via scope \" + approvedScopeMap.get(ContextType.PATIENT) +\n+                        \" with patient context '\" + resource.getId() + \"'\");\n+                }\n+                return;\n+            }\n+\n+            // Else, see if the target resource belongs to the Patient compartment of the in-context patient\n+            try {\n+                List<String> inclusionCriteria = CompartmentUtil\n+                        .getCompartmentResourceTypeInclusionCriteria(CompartmentType.PATIENT.getValue(), resourceType);\n+\n+                EvaluationContext resourceContext = new FHIRPathEvaluator.EvaluationContext(resource);\n+\n+                for (String searchParm : inclusionCriteria) {\n+                    try {\n+                        String expression = SearchUtil.getSearchParameter(resourceType, searchParm).getExpression().getValue();\n+                        Collection<FHIRPathNode> nodes = FHIRPathEvaluator.evaluator().evaluate(resourceContext, expression);\n+                        for (FHIRPathNode node : nodes) {\n+                            String patientRefVal = getPatientRefVal(node);\n+                            if (patientRefVal != null && contextIds.contains(patientRefVal)) {\n+                                if (log.isLoggable(Level.FINE)) {\n+                                    log.fine(\"Interaction is permitted via scope \" + approvedScopeMap.get(ContextType.PATIENT) +\n+                                        \" with patient context '\" + patientRefVal + \"'\");\n+                                }\n+                                return;\n+                            }\n+                        }\n+                    } catch (Exception e) {\n+                        log.log(Level.WARNING, \"Unexpected exception while processing inclusionCriteria '\" + searchParm +\n+                                \"' in the Patient compartment for resource type \" + resourceType);\n+                    }\n+                }\n+            } catch (FHIRSearchException e) {\n+                log.log(Level.WARNING, \"Unexpected exception while enforcing authorization policy in the Patient compartment\"\n+                        + \" for resource type \" + resourceType);\n+            }\n+        }\n+\n+        if (approvedScopeMap.containsKey(ContextType.USER)) {\n+            throw new UnsupportedOperationException(\"SMART scopes with context type 'user' are not yet supported.\");\n+        }\n+\n+\n+        String msg = \"Requested interaction is not permitted by any of the passed scopes.\";\n+        throw new FHIRPersistenceInterceptorException(msg)\n+                .withIssue(FHIRUtil.buildOperationOutcomeIssue(msg, IssueType.FORBIDDEN));\n+    }\n+\n+    /**\n+     * @param node\n+     * @return the id to the Patient resource referenced by this node (assuming it is a Reference with a valid\n+     *         reference value); otherwise null\n+     */\n+    private String getPatientRefVal(FHIRPathNode node) {\n+        if (!node.isElementNode() || !node.asElementNode().element().is(Reference.class)) {\n+            throw new IllegalStateException(\"Patient compartment inclusionCriteria expression has returned a non-Reference\");\n+        }\n+        Reference reference = node.asElementNode().element().as(Reference.class);\n+        if (reference.getReference() != null && reference.getReference().hasValue()) {\n+            String refVal = reference.getReference().getValue();\n+            if (refVal != null && refVal.startsWith(PATIENT_REF_PREFIX)) {\n+                return refVal.substring(PATIENT_REF_PREFIX.length());\n+            }\n+        } else if (log.isLoggable(Level.FINE)){\n+            log.fine(\"Skipping non-patient / non-relative reference: '\" + reference + \"'\");\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * @param permission\n+     * @param requiredPermission\n+     * @return true if the grantedPermission includes the requiredPermission; otherwise false\n+     */\n+    private boolean hasPermission(Permission grantedPermission, Permission requiredPermission) {\n+        if (grantedPermission == Permission.ALL) {\n+            return true;\n+        } else {\n+            return grantedPermission == requiredPermission;\n+        }\n+    }\n+\n+    private String getAccessToken() throws FHIRPersistenceInterceptorException {\n+        List<String> list = FHIRRequestContext.get().getHttpHeaders().get(\"Authorization\");\n+        if (list.size() != 1) {\n+            throw new FHIRPersistenceInterceptorException(\"Request must contain exactly one Authorization header.\");\n+        }\n+        String header = list.get(0);\n+\n+        if (!header.startsWith(BEARER_TOKEN_PREFIX)) {\n+            throw new FHIRPersistenceInterceptorException(\"Authorization header must carry a Bearer token\");\n+        }\n+\n+        return header.substring(BEARER_TOKEN_PREFIX.length()).trim();\n+    }\n+\n+    private List<Scope> getScopesFromToken(DecodedJWT jwt) {\n+        Claim claim = jwt.getClaim(\"scope\");\n+        if (claim.isNull()) {\n+            throw new IllegalArgumentException(\"Authorization token is missing 'scope' claim\");\n+        }\n+\n+        List<String> scopeStrings;\n+        String claimString = claim.asString();\n+\n+        if (claimString != null) {\n+            scopeStrings = Arrays.asList(claim.asString().split(\"\\\\s+\"));\n+        } else {\n+            log.fine(\"Found scope claim was expected to be a string but is not; processing as a list\");\n+            scopeStrings = claim.asList(String.class);\n+        }\n+\n+        return scopeStrings.stream()\n+                .filter(s -> s.matches(Scope.SCOPE_STRING_REGEX))\n+                .map(s -> new Scope(s))\n+                .collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "originalPosition": 251}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwOTM0NDk0", "url": "https://github.com/IBM/FHIR/pull/1400#pullrequestreview-460934494", "createdAt": "2020-08-04T15:38:16Z", "commit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNTozODoxNlrOG7mITQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNTozODoxNlrOG7mITQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0Mzg4NQ==", "bodyText": "Are you anticipating more than one id?", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465143885", "createdAt": "2020-08-04T15:38:16Z", "author": {"login": "prb112"}, "path": "fhir-smart/src/main/java/com/ibm/fhir/smart/AuthzPolicyEnforcementPersistenceInterceptor.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019, 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.smart;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import com.auth0.jwt.JWT;\n+import com.auth0.jwt.interfaces.Claim;\n+import com.auth0.jwt.interfaces.DecodedJWT;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Resource;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.code.CompartmentType;\n+import com.ibm.fhir.model.type.code.IssueType;\n+import com.ibm.fhir.model.type.code.ResourceType;\n+import com.ibm.fhir.model.util.FHIRUtil;\n+import com.ibm.fhir.path.FHIRPathNode;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator.EvaluationContext;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceEvent;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceInterceptor;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceInterceptorException;\n+import com.ibm.fhir.search.compartment.CompartmentUtil;\n+import com.ibm.fhir.search.exception.FHIRSearchException;\n+import com.ibm.fhir.search.util.SearchUtil;\n+import com.ibm.fhir.smart.Scope.ContextType;\n+import com.ibm.fhir.smart.Scope.Permission;\n+\n+public class AuthzPolicyEnforcementPersistenceInterceptor implements FHIRPersistenceInterceptor {\n+    private static final Logger log = Logger.getLogger(AuthzPolicyEnforcementPersistenceInterceptor.class.getName());\n+\n+    private static final String BEARER_TOKEN_PREFIX = \"Bearer\";\n+    private static final String PATIENT_REF_PREFIX = \"Patient/\";\n+\n+    @Override\n+    public void beforeCreate(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void beforeDelete(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getPrevFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void beforeUpdate(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        // TODO: do we need to check READ permission on the prevFhirResource as well?\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterRead(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterVread(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterHistory(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        if (event.getFhirResource() instanceof Bundle) {\n+            for ( Bundle.Entry entry : ((Bundle) event.getFhirResource()).getEntry()) {\n+                if (entry.getResource() != null) {\n+                    enforce(entry.getResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+                }\n+            }\n+        } else {\n+            throw new IllegalStateException(\"Expected event resource of type Bundle but found \" +\n+                    event.getFhirResource().getClass().getSimpleName());\n+        }\n+    }\n+\n+    @Override\n+    public void afterSearch(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        if (event.getFhirResource() instanceof Bundle) {\n+            for ( Bundle.Entry entry : ((Bundle) event.getFhirResource()).getEntry()) {\n+                if (entry.getResource() != null) {\n+                    enforce(entry.getResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+                }\n+            }\n+        } else {\n+            throw new IllegalStateException(\"Expected event resource of type Bundle but found \" +\n+                    event.getFhirResource().getClass().getSimpleName());\n+        }\n+    }\n+\n+    /**\n+     * @param event\n+     * @param contextIds\n+     * @param collect\n+     * @throws FHIRPersistenceInterceptorException\n+     */\n+    private void enforce(Resource resource, List<String> contextIds, Permission requiredPermission, List<Scope> approvedScopes)\n+            throws FHIRPersistenceInterceptorException {\n+        Objects.requireNonNull(resource, \"resource\");\n+        Objects.requireNonNull(contextIds, \"contextIds\");\n+\n+        String resourceType = resource.getClass().getSimpleName();\n+        Map<ContextType, List<Scope>> approvedScopeMap = approvedScopes.stream()\n+                // First filter the list to only scopes which grant the required permissions on the passed resourceType\n+                .filter(s -> s.getResourceType() == ResourceType.ValueSet.RESOURCE ||\n+                        s.getResourceType().value().equals(resourceType))\n+                .filter(s -> hasPermission(s.getPermission(),requiredPermission))\n+                // Then group the scopes by their context type\n+                .collect(Collectors.groupingBy(s -> s.getContextType()));\n+\n+        if (approvedScopeMap.containsKey(ContextType.PATIENT)) {\n+\n+            // If the target resource is the Patient resource which matches the in-context patient, allow it\n+            if (resource instanceof Patient && resource.getId() != null && contextIds.contains(resource.getId())) {\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Interaction is permitted via scope \" + approvedScopeMap.get(ContextType.PATIENT) +\n+                        \" with patient context '\" + resource.getId() + \"'\");\n+                }\n+                return;\n+            }\n+\n+            // Else, see if the target resource belongs to the Patient compartment of the in-context patient\n+            try {\n+                List<String> inclusionCriteria = CompartmentUtil\n+                        .getCompartmentResourceTypeInclusionCriteria(CompartmentType.PATIENT.getValue(), resourceType);\n+\n+                EvaluationContext resourceContext = new FHIRPathEvaluator.EvaluationContext(resource);\n+\n+                for (String searchParm : inclusionCriteria) {\n+                    try {\n+                        String expression = SearchUtil.getSearchParameter(resourceType, searchParm).getExpression().getValue();\n+                        Collection<FHIRPathNode> nodes = FHIRPathEvaluator.evaluator().evaluate(resourceContext, expression);\n+                        for (FHIRPathNode node : nodes) {\n+                            String patientRefVal = getPatientRefVal(node);\n+                            if (patientRefVal != null && contextIds.contains(patientRefVal)) {\n+                                if (log.isLoggable(Level.FINE)) {\n+                                    log.fine(\"Interaction is permitted via scope \" + approvedScopeMap.get(ContextType.PATIENT) +\n+                                        \" with patient context '\" + patientRefVal + \"'\");\n+                                }\n+                                return;\n+                            }\n+                        }\n+                    } catch (Exception e) {\n+                        log.log(Level.WARNING, \"Unexpected exception while processing inclusionCriteria '\" + searchParm +\n+                                \"' in the Patient compartment for resource type \" + resourceType);\n+                    }\n+                }\n+            } catch (FHIRSearchException e) {\n+                log.log(Level.WARNING, \"Unexpected exception while enforcing authorization policy in the Patient compartment\"\n+                        + \" for resource type \" + resourceType);\n+            }\n+        }\n+\n+        if (approvedScopeMap.containsKey(ContextType.USER)) {\n+            throw new UnsupportedOperationException(\"SMART scopes with context type 'user' are not yet supported.\");\n+        }\n+\n+\n+        String msg = \"Requested interaction is not permitted by any of the passed scopes.\";\n+        throw new FHIRPersistenceInterceptorException(msg)\n+                .withIssue(FHIRUtil.buildOperationOutcomeIssue(msg, IssueType.FORBIDDEN));\n+    }\n+\n+    /**\n+     * @param node\n+     * @return the id to the Patient resource referenced by this node (assuming it is a Reference with a valid\n+     *         reference value); otherwise null\n+     */\n+    private String getPatientRefVal(FHIRPathNode node) {\n+        if (!node.isElementNode() || !node.asElementNode().element().is(Reference.class)) {\n+            throw new IllegalStateException(\"Patient compartment inclusionCriteria expression has returned a non-Reference\");\n+        }\n+        Reference reference = node.asElementNode().element().as(Reference.class);\n+        if (reference.getReference() != null && reference.getReference().hasValue()) {\n+            String refVal = reference.getReference().getValue();\n+            if (refVal != null && refVal.startsWith(PATIENT_REF_PREFIX)) {\n+                return refVal.substring(PATIENT_REF_PREFIX.length());\n+            }\n+        } else if (log.isLoggable(Level.FINE)){\n+            log.fine(\"Skipping non-patient / non-relative reference: '\" + reference + \"'\");\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * @param permission\n+     * @param requiredPermission\n+     * @return true if the grantedPermission includes the requiredPermission; otherwise false\n+     */\n+    private boolean hasPermission(Permission grantedPermission, Permission requiredPermission) {\n+        if (grantedPermission == Permission.ALL) {\n+            return true;\n+        } else {\n+            return grantedPermission == requiredPermission;\n+        }\n+    }\n+\n+    private String getAccessToken() throws FHIRPersistenceInterceptorException {\n+        List<String> list = FHIRRequestContext.get().getHttpHeaders().get(\"Authorization\");\n+        if (list.size() != 1) {\n+            throw new FHIRPersistenceInterceptorException(\"Request must contain exactly one Authorization header.\");\n+        }\n+        String header = list.get(0);\n+\n+        if (!header.startsWith(BEARER_TOKEN_PREFIX)) {\n+            throw new FHIRPersistenceInterceptorException(\"Authorization header must carry a Bearer token\");\n+        }\n+\n+        return header.substring(BEARER_TOKEN_PREFIX.length()).trim();\n+    }\n+\n+    private List<Scope> getScopesFromToken(DecodedJWT jwt) {\n+        Claim claim = jwt.getClaim(\"scope\");\n+        if (claim.isNull()) {\n+            throw new IllegalArgumentException(\"Authorization token is missing 'scope' claim\");\n+        }\n+\n+        List<String> scopeStrings;\n+        String claimString = claim.asString();\n+\n+        if (claimString != null) {\n+            scopeStrings = Arrays.asList(claim.asString().split(\"\\\\s+\"));\n+        } else {\n+            log.fine(\"Found scope claim was expected to be a string but is not; processing as a list\");\n+            scopeStrings = claim.asList(String.class);\n+        }\n+\n+        return scopeStrings.stream()\n+                .filter(s -> s.matches(Scope.SCOPE_STRING_REGEX))\n+                .map(s -> new Scope(s))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private List<String> getPatientIdFromToken(DecodedJWT jwt) {\n+        Claim claim = jwt.getClaim(\"patient_id\");\n+        if (claim.isNull()) {\n+            throw new IllegalArgumentException(\"Authorization token is missing 'patient_id' claim\");\n+        }\n+\n+        String patientId = claim.asString();\n+        if (patientId == null) {\n+            log.fine(\"Found patient_id claim was expected to be a string but is not; processing as a list\");\n+            return claim.asList(String.class);\n+        }\n+\n+        return Collections.singletonList(patientId);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "originalPosition": 267}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48", "author": {"user": {"login": "lmsurpre", "name": "Lee Surprenant"}}, "url": "https://github.com/IBM/FHIR/commit/232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48", "committedDate": "2020-08-04T15:24:59Z", "message": "issue #1352 - introduce fhir-smart component\n\nin this initial version, fhir-smart includes a single\nPersistenceInterceptor which uses java-jwt to decode\nthe token, parses the patient context from a \"patient_id\" claim and\nparses the granted scope string,\nand checks these values against the interaction being performed.\n\nSigned-off-by: Lee Surprenant <lmsurpre@us.ibm.com>"}, "afterCommit": {"oid": "0871ded135dbfb16c71181c9381dec5ff746f63f", "author": {"user": {"login": "lmsurpre", "name": "Lee Surprenant"}}, "url": "https://github.com/IBM/FHIR/commit/0871ded135dbfb16c71181c9381dec5ff746f63f", "committedDate": "2020-08-04T15:39:03Z", "message": "issue #1352 - introduce fhir-smart component\n\nin this initial version, fhir-smart includes a single\nPersistenceInterceptor which uses java-jwt to decode\nthe token, parses the patient context from a \"patient_id\" claim and\nparses the granted scope string,\nand checks these values against the interaction being performed.\n\nSigned-off-by: Lee Surprenant <lmsurpre@us.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0871ded135dbfb16c71181c9381dec5ff746f63f", "author": {"user": {"login": "lmsurpre", "name": "Lee Surprenant"}}, "url": "https://github.com/IBM/FHIR/commit/0871ded135dbfb16c71181c9381dec5ff746f63f", "committedDate": "2020-08-04T15:39:03Z", "message": "issue #1352 - introduce fhir-smart component\n\nin this initial version, fhir-smart includes a single\nPersistenceInterceptor which uses java-jwt to decode\nthe token, parses the patient context from a \"patient_id\" claim and\nparses the granted scope string,\nand checks these values against the interaction being performed.\n\nSigned-off-by: Lee Surprenant <lmsurpre@us.ibm.com>"}, "afterCommit": {"oid": "d0732a4f1f0c2ae50eb4a3a8c3eed867580dc51b", "author": {"user": {"login": "lmsurpre", "name": "Lee Surprenant"}}, "url": "https://github.com/IBM/FHIR/commit/d0732a4f1f0c2ae50eb4a3a8c3eed867580dc51b", "committedDate": "2020-08-04T15:56:29Z", "message": "issue #1352 - introduce fhir-smart component\n\nin this initial version, fhir-smart includes a single\nPersistenceInterceptor which uses java-jwt to decode\nthe token, parses the patient context from a \"patient_id\" claim and\nparses the granted scope string,\nand checks these values against the interaction being performed.\n\nSigned-off-by: Lee Surprenant <lmsurpre@us.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d0732a4f1f0c2ae50eb4a3a8c3eed867580dc51b", "author": {"user": {"login": "lmsurpre", "name": "Lee Surprenant"}}, "url": "https://github.com/IBM/FHIR/commit/d0732a4f1f0c2ae50eb4a3a8c3eed867580dc51b", "committedDate": "2020-08-04T15:56:29Z", "message": "issue #1352 - introduce fhir-smart component\n\nin this initial version, fhir-smart includes a single\nPersistenceInterceptor which uses java-jwt to decode\nthe token, parses the patient context from a \"patient_id\" claim and\nparses the granted scope string,\nand checks these values against the interaction being performed.\n\nSigned-off-by: Lee Surprenant <lmsurpre@us.ibm.com>"}, "afterCommit": {"oid": "4fae3518085bfb79f24ec7276bd7b8003faeacc4", "author": {"user": {"login": "lmsurpre", "name": "Lee Surprenant"}}, "url": "https://github.com/IBM/FHIR/commit/4fae3518085bfb79f24ec7276bd7b8003faeacc4", "committedDate": "2020-08-04T16:25:28Z", "message": "issue #1352 - introduce fhir-smart component\n\nin this initial version, fhir-smart includes a single\nPersistenceInterceptor which uses java-jwt to decode\nthe token, parses the patient context from a \"patient_id\" claim and\nparses the granted scope string,\nand checks these values against the interaction being performed.\n\nSigned-off-by: Lee Surprenant <lmsurpre@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54d51ecb6515313278ed23cd9e68548aabe88609", "author": {"user": {"login": "lmsurpre", "name": "Lee Surprenant"}}, "url": "https://github.com/IBM/FHIR/commit/54d51ecb6515313278ed23cd9e68548aabe88609", "committedDate": "2020-08-04T16:28:45Z", "message": "issue #1352 - introduce fhir-smart component\n\nin this initial version, fhir-smart includes a single\nPersistenceInterceptor which uses java-jwt to decode\nthe token, parses the patient context from a \"patient_id\" claim and\nparses the granted scope string,\nand checks these values against the interaction being performed.\n\nSigned-off-by: Lee Surprenant <lmsurpre@us.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4fae3518085bfb79f24ec7276bd7b8003faeacc4", "author": {"user": {"login": "lmsurpre", "name": "Lee Surprenant"}}, "url": "https://github.com/IBM/FHIR/commit/4fae3518085bfb79f24ec7276bd7b8003faeacc4", "committedDate": "2020-08-04T16:25:28Z", "message": "issue #1352 - introduce fhir-smart component\n\nin this initial version, fhir-smart includes a single\nPersistenceInterceptor which uses java-jwt to decode\nthe token, parses the patient context from a \"patient_id\" claim and\nparses the granted scope string,\nand checks these values against the interaction being performed.\n\nSigned-off-by: Lee Surprenant <lmsurpre@us.ibm.com>"}, "afterCommit": {"oid": "54d51ecb6515313278ed23cd9e68548aabe88609", "author": {"user": {"login": "lmsurpre", "name": "Lee Surprenant"}}, "url": "https://github.com/IBM/FHIR/commit/54d51ecb6515313278ed23cd9e68548aabe88609", "committedDate": "2020-08-04T16:28:45Z", "message": "issue #1352 - introduce fhir-smart component\n\nin this initial version, fhir-smart includes a single\nPersistenceInterceptor which uses java-jwt to decode\nthe token, parses the patient context from a \"patient_id\" claim and\nparses the granted scope string,\nand checks these values against the interaction being performed.\n\nSigned-off-by: Lee Surprenant <lmsurpre@us.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwOTc3Njk3", "url": "https://github.com/IBM/FHIR/pull/1400#pullrequestreview-460977697", "createdAt": "2020-08-04T16:29:15Z", "commit": {"oid": "4fae3518085bfb79f24ec7276bd7b8003faeacc4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMDIxNDY5", "url": "https://github.com/IBM/FHIR/pull/1400#pullrequestreview-461021469", "createdAt": "2020-08-04T17:27:30Z", "commit": {"oid": "54d51ecb6515313278ed23cd9e68548aabe88609"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e6a838d9583189dea3c323cafe73890f620adad", "author": {"user": {"login": "lmsurpre", "name": "Lee Surprenant"}}, "url": "https://github.com/IBM/FHIR/commit/5e6a838d9583189dea3c323cafe73890f620adad", "committedDate": "2020-08-04T18:06:54Z", "message": "issue #1352 - introduce parameterization for testing scopestring combos\n\nAlso fixed a NullPointerException found in FHIRConfigHelper when there\nis no tenantId present.\n\nSigned-off-by: Lee Surprenant <lmsurpre@us.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "06fa3014db2c319b965582392d7af5da44437236", "author": {"user": {"login": "lmsurpre", "name": "Lee Surprenant"}}, "url": "https://github.com/IBM/FHIR/commit/06fa3014db2c319b965582392d7af5da44437236", "committedDate": "2020-08-04T17:58:52Z", "message": "issue #1352 - introduce parameterization for testing scopestring combos\n\nAlso fixed a NullPointerException found in FHIRConfigHelper when there\nis no tenantId present.\n\nSigned-off-by: Lee Surprenant <lmsurpre@us.ibm.com>"}, "afterCommit": {"oid": "5e6a838d9583189dea3c323cafe73890f620adad", "author": {"user": {"login": "lmsurpre", "name": "Lee Surprenant"}}, "url": "https://github.com/IBM/FHIR/commit/5e6a838d9583189dea3c323cafe73890f620adad", "committedDate": "2020-08-04T18:06:54Z", "message": "issue #1352 - introduce parameterization for testing scopestring combos\n\nAlso fixed a NullPointerException found in FHIRConfigHelper when there\nis no tenantId present.\n\nSigned-off-by: Lee Surprenant <lmsurpre@us.ibm.com>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1381, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}