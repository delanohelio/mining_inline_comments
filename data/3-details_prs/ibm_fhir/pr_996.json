{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEwMjA2MjQz", "number": 996, "title": "Improve Tenant-Key Behavior #990", "bodyText": "Introduced the TenantKeyFileUtil\n\nWrite a generated key to a file\nRead a key from a file used during processing\n\n\nUpdate the fhir-persistence-schema README.md\nUpdate Db2AddTablePartition to cleanup code\nUpdate Main.java to check for Multitenant Feature instead of an OR\n\nSigned-off-by: Paul Bastide pbastide@us.ibm.com", "createdAt": "2020-04-28T15:50:20Z", "url": "https://github.com/IBM/FHIR/pull/996", "merged": true, "mergeCommit": {"oid": "9b636aef1bfeb6d152769492df4a9bdfe3c33c31"}, "closed": true, "closedAt": "2020-04-30T11:30:56Z", "author": {"login": "prb112"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABccF6ZGAH2gAyNDEwMjA2MjQzOmU4YWUxMDM5ODg4ZmY5NTc4Y2Q2NGM3Mjk3YWMzNzQwZjI3MDQwZDA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABccf9UsAFqTQwMzA3NjA1OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "e8ae1039888ff9578cd64c7297ac3740f27040d0", "author": {"user": {"login": "prb112", "name": "Paul Bastide"}}, "url": "https://github.com/IBM/FHIR/commit/e8ae1039888ff9578cd64c7297ac3740f27040d0", "committedDate": "2020-04-28T15:49:16Z", "message": "Improve Tenant-Key Behavior #990\n\n- Introduced the TenantKeyFileUtil\n\t- Write a generated key to a file\n\t- Read a key from a file used during processing\n- Update the fhir-persistence-schema README.md\n- Update Db2AddTablePartition to cleanup code\n- Update Main.java to check for Multitenant Feature instead of an OR\n\nSigned-off-by: Paul Bastide <pbastide@us.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyODM0ODY3", "url": "https://github.com/IBM/FHIR/pull/996#pullrequestreview-402834867", "createdAt": "2020-04-29T16:26:01Z", "commit": {"oid": "e8ae1039888ff9578cd64c7297ac3740f27040d0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNjoyNjowMVrOGOG8zA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNjoyNjowMVrOGOG8zA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ0NzExNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Use `--tenant-key-file tenant.key.file` to direct the action to read the tenant-key from file.  If the file exists the tenant key (up to 44 characters is read from the file.  If the file does not exist, the generated tenantKey is written out to the file.\n          \n          \n            \n            Use `--tenant-key-file tenant.key.file` to direct the action to read the tenant-key from file.  If the file exists the tenant key (up to 44 characters) is read from the file.  If the file does not exist, the generated tenantKey is written out to the file.", "url": "https://github.com/IBM/FHIR/pull/996#discussion_r417447116", "createdAt": "2020-04-29T16:26:01Z", "author": {"login": "lmsurpre"}, "path": "fhir-persistence-schema/README.md", "diffHunk": "@@ -129,6 +129,8 @@ Don't forget to copy the tenant-key secret generated by --allocate-tenant. This\n --allocate-tenant default\n ```\n \n+Use `--tenant-key-file tenant.key.file` to direct the action to read the tenant-key from file.  If the file exists the tenant key (up to 44 characters is read from the file.  If the file does not exist, the generated tenantKey is written out to the file.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8ae1039888ff9578cd64c7297ac3740f27040d0"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyODM4MTk5", "url": "https://github.com/IBM/FHIR/pull/996#pullrequestreview-402838199", "createdAt": "2020-04-29T16:30:16Z", "commit": {"oid": "e8ae1039888ff9578cd64c7297ac3740f27040d0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNjozMDoxNlrOGOHHpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNjozMDoxNlrOGOHHpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ0OTg5Mw==", "bodyText": "if we ever add to the MULTITENANT_FEATURE_ENABLED list, we'll need to update this line...but I think its fine for now", "url": "https://github.com/IBM/FHIR/pull/996#discussion_r417449893", "createdAt": "2020-04-29T16:30:16Z", "author": {"login": "lmsurpre"}, "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/app/Main.java", "diffHunk": "@@ -858,42 +886,103 @@ protected void addTenantKey() {\n             }\n         }\n \n-        logger.info(\"New tenant key: \" + addKeyForTenant + \" [key=\" + tenantKey + \"]\");\n+        if (tenantKeyFileName == null) {\n+            // Generated\n+            logger.info(\"New tenant key: \" + addKeyForTenant + \" [key=\" + tenantKey + \"]\");\n+        } else {\n+            // Loaded from File\n+            logger.info(\n+                    \"New tenant key from file: \" + addKeyForTenant + \" [tenantKeyFileName=\" + tenantKeyFileName + \"]\");\n+            if (!tenantKeyFileUtil.keyFileExists(tenantKeyFileName)) {\n+                tenantKeyFileUtil.writeTenantFile(tenantKeyFileName, tenantKey);\n+            }\n+        }\n \n     }\n \n+    /**\n+     * checks if tenant name and tenant key exists.\n+     * \n+     * @param adapter    the db2 adapter as this is a db2 feature only now\n+     * @param tenantName the tenant's name\n+     * @param tenantKey  tenant key\n+     */\n+    protected void checkIfTenantNameAndTenantKeyExists(Db2Adapter adapter, String tenantName, String tenantKey) {\n+        try (ITransaction tx = TransactionFactory.openTransaction(connectionPool)) {\n+            try {\n+                final String sql =\n+                        \"SELECT t.tenant_status FROM fhir_admin.tenants t WHERE t.tenant_name = ? \"\n+                                + \"AND EXISTS (SELECT 1 FROM fhir_admin.tenant_keys tk WHERE tk.mt_id = t.mt_id \"\n+                                + \"AND tk.tenant_hash = sysibm.hash(tk.tenant_salt || ?, 2));\";\n+                try (PreparedStatement stmt = connectionPool.getConnection().prepareStatement(sql)) {\n+                    stmt.setString(1, tenantName);\n+                    stmt.setString(2, tenantKey);\n+                    if (stmt.execute()) {\n+                        try (ResultSet resultSet = stmt.getResultSet();) {\n+                            if (resultSet.next()) {\n+                                throw new IllegalArgumentException(\"tenantName and tenantKey already exists\");\n+                            }\n+                        }\n+                    } else {\n+                        throw new IllegalArgumentException(\"Problem checking the results\");\n+                    }\n+                } catch (SQLException e) {\n+                    throw new IllegalArgumentException(\n+                            \"Exception when querying backend to verify tenant key and tenant name\", e);\n+                }\n+            } catch (DataAccessException x) {\n+                // Something went wrong, so mark the transaction as failed\n+                tx.setRollbackOnly();\n+                throw x;\n+            }\n+        }\n+    }\n+\n     /**\n      * Allocate this tenant, creating new partitions if required.\n      */\n     protected void allocateTenant() {\n-        if (dbType == DbType.DERBY || dbType == DbType.POSTGRESQL) {\n+        if (!MULTITENANT_FEATURE_ENABLED.contains(dbType)) {\n             return;\n         }\n+\n         // The key we'll use for this tenant. This key should be used in subsequent\n         // activities related to this tenant, such as setting the tenant context.\n-        final String tenantKey = getRandomKey();\n+        if (tenantKeyFileUtil.keyFileExists(tenantKeyFileName)) {\n+            // Only if the Tenant Key file is provided as a parameter is it not null. \n+            // in  this case we want special behavior.\n+            tenantKey = this.tenantKeyFileUtil.readTenantFile(tenantKeyFileName);\n+        } else {\n+            tenantKey = getRandomKey();\n+        }\n \n         // The salt is used when we hash the tenantKey. We're just using SHA-256 for\n         // the hash here, not multiple rounds of a password hashing algorithm. It's\n         // sufficient in our case because we are using a 32-byte random value as the\n         // key, giving 256 bits of entropy.\n         final String tenantSalt = getRandomKey();\n \n+        Db2Adapter adapter = new Db2Adapter(connectionPool);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8ae1039888ff9578cd64c7297ac3740f27040d0"}, "originalPosition": 267}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyODM5MzIx", "url": "https://github.com/IBM/FHIR/pull/996#pullrequestreview-402839321", "createdAt": "2020-04-29T16:31:39Z", "commit": {"oid": "e8ae1039888ff9578cd64c7297ac3740f27040d0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNjozMTozOVrOGOHLbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNjozMTozOVrOGOHLbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ1MDg2MQ==", "bodyText": "maybe move these below the if-else block so its closer to the try-with-resource?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // Open a new transaction and associate it with our connection pool. Remember\n          \n          \n            \n                    // that we don't support distributed transactions, so all connections within\n          \n          \n            \n                    // this transaction must come from the same pool", "url": "https://github.com/IBM/FHIR/pull/996#discussion_r417450861", "createdAt": "2020-04-29T16:31:39Z", "author": {"login": "lmsurpre"}, "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/app/Main.java", "diffHunk": "@@ -858,42 +886,103 @@ protected void addTenantKey() {\n             }\n         }\n \n-        logger.info(\"New tenant key: \" + addKeyForTenant + \" [key=\" + tenantKey + \"]\");\n+        if (tenantKeyFileName == null) {\n+            // Generated\n+            logger.info(\"New tenant key: \" + addKeyForTenant + \" [key=\" + tenantKey + \"]\");\n+        } else {\n+            // Loaded from File\n+            logger.info(\n+                    \"New tenant key from file: \" + addKeyForTenant + \" [tenantKeyFileName=\" + tenantKeyFileName + \"]\");\n+            if (!tenantKeyFileUtil.keyFileExists(tenantKeyFileName)) {\n+                tenantKeyFileUtil.writeTenantFile(tenantKeyFileName, tenantKey);\n+            }\n+        }\n \n     }\n \n+    /**\n+     * checks if tenant name and tenant key exists.\n+     * \n+     * @param adapter    the db2 adapter as this is a db2 feature only now\n+     * @param tenantName the tenant's name\n+     * @param tenantKey  tenant key\n+     */\n+    protected void checkIfTenantNameAndTenantKeyExists(Db2Adapter adapter, String tenantName, String tenantKey) {\n+        try (ITransaction tx = TransactionFactory.openTransaction(connectionPool)) {\n+            try {\n+                final String sql =\n+                        \"SELECT t.tenant_status FROM fhir_admin.tenants t WHERE t.tenant_name = ? \"\n+                                + \"AND EXISTS (SELECT 1 FROM fhir_admin.tenant_keys tk WHERE tk.mt_id = t.mt_id \"\n+                                + \"AND tk.tenant_hash = sysibm.hash(tk.tenant_salt || ?, 2));\";\n+                try (PreparedStatement stmt = connectionPool.getConnection().prepareStatement(sql)) {\n+                    stmt.setString(1, tenantName);\n+                    stmt.setString(2, tenantKey);\n+                    if (stmt.execute()) {\n+                        try (ResultSet resultSet = stmt.getResultSet();) {\n+                            if (resultSet.next()) {\n+                                throw new IllegalArgumentException(\"tenantName and tenantKey already exists\");\n+                            }\n+                        }\n+                    } else {\n+                        throw new IllegalArgumentException(\"Problem checking the results\");\n+                    }\n+                } catch (SQLException e) {\n+                    throw new IllegalArgumentException(\n+                            \"Exception when querying backend to verify tenant key and tenant name\", e);\n+                }\n+            } catch (DataAccessException x) {\n+                // Something went wrong, so mark the transaction as failed\n+                tx.setRollbackOnly();\n+                throw x;\n+            }\n+        }\n+    }\n+\n     /**\n      * Allocate this tenant, creating new partitions if required.\n      */\n     protected void allocateTenant() {\n-        if (dbType == DbType.DERBY || dbType == DbType.POSTGRESQL) {\n+        if (!MULTITENANT_FEATURE_ENABLED.contains(dbType)) {\n             return;\n         }\n+\n         // The key we'll use for this tenant. This key should be used in subsequent\n         // activities related to this tenant, such as setting the tenant context.\n-        final String tenantKey = getRandomKey();\n+        if (tenantKeyFileUtil.keyFileExists(tenantKeyFileName)) {\n+            // Only if the Tenant Key file is provided as a parameter is it not null. \n+            // in  this case we want special behavior.\n+            tenantKey = this.tenantKeyFileUtil.readTenantFile(tenantKeyFileName);\n+        } else {\n+            tenantKey = getRandomKey();\n+        }\n \n         // The salt is used when we hash the tenantKey. We're just using SHA-256 for\n         // the hash here, not multiple rounds of a password hashing algorithm. It's\n         // sufficient in our case because we are using a 32-byte random value as the\n         // key, giving 256 bits of entropy.\n         final String tenantSalt = getRandomKey();\n \n+        Db2Adapter adapter = new Db2Adapter(connectionPool);\n+        checkIfTenantNameAndTenantKeyExists(adapter, tenantName, tenantKey);\n+\n         // Open a new transaction and associate it with our connection pool. Remember\n         // that we don't support distributed transactions, so all connections within\n         // this transaction must come from the same pool", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8ae1039888ff9578cd64c7297ac3740f27040d0"}, "originalPosition": 272}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyODQyODg0", "url": "https://github.com/IBM/FHIR/pull/996#pullrequestreview-402842884", "createdAt": "2020-04-29T16:36:07Z", "commit": {"oid": "e8ae1039888ff9578cd64c7297ac3740f27040d0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNjozNjowN1rOGOHWLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNjozNjowN1rOGOHWLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ1MzYxNQ==", "bodyText": "why does it end in .nowrite?\nI think the pattern should match the name given in the examples in the README; currently that is  --tenant-key-file tenant.key.file", "url": "https://github.com/IBM/FHIR/pull/996#discussion_r417453615", "createdAt": "2020-04-29T16:36:07Z", "author": {"login": "lmsurpre"}, "path": "fhir-persistence-schema/src/test/resources/test/.gitignore", "diffHunk": "@@ -0,0 +1,2 @@\n+# Blocks the Addition of the test files into git\n+**/*.key.nowrite", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8ae1039888ff9578cd64c7297ac3740f27040d0"}, "originalPosition": 2}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyODU0Mzc3", "url": "https://github.com/IBM/FHIR/pull/996#pullrequestreview-402854377", "createdAt": "2020-04-29T16:50:13Z", "commit": {"oid": "e8ae1039888ff9578cd64c7297ac3740f27040d0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNjo1MDoxM1rOGOH6ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNjo1MDoxM1rOGOH6ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2MjkyMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n            \n          \n          \n            \n                    // Open a new transaction and associate it with our connection pool. Remember\n          \n          \n            \n                    // that we don't support distributed transactions, so all connections within\n          \n          \n            \n                    // this transaction must come from the same pool", "url": "https://github.com/IBM/FHIR/pull/996#discussion_r417462922", "createdAt": "2020-04-29T16:50:13Z", "author": {"login": "prb112"}, "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/app/Main.java", "diffHunk": "@@ -858,42 +886,103 @@ protected void addTenantKey() {\n             }\n         }\n \n-        logger.info(\"New tenant key: \" + addKeyForTenant + \" [key=\" + tenantKey + \"]\");\n+        if (tenantKeyFileName == null) {\n+            // Generated\n+            logger.info(\"New tenant key: \" + addKeyForTenant + \" [key=\" + tenantKey + \"]\");\n+        } else {\n+            // Loaded from File\n+            logger.info(\n+                    \"New tenant key from file: \" + addKeyForTenant + \" [tenantKeyFileName=\" + tenantKeyFileName + \"]\");\n+            if (!tenantKeyFileUtil.keyFileExists(tenantKeyFileName)) {\n+                tenantKeyFileUtil.writeTenantFile(tenantKeyFileName, tenantKey);\n+            }\n+        }\n \n     }\n \n+    /**\n+     * checks if tenant name and tenant key exists.\n+     * \n+     * @param adapter    the db2 adapter as this is a db2 feature only now\n+     * @param tenantName the tenant's name\n+     * @param tenantKey  tenant key\n+     */\n+    protected void checkIfTenantNameAndTenantKeyExists(Db2Adapter adapter, String tenantName, String tenantKey) {\n+        try (ITransaction tx = TransactionFactory.openTransaction(connectionPool)) {\n+            try {\n+                final String sql =\n+                        \"SELECT t.tenant_status FROM fhir_admin.tenants t WHERE t.tenant_name = ? \"\n+                                + \"AND EXISTS (SELECT 1 FROM fhir_admin.tenant_keys tk WHERE tk.mt_id = t.mt_id \"\n+                                + \"AND tk.tenant_hash = sysibm.hash(tk.tenant_salt || ?, 2));\";\n+                try (PreparedStatement stmt = connectionPool.getConnection().prepareStatement(sql)) {\n+                    stmt.setString(1, tenantName);\n+                    stmt.setString(2, tenantKey);\n+                    if (stmt.execute()) {\n+                        try (ResultSet resultSet = stmt.getResultSet();) {\n+                            if (resultSet.next()) {\n+                                throw new IllegalArgumentException(\"tenantName and tenantKey already exists\");\n+                            }\n+                        }\n+                    } else {\n+                        throw new IllegalArgumentException(\"Problem checking the results\");\n+                    }\n+                } catch (SQLException e) {\n+                    throw new IllegalArgumentException(\n+                            \"Exception when querying backend to verify tenant key and tenant name\", e);\n+                }\n+            } catch (DataAccessException x) {\n+                // Something went wrong, so mark the transaction as failed\n+                tx.setRollbackOnly();\n+                throw x;\n+            }\n+        }\n+    }\n+\n     /**\n      * Allocate this tenant, creating new partitions if required.\n      */\n     protected void allocateTenant() {\n-        if (dbType == DbType.DERBY || dbType == DbType.POSTGRESQL) {\n+        if (!MULTITENANT_FEATURE_ENABLED.contains(dbType)) {\n             return;\n         }\n+\n         // The key we'll use for this tenant. This key should be used in subsequent\n         // activities related to this tenant, such as setting the tenant context.\n-        final String tenantKey = getRandomKey();\n+        if (tenantKeyFileUtil.keyFileExists(tenantKeyFileName)) {\n+            // Only if the Tenant Key file is provided as a parameter is it not null. \n+            // in  this case we want special behavior.\n+            tenantKey = this.tenantKeyFileUtil.readTenantFile(tenantKeyFileName);\n+        } else {\n+            tenantKey = getRandomKey();\n+        }\n \n         // The salt is used when we hash the tenantKey. We're just using SHA-256 for\n         // the hash here, not multiple rounds of a password hashing algorithm. It's\n         // sufficient in our case because we are using a 32-byte random value as the\n         // key, giving 256 bits of entropy.\n         final String tenantSalt = getRandomKey();\n \n+        Db2Adapter adapter = new Db2Adapter(connectionPool);\n+        checkIfTenantNameAndTenantKeyExists(adapter, tenantName, tenantKey);\n+\n         // Open a new transaction and associate it with our connection pool. Remember\n         // that we don't support distributed transactions, so all connections within\n         // this transaction must come from the same pool\n-        Db2Adapter adapter = new Db2Adapter(connectionPool);\n-        logger.info(\"Allocating new tenant: \" + tenantName + \" [key=\" + tenantKey + \"]\");\n+        if (tenantKeyFileName == null) {\n+            logger.info(\"Allocating new tenant: \" + tenantName + \" [key=\" + tenantKey + \"]\");\n+        } else {\n+            logger.info(\"Allocating new tenant: \" + tenantName + \" [tenantKeyFileName=\" + tenantKeyFileName + \"]\");\n+        }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8ae1039888ff9578cd64c7297ac3740f27040d0"}, "originalPosition": 280}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b116f0f006b9ef3c5c571f357aac90b0db21e19d", "author": {"user": {"login": "prb112", "name": "Paul Bastide"}}, "url": "https://github.com/IBM/FHIR/commit/b116f0f006b9ef3c5c571f357aac90b0db21e19d", "committedDate": "2020-04-29T16:51:05Z", "message": "Apply suggestions from code review\r\n\r\nSigned-off-by: Paul Bastide <pbastide@us.ibm.com>\n\nCo-Authored-By: Lee Surprenant <lmsurpre@us.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzMDc2MDU5", "url": "https://github.com/IBM/FHIR/pull/996#pullrequestreview-403076059", "createdAt": "2020-04-29T22:10:00Z", "commit": {"oid": "b116f0f006b9ef3c5c571f357aac90b0db21e19d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 409, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}