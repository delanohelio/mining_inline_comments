{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE1MDIwNjUw", "number": 1666, "title": "Issue #1218 - enable reverse chain (_has) search", "bodyText": "Signed-off-by: Mike Schroeder mschroed@us.ibm.com", "createdAt": "2020-11-03T22:16:47Z", "url": "https://github.com/IBM/FHIR/pull/1666", "merged": true, "mergeCommit": {"oid": "e90c2ce9105fcc461ce0a54e572b5891fa7982e8"}, "closed": true, "closedAt": "2020-11-09T21:12:11Z", "author": {"login": "michaelwschroeder"}, "timelineItems": {"totalCount": 61, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdZAtMFAH2gAyNTE1MDIwNjUwOjkwMjE2MmRkYjM5YTkyYTZiZDMzNGUyZGMzYmZjNmU4NTYxMjUxMjU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABda7Z3XgFqTUyNjY1Nzc1MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125", "author": {"user": {"login": "michaelwschroeder", "name": "Michael W Schroeder"}}, "url": "https://github.com/IBM/FHIR/commit/902162ddb39a92a6bd334e2dc3bfc6e856125125", "committedDate": "2020-11-03T22:14:42Z", "message": "Issue #1218 - enable reverse chain (_has) search\n\nSigned-off-by: Mike Schroeder <mschroed@us.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzQ2NzA1", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-523346705", "createdAt": "2020-11-04T13:14:13Z", "commit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzoxNDoxM1rOHtXgvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzoxNDoxM1rOHtXgvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMzMzE4MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            It cannot be used in combination with the `_type` parameter, and the search parameter specified at the end of its chain cannot be\n          \n          \n            \n            a search result parameter.\n          \n          \n            \n            \n          \n          \n            \n            * `_has` cannot be used in combination with the `_type` parameter.\n          \n          \n            \n            * The search parameter specified at the end of its chain cannot be a search result parameter.", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517333181", "createdAt": "2020-11-04T13:14:13Z", "author": {"login": "prb112"}, "path": "docs/src/pages/Conformance.md", "diffHunk": "@@ -109,11 +109,14 @@ In addition, the following search parameters are supported on all resources:\n * `_security`\n * `_source`\n * `_type`\n+* `_has`\n \n These parameters can be used while searching any single resource type or while searching across resource types (whole system search).\n-The `_type` parameter is special in that it is only applicable for whole system search.\n+The `_type` parameter is special in that it is only applicable for whole system search. The `_has` parameter has two restrictions:\n+It cannot be used in combination with the `_type` parameter, and the search parameter specified at the end of its chain cannot be\n+a search result parameter.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "originalPosition": 19}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzQ5ODI3", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-523349827", "createdAt": "2020-11-04T13:18:22Z", "commit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzoxODoyMlrOHtXp6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzoxODoyMlrOHtXp6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMzNTUzMQ==", "bodyText": "Just as a form, since we are using a StringBuilder let's build the string with it.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                                    .append(\" AS \" + paramTableAlias)\n          \n          \n            \n                                                    .append(\" AS \").append(paramTableAlias)", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517335531", "createdAt": "2020-11-04T13:18:22Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/QuerySegmentAggregator.java", "diffHunk": "@@ -555,20 +555,35 @@ protected void buildWhereClause(StringBuilder whereClause, String overrideType)\n                     whereClause.append(whereClauseSegment);\n                 } else {\n                     if (!Type.COMPOSITE.equals(param.getType())) {\n-                        // Join a standard parameter table\n-                        //   JOIN Observation_TOKEN_VALUES AS param0\n-                        //     ON param0.PARAMETER_NAME_ID=1191 AND param0.TOKEN_VALUE = :p1\n-                        //    AND param0.LOGICAL_RESOURCE_ID = LR.LOGICAL_RESOURCE_ID\n-\n                         final String paramTableAlias = \"param\" + i;\n-                        final String onFilter = querySegment.getQueryString().replaceAll(PARAMETER_TABLE_ALIAS + \"\\\\.\", paramTableAlias + \".\");\n-\n-                        whereClause.append(JOIN);\n-                        whereClause.append(tableName(overrideType, param));\n-                        whereClause.append(\" AS \" + paramTableAlias);\n-                        whereClause.append(ON);\n-                        whereClause.append(onFilter);\n-                        whereClause.append(\" AND LR.LOGICAL_RESOURCE_ID = \" + paramTableAlias + \".LOGICAL_RESOURCE_ID\");\n+                        if (param.isReverseChained()) {\n+                            // Join on a select from logical resource table\n+                            //   JOIN (\n+                            //     SELECT CLR0.LOGICAL_ID FROM Observation_LOGICAL_RESOURCES AS CLR0\n+                            //       ...\n+                            //   ) AS param0 ON LR.LOGICAL_ID = param0.LOGICAL_ID\n+                            whereClause.append(JOIN)\n+                                        .append(LEFT_PAREN);\n+                            whereClause.append(querySegment.getQueryString());\n+                            whereClause.append(RIGHT_PAREN)\n+                                        .append(\" AS \" + paramTableAlias)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "originalPosition": 28}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzUwMDIz", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-523350023", "createdAt": "2020-11-04T13:18:40Z", "commit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzoxODo0MFrOHtXqhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzoxODo0MFrOHtXqhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMzNTY4Ng==", "bodyText": "Just as a form, since we are using a StringBuilder let's build the string with it.", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517335686", "createdAt": "2020-11-04T13:18:40Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/QuerySegmentAggregator.java", "diffHunk": "@@ -555,20 +555,35 @@ protected void buildWhereClause(StringBuilder whereClause, String overrideType)\n                     whereClause.append(whereClauseSegment);\n                 } else {\n                     if (!Type.COMPOSITE.equals(param.getType())) {\n-                        // Join a standard parameter table\n-                        //   JOIN Observation_TOKEN_VALUES AS param0\n-                        //     ON param0.PARAMETER_NAME_ID=1191 AND param0.TOKEN_VALUE = :p1\n-                        //    AND param0.LOGICAL_RESOURCE_ID = LR.LOGICAL_RESOURCE_ID\n-\n                         final String paramTableAlias = \"param\" + i;\n-                        final String onFilter = querySegment.getQueryString().replaceAll(PARAMETER_TABLE_ALIAS + \"\\\\.\", paramTableAlias + \".\");\n-\n-                        whereClause.append(JOIN);\n-                        whereClause.append(tableName(overrideType, param));\n-                        whereClause.append(\" AS \" + paramTableAlias);\n-                        whereClause.append(ON);\n-                        whereClause.append(onFilter);\n-                        whereClause.append(\" AND LR.LOGICAL_RESOURCE_ID = \" + paramTableAlias + \".LOGICAL_RESOURCE_ID\");\n+                        if (param.isReverseChained()) {\n+                            // Join on a select from logical resource table\n+                            //   JOIN (\n+                            //     SELECT CLR0.LOGICAL_ID FROM Observation_LOGICAL_RESOURCES AS CLR0\n+                            //       ...\n+                            //   ) AS param0 ON LR.LOGICAL_ID = param0.LOGICAL_ID\n+                            whereClause.append(JOIN)\n+                                        .append(LEFT_PAREN);\n+                            whereClause.append(querySegment.getQueryString());\n+                            whereClause.append(RIGHT_PAREN)\n+                                        .append(\" AS \" + paramTableAlias)\n+                                        .append(ON)\n+                                        .append(\"LR.LOGICAL_ID = \" + paramTableAlias + \".LOGICAL_ID\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "originalPosition": 30}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzU1NzUz", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-523355753", "createdAt": "2020-11-04T13:25:22Z", "commit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzoyNToyM1rOHtX6gA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzoyNToyM1rOHtX6gA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMzOTc3Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testDeleteResources() {\n          \n          \n            \n                public void testDeleteResources() {\n          \n      \n    \n    \n  \n\nnot a test per say?", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517339776", "createdAt": "2020-11-04T13:25:23Z", "author": {"login": "prb112"}, "path": "fhir-server-test/src/test/java/com/ibm/fhir/server/test/SearchReverseChainTest.java", "diffHunk": "@@ -0,0 +1,1034 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.server.test;\n+\n+import static com.ibm.fhir.model.type.String.of;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.ws.rs.client.Entity;\n+import javax.ws.rs.client.WebTarget;\n+import javax.ws.rs.core.Response;\n+\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.Test;\n+\n+import com.ibm.fhir.core.FHIRMediaType;\n+import com.ibm.fhir.model.format.Format;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Encounter;\n+import com.ibm.fhir.model.resource.Endpoint;\n+import com.ibm.fhir.model.resource.Location;\n+import com.ibm.fhir.model.resource.OperationOutcome;\n+import com.ibm.fhir.model.resource.Organization;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Procedure;\n+import com.ibm.fhir.model.test.TestUtil;\n+import com.ibm.fhir.model.type.Code;\n+import com.ibm.fhir.model.type.CodeableConcept;\n+import com.ibm.fhir.model.type.Coding;\n+import com.ibm.fhir.model.type.ContactPoint;\n+import com.ibm.fhir.model.type.Date;\n+import com.ibm.fhir.model.type.DateTime;\n+import com.ibm.fhir.model.type.Decimal;\n+import com.ibm.fhir.model.type.Duration;\n+import com.ibm.fhir.model.type.HumanName;\n+import com.ibm.fhir.model.type.Meta;\n+import com.ibm.fhir.model.type.Period;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.Uri;\n+import com.ibm.fhir.model.type.code.AdministrativeGender;\n+import com.ibm.fhir.model.type.code.ContactPointSystem;\n+import com.ibm.fhir.model.type.code.EncounterStatus;\n+import com.ibm.fhir.model.type.code.ProcedureStatus;\n+import com.ibm.fhir.model.type.code.ResourceType;\n+\n+/**\n+ * The tests execute the reverse chained behavior in order to exercise reference chains.\n+ */\n+public class SearchReverseChainTest extends FHIRServerTestBase {\n+    private String patient1Id;\n+    private String patient2Id;\n+    private String procedure1Id;\n+    private String procedure2Id;\n+    private String organization1Id;\n+    private String organization2Id;\n+    private String encounter1Id;\n+    private String encounter2Id;\n+    private String endpointId;\n+    private String locationId;\n+    private Instant now = Instant.now();\n+    private String tag = Long.toString(now.toEpochMilli());\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testCreateEndpoint() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+       // Build a new Endpoint.\n+        Endpoint endpoint = TestUtil.getMinimalResource(ResourceType.ENDPOINT, Format.JSON);\n+        endpoint = endpoint.toBuilder().name(of(tag)).build();\n+\n+        // Call the 'create' API.\n+        Entity<Endpoint> entity = Entity.entity(endpoint, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Endpoint\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the endpoint's logical id value.\n+        endpointId = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new Endpoint and verify it.\n+        response = target.path(\"Endpoint/\" + endpointId).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEndpoint\"})\n+    public void testCreateOrganization1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Organization.\n+        Organization organization = TestUtil.getMinimalResource(ResourceType.ORGANIZATION, Format.JSON);\n+        organization = organization.toBuilder()\n+                .name(of(tag))\n+                .endpoint(Reference.builder().reference(of(\"Endpoint/\" + endpointId)).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Organization> entity = Entity.entity(organization, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Organization\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the organization's logical id value.\n+        organization1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new organization and verify it.\n+        response = target.path(\"Organization/\" + organization1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEndpoint\"})\n+    public void testCreateOrganization2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+       // Build a new Organization.\n+        Organization organization = TestUtil.getMinimalResource(ResourceType.ORGANIZATION, Format.JSON);\n+        organization = organization.toBuilder()\n+                .name(of(tag))\n+                .endpoint(Reference.builder().reference(of(\"Endpoint/\" + endpointId)).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Organization> entity = Entity.entity(organization, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Organization\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the organization's logical id value.\n+        organization2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new organization and verify it.\n+        response = target.path(\"Organization/\" + organization2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateOrganization1\"})\n+    public void testCreatePatient1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Patient and then call the 'create' API.\n+        Patient patient = TestUtil.getMinimalResource(ResourceType.PATIENT, Format.JSON);\n+        patient = patient.toBuilder()\n+                .gender(AdministrativeGender.MALE)\n+                .name(HumanName.builder()\n+                    .given(of(\"1\" + tag))\n+                    .build())\n+                .meta(Meta.builder()\n+                    .tag(Coding.builder()\n+                        .code(Code.of(tag))\n+                        .build())\n+                    .build())\n+                .generalPractitioner(Reference.builder().reference(of(\"PractitionerRole/\" + tag)).build())\n+                .managingOrganization(Reference.builder().reference(of(\"Organization/\" + organization1Id)).build())\n+                .birthDate(Date.of(now.toString().substring(0,10)))\n+                .telecom(ContactPoint.builder().system(ContactPointSystem.PHONE).value(of(\"1\" + tag)).build())\n+               .build();\n+\n+        Entity<Patient> entity = Entity.entity(patient, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Patient\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the patient's logical id value.\n+        patient1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new patient and verify it.\n+        response = target.path(\"Patient/\" + patient1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreatePatient1\", \"testCreateOrganization2\"})\n+    public void testCreatePatient2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Patient and then call the 'create' API.\n+        Patient patient = TestUtil.getMinimalResource(ResourceType.PATIENT, Format.JSON);\n+        patient = patient.toBuilder()\n+                .gender(AdministrativeGender.FEMALE)\n+                .name(HumanName.builder()\n+                    .given(of(\"2\" + tag))\n+                    .build())\n+                .meta(Meta.builder()\n+                    .tag(Coding.builder()\n+                        .code(Code.of(tag))\n+                        .build())\n+                    .build())\n+                .generalPractitioner(Reference.builder().reference(of(\"Practitioner/\" + tag)).build())\n+                .managingOrganization(Reference.builder().reference(of(\"Organization/\" + organization2Id)).build())\n+                .birthDate(Date.of(now.minus(1, ChronoUnit.DAYS).toString().substring(0,10)))\n+                .telecom(ContactPoint.builder().system(ContactPointSystem.PHONE).value(of(\"2\" + tag)).build())\n+                .build();\n+\n+        Entity<Patient> entity = Entity.entity(patient, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Patient\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the patient's logical id value.\n+        patient2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new patient and verify it.\n+        response = target.path(\"Patient/\" + patient2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreatePatient1\"})\n+    public void testCreateProcedure1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Procedure and add subject reference to patient.\n+        Procedure procedure = TestUtil.getMinimalResource(ResourceType.PROCEDURE, Format.JSON);\n+        procedure = procedure.toBuilder()\n+                .status(ProcedureStatus.COMPLETED)\n+                .subject(Reference.builder().reference(of(\"Patient/\" + patient1Id)).build())\n+                .basedOn(Reference.builder().reference(of(\"CarePlan/\" + tag)).build())\n+                .performed(DateTime.of(now.toString()))\n+                .instantiatesUri(Uri.of(\"1\" + tag))\n+                .code(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"1\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Procedure> entity = Entity.entity(procedure, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Procedure\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the procedure's logical id value.\n+        procedure1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new procedure and verify it.\n+        response = target.path(\"Procedure/\" + procedure1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreatePatient2\"})\n+    public void testCreateProcedure2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        Reference reference = Reference.builder().reference(of(\"Patient/\" + patient2Id)).build();\n+\n+        // Build a new Procedure and add subject reference to patient.\n+        Procedure procedure = TestUtil.getMinimalResource(ResourceType.PROCEDURE, Format.JSON);\n+        procedure = procedure.toBuilder()\n+                .status(ProcedureStatus.COMPLETED)\n+                .subject(reference)\n+                .basedOn(Reference.builder().reference(of(\"ServiceRequest/\" + tag)).build())\n+                .performed(DateTime.of(now.minus(1, ChronoUnit.DAYS).toString()))\n+                .instantiatesUri(Uri.of(\"2\" + tag))\n+                .code(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"2\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Procedure> entity = Entity.entity(procedure, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Procedure\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the procedure's logical id value.\n+        procedure2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new procedure and verify it.\n+        response = target.path(\"Procedure/\" + procedure2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure1\", \"testCreateOrganization1\"})\n+    public void testCreateEncounter1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Encounter and add reason-reference reference to procedure.\n+        Encounter encounter = TestUtil.getMinimalResource(ResourceType.ENCOUNTER, Format.JSON);\n+        encounter = encounter.toBuilder()\n+                .status(EncounterStatus.FINISHED)\n+                .reasonReference(Reference.builder().reference(of(\"Procedure/\" + procedure1Id)).build())\n+                .serviceProvider(Reference.builder().reference(of(\"Organization/\" + organization1Id)).build())\n+                .period(Period.builder().start(DateTime.of(now.toString())).end(DateTime.of(now.toString())).build())\n+                .length(Duration.builder().system(Uri.of(\"http://unitsofmeasure.org\")).code(Code.of(\"s\")).value(Decimal.of(\"1\" + tag)).build())\n+                .type(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"1\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Encounter> entity = Entity.entity(encounter, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Encounter\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the encounter's logical id value.\n+        encounter1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new encounter and verify it.\n+        response = target.path(\"Encounter/\" + encounter1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure2\", \"testCreateOrganization2\"})\n+    public void testCreateEncounter2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Encounter and add reason-reference reference to procedure.\n+        Encounter encounter = TestUtil.getMinimalResource(ResourceType.ENCOUNTER, Format.JSON);\n+        encounter = encounter.toBuilder()\n+                .status(EncounterStatus.FINISHED)\n+                .reasonReference(Reference.builder().reference(of(\"Procedure/\" + procedure2Id)).build())\n+                .serviceProvider(Reference.builder().reference(of(\"Organization/\" + organization2Id)).build())\n+                .period(Period.builder().start(DateTime.of(now.minus(1, ChronoUnit.DAYS).toString())).end(DateTime.of(now.minus(1, ChronoUnit.DAYS).toString())).build())\n+                .length(Duration.builder().system(Uri.of(\"http://unitsofmeasure.org\")).code(Code.of(\"s\")).value(Decimal.of(\"2\" + tag)).build())\n+                .type(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"2\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Encounter> entity = Entity.entity(encounter, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Encounter\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the encounter's logical id value.\n+        encounter2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new encounter and verify it.\n+        response = target.path(\"Encounter/\" + encounter2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateOrganization1\"})\n+    public void testCreateLocation() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        Location location = TestUtil.readExampleResource(\"json/spec/location-example.json\");\n+        location = location.toBuilder()\n+                .managingOrganization(Reference.builder().reference(of(\"Organization/\" + organization1Id)).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Location> entity = Entity.entity(location, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Location\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the location's logical id value.\n+        locationId = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new Location and verify it.\n+        response   = target.path(\"Location/\" + locationId).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @AfterClass\n+    public void testDeleteResources() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "originalPosition": 347}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzU5Mjc5", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-523359279", "createdAt": "2020-11-04T13:29:29Z", "commit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzoyOTozMFrOHtYERQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzoyOTozMFrOHtYERQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0MjI3Nw==", "bodyText": "If I follow...\n1st part\n_has:Patient:patient:\nIt's always going to run the param.getChain (it'll have at least one entry)\nThen loops...\nOK - this makes sense to me - I just needed to write this out, leaving here for others as they review.", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517342277", "createdAt": "2020-11-04T13:29:30Z", "author": {"login": "prb112"}, "path": "fhir-search/src/main/java/com/ibm/fhir/search/uri/UriBuilder.java", "diffHunk": "@@ -279,4 +281,38 @@ private void appendChainedParm(QueryParameter param, StringBuilder returnString)\n         }\n     }\n \n+    /*\n+     * creates a reverse chained parameter\n+     *\n+     * @param param\n+     *\n+     * @param returnString\n+     */\n+    private void appendReverseChainedParm(QueryParameter param, StringBuilder returnString) {\n+        // Build initial string: \"_has:<reference-resource-type>:<refernece-search-parm>:\n+        returnString.append(SearchConstants.HAS)\n+                    .append(SearchConstants.COLON_DELIMITER)\n+                    .append(param.getModifierResourceTypeName())\n+                    .append(SearchConstants.COLON_DELIMITER)\n+                    .append(param.getCode())\n+                    .append(SearchConstants.COLON_DELIMITER);\n+\n+        // Loop through chained parms to build chained strings\n+        for (QueryParameter revChainParam : param.getChain()) {\n+            if (revChainParam.isReverseChained()) {\n+                returnString.append(SearchConstants.HAS)\n+                            .append(SearchConstants.COLON_DELIMITER)\n+                            .append(revChainParam.getModifierResourceTypeName())\n+                            .append(SearchConstants.COLON_DELIMITER)\n+                            .append(revChainParam.getCode())\n+                            .append(SearchConstants.COLON_DELIMITER);\n+            } else if (revChainParam.isChained()) {\n+                appendChainedParm(revChainParam, returnString);\n+                returnString.append(SearchConstants.CHAINED_PARAMETER_CHARACTER);\n+            } else {\n+                appendNormalParameter(revChainParam, returnString);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "originalPosition": 60}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzYwMTgw", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-523360180", "createdAt": "2020-11-04T13:30:35Z", "commit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzozMDozNVrOHtYG6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzozMDozNVrOHtYG6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0Mjk1NQ==", "bodyText": "good test", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517342955", "createdAt": "2020-11-04T13:30:35Z", "author": {"login": "prb112"}, "path": "fhir-search/src/test/java/com/ibm/fhir/search/test/RevChainParameterParseTest.java", "diffHunk": "@@ -0,0 +1,777 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.search.test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertNull;\n+import static org.testng.Assert.assertTrue;\n+\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.testng.annotations.Test;\n+\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Resource;\n+import com.ibm.fhir.search.SearchConstants.Modifier;\n+import com.ibm.fhir.search.SearchConstants.Type;\n+import com.ibm.fhir.search.context.FHIRSearchContext;\n+import com.ibm.fhir.search.exception.FHIRSearchException;\n+import com.ibm.fhir.search.parameters.QueryParameter;\n+import com.ibm.fhir.search.parameters.QueryParameterValue;\n+import com.ibm.fhir.search.util.SearchUtil;\n+\n+/**\n+ * This TestNG test class contains methods that test the parsing of reverse chain search parameters\n+ * (_has) in the SearchUtil class.\n+ */\n+public class RevChainParameterParseTest extends BaseSearchTest {\n+\n+    @Test(expectedExceptions = FHIRSearchException.class)\n+    public void testReverseChainWithTypeException() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Resource> resourceType = Resource.class;\n+\n+        queryParameters.put(\"_type\", Collections.singletonList(\"Patient\"));\n+        queryParameters.put(\"_has:Observation:subject:code\", Collections.singletonList(\"xxx\"));\n+        SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+    }\n+\n+    @Test(expectedExceptions = FHIRSearchException.class)\n+    public void testReverseChainParseException1() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Patient> resourceType = Patient.class;\n+\n+        queryParameters.put(\"_has\", Collections.singletonList(\"xxx\"));\n+        SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+    }\n+\n+    @Test(expectedExceptions = FHIRSearchException.class)\n+    public void testReverseChainParseException2() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Patient> resourceType = Patient.class;\n+\n+        queryParameters.put(\"_has:Observation\", Collections.singletonList(\"xxx\"));\n+        SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+    }\n+\n+    @Test(expectedExceptions = FHIRSearchException.class)\n+    public void testReverseChainParseException3() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Patient> resourceType = Patient.class;\n+\n+        queryParameters.put(\"_has:Procedure:subject:extra:_has:Encounter:reason-reference:status\", Collections.singletonList(\"xxx\"));\n+        SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+    }\n+\n+    @Test(expectedExceptions = FHIRSearchException.class)\n+    public void testReverseChainBadReferenceTypeException() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Patient> resourceType = Patient.class;\n+\n+        queryParameters.put(\"_has:BadType:subject:code\", Collections.singletonList(\"xxx\"));\n+        SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+    }\n+\n+    @Test(expectedExceptions = FHIRSearchException.class)\n+    public void testReverseChainBadReferenceSearchParmException() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Patient> resourceType = Patient.class;\n+\n+        queryParameters.put(\"_has:Procedure:badSearchParm:code\", Collections.singletonList(\"xxx\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "originalPosition": 92}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzYyNDUy", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-523362452", "createdAt": "2020-11-04T13:33:23Z", "commit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzozMzoyNFrOHtYNlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzozMzoyNFrOHtYNlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0NDY2MQ==", "bodyText": "slight comment\nIn Exception cases String.format, we as a team deem it to be OK, but it is actually slower than assembling a string.  (I mention this as John and I had a deep discussion about StringBuilding performance when I made a similar change in this class).", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517344661", "createdAt": "2020-11-04T13:33:24Z", "author": {"login": "prb112"}, "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -756,20 +772,16 @@ public static FHIRSearchContext parseQueryParameters(Class<?> resourceType,\n                           // Get the search parameter from our filtered set of applicable SPs for this resource type.\n                           searchParameter = getSearchParameter(resType, parameterCode);\n                           if (searchParameter == null) {\n-                              String msg =\n-                                      \"Search parameter '\" + parameterCode + \"' for resource type '\"\n-                                              + resType + \"' was not found.\";\n-                              throw SearchExceptionUtil.buildNewInvalidSearchException(msg);\n+                              throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                                  String.format(SEARCH_PARAMETER_NOT_FOUND, parameterCode, resType));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "originalPosition": 54}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzYzODg0", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-523363884", "createdAt": "2020-11-04T13:35:13Z", "commit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzozNToxM1rOHtYSGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzozNToxM1rOHtYSGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0NTgxOQ==", "bodyText": "mentioning this as it's the Eclipse Formatter control (turns on/off)\n@formatter:off \n@formatter:on", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517345819", "createdAt": "2020-11-04T13:35:13Z", "author": {"login": "prb112"}, "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -1589,6 +1605,168 @@ private static QueryParameter parseChainedParameter(Class<?> resourceType, Strin\n         return rootParameter;\n     }\n \n+    /**\n+     * Transforms the passed string representing reverse chain search criteria, into\n+     * an actual chain of QueryParameter objects. This method consumes strings of this form:\n+     * <pre>\n+     *      +-------------------------------------------------------------------+\n+     *      |                                                                   |\n+     *      V                                                                   |\n+     * >>---+--- \"_has:{referenced-by-resource-type}:{reference-parameter}:\" ---+--- \"{search-parameter}\" ---><\n+     * </pre>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "originalPosition": 102}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzY0NTk5", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-523364599", "createdAt": "2020-11-04T13:36:07Z", "commit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzozNjowN1rOHtYUfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzozNjowN1rOHtYUfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0NjQzMQ==", "bodyText": "It's actually a code.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static boolean isReverseChainedParameter(String name) {\n          \n          \n            \n                public static boolean isReverseChainedParameter(String code) {", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517346431", "createdAt": "2020-11-04T13:36:07Z", "author": {"login": "prb112"}, "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -1370,6 +1382,10 @@ public static boolean isChainedParameter(String name) {\n         return name.contains(SearchConstants.CHAINED_PARAMETER_CHARACTER);\n     }\n \n+    public static boolean isReverseChainedParameter(String name) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "originalPosition": 83}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzY0NzIx", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-523364721", "createdAt": "2020-11-04T13:36:16Z", "commit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzozNjoxNlrOHtYU2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzozNjoxNlrOHtYU2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0NjUyMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return name.startsWith(SearchConstants.HAS);\n          \n          \n            \n                    return code.startsWith(SearchConstants.HAS);", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517346522", "createdAt": "2020-11-04T13:36:16Z", "author": {"login": "prb112"}, "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -1370,6 +1382,10 @@ public static boolean isChainedParameter(String name) {\n         return name.contains(SearchConstants.CHAINED_PARAMETER_CHARACTER);\n     }\n \n+    public static boolean isReverseChainedParameter(String name) {\n+        return name.startsWith(SearchConstants.HAS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "originalPosition": 84}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzY1ODky", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-523365892", "createdAt": "2020-11-04T13:37:35Z", "commit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzozNzozNVrOHtYYZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzozNzozNVrOHtYYZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0NzQzMQ==", "bodyText": "I think substring might be preferred here instead of replaceFirst. it'll always be a fixed length.", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517347431", "createdAt": "2020-11-04T13:37:35Z", "author": {"login": "prb112"}, "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -1589,6 +1605,168 @@ private static QueryParameter parseChainedParameter(Class<?> resourceType, Strin\n         return rootParameter;\n     }\n \n+    /**\n+     * Transforms the passed string representing reverse chain search criteria, into\n+     * an actual chain of QueryParameter objects. This method consumes strings of this form:\n+     * <pre>\n+     *      +-------------------------------------------------------------------+\n+     *      |                                                                   |\n+     *      V                                                                   |\n+     * >>---+--- \"_has:{referenced-by-resource-type}:{reference-parameter}:\" ---+--- \"{search-parameter}\" ---><\n+     * </pre>\n+     * See the FHIR specification for details:\n+     * <a href=\"https://www.hl7.org/fhir/search.html#has</a>\n+     *\n+     * @param resourceType\n+     *          Search type.\n+     * @param reverseChainParameterString\n+     *          Reverse chain search parameter string.\n+     * @param valuesString\n+     *          String containing the final search value.\n+     * @return QueryParameter\n+     *          The root of a parameter chain for the reverse chain criteria.\n+     */\n+    private static QueryParameter parseReverseChainedParameter(Class<?> resourceType, String reverseChainParameterString, String valuesString) throws Exception {\n+\n+        QueryParameter rootParameter = null;\n+\n+        try {\n+            // Strip leading '_has:' and then split by ':_has:'\n+            List<String> components = Arrays.asList(reverseChainParameterString\n+                .replaceFirst(SearchConstants.HAS + SearchConstants.COLON_DELIMITER_STR, \"\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "originalPosition": 122}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzY2NTcz", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-523366573", "createdAt": "2020-11-04T13:38:25Z", "commit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzozODoyNVrOHtYaRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzozODoyNVrOHtYaRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0NzkxMA==", "bodyText": "I'm almost positive in modern compilers this ends up getting inlined, however, it's worth making your own static final constant.", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517347910", "createdAt": "2020-11-04T13:38:25Z", "author": {"login": "prb112"}, "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -1589,6 +1605,168 @@ private static QueryParameter parseChainedParameter(Class<?> resourceType, Strin\n         return rootParameter;\n     }\n \n+    /**\n+     * Transforms the passed string representing reverse chain search criteria, into\n+     * an actual chain of QueryParameter objects. This method consumes strings of this form:\n+     * <pre>\n+     *      +-------------------------------------------------------------------+\n+     *      |                                                                   |\n+     *      V                                                                   |\n+     * >>---+--- \"_has:{referenced-by-resource-type}:{reference-parameter}:\" ---+--- \"{search-parameter}\" ---><\n+     * </pre>\n+     * See the FHIR specification for details:\n+     * <a href=\"https://www.hl7.org/fhir/search.html#has</a>\n+     *\n+     * @param resourceType\n+     *          Search type.\n+     * @param reverseChainParameterString\n+     *          Reverse chain search parameter string.\n+     * @param valuesString\n+     *          String containing the final search value.\n+     * @return QueryParameter\n+     *          The root of a parameter chain for the reverse chain criteria.\n+     */\n+    private static QueryParameter parseReverseChainedParameter(Class<?> resourceType, String reverseChainParameterString, String valuesString) throws Exception {\n+\n+        QueryParameter rootParameter = null;\n+\n+        try {\n+            // Strip leading '_has:' and then split by ':_has:'\n+            List<String> components = Arrays.asList(reverseChainParameterString\n+                .replaceFirst(SearchConstants.HAS + SearchConstants.COLON_DELIMITER_STR, \"\")\n+                .split(SearchConstants.COLON_DELIMITER_STR + SearchConstants.HAS + SearchConstants.COLON_DELIMITER_STR));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "originalPosition": 123}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzcwMDUz", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-523370053", "createdAt": "2020-11-04T13:42:35Z", "commit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo0MjozNVrOHtYlFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo0MjozNVrOHtYlFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1MDY3OA==", "bodyText": "at this point in the code would referenceSearchParameter.getType ever be null?\nI don't think so at this point in the model this will be null as the type | \u03a3 | 1..1 | code\nThis is good.  Leaving my note here.", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517350678", "createdAt": "2020-11-04T13:42:35Z", "author": {"login": "prb112"}, "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -1589,6 +1605,168 @@ private static QueryParameter parseChainedParameter(Class<?> resourceType, Strin\n         return rootParameter;\n     }\n \n+    /**\n+     * Transforms the passed string representing reverse chain search criteria, into\n+     * an actual chain of QueryParameter objects. This method consumes strings of this form:\n+     * <pre>\n+     *      +-------------------------------------------------------------------+\n+     *      |                                                                   |\n+     *      V                                                                   |\n+     * >>---+--- \"_has:{referenced-by-resource-type}:{reference-parameter}:\" ---+--- \"{search-parameter}\" ---><\n+     * </pre>\n+     * See the FHIR specification for details:\n+     * <a href=\"https://www.hl7.org/fhir/search.html#has</a>\n+     *\n+     * @param resourceType\n+     *          Search type.\n+     * @param reverseChainParameterString\n+     *          Reverse chain search parameter string.\n+     * @param valuesString\n+     *          String containing the final search value.\n+     * @return QueryParameter\n+     *          The root of a parameter chain for the reverse chain criteria.\n+     */\n+    private static QueryParameter parseReverseChainedParameter(Class<?> resourceType, String reverseChainParameterString, String valuesString) throws Exception {\n+\n+        QueryParameter rootParameter = null;\n+\n+        try {\n+            // Strip leading '_has:' and then split by ':_has:'\n+            List<String> components = Arrays.asList(reverseChainParameterString\n+                .replaceFirst(SearchConstants.HAS + SearchConstants.COLON_DELIMITER_STR, \"\")\n+                .split(SearchConstants.COLON_DELIMITER_STR + SearchConstants.HAS + SearchConstants.COLON_DELIMITER_STR));\n+\n+            if (components.size() == 0) {\n+                throw SearchExceptionUtil.buildNewInvalidSearchException(INCORRECT_NUMBER_OF_COMPONENTS_FOR_REVERSE_CHAIN_SEARCH);\n+            }\n+\n+            int currentIndex = 0;\n+            int lastIndex = components.size() - 1;\n+\n+            for (String component : components) {\n+                // Split into subcomponents by colon delimiter\n+                List<String> subcomponents = Arrays.asList(component.split(SearchConstants.COLON_DELIMITER_STR, 3));\n+\n+                // Validate correct number of subcomponents\n+                if ((currentIndex < lastIndex && subcomponents.size() != 2) ||\n+                        (currentIndex == lastIndex && subcomponents.size() != 3)) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(INCORRECT_NUMBER_OF_COMPONENTS_FOR_REVERSE_CHAIN_SEARCH);\n+                }\n+\n+                // Validate referenced-by resource type\n+                String referencedByResourceTypeName = subcomponents.get(0);\n+                Class<? extends Resource> referencedByResourceType = ModelSupport.getResourceType(referencedByResourceTypeName);\n+                if (referencedByResourceType == null) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                        String.format(INVALID_RESOURCE_TYPE_FOR_REVERSE_CHAIN_SEARCH, referencedByResourceTypeName));\n+                }\n+\n+                // Validate reference search parameter\n+                String referenceSearchParameterName = subcomponents.get(1);\n+                SearchParameter referenceSearchParameter = getSearchParameter(referencedByResourceType, referenceSearchParameterName);\n+                if (referenceSearchParameter == null) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                        String.format(SEARCH_PARAMETER_NOT_FOUND, referenceSearchParameterName, referencedByResourceTypeName));\n+                }\n+                if (!Type.REFERENCE.equals(Type.fromValue(referenceSearchParameter.getType().getValue()))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "originalPosition": 157}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzcwNTky", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-523370592", "createdAt": "2020-11-04T13:43:14Z", "commit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo0MzoxNFrOHtYm1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo0MzoxNFrOHtYm1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1MTEyNw==", "bodyText": "This can only be an emptyList in the worst case.  I think this is good.", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517351127", "createdAt": "2020-11-04T13:43:14Z", "author": {"login": "prb112"}, "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -1589,6 +1605,168 @@ private static QueryParameter parseChainedParameter(Class<?> resourceType, Strin\n         return rootParameter;\n     }\n \n+    /**\n+     * Transforms the passed string representing reverse chain search criteria, into\n+     * an actual chain of QueryParameter objects. This method consumes strings of this form:\n+     * <pre>\n+     *      +-------------------------------------------------------------------+\n+     *      |                                                                   |\n+     *      V                                                                   |\n+     * >>---+--- \"_has:{referenced-by-resource-type}:{reference-parameter}:\" ---+--- \"{search-parameter}\" ---><\n+     * </pre>\n+     * See the FHIR specification for details:\n+     * <a href=\"https://www.hl7.org/fhir/search.html#has</a>\n+     *\n+     * @param resourceType\n+     *          Search type.\n+     * @param reverseChainParameterString\n+     *          Reverse chain search parameter string.\n+     * @param valuesString\n+     *          String containing the final search value.\n+     * @return QueryParameter\n+     *          The root of a parameter chain for the reverse chain criteria.\n+     */\n+    private static QueryParameter parseReverseChainedParameter(Class<?> resourceType, String reverseChainParameterString, String valuesString) throws Exception {\n+\n+        QueryParameter rootParameter = null;\n+\n+        try {\n+            // Strip leading '_has:' and then split by ':_has:'\n+            List<String> components = Arrays.asList(reverseChainParameterString\n+                .replaceFirst(SearchConstants.HAS + SearchConstants.COLON_DELIMITER_STR, \"\")\n+                .split(SearchConstants.COLON_DELIMITER_STR + SearchConstants.HAS + SearchConstants.COLON_DELIMITER_STR));\n+\n+            if (components.size() == 0) {\n+                throw SearchExceptionUtil.buildNewInvalidSearchException(INCORRECT_NUMBER_OF_COMPONENTS_FOR_REVERSE_CHAIN_SEARCH);\n+            }\n+\n+            int currentIndex = 0;\n+            int lastIndex = components.size() - 1;\n+\n+            for (String component : components) {\n+                // Split into subcomponents by colon delimiter\n+                List<String> subcomponents = Arrays.asList(component.split(SearchConstants.COLON_DELIMITER_STR, 3));\n+\n+                // Validate correct number of subcomponents\n+                if ((currentIndex < lastIndex && subcomponents.size() != 2) ||\n+                        (currentIndex == lastIndex && subcomponents.size() != 3)) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(INCORRECT_NUMBER_OF_COMPONENTS_FOR_REVERSE_CHAIN_SEARCH);\n+                }\n+\n+                // Validate referenced-by resource type\n+                String referencedByResourceTypeName = subcomponents.get(0);\n+                Class<? extends Resource> referencedByResourceType = ModelSupport.getResourceType(referencedByResourceTypeName);\n+                if (referencedByResourceType == null) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                        String.format(INVALID_RESOURCE_TYPE_FOR_REVERSE_CHAIN_SEARCH, referencedByResourceTypeName));\n+                }\n+\n+                // Validate reference search parameter\n+                String referenceSearchParameterName = subcomponents.get(1);\n+                SearchParameter referenceSearchParameter = getSearchParameter(referencedByResourceType, referenceSearchParameterName);\n+                if (referenceSearchParameter == null) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                        String.format(SEARCH_PARAMETER_NOT_FOUND, referenceSearchParameterName, referencedByResourceTypeName));\n+                }\n+                if (!Type.REFERENCE.equals(Type.fromValue(referenceSearchParameter.getType().getValue()))) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                        String.format(PARAMETER_TYPE_NOT_REFERENCE_FOR_REVERSE_CHAIN_SEARCH, referenceSearchParameterName));\n+                }\n+\n+                // Validate resource type is one of the reference search parameter target resource types\n+                if (!referenceSearchParameter.getTarget().contains(ResourceType.of(resourceType.getSimpleName()))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "originalPosition": 163}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzcwODk2", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-523370896", "createdAt": "2020-11-04T13:43:35Z", "commit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo0MzozNVrOHtYnvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo0MzozNVrOHtYnvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1MTM1Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            } else {\n          \n          \n            \n                                if (rootParameter.getChain().isEmpty()) {\n          \n          \n            \n                            } else if (rootParameter.getChain().isEmpty()) {", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517351357", "createdAt": "2020-11-04T13:43:35Z", "author": {"login": "prb112"}, "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -1589,6 +1605,168 @@ private static QueryParameter parseChainedParameter(Class<?> resourceType, Strin\n         return rootParameter;\n     }\n \n+    /**\n+     * Transforms the passed string representing reverse chain search criteria, into\n+     * an actual chain of QueryParameter objects. This method consumes strings of this form:\n+     * <pre>\n+     *      +-------------------------------------------------------------------+\n+     *      |                                                                   |\n+     *      V                                                                   |\n+     * >>---+--- \"_has:{referenced-by-resource-type}:{reference-parameter}:\" ---+--- \"{search-parameter}\" ---><\n+     * </pre>\n+     * See the FHIR specification for details:\n+     * <a href=\"https://www.hl7.org/fhir/search.html#has</a>\n+     *\n+     * @param resourceType\n+     *          Search type.\n+     * @param reverseChainParameterString\n+     *          Reverse chain search parameter string.\n+     * @param valuesString\n+     *          String containing the final search value.\n+     * @return QueryParameter\n+     *          The root of a parameter chain for the reverse chain criteria.\n+     */\n+    private static QueryParameter parseReverseChainedParameter(Class<?> resourceType, String reverseChainParameterString, String valuesString) throws Exception {\n+\n+        QueryParameter rootParameter = null;\n+\n+        try {\n+            // Strip leading '_has:' and then split by ':_has:'\n+            List<String> components = Arrays.asList(reverseChainParameterString\n+                .replaceFirst(SearchConstants.HAS + SearchConstants.COLON_DELIMITER_STR, \"\")\n+                .split(SearchConstants.COLON_DELIMITER_STR + SearchConstants.HAS + SearchConstants.COLON_DELIMITER_STR));\n+\n+            if (components.size() == 0) {\n+                throw SearchExceptionUtil.buildNewInvalidSearchException(INCORRECT_NUMBER_OF_COMPONENTS_FOR_REVERSE_CHAIN_SEARCH);\n+            }\n+\n+            int currentIndex = 0;\n+            int lastIndex = components.size() - 1;\n+\n+            for (String component : components) {\n+                // Split into subcomponents by colon delimiter\n+                List<String> subcomponents = Arrays.asList(component.split(SearchConstants.COLON_DELIMITER_STR, 3));\n+\n+                // Validate correct number of subcomponents\n+                if ((currentIndex < lastIndex && subcomponents.size() != 2) ||\n+                        (currentIndex == lastIndex && subcomponents.size() != 3)) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(INCORRECT_NUMBER_OF_COMPONENTS_FOR_REVERSE_CHAIN_SEARCH);\n+                }\n+\n+                // Validate referenced-by resource type\n+                String referencedByResourceTypeName = subcomponents.get(0);\n+                Class<? extends Resource> referencedByResourceType = ModelSupport.getResourceType(referencedByResourceTypeName);\n+                if (referencedByResourceType == null) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                        String.format(INVALID_RESOURCE_TYPE_FOR_REVERSE_CHAIN_SEARCH, referencedByResourceTypeName));\n+                }\n+\n+                // Validate reference search parameter\n+                String referenceSearchParameterName = subcomponents.get(1);\n+                SearchParameter referenceSearchParameter = getSearchParameter(referencedByResourceType, referenceSearchParameterName);\n+                if (referenceSearchParameter == null) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                        String.format(SEARCH_PARAMETER_NOT_FOUND, referenceSearchParameterName, referencedByResourceTypeName));\n+                }\n+                if (!Type.REFERENCE.equals(Type.fromValue(referenceSearchParameter.getType().getValue()))) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                        String.format(PARAMETER_TYPE_NOT_REFERENCE_FOR_REVERSE_CHAIN_SEARCH, referenceSearchParameterName));\n+                }\n+\n+                // Validate resource type is one of the reference search parameter target resource types\n+                if (!referenceSearchParameter.getTarget().contains(ResourceType.of(resourceType.getSimpleName()))) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                        String.format(TARGET_TYPE_OF_REFERENCE_PARAMETER_NOT_VALID_FOR_REVERSE_CHAIN_SEARCH,\n+                            referenceSearchParameterName, resourceType.getSimpleName()));\n+                }\n+\n+                // Create new QueryParameter\n+                QueryParameter parameter = new QueryParameter(Type.REFERENCE, referenceSearchParameterName, Modifier.TYPE, referencedByResourceTypeName, false, true);\n+                if (rootParameter == null) {\n+                    rootParameter = parameter;\n+                } else {\n+                    if (rootParameter.getChain().isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "originalPosition": 174}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzcyMzY3", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-523372367", "createdAt": "2020-11-04T13:45:21Z", "commit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo0NToyMVrOHtYsFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo0NToyMVrOHtYsFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1MjQ2OA==", "bodyText": "we should probably surround the modifierName with single quotes\nWe might want to URL encode it as well", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517352468", "createdAt": "2020-11-04T13:45:21Z", "author": {"login": "prb112"}, "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -1589,6 +1605,168 @@ private static QueryParameter parseChainedParameter(Class<?> resourceType, Strin\n         return rootParameter;\n     }\n \n+    /**\n+     * Transforms the passed string representing reverse chain search criteria, into\n+     * an actual chain of QueryParameter objects. This method consumes strings of this form:\n+     * <pre>\n+     *      +-------------------------------------------------------------------+\n+     *      |                                                                   |\n+     *      V                                                                   |\n+     * >>---+--- \"_has:{referenced-by-resource-type}:{reference-parameter}:\" ---+--- \"{search-parameter}\" ---><\n+     * </pre>\n+     * See the FHIR specification for details:\n+     * <a href=\"https://www.hl7.org/fhir/search.html#has</a>\n+     *\n+     * @param resourceType\n+     *          Search type.\n+     * @param reverseChainParameterString\n+     *          Reverse chain search parameter string.\n+     * @param valuesString\n+     *          String containing the final search value.\n+     * @return QueryParameter\n+     *          The root of a parameter chain for the reverse chain criteria.\n+     */\n+    private static QueryParameter parseReverseChainedParameter(Class<?> resourceType, String reverseChainParameterString, String valuesString) throws Exception {\n+\n+        QueryParameter rootParameter = null;\n+\n+        try {\n+            // Strip leading '_has:' and then split by ':_has:'\n+            List<String> components = Arrays.asList(reverseChainParameterString\n+                .replaceFirst(SearchConstants.HAS + SearchConstants.COLON_DELIMITER_STR, \"\")\n+                .split(SearchConstants.COLON_DELIMITER_STR + SearchConstants.HAS + SearchConstants.COLON_DELIMITER_STR));\n+\n+            if (components.size() == 0) {\n+                throw SearchExceptionUtil.buildNewInvalidSearchException(INCORRECT_NUMBER_OF_COMPONENTS_FOR_REVERSE_CHAIN_SEARCH);\n+            }\n+\n+            int currentIndex = 0;\n+            int lastIndex = components.size() - 1;\n+\n+            for (String component : components) {\n+                // Split into subcomponents by colon delimiter\n+                List<String> subcomponents = Arrays.asList(component.split(SearchConstants.COLON_DELIMITER_STR, 3));\n+\n+                // Validate correct number of subcomponents\n+                if ((currentIndex < lastIndex && subcomponents.size() != 2) ||\n+                        (currentIndex == lastIndex && subcomponents.size() != 3)) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(INCORRECT_NUMBER_OF_COMPONENTS_FOR_REVERSE_CHAIN_SEARCH);\n+                }\n+\n+                // Validate referenced-by resource type\n+                String referencedByResourceTypeName = subcomponents.get(0);\n+                Class<? extends Resource> referencedByResourceType = ModelSupport.getResourceType(referencedByResourceTypeName);\n+                if (referencedByResourceType == null) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                        String.format(INVALID_RESOURCE_TYPE_FOR_REVERSE_CHAIN_SEARCH, referencedByResourceTypeName));\n+                }\n+\n+                // Validate reference search parameter\n+                String referenceSearchParameterName = subcomponents.get(1);\n+                SearchParameter referenceSearchParameter = getSearchParameter(referencedByResourceType, referenceSearchParameterName);\n+                if (referenceSearchParameter == null) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                        String.format(SEARCH_PARAMETER_NOT_FOUND, referenceSearchParameterName, referencedByResourceTypeName));\n+                }\n+                if (!Type.REFERENCE.equals(Type.fromValue(referenceSearchParameter.getType().getValue()))) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                        String.format(PARAMETER_TYPE_NOT_REFERENCE_FOR_REVERSE_CHAIN_SEARCH, referenceSearchParameterName));\n+                }\n+\n+                // Validate resource type is one of the reference search parameter target resource types\n+                if (!referenceSearchParameter.getTarget().contains(ResourceType.of(resourceType.getSimpleName()))) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                        String.format(TARGET_TYPE_OF_REFERENCE_PARAMETER_NOT_VALID_FOR_REVERSE_CHAIN_SEARCH,\n+                            referenceSearchParameterName, resourceType.getSimpleName()));\n+                }\n+\n+                // Create new QueryParameter\n+                QueryParameter parameter = new QueryParameter(Type.REFERENCE, referenceSearchParameterName, Modifier.TYPE, referencedByResourceTypeName, false, true);\n+                if (rootParameter == null) {\n+                    rootParameter = parameter;\n+                } else {\n+                    if (rootParameter.getChain().isEmpty()) {\n+                        rootParameter.setNextParameter(parameter);\n+                    } else {\n+                        rootParameter.getChain().getLast().setNextParameter(parameter);\n+                    }\n+                }\n+\n+                if (currentIndex == lastIndex) {\n+                    // Add last search parameter\n+                    String parameterName = subcomponents.get(2);\n+                    if (isChainedParameter(parameterName)) {\n+                        QueryParameter lastParameter = parseChainedParameter(referencedByResourceType, parameterName, valuesString);\n+                        if (rootParameter.getChain().isEmpty()) {\n+                            rootParameter.setNextParameter(lastParameter);\n+                        } else {\n+                            rootParameter.getChain().getLast().setNextParameter(lastParameter);\n+                        }\n+                    } else {\n+                        String modifierName = null;\n+                        Modifier modifier = null;\n+                        String modifierResourceTypeName = null;\n+\n+                        // Check if modifier is specified\n+                        int index = parameterName.indexOf(\":\");\n+                        if (index != -1) {\n+                            modifierName = parameterName.substring(index + 1);\n+                            parameterName = parameterName.substring(0, index);\n+                        }\n+\n+                        SearchParameter searchParameter = getSearchParameter(referencedByResourceType, parameterName);\n+                        if (searchParameter == null) {\n+                            throw SearchExceptionUtil.buildNewInvalidSearchException(String.format(SEARCH_PARAMETER_NOT_FOUND, parameterName, referencedByResourceTypeName));\n+                        }\n+                        Type type = Type.fromValue(searchParameter.getType().getValue());\n+\n+                        if (modifierName != null) {\n+                            if (ModelSupport.isResourceType(modifierName)) {\n+                                modifier = Modifier.TYPE;\n+                                modifierResourceTypeName = modifierName;\n+                            } else {\n+                                try {\n+                                    modifier = Modifier.fromValue(modifierName);\n+                                } catch (IllegalArgumentException e) {\n+                                    String msg = \"Undefined Modifier: \" + modifierName;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "originalPosition": 217}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzcyODA1", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-523372805", "createdAt": "2020-11-04T13:45:54Z", "commit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo0NTo1NFrOHtYteA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo0NTo1NFrOHtYteA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1MjgyNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                            String msg = \"Unsupported type/modifier combination: \" + type.value() + \"/\" + modifier.value();\n          \n          \n            \n                                            String msg = \"Unsupported type/modifier combination: '\" + type.value() + \"/\" + modifier.value() +\"'\";\n          \n      \n    \n    \n  \n\nAdd single quotes", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517352824", "createdAt": "2020-11-04T13:45:54Z", "author": {"login": "prb112"}, "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -1589,6 +1605,168 @@ private static QueryParameter parseChainedParameter(Class<?> resourceType, Strin\n         return rootParameter;\n     }\n \n+    /**\n+     * Transforms the passed string representing reverse chain search criteria, into\n+     * an actual chain of QueryParameter objects. This method consumes strings of this form:\n+     * <pre>\n+     *      +-------------------------------------------------------------------+\n+     *      |                                                                   |\n+     *      V                                                                   |\n+     * >>---+--- \"_has:{referenced-by-resource-type}:{reference-parameter}:\" ---+--- \"{search-parameter}\" ---><\n+     * </pre>\n+     * See the FHIR specification for details:\n+     * <a href=\"https://www.hl7.org/fhir/search.html#has</a>\n+     *\n+     * @param resourceType\n+     *          Search type.\n+     * @param reverseChainParameterString\n+     *          Reverse chain search parameter string.\n+     * @param valuesString\n+     *          String containing the final search value.\n+     * @return QueryParameter\n+     *          The root of a parameter chain for the reverse chain criteria.\n+     */\n+    private static QueryParameter parseReverseChainedParameter(Class<?> resourceType, String reverseChainParameterString, String valuesString) throws Exception {\n+\n+        QueryParameter rootParameter = null;\n+\n+        try {\n+            // Strip leading '_has:' and then split by ':_has:'\n+            List<String> components = Arrays.asList(reverseChainParameterString\n+                .replaceFirst(SearchConstants.HAS + SearchConstants.COLON_DELIMITER_STR, \"\")\n+                .split(SearchConstants.COLON_DELIMITER_STR + SearchConstants.HAS + SearchConstants.COLON_DELIMITER_STR));\n+\n+            if (components.size() == 0) {\n+                throw SearchExceptionUtil.buildNewInvalidSearchException(INCORRECT_NUMBER_OF_COMPONENTS_FOR_REVERSE_CHAIN_SEARCH);\n+            }\n+\n+            int currentIndex = 0;\n+            int lastIndex = components.size() - 1;\n+\n+            for (String component : components) {\n+                // Split into subcomponents by colon delimiter\n+                List<String> subcomponents = Arrays.asList(component.split(SearchConstants.COLON_DELIMITER_STR, 3));\n+\n+                // Validate correct number of subcomponents\n+                if ((currentIndex < lastIndex && subcomponents.size() != 2) ||\n+                        (currentIndex == lastIndex && subcomponents.size() != 3)) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(INCORRECT_NUMBER_OF_COMPONENTS_FOR_REVERSE_CHAIN_SEARCH);\n+                }\n+\n+                // Validate referenced-by resource type\n+                String referencedByResourceTypeName = subcomponents.get(0);\n+                Class<? extends Resource> referencedByResourceType = ModelSupport.getResourceType(referencedByResourceTypeName);\n+                if (referencedByResourceType == null) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                        String.format(INVALID_RESOURCE_TYPE_FOR_REVERSE_CHAIN_SEARCH, referencedByResourceTypeName));\n+                }\n+\n+                // Validate reference search parameter\n+                String referenceSearchParameterName = subcomponents.get(1);\n+                SearchParameter referenceSearchParameter = getSearchParameter(referencedByResourceType, referenceSearchParameterName);\n+                if (referenceSearchParameter == null) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                        String.format(SEARCH_PARAMETER_NOT_FOUND, referenceSearchParameterName, referencedByResourceTypeName));\n+                }\n+                if (!Type.REFERENCE.equals(Type.fromValue(referenceSearchParameter.getType().getValue()))) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                        String.format(PARAMETER_TYPE_NOT_REFERENCE_FOR_REVERSE_CHAIN_SEARCH, referenceSearchParameterName));\n+                }\n+\n+                // Validate resource type is one of the reference search parameter target resource types\n+                if (!referenceSearchParameter.getTarget().contains(ResourceType.of(resourceType.getSimpleName()))) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                        String.format(TARGET_TYPE_OF_REFERENCE_PARAMETER_NOT_VALID_FOR_REVERSE_CHAIN_SEARCH,\n+                            referenceSearchParameterName, resourceType.getSimpleName()));\n+                }\n+\n+                // Create new QueryParameter\n+                QueryParameter parameter = new QueryParameter(Type.REFERENCE, referenceSearchParameterName, Modifier.TYPE, referencedByResourceTypeName, false, true);\n+                if (rootParameter == null) {\n+                    rootParameter = parameter;\n+                } else {\n+                    if (rootParameter.getChain().isEmpty()) {\n+                        rootParameter.setNextParameter(parameter);\n+                    } else {\n+                        rootParameter.getChain().getLast().setNextParameter(parameter);\n+                    }\n+                }\n+\n+                if (currentIndex == lastIndex) {\n+                    // Add last search parameter\n+                    String parameterName = subcomponents.get(2);\n+                    if (isChainedParameter(parameterName)) {\n+                        QueryParameter lastParameter = parseChainedParameter(referencedByResourceType, parameterName, valuesString);\n+                        if (rootParameter.getChain().isEmpty()) {\n+                            rootParameter.setNextParameter(lastParameter);\n+                        } else {\n+                            rootParameter.getChain().getLast().setNextParameter(lastParameter);\n+                        }\n+                    } else {\n+                        String modifierName = null;\n+                        Modifier modifier = null;\n+                        String modifierResourceTypeName = null;\n+\n+                        // Check if modifier is specified\n+                        int index = parameterName.indexOf(\":\");\n+                        if (index != -1) {\n+                            modifierName = parameterName.substring(index + 1);\n+                            parameterName = parameterName.substring(0, index);\n+                        }\n+\n+                        SearchParameter searchParameter = getSearchParameter(referencedByResourceType, parameterName);\n+                        if (searchParameter == null) {\n+                            throw SearchExceptionUtil.buildNewInvalidSearchException(String.format(SEARCH_PARAMETER_NOT_FOUND, parameterName, referencedByResourceTypeName));\n+                        }\n+                        Type type = Type.fromValue(searchParameter.getType().getValue());\n+\n+                        if (modifierName != null) {\n+                            if (ModelSupport.isResourceType(modifierName)) {\n+                                modifier = Modifier.TYPE;\n+                                modifierResourceTypeName = modifierName;\n+                            } else {\n+                                try {\n+                                    modifier = Modifier.fromValue(modifierName);\n+                                } catch (IllegalArgumentException e) {\n+                                    String msg = \"Undefined Modifier: \" + modifierName;\n+                                    throw SearchExceptionUtil.buildNewInvalidSearchException(msg);\n+                                }\n+                            }\n+                            if (!isAllowed(type, modifier)) {\n+                                String msg = \"Unsupported type/modifier combination: \" + type.value() + \"/\" + modifier.value();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "originalPosition": 222}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzczNjI5", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-523373629", "createdAt": "2020-11-04T13:46:56Z", "commit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo0Njo1NlrOHtYwCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo0Njo1NlrOHtYwCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1MzQ4Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            whereClauseSegment.append(AND).append(chainedParmVar + DOT).append(CODE_SYSTEM_ID).append(EQ)\n          \n          \n            \n                            whereClauseSegment.append(AND).append(chainedParmVar).append(DOT).append(CODE_SYSTEM_ID).append(EQ)", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517353483", "createdAt": "2020-11-04T13:46:56Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -772,7 +774,7 @@ private void appendMidChainParm(StringBuilder whereClauseSegment, QueryParameter\n         if (codeSystemName != null && !codeSystemName.equals(\"*\")) {\n             Integer codeSystemId = identityCache.getCodeSystemId(codeSystemName);\n             if (codeSystemId != null) {\n-                whereClauseSegment.append(AND).append(PARAMETER_TABLE_ALIAS + DOT).append(CODE_SYSTEM_ID).append(EQ)\n+                whereClauseSegment.append(AND).append(chainedParmVar + DOT).append(CODE_SYSTEM_ID).append(EQ)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "originalPosition": 16}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzc0NDM0", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-523374434", "createdAt": "2020-11-04T13:47:50Z", "commit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo0Nzo1MFrOHtYyTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo0Nzo1MFrOHtYyTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1NDA2Mw==", "bodyText": "I'm almost positive these are repeated constants, maybe they should be top level constants for consistency?", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517354063", "createdAt": "2020-11-04T13:47:50Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -1384,4 +1386,242 @@ private SqlQueryData processMissingParm(Class<?> resourceType, QueryParameter qu\n         log.exiting(CLASSNAME, METHODNAME);\n         return queryData;\n     }\n+\n+    /**\n+     * Contains special logic for handling reverse chained reference search parameters.\n+     * <p>\n+     * A select statement is built to realize the reverse chaining logic required. Here is a sample\n+     * reverse chained query for a Patient given this search parameter: _has:Observation:patient:code=1234\n+     *\n+     * <pre>\n+     * SELECT\n+     *   CLR0.LOGICAL_ID\n+     * FROM\n+     *   Patient_LOGICAL_RESOURCES AS CLR0\n+     *   JOIN Patient_RESOURCES AS CR0 ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+     * WHERE\n+     *   EXISTS (\n+     *     SELECT\n+     *       1\n+     *     FROM\n+     *       Observation_TOKEN_VALUES_V AS CP1\n+     *       JOIN Observation_LOGICAL_RESOURCES AS CLR1 ON CLR1.LOGICAL_RESOURCE_ID = CP1.LOGICAL_RESOURCE_ID\n+     *       JOIN Observation_RESOURCES AS CR1 ON CR1.RESOURCE_ID = CLR1.CURRENT_RESOURCE_ID AND CR1.IS_DELETED = 'N'\n+     *       JOIN Observation_TOKEN_VALUES_V AS CP2 ON CP2.LOGICAL_RESOURCE_ID = CLR1.LOGICAL_RESOURCE_ID\n+     *       AND (\n+     *         CP2.PARAMETER_NAME_ID = 1073\n+     *         AND ((CP2.TOKEN_VALUE = ?))\n+     *       )\n+     *     WHERE\n+     *       CP1.TOKEN_VALUE = CLR0.LOGICAL_ID\n+     *       AND CP1.PARAMETER_NAME_ID = 1274\n+     *       AND CP1.CODE_SYSTEM_ID = 20004\n+     *   )\n+     * </pre>\n+     *\n+     * @see https://www.hl7.org/fhir/search.html#has\n+     * @param resourceType\n+     *                  - The resource type being searched.\n+     * @param queryParm\n+     *                  - A Parameter representing a reverse chained query.\n+     * @return SqlQueryData\n+     *                  - The query segment for a reverse chained parameter reference search.\n+     * @throws Exception\n+     */\n+    @Override\n+    protected SqlQueryData processReverseChainedReferenceParm(Class<?> resourceType, QueryParameter queryParm) throws Exception {\n+        final String METHODNAME = \"processReverseChainedReferenceParm\";\n+        log.entering(CLASSNAME, METHODNAME, queryParm.toString());\n+\n+        final String CR = \"CR\";\n+        final String CLR = \"CLR\";\n+        final String CP = \"CP\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "originalPosition": 73}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzc1MjEz", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-523375213", "createdAt": "2020-11-04T13:48:40Z", "commit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo0ODo0MFrOHtY0gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo0ODo0MFrOHtY0gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1NDYyNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            // BUild outer select: SELECT CLR0.LOGICAL_ID\n          \n          \n            \n                            //                       FROM <resource-type>_LOGICAL_RESOURCES AS CLR0\n          \n          \n            \n            \n          \n          \n            \n                            // Builds outer select: \n          \n          \n            \n                            // @formatter:off\n          \n          \n            \n                            // SELECT CLR0.LOGICAL_ID\n          \n          \n            \n                            //                       FROM <resource-type>_LOGICAL_RESOURCES AS CLR0", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517354626", "createdAt": "2020-11-04T13:48:40Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -1384,4 +1386,242 @@ private SqlQueryData processMissingParm(Class<?> resourceType, QueryParameter qu\n         log.exiting(CLASSNAME, METHODNAME);\n         return queryData;\n     }\n+\n+    /**\n+     * Contains special logic for handling reverse chained reference search parameters.\n+     * <p>\n+     * A select statement is built to realize the reverse chaining logic required. Here is a sample\n+     * reverse chained query for a Patient given this search parameter: _has:Observation:patient:code=1234\n+     *\n+     * <pre>\n+     * SELECT\n+     *   CLR0.LOGICAL_ID\n+     * FROM\n+     *   Patient_LOGICAL_RESOURCES AS CLR0\n+     *   JOIN Patient_RESOURCES AS CR0 ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+     * WHERE\n+     *   EXISTS (\n+     *     SELECT\n+     *       1\n+     *     FROM\n+     *       Observation_TOKEN_VALUES_V AS CP1\n+     *       JOIN Observation_LOGICAL_RESOURCES AS CLR1 ON CLR1.LOGICAL_RESOURCE_ID = CP1.LOGICAL_RESOURCE_ID\n+     *       JOIN Observation_RESOURCES AS CR1 ON CR1.RESOURCE_ID = CLR1.CURRENT_RESOURCE_ID AND CR1.IS_DELETED = 'N'\n+     *       JOIN Observation_TOKEN_VALUES_V AS CP2 ON CP2.LOGICAL_RESOURCE_ID = CLR1.LOGICAL_RESOURCE_ID\n+     *       AND (\n+     *         CP2.PARAMETER_NAME_ID = 1073\n+     *         AND ((CP2.TOKEN_VALUE = ?))\n+     *       )\n+     *     WHERE\n+     *       CP1.TOKEN_VALUE = CLR0.LOGICAL_ID\n+     *       AND CP1.PARAMETER_NAME_ID = 1274\n+     *       AND CP1.CODE_SYSTEM_ID = 20004\n+     *   )\n+     * </pre>\n+     *\n+     * @see https://www.hl7.org/fhir/search.html#has\n+     * @param resourceType\n+     *                  - The resource type being searched.\n+     * @param queryParm\n+     *                  - A Parameter representing a reverse chained query.\n+     * @return SqlQueryData\n+     *                  - The query segment for a reverse chained parameter reference search.\n+     * @throws Exception\n+     */\n+    @Override\n+    protected SqlQueryData processReverseChainedReferenceParm(Class<?> resourceType, QueryParameter queryParm) throws Exception {\n+        final String METHODNAME = \"processReverseChainedReferenceParm\";\n+        log.entering(CLASSNAME, METHODNAME, queryParm.toString());\n+\n+        final String CR = \"CR\";\n+        final String CLR = \"CLR\";\n+        final String CP = \"CP\";\n+        String prevChainedResourceVar = null;\n+        String prevChainedLogicalResourceVar = null;\n+        String chainedResourceVar = null;\n+        String chainedLogicalResourceVar = null;\n+        String chainedParmVar = null;\n+        String nextChainedResourceVar = null;\n+        String nextChainedLogicalResourceVar = null;\n+        String nextChainedParmVar = null;\n+        QueryParameter previousParm = null;;\n+        int parmIndex = 0;\n+        int lastParmIndex = queryParm.getChain().size();\n+        boolean chainedParmProcessed = false;\n+        StringBuilder selectSegments = new StringBuilder();\n+        StringBuilder whereClauseSegments = new StringBuilder();\n+        List<Object> bindVariables = new ArrayList<>();\n+\n+        // Loop through the chained query parameters in order\n+        List<QueryParameter> queryParms = queryParm.getChain();\n+        queryParms.add(0, queryParm);\n+        for (QueryParameter currentParm : queryParms) {\n+\n+            prevChainedResourceVar        = CR + parmIndex;\n+            prevChainedLogicalResourceVar = CLR + parmIndex;\n+            chainedResourceVar        = CR + (parmIndex + 1);\n+            chainedLogicalResourceVar = CLR + (parmIndex + 1);\n+            chainedParmVar            = CP + (parmIndex + 1);\n+            nextChainedResourceVar        = CR + (parmIndex + 2);\n+            nextChainedLogicalResourceVar = CLR + (parmIndex + 2);\n+            nextChainedParmVar        = CP + (parmIndex + 2);\n+            StringBuilder whereClauseSegment = new StringBuilder();\n+\n+            if (parmIndex == 0) {\n+                // BUild outer select: SELECT CLR0.LOGICAL_ID\n+                //                       FROM <resource-type>_LOGICAL_RESOURCES AS CLR0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "originalPosition": 107}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzc1Mzc2", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-523375376", "createdAt": "2020-11-04T13:48:51Z", "commit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo0ODo1MVrOHtY0_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo0ODo1MVrOHtY0_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1NDc0OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            //                       WHERE\n          \n          \n            \n                            //                       WHERE\n          \n          \n            \n                            // @formatter:on", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517354749", "createdAt": "2020-11-04T13:48:51Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -1384,4 +1386,242 @@ private SqlQueryData processMissingParm(Class<?> resourceType, QueryParameter qu\n         log.exiting(CLASSNAME, METHODNAME);\n         return queryData;\n     }\n+\n+    /**\n+     * Contains special logic for handling reverse chained reference search parameters.\n+     * <p>\n+     * A select statement is built to realize the reverse chaining logic required. Here is a sample\n+     * reverse chained query for a Patient given this search parameter: _has:Observation:patient:code=1234\n+     *\n+     * <pre>\n+     * SELECT\n+     *   CLR0.LOGICAL_ID\n+     * FROM\n+     *   Patient_LOGICAL_RESOURCES AS CLR0\n+     *   JOIN Patient_RESOURCES AS CR0 ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+     * WHERE\n+     *   EXISTS (\n+     *     SELECT\n+     *       1\n+     *     FROM\n+     *       Observation_TOKEN_VALUES_V AS CP1\n+     *       JOIN Observation_LOGICAL_RESOURCES AS CLR1 ON CLR1.LOGICAL_RESOURCE_ID = CP1.LOGICAL_RESOURCE_ID\n+     *       JOIN Observation_RESOURCES AS CR1 ON CR1.RESOURCE_ID = CLR1.CURRENT_RESOURCE_ID AND CR1.IS_DELETED = 'N'\n+     *       JOIN Observation_TOKEN_VALUES_V AS CP2 ON CP2.LOGICAL_RESOURCE_ID = CLR1.LOGICAL_RESOURCE_ID\n+     *       AND (\n+     *         CP2.PARAMETER_NAME_ID = 1073\n+     *         AND ((CP2.TOKEN_VALUE = ?))\n+     *       )\n+     *     WHERE\n+     *       CP1.TOKEN_VALUE = CLR0.LOGICAL_ID\n+     *       AND CP1.PARAMETER_NAME_ID = 1274\n+     *       AND CP1.CODE_SYSTEM_ID = 20004\n+     *   )\n+     * </pre>\n+     *\n+     * @see https://www.hl7.org/fhir/search.html#has\n+     * @param resourceType\n+     *                  - The resource type being searched.\n+     * @param queryParm\n+     *                  - A Parameter representing a reverse chained query.\n+     * @return SqlQueryData\n+     *                  - The query segment for a reverse chained parameter reference search.\n+     * @throws Exception\n+     */\n+    @Override\n+    protected SqlQueryData processReverseChainedReferenceParm(Class<?> resourceType, QueryParameter queryParm) throws Exception {\n+        final String METHODNAME = \"processReverseChainedReferenceParm\";\n+        log.entering(CLASSNAME, METHODNAME, queryParm.toString());\n+\n+        final String CR = \"CR\";\n+        final String CLR = \"CLR\";\n+        final String CP = \"CP\";\n+        String prevChainedResourceVar = null;\n+        String prevChainedLogicalResourceVar = null;\n+        String chainedResourceVar = null;\n+        String chainedLogicalResourceVar = null;\n+        String chainedParmVar = null;\n+        String nextChainedResourceVar = null;\n+        String nextChainedLogicalResourceVar = null;\n+        String nextChainedParmVar = null;\n+        QueryParameter previousParm = null;;\n+        int parmIndex = 0;\n+        int lastParmIndex = queryParm.getChain().size();\n+        boolean chainedParmProcessed = false;\n+        StringBuilder selectSegments = new StringBuilder();\n+        StringBuilder whereClauseSegments = new StringBuilder();\n+        List<Object> bindVariables = new ArrayList<>();\n+\n+        // Loop through the chained query parameters in order\n+        List<QueryParameter> queryParms = queryParm.getChain();\n+        queryParms.add(0, queryParm);\n+        for (QueryParameter currentParm : queryParms) {\n+\n+            prevChainedResourceVar        = CR + parmIndex;\n+            prevChainedLogicalResourceVar = CLR + parmIndex;\n+            chainedResourceVar        = CR + (parmIndex + 1);\n+            chainedLogicalResourceVar = CLR + (parmIndex + 1);\n+            chainedParmVar            = CP + (parmIndex + 1);\n+            nextChainedResourceVar        = CR + (parmIndex + 2);\n+            nextChainedLogicalResourceVar = CLR + (parmIndex + 2);\n+            nextChainedParmVar        = CP + (parmIndex + 2);\n+            StringBuilder whereClauseSegment = new StringBuilder();\n+\n+            if (parmIndex == 0) {\n+                // BUild outer select: SELECT CLR0.LOGICAL_ID\n+                //                       FROM <resource-type>_LOGICAL_RESOURCES AS CLR0\n+                //                       JOIN <resource-type>_RESOURCES AS CR0\n+                //                         ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+                //                       WHERE", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "originalPosition": 110}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzc1ODc5", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-523375879", "createdAt": "2020-11-04T13:49:26Z", "commit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo0OToyNlrOHtY2jQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo0OToyNlrOHtY2jQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1NTE0OQ==", "bodyText": "let's break these into individual appends\nAlso SELECT and I think LogicalId are already in JDBCConstants", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517355149", "createdAt": "2020-11-04T13:49:26Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -1384,4 +1386,242 @@ private SqlQueryData processMissingParm(Class<?> resourceType, QueryParameter qu\n         log.exiting(CLASSNAME, METHODNAME);\n         return queryData;\n     }\n+\n+    /**\n+     * Contains special logic for handling reverse chained reference search parameters.\n+     * <p>\n+     * A select statement is built to realize the reverse chaining logic required. Here is a sample\n+     * reverse chained query for a Patient given this search parameter: _has:Observation:patient:code=1234\n+     *\n+     * <pre>\n+     * SELECT\n+     *   CLR0.LOGICAL_ID\n+     * FROM\n+     *   Patient_LOGICAL_RESOURCES AS CLR0\n+     *   JOIN Patient_RESOURCES AS CR0 ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+     * WHERE\n+     *   EXISTS (\n+     *     SELECT\n+     *       1\n+     *     FROM\n+     *       Observation_TOKEN_VALUES_V AS CP1\n+     *       JOIN Observation_LOGICAL_RESOURCES AS CLR1 ON CLR1.LOGICAL_RESOURCE_ID = CP1.LOGICAL_RESOURCE_ID\n+     *       JOIN Observation_RESOURCES AS CR1 ON CR1.RESOURCE_ID = CLR1.CURRENT_RESOURCE_ID AND CR1.IS_DELETED = 'N'\n+     *       JOIN Observation_TOKEN_VALUES_V AS CP2 ON CP2.LOGICAL_RESOURCE_ID = CLR1.LOGICAL_RESOURCE_ID\n+     *       AND (\n+     *         CP2.PARAMETER_NAME_ID = 1073\n+     *         AND ((CP2.TOKEN_VALUE = ?))\n+     *       )\n+     *     WHERE\n+     *       CP1.TOKEN_VALUE = CLR0.LOGICAL_ID\n+     *       AND CP1.PARAMETER_NAME_ID = 1274\n+     *       AND CP1.CODE_SYSTEM_ID = 20004\n+     *   )\n+     * </pre>\n+     *\n+     * @see https://www.hl7.org/fhir/search.html#has\n+     * @param resourceType\n+     *                  - The resource type being searched.\n+     * @param queryParm\n+     *                  - A Parameter representing a reverse chained query.\n+     * @return SqlQueryData\n+     *                  - The query segment for a reverse chained parameter reference search.\n+     * @throws Exception\n+     */\n+    @Override\n+    protected SqlQueryData processReverseChainedReferenceParm(Class<?> resourceType, QueryParameter queryParm) throws Exception {\n+        final String METHODNAME = \"processReverseChainedReferenceParm\";\n+        log.entering(CLASSNAME, METHODNAME, queryParm.toString());\n+\n+        final String CR = \"CR\";\n+        final String CLR = \"CLR\";\n+        final String CP = \"CP\";\n+        String prevChainedResourceVar = null;\n+        String prevChainedLogicalResourceVar = null;\n+        String chainedResourceVar = null;\n+        String chainedLogicalResourceVar = null;\n+        String chainedParmVar = null;\n+        String nextChainedResourceVar = null;\n+        String nextChainedLogicalResourceVar = null;\n+        String nextChainedParmVar = null;\n+        QueryParameter previousParm = null;;\n+        int parmIndex = 0;\n+        int lastParmIndex = queryParm.getChain().size();\n+        boolean chainedParmProcessed = false;\n+        StringBuilder selectSegments = new StringBuilder();\n+        StringBuilder whereClauseSegments = new StringBuilder();\n+        List<Object> bindVariables = new ArrayList<>();\n+\n+        // Loop through the chained query parameters in order\n+        List<QueryParameter> queryParms = queryParm.getChain();\n+        queryParms.add(0, queryParm);\n+        for (QueryParameter currentParm : queryParms) {\n+\n+            prevChainedResourceVar        = CR + parmIndex;\n+            prevChainedLogicalResourceVar = CLR + parmIndex;\n+            chainedResourceVar        = CR + (parmIndex + 1);\n+            chainedLogicalResourceVar = CLR + (parmIndex + 1);\n+            chainedParmVar            = CP + (parmIndex + 1);\n+            nextChainedResourceVar        = CR + (parmIndex + 2);\n+            nextChainedLogicalResourceVar = CLR + (parmIndex + 2);\n+            nextChainedParmVar        = CP + (parmIndex + 2);\n+            StringBuilder whereClauseSegment = new StringBuilder();\n+\n+            if (parmIndex == 0) {\n+                // BUild outer select: SELECT CLR0.LOGICAL_ID\n+                //                       FROM <resource-type>_LOGICAL_RESOURCES AS CLR0\n+                //                       JOIN <resource-type>_RESOURCES AS CR0\n+                //                         ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+                //                       WHERE\n+                selectSegments.append(\"SELECT \" + prevChainedLogicalResourceVar + DOT + \"LOGICAL_ID\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "originalPosition": 111}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzc2MzY2", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-523376366", "createdAt": "2020-11-04T13:49:58Z", "commit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo0OTo1OFrOHtY4AA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo0OTo1OFrOHtY4AA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1NTUyMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                //                           FROM <modifierTypeResourceName>_TOKEN_VALUES_V AS CPx\n          \n          \n            \n                                //                           JOIN <modifierTypeResourceName>_LOGICAL_RESOURCES AS CLRx\n          \n          \n            \n                                //                             ON CLRx.LOGICAL_RESOURCE_ID = CPx.LOGICAL_RESOURCE_ID\n          \n          \n            \n                                //                           JOIN <modifierTypeResourceName>_RESOURCES AS CRx\n          \n          \n            \n                                //                             ON CRx.RESOURCE_ID = CLRx.CURRENT_RESOURCE_ID AND CRx.IS_DELETED = 'N'\n          \n          \n            \n                                // @formatter:off\n          \n          \n            \n                                //                           FROM <modifierTypeResourceName>_TOKEN_VALUES_V AS CPx\n          \n          \n            \n                                //                           JOIN <modifierTypeResourceName>_LOGICAL_RESOURCES AS CLRx\n          \n          \n            \n                                //                             ON CLRx.LOGICAL_RESOURCE_ID = CPx.LOGICAL_RESOURCE_ID\n          \n          \n            \n                                //                           JOIN <modifierTypeResourceName>_RESOURCES AS CRx\n          \n          \n            \n                                //                             ON CRx.RESOURCE_ID = CLRx.CURRENT_RESOURCE_ID AND CRx.IS_DELETED = 'N'\n          \n          \n            \n                                // @formatter:on", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517355520", "createdAt": "2020-11-04T13:49:58Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -1384,4 +1386,242 @@ private SqlQueryData processMissingParm(Class<?> resourceType, QueryParameter qu\n         log.exiting(CLASSNAME, METHODNAME);\n         return queryData;\n     }\n+\n+    /**\n+     * Contains special logic for handling reverse chained reference search parameters.\n+     * <p>\n+     * A select statement is built to realize the reverse chaining logic required. Here is a sample\n+     * reverse chained query for a Patient given this search parameter: _has:Observation:patient:code=1234\n+     *\n+     * <pre>\n+     * SELECT\n+     *   CLR0.LOGICAL_ID\n+     * FROM\n+     *   Patient_LOGICAL_RESOURCES AS CLR0\n+     *   JOIN Patient_RESOURCES AS CR0 ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+     * WHERE\n+     *   EXISTS (\n+     *     SELECT\n+     *       1\n+     *     FROM\n+     *       Observation_TOKEN_VALUES_V AS CP1\n+     *       JOIN Observation_LOGICAL_RESOURCES AS CLR1 ON CLR1.LOGICAL_RESOURCE_ID = CP1.LOGICAL_RESOURCE_ID\n+     *       JOIN Observation_RESOURCES AS CR1 ON CR1.RESOURCE_ID = CLR1.CURRENT_RESOURCE_ID AND CR1.IS_DELETED = 'N'\n+     *       JOIN Observation_TOKEN_VALUES_V AS CP2 ON CP2.LOGICAL_RESOURCE_ID = CLR1.LOGICAL_RESOURCE_ID\n+     *       AND (\n+     *         CP2.PARAMETER_NAME_ID = 1073\n+     *         AND ((CP2.TOKEN_VALUE = ?))\n+     *       )\n+     *     WHERE\n+     *       CP1.TOKEN_VALUE = CLR0.LOGICAL_ID\n+     *       AND CP1.PARAMETER_NAME_ID = 1274\n+     *       AND CP1.CODE_SYSTEM_ID = 20004\n+     *   )\n+     * </pre>\n+     *\n+     * @see https://www.hl7.org/fhir/search.html#has\n+     * @param resourceType\n+     *                  - The resource type being searched.\n+     * @param queryParm\n+     *                  - A Parameter representing a reverse chained query.\n+     * @return SqlQueryData\n+     *                  - The query segment for a reverse chained parameter reference search.\n+     * @throws Exception\n+     */\n+    @Override\n+    protected SqlQueryData processReverseChainedReferenceParm(Class<?> resourceType, QueryParameter queryParm) throws Exception {\n+        final String METHODNAME = \"processReverseChainedReferenceParm\";\n+        log.entering(CLASSNAME, METHODNAME, queryParm.toString());\n+\n+        final String CR = \"CR\";\n+        final String CLR = \"CLR\";\n+        final String CP = \"CP\";\n+        String prevChainedResourceVar = null;\n+        String prevChainedLogicalResourceVar = null;\n+        String chainedResourceVar = null;\n+        String chainedLogicalResourceVar = null;\n+        String chainedParmVar = null;\n+        String nextChainedResourceVar = null;\n+        String nextChainedLogicalResourceVar = null;\n+        String nextChainedParmVar = null;\n+        QueryParameter previousParm = null;;\n+        int parmIndex = 0;\n+        int lastParmIndex = queryParm.getChain().size();\n+        boolean chainedParmProcessed = false;\n+        StringBuilder selectSegments = new StringBuilder();\n+        StringBuilder whereClauseSegments = new StringBuilder();\n+        List<Object> bindVariables = new ArrayList<>();\n+\n+        // Loop through the chained query parameters in order\n+        List<QueryParameter> queryParms = queryParm.getChain();\n+        queryParms.add(0, queryParm);\n+        for (QueryParameter currentParm : queryParms) {\n+\n+            prevChainedResourceVar        = CR + parmIndex;\n+            prevChainedLogicalResourceVar = CLR + parmIndex;\n+            chainedResourceVar        = CR + (parmIndex + 1);\n+            chainedLogicalResourceVar = CLR + (parmIndex + 1);\n+            chainedParmVar            = CP + (parmIndex + 1);\n+            nextChainedResourceVar        = CR + (parmIndex + 2);\n+            nextChainedLogicalResourceVar = CLR + (parmIndex + 2);\n+            nextChainedParmVar        = CP + (parmIndex + 2);\n+            StringBuilder whereClauseSegment = new StringBuilder();\n+\n+            if (parmIndex == 0) {\n+                // BUild outer select: SELECT CLR0.LOGICAL_ID\n+                //                       FROM <resource-type>_LOGICAL_RESOURCES AS CLR0\n+                //                       JOIN <resource-type>_RESOURCES AS CR0\n+                //                         ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+                //                       WHERE\n+                selectSegments.append(\"SELECT \" + prevChainedLogicalResourceVar + DOT + \"LOGICAL_ID\")\n+                                .append(FROM + resourceType.getSimpleName() + \"_LOGICAL_RESOURCES AS \" + prevChainedLogicalResourceVar)\n+                                .append(JOIN + resourceType.getSimpleName() + \"_RESOURCES AS \" + prevChainedResourceVar)\n+                                .append(ON + prevChainedResourceVar + DOT + \"RESOURCE_ID\" + EQ + prevChainedLogicalResourceVar + DOT + \"CURRENT_RESOURCE_ID\")\n+                                .append(AND + prevChainedResourceVar + DOT + \"IS_DELETED\" + EQ + \"'N'\")\n+                                .append(WHERE);\n+            }\n+\n+            if (parmIndex < lastParmIndex) {\n+                if (currentParm.isReverseChained()) {\n+                    // Build inner select joins: EXISTS (SELECT 1\n+                    //                           FROM <modifierTypeResourceName>_TOKEN_VALUES_V AS CPx\n+                    //                           JOIN <modifierTypeResourceName>_LOGICAL_RESOURCES AS CLRx\n+                    //                             ON CLRx.LOGICAL_RESOURCE_ID = CPx.LOGICAL_RESOURCE_ID\n+                    //                           JOIN <modifierTypeResourceName>_RESOURCES AS CRx\n+                    //                             ON CRx.RESOURCE_ID = CLRx.CURRENT_RESOURCE_ID AND CRx.IS_DELETED = 'N'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "originalPosition": 126}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzc2ODQx", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-523376841", "createdAt": "2020-11-04T13:50:31Z", "commit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo1MDozMlrOHtY5aA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo1MDozMlrOHtY5aA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1NTg4MA==", "bodyText": "same comment about appends and the EXISTS I think is already in the JDBCConstants\nsame with RESOURCE_ID and IS_DELETED", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517355880", "createdAt": "2020-11-04T13:50:32Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -1384,4 +1386,242 @@ private SqlQueryData processMissingParm(Class<?> resourceType, QueryParameter qu\n         log.exiting(CLASSNAME, METHODNAME);\n         return queryData;\n     }\n+\n+    /**\n+     * Contains special logic for handling reverse chained reference search parameters.\n+     * <p>\n+     * A select statement is built to realize the reverse chaining logic required. Here is a sample\n+     * reverse chained query for a Patient given this search parameter: _has:Observation:patient:code=1234\n+     *\n+     * <pre>\n+     * SELECT\n+     *   CLR0.LOGICAL_ID\n+     * FROM\n+     *   Patient_LOGICAL_RESOURCES AS CLR0\n+     *   JOIN Patient_RESOURCES AS CR0 ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+     * WHERE\n+     *   EXISTS (\n+     *     SELECT\n+     *       1\n+     *     FROM\n+     *       Observation_TOKEN_VALUES_V AS CP1\n+     *       JOIN Observation_LOGICAL_RESOURCES AS CLR1 ON CLR1.LOGICAL_RESOURCE_ID = CP1.LOGICAL_RESOURCE_ID\n+     *       JOIN Observation_RESOURCES AS CR1 ON CR1.RESOURCE_ID = CLR1.CURRENT_RESOURCE_ID AND CR1.IS_DELETED = 'N'\n+     *       JOIN Observation_TOKEN_VALUES_V AS CP2 ON CP2.LOGICAL_RESOURCE_ID = CLR1.LOGICAL_RESOURCE_ID\n+     *       AND (\n+     *         CP2.PARAMETER_NAME_ID = 1073\n+     *         AND ((CP2.TOKEN_VALUE = ?))\n+     *       )\n+     *     WHERE\n+     *       CP1.TOKEN_VALUE = CLR0.LOGICAL_ID\n+     *       AND CP1.PARAMETER_NAME_ID = 1274\n+     *       AND CP1.CODE_SYSTEM_ID = 20004\n+     *   )\n+     * </pre>\n+     *\n+     * @see https://www.hl7.org/fhir/search.html#has\n+     * @param resourceType\n+     *                  - The resource type being searched.\n+     * @param queryParm\n+     *                  - A Parameter representing a reverse chained query.\n+     * @return SqlQueryData\n+     *                  - The query segment for a reverse chained parameter reference search.\n+     * @throws Exception\n+     */\n+    @Override\n+    protected SqlQueryData processReverseChainedReferenceParm(Class<?> resourceType, QueryParameter queryParm) throws Exception {\n+        final String METHODNAME = \"processReverseChainedReferenceParm\";\n+        log.entering(CLASSNAME, METHODNAME, queryParm.toString());\n+\n+        final String CR = \"CR\";\n+        final String CLR = \"CLR\";\n+        final String CP = \"CP\";\n+        String prevChainedResourceVar = null;\n+        String prevChainedLogicalResourceVar = null;\n+        String chainedResourceVar = null;\n+        String chainedLogicalResourceVar = null;\n+        String chainedParmVar = null;\n+        String nextChainedResourceVar = null;\n+        String nextChainedLogicalResourceVar = null;\n+        String nextChainedParmVar = null;\n+        QueryParameter previousParm = null;;\n+        int parmIndex = 0;\n+        int lastParmIndex = queryParm.getChain().size();\n+        boolean chainedParmProcessed = false;\n+        StringBuilder selectSegments = new StringBuilder();\n+        StringBuilder whereClauseSegments = new StringBuilder();\n+        List<Object> bindVariables = new ArrayList<>();\n+\n+        // Loop through the chained query parameters in order\n+        List<QueryParameter> queryParms = queryParm.getChain();\n+        queryParms.add(0, queryParm);\n+        for (QueryParameter currentParm : queryParms) {\n+\n+            prevChainedResourceVar        = CR + parmIndex;\n+            prevChainedLogicalResourceVar = CLR + parmIndex;\n+            chainedResourceVar        = CR + (parmIndex + 1);\n+            chainedLogicalResourceVar = CLR + (parmIndex + 1);\n+            chainedParmVar            = CP + (parmIndex + 1);\n+            nextChainedResourceVar        = CR + (parmIndex + 2);\n+            nextChainedLogicalResourceVar = CLR + (parmIndex + 2);\n+            nextChainedParmVar        = CP + (parmIndex + 2);\n+            StringBuilder whereClauseSegment = new StringBuilder();\n+\n+            if (parmIndex == 0) {\n+                // BUild outer select: SELECT CLR0.LOGICAL_ID\n+                //                       FROM <resource-type>_LOGICAL_RESOURCES AS CLR0\n+                //                       JOIN <resource-type>_RESOURCES AS CR0\n+                //                         ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+                //                       WHERE\n+                selectSegments.append(\"SELECT \" + prevChainedLogicalResourceVar + DOT + \"LOGICAL_ID\")\n+                                .append(FROM + resourceType.getSimpleName() + \"_LOGICAL_RESOURCES AS \" + prevChainedLogicalResourceVar)\n+                                .append(JOIN + resourceType.getSimpleName() + \"_RESOURCES AS \" + prevChainedResourceVar)\n+                                .append(ON + prevChainedResourceVar + DOT + \"RESOURCE_ID\" + EQ + prevChainedLogicalResourceVar + DOT + \"CURRENT_RESOURCE_ID\")\n+                                .append(AND + prevChainedResourceVar + DOT + \"IS_DELETED\" + EQ + \"'N'\")\n+                                .append(WHERE);\n+            }\n+\n+            if (parmIndex < lastParmIndex) {\n+                if (currentParm.isReverseChained()) {\n+                    // Build inner select joins: EXISTS (SELECT 1\n+                    //                           FROM <modifierTypeResourceName>_TOKEN_VALUES_V AS CPx\n+                    //                           JOIN <modifierTypeResourceName>_LOGICAL_RESOURCES AS CLRx\n+                    //                             ON CLRx.LOGICAL_RESOURCE_ID = CPx.LOGICAL_RESOURCE_ID\n+                    //                           JOIN <modifierTypeResourceName>_RESOURCES AS CRx\n+                    //                             ON CRx.RESOURCE_ID = CLRx.CURRENT_RESOURCE_ID AND CRx.IS_DELETED = 'N'\n+                    selectSegments.append(\"EXISTS \" + LEFT_PAREN + \"SELECT 1\")\n+                                    .append(FROM + currentParm.getModifierResourceTypeName() + \"_TOKEN_VALUES_V AS \" + chainedParmVar)\n+                                    .append(JOIN + currentParm.getModifierResourceTypeName() + \"_LOGICAL_RESOURCES AS \" + chainedLogicalResourceVar)\n+                                    .append(ON + chainedLogicalResourceVar + DOT + \"LOGICAL_RESOURCE_ID\" + EQ + chainedParmVar + DOT + \"LOGICAL_RESOURCE_ID\")\n+                                    .append(JOIN + currentParm.getModifierResourceTypeName() + \"_RESOURCES AS \" + chainedResourceVar)\n+                                    .append(ON + chainedResourceVar + DOT + \"RESOURCE_ID\" + EQ + chainedLogicalResourceVar + DOT + \"CURRENT_RESOURCE_ID\")\n+                                    .append(AND + chainedResourceVar + DOT + \"IS_DELETED\" + EQ + \"'N'\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "originalPosition": 133}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzc3NTMx", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-523377531", "createdAt": "2020-11-04T13:51:18Z", "commit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo1MToxOFrOHtY7gQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo1MToxOFrOHtY7gQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1NjQxNw==", "bodyText": "Where you have the nice format, we can add the @formatter:on and off", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517356417", "createdAt": "2020-11-04T13:51:18Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -1384,4 +1386,242 @@ private SqlQueryData processMissingParm(Class<?> resourceType, QueryParameter qu\n         log.exiting(CLASSNAME, METHODNAME);\n         return queryData;\n     }\n+\n+    /**\n+     * Contains special logic for handling reverse chained reference search parameters.\n+     * <p>\n+     * A select statement is built to realize the reverse chaining logic required. Here is a sample\n+     * reverse chained query for a Patient given this search parameter: _has:Observation:patient:code=1234\n+     *\n+     * <pre>\n+     * SELECT\n+     *   CLR0.LOGICAL_ID\n+     * FROM\n+     *   Patient_LOGICAL_RESOURCES AS CLR0\n+     *   JOIN Patient_RESOURCES AS CR0 ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+     * WHERE\n+     *   EXISTS (\n+     *     SELECT\n+     *       1\n+     *     FROM\n+     *       Observation_TOKEN_VALUES_V AS CP1\n+     *       JOIN Observation_LOGICAL_RESOURCES AS CLR1 ON CLR1.LOGICAL_RESOURCE_ID = CP1.LOGICAL_RESOURCE_ID\n+     *       JOIN Observation_RESOURCES AS CR1 ON CR1.RESOURCE_ID = CLR1.CURRENT_RESOURCE_ID AND CR1.IS_DELETED = 'N'\n+     *       JOIN Observation_TOKEN_VALUES_V AS CP2 ON CP2.LOGICAL_RESOURCE_ID = CLR1.LOGICAL_RESOURCE_ID\n+     *       AND (\n+     *         CP2.PARAMETER_NAME_ID = 1073\n+     *         AND ((CP2.TOKEN_VALUE = ?))\n+     *       )\n+     *     WHERE\n+     *       CP1.TOKEN_VALUE = CLR0.LOGICAL_ID\n+     *       AND CP1.PARAMETER_NAME_ID = 1274\n+     *       AND CP1.CODE_SYSTEM_ID = 20004\n+     *   )\n+     * </pre>\n+     *\n+     * @see https://www.hl7.org/fhir/search.html#has\n+     * @param resourceType\n+     *                  - The resource type being searched.\n+     * @param queryParm\n+     *                  - A Parameter representing a reverse chained query.\n+     * @return SqlQueryData\n+     *                  - The query segment for a reverse chained parameter reference search.\n+     * @throws Exception\n+     */\n+    @Override\n+    protected SqlQueryData processReverseChainedReferenceParm(Class<?> resourceType, QueryParameter queryParm) throws Exception {\n+        final String METHODNAME = \"processReverseChainedReferenceParm\";\n+        log.entering(CLASSNAME, METHODNAME, queryParm.toString());\n+\n+        final String CR = \"CR\";\n+        final String CLR = \"CLR\";\n+        final String CP = \"CP\";\n+        String prevChainedResourceVar = null;\n+        String prevChainedLogicalResourceVar = null;\n+        String chainedResourceVar = null;\n+        String chainedLogicalResourceVar = null;\n+        String chainedParmVar = null;\n+        String nextChainedResourceVar = null;\n+        String nextChainedLogicalResourceVar = null;\n+        String nextChainedParmVar = null;\n+        QueryParameter previousParm = null;;\n+        int parmIndex = 0;\n+        int lastParmIndex = queryParm.getChain().size();\n+        boolean chainedParmProcessed = false;\n+        StringBuilder selectSegments = new StringBuilder();\n+        StringBuilder whereClauseSegments = new StringBuilder();\n+        List<Object> bindVariables = new ArrayList<>();\n+\n+        // Loop through the chained query parameters in order\n+        List<QueryParameter> queryParms = queryParm.getChain();\n+        queryParms.add(0, queryParm);\n+        for (QueryParameter currentParm : queryParms) {\n+\n+            prevChainedResourceVar        = CR + parmIndex;\n+            prevChainedLogicalResourceVar = CLR + parmIndex;\n+            chainedResourceVar        = CR + (parmIndex + 1);\n+            chainedLogicalResourceVar = CLR + (parmIndex + 1);\n+            chainedParmVar            = CP + (parmIndex + 1);\n+            nextChainedResourceVar        = CR + (parmIndex + 2);\n+            nextChainedLogicalResourceVar = CLR + (parmIndex + 2);\n+            nextChainedParmVar        = CP + (parmIndex + 2);\n+            StringBuilder whereClauseSegment = new StringBuilder();\n+\n+            if (parmIndex == 0) {\n+                // BUild outer select: SELECT CLR0.LOGICAL_ID\n+                //                       FROM <resource-type>_LOGICAL_RESOURCES AS CLR0\n+                //                       JOIN <resource-type>_RESOURCES AS CR0\n+                //                         ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+                //                       WHERE\n+                selectSegments.append(\"SELECT \" + prevChainedLogicalResourceVar + DOT + \"LOGICAL_ID\")\n+                                .append(FROM + resourceType.getSimpleName() + \"_LOGICAL_RESOURCES AS \" + prevChainedLogicalResourceVar)\n+                                .append(JOIN + resourceType.getSimpleName() + \"_RESOURCES AS \" + prevChainedResourceVar)\n+                                .append(ON + prevChainedResourceVar + DOT + \"RESOURCE_ID\" + EQ + prevChainedLogicalResourceVar + DOT + \"CURRENT_RESOURCE_ID\")\n+                                .append(AND + prevChainedResourceVar + DOT + \"IS_DELETED\" + EQ + \"'N'\")\n+                                .append(WHERE);\n+            }\n+\n+            if (parmIndex < lastParmIndex) {\n+                if (currentParm.isReverseChained()) {\n+                    // Build inner select joins: EXISTS (SELECT 1\n+                    //                           FROM <modifierTypeResourceName>_TOKEN_VALUES_V AS CPx\n+                    //                           JOIN <modifierTypeResourceName>_LOGICAL_RESOURCES AS CLRx\n+                    //                             ON CLRx.LOGICAL_RESOURCE_ID = CPx.LOGICAL_RESOURCE_ID\n+                    //                           JOIN <modifierTypeResourceName>_RESOURCES AS CRx\n+                    //                             ON CRx.RESOURCE_ID = CLRx.CURRENT_RESOURCE_ID AND CRx.IS_DELETED = 'N'\n+                    selectSegments.append(\"EXISTS \" + LEFT_PAREN + \"SELECT 1\")\n+                                    .append(FROM + currentParm.getModifierResourceTypeName() + \"_TOKEN_VALUES_V AS \" + chainedParmVar)\n+                                    .append(JOIN + currentParm.getModifierResourceTypeName() + \"_LOGICAL_RESOURCES AS \" + chainedLogicalResourceVar)\n+                                    .append(ON + chainedLogicalResourceVar + DOT + \"LOGICAL_RESOURCE_ID\" + EQ + chainedParmVar + DOT + \"LOGICAL_RESOURCE_ID\")\n+                                    .append(JOIN + currentParm.getModifierResourceTypeName() + \"_RESOURCES AS \" + chainedResourceVar)\n+                                    .append(ON + chainedResourceVar + DOT + \"RESOURCE_ID\" + EQ + chainedLogicalResourceVar + DOT + \"CURRENT_RESOURCE_ID\")\n+                                    .append(AND + chainedResourceVar + DOT + \"IS_DELETED\" + EQ + \"'N'\");\n+\n+                    String referencedResourceType = null;\n+                    if (parmIndex == 0) {\n+                        referencedResourceType = resourceType.getSimpleName();\n+                    } else {\n+                        referencedResourceType = previousParm.getModifierResourceTypeName();\n+                    }\n+                    if (parmIndex < lastParmIndex - 1 && currentParm.getNextParameter().isReverseChained()) {\n+                        // Build inner select where clause: WHERE CPx.TOKEN_VALUE = CLR<x-1>.LOGICAL_ID\n+                        //                                    AND CPx.PARAMETER_NAME_ID = <parm-name-id>\n+                        //                                    AND CPx.CDE_SYSTEM_ID = <code-system-id>\n+                        //                                    AND", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "originalPosition": 145}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzc3OTUx", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-523377951", "createdAt": "2020-11-04T13:51:47Z", "commit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo1MTo0N1rOHtY8rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo1MTo0N1rOHtY8rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1NjcxOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    // BUild ON clause for join: ) AS CPx ON CPx.LOGICAL_RESOURCE_ID = CLR<x-1>.LOGICAL_RESOURCE_ID\n          \n          \n            \n                                    // Builds ON clause for join: ) AS CPx ON CPx.LOGICAL_RESOURCE_ID = CLR<x-1>.LOGICAL_RESOURCE_ID", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517356718", "createdAt": "2020-11-04T13:51:47Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -1384,4 +1386,242 @@ private SqlQueryData processMissingParm(Class<?> resourceType, QueryParameter qu\n         log.exiting(CLASSNAME, METHODNAME);\n         return queryData;\n     }\n+\n+    /**\n+     * Contains special logic for handling reverse chained reference search parameters.\n+     * <p>\n+     * A select statement is built to realize the reverse chaining logic required. Here is a sample\n+     * reverse chained query for a Patient given this search parameter: _has:Observation:patient:code=1234\n+     *\n+     * <pre>\n+     * SELECT\n+     *   CLR0.LOGICAL_ID\n+     * FROM\n+     *   Patient_LOGICAL_RESOURCES AS CLR0\n+     *   JOIN Patient_RESOURCES AS CR0 ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+     * WHERE\n+     *   EXISTS (\n+     *     SELECT\n+     *       1\n+     *     FROM\n+     *       Observation_TOKEN_VALUES_V AS CP1\n+     *       JOIN Observation_LOGICAL_RESOURCES AS CLR1 ON CLR1.LOGICAL_RESOURCE_ID = CP1.LOGICAL_RESOURCE_ID\n+     *       JOIN Observation_RESOURCES AS CR1 ON CR1.RESOURCE_ID = CLR1.CURRENT_RESOURCE_ID AND CR1.IS_DELETED = 'N'\n+     *       JOIN Observation_TOKEN_VALUES_V AS CP2 ON CP2.LOGICAL_RESOURCE_ID = CLR1.LOGICAL_RESOURCE_ID\n+     *       AND (\n+     *         CP2.PARAMETER_NAME_ID = 1073\n+     *         AND ((CP2.TOKEN_VALUE = ?))\n+     *       )\n+     *     WHERE\n+     *       CP1.TOKEN_VALUE = CLR0.LOGICAL_ID\n+     *       AND CP1.PARAMETER_NAME_ID = 1274\n+     *       AND CP1.CODE_SYSTEM_ID = 20004\n+     *   )\n+     * </pre>\n+     *\n+     * @see https://www.hl7.org/fhir/search.html#has\n+     * @param resourceType\n+     *                  - The resource type being searched.\n+     * @param queryParm\n+     *                  - A Parameter representing a reverse chained query.\n+     * @return SqlQueryData\n+     *                  - The query segment for a reverse chained parameter reference search.\n+     * @throws Exception\n+     */\n+    @Override\n+    protected SqlQueryData processReverseChainedReferenceParm(Class<?> resourceType, QueryParameter queryParm) throws Exception {\n+        final String METHODNAME = \"processReverseChainedReferenceParm\";\n+        log.entering(CLASSNAME, METHODNAME, queryParm.toString());\n+\n+        final String CR = \"CR\";\n+        final String CLR = \"CLR\";\n+        final String CP = \"CP\";\n+        String prevChainedResourceVar = null;\n+        String prevChainedLogicalResourceVar = null;\n+        String chainedResourceVar = null;\n+        String chainedLogicalResourceVar = null;\n+        String chainedParmVar = null;\n+        String nextChainedResourceVar = null;\n+        String nextChainedLogicalResourceVar = null;\n+        String nextChainedParmVar = null;\n+        QueryParameter previousParm = null;;\n+        int parmIndex = 0;\n+        int lastParmIndex = queryParm.getChain().size();\n+        boolean chainedParmProcessed = false;\n+        StringBuilder selectSegments = new StringBuilder();\n+        StringBuilder whereClauseSegments = new StringBuilder();\n+        List<Object> bindVariables = new ArrayList<>();\n+\n+        // Loop through the chained query parameters in order\n+        List<QueryParameter> queryParms = queryParm.getChain();\n+        queryParms.add(0, queryParm);\n+        for (QueryParameter currentParm : queryParms) {\n+\n+            prevChainedResourceVar        = CR + parmIndex;\n+            prevChainedLogicalResourceVar = CLR + parmIndex;\n+            chainedResourceVar        = CR + (parmIndex + 1);\n+            chainedLogicalResourceVar = CLR + (parmIndex + 1);\n+            chainedParmVar            = CP + (parmIndex + 1);\n+            nextChainedResourceVar        = CR + (parmIndex + 2);\n+            nextChainedLogicalResourceVar = CLR + (parmIndex + 2);\n+            nextChainedParmVar        = CP + (parmIndex + 2);\n+            StringBuilder whereClauseSegment = new StringBuilder();\n+\n+            if (parmIndex == 0) {\n+                // BUild outer select: SELECT CLR0.LOGICAL_ID\n+                //                       FROM <resource-type>_LOGICAL_RESOURCES AS CLR0\n+                //                       JOIN <resource-type>_RESOURCES AS CR0\n+                //                         ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+                //                       WHERE\n+                selectSegments.append(\"SELECT \" + prevChainedLogicalResourceVar + DOT + \"LOGICAL_ID\")\n+                                .append(FROM + resourceType.getSimpleName() + \"_LOGICAL_RESOURCES AS \" + prevChainedLogicalResourceVar)\n+                                .append(JOIN + resourceType.getSimpleName() + \"_RESOURCES AS \" + prevChainedResourceVar)\n+                                .append(ON + prevChainedResourceVar + DOT + \"RESOURCE_ID\" + EQ + prevChainedLogicalResourceVar + DOT + \"CURRENT_RESOURCE_ID\")\n+                                .append(AND + prevChainedResourceVar + DOT + \"IS_DELETED\" + EQ + \"'N'\")\n+                                .append(WHERE);\n+            }\n+\n+            if (parmIndex < lastParmIndex) {\n+                if (currentParm.isReverseChained()) {\n+                    // Build inner select joins: EXISTS (SELECT 1\n+                    //                           FROM <modifierTypeResourceName>_TOKEN_VALUES_V AS CPx\n+                    //                           JOIN <modifierTypeResourceName>_LOGICAL_RESOURCES AS CLRx\n+                    //                             ON CLRx.LOGICAL_RESOURCE_ID = CPx.LOGICAL_RESOURCE_ID\n+                    //                           JOIN <modifierTypeResourceName>_RESOURCES AS CRx\n+                    //                             ON CRx.RESOURCE_ID = CLRx.CURRENT_RESOURCE_ID AND CRx.IS_DELETED = 'N'\n+                    selectSegments.append(\"EXISTS \" + LEFT_PAREN + \"SELECT 1\")\n+                                    .append(FROM + currentParm.getModifierResourceTypeName() + \"_TOKEN_VALUES_V AS \" + chainedParmVar)\n+                                    .append(JOIN + currentParm.getModifierResourceTypeName() + \"_LOGICAL_RESOURCES AS \" + chainedLogicalResourceVar)\n+                                    .append(ON + chainedLogicalResourceVar + DOT + \"LOGICAL_RESOURCE_ID\" + EQ + chainedParmVar + DOT + \"LOGICAL_RESOURCE_ID\")\n+                                    .append(JOIN + currentParm.getModifierResourceTypeName() + \"_RESOURCES AS \" + chainedResourceVar)\n+                                    .append(ON + chainedResourceVar + DOT + \"RESOURCE_ID\" + EQ + chainedLogicalResourceVar + DOT + \"CURRENT_RESOURCE_ID\")\n+                                    .append(AND + chainedResourceVar + DOT + \"IS_DELETED\" + EQ + \"'N'\");\n+\n+                    String referencedResourceType = null;\n+                    if (parmIndex == 0) {\n+                        referencedResourceType = resourceType.getSimpleName();\n+                    } else {\n+                        referencedResourceType = previousParm.getModifierResourceTypeName();\n+                    }\n+                    if (parmIndex < lastParmIndex - 1 && currentParm.getNextParameter().isReverseChained()) {\n+                        // Build inner select where clause: WHERE CPx.TOKEN_VALUE = CLR<x-1>.LOGICAL_ID\n+                        //                                    AND CPx.PARAMETER_NAME_ID = <parm-name-id>\n+                        //                                    AND CPx.CDE_SYSTEM_ID = <code-system-id>\n+                        //                                    AND\n+                        selectSegments.append(WHERE + chainedParmVar + DOT + \"TOKEN_VALUE\" + EQ + prevChainedLogicalResourceVar + DOT + \"LOGICAL_ID\" + AND);\n+                        populateReferenceNameAndCodeSystemIdSubSegment(selectSegments, currentParm.getCode(), referencedResourceType, chainedParmVar);\n+                        selectSegments.append(AND);\n+                    } else {\n+                        // Build final inner select where clause: WHERE CPx.TOKEN_VALUE = CLR<x-1>.LOGICAL_ID\n+                        //                                          AND CPx.PARAMETER_NAME_ID = <parm-name-id>\n+                        //                                          AND CPx.CDE_SYSTEM_ID = <code-system-id>\n+                        whereClauseSegment.append(WHERE + chainedParmVar + DOT + \"TOKEN_VALUE\" + EQ + prevChainedLogicalResourceVar + DOT + \"LOGICAL_ID\" + AND);\n+                        populateReferenceNameAndCodeSystemIdSubSegment(whereClauseSegment, currentParm.getCode(), referencedResourceType, chainedParmVar);\n+                    }\n+\n+                    // Add closing right paren for EXISTS\n+                    whereClauseSegment.append(RIGHT_PAREN);\n+                } else if (currentParm.isChained()) {\n+                    // Build chained query\n+                    if (!chainedParmProcessed) {\n+                        // Build initial chain join and select:\n+                        // SELECT CPx.LOGICAL_RESOURCE_ID FROM <modifierTypeResourceName>_TOKEN_VALUES_V AS CPx WHERE\n+                        selectSegments.append(JOIN + LEFT_PAREN)\n+                                        .append(\"SELECT \" + chainedParmVar + DOT + \"LOGICAL_RESOURCE_ID\" + FROM)\n+                                        .append(previousParm.getModifierResourceTypeName() + \"_TOKEN_VALUES_V AS \" + chainedParmVar + WHERE);\n+                    }\n+\n+                    // Build this piece: CPx.PARAMETER_NAME_ID = <code-id> AND CPx.STR_VALUE IN\n+                    appendMidChainParm(selectSegments, currentParm, chainedParmVar);\n+\n+                    // Build this piece: (SELECT 'resource-type-name' || '/' || CLR<x+1>.LOGICAL_ID ...\n+                    selectSegments.append(LEFT_PAREN);\n+                    appendInnerSelect(selectSegments, currentParm, currentParm.getModifierResourceTypeName(),\n+                        nextChainedResourceVar, nextChainedLogicalResourceVar, nextChainedParmVar);\n+                    whereClauseSegment.append(RIGHT_PAREN);\n+\n+                    if (!chainedParmProcessed) {\n+                        chainedParmProcessed = true;\n+\n+                        // BUild ON clause for join: ) AS CPx ON CPx.LOGICAL_RESOURCE_ID = CLR<x-1>.LOGICAL_RESOURCE_ID", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "originalPosition": 181}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzgyMzc2", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-523382376", "createdAt": "2020-11-04T13:56:46Z", "commit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo1Njo0N1rOHtZJqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo1Njo0N1rOHtZJqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2MDA0Mw==", "bodyText": "You could embed the !chainedParmProcessed block down here, and only test this branch at most once\nNet, I'm suggesting a logic change where the test if (!\"_id\".equals(currentParm.getCode())) {  is not in some circumstances twice, and branching of !chainedParmProcessed is done here before the existing code in this branch\nP.S. I think this works, please validate.", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517360043", "createdAt": "2020-11-04T13:56:47Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -1384,4 +1386,242 @@ private SqlQueryData processMissingParm(Class<?> resourceType, QueryParameter qu\n         log.exiting(CLASSNAME, METHODNAME);\n         return queryData;\n     }\n+\n+    /**\n+     * Contains special logic for handling reverse chained reference search parameters.\n+     * <p>\n+     * A select statement is built to realize the reverse chaining logic required. Here is a sample\n+     * reverse chained query for a Patient given this search parameter: _has:Observation:patient:code=1234\n+     *\n+     * <pre>\n+     * SELECT\n+     *   CLR0.LOGICAL_ID\n+     * FROM\n+     *   Patient_LOGICAL_RESOURCES AS CLR0\n+     *   JOIN Patient_RESOURCES AS CR0 ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+     * WHERE\n+     *   EXISTS (\n+     *     SELECT\n+     *       1\n+     *     FROM\n+     *       Observation_TOKEN_VALUES_V AS CP1\n+     *       JOIN Observation_LOGICAL_RESOURCES AS CLR1 ON CLR1.LOGICAL_RESOURCE_ID = CP1.LOGICAL_RESOURCE_ID\n+     *       JOIN Observation_RESOURCES AS CR1 ON CR1.RESOURCE_ID = CLR1.CURRENT_RESOURCE_ID AND CR1.IS_DELETED = 'N'\n+     *       JOIN Observation_TOKEN_VALUES_V AS CP2 ON CP2.LOGICAL_RESOURCE_ID = CLR1.LOGICAL_RESOURCE_ID\n+     *       AND (\n+     *         CP2.PARAMETER_NAME_ID = 1073\n+     *         AND ((CP2.TOKEN_VALUE = ?))\n+     *       )\n+     *     WHERE\n+     *       CP1.TOKEN_VALUE = CLR0.LOGICAL_ID\n+     *       AND CP1.PARAMETER_NAME_ID = 1274\n+     *       AND CP1.CODE_SYSTEM_ID = 20004\n+     *   )\n+     * </pre>\n+     *\n+     * @see https://www.hl7.org/fhir/search.html#has\n+     * @param resourceType\n+     *                  - The resource type being searched.\n+     * @param queryParm\n+     *                  - A Parameter representing a reverse chained query.\n+     * @return SqlQueryData\n+     *                  - The query segment for a reverse chained parameter reference search.\n+     * @throws Exception\n+     */\n+    @Override\n+    protected SqlQueryData processReverseChainedReferenceParm(Class<?> resourceType, QueryParameter queryParm) throws Exception {\n+        final String METHODNAME = \"processReverseChainedReferenceParm\";\n+        log.entering(CLASSNAME, METHODNAME, queryParm.toString());\n+\n+        final String CR = \"CR\";\n+        final String CLR = \"CLR\";\n+        final String CP = \"CP\";\n+        String prevChainedResourceVar = null;\n+        String prevChainedLogicalResourceVar = null;\n+        String chainedResourceVar = null;\n+        String chainedLogicalResourceVar = null;\n+        String chainedParmVar = null;\n+        String nextChainedResourceVar = null;\n+        String nextChainedLogicalResourceVar = null;\n+        String nextChainedParmVar = null;\n+        QueryParameter previousParm = null;;\n+        int parmIndex = 0;\n+        int lastParmIndex = queryParm.getChain().size();\n+        boolean chainedParmProcessed = false;\n+        StringBuilder selectSegments = new StringBuilder();\n+        StringBuilder whereClauseSegments = new StringBuilder();\n+        List<Object> bindVariables = new ArrayList<>();\n+\n+        // Loop through the chained query parameters in order\n+        List<QueryParameter> queryParms = queryParm.getChain();\n+        queryParms.add(0, queryParm);\n+        for (QueryParameter currentParm : queryParms) {\n+\n+            prevChainedResourceVar        = CR + parmIndex;\n+            prevChainedLogicalResourceVar = CLR + parmIndex;\n+            chainedResourceVar        = CR + (parmIndex + 1);\n+            chainedLogicalResourceVar = CLR + (parmIndex + 1);\n+            chainedParmVar            = CP + (parmIndex + 1);\n+            nextChainedResourceVar        = CR + (parmIndex + 2);\n+            nextChainedLogicalResourceVar = CLR + (parmIndex + 2);\n+            nextChainedParmVar        = CP + (parmIndex + 2);\n+            StringBuilder whereClauseSegment = new StringBuilder();\n+\n+            if (parmIndex == 0) {\n+                // BUild outer select: SELECT CLR0.LOGICAL_ID\n+                //                       FROM <resource-type>_LOGICAL_RESOURCES AS CLR0\n+                //                       JOIN <resource-type>_RESOURCES AS CR0\n+                //                         ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+                //                       WHERE\n+                selectSegments.append(\"SELECT \" + prevChainedLogicalResourceVar + DOT + \"LOGICAL_ID\")\n+                                .append(FROM + resourceType.getSimpleName() + \"_LOGICAL_RESOURCES AS \" + prevChainedLogicalResourceVar)\n+                                .append(JOIN + resourceType.getSimpleName() + \"_RESOURCES AS \" + prevChainedResourceVar)\n+                                .append(ON + prevChainedResourceVar + DOT + \"RESOURCE_ID\" + EQ + prevChainedLogicalResourceVar + DOT + \"CURRENT_RESOURCE_ID\")\n+                                .append(AND + prevChainedResourceVar + DOT + \"IS_DELETED\" + EQ + \"'N'\")\n+                                .append(WHERE);\n+            }\n+\n+            if (parmIndex < lastParmIndex) {\n+                if (currentParm.isReverseChained()) {\n+                    // Build inner select joins: EXISTS (SELECT 1\n+                    //                           FROM <modifierTypeResourceName>_TOKEN_VALUES_V AS CPx\n+                    //                           JOIN <modifierTypeResourceName>_LOGICAL_RESOURCES AS CLRx\n+                    //                             ON CLRx.LOGICAL_RESOURCE_ID = CPx.LOGICAL_RESOURCE_ID\n+                    //                           JOIN <modifierTypeResourceName>_RESOURCES AS CRx\n+                    //                             ON CRx.RESOURCE_ID = CLRx.CURRENT_RESOURCE_ID AND CRx.IS_DELETED = 'N'\n+                    selectSegments.append(\"EXISTS \" + LEFT_PAREN + \"SELECT 1\")\n+                                    .append(FROM + currentParm.getModifierResourceTypeName() + \"_TOKEN_VALUES_V AS \" + chainedParmVar)\n+                                    .append(JOIN + currentParm.getModifierResourceTypeName() + \"_LOGICAL_RESOURCES AS \" + chainedLogicalResourceVar)\n+                                    .append(ON + chainedLogicalResourceVar + DOT + \"LOGICAL_RESOURCE_ID\" + EQ + chainedParmVar + DOT + \"LOGICAL_RESOURCE_ID\")\n+                                    .append(JOIN + currentParm.getModifierResourceTypeName() + \"_RESOURCES AS \" + chainedResourceVar)\n+                                    .append(ON + chainedResourceVar + DOT + \"RESOURCE_ID\" + EQ + chainedLogicalResourceVar + DOT + \"CURRENT_RESOURCE_ID\")\n+                                    .append(AND + chainedResourceVar + DOT + \"IS_DELETED\" + EQ + \"'N'\");\n+\n+                    String referencedResourceType = null;\n+                    if (parmIndex == 0) {\n+                        referencedResourceType = resourceType.getSimpleName();\n+                    } else {\n+                        referencedResourceType = previousParm.getModifierResourceTypeName();\n+                    }\n+                    if (parmIndex < lastParmIndex - 1 && currentParm.getNextParameter().isReverseChained()) {\n+                        // Build inner select where clause: WHERE CPx.TOKEN_VALUE = CLR<x-1>.LOGICAL_ID\n+                        //                                    AND CPx.PARAMETER_NAME_ID = <parm-name-id>\n+                        //                                    AND CPx.CDE_SYSTEM_ID = <code-system-id>\n+                        //                                    AND\n+                        selectSegments.append(WHERE + chainedParmVar + DOT + \"TOKEN_VALUE\" + EQ + prevChainedLogicalResourceVar + DOT + \"LOGICAL_ID\" + AND);\n+                        populateReferenceNameAndCodeSystemIdSubSegment(selectSegments, currentParm.getCode(), referencedResourceType, chainedParmVar);\n+                        selectSegments.append(AND);\n+                    } else {\n+                        // Build final inner select where clause: WHERE CPx.TOKEN_VALUE = CLR<x-1>.LOGICAL_ID\n+                        //                                          AND CPx.PARAMETER_NAME_ID = <parm-name-id>\n+                        //                                          AND CPx.CDE_SYSTEM_ID = <code-system-id>\n+                        whereClauseSegment.append(WHERE + chainedParmVar + DOT + \"TOKEN_VALUE\" + EQ + prevChainedLogicalResourceVar + DOT + \"LOGICAL_ID\" + AND);\n+                        populateReferenceNameAndCodeSystemIdSubSegment(whereClauseSegment, currentParm.getCode(), referencedResourceType, chainedParmVar);\n+                    }\n+\n+                    // Add closing right paren for EXISTS\n+                    whereClauseSegment.append(RIGHT_PAREN);\n+                } else if (currentParm.isChained()) {\n+                    // Build chained query\n+                    if (!chainedParmProcessed) {\n+                        // Build initial chain join and select:\n+                        // SELECT CPx.LOGICAL_RESOURCE_ID FROM <modifierTypeResourceName>_TOKEN_VALUES_V AS CPx WHERE\n+                        selectSegments.append(JOIN + LEFT_PAREN)\n+                                        .append(\"SELECT \" + chainedParmVar + DOT + \"LOGICAL_RESOURCE_ID\" + FROM)\n+                                        .append(previousParm.getModifierResourceTypeName() + \"_TOKEN_VALUES_V AS \" + chainedParmVar + WHERE);\n+                    }\n+\n+                    // Build this piece: CPx.PARAMETER_NAME_ID = <code-id> AND CPx.STR_VALUE IN\n+                    appendMidChainParm(selectSegments, currentParm, chainedParmVar);\n+\n+                    // Build this piece: (SELECT 'resource-type-name' || '/' || CLR<x+1>.LOGICAL_ID ...\n+                    selectSegments.append(LEFT_PAREN);\n+                    appendInnerSelect(selectSegments, currentParm, currentParm.getModifierResourceTypeName(),\n+                        nextChainedResourceVar, nextChainedLogicalResourceVar, nextChainedParmVar);\n+                    whereClauseSegment.append(RIGHT_PAREN);\n+\n+                    if (!chainedParmProcessed) {\n+                        chainedParmProcessed = true;\n+\n+                        // BUild ON clause for join: ) AS CPx ON CPx.LOGICAL_RESOURCE_ID = CLR<x-1>.LOGICAL_RESOURCE_ID\n+                        whereClauseSegment.append(RIGHT_PAREN + \" AS \" + chainedParmVar + ON)\n+                                            .append(chainedParmVar + DOT + \"LOGICAL_RESOURCE_ID\" + EQ + prevChainedLogicalResourceVar + DOT + \"LOGICAL_RESOURCE_ID\");\n+                    }\n+                }\n+            } else if (parmIndex == lastParmIndex) {\n+                // This logic processes the LAST parameter in the chain.\n+                if (!chainedParmProcessed) {\n+                    if (!\"_id\".equals(currentParm.getCode())) {\n+                        // Build this join: JOIN <modifierTypeResourceName>_<type>_VALUES AS CPx\n+                        //                    ON CPx.LOGICAL_RESOURCE_ID = CLR<x-1>.LOGICAL_RESOURCE_ID\n+                        //                    AND\n+                        whereClauseSegment.append(JOIN + QuerySegmentAggregator.tableName(previousParm.getModifierResourceTypeName(), currentParm))\n+                                            .append(\" AS \" + chainedParmVar + ON + chainedParmVar + DOT + \"LOGICAL_RESOURCE_ID\");\n+                    } else {\n+                        // Build this join: JOIN <modifierTypeResourceName>_LOGICAL_RESOURCES AS CLRx\n+                        //                    ON CLRx.LOGICAL_RESOURCE_ID = CLR<x-1>.LOGICAL_RESOURCE_ID\n+                        //                    AND\n+                        whereClauseSegment.append(JOIN + previousParm.getModifierResourceTypeName() + \"_LOGICAL_RESOURCES\")\n+                                            .append(\" AS \" + chainedLogicalResourceVar + ON + chainedLogicalResourceVar + DOT + \"LOGICAL_RESOURCE_ID\");\n+                    }\n+                    whereClauseSegment.append(EQ + prevChainedLogicalResourceVar + DOT + \"LOGICAL_RESOURCE_ID\" + AND);\n+                }\n+\n+                // Build the rest\n+                SqlQueryData sqlQueryData;\n+                if (!\"_id\".equals(currentParm.getCode())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "originalPosition": 207}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzgzMzEw", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-523383310", "createdAt": "2020-11-04T13:57:50Z", "commit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo1Nzo1MFrOHtZMXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo1Nzo1MFrOHtZMXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2MDczNA==", "bodyText": "Not to change too much, but please note we use code not names. I think for consistency, we probably leave as name here.", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517360734", "createdAt": "2020-11-04T13:57:50Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -1384,4 +1386,242 @@ private SqlQueryData processMissingParm(Class<?> resourceType, QueryParameter qu\n         log.exiting(CLASSNAME, METHODNAME);\n         return queryData;\n     }\n+\n+    /**\n+     * Contains special logic for handling reverse chained reference search parameters.\n+     * <p>\n+     * A select statement is built to realize the reverse chaining logic required. Here is a sample\n+     * reverse chained query for a Patient given this search parameter: _has:Observation:patient:code=1234\n+     *\n+     * <pre>\n+     * SELECT\n+     *   CLR0.LOGICAL_ID\n+     * FROM\n+     *   Patient_LOGICAL_RESOURCES AS CLR0\n+     *   JOIN Patient_RESOURCES AS CR0 ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+     * WHERE\n+     *   EXISTS (\n+     *     SELECT\n+     *       1\n+     *     FROM\n+     *       Observation_TOKEN_VALUES_V AS CP1\n+     *       JOIN Observation_LOGICAL_RESOURCES AS CLR1 ON CLR1.LOGICAL_RESOURCE_ID = CP1.LOGICAL_RESOURCE_ID\n+     *       JOIN Observation_RESOURCES AS CR1 ON CR1.RESOURCE_ID = CLR1.CURRENT_RESOURCE_ID AND CR1.IS_DELETED = 'N'\n+     *       JOIN Observation_TOKEN_VALUES_V AS CP2 ON CP2.LOGICAL_RESOURCE_ID = CLR1.LOGICAL_RESOURCE_ID\n+     *       AND (\n+     *         CP2.PARAMETER_NAME_ID = 1073\n+     *         AND ((CP2.TOKEN_VALUE = ?))\n+     *       )\n+     *     WHERE\n+     *       CP1.TOKEN_VALUE = CLR0.LOGICAL_ID\n+     *       AND CP1.PARAMETER_NAME_ID = 1274\n+     *       AND CP1.CODE_SYSTEM_ID = 20004\n+     *   )\n+     * </pre>\n+     *\n+     * @see https://www.hl7.org/fhir/search.html#has\n+     * @param resourceType\n+     *                  - The resource type being searched.\n+     * @param queryParm\n+     *                  - A Parameter representing a reverse chained query.\n+     * @return SqlQueryData\n+     *                  - The query segment for a reverse chained parameter reference search.\n+     * @throws Exception\n+     */\n+    @Override\n+    protected SqlQueryData processReverseChainedReferenceParm(Class<?> resourceType, QueryParameter queryParm) throws Exception {\n+        final String METHODNAME = \"processReverseChainedReferenceParm\";\n+        log.entering(CLASSNAME, METHODNAME, queryParm.toString());\n+\n+        final String CR = \"CR\";\n+        final String CLR = \"CLR\";\n+        final String CP = \"CP\";\n+        String prevChainedResourceVar = null;\n+        String prevChainedLogicalResourceVar = null;\n+        String chainedResourceVar = null;\n+        String chainedLogicalResourceVar = null;\n+        String chainedParmVar = null;\n+        String nextChainedResourceVar = null;\n+        String nextChainedLogicalResourceVar = null;\n+        String nextChainedParmVar = null;\n+        QueryParameter previousParm = null;;\n+        int parmIndex = 0;\n+        int lastParmIndex = queryParm.getChain().size();\n+        boolean chainedParmProcessed = false;\n+        StringBuilder selectSegments = new StringBuilder();\n+        StringBuilder whereClauseSegments = new StringBuilder();\n+        List<Object> bindVariables = new ArrayList<>();\n+\n+        // Loop through the chained query parameters in order\n+        List<QueryParameter> queryParms = queryParm.getChain();\n+        queryParms.add(0, queryParm);\n+        for (QueryParameter currentParm : queryParms) {\n+\n+            prevChainedResourceVar        = CR + parmIndex;\n+            prevChainedLogicalResourceVar = CLR + parmIndex;\n+            chainedResourceVar        = CR + (parmIndex + 1);\n+            chainedLogicalResourceVar = CLR + (parmIndex + 1);\n+            chainedParmVar            = CP + (parmIndex + 1);\n+            nextChainedResourceVar        = CR + (parmIndex + 2);\n+            nextChainedLogicalResourceVar = CLR + (parmIndex + 2);\n+            nextChainedParmVar        = CP + (parmIndex + 2);\n+            StringBuilder whereClauseSegment = new StringBuilder();\n+\n+            if (parmIndex == 0) {\n+                // BUild outer select: SELECT CLR0.LOGICAL_ID\n+                //                       FROM <resource-type>_LOGICAL_RESOURCES AS CLR0\n+                //                       JOIN <resource-type>_RESOURCES AS CR0\n+                //                         ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+                //                       WHERE\n+                selectSegments.append(\"SELECT \" + prevChainedLogicalResourceVar + DOT + \"LOGICAL_ID\")\n+                                .append(FROM + resourceType.getSimpleName() + \"_LOGICAL_RESOURCES AS \" + prevChainedLogicalResourceVar)\n+                                .append(JOIN + resourceType.getSimpleName() + \"_RESOURCES AS \" + prevChainedResourceVar)\n+                                .append(ON + prevChainedResourceVar + DOT + \"RESOURCE_ID\" + EQ + prevChainedLogicalResourceVar + DOT + \"CURRENT_RESOURCE_ID\")\n+                                .append(AND + prevChainedResourceVar + DOT + \"IS_DELETED\" + EQ + \"'N'\")\n+                                .append(WHERE);\n+            }\n+\n+            if (parmIndex < lastParmIndex) {\n+                if (currentParm.isReverseChained()) {\n+                    // Build inner select joins: EXISTS (SELECT 1\n+                    //                           FROM <modifierTypeResourceName>_TOKEN_VALUES_V AS CPx\n+                    //                           JOIN <modifierTypeResourceName>_LOGICAL_RESOURCES AS CLRx\n+                    //                             ON CLRx.LOGICAL_RESOURCE_ID = CPx.LOGICAL_RESOURCE_ID\n+                    //                           JOIN <modifierTypeResourceName>_RESOURCES AS CRx\n+                    //                             ON CRx.RESOURCE_ID = CLRx.CURRENT_RESOURCE_ID AND CRx.IS_DELETED = 'N'\n+                    selectSegments.append(\"EXISTS \" + LEFT_PAREN + \"SELECT 1\")\n+                                    .append(FROM + currentParm.getModifierResourceTypeName() + \"_TOKEN_VALUES_V AS \" + chainedParmVar)\n+                                    .append(JOIN + currentParm.getModifierResourceTypeName() + \"_LOGICAL_RESOURCES AS \" + chainedLogicalResourceVar)\n+                                    .append(ON + chainedLogicalResourceVar + DOT + \"LOGICAL_RESOURCE_ID\" + EQ + chainedParmVar + DOT + \"LOGICAL_RESOURCE_ID\")\n+                                    .append(JOIN + currentParm.getModifierResourceTypeName() + \"_RESOURCES AS \" + chainedResourceVar)\n+                                    .append(ON + chainedResourceVar + DOT + \"RESOURCE_ID\" + EQ + chainedLogicalResourceVar + DOT + \"CURRENT_RESOURCE_ID\")\n+                                    .append(AND + chainedResourceVar + DOT + \"IS_DELETED\" + EQ + \"'N'\");\n+\n+                    String referencedResourceType = null;\n+                    if (parmIndex == 0) {\n+                        referencedResourceType = resourceType.getSimpleName();\n+                    } else {\n+                        referencedResourceType = previousParm.getModifierResourceTypeName();\n+                    }\n+                    if (parmIndex < lastParmIndex - 1 && currentParm.getNextParameter().isReverseChained()) {\n+                        // Build inner select where clause: WHERE CPx.TOKEN_VALUE = CLR<x-1>.LOGICAL_ID\n+                        //                                    AND CPx.PARAMETER_NAME_ID = <parm-name-id>\n+                        //                                    AND CPx.CDE_SYSTEM_ID = <code-system-id>\n+                        //                                    AND\n+                        selectSegments.append(WHERE + chainedParmVar + DOT + \"TOKEN_VALUE\" + EQ + prevChainedLogicalResourceVar + DOT + \"LOGICAL_ID\" + AND);\n+                        populateReferenceNameAndCodeSystemIdSubSegment(selectSegments, currentParm.getCode(), referencedResourceType, chainedParmVar);\n+                        selectSegments.append(AND);\n+                    } else {\n+                        // Build final inner select where clause: WHERE CPx.TOKEN_VALUE = CLR<x-1>.LOGICAL_ID\n+                        //                                          AND CPx.PARAMETER_NAME_ID = <parm-name-id>\n+                        //                                          AND CPx.CDE_SYSTEM_ID = <code-system-id>\n+                        whereClauseSegment.append(WHERE + chainedParmVar + DOT + \"TOKEN_VALUE\" + EQ + prevChainedLogicalResourceVar + DOT + \"LOGICAL_ID\" + AND);\n+                        populateReferenceNameAndCodeSystemIdSubSegment(whereClauseSegment, currentParm.getCode(), referencedResourceType, chainedParmVar);\n+                    }\n+\n+                    // Add closing right paren for EXISTS\n+                    whereClauseSegment.append(RIGHT_PAREN);\n+                } else if (currentParm.isChained()) {\n+                    // Build chained query\n+                    if (!chainedParmProcessed) {\n+                        // Build initial chain join and select:\n+                        // SELECT CPx.LOGICAL_RESOURCE_ID FROM <modifierTypeResourceName>_TOKEN_VALUES_V AS CPx WHERE\n+                        selectSegments.append(JOIN + LEFT_PAREN)\n+                                        .append(\"SELECT \" + chainedParmVar + DOT + \"LOGICAL_RESOURCE_ID\" + FROM)\n+                                        .append(previousParm.getModifierResourceTypeName() + \"_TOKEN_VALUES_V AS \" + chainedParmVar + WHERE);\n+                    }\n+\n+                    // Build this piece: CPx.PARAMETER_NAME_ID = <code-id> AND CPx.STR_VALUE IN\n+                    appendMidChainParm(selectSegments, currentParm, chainedParmVar);\n+\n+                    // Build this piece: (SELECT 'resource-type-name' || '/' || CLR<x+1>.LOGICAL_ID ...\n+                    selectSegments.append(LEFT_PAREN);\n+                    appendInnerSelect(selectSegments, currentParm, currentParm.getModifierResourceTypeName(),\n+                        nextChainedResourceVar, nextChainedLogicalResourceVar, nextChainedParmVar);\n+                    whereClauseSegment.append(RIGHT_PAREN);\n+\n+                    if (!chainedParmProcessed) {\n+                        chainedParmProcessed = true;\n+\n+                        // BUild ON clause for join: ) AS CPx ON CPx.LOGICAL_RESOURCE_ID = CLR<x-1>.LOGICAL_RESOURCE_ID\n+                        whereClauseSegment.append(RIGHT_PAREN + \" AS \" + chainedParmVar + ON)\n+                                            .append(chainedParmVar + DOT + \"LOGICAL_RESOURCE_ID\" + EQ + prevChainedLogicalResourceVar + DOT + \"LOGICAL_RESOURCE_ID\");\n+                    }\n+                }\n+            } else if (parmIndex == lastParmIndex) {\n+                // This logic processes the LAST parameter in the chain.\n+                if (!chainedParmProcessed) {\n+                    if (!\"_id\".equals(currentParm.getCode())) {\n+                        // Build this join: JOIN <modifierTypeResourceName>_<type>_VALUES AS CPx\n+                        //                    ON CPx.LOGICAL_RESOURCE_ID = CLR<x-1>.LOGICAL_RESOURCE_ID\n+                        //                    AND\n+                        whereClauseSegment.append(JOIN + QuerySegmentAggregator.tableName(previousParm.getModifierResourceTypeName(), currentParm))\n+                                            .append(\" AS \" + chainedParmVar + ON + chainedParmVar + DOT + \"LOGICAL_RESOURCE_ID\");\n+                    } else {\n+                        // Build this join: JOIN <modifierTypeResourceName>_LOGICAL_RESOURCES AS CLRx\n+                        //                    ON CLRx.LOGICAL_RESOURCE_ID = CLR<x-1>.LOGICAL_RESOURCE_ID\n+                        //                    AND\n+                        whereClauseSegment.append(JOIN + previousParm.getModifierResourceTypeName() + \"_LOGICAL_RESOURCES\")\n+                                            .append(\" AS \" + chainedLogicalResourceVar + ON + chainedLogicalResourceVar + DOT + \"LOGICAL_RESOURCE_ID\");\n+                    }\n+                    whereClauseSegment.append(EQ + prevChainedLogicalResourceVar + DOT + \"LOGICAL_RESOURCE_ID\" + AND);\n+                }\n+\n+                // Build the rest\n+                SqlQueryData sqlQueryData;\n+                if (!\"_id\".equals(currentParm.getCode())) {\n+                    // (CPx.PARAMETER_NAME_ID=<code-id> AND (CPx.<type>_VALUE=<valueCode>))\n+                    sqlQueryData = buildQueryParm(ModelSupport.getResourceType(previousParm.getModifierResourceTypeName()), currentParm, chainedParmVar);\n+                } else {\n+                    // CLRx.LOGICAL_ID IN (?)\n+                    sqlQueryData = buildChainedIdClause(currentParm, chainedParmVar);\n+                }\n+\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"chained sqlQueryData[\" + chainedParmVar + \"] = \" + sqlQueryData.getQueryString());\n+                }\n+                whereClauseSegment.append(sqlQueryData.getQueryString());\n+                bindVariables.addAll(sqlQueryData.getBindVariables());\n+           }\n+\n+            // Insert where clause segment in whole\n+            whereClauseSegments.insert(0, whereClauseSegment.toString());\n+\n+            previousParm = currentParm;\n+            parmIndex++;\n+        }\n+\n+        SqlQueryData queryData = new SqlQueryData(whereClauseSegments.insert(0, selectSegments.toString()).toString(), bindVariables);\n+        log.exiting(CLASSNAME, METHODNAME, queryData.getQueryString());\n+        return queryData;\n+    }\n+\n+    /**\n+     * Populates the reference parameter name ID and code system ID sub-segment of the passed where clause segment.\n+     *\n+     * @param whereClauseSegment - the segment to which the sub-segment will be added\n+     * @param queryParmName - the search parameter name\n+     * @param resourceTypeName - the resource type of the reference being followed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "originalPosition": 239}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzgzODk4", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-523383898", "createdAt": "2020-11-04T13:58:29Z", "commit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo1ODoyOVrOHtZN7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo1ODoyOVrOHtZN7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2MTEzMw==", "bodyText": "candidate for breaking into individual appends.", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517361133", "createdAt": "2020-11-04T13:58:29Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -1384,4 +1386,242 @@ private SqlQueryData processMissingParm(Class<?> resourceType, QueryParameter qu\n         log.exiting(CLASSNAME, METHODNAME);\n         return queryData;\n     }\n+\n+    /**\n+     * Contains special logic for handling reverse chained reference search parameters.\n+     * <p>\n+     * A select statement is built to realize the reverse chaining logic required. Here is a sample\n+     * reverse chained query for a Patient given this search parameter: _has:Observation:patient:code=1234\n+     *\n+     * <pre>\n+     * SELECT\n+     *   CLR0.LOGICAL_ID\n+     * FROM\n+     *   Patient_LOGICAL_RESOURCES AS CLR0\n+     *   JOIN Patient_RESOURCES AS CR0 ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+     * WHERE\n+     *   EXISTS (\n+     *     SELECT\n+     *       1\n+     *     FROM\n+     *       Observation_TOKEN_VALUES_V AS CP1\n+     *       JOIN Observation_LOGICAL_RESOURCES AS CLR1 ON CLR1.LOGICAL_RESOURCE_ID = CP1.LOGICAL_RESOURCE_ID\n+     *       JOIN Observation_RESOURCES AS CR1 ON CR1.RESOURCE_ID = CLR1.CURRENT_RESOURCE_ID AND CR1.IS_DELETED = 'N'\n+     *       JOIN Observation_TOKEN_VALUES_V AS CP2 ON CP2.LOGICAL_RESOURCE_ID = CLR1.LOGICAL_RESOURCE_ID\n+     *       AND (\n+     *         CP2.PARAMETER_NAME_ID = 1073\n+     *         AND ((CP2.TOKEN_VALUE = ?))\n+     *       )\n+     *     WHERE\n+     *       CP1.TOKEN_VALUE = CLR0.LOGICAL_ID\n+     *       AND CP1.PARAMETER_NAME_ID = 1274\n+     *       AND CP1.CODE_SYSTEM_ID = 20004\n+     *   )\n+     * </pre>\n+     *\n+     * @see https://www.hl7.org/fhir/search.html#has\n+     * @param resourceType\n+     *                  - The resource type being searched.\n+     * @param queryParm\n+     *                  - A Parameter representing a reverse chained query.\n+     * @return SqlQueryData\n+     *                  - The query segment for a reverse chained parameter reference search.\n+     * @throws Exception\n+     */\n+    @Override\n+    protected SqlQueryData processReverseChainedReferenceParm(Class<?> resourceType, QueryParameter queryParm) throws Exception {\n+        final String METHODNAME = \"processReverseChainedReferenceParm\";\n+        log.entering(CLASSNAME, METHODNAME, queryParm.toString());\n+\n+        final String CR = \"CR\";\n+        final String CLR = \"CLR\";\n+        final String CP = \"CP\";\n+        String prevChainedResourceVar = null;\n+        String prevChainedLogicalResourceVar = null;\n+        String chainedResourceVar = null;\n+        String chainedLogicalResourceVar = null;\n+        String chainedParmVar = null;\n+        String nextChainedResourceVar = null;\n+        String nextChainedLogicalResourceVar = null;\n+        String nextChainedParmVar = null;\n+        QueryParameter previousParm = null;;\n+        int parmIndex = 0;\n+        int lastParmIndex = queryParm.getChain().size();\n+        boolean chainedParmProcessed = false;\n+        StringBuilder selectSegments = new StringBuilder();\n+        StringBuilder whereClauseSegments = new StringBuilder();\n+        List<Object> bindVariables = new ArrayList<>();\n+\n+        // Loop through the chained query parameters in order\n+        List<QueryParameter> queryParms = queryParm.getChain();\n+        queryParms.add(0, queryParm);\n+        for (QueryParameter currentParm : queryParms) {\n+\n+            prevChainedResourceVar        = CR + parmIndex;\n+            prevChainedLogicalResourceVar = CLR + parmIndex;\n+            chainedResourceVar        = CR + (parmIndex + 1);\n+            chainedLogicalResourceVar = CLR + (parmIndex + 1);\n+            chainedParmVar            = CP + (parmIndex + 1);\n+            nextChainedResourceVar        = CR + (parmIndex + 2);\n+            nextChainedLogicalResourceVar = CLR + (parmIndex + 2);\n+            nextChainedParmVar        = CP + (parmIndex + 2);\n+            StringBuilder whereClauseSegment = new StringBuilder();\n+\n+            if (parmIndex == 0) {\n+                // BUild outer select: SELECT CLR0.LOGICAL_ID\n+                //                       FROM <resource-type>_LOGICAL_RESOURCES AS CLR0\n+                //                       JOIN <resource-type>_RESOURCES AS CR0\n+                //                         ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+                //                       WHERE\n+                selectSegments.append(\"SELECT \" + prevChainedLogicalResourceVar + DOT + \"LOGICAL_ID\")\n+                                .append(FROM + resourceType.getSimpleName() + \"_LOGICAL_RESOURCES AS \" + prevChainedLogicalResourceVar)\n+                                .append(JOIN + resourceType.getSimpleName() + \"_RESOURCES AS \" + prevChainedResourceVar)\n+                                .append(ON + prevChainedResourceVar + DOT + \"RESOURCE_ID\" + EQ + prevChainedLogicalResourceVar + DOT + \"CURRENT_RESOURCE_ID\")\n+                                .append(AND + prevChainedResourceVar + DOT + \"IS_DELETED\" + EQ + \"'N'\")\n+                                .append(WHERE);\n+            }\n+\n+            if (parmIndex < lastParmIndex) {\n+                if (currentParm.isReverseChained()) {\n+                    // Build inner select joins: EXISTS (SELECT 1\n+                    //                           FROM <modifierTypeResourceName>_TOKEN_VALUES_V AS CPx\n+                    //                           JOIN <modifierTypeResourceName>_LOGICAL_RESOURCES AS CLRx\n+                    //                             ON CLRx.LOGICAL_RESOURCE_ID = CPx.LOGICAL_RESOURCE_ID\n+                    //                           JOIN <modifierTypeResourceName>_RESOURCES AS CRx\n+                    //                             ON CRx.RESOURCE_ID = CLRx.CURRENT_RESOURCE_ID AND CRx.IS_DELETED = 'N'\n+                    selectSegments.append(\"EXISTS \" + LEFT_PAREN + \"SELECT 1\")\n+                                    .append(FROM + currentParm.getModifierResourceTypeName() + \"_TOKEN_VALUES_V AS \" + chainedParmVar)\n+                                    .append(JOIN + currentParm.getModifierResourceTypeName() + \"_LOGICAL_RESOURCES AS \" + chainedLogicalResourceVar)\n+                                    .append(ON + chainedLogicalResourceVar + DOT + \"LOGICAL_RESOURCE_ID\" + EQ + chainedParmVar + DOT + \"LOGICAL_RESOURCE_ID\")\n+                                    .append(JOIN + currentParm.getModifierResourceTypeName() + \"_RESOURCES AS \" + chainedResourceVar)\n+                                    .append(ON + chainedResourceVar + DOT + \"RESOURCE_ID\" + EQ + chainedLogicalResourceVar + DOT + \"CURRENT_RESOURCE_ID\")\n+                                    .append(AND + chainedResourceVar + DOT + \"IS_DELETED\" + EQ + \"'N'\");\n+\n+                    String referencedResourceType = null;\n+                    if (parmIndex == 0) {\n+                        referencedResourceType = resourceType.getSimpleName();\n+                    } else {\n+                        referencedResourceType = previousParm.getModifierResourceTypeName();\n+                    }\n+                    if (parmIndex < lastParmIndex - 1 && currentParm.getNextParameter().isReverseChained()) {\n+                        // Build inner select where clause: WHERE CPx.TOKEN_VALUE = CLR<x-1>.LOGICAL_ID\n+                        //                                    AND CPx.PARAMETER_NAME_ID = <parm-name-id>\n+                        //                                    AND CPx.CDE_SYSTEM_ID = <code-system-id>\n+                        //                                    AND\n+                        selectSegments.append(WHERE + chainedParmVar + DOT + \"TOKEN_VALUE\" + EQ + prevChainedLogicalResourceVar + DOT + \"LOGICAL_ID\" + AND);\n+                        populateReferenceNameAndCodeSystemIdSubSegment(selectSegments, currentParm.getCode(), referencedResourceType, chainedParmVar);\n+                        selectSegments.append(AND);\n+                    } else {\n+                        // Build final inner select where clause: WHERE CPx.TOKEN_VALUE = CLR<x-1>.LOGICAL_ID\n+                        //                                          AND CPx.PARAMETER_NAME_ID = <parm-name-id>\n+                        //                                          AND CPx.CDE_SYSTEM_ID = <code-system-id>\n+                        whereClauseSegment.append(WHERE + chainedParmVar + DOT + \"TOKEN_VALUE\" + EQ + prevChainedLogicalResourceVar + DOT + \"LOGICAL_ID\" + AND);\n+                        populateReferenceNameAndCodeSystemIdSubSegment(whereClauseSegment, currentParm.getCode(), referencedResourceType, chainedParmVar);\n+                    }\n+\n+                    // Add closing right paren for EXISTS\n+                    whereClauseSegment.append(RIGHT_PAREN);\n+                } else if (currentParm.isChained()) {\n+                    // Build chained query\n+                    if (!chainedParmProcessed) {\n+                        // Build initial chain join and select:\n+                        // SELECT CPx.LOGICAL_RESOURCE_ID FROM <modifierTypeResourceName>_TOKEN_VALUES_V AS CPx WHERE\n+                        selectSegments.append(JOIN + LEFT_PAREN)\n+                                        .append(\"SELECT \" + chainedParmVar + DOT + \"LOGICAL_RESOURCE_ID\" + FROM)\n+                                        .append(previousParm.getModifierResourceTypeName() + \"_TOKEN_VALUES_V AS \" + chainedParmVar + WHERE);\n+                    }\n+\n+                    // Build this piece: CPx.PARAMETER_NAME_ID = <code-id> AND CPx.STR_VALUE IN\n+                    appendMidChainParm(selectSegments, currentParm, chainedParmVar);\n+\n+                    // Build this piece: (SELECT 'resource-type-name' || '/' || CLR<x+1>.LOGICAL_ID ...\n+                    selectSegments.append(LEFT_PAREN);\n+                    appendInnerSelect(selectSegments, currentParm, currentParm.getModifierResourceTypeName(),\n+                        nextChainedResourceVar, nextChainedLogicalResourceVar, nextChainedParmVar);\n+                    whereClauseSegment.append(RIGHT_PAREN);\n+\n+                    if (!chainedParmProcessed) {\n+                        chainedParmProcessed = true;\n+\n+                        // BUild ON clause for join: ) AS CPx ON CPx.LOGICAL_RESOURCE_ID = CLR<x-1>.LOGICAL_RESOURCE_ID\n+                        whereClauseSegment.append(RIGHT_PAREN + \" AS \" + chainedParmVar + ON)\n+                                            .append(chainedParmVar + DOT + \"LOGICAL_RESOURCE_ID\" + EQ + prevChainedLogicalResourceVar + DOT + \"LOGICAL_RESOURCE_ID\");\n+                    }\n+                }\n+            } else if (parmIndex == lastParmIndex) {\n+                // This logic processes the LAST parameter in the chain.\n+                if (!chainedParmProcessed) {\n+                    if (!\"_id\".equals(currentParm.getCode())) {\n+                        // Build this join: JOIN <modifierTypeResourceName>_<type>_VALUES AS CPx\n+                        //                    ON CPx.LOGICAL_RESOURCE_ID = CLR<x-1>.LOGICAL_RESOURCE_ID\n+                        //                    AND\n+                        whereClauseSegment.append(JOIN + QuerySegmentAggregator.tableName(previousParm.getModifierResourceTypeName(), currentParm))\n+                                            .append(\" AS \" + chainedParmVar + ON + chainedParmVar + DOT + \"LOGICAL_RESOURCE_ID\");\n+                    } else {\n+                        // Build this join: JOIN <modifierTypeResourceName>_LOGICAL_RESOURCES AS CLRx\n+                        //                    ON CLRx.LOGICAL_RESOURCE_ID = CLR<x-1>.LOGICAL_RESOURCE_ID\n+                        //                    AND\n+                        whereClauseSegment.append(JOIN + previousParm.getModifierResourceTypeName() + \"_LOGICAL_RESOURCES\")\n+                                            .append(\" AS \" + chainedLogicalResourceVar + ON + chainedLogicalResourceVar + DOT + \"LOGICAL_RESOURCE_ID\");\n+                    }\n+                    whereClauseSegment.append(EQ + prevChainedLogicalResourceVar + DOT + \"LOGICAL_RESOURCE_ID\" + AND);\n+                }\n+\n+                // Build the rest\n+                SqlQueryData sqlQueryData;\n+                if (!\"_id\".equals(currentParm.getCode())) {\n+                    // (CPx.PARAMETER_NAME_ID=<code-id> AND (CPx.<type>_VALUE=<valueCode>))\n+                    sqlQueryData = buildQueryParm(ModelSupport.getResourceType(previousParm.getModifierResourceTypeName()), currentParm, chainedParmVar);\n+                } else {\n+                    // CLRx.LOGICAL_ID IN (?)\n+                    sqlQueryData = buildChainedIdClause(currentParm, chainedParmVar);\n+                }\n+\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"chained sqlQueryData[\" + chainedParmVar + \"] = \" + sqlQueryData.getQueryString());\n+                }\n+                whereClauseSegment.append(sqlQueryData.getQueryString());\n+                bindVariables.addAll(sqlQueryData.getBindVariables());\n+           }\n+\n+            // Insert where clause segment in whole\n+            whereClauseSegments.insert(0, whereClauseSegment.toString());\n+\n+            previousParm = currentParm;\n+            parmIndex++;\n+        }\n+\n+        SqlQueryData queryData = new SqlQueryData(whereClauseSegments.insert(0, selectSegments.toString()).toString(), bindVariables);\n+        log.exiting(CLASSNAME, METHODNAME, queryData.getQueryString());\n+        return queryData;\n+    }\n+\n+    /**\n+     * Populates the reference parameter name ID and code system ID sub-segment of the passed where clause segment.\n+     *\n+     * @param whereClauseSegment - the segment to which the sub-segment will be added\n+     * @param queryParmName - the search parameter name\n+     * @param resourceTypeName - the resource type of the reference being followed\n+     * @param parameterTableAlias - the alias for the parameter table e.g. CPx\n+     * @throws FHIRPersistenceException\n+     */\n+    private void populateReferenceNameAndCodeSystemIdSubSegment(StringBuilder whereClauseSegment, String queryParmName,\n+            String resourceTypeName, String parameterTableAlias) throws FHIRPersistenceException {\n+        final String METHODNAME = \"populateReferenceNameAndCodeSystemIdSubSegment\";\n+        log.entering(CLASSNAME, METHODNAME, queryParmName);\n+\n+        Integer parameterNameId = identityCache.getParameterNameId(queryParmName);\n+        Integer codeSystemId = getCodeSystemId(resourceTypeName);\n+\n+        // Build the segment:\n+        // CPx.PARAMETER_NAME_ID = <parameter-name-id> AND CPx.CODE_SYSTEM_ID = <code-system_id>\n+        whereClauseSegment.append(parameterTableAlias + DOT + \"PARAMETER_NAME_ID=\")\n+                .append(nullCheck(parameterNameId))\n+                .append(AND)\n+                .append(parameterTableAlias + DOT + \"CODE_SYSTEM_ID=\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "originalPosition": 256}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzg1MjAx", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-523385201", "createdAt": "2020-11-04T13:59:52Z", "commit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo1OTo1MlrOHtZSQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo1OTo1MlrOHtZSQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2MjI0MQ==", "bodyText": "Random comment, you pick up the style of the code/section very quickly.  Thanks for matching the styles seemingly effortlessly.", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517362241", "createdAt": "2020-11-04T13:59:52Z", "author": {"login": "prb112"}, "path": "fhir-persistence/src/test/java/com/ibm/fhir/persistence/test/common/AbstractReverseChainTest.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.test.common;\n+\n+import static com.ibm.fhir.model.type.String.string;\n+import static org.testng.AssertJUnit.assertEquals;\n+import static org.testng.AssertJUnit.assertNotNull;\n+import static org.testng.AssertJUnit.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import com.ibm.fhir.model.format.Format;\n+import com.ibm.fhir.model.resource.Device;\n+import com.ibm.fhir.model.resource.Encounter;\n+import com.ibm.fhir.model.resource.Observation;\n+import com.ibm.fhir.model.resource.Organization;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Resource;\n+import com.ibm.fhir.model.test.TestUtil;\n+import com.ibm.fhir.model.type.Code;\n+import com.ibm.fhir.model.type.CodeableConcept;\n+import com.ibm.fhir.model.type.Coding;\n+import com.ibm.fhir.model.type.HumanName;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.code.ObservationStatus;\n+import com.ibm.fhir.model.type.code.ResourceType;\n+\n+/**\n+ *  This class tests the persistence layer support for the FHIR _has search parameter.\n+ *  @see https://www.hl7.org/fhir/R4/search.html#has\n+ */\n+public abstract class AbstractReverseChainTest extends AbstractPersistenceTest {\n+    private static Patient savedPatient1;\n+    private static Patient savedPatient2;\n+    private static Patient savedPatient3;\n+    private static Patient savedPatient4;\n+    private static Observation savedObservation1;\n+    private static Observation savedObservation2;\n+    private static Observation savedObservation3;\n+    private static Observation savedObservation4;\n+    private static Observation savedObservation5;\n+    private static Encounter savedEncounter1;\n+    private static Device savedDevice1;\n+    private static Organization savedOrg1;\n+    private static Organization savedOrg2;\n+    private static Organization savedOrg3;\n+\n+    /**\n+     * Loads up and saves a bunch of resources with various references to one another\n+     */\n+    @BeforeClass\n+    public void createResources() throws Exception {\n+        Organization org = TestUtil.getMinimalResource(ResourceType.ORGANIZATION, Format.JSON);\n+        Encounter encounter = TestUtil.getMinimalResource(ResourceType.ENCOUNTER, Format.JSON);\n+        Observation observation = TestUtil.getMinimalResource(ResourceType.OBSERVATION, Format.JSON);\n+        Patient patient = TestUtil.getMinimalResource(ResourceType.PATIENT, Format.JSON);\n+        Device device = TestUtil.getMinimalResource(ResourceType.DEVICE, Format.JSON);\n+\n+        // Organizations that will be referenced by a Patient\n+        savedOrg1 = persistence.create(getDefaultPersistenceContext(), org).getResource();\n+        savedOrg2 = persistence.create(getDefaultPersistenceContext(), org).getResource();\n+        savedOrg3 = persistence.create(getDefaultPersistenceContext(), org).getResource();\n+\n+        // an Encounter that will be referenced by Observations\n+        savedEncounter1 = persistence.create(getDefaultPersistenceContext(), encounter).getResource();\n+\n+        // an Observation that has no references to any other resource types\n+        savedObservation1 = persistence.create(getDefaultPersistenceContext(), observation).getResource();\n+\n+        // a Patient that will be referenced by Observations and references an Organization\n+        savedPatient1 = patient.toBuilder().managingOrganization(reference(\"Organization/\" + savedOrg2.getId())).build();\n+        savedPatient1 = persistence.create(getDefaultPersistenceContext(), savedPatient1).getResource();\n+\n+        // an Observation with a reference to a Patient\n+        savedObservation2 = observation.toBuilder().subject(reference(\"Patient/\" + savedPatient1.getId())).build();\n+        savedObservation2 = persistence.create(getDefaultPersistenceContext(), savedObservation2).getResource();\n+\n+        // an Observation with a reference to a Patient and a reference to an Encounter\n+        savedObservation3 = observation.toBuilder()\n+                                       .subject(reference(\"Patient/\" + savedPatient1.getId()))\n+                                       .encounter(reference(\"Encounter/\" + savedEncounter1.getId()))\n+                                       .build();\n+        savedObservation3 = persistence.create(getDefaultPersistenceContext(), savedObservation3).getResource();\n+\n+        // a Patient that will be referenced by an Observation and references an Organization\n+        savedPatient2 = patient.toBuilder().managingOrganization(reference(\"Organization/\" + savedOrg3.getId())).build();\n+        savedPatient2 = persistence.create(getDefaultPersistenceContext(), savedPatient2).getResource();\n+        savedPatient2 = savedPatient2.toBuilder().name(humanName(\"Vito\", \"Corleone\")).build();\n+        savedPatient2 = persistence.update(getDefaultPersistenceContext(), savedPatient2.getId(), savedPatient2).getResource();\n+\n+        // an Observation with a reference to a Patient and a reference to an Encounter\n+        savedObservation4 = observation.toBuilder()\n+                                       .subject(reference(\"Patient/\" + savedPatient2.getId()))\n+                                       .encounter(reference(\"Encounter/\" + savedEncounter1.getId()))\n+                                       .value(com.ibm.fhir.model.type.String.of(\"test\"))\n+                                       .code(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"code\")).build()).build())\n+                                       .build();\n+        savedObservation4 = persistence.create(getDefaultPersistenceContext(), savedObservation4).getResource();\n+\n+        // a Patient that references an Organization and is referenced by an Observation and a Device\n+        savedPatient3 = patient.toBuilder().managingOrganization(reference(\"Organization/\" + savedOrg1.getId())).build();\n+        savedPatient3 = persistence.create(getDefaultPersistenceContext(), savedPatient3).getResource();\n+\n+        // an Observation with a reference to a Patient\n+        savedObservation5 = observation.toBuilder()\n+                                       .subject(reference(\"Patient/\" + savedPatient3.getId()))\n+                                       .status(ObservationStatus.FINAL)\n+                                       .build();\n+        savedObservation5 = persistence.create(getDefaultPersistenceContext(), savedObservation5).getResource();\n+\n+        // a Device with a reference to a Patient\n+        savedDevice1 = device.toBuilder().patient(reference(\"Patient/\" + savedPatient3.getId())).build();\n+        savedDevice1 = persistence.create(getDefaultPersistenceContext(), savedDevice1).getResource();\n+        savedDevice1 = savedDevice1.toBuilder().manufacturer(string(\"Updated Manufacturer\")).build();\n+        savedDevice1 = persistence.update(getDefaultPersistenceContext(), savedDevice1.getId(), savedDevice1).getResource();\n+\n+        // a Patient that will have no other resources referencing it\n+        savedPatient4 = persistence.create(getDefaultPersistenceContext(), patient).getResource();\n+    }\n+\n+    @AfterClass\n+    public void deleteResources() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "originalPosition": 135}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzg2NDI4", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-523386428", "createdAt": "2020-11-04T14:01:07Z", "commit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDowMTowN1rOHtZVvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDowMTowN1rOHtZVvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2MzEzNA==", "bodyText": "Maybe comment why this commented out?", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517363134", "createdAt": "2020-11-04T14:01:07Z", "author": {"login": "prb112"}, "path": "fhir-persistence/src/test/java/com/ibm/fhir/persistence/test/common/AbstractReverseChainTest.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.test.common;\n+\n+import static com.ibm.fhir.model.type.String.string;\n+import static org.testng.AssertJUnit.assertEquals;\n+import static org.testng.AssertJUnit.assertNotNull;\n+import static org.testng.AssertJUnit.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import com.ibm.fhir.model.format.Format;\n+import com.ibm.fhir.model.resource.Device;\n+import com.ibm.fhir.model.resource.Encounter;\n+import com.ibm.fhir.model.resource.Observation;\n+import com.ibm.fhir.model.resource.Organization;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Resource;\n+import com.ibm.fhir.model.test.TestUtil;\n+import com.ibm.fhir.model.type.Code;\n+import com.ibm.fhir.model.type.CodeableConcept;\n+import com.ibm.fhir.model.type.Coding;\n+import com.ibm.fhir.model.type.HumanName;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.code.ObservationStatus;\n+import com.ibm.fhir.model.type.code.ResourceType;\n+\n+/**\n+ *  This class tests the persistence layer support for the FHIR _has search parameter.\n+ *  @see https://www.hl7.org/fhir/R4/search.html#has\n+ */\n+public abstract class AbstractReverseChainTest extends AbstractPersistenceTest {\n+    private static Patient savedPatient1;\n+    private static Patient savedPatient2;\n+    private static Patient savedPatient3;\n+    private static Patient savedPatient4;\n+    private static Observation savedObservation1;\n+    private static Observation savedObservation2;\n+    private static Observation savedObservation3;\n+    private static Observation savedObservation4;\n+    private static Observation savedObservation5;\n+    private static Encounter savedEncounter1;\n+    private static Device savedDevice1;\n+    private static Organization savedOrg1;\n+    private static Organization savedOrg2;\n+    private static Organization savedOrg3;\n+\n+    /**\n+     * Loads up and saves a bunch of resources with various references to one another\n+     */\n+    @BeforeClass\n+    public void createResources() throws Exception {\n+        Organization org = TestUtil.getMinimalResource(ResourceType.ORGANIZATION, Format.JSON);\n+        Encounter encounter = TestUtil.getMinimalResource(ResourceType.ENCOUNTER, Format.JSON);\n+        Observation observation = TestUtil.getMinimalResource(ResourceType.OBSERVATION, Format.JSON);\n+        Patient patient = TestUtil.getMinimalResource(ResourceType.PATIENT, Format.JSON);\n+        Device device = TestUtil.getMinimalResource(ResourceType.DEVICE, Format.JSON);\n+\n+        // Organizations that will be referenced by a Patient\n+        savedOrg1 = persistence.create(getDefaultPersistenceContext(), org).getResource();\n+        savedOrg2 = persistence.create(getDefaultPersistenceContext(), org).getResource();\n+        savedOrg3 = persistence.create(getDefaultPersistenceContext(), org).getResource();\n+\n+        // an Encounter that will be referenced by Observations\n+        savedEncounter1 = persistence.create(getDefaultPersistenceContext(), encounter).getResource();\n+\n+        // an Observation that has no references to any other resource types\n+        savedObservation1 = persistence.create(getDefaultPersistenceContext(), observation).getResource();\n+\n+        // a Patient that will be referenced by Observations and references an Organization\n+        savedPatient1 = patient.toBuilder().managingOrganization(reference(\"Organization/\" + savedOrg2.getId())).build();\n+        savedPatient1 = persistence.create(getDefaultPersistenceContext(), savedPatient1).getResource();\n+\n+        // an Observation with a reference to a Patient\n+        savedObservation2 = observation.toBuilder().subject(reference(\"Patient/\" + savedPatient1.getId())).build();\n+        savedObservation2 = persistence.create(getDefaultPersistenceContext(), savedObservation2).getResource();\n+\n+        // an Observation with a reference to a Patient and a reference to an Encounter\n+        savedObservation3 = observation.toBuilder()\n+                                       .subject(reference(\"Patient/\" + savedPatient1.getId()))\n+                                       .encounter(reference(\"Encounter/\" + savedEncounter1.getId()))\n+                                       .build();\n+        savedObservation3 = persistence.create(getDefaultPersistenceContext(), savedObservation3).getResource();\n+\n+        // a Patient that will be referenced by an Observation and references an Organization\n+        savedPatient2 = patient.toBuilder().managingOrganization(reference(\"Organization/\" + savedOrg3.getId())).build();\n+        savedPatient2 = persistence.create(getDefaultPersistenceContext(), savedPatient2).getResource();\n+        savedPatient2 = savedPatient2.toBuilder().name(humanName(\"Vito\", \"Corleone\")).build();\n+        savedPatient2 = persistence.update(getDefaultPersistenceContext(), savedPatient2.getId(), savedPatient2).getResource();\n+\n+        // an Observation with a reference to a Patient and a reference to an Encounter\n+        savedObservation4 = observation.toBuilder()\n+                                       .subject(reference(\"Patient/\" + savedPatient2.getId()))\n+                                       .encounter(reference(\"Encounter/\" + savedEncounter1.getId()))\n+                                       .value(com.ibm.fhir.model.type.String.of(\"test\"))\n+                                       .code(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"code\")).build()).build())\n+                                       .build();\n+        savedObservation4 = persistence.create(getDefaultPersistenceContext(), savedObservation4).getResource();\n+\n+        // a Patient that references an Organization and is referenced by an Observation and a Device\n+        savedPatient3 = patient.toBuilder().managingOrganization(reference(\"Organization/\" + savedOrg1.getId())).build();\n+        savedPatient3 = persistence.create(getDefaultPersistenceContext(), savedPatient3).getResource();\n+\n+        // an Observation with a reference to a Patient\n+        savedObservation5 = observation.toBuilder()\n+                                       .subject(reference(\"Patient/\" + savedPatient3.getId()))\n+                                       .status(ObservationStatus.FINAL)\n+                                       .build();\n+        savedObservation5 = persistence.create(getDefaultPersistenceContext(), savedObservation5).getResource();\n+\n+        // a Device with a reference to a Patient\n+        savedDevice1 = device.toBuilder().patient(reference(\"Patient/\" + savedPatient3.getId())).build();\n+        savedDevice1 = persistence.create(getDefaultPersistenceContext(), savedDevice1).getResource();\n+        savedDevice1 = savedDevice1.toBuilder().manufacturer(string(\"Updated Manufacturer\")).build();\n+        savedDevice1 = persistence.update(getDefaultPersistenceContext(), savedDevice1.getId(), savedDevice1).getResource();\n+\n+        // a Patient that will have no other resources referencing it\n+        savedPatient4 = persistence.create(getDefaultPersistenceContext(), patient).getResource();\n+    }\n+\n+    @AfterClass\n+    public void deleteResources() throws Exception {\n+        Resource[] resources = {savedPatient1, savedPatient2, savedPatient3, savedPatient4,\n+                savedObservation1, savedObservation2, savedObservation3, savedObservation4, savedObservation5,\n+                savedEncounter1, savedDevice1, savedOrg1};\n+\n+        if (persistence.isDeleteSupported()) {\n+            if (persistence.isTransactional()) {\n+                persistence.getTransaction().begin();\n+            }\n+\n+            try {\n+                for (Resource resource : resources) {\n+                    persistence.delete(getDefaultPersistenceContext(), resource.getClass(), resource.getId());\n+                }\n+            } catch (Throwable t) {\n+                if (persistence.isTransactional()) {\n+                    persistence.getTransaction().setRollbackOnly();\n+                }\n+                throw t;\n+            } finally {\n+                if (persistence.isTransactional()) {\n+                    persistence.getTransaction().end();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This test queries for Patients which are referenced by Observations with a specified code.\n+     * No Observations are found containing the code, thus no Patients are returned.\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testReverseChainNoResult() throws Exception {\n+        Map<String, List<String>> queryParms = new HashMap<String, List<String>>();\n+        queryParms.put(\"_has:Observation:subject:code\", Collections.singletonList(\"test\"));\n+        List<Resource> resources = runQueryTest(Patient.class, queryParms);\n+        assertNotNull(resources);\n+        assertEquals(0, resources.size());\n+    }\n+\n+    /**\n+     * This test queries for Patients which are referenced by Observations with a specified status.\n+     * One observation is found containing the status, thus one Patient is returned.\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testReverseChainSingleResult() throws Exception {\n+        Map<String, List<String>> queryParms = new HashMap<String, List<String>>();\n+        queryParms.put(\"_has:Observation:subject:status\", Collections.singletonList(ObservationStatus.FINAL.getValue()));\n+        List<Resource> resources = runQueryTest(Patient.class, queryParms);\n+        assertNotNull(resources);\n+        assertEquals(1, resources.size());\n+        assertEquals(\"Patient\", resources.get(0).getClass().getSimpleName());\n+        assertEquals(savedPatient3.getId(), resources.get(0).getId());\n+    }\n+\n+    /**\n+     * This test queries for Patients which are referenced by Observations with a specified encounter.\n+     * Two observations are found containing the encounter reference, thus two Patients are returned.\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testReverseChainMultipleResults() throws Exception {\n+        Map<String, List<String>> queryParms = new HashMap<String, List<String>>();\n+        queryParms.put(\"_has:Observation:subject:encounter\", Collections.singletonList(\"Encounter/\" + savedEncounter1.getId()));\n+        List<Resource> resources = runQueryTest(Patient.class, queryParms);\n+        assertNotNull(resources);\n+        assertEquals(2, resources.size());\n+        List<String> resourceIds = new ArrayList<>();\n+        for (Resource resource : resources) {\n+            resourceIds.add(resource.getId());\n+        }\n+        assertTrue(resourceIds.contains(savedPatient1.getId()));\n+        assertTrue(resourceIds.contains(savedPatient2.getId()));\n+    }\n+\n+    /**\n+     * This test queries for Patients which are referenced by Observations which in turn are\n+     * referenced by Encounters with a specific status.\n+     * No Encounters are found, thus no Observations are found, thus no Patients are returned.\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testMultiReverseChainNoResult() throws Exception {\n+        Map<String, List<String>> queryParms = new HashMap<String, List<String>>();\n+        queryParms.put(\"_has:Observation:subject:_has:Encounter:reason-reference:status\", Collections.singletonList(\"test\"));\n+        List<Resource> resources = runQueryTest(Patient.class, queryParms);\n+        assertNotNull(resources);\n+        assertEquals(0, resources.size());\n+    }\n+\n+    /**\n+     * This test queries for Organizations which are referenced by Patients which in turn are\n+     * referenced by Observations with a specified status.\n+     * One observation is found containing the status, thus one Patient is found, thus one\n+     * Organization is returned.\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testMultiReverseChainSingleResult() throws Exception {\n+        Map<String, List<String>> queryParms = new HashMap<String, List<String>>();\n+        queryParms.put(\"_has:Patient:organization:_has:Observation:subject:status\", Collections.singletonList(ObservationStatus.FINAL.getValue()));\n+        List<Resource> resources = runQueryTest(Organization.class, queryParms);\n+        assertNotNull(resources);\n+        assertEquals(1, resources.size());\n+        assertEquals(\"Organization\", resources.get(0).getClass().getSimpleName());\n+        assertEquals(savedOrg1.getId(), resources.get(0).getId());\n+    }\n+\n+    /**\n+     * This test queries for Organizations which are referenced by Patients which in turn are\n+     * referenced by Observations with a specified encounter.\n+     * Two observations are found containing the encounter, thus two Patients are found, thus two\n+     * Organizations are returned.\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testMultiReverseChainMultipleResults() throws Exception {\n+        Map<String, List<String>> queryParms = new HashMap<String, List<String>>();\n+        queryParms.put(\"_has:Patient:organization:_has:Observation:subject:encounter\", Collections.singletonList(\"Encounter/\" + savedEncounter1.getId()));\n+        List<Resource> resources = runQueryTest(Organization.class, queryParms);\n+        assertNotNull(resources);\n+        assertEquals(2, resources.size());\n+        List<String> resourceIds = new ArrayList<>();\n+        for (Resource resource : resources) {\n+            resourceIds.add(resource.getId());\n+        }\n+        assertTrue(resourceIds.contains(savedOrg2.getId()));\n+        assertTrue(resourceIds.contains(savedOrg3.getId()));\n+    }\n+\n+    /**\n+     * This test queries for Patients which are referenced by Observations with an _id that is\n+     * one of two values.\n+     * Two observations are found, thus two Patients are returned.\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testReverseChainMultipleResultsFromMultipleValues() throws Exception {\n+        Map<String, List<String>> queryParms = new HashMap<String, List<String>>();\n+        queryParms.put(\"_has:Observation:subject:_id\", Collections.singletonList(savedObservation2.getId() + \",\" + savedObservation4.getId()));\n+        List<Resource> resources = runQueryTest(Patient.class, queryParms);\n+        assertNotNull(resources);\n+        assertEquals(2, resources.size());\n+        List<String> resourceIds = new ArrayList<>();\n+        for (Resource resource : resources) {\n+            resourceIds.add(resource.getId());\n+        }\n+        assertTrue(resourceIds.contains(savedPatient1.getId()));\n+        assertTrue(resourceIds.contains(savedPatient2.getId()));\n+    }\n+\n+    /**\n+     * This test queries for Encounters which are referenced by Observations with an _id that is\n+     * one of two values.\n+     * Two observations are found. both referencing the same encounter, thus one Encounter is returned.\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testReverseChainSingleResultsFromMultipleQueries() throws Exception {\n+        Map<String, List<String>> queryParms = new HashMap<String, List<String>>();\n+        queryParms.put(\"_has:Observation:encounter:_id\", Arrays.asList(savedObservation3.getId(), savedObservation4.getId()));\n+        List<Resource> resources = runQueryTest(Encounter.class, queryParms);\n+        assertNotNull(resources);\n+        assertEquals(1, resources.size());\n+        assertEquals(\"Encounter\", resources.get(0).getClass().getSimpleName());\n+        assertEquals(savedEncounter1.getId(), resources.get(0).getId());\n+    }\n+\n+    /**\n+     * This test queries for Encounters which are referenced by Observations with a\n+     * reference to Patients with a specified name.\n+     * One patient is found, thus one observation, thus one encounter is returned.\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testReverseChainSingleResultWithChainedParm() throws Exception {\n+        Map<String, List<String>> queryParms = new HashMap<String, List<String>>();\n+        queryParms.put(\"_has:Observation:encounter:subject:Patient.name\", Collections.singletonList(\"Vito\"));\n+        List<Resource> resources = runQueryTest(Encounter.class, queryParms);\n+        assertNotNull(resources);\n+        assertEquals(1, resources.size());\n+        assertEquals(\"Encounter\", resources.get(0).getClass().getSimpleName());\n+        assertEquals(savedEncounter1.getId(), resources.get(0).getId());\n+    }\n+\n+    /**\n+     * This test queries for Encounters which are referenced by Observations\n+     * matching on a string type search parameter.\n+     * One observation is found, thus one encounter is returned.\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testReverseChainSingleResultWithStringParm() throws Exception {\n+        Map<String, List<String>> queryParms = new HashMap<String, List<String>>();\n+        queryParms.put(\"_has:Observation:encounter:value-string\", Collections.singletonList(\"test\"));\n+        List<Resource> resources = runQueryTest(Encounter.class, queryParms);\n+        assertNotNull(resources);\n+        assertEquals(1, resources.size());\n+        assertEquals(\"Encounter\", resources.get(0).getClass().getSimpleName());\n+        assertEquals(savedEncounter1.getId(), resources.get(0).getId());\n+    }\n+\n+    /**\n+     * This test queries for Encounters which are referenced by Observations\n+     * matching on a composite type search parameter.\n+     * One observation is found, thus one encounter is returned.\n+     * @throws Exception\n+     */\n+//    @Test\n+//    public void testReverseChainSingleResultWithCompositeParm() throws Exception {\n+//        Map<String, List<String>> queryParms = new HashMap<String, List<String>>();\n+//        queryParms.put(\"_has:Observation:encounter:code-value-string\", Collections.singletonList(\"code$test\"));\n+//         List<Resource> resources = runQueryTest(Encounter.class, queryParms);\n+//        assertNotNull(resources);\n+//        assertEquals(1, resources.size());\n+//        assertEquals(\"Encounter\", resources.get(0).getClass().getSimpleName());\n+//        assertEquals(savedEncounter1.getId(), resources.get(0).getId());\n+//    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "originalPosition": 354}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzg2OTE5", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-523386919", "createdAt": "2020-11-04T14:01:40Z", "commit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDowMTo0MFrOHtZXEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDowMTo0MFrOHtZXEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2MzQ3Mw==", "bodyText": "Is it plausible / possible to have more than one _has on a reverse chain?\nDo we support it from the REST layer?\nWhat type of error do we throw?", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517363473", "createdAt": "2020-11-04T14:01:40Z", "author": {"login": "prb112"}, "path": "fhir-persistence/src/test/java/com/ibm/fhir/persistence/test/common/AbstractReverseChainTest.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.test.common;\n+\n+import static com.ibm.fhir.model.type.String.string;\n+import static org.testng.AssertJUnit.assertEquals;\n+import static org.testng.AssertJUnit.assertNotNull;\n+import static org.testng.AssertJUnit.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import com.ibm.fhir.model.format.Format;\n+import com.ibm.fhir.model.resource.Device;\n+import com.ibm.fhir.model.resource.Encounter;\n+import com.ibm.fhir.model.resource.Observation;\n+import com.ibm.fhir.model.resource.Organization;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Resource;\n+import com.ibm.fhir.model.test.TestUtil;\n+import com.ibm.fhir.model.type.Code;\n+import com.ibm.fhir.model.type.CodeableConcept;\n+import com.ibm.fhir.model.type.Coding;\n+import com.ibm.fhir.model.type.HumanName;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.code.ObservationStatus;\n+import com.ibm.fhir.model.type.code.ResourceType;\n+\n+/**\n+ *  This class tests the persistence layer support for the FHIR _has search parameter.\n+ *  @see https://www.hl7.org/fhir/R4/search.html#has\n+ */\n+public abstract class AbstractReverseChainTest extends AbstractPersistenceTest {\n+    private static Patient savedPatient1;\n+    private static Patient savedPatient2;\n+    private static Patient savedPatient3;\n+    private static Patient savedPatient4;\n+    private static Observation savedObservation1;\n+    private static Observation savedObservation2;\n+    private static Observation savedObservation3;\n+    private static Observation savedObservation4;\n+    private static Observation savedObservation5;\n+    private static Encounter savedEncounter1;\n+    private static Device savedDevice1;\n+    private static Organization savedOrg1;\n+    private static Organization savedOrg2;\n+    private static Organization savedOrg3;\n+\n+    /**\n+     * Loads up and saves a bunch of resources with various references to one another\n+     */\n+    @BeforeClass\n+    public void createResources() throws Exception {\n+        Organization org = TestUtil.getMinimalResource(ResourceType.ORGANIZATION, Format.JSON);\n+        Encounter encounter = TestUtil.getMinimalResource(ResourceType.ENCOUNTER, Format.JSON);\n+        Observation observation = TestUtil.getMinimalResource(ResourceType.OBSERVATION, Format.JSON);\n+        Patient patient = TestUtil.getMinimalResource(ResourceType.PATIENT, Format.JSON);\n+        Device device = TestUtil.getMinimalResource(ResourceType.DEVICE, Format.JSON);\n+\n+        // Organizations that will be referenced by a Patient\n+        savedOrg1 = persistence.create(getDefaultPersistenceContext(), org).getResource();\n+        savedOrg2 = persistence.create(getDefaultPersistenceContext(), org).getResource();\n+        savedOrg3 = persistence.create(getDefaultPersistenceContext(), org).getResource();\n+\n+        // an Encounter that will be referenced by Observations\n+        savedEncounter1 = persistence.create(getDefaultPersistenceContext(), encounter).getResource();\n+\n+        // an Observation that has no references to any other resource types\n+        savedObservation1 = persistence.create(getDefaultPersistenceContext(), observation).getResource();\n+\n+        // a Patient that will be referenced by Observations and references an Organization\n+        savedPatient1 = patient.toBuilder().managingOrganization(reference(\"Organization/\" + savedOrg2.getId())).build();\n+        savedPatient1 = persistence.create(getDefaultPersistenceContext(), savedPatient1).getResource();\n+\n+        // an Observation with a reference to a Patient\n+        savedObservation2 = observation.toBuilder().subject(reference(\"Patient/\" + savedPatient1.getId())).build();\n+        savedObservation2 = persistence.create(getDefaultPersistenceContext(), savedObservation2).getResource();\n+\n+        // an Observation with a reference to a Patient and a reference to an Encounter\n+        savedObservation3 = observation.toBuilder()\n+                                       .subject(reference(\"Patient/\" + savedPatient1.getId()))\n+                                       .encounter(reference(\"Encounter/\" + savedEncounter1.getId()))\n+                                       .build();\n+        savedObservation3 = persistence.create(getDefaultPersistenceContext(), savedObservation3).getResource();\n+\n+        // a Patient that will be referenced by an Observation and references an Organization\n+        savedPatient2 = patient.toBuilder().managingOrganization(reference(\"Organization/\" + savedOrg3.getId())).build();\n+        savedPatient2 = persistence.create(getDefaultPersistenceContext(), savedPatient2).getResource();\n+        savedPatient2 = savedPatient2.toBuilder().name(humanName(\"Vito\", \"Corleone\")).build();\n+        savedPatient2 = persistence.update(getDefaultPersistenceContext(), savedPatient2.getId(), savedPatient2).getResource();\n+\n+        // an Observation with a reference to a Patient and a reference to an Encounter\n+        savedObservation4 = observation.toBuilder()\n+                                       .subject(reference(\"Patient/\" + savedPatient2.getId()))\n+                                       .encounter(reference(\"Encounter/\" + savedEncounter1.getId()))\n+                                       .value(com.ibm.fhir.model.type.String.of(\"test\"))\n+                                       .code(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"code\")).build()).build())\n+                                       .build();\n+        savedObservation4 = persistence.create(getDefaultPersistenceContext(), savedObservation4).getResource();\n+\n+        // a Patient that references an Organization and is referenced by an Observation and a Device\n+        savedPatient3 = patient.toBuilder().managingOrganization(reference(\"Organization/\" + savedOrg1.getId())).build();\n+        savedPatient3 = persistence.create(getDefaultPersistenceContext(), savedPatient3).getResource();\n+\n+        // an Observation with a reference to a Patient\n+        savedObservation5 = observation.toBuilder()\n+                                       .subject(reference(\"Patient/\" + savedPatient3.getId()))\n+                                       .status(ObservationStatus.FINAL)\n+                                       .build();\n+        savedObservation5 = persistence.create(getDefaultPersistenceContext(), savedObservation5).getResource();\n+\n+        // a Device with a reference to a Patient\n+        savedDevice1 = device.toBuilder().patient(reference(\"Patient/\" + savedPatient3.getId())).build();\n+        savedDevice1 = persistence.create(getDefaultPersistenceContext(), savedDevice1).getResource();\n+        savedDevice1 = savedDevice1.toBuilder().manufacturer(string(\"Updated Manufacturer\")).build();\n+        savedDevice1 = persistence.update(getDefaultPersistenceContext(), savedDevice1.getId(), savedDevice1).getResource();\n+\n+        // a Patient that will have no other resources referencing it\n+        savedPatient4 = persistence.create(getDefaultPersistenceContext(), patient).getResource();\n+    }\n+\n+    @AfterClass\n+    public void deleteResources() throws Exception {\n+        Resource[] resources = {savedPatient1, savedPatient2, savedPatient3, savedPatient4,\n+                savedObservation1, savedObservation2, savedObservation3, savedObservation4, savedObservation5,\n+                savedEncounter1, savedDevice1, savedOrg1};\n+\n+        if (persistence.isDeleteSupported()) {\n+            if (persistence.isTransactional()) {\n+                persistence.getTransaction().begin();\n+            }\n+\n+            try {\n+                for (Resource resource : resources) {\n+                    persistence.delete(getDefaultPersistenceContext(), resource.getClass(), resource.getId());\n+                }\n+            } catch (Throwable t) {\n+                if (persistence.isTransactional()) {\n+                    persistence.getTransaction().setRollbackOnly();\n+                }\n+                throw t;\n+            } finally {\n+                if (persistence.isTransactional()) {\n+                    persistence.getTransaction().end();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This test queries for Patients which are referenced by Observations with a specified code.\n+     * No Observations are found containing the code, thus no Patients are returned.\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testReverseChainNoResult() throws Exception {\n+        Map<String, List<String>> queryParms = new HashMap<String, List<String>>();\n+        queryParms.put(\"_has:Observation:subject:code\", Collections.singletonList(\"test\"));\n+        List<Resource> resources = runQueryTest(Patient.class, queryParms);\n+        assertNotNull(resources);\n+        assertEquals(0, resources.size());\n+    }\n+\n+    /**\n+     * This test queries for Patients which are referenced by Observations with a specified status.\n+     * One observation is found containing the status, thus one Patient is returned.\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testReverseChainSingleResult() throws Exception {\n+        Map<String, List<String>> queryParms = new HashMap<String, List<String>>();\n+        queryParms.put(\"_has:Observation:subject:status\", Collections.singletonList(ObservationStatus.FINAL.getValue()));\n+        List<Resource> resources = runQueryTest(Patient.class, queryParms);\n+        assertNotNull(resources);\n+        assertEquals(1, resources.size());\n+        assertEquals(\"Patient\", resources.get(0).getClass().getSimpleName());\n+        assertEquals(savedPatient3.getId(), resources.get(0).getId());\n+    }\n+\n+    /**\n+     * This test queries for Patients which are referenced by Observations with a specified encounter.\n+     * Two observations are found containing the encounter reference, thus two Patients are returned.\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testReverseChainMultipleResults() throws Exception {\n+        Map<String, List<String>> queryParms = new HashMap<String, List<String>>();\n+        queryParms.put(\"_has:Observation:subject:encounter\", Collections.singletonList(\"Encounter/\" + savedEncounter1.getId()));\n+        List<Resource> resources = runQueryTest(Patient.class, queryParms);\n+        assertNotNull(resources);\n+        assertEquals(2, resources.size());\n+        List<String> resourceIds = new ArrayList<>();\n+        for (Resource resource : resources) {\n+            resourceIds.add(resource.getId());\n+        }\n+        assertTrue(resourceIds.contains(savedPatient1.getId()));\n+        assertTrue(resourceIds.contains(savedPatient2.getId()));\n+    }\n+\n+    /**\n+     * This test queries for Patients which are referenced by Observations which in turn are\n+     * referenced by Encounters with a specific status.\n+     * No Encounters are found, thus no Observations are found, thus no Patients are returned.\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testMultiReverseChainNoResult() throws Exception {\n+        Map<String, List<String>> queryParms = new HashMap<String, List<String>>();\n+        queryParms.put(\"_has:Observation:subject:_has:Encounter:reason-reference:status\", Collections.singletonList(\"test\"));\n+        List<Resource> resources = runQueryTest(Patient.class, queryParms);\n+        assertNotNull(resources);\n+        assertEquals(0, resources.size());\n+    }\n+\n+    /**\n+     * This test queries for Organizations which are referenced by Patients which in turn are\n+     * referenced by Observations with a specified status.\n+     * One observation is found containing the status, thus one Patient is found, thus one\n+     * Organization is returned.\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testMultiReverseChainSingleResult() throws Exception {\n+        Map<String, List<String>> queryParms = new HashMap<String, List<String>>();\n+        queryParms.put(\"_has:Patient:organization:_has:Observation:subject:status\", Collections.singletonList(ObservationStatus.FINAL.getValue()));\n+        List<Resource> resources = runQueryTest(Organization.class, queryParms);\n+        assertNotNull(resources);\n+        assertEquals(1, resources.size());\n+        assertEquals(\"Organization\", resources.get(0).getClass().getSimpleName());\n+        assertEquals(savedOrg1.getId(), resources.get(0).getId());\n+    }\n+\n+    /**\n+     * This test queries for Organizations which are referenced by Patients which in turn are\n+     * referenced by Observations with a specified encounter.\n+     * Two observations are found containing the encounter, thus two Patients are found, thus two\n+     * Organizations are returned.\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testMultiReverseChainMultipleResults() throws Exception {\n+        Map<String, List<String>> queryParms = new HashMap<String, List<String>>();\n+        queryParms.put(\"_has:Patient:organization:_has:Observation:subject:encounter\", Collections.singletonList(\"Encounter/\" + savedEncounter1.getId()));\n+        List<Resource> resources = runQueryTest(Organization.class, queryParms);\n+        assertNotNull(resources);\n+        assertEquals(2, resources.size());\n+        List<String> resourceIds = new ArrayList<>();\n+        for (Resource resource : resources) {\n+            resourceIds.add(resource.getId());\n+        }\n+        assertTrue(resourceIds.contains(savedOrg2.getId()));\n+        assertTrue(resourceIds.contains(savedOrg3.getId()));\n+    }\n+\n+    /**\n+     * This test queries for Patients which are referenced by Observations with an _id that is\n+     * one of two values.\n+     * Two observations are found, thus two Patients are returned.\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testReverseChainMultipleResultsFromMultipleValues() throws Exception {\n+        Map<String, List<String>> queryParms = new HashMap<String, List<String>>();\n+        queryParms.put(\"_has:Observation:subject:_id\", Collections.singletonList(savedObservation2.getId() + \",\" + savedObservation4.getId()));\n+        List<Resource> resources = runQueryTest(Patient.class, queryParms);\n+        assertNotNull(resources);\n+        assertEquals(2, resources.size());\n+        List<String> resourceIds = new ArrayList<>();\n+        for (Resource resource : resources) {\n+            resourceIds.add(resource.getId());\n+        }\n+        assertTrue(resourceIds.contains(savedPatient1.getId()));\n+        assertTrue(resourceIds.contains(savedPatient2.getId()));\n+    }\n+\n+    /**\n+     * This test queries for Encounters which are referenced by Observations with an _id that is\n+     * one of two values.\n+     * Two observations are found. both referencing the same encounter, thus one Encounter is returned.\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testReverseChainSingleResultsFromMultipleQueries() throws Exception {\n+        Map<String, List<String>> queryParms = new HashMap<String, List<String>>();\n+        queryParms.put(\"_has:Observation:encounter:_id\", Arrays.asList(savedObservation3.getId(), savedObservation4.getId()));\n+        List<Resource> resources = runQueryTest(Encounter.class, queryParms);\n+        assertNotNull(resources);\n+        assertEquals(1, resources.size());\n+        assertEquals(\"Encounter\", resources.get(0).getClass().getSimpleName());\n+        assertEquals(savedEncounter1.getId(), resources.get(0).getId());\n+    }\n+\n+    /**\n+     * This test queries for Encounters which are referenced by Observations with a\n+     * reference to Patients with a specified name.\n+     * One patient is found, thus one observation, thus one encounter is returned.\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testReverseChainSingleResultWithChainedParm() throws Exception {\n+        Map<String, List<String>> queryParms = new HashMap<String, List<String>>();\n+        queryParms.put(\"_has:Observation:encounter:subject:Patient.name\", Collections.singletonList(\"Vito\"));\n+        List<Resource> resources = runQueryTest(Encounter.class, queryParms);\n+        assertNotNull(resources);\n+        assertEquals(1, resources.size());\n+        assertEquals(\"Encounter\", resources.get(0).getClass().getSimpleName());\n+        assertEquals(savedEncounter1.getId(), resources.get(0).getId());\n+    }\n+\n+    /**\n+     * This test queries for Encounters which are referenced by Observations\n+     * matching on a string type search parameter.\n+     * One observation is found, thus one encounter is returned.\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testReverseChainSingleResultWithStringParm() throws Exception {\n+        Map<String, List<String>> queryParms = new HashMap<String, List<String>>();\n+        queryParms.put(\"_has:Observation:encounter:value-string\", Collections.singletonList(\"test\"));\n+        List<Resource> resources = runQueryTest(Encounter.class, queryParms);\n+        assertNotNull(resources);\n+        assertEquals(1, resources.size());\n+        assertEquals(\"Encounter\", resources.get(0).getClass().getSimpleName());\n+        assertEquals(savedEncounter1.getId(), resources.get(0).getId());\n+    }\n+\n+    /**\n+     * This test queries for Encounters which are referenced by Observations\n+     * matching on a composite type search parameter.\n+     * One observation is found, thus one encounter is returned.\n+     * @throws Exception\n+     */\n+//    @Test\n+//    public void testReverseChainSingleResultWithCompositeParm() throws Exception {\n+//        Map<String, List<String>> queryParms = new HashMap<String, List<String>>();\n+//        queryParms.put(\"_has:Observation:encounter:code-value-string\", Collections.singletonList(\"code$test\"));\n+//         List<Resource> resources = runQueryTest(Encounter.class, queryParms);\n+//        assertNotNull(resources);\n+//        assertEquals(1, resources.size());\n+//        assertEquals(\"Encounter\", resources.get(0).getClass().getSimpleName());\n+//        assertEquals(savedEncounter1.getId(), resources.get(0).getId());\n+//    }\n+\n+    private Reference reference(String reference) {\n+        return Reference.builder().reference(string(reference)).build();\n+    }\n+\n+    private HumanName humanName(String firstName, String lastName) {\n+        return HumanName.builder().given(string(firstName)).family(string(lastName)).build();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "originalPosition": 362}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzg4Nzcx", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-523388771", "createdAt": "2020-11-04T14:03:38Z", "commit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDowMzozOVrOHtZccw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDowMzozOVrOHtZccw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2NDg1MQ==", "bodyText": "above is a good candidate for the formatter:off comment and end with formatter on", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517364851", "createdAt": "2020-11-04T14:03:39Z", "author": {"login": "prb112"}, "path": "fhir-server-test/src/test/java/com/ibm/fhir/server/test/SearchReverseChainTest.java", "diffHunk": "@@ -0,0 +1,1034 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.server.test;\n+\n+import static com.ibm.fhir.model.type.String.of;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.ws.rs.client.Entity;\n+import javax.ws.rs.client.WebTarget;\n+import javax.ws.rs.core.Response;\n+\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.Test;\n+\n+import com.ibm.fhir.core.FHIRMediaType;\n+import com.ibm.fhir.model.format.Format;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Encounter;\n+import com.ibm.fhir.model.resource.Endpoint;\n+import com.ibm.fhir.model.resource.Location;\n+import com.ibm.fhir.model.resource.OperationOutcome;\n+import com.ibm.fhir.model.resource.Organization;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Procedure;\n+import com.ibm.fhir.model.test.TestUtil;\n+import com.ibm.fhir.model.type.Code;\n+import com.ibm.fhir.model.type.CodeableConcept;\n+import com.ibm.fhir.model.type.Coding;\n+import com.ibm.fhir.model.type.ContactPoint;\n+import com.ibm.fhir.model.type.Date;\n+import com.ibm.fhir.model.type.DateTime;\n+import com.ibm.fhir.model.type.Decimal;\n+import com.ibm.fhir.model.type.Duration;\n+import com.ibm.fhir.model.type.HumanName;\n+import com.ibm.fhir.model.type.Meta;\n+import com.ibm.fhir.model.type.Period;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.Uri;\n+import com.ibm.fhir.model.type.code.AdministrativeGender;\n+import com.ibm.fhir.model.type.code.ContactPointSystem;\n+import com.ibm.fhir.model.type.code.EncounterStatus;\n+import com.ibm.fhir.model.type.code.ProcedureStatus;\n+import com.ibm.fhir.model.type.code.ResourceType;\n+\n+/**\n+ * The tests execute the reverse chained behavior in order to exercise reference chains.\n+ */\n+public class SearchReverseChainTest extends FHIRServerTestBase {\n+    private String patient1Id;\n+    private String patient2Id;\n+    private String procedure1Id;\n+    private String procedure2Id;\n+    private String organization1Id;\n+    private String organization2Id;\n+    private String encounter1Id;\n+    private String encounter2Id;\n+    private String endpointId;\n+    private String locationId;\n+    private Instant now = Instant.now();\n+    private String tag = Long.toString(now.toEpochMilli());\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testCreateEndpoint() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+       // Build a new Endpoint.\n+        Endpoint endpoint = TestUtil.getMinimalResource(ResourceType.ENDPOINT, Format.JSON);\n+        endpoint = endpoint.toBuilder().name(of(tag)).build();\n+\n+        // Call the 'create' API.\n+        Entity<Endpoint> entity = Entity.entity(endpoint, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Endpoint\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the endpoint's logical id value.\n+        endpointId = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new Endpoint and verify it.\n+        response = target.path(\"Endpoint/\" + endpointId).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEndpoint\"})\n+    public void testCreateOrganization1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Organization.\n+        Organization organization = TestUtil.getMinimalResource(ResourceType.ORGANIZATION, Format.JSON);\n+        organization = organization.toBuilder()\n+                .name(of(tag))\n+                .endpoint(Reference.builder().reference(of(\"Endpoint/\" + endpointId)).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Organization> entity = Entity.entity(organization, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Organization\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the organization's logical id value.\n+        organization1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new organization and verify it.\n+        response = target.path(\"Organization/\" + organization1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEndpoint\"})\n+    public void testCreateOrganization2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+       // Build a new Organization.\n+        Organization organization = TestUtil.getMinimalResource(ResourceType.ORGANIZATION, Format.JSON);\n+        organization = organization.toBuilder()\n+                .name(of(tag))\n+                .endpoint(Reference.builder().reference(of(\"Endpoint/\" + endpointId)).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Organization> entity = Entity.entity(organization, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Organization\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the organization's logical id value.\n+        organization2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new organization and verify it.\n+        response = target.path(\"Organization/\" + organization2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateOrganization1\"})\n+    public void testCreatePatient1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Patient and then call the 'create' API.\n+        Patient patient = TestUtil.getMinimalResource(ResourceType.PATIENT, Format.JSON);\n+        patient = patient.toBuilder()\n+                .gender(AdministrativeGender.MALE)\n+                .name(HumanName.builder()\n+                    .given(of(\"1\" + tag))\n+                    .build())\n+                .meta(Meta.builder()\n+                    .tag(Coding.builder()\n+                        .code(Code.of(tag))\n+                        .build())\n+                    .build())\n+                .generalPractitioner(Reference.builder().reference(of(\"PractitionerRole/\" + tag)).build())\n+                .managingOrganization(Reference.builder().reference(of(\"Organization/\" + organization1Id)).build())\n+                .birthDate(Date.of(now.toString().substring(0,10)))\n+                .telecom(ContactPoint.builder().system(ContactPointSystem.PHONE).value(of(\"1\" + tag)).build())\n+               .build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "originalPosition": 162}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzg4OTI2", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-523388926", "createdAt": "2020-11-04T14:03:50Z", "commit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDowMzo1MFrOHtZc5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDowMzo1MFrOHtZc5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2NDk2Nw==", "bodyText": "same formatter comment", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517364967", "createdAt": "2020-11-04T14:03:50Z", "author": {"login": "prb112"}, "path": "fhir-server-test/src/test/java/com/ibm/fhir/server/test/SearchReverseChainTest.java", "diffHunk": "@@ -0,0 +1,1034 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.server.test;\n+\n+import static com.ibm.fhir.model.type.String.of;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.ws.rs.client.Entity;\n+import javax.ws.rs.client.WebTarget;\n+import javax.ws.rs.core.Response;\n+\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.Test;\n+\n+import com.ibm.fhir.core.FHIRMediaType;\n+import com.ibm.fhir.model.format.Format;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Encounter;\n+import com.ibm.fhir.model.resource.Endpoint;\n+import com.ibm.fhir.model.resource.Location;\n+import com.ibm.fhir.model.resource.OperationOutcome;\n+import com.ibm.fhir.model.resource.Organization;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Procedure;\n+import com.ibm.fhir.model.test.TestUtil;\n+import com.ibm.fhir.model.type.Code;\n+import com.ibm.fhir.model.type.CodeableConcept;\n+import com.ibm.fhir.model.type.Coding;\n+import com.ibm.fhir.model.type.ContactPoint;\n+import com.ibm.fhir.model.type.Date;\n+import com.ibm.fhir.model.type.DateTime;\n+import com.ibm.fhir.model.type.Decimal;\n+import com.ibm.fhir.model.type.Duration;\n+import com.ibm.fhir.model.type.HumanName;\n+import com.ibm.fhir.model.type.Meta;\n+import com.ibm.fhir.model.type.Period;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.Uri;\n+import com.ibm.fhir.model.type.code.AdministrativeGender;\n+import com.ibm.fhir.model.type.code.ContactPointSystem;\n+import com.ibm.fhir.model.type.code.EncounterStatus;\n+import com.ibm.fhir.model.type.code.ProcedureStatus;\n+import com.ibm.fhir.model.type.code.ResourceType;\n+\n+/**\n+ * The tests execute the reverse chained behavior in order to exercise reference chains.\n+ */\n+public class SearchReverseChainTest extends FHIRServerTestBase {\n+    private String patient1Id;\n+    private String patient2Id;\n+    private String procedure1Id;\n+    private String procedure2Id;\n+    private String organization1Id;\n+    private String organization2Id;\n+    private String encounter1Id;\n+    private String encounter2Id;\n+    private String endpointId;\n+    private String locationId;\n+    private Instant now = Instant.now();\n+    private String tag = Long.toString(now.toEpochMilli());\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testCreateEndpoint() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+       // Build a new Endpoint.\n+        Endpoint endpoint = TestUtil.getMinimalResource(ResourceType.ENDPOINT, Format.JSON);\n+        endpoint = endpoint.toBuilder().name(of(tag)).build();\n+\n+        // Call the 'create' API.\n+        Entity<Endpoint> entity = Entity.entity(endpoint, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Endpoint\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the endpoint's logical id value.\n+        endpointId = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new Endpoint and verify it.\n+        response = target.path(\"Endpoint/\" + endpointId).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEndpoint\"})\n+    public void testCreateOrganization1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Organization.\n+        Organization organization = TestUtil.getMinimalResource(ResourceType.ORGANIZATION, Format.JSON);\n+        organization = organization.toBuilder()\n+                .name(of(tag))\n+                .endpoint(Reference.builder().reference(of(\"Endpoint/\" + endpointId)).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Organization> entity = Entity.entity(organization, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Organization\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the organization's logical id value.\n+        organization1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new organization and verify it.\n+        response = target.path(\"Organization/\" + organization1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEndpoint\"})\n+    public void testCreateOrganization2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+       // Build a new Organization.\n+        Organization organization = TestUtil.getMinimalResource(ResourceType.ORGANIZATION, Format.JSON);\n+        organization = organization.toBuilder()\n+                .name(of(tag))\n+                .endpoint(Reference.builder().reference(of(\"Endpoint/\" + endpointId)).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Organization> entity = Entity.entity(organization, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Organization\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the organization's logical id value.\n+        organization2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new organization and verify it.\n+        response = target.path(\"Organization/\" + organization2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateOrganization1\"})\n+    public void testCreatePatient1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Patient and then call the 'create' API.\n+        Patient patient = TestUtil.getMinimalResource(ResourceType.PATIENT, Format.JSON);\n+        patient = patient.toBuilder()\n+                .gender(AdministrativeGender.MALE)\n+                .name(HumanName.builder()\n+                    .given(of(\"1\" + tag))\n+                    .build())\n+                .meta(Meta.builder()\n+                    .tag(Coding.builder()\n+                        .code(Code.of(tag))\n+                        .build())\n+                    .build())\n+                .generalPractitioner(Reference.builder().reference(of(\"PractitionerRole/\" + tag)).build())\n+                .managingOrganization(Reference.builder().reference(of(\"Organization/\" + organization1Id)).build())\n+                .birthDate(Date.of(now.toString().substring(0,10)))\n+                .telecom(ContactPoint.builder().system(ContactPointSystem.PHONE).value(of(\"1\" + tag)).build())\n+               .build();\n+\n+        Entity<Patient> entity = Entity.entity(patient, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Patient\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the patient's logical id value.\n+        patient1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new patient and verify it.\n+        response = target.path(\"Patient/\" + patient1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreatePatient1\", \"testCreateOrganization2\"})\n+    public void testCreatePatient2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Patient and then call the 'create' API.\n+        Patient patient = TestUtil.getMinimalResource(ResourceType.PATIENT, Format.JSON);\n+        patient = patient.toBuilder()\n+                .gender(AdministrativeGender.FEMALE)\n+                .name(HumanName.builder()\n+                    .given(of(\"2\" + tag))\n+                    .build())\n+                .meta(Meta.builder()\n+                    .tag(Coding.builder()\n+                        .code(Code.of(tag))\n+                        .build())\n+                    .build())\n+                .generalPractitioner(Reference.builder().reference(of(\"Practitioner/\" + tag)).build())\n+                .managingOrganization(Reference.builder().reference(of(\"Organization/\" + organization2Id)).build())\n+                .birthDate(Date.of(now.minus(1, ChronoUnit.DAYS).toString().substring(0,10)))\n+                .telecom(ContactPoint.builder().system(ContactPointSystem.PHONE).value(of(\"2\" + tag)).build())\n+                .build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "originalPosition": 196}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzkwNzkz", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-523390793", "createdAt": "2020-11-04T14:05:52Z", "commit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDowNTo1MlrOHtZihg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDowNTo1MlrOHtZihg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2NjQwNg==", "bodyText": "Refer to corresponding comment in SearchUtil (this response should have 'badModifier' and possibly be URL Encoded.", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517366406", "createdAt": "2020-11-04T14:05:52Z", "author": {"login": "prb112"}, "path": "fhir-server-test/src/test/java/com/ibm/fhir/server/test/SearchReverseChainTest.java", "diffHunk": "@@ -0,0 +1,1034 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.server.test;\n+\n+import static com.ibm.fhir.model.type.String.of;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.ws.rs.client.Entity;\n+import javax.ws.rs.client.WebTarget;\n+import javax.ws.rs.core.Response;\n+\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.Test;\n+\n+import com.ibm.fhir.core.FHIRMediaType;\n+import com.ibm.fhir.model.format.Format;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Encounter;\n+import com.ibm.fhir.model.resource.Endpoint;\n+import com.ibm.fhir.model.resource.Location;\n+import com.ibm.fhir.model.resource.OperationOutcome;\n+import com.ibm.fhir.model.resource.Organization;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Procedure;\n+import com.ibm.fhir.model.test.TestUtil;\n+import com.ibm.fhir.model.type.Code;\n+import com.ibm.fhir.model.type.CodeableConcept;\n+import com.ibm.fhir.model.type.Coding;\n+import com.ibm.fhir.model.type.ContactPoint;\n+import com.ibm.fhir.model.type.Date;\n+import com.ibm.fhir.model.type.DateTime;\n+import com.ibm.fhir.model.type.Decimal;\n+import com.ibm.fhir.model.type.Duration;\n+import com.ibm.fhir.model.type.HumanName;\n+import com.ibm.fhir.model.type.Meta;\n+import com.ibm.fhir.model.type.Period;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.Uri;\n+import com.ibm.fhir.model.type.code.AdministrativeGender;\n+import com.ibm.fhir.model.type.code.ContactPointSystem;\n+import com.ibm.fhir.model.type.code.EncounterStatus;\n+import com.ibm.fhir.model.type.code.ProcedureStatus;\n+import com.ibm.fhir.model.type.code.ResourceType;\n+\n+/**\n+ * The tests execute the reverse chained behavior in order to exercise reference chains.\n+ */\n+public class SearchReverseChainTest extends FHIRServerTestBase {\n+    private String patient1Id;\n+    private String patient2Id;\n+    private String procedure1Id;\n+    private String procedure2Id;\n+    private String organization1Id;\n+    private String organization2Id;\n+    private String encounter1Id;\n+    private String encounter2Id;\n+    private String endpointId;\n+    private String locationId;\n+    private Instant now = Instant.now();\n+    private String tag = Long.toString(now.toEpochMilli());\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testCreateEndpoint() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+       // Build a new Endpoint.\n+        Endpoint endpoint = TestUtil.getMinimalResource(ResourceType.ENDPOINT, Format.JSON);\n+        endpoint = endpoint.toBuilder().name(of(tag)).build();\n+\n+        // Call the 'create' API.\n+        Entity<Endpoint> entity = Entity.entity(endpoint, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Endpoint\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the endpoint's logical id value.\n+        endpointId = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new Endpoint and verify it.\n+        response = target.path(\"Endpoint/\" + endpointId).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEndpoint\"})\n+    public void testCreateOrganization1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Organization.\n+        Organization organization = TestUtil.getMinimalResource(ResourceType.ORGANIZATION, Format.JSON);\n+        organization = organization.toBuilder()\n+                .name(of(tag))\n+                .endpoint(Reference.builder().reference(of(\"Endpoint/\" + endpointId)).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Organization> entity = Entity.entity(organization, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Organization\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the organization's logical id value.\n+        organization1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new organization and verify it.\n+        response = target.path(\"Organization/\" + organization1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEndpoint\"})\n+    public void testCreateOrganization2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+       // Build a new Organization.\n+        Organization organization = TestUtil.getMinimalResource(ResourceType.ORGANIZATION, Format.JSON);\n+        organization = organization.toBuilder()\n+                .name(of(tag))\n+                .endpoint(Reference.builder().reference(of(\"Endpoint/\" + endpointId)).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Organization> entity = Entity.entity(organization, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Organization\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the organization's logical id value.\n+        organization2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new organization and verify it.\n+        response = target.path(\"Organization/\" + organization2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateOrganization1\"})\n+    public void testCreatePatient1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Patient and then call the 'create' API.\n+        Patient patient = TestUtil.getMinimalResource(ResourceType.PATIENT, Format.JSON);\n+        patient = patient.toBuilder()\n+                .gender(AdministrativeGender.MALE)\n+                .name(HumanName.builder()\n+                    .given(of(\"1\" + tag))\n+                    .build())\n+                .meta(Meta.builder()\n+                    .tag(Coding.builder()\n+                        .code(Code.of(tag))\n+                        .build())\n+                    .build())\n+                .generalPractitioner(Reference.builder().reference(of(\"PractitionerRole/\" + tag)).build())\n+                .managingOrganization(Reference.builder().reference(of(\"Organization/\" + organization1Id)).build())\n+                .birthDate(Date.of(now.toString().substring(0,10)))\n+                .telecom(ContactPoint.builder().system(ContactPointSystem.PHONE).value(of(\"1\" + tag)).build())\n+               .build();\n+\n+        Entity<Patient> entity = Entity.entity(patient, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Patient\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the patient's logical id value.\n+        patient1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new patient and verify it.\n+        response = target.path(\"Patient/\" + patient1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreatePatient1\", \"testCreateOrganization2\"})\n+    public void testCreatePatient2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Patient and then call the 'create' API.\n+        Patient patient = TestUtil.getMinimalResource(ResourceType.PATIENT, Format.JSON);\n+        patient = patient.toBuilder()\n+                .gender(AdministrativeGender.FEMALE)\n+                .name(HumanName.builder()\n+                    .given(of(\"2\" + tag))\n+                    .build())\n+                .meta(Meta.builder()\n+                    .tag(Coding.builder()\n+                        .code(Code.of(tag))\n+                        .build())\n+                    .build())\n+                .generalPractitioner(Reference.builder().reference(of(\"Practitioner/\" + tag)).build())\n+                .managingOrganization(Reference.builder().reference(of(\"Organization/\" + organization2Id)).build())\n+                .birthDate(Date.of(now.minus(1, ChronoUnit.DAYS).toString().substring(0,10)))\n+                .telecom(ContactPoint.builder().system(ContactPointSystem.PHONE).value(of(\"2\" + tag)).build())\n+                .build();\n+\n+        Entity<Patient> entity = Entity.entity(patient, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Patient\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the patient's logical id value.\n+        patient2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new patient and verify it.\n+        response = target.path(\"Patient/\" + patient2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreatePatient1\"})\n+    public void testCreateProcedure1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Procedure and add subject reference to patient.\n+        Procedure procedure = TestUtil.getMinimalResource(ResourceType.PROCEDURE, Format.JSON);\n+        procedure = procedure.toBuilder()\n+                .status(ProcedureStatus.COMPLETED)\n+                .subject(Reference.builder().reference(of(\"Patient/\" + patient1Id)).build())\n+                .basedOn(Reference.builder().reference(of(\"CarePlan/\" + tag)).build())\n+                .performed(DateTime.of(now.toString()))\n+                .instantiatesUri(Uri.of(\"1\" + tag))\n+                .code(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"1\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Procedure> entity = Entity.entity(procedure, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Procedure\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the procedure's logical id value.\n+        procedure1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new procedure and verify it.\n+        response = target.path(\"Procedure/\" + procedure1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreatePatient2\"})\n+    public void testCreateProcedure2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        Reference reference = Reference.builder().reference(of(\"Patient/\" + patient2Id)).build();\n+\n+        // Build a new Procedure and add subject reference to patient.\n+        Procedure procedure = TestUtil.getMinimalResource(ResourceType.PROCEDURE, Format.JSON);\n+        procedure = procedure.toBuilder()\n+                .status(ProcedureStatus.COMPLETED)\n+                .subject(reference)\n+                .basedOn(Reference.builder().reference(of(\"ServiceRequest/\" + tag)).build())\n+                .performed(DateTime.of(now.minus(1, ChronoUnit.DAYS).toString()))\n+                .instantiatesUri(Uri.of(\"2\" + tag))\n+                .code(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"2\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Procedure> entity = Entity.entity(procedure, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Procedure\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the procedure's logical id value.\n+        procedure2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new procedure and verify it.\n+        response = target.path(\"Procedure/\" + procedure2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure1\", \"testCreateOrganization1\"})\n+    public void testCreateEncounter1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Encounter and add reason-reference reference to procedure.\n+        Encounter encounter = TestUtil.getMinimalResource(ResourceType.ENCOUNTER, Format.JSON);\n+        encounter = encounter.toBuilder()\n+                .status(EncounterStatus.FINISHED)\n+                .reasonReference(Reference.builder().reference(of(\"Procedure/\" + procedure1Id)).build())\n+                .serviceProvider(Reference.builder().reference(of(\"Organization/\" + organization1Id)).build())\n+                .period(Period.builder().start(DateTime.of(now.toString())).end(DateTime.of(now.toString())).build())\n+                .length(Duration.builder().system(Uri.of(\"http://unitsofmeasure.org\")).code(Code.of(\"s\")).value(Decimal.of(\"1\" + tag)).build())\n+                .type(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"1\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Encounter> entity = Entity.entity(encounter, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Encounter\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the encounter's logical id value.\n+        encounter1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new encounter and verify it.\n+        response = target.path(\"Encounter/\" + encounter1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure2\", \"testCreateOrganization2\"})\n+    public void testCreateEncounter2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Encounter and add reason-reference reference to procedure.\n+        Encounter encounter = TestUtil.getMinimalResource(ResourceType.ENCOUNTER, Format.JSON);\n+        encounter = encounter.toBuilder()\n+                .status(EncounterStatus.FINISHED)\n+                .reasonReference(Reference.builder().reference(of(\"Procedure/\" + procedure2Id)).build())\n+                .serviceProvider(Reference.builder().reference(of(\"Organization/\" + organization2Id)).build())\n+                .period(Period.builder().start(DateTime.of(now.minus(1, ChronoUnit.DAYS).toString())).end(DateTime.of(now.minus(1, ChronoUnit.DAYS).toString())).build())\n+                .length(Duration.builder().system(Uri.of(\"http://unitsofmeasure.org\")).code(Code.of(\"s\")).value(Decimal.of(\"2\" + tag)).build())\n+                .type(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"2\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Encounter> entity = Entity.entity(encounter, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Encounter\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the encounter's logical id value.\n+        encounter2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new encounter and verify it.\n+        response = target.path(\"Encounter/\" + encounter2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateOrganization1\"})\n+    public void testCreateLocation() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        Location location = TestUtil.readExampleResource(\"json/spec/location-example.json\");\n+        location = location.toBuilder()\n+                .managingOrganization(Reference.builder().reference(of(\"Organization/\" + organization1Id)).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Location> entity = Entity.entity(location, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Location\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the location's logical id value.\n+        locationId = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new Location and verify it.\n+        response   = target.path(\"Location/\" + locationId).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @AfterClass\n+    public void testDeleteResources() {\n+        WebTarget target = getWebTarget();\n+        if (patient1Id != null) {\n+            Response response   = target.path(\"Patient/\" + patient1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (patient2Id != null) {\n+            Response response   = target.path(\"Patient/\" + patient2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (procedure1Id != null) {\n+            Response response   = target.path(\"Procedure/\" + procedure1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (procedure2Id != null) {\n+            Response response   = target.path(\"Procedure/\" + procedure2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (organization1Id != null) {\n+            Response response   = target.path(\"Organization/\" + organization1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (organization2Id != null) {\n+            Response response   = target.path(\"Organization/\" + organization2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (encounter1Id != null) {\n+            Response response   = target.path(\"Encounter/\" + encounter1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (encounter2Id != null) {\n+            Response response   = target.path(\"Encounter/\" + encounter2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (endpointId != null) {\n+            Response response   = target.path(\"Endpoint/\" + endpointId).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (locationId != null) {\n+            Response response   = target.path(\"Location/\" + locationId).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithTypeError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"\")\n+                .queryParam(\"_type\", \"Patient\")\n+                .queryParam(\"_has:Procedure:subject:status\", ProcedureStatus.COMPLETED.getValue())\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"system search not supported with _has\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithParseError1() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"An incorrect number of components were specified for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithParseError2() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"An incorrect number of components were specified for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithParseError3() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:extra:_has:Encounter:reason-reference:status\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"An incorrect number of components were specified for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithResourceTypeNotValidError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:BadType:subject:code\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Resource type 'BadType' is not valid for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmNotFoundError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:badSearchParm:code\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter 'badSearchParm' for resource type 'Procedure' was not found.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmNotFoundError2() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:badSearchParm\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter 'badSearchParm' for resource type 'Procedure' was not found.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmNotReferenceError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:code:code\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter 'code' is not of type reference for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmTargetTypeNotValidError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:encounter:code\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter 'encounter' target types do not include expected type 'Patient' for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmUndefinedModifierError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:code:badModifier\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Undefined Modifier: badModifier\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "originalPosition": 519}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzkyNTk0", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-523392594", "createdAt": "2020-11-04T14:07:41Z", "commit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDowNzo0MVrOHtZn6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDowNzo0MVrOHtZn6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2Nzc4Ng==", "bodyText": "Why does this become uppercase, should we upper case it?", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517367786", "createdAt": "2020-11-04T14:07:41Z", "author": {"login": "prb112"}, "path": "fhir-server-test/src/test/java/com/ibm/fhir/server/test/SearchReverseChainTest.java", "diffHunk": "@@ -0,0 +1,1034 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.server.test;\n+\n+import static com.ibm.fhir.model.type.String.of;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.ws.rs.client.Entity;\n+import javax.ws.rs.client.WebTarget;\n+import javax.ws.rs.core.Response;\n+\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.Test;\n+\n+import com.ibm.fhir.core.FHIRMediaType;\n+import com.ibm.fhir.model.format.Format;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Encounter;\n+import com.ibm.fhir.model.resource.Endpoint;\n+import com.ibm.fhir.model.resource.Location;\n+import com.ibm.fhir.model.resource.OperationOutcome;\n+import com.ibm.fhir.model.resource.Organization;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Procedure;\n+import com.ibm.fhir.model.test.TestUtil;\n+import com.ibm.fhir.model.type.Code;\n+import com.ibm.fhir.model.type.CodeableConcept;\n+import com.ibm.fhir.model.type.Coding;\n+import com.ibm.fhir.model.type.ContactPoint;\n+import com.ibm.fhir.model.type.Date;\n+import com.ibm.fhir.model.type.DateTime;\n+import com.ibm.fhir.model.type.Decimal;\n+import com.ibm.fhir.model.type.Duration;\n+import com.ibm.fhir.model.type.HumanName;\n+import com.ibm.fhir.model.type.Meta;\n+import com.ibm.fhir.model.type.Period;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.Uri;\n+import com.ibm.fhir.model.type.code.AdministrativeGender;\n+import com.ibm.fhir.model.type.code.ContactPointSystem;\n+import com.ibm.fhir.model.type.code.EncounterStatus;\n+import com.ibm.fhir.model.type.code.ProcedureStatus;\n+import com.ibm.fhir.model.type.code.ResourceType;\n+\n+/**\n+ * The tests execute the reverse chained behavior in order to exercise reference chains.\n+ */\n+public class SearchReverseChainTest extends FHIRServerTestBase {\n+    private String patient1Id;\n+    private String patient2Id;\n+    private String procedure1Id;\n+    private String procedure2Id;\n+    private String organization1Id;\n+    private String organization2Id;\n+    private String encounter1Id;\n+    private String encounter2Id;\n+    private String endpointId;\n+    private String locationId;\n+    private Instant now = Instant.now();\n+    private String tag = Long.toString(now.toEpochMilli());\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testCreateEndpoint() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+       // Build a new Endpoint.\n+        Endpoint endpoint = TestUtil.getMinimalResource(ResourceType.ENDPOINT, Format.JSON);\n+        endpoint = endpoint.toBuilder().name(of(tag)).build();\n+\n+        // Call the 'create' API.\n+        Entity<Endpoint> entity = Entity.entity(endpoint, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Endpoint\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the endpoint's logical id value.\n+        endpointId = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new Endpoint and verify it.\n+        response = target.path(\"Endpoint/\" + endpointId).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEndpoint\"})\n+    public void testCreateOrganization1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Organization.\n+        Organization organization = TestUtil.getMinimalResource(ResourceType.ORGANIZATION, Format.JSON);\n+        organization = organization.toBuilder()\n+                .name(of(tag))\n+                .endpoint(Reference.builder().reference(of(\"Endpoint/\" + endpointId)).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Organization> entity = Entity.entity(organization, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Organization\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the organization's logical id value.\n+        organization1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new organization and verify it.\n+        response = target.path(\"Organization/\" + organization1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEndpoint\"})\n+    public void testCreateOrganization2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+       // Build a new Organization.\n+        Organization organization = TestUtil.getMinimalResource(ResourceType.ORGANIZATION, Format.JSON);\n+        organization = organization.toBuilder()\n+                .name(of(tag))\n+                .endpoint(Reference.builder().reference(of(\"Endpoint/\" + endpointId)).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Organization> entity = Entity.entity(organization, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Organization\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the organization's logical id value.\n+        organization2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new organization and verify it.\n+        response = target.path(\"Organization/\" + organization2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateOrganization1\"})\n+    public void testCreatePatient1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Patient and then call the 'create' API.\n+        Patient patient = TestUtil.getMinimalResource(ResourceType.PATIENT, Format.JSON);\n+        patient = patient.toBuilder()\n+                .gender(AdministrativeGender.MALE)\n+                .name(HumanName.builder()\n+                    .given(of(\"1\" + tag))\n+                    .build())\n+                .meta(Meta.builder()\n+                    .tag(Coding.builder()\n+                        .code(Code.of(tag))\n+                        .build())\n+                    .build())\n+                .generalPractitioner(Reference.builder().reference(of(\"PractitionerRole/\" + tag)).build())\n+                .managingOrganization(Reference.builder().reference(of(\"Organization/\" + organization1Id)).build())\n+                .birthDate(Date.of(now.toString().substring(0,10)))\n+                .telecom(ContactPoint.builder().system(ContactPointSystem.PHONE).value(of(\"1\" + tag)).build())\n+               .build();\n+\n+        Entity<Patient> entity = Entity.entity(patient, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Patient\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the patient's logical id value.\n+        patient1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new patient and verify it.\n+        response = target.path(\"Patient/\" + patient1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreatePatient1\", \"testCreateOrganization2\"})\n+    public void testCreatePatient2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Patient and then call the 'create' API.\n+        Patient patient = TestUtil.getMinimalResource(ResourceType.PATIENT, Format.JSON);\n+        patient = patient.toBuilder()\n+                .gender(AdministrativeGender.FEMALE)\n+                .name(HumanName.builder()\n+                    .given(of(\"2\" + tag))\n+                    .build())\n+                .meta(Meta.builder()\n+                    .tag(Coding.builder()\n+                        .code(Code.of(tag))\n+                        .build())\n+                    .build())\n+                .generalPractitioner(Reference.builder().reference(of(\"Practitioner/\" + tag)).build())\n+                .managingOrganization(Reference.builder().reference(of(\"Organization/\" + organization2Id)).build())\n+                .birthDate(Date.of(now.minus(1, ChronoUnit.DAYS).toString().substring(0,10)))\n+                .telecom(ContactPoint.builder().system(ContactPointSystem.PHONE).value(of(\"2\" + tag)).build())\n+                .build();\n+\n+        Entity<Patient> entity = Entity.entity(patient, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Patient\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the patient's logical id value.\n+        patient2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new patient and verify it.\n+        response = target.path(\"Patient/\" + patient2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreatePatient1\"})\n+    public void testCreateProcedure1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Procedure and add subject reference to patient.\n+        Procedure procedure = TestUtil.getMinimalResource(ResourceType.PROCEDURE, Format.JSON);\n+        procedure = procedure.toBuilder()\n+                .status(ProcedureStatus.COMPLETED)\n+                .subject(Reference.builder().reference(of(\"Patient/\" + patient1Id)).build())\n+                .basedOn(Reference.builder().reference(of(\"CarePlan/\" + tag)).build())\n+                .performed(DateTime.of(now.toString()))\n+                .instantiatesUri(Uri.of(\"1\" + tag))\n+                .code(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"1\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Procedure> entity = Entity.entity(procedure, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Procedure\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the procedure's logical id value.\n+        procedure1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new procedure and verify it.\n+        response = target.path(\"Procedure/\" + procedure1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreatePatient2\"})\n+    public void testCreateProcedure2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        Reference reference = Reference.builder().reference(of(\"Patient/\" + patient2Id)).build();\n+\n+        // Build a new Procedure and add subject reference to patient.\n+        Procedure procedure = TestUtil.getMinimalResource(ResourceType.PROCEDURE, Format.JSON);\n+        procedure = procedure.toBuilder()\n+                .status(ProcedureStatus.COMPLETED)\n+                .subject(reference)\n+                .basedOn(Reference.builder().reference(of(\"ServiceRequest/\" + tag)).build())\n+                .performed(DateTime.of(now.minus(1, ChronoUnit.DAYS).toString()))\n+                .instantiatesUri(Uri.of(\"2\" + tag))\n+                .code(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"2\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Procedure> entity = Entity.entity(procedure, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Procedure\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the procedure's logical id value.\n+        procedure2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new procedure and verify it.\n+        response = target.path(\"Procedure/\" + procedure2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure1\", \"testCreateOrganization1\"})\n+    public void testCreateEncounter1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Encounter and add reason-reference reference to procedure.\n+        Encounter encounter = TestUtil.getMinimalResource(ResourceType.ENCOUNTER, Format.JSON);\n+        encounter = encounter.toBuilder()\n+                .status(EncounterStatus.FINISHED)\n+                .reasonReference(Reference.builder().reference(of(\"Procedure/\" + procedure1Id)).build())\n+                .serviceProvider(Reference.builder().reference(of(\"Organization/\" + organization1Id)).build())\n+                .period(Period.builder().start(DateTime.of(now.toString())).end(DateTime.of(now.toString())).build())\n+                .length(Duration.builder().system(Uri.of(\"http://unitsofmeasure.org\")).code(Code.of(\"s\")).value(Decimal.of(\"1\" + tag)).build())\n+                .type(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"1\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Encounter> entity = Entity.entity(encounter, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Encounter\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the encounter's logical id value.\n+        encounter1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new encounter and verify it.\n+        response = target.path(\"Encounter/\" + encounter1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure2\", \"testCreateOrganization2\"})\n+    public void testCreateEncounter2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Encounter and add reason-reference reference to procedure.\n+        Encounter encounter = TestUtil.getMinimalResource(ResourceType.ENCOUNTER, Format.JSON);\n+        encounter = encounter.toBuilder()\n+                .status(EncounterStatus.FINISHED)\n+                .reasonReference(Reference.builder().reference(of(\"Procedure/\" + procedure2Id)).build())\n+                .serviceProvider(Reference.builder().reference(of(\"Organization/\" + organization2Id)).build())\n+                .period(Period.builder().start(DateTime.of(now.minus(1, ChronoUnit.DAYS).toString())).end(DateTime.of(now.minus(1, ChronoUnit.DAYS).toString())).build())\n+                .length(Duration.builder().system(Uri.of(\"http://unitsofmeasure.org\")).code(Code.of(\"s\")).value(Decimal.of(\"2\" + tag)).build())\n+                .type(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"2\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Encounter> entity = Entity.entity(encounter, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Encounter\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the encounter's logical id value.\n+        encounter2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new encounter and verify it.\n+        response = target.path(\"Encounter/\" + encounter2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateOrganization1\"})\n+    public void testCreateLocation() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        Location location = TestUtil.readExampleResource(\"json/spec/location-example.json\");\n+        location = location.toBuilder()\n+                .managingOrganization(Reference.builder().reference(of(\"Organization/\" + organization1Id)).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Location> entity = Entity.entity(location, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Location\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the location's logical id value.\n+        locationId = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new Location and verify it.\n+        response   = target.path(\"Location/\" + locationId).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @AfterClass\n+    public void testDeleteResources() {\n+        WebTarget target = getWebTarget();\n+        if (patient1Id != null) {\n+            Response response   = target.path(\"Patient/\" + patient1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (patient2Id != null) {\n+            Response response   = target.path(\"Patient/\" + patient2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (procedure1Id != null) {\n+            Response response   = target.path(\"Procedure/\" + procedure1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (procedure2Id != null) {\n+            Response response   = target.path(\"Procedure/\" + procedure2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (organization1Id != null) {\n+            Response response   = target.path(\"Organization/\" + organization1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (organization2Id != null) {\n+            Response response   = target.path(\"Organization/\" + organization2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (encounter1Id != null) {\n+            Response response   = target.path(\"Encounter/\" + encounter1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (encounter2Id != null) {\n+            Response response   = target.path(\"Encounter/\" + encounter2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (endpointId != null) {\n+            Response response   = target.path(\"Endpoint/\" + endpointId).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (locationId != null) {\n+            Response response   = target.path(\"Location/\" + locationId).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithTypeError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"\")\n+                .queryParam(\"_type\", \"Patient\")\n+                .queryParam(\"_has:Procedure:subject:status\", ProcedureStatus.COMPLETED.getValue())\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"system search not supported with _has\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithParseError1() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"An incorrect number of components were specified for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithParseError2() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"An incorrect number of components were specified for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithParseError3() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:extra:_has:Encounter:reason-reference:status\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"An incorrect number of components were specified for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithResourceTypeNotValidError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:BadType:subject:code\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Resource type 'BadType' is not valid for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmNotFoundError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:badSearchParm:code\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter 'badSearchParm' for resource type 'Procedure' was not found.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmNotFoundError2() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:badSearchParm\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter 'badSearchParm' for resource type 'Procedure' was not found.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmNotReferenceError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:code:code\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter 'code' is not of type reference for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmTargetTypeNotValidError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:encounter:code\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter 'encounter' target types do not include expected type 'Patient' for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmUndefinedModifierError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:code:badModifier\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Undefined Modifier: badModifier\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmUnsupportedModifierError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:code:contains\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Unsupported type/modifier combination: token/contains\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmIsResultParmError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:_total\", \"1\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter '_total' for resource type 'Procedure' was not found.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithChainedSearchParmBadModifierError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:encounter:contains.status\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Modifier: 'CONTAINS' not allowed on chained parameter\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "originalPosition": 558}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzkzMzEw", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-523393310", "createdAt": "2020-11-04T14:08:26Z", "commit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDowODoyNlrOHtZp_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDowODoyNlrOHtZp_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2ODMxOQ==", "bodyText": "Why does this become uppercase? I think it's from the fhir-search Type enum, and we should probably use the natural value of lower case token which is what's read fromt he Parameter", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517368319", "createdAt": "2020-11-04T14:08:26Z", "author": {"login": "prb112"}, "path": "fhir-server-test/src/test/java/com/ibm/fhir/server/test/SearchReverseChainTest.java", "diffHunk": "@@ -0,0 +1,1034 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.server.test;\n+\n+import static com.ibm.fhir.model.type.String.of;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.ws.rs.client.Entity;\n+import javax.ws.rs.client.WebTarget;\n+import javax.ws.rs.core.Response;\n+\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.Test;\n+\n+import com.ibm.fhir.core.FHIRMediaType;\n+import com.ibm.fhir.model.format.Format;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Encounter;\n+import com.ibm.fhir.model.resource.Endpoint;\n+import com.ibm.fhir.model.resource.Location;\n+import com.ibm.fhir.model.resource.OperationOutcome;\n+import com.ibm.fhir.model.resource.Organization;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Procedure;\n+import com.ibm.fhir.model.test.TestUtil;\n+import com.ibm.fhir.model.type.Code;\n+import com.ibm.fhir.model.type.CodeableConcept;\n+import com.ibm.fhir.model.type.Coding;\n+import com.ibm.fhir.model.type.ContactPoint;\n+import com.ibm.fhir.model.type.Date;\n+import com.ibm.fhir.model.type.DateTime;\n+import com.ibm.fhir.model.type.Decimal;\n+import com.ibm.fhir.model.type.Duration;\n+import com.ibm.fhir.model.type.HumanName;\n+import com.ibm.fhir.model.type.Meta;\n+import com.ibm.fhir.model.type.Period;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.Uri;\n+import com.ibm.fhir.model.type.code.AdministrativeGender;\n+import com.ibm.fhir.model.type.code.ContactPointSystem;\n+import com.ibm.fhir.model.type.code.EncounterStatus;\n+import com.ibm.fhir.model.type.code.ProcedureStatus;\n+import com.ibm.fhir.model.type.code.ResourceType;\n+\n+/**\n+ * The tests execute the reverse chained behavior in order to exercise reference chains.\n+ */\n+public class SearchReverseChainTest extends FHIRServerTestBase {\n+    private String patient1Id;\n+    private String patient2Id;\n+    private String procedure1Id;\n+    private String procedure2Id;\n+    private String organization1Id;\n+    private String organization2Id;\n+    private String encounter1Id;\n+    private String encounter2Id;\n+    private String endpointId;\n+    private String locationId;\n+    private Instant now = Instant.now();\n+    private String tag = Long.toString(now.toEpochMilli());\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testCreateEndpoint() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+       // Build a new Endpoint.\n+        Endpoint endpoint = TestUtil.getMinimalResource(ResourceType.ENDPOINT, Format.JSON);\n+        endpoint = endpoint.toBuilder().name(of(tag)).build();\n+\n+        // Call the 'create' API.\n+        Entity<Endpoint> entity = Entity.entity(endpoint, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Endpoint\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the endpoint's logical id value.\n+        endpointId = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new Endpoint and verify it.\n+        response = target.path(\"Endpoint/\" + endpointId).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEndpoint\"})\n+    public void testCreateOrganization1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Organization.\n+        Organization organization = TestUtil.getMinimalResource(ResourceType.ORGANIZATION, Format.JSON);\n+        organization = organization.toBuilder()\n+                .name(of(tag))\n+                .endpoint(Reference.builder().reference(of(\"Endpoint/\" + endpointId)).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Organization> entity = Entity.entity(organization, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Organization\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the organization's logical id value.\n+        organization1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new organization and verify it.\n+        response = target.path(\"Organization/\" + organization1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEndpoint\"})\n+    public void testCreateOrganization2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+       // Build a new Organization.\n+        Organization organization = TestUtil.getMinimalResource(ResourceType.ORGANIZATION, Format.JSON);\n+        organization = organization.toBuilder()\n+                .name(of(tag))\n+                .endpoint(Reference.builder().reference(of(\"Endpoint/\" + endpointId)).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Organization> entity = Entity.entity(organization, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Organization\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the organization's logical id value.\n+        organization2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new organization and verify it.\n+        response = target.path(\"Organization/\" + organization2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateOrganization1\"})\n+    public void testCreatePatient1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Patient and then call the 'create' API.\n+        Patient patient = TestUtil.getMinimalResource(ResourceType.PATIENT, Format.JSON);\n+        patient = patient.toBuilder()\n+                .gender(AdministrativeGender.MALE)\n+                .name(HumanName.builder()\n+                    .given(of(\"1\" + tag))\n+                    .build())\n+                .meta(Meta.builder()\n+                    .tag(Coding.builder()\n+                        .code(Code.of(tag))\n+                        .build())\n+                    .build())\n+                .generalPractitioner(Reference.builder().reference(of(\"PractitionerRole/\" + tag)).build())\n+                .managingOrganization(Reference.builder().reference(of(\"Organization/\" + organization1Id)).build())\n+                .birthDate(Date.of(now.toString().substring(0,10)))\n+                .telecom(ContactPoint.builder().system(ContactPointSystem.PHONE).value(of(\"1\" + tag)).build())\n+               .build();\n+\n+        Entity<Patient> entity = Entity.entity(patient, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Patient\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the patient's logical id value.\n+        patient1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new patient and verify it.\n+        response = target.path(\"Patient/\" + patient1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreatePatient1\", \"testCreateOrganization2\"})\n+    public void testCreatePatient2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Patient and then call the 'create' API.\n+        Patient patient = TestUtil.getMinimalResource(ResourceType.PATIENT, Format.JSON);\n+        patient = patient.toBuilder()\n+                .gender(AdministrativeGender.FEMALE)\n+                .name(HumanName.builder()\n+                    .given(of(\"2\" + tag))\n+                    .build())\n+                .meta(Meta.builder()\n+                    .tag(Coding.builder()\n+                        .code(Code.of(tag))\n+                        .build())\n+                    .build())\n+                .generalPractitioner(Reference.builder().reference(of(\"Practitioner/\" + tag)).build())\n+                .managingOrganization(Reference.builder().reference(of(\"Organization/\" + organization2Id)).build())\n+                .birthDate(Date.of(now.minus(1, ChronoUnit.DAYS).toString().substring(0,10)))\n+                .telecom(ContactPoint.builder().system(ContactPointSystem.PHONE).value(of(\"2\" + tag)).build())\n+                .build();\n+\n+        Entity<Patient> entity = Entity.entity(patient, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Patient\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the patient's logical id value.\n+        patient2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new patient and verify it.\n+        response = target.path(\"Patient/\" + patient2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreatePatient1\"})\n+    public void testCreateProcedure1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Procedure and add subject reference to patient.\n+        Procedure procedure = TestUtil.getMinimalResource(ResourceType.PROCEDURE, Format.JSON);\n+        procedure = procedure.toBuilder()\n+                .status(ProcedureStatus.COMPLETED)\n+                .subject(Reference.builder().reference(of(\"Patient/\" + patient1Id)).build())\n+                .basedOn(Reference.builder().reference(of(\"CarePlan/\" + tag)).build())\n+                .performed(DateTime.of(now.toString()))\n+                .instantiatesUri(Uri.of(\"1\" + tag))\n+                .code(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"1\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Procedure> entity = Entity.entity(procedure, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Procedure\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the procedure's logical id value.\n+        procedure1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new procedure and verify it.\n+        response = target.path(\"Procedure/\" + procedure1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreatePatient2\"})\n+    public void testCreateProcedure2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        Reference reference = Reference.builder().reference(of(\"Patient/\" + patient2Id)).build();\n+\n+        // Build a new Procedure and add subject reference to patient.\n+        Procedure procedure = TestUtil.getMinimalResource(ResourceType.PROCEDURE, Format.JSON);\n+        procedure = procedure.toBuilder()\n+                .status(ProcedureStatus.COMPLETED)\n+                .subject(reference)\n+                .basedOn(Reference.builder().reference(of(\"ServiceRequest/\" + tag)).build())\n+                .performed(DateTime.of(now.minus(1, ChronoUnit.DAYS).toString()))\n+                .instantiatesUri(Uri.of(\"2\" + tag))\n+                .code(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"2\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Procedure> entity = Entity.entity(procedure, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Procedure\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the procedure's logical id value.\n+        procedure2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new procedure and verify it.\n+        response = target.path(\"Procedure/\" + procedure2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure1\", \"testCreateOrganization1\"})\n+    public void testCreateEncounter1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Encounter and add reason-reference reference to procedure.\n+        Encounter encounter = TestUtil.getMinimalResource(ResourceType.ENCOUNTER, Format.JSON);\n+        encounter = encounter.toBuilder()\n+                .status(EncounterStatus.FINISHED)\n+                .reasonReference(Reference.builder().reference(of(\"Procedure/\" + procedure1Id)).build())\n+                .serviceProvider(Reference.builder().reference(of(\"Organization/\" + organization1Id)).build())\n+                .period(Period.builder().start(DateTime.of(now.toString())).end(DateTime.of(now.toString())).build())\n+                .length(Duration.builder().system(Uri.of(\"http://unitsofmeasure.org\")).code(Code.of(\"s\")).value(Decimal.of(\"1\" + tag)).build())\n+                .type(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"1\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Encounter> entity = Entity.entity(encounter, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Encounter\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the encounter's logical id value.\n+        encounter1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new encounter and verify it.\n+        response = target.path(\"Encounter/\" + encounter1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure2\", \"testCreateOrganization2\"})\n+    public void testCreateEncounter2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Encounter and add reason-reference reference to procedure.\n+        Encounter encounter = TestUtil.getMinimalResource(ResourceType.ENCOUNTER, Format.JSON);\n+        encounter = encounter.toBuilder()\n+                .status(EncounterStatus.FINISHED)\n+                .reasonReference(Reference.builder().reference(of(\"Procedure/\" + procedure2Id)).build())\n+                .serviceProvider(Reference.builder().reference(of(\"Organization/\" + organization2Id)).build())\n+                .period(Period.builder().start(DateTime.of(now.minus(1, ChronoUnit.DAYS).toString())).end(DateTime.of(now.minus(1, ChronoUnit.DAYS).toString())).build())\n+                .length(Duration.builder().system(Uri.of(\"http://unitsofmeasure.org\")).code(Code.of(\"s\")).value(Decimal.of(\"2\" + tag)).build())\n+                .type(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"2\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Encounter> entity = Entity.entity(encounter, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Encounter\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the encounter's logical id value.\n+        encounter2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new encounter and verify it.\n+        response = target.path(\"Encounter/\" + encounter2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateOrganization1\"})\n+    public void testCreateLocation() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        Location location = TestUtil.readExampleResource(\"json/spec/location-example.json\");\n+        location = location.toBuilder()\n+                .managingOrganization(Reference.builder().reference(of(\"Organization/\" + organization1Id)).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Location> entity = Entity.entity(location, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Location\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the location's logical id value.\n+        locationId = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new Location and verify it.\n+        response   = target.path(\"Location/\" + locationId).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @AfterClass\n+    public void testDeleteResources() {\n+        WebTarget target = getWebTarget();\n+        if (patient1Id != null) {\n+            Response response   = target.path(\"Patient/\" + patient1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (patient2Id != null) {\n+            Response response   = target.path(\"Patient/\" + patient2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (procedure1Id != null) {\n+            Response response   = target.path(\"Procedure/\" + procedure1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (procedure2Id != null) {\n+            Response response   = target.path(\"Procedure/\" + procedure2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (organization1Id != null) {\n+            Response response   = target.path(\"Organization/\" + organization1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (organization2Id != null) {\n+            Response response   = target.path(\"Organization/\" + organization2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (encounter1Id != null) {\n+            Response response   = target.path(\"Encounter/\" + encounter1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (encounter2Id != null) {\n+            Response response   = target.path(\"Encounter/\" + encounter2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (endpointId != null) {\n+            Response response   = target.path(\"Endpoint/\" + endpointId).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (locationId != null) {\n+            Response response   = target.path(\"Location/\" + locationId).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithTypeError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"\")\n+                .queryParam(\"_type\", \"Patient\")\n+                .queryParam(\"_has:Procedure:subject:status\", ProcedureStatus.COMPLETED.getValue())\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"system search not supported with _has\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithParseError1() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"An incorrect number of components were specified for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithParseError2() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"An incorrect number of components were specified for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithParseError3() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:extra:_has:Encounter:reason-reference:status\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"An incorrect number of components were specified for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithResourceTypeNotValidError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:BadType:subject:code\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Resource type 'BadType' is not valid for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmNotFoundError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:badSearchParm:code\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter 'badSearchParm' for resource type 'Procedure' was not found.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmNotFoundError2() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:badSearchParm\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter 'badSearchParm' for resource type 'Procedure' was not found.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmNotReferenceError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:code:code\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter 'code' is not of type reference for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmTargetTypeNotValidError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:encounter:code\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter 'encounter' target types do not include expected type 'Patient' for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmUndefinedModifierError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:code:badModifier\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Undefined Modifier: badModifier\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmUnsupportedModifierError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:code:contains\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Unsupported type/modifier combination: token/contains\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmIsResultParmError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:_total\", \"1\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter '_total' for resource type 'Procedure' was not found.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithChainedSearchParmBadModifierError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:encounter:contains.status\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Modifier: 'CONTAINS' not allowed on chained parameter\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithChainedSearchParmNotReferenceError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:code.status\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Type: 'TOKEN' not allowed on chained parameter\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "originalPosition": 571}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzk3MDEz", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-523397013", "createdAt": "2020-11-04T14:12:23Z", "commit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDoxMjoyM1rOHtZ2Jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDoxMjoyM1rOHtZ2Jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM3MTQzMA==", "bodyText": "I've seen this a couple of times.\n1 - assertEquals is probably preferred when doing the equals (that way you can see what the size value is\n2 - If the delete fails for any reason, it leaves dirty data, so we typically do >= 1\nIf the delete fails, does it impact this test in any way?", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517371430", "createdAt": "2020-11-04T14:12:23Z", "author": {"login": "prb112"}, "path": "fhir-server-test/src/test/java/com/ibm/fhir/server/test/SearchReverseChainTest.java", "diffHunk": "@@ -0,0 +1,1034 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.server.test;\n+\n+import static com.ibm.fhir.model.type.String.of;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.ws.rs.client.Entity;\n+import javax.ws.rs.client.WebTarget;\n+import javax.ws.rs.core.Response;\n+\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.Test;\n+\n+import com.ibm.fhir.core.FHIRMediaType;\n+import com.ibm.fhir.model.format.Format;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Encounter;\n+import com.ibm.fhir.model.resource.Endpoint;\n+import com.ibm.fhir.model.resource.Location;\n+import com.ibm.fhir.model.resource.OperationOutcome;\n+import com.ibm.fhir.model.resource.Organization;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Procedure;\n+import com.ibm.fhir.model.test.TestUtil;\n+import com.ibm.fhir.model.type.Code;\n+import com.ibm.fhir.model.type.CodeableConcept;\n+import com.ibm.fhir.model.type.Coding;\n+import com.ibm.fhir.model.type.ContactPoint;\n+import com.ibm.fhir.model.type.Date;\n+import com.ibm.fhir.model.type.DateTime;\n+import com.ibm.fhir.model.type.Decimal;\n+import com.ibm.fhir.model.type.Duration;\n+import com.ibm.fhir.model.type.HumanName;\n+import com.ibm.fhir.model.type.Meta;\n+import com.ibm.fhir.model.type.Period;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.Uri;\n+import com.ibm.fhir.model.type.code.AdministrativeGender;\n+import com.ibm.fhir.model.type.code.ContactPointSystem;\n+import com.ibm.fhir.model.type.code.EncounterStatus;\n+import com.ibm.fhir.model.type.code.ProcedureStatus;\n+import com.ibm.fhir.model.type.code.ResourceType;\n+\n+/**\n+ * The tests execute the reverse chained behavior in order to exercise reference chains.\n+ */\n+public class SearchReverseChainTest extends FHIRServerTestBase {\n+    private String patient1Id;\n+    private String patient2Id;\n+    private String procedure1Id;\n+    private String procedure2Id;\n+    private String organization1Id;\n+    private String organization2Id;\n+    private String encounter1Id;\n+    private String encounter2Id;\n+    private String endpointId;\n+    private String locationId;\n+    private Instant now = Instant.now();\n+    private String tag = Long.toString(now.toEpochMilli());\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testCreateEndpoint() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+       // Build a new Endpoint.\n+        Endpoint endpoint = TestUtil.getMinimalResource(ResourceType.ENDPOINT, Format.JSON);\n+        endpoint = endpoint.toBuilder().name(of(tag)).build();\n+\n+        // Call the 'create' API.\n+        Entity<Endpoint> entity = Entity.entity(endpoint, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Endpoint\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the endpoint's logical id value.\n+        endpointId = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new Endpoint and verify it.\n+        response = target.path(\"Endpoint/\" + endpointId).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEndpoint\"})\n+    public void testCreateOrganization1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Organization.\n+        Organization organization = TestUtil.getMinimalResource(ResourceType.ORGANIZATION, Format.JSON);\n+        organization = organization.toBuilder()\n+                .name(of(tag))\n+                .endpoint(Reference.builder().reference(of(\"Endpoint/\" + endpointId)).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Organization> entity = Entity.entity(organization, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Organization\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the organization's logical id value.\n+        organization1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new organization and verify it.\n+        response = target.path(\"Organization/\" + organization1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEndpoint\"})\n+    public void testCreateOrganization2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+       // Build a new Organization.\n+        Organization organization = TestUtil.getMinimalResource(ResourceType.ORGANIZATION, Format.JSON);\n+        organization = organization.toBuilder()\n+                .name(of(tag))\n+                .endpoint(Reference.builder().reference(of(\"Endpoint/\" + endpointId)).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Organization> entity = Entity.entity(organization, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Organization\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the organization's logical id value.\n+        organization2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new organization and verify it.\n+        response = target.path(\"Organization/\" + organization2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateOrganization1\"})\n+    public void testCreatePatient1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Patient and then call the 'create' API.\n+        Patient patient = TestUtil.getMinimalResource(ResourceType.PATIENT, Format.JSON);\n+        patient = patient.toBuilder()\n+                .gender(AdministrativeGender.MALE)\n+                .name(HumanName.builder()\n+                    .given(of(\"1\" + tag))\n+                    .build())\n+                .meta(Meta.builder()\n+                    .tag(Coding.builder()\n+                        .code(Code.of(tag))\n+                        .build())\n+                    .build())\n+                .generalPractitioner(Reference.builder().reference(of(\"PractitionerRole/\" + tag)).build())\n+                .managingOrganization(Reference.builder().reference(of(\"Organization/\" + organization1Id)).build())\n+                .birthDate(Date.of(now.toString().substring(0,10)))\n+                .telecom(ContactPoint.builder().system(ContactPointSystem.PHONE).value(of(\"1\" + tag)).build())\n+               .build();\n+\n+        Entity<Patient> entity = Entity.entity(patient, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Patient\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the patient's logical id value.\n+        patient1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new patient and verify it.\n+        response = target.path(\"Patient/\" + patient1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreatePatient1\", \"testCreateOrganization2\"})\n+    public void testCreatePatient2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Patient and then call the 'create' API.\n+        Patient patient = TestUtil.getMinimalResource(ResourceType.PATIENT, Format.JSON);\n+        patient = patient.toBuilder()\n+                .gender(AdministrativeGender.FEMALE)\n+                .name(HumanName.builder()\n+                    .given(of(\"2\" + tag))\n+                    .build())\n+                .meta(Meta.builder()\n+                    .tag(Coding.builder()\n+                        .code(Code.of(tag))\n+                        .build())\n+                    .build())\n+                .generalPractitioner(Reference.builder().reference(of(\"Practitioner/\" + tag)).build())\n+                .managingOrganization(Reference.builder().reference(of(\"Organization/\" + organization2Id)).build())\n+                .birthDate(Date.of(now.minus(1, ChronoUnit.DAYS).toString().substring(0,10)))\n+                .telecom(ContactPoint.builder().system(ContactPointSystem.PHONE).value(of(\"2\" + tag)).build())\n+                .build();\n+\n+        Entity<Patient> entity = Entity.entity(patient, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Patient\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the patient's logical id value.\n+        patient2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new patient and verify it.\n+        response = target.path(\"Patient/\" + patient2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreatePatient1\"})\n+    public void testCreateProcedure1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Procedure and add subject reference to patient.\n+        Procedure procedure = TestUtil.getMinimalResource(ResourceType.PROCEDURE, Format.JSON);\n+        procedure = procedure.toBuilder()\n+                .status(ProcedureStatus.COMPLETED)\n+                .subject(Reference.builder().reference(of(\"Patient/\" + patient1Id)).build())\n+                .basedOn(Reference.builder().reference(of(\"CarePlan/\" + tag)).build())\n+                .performed(DateTime.of(now.toString()))\n+                .instantiatesUri(Uri.of(\"1\" + tag))\n+                .code(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"1\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Procedure> entity = Entity.entity(procedure, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Procedure\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the procedure's logical id value.\n+        procedure1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new procedure and verify it.\n+        response = target.path(\"Procedure/\" + procedure1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreatePatient2\"})\n+    public void testCreateProcedure2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        Reference reference = Reference.builder().reference(of(\"Patient/\" + patient2Id)).build();\n+\n+        // Build a new Procedure and add subject reference to patient.\n+        Procedure procedure = TestUtil.getMinimalResource(ResourceType.PROCEDURE, Format.JSON);\n+        procedure = procedure.toBuilder()\n+                .status(ProcedureStatus.COMPLETED)\n+                .subject(reference)\n+                .basedOn(Reference.builder().reference(of(\"ServiceRequest/\" + tag)).build())\n+                .performed(DateTime.of(now.minus(1, ChronoUnit.DAYS).toString()))\n+                .instantiatesUri(Uri.of(\"2\" + tag))\n+                .code(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"2\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Procedure> entity = Entity.entity(procedure, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Procedure\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the procedure's logical id value.\n+        procedure2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new procedure and verify it.\n+        response = target.path(\"Procedure/\" + procedure2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure1\", \"testCreateOrganization1\"})\n+    public void testCreateEncounter1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Encounter and add reason-reference reference to procedure.\n+        Encounter encounter = TestUtil.getMinimalResource(ResourceType.ENCOUNTER, Format.JSON);\n+        encounter = encounter.toBuilder()\n+                .status(EncounterStatus.FINISHED)\n+                .reasonReference(Reference.builder().reference(of(\"Procedure/\" + procedure1Id)).build())\n+                .serviceProvider(Reference.builder().reference(of(\"Organization/\" + organization1Id)).build())\n+                .period(Period.builder().start(DateTime.of(now.toString())).end(DateTime.of(now.toString())).build())\n+                .length(Duration.builder().system(Uri.of(\"http://unitsofmeasure.org\")).code(Code.of(\"s\")).value(Decimal.of(\"1\" + tag)).build())\n+                .type(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"1\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Encounter> entity = Entity.entity(encounter, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Encounter\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the encounter's logical id value.\n+        encounter1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new encounter and verify it.\n+        response = target.path(\"Encounter/\" + encounter1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure2\", \"testCreateOrganization2\"})\n+    public void testCreateEncounter2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Encounter and add reason-reference reference to procedure.\n+        Encounter encounter = TestUtil.getMinimalResource(ResourceType.ENCOUNTER, Format.JSON);\n+        encounter = encounter.toBuilder()\n+                .status(EncounterStatus.FINISHED)\n+                .reasonReference(Reference.builder().reference(of(\"Procedure/\" + procedure2Id)).build())\n+                .serviceProvider(Reference.builder().reference(of(\"Organization/\" + organization2Id)).build())\n+                .period(Period.builder().start(DateTime.of(now.minus(1, ChronoUnit.DAYS).toString())).end(DateTime.of(now.minus(1, ChronoUnit.DAYS).toString())).build())\n+                .length(Duration.builder().system(Uri.of(\"http://unitsofmeasure.org\")).code(Code.of(\"s\")).value(Decimal.of(\"2\" + tag)).build())\n+                .type(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"2\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Encounter> entity = Entity.entity(encounter, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Encounter\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the encounter's logical id value.\n+        encounter2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new encounter and verify it.\n+        response = target.path(\"Encounter/\" + encounter2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateOrganization1\"})\n+    public void testCreateLocation() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        Location location = TestUtil.readExampleResource(\"json/spec/location-example.json\");\n+        location = location.toBuilder()\n+                .managingOrganization(Reference.builder().reference(of(\"Organization/\" + organization1Id)).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Location> entity = Entity.entity(location, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Location\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the location's logical id value.\n+        locationId = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new Location and verify it.\n+        response   = target.path(\"Location/\" + locationId).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @AfterClass\n+    public void testDeleteResources() {\n+        WebTarget target = getWebTarget();\n+        if (patient1Id != null) {\n+            Response response   = target.path(\"Patient/\" + patient1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (patient2Id != null) {\n+            Response response   = target.path(\"Patient/\" + patient2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (procedure1Id != null) {\n+            Response response   = target.path(\"Procedure/\" + procedure1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (procedure2Id != null) {\n+            Response response   = target.path(\"Procedure/\" + procedure2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (organization1Id != null) {\n+            Response response   = target.path(\"Organization/\" + organization1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (organization2Id != null) {\n+            Response response   = target.path(\"Organization/\" + organization2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (encounter1Id != null) {\n+            Response response   = target.path(\"Encounter/\" + encounter1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (encounter2Id != null) {\n+            Response response   = target.path(\"Encounter/\" + encounter2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (endpointId != null) {\n+            Response response   = target.path(\"Endpoint/\" + endpointId).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (locationId != null) {\n+            Response response   = target.path(\"Location/\" + locationId).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithTypeError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"\")\n+                .queryParam(\"_type\", \"Patient\")\n+                .queryParam(\"_has:Procedure:subject:status\", ProcedureStatus.COMPLETED.getValue())\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"system search not supported with _has\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithParseError1() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"An incorrect number of components were specified for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithParseError2() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"An incorrect number of components were specified for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithParseError3() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:extra:_has:Encounter:reason-reference:status\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"An incorrect number of components were specified for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithResourceTypeNotValidError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:BadType:subject:code\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Resource type 'BadType' is not valid for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmNotFoundError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:badSearchParm:code\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter 'badSearchParm' for resource type 'Procedure' was not found.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmNotFoundError2() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:badSearchParm\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter 'badSearchParm' for resource type 'Procedure' was not found.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmNotReferenceError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:code:code\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter 'code' is not of type reference for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmTargetTypeNotValidError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:encounter:code\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter 'encounter' target types do not include expected type 'Patient' for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmUndefinedModifierError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:code:badModifier\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Undefined Modifier: badModifier\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmUnsupportedModifierError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:code:contains\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Unsupported type/modifier combination: token/contains\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmIsResultParmError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:_total\", \"1\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter '_total' for resource type 'Procedure' was not found.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithChainedSearchParmBadModifierError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:encounter:contains.status\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Modifier: 'CONTAINS' not allowed on chained parameter\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithChainedSearchParmNotReferenceError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:code.status\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Type: 'TOKEN' not allowed on chained parameter\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithChainedSearchParmResourceTypeNotValidError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:part-of:Condition.status\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Modifier resource type [Condition] is not allowed for search parameter [part-of] of resource type [Procedure].\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithChainedSearchParmResourceTypeNotSpecifiedError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:part-of.status\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter: 'part-of' must have resource type name modifier\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure1\", \"testCreateProcedure2\"})\n+    public void testSearchSingleReverseChainMultipleResults() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_tag\", tag)\n+                .queryParam(\"_has:Procedure:subject:status\", ProcedureStatus.COMPLETED.getValue())\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 2);\n+        List<String> resourceIds = new ArrayList<>();\n+        for (Bundle.Entry entry : bundle.getEntry()) {\n+            resourceIds.add(entry.getResource().getId());\n+        }\n+        assertTrue(resourceIds.contains(patient1Id));\n+        assertTrue(resourceIds.contains(patient2Id));\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure1\", \"testCreateProcedure2\"})\n+    public void testSearchSingleReverseChainSingleResult() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_tag\", tag)\n+                .queryParam(\"_has:Procedure:subject:_id\", procedure1Id)\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 1);\n+        assertEquals(patient1Id, bundle.getEntry().get(0).getResource().getId());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEncounter1\", \"testCreateEncounter2\"})\n+    public void testSearchMultipleReverseChainMultipleResults() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_tag\", tag)\n+                .queryParam(\"_has:Procedure:subject:_has:Encounter:reason-reference:status\", EncounterStatus.FINISHED.getValue())\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 2);\n+        List<String> resourceIds = new ArrayList<>();\n+        for (Bundle.Entry entry : bundle.getEntry()) {\n+            resourceIds.add(entry.getResource().getId());\n+        }\n+        assertTrue(resourceIds.contains(patient1Id));\n+        assertTrue(resourceIds.contains(patient2Id));\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEncounter1\", \"testCreateEncounter2\"})\n+    public void testSearchMultipleReverseChainSingleResult() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_tag\", tag)\n+                .queryParam(\"_has:Procedure:subject:_has:Encounter:reason-reference:_id\", encounter2Id)\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 1);\n+        assertEquals(patient2Id, bundle.getEntry().get(0).getResource().getId());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEncounter1\", \"testCreateEncounter2\"})\n+    public void testSearchMultipleReverseChainORSearch() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_tag\", tag)\n+                .queryParam(\"_has:Procedure:subject:_has:Encounter:reason-reference:_id\", encounter1Id + \",\" + encounter2Id)\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 2);\n+        List<String> resourceIds = new ArrayList<>();\n+        for (Bundle.Entry entry : bundle.getEntry()) {\n+            resourceIds.add(entry.getResource().getId());\n+        }\n+        assertTrue(resourceIds.contains(patient1Id));\n+        assertTrue(resourceIds.contains(patient2Id));\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEncounter1\", \"testCreateEncounter2\"})\n+    public void testSearchMultipleReverseChainANDSearch() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_tag\", tag)\n+                .queryParam(\"_has:Procedure:subject:_has:Encounter:reason-reference:_id\", encounter1Id, encounter2Id)\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 0);\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEncounter1\", \"testCreateEncounter2\"})\n+    public void testSearchMultipleReverseChainWithChainedSearchParm() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_tag\", tag)\n+                .queryParam(\"_has:Procedure:subject:_has:Encounter:reason-reference:service-provider.name\", tag)\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 2);\n+        List<String> resourceIds = new ArrayList<>();\n+        for (Bundle.Entry entry : bundle.getEntry()) {\n+            resourceIds.add(entry.getResource().getId());\n+        }\n+        assertTrue(resourceIds.contains(patient1Id));\n+        assertTrue(resourceIds.contains(patient2Id));\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEncounter1\", \"testCreateEncounter2\"})\n+    public void testSearchMultipleReverseChainWithChainedSearchParmOfId() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_tag\", tag)\n+                .queryParam(\"_has:Procedure:subject:_has:Encounter:reason-reference:service-provider._id\", organization1Id)\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 1);\n+        assertEquals(patient1Id, bundle.getEntry().get(0).getResource().getId());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEncounter1\", \"testCreateEncounter2\"})\n+    public void testSearchMultipleReverseChainWithMultipleChainedSearchParm() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_tag\", tag)\n+                .queryParam(\"_has:Procedure:subject:_has:Encounter:reason-reference:service-provider.endpoint.name\", tag)\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 2);\n+        List<String> resourceIds = new ArrayList<>();\n+        for (Bundle.Entry entry : bundle.getEntry()) {\n+            resourceIds.add(entry.getResource().getId());\n+        }\n+        assertTrue(resourceIds.contains(patient1Id));\n+        assertTrue(resourceIds.contains(patient2Id));\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure1\", \"testCreateProcedure2\"})\n+    public void testSearchSingleReverseChainWithStringParm() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"given\", \"1\" + tag)\n+                .queryParam(\"_has:Procedure:subject:status\", ProcedureStatus.COMPLETED.getValue())\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "originalPosition": 790}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzk3OTgx", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-523397981", "createdAt": "2020-11-04T14:13:23Z", "commit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDoxMzoyM1rOHtZ46Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDoxMzoyM1rOHtZ46Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM3MjEzNw==", "bodyText": "even if this fails, let's have a multiple _has test and capture the failure.\nAlso probably should update conformance to state if multiple has is supported or not.", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r517372137", "createdAt": "2020-11-04T14:13:23Z", "author": {"login": "prb112"}, "path": "fhir-server-test/src/test/java/com/ibm/fhir/server/test/SearchReverseChainTest.java", "diffHunk": "@@ -0,0 +1,1034 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.server.test;\n+\n+import static com.ibm.fhir.model.type.String.of;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.ws.rs.client.Entity;\n+import javax.ws.rs.client.WebTarget;\n+import javax.ws.rs.core.Response;\n+\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.Test;\n+\n+import com.ibm.fhir.core.FHIRMediaType;\n+import com.ibm.fhir.model.format.Format;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Encounter;\n+import com.ibm.fhir.model.resource.Endpoint;\n+import com.ibm.fhir.model.resource.Location;\n+import com.ibm.fhir.model.resource.OperationOutcome;\n+import com.ibm.fhir.model.resource.Organization;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Procedure;\n+import com.ibm.fhir.model.test.TestUtil;\n+import com.ibm.fhir.model.type.Code;\n+import com.ibm.fhir.model.type.CodeableConcept;\n+import com.ibm.fhir.model.type.Coding;\n+import com.ibm.fhir.model.type.ContactPoint;\n+import com.ibm.fhir.model.type.Date;\n+import com.ibm.fhir.model.type.DateTime;\n+import com.ibm.fhir.model.type.Decimal;\n+import com.ibm.fhir.model.type.Duration;\n+import com.ibm.fhir.model.type.HumanName;\n+import com.ibm.fhir.model.type.Meta;\n+import com.ibm.fhir.model.type.Period;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.Uri;\n+import com.ibm.fhir.model.type.code.AdministrativeGender;\n+import com.ibm.fhir.model.type.code.ContactPointSystem;\n+import com.ibm.fhir.model.type.code.EncounterStatus;\n+import com.ibm.fhir.model.type.code.ProcedureStatus;\n+import com.ibm.fhir.model.type.code.ResourceType;\n+\n+/**\n+ * The tests execute the reverse chained behavior in order to exercise reference chains.\n+ */\n+public class SearchReverseChainTest extends FHIRServerTestBase {\n+    private String patient1Id;\n+    private String patient2Id;\n+    private String procedure1Id;\n+    private String procedure2Id;\n+    private String organization1Id;\n+    private String organization2Id;\n+    private String encounter1Id;\n+    private String encounter2Id;\n+    private String endpointId;\n+    private String locationId;\n+    private Instant now = Instant.now();\n+    private String tag = Long.toString(now.toEpochMilli());\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testCreateEndpoint() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+       // Build a new Endpoint.\n+        Endpoint endpoint = TestUtil.getMinimalResource(ResourceType.ENDPOINT, Format.JSON);\n+        endpoint = endpoint.toBuilder().name(of(tag)).build();\n+\n+        // Call the 'create' API.\n+        Entity<Endpoint> entity = Entity.entity(endpoint, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Endpoint\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the endpoint's logical id value.\n+        endpointId = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new Endpoint and verify it.\n+        response = target.path(\"Endpoint/\" + endpointId).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEndpoint\"})\n+    public void testCreateOrganization1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Organization.\n+        Organization organization = TestUtil.getMinimalResource(ResourceType.ORGANIZATION, Format.JSON);\n+        organization = organization.toBuilder()\n+                .name(of(tag))\n+                .endpoint(Reference.builder().reference(of(\"Endpoint/\" + endpointId)).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Organization> entity = Entity.entity(organization, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Organization\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the organization's logical id value.\n+        organization1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new organization and verify it.\n+        response = target.path(\"Organization/\" + organization1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEndpoint\"})\n+    public void testCreateOrganization2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+       // Build a new Organization.\n+        Organization organization = TestUtil.getMinimalResource(ResourceType.ORGANIZATION, Format.JSON);\n+        organization = organization.toBuilder()\n+                .name(of(tag))\n+                .endpoint(Reference.builder().reference(of(\"Endpoint/\" + endpointId)).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Organization> entity = Entity.entity(organization, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Organization\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the organization's logical id value.\n+        organization2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new organization and verify it.\n+        response = target.path(\"Organization/\" + organization2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateOrganization1\"})\n+    public void testCreatePatient1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Patient and then call the 'create' API.\n+        Patient patient = TestUtil.getMinimalResource(ResourceType.PATIENT, Format.JSON);\n+        patient = patient.toBuilder()\n+                .gender(AdministrativeGender.MALE)\n+                .name(HumanName.builder()\n+                    .given(of(\"1\" + tag))\n+                    .build())\n+                .meta(Meta.builder()\n+                    .tag(Coding.builder()\n+                        .code(Code.of(tag))\n+                        .build())\n+                    .build())\n+                .generalPractitioner(Reference.builder().reference(of(\"PractitionerRole/\" + tag)).build())\n+                .managingOrganization(Reference.builder().reference(of(\"Organization/\" + organization1Id)).build())\n+                .birthDate(Date.of(now.toString().substring(0,10)))\n+                .telecom(ContactPoint.builder().system(ContactPointSystem.PHONE).value(of(\"1\" + tag)).build())\n+               .build();\n+\n+        Entity<Patient> entity = Entity.entity(patient, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Patient\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the patient's logical id value.\n+        patient1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new patient and verify it.\n+        response = target.path(\"Patient/\" + patient1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreatePatient1\", \"testCreateOrganization2\"})\n+    public void testCreatePatient2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Patient and then call the 'create' API.\n+        Patient patient = TestUtil.getMinimalResource(ResourceType.PATIENT, Format.JSON);\n+        patient = patient.toBuilder()\n+                .gender(AdministrativeGender.FEMALE)\n+                .name(HumanName.builder()\n+                    .given(of(\"2\" + tag))\n+                    .build())\n+                .meta(Meta.builder()\n+                    .tag(Coding.builder()\n+                        .code(Code.of(tag))\n+                        .build())\n+                    .build())\n+                .generalPractitioner(Reference.builder().reference(of(\"Practitioner/\" + tag)).build())\n+                .managingOrganization(Reference.builder().reference(of(\"Organization/\" + organization2Id)).build())\n+                .birthDate(Date.of(now.minus(1, ChronoUnit.DAYS).toString().substring(0,10)))\n+                .telecom(ContactPoint.builder().system(ContactPointSystem.PHONE).value(of(\"2\" + tag)).build())\n+                .build();\n+\n+        Entity<Patient> entity = Entity.entity(patient, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Patient\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the patient's logical id value.\n+        patient2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new patient and verify it.\n+        response = target.path(\"Patient/\" + patient2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreatePatient1\"})\n+    public void testCreateProcedure1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Procedure and add subject reference to patient.\n+        Procedure procedure = TestUtil.getMinimalResource(ResourceType.PROCEDURE, Format.JSON);\n+        procedure = procedure.toBuilder()\n+                .status(ProcedureStatus.COMPLETED)\n+                .subject(Reference.builder().reference(of(\"Patient/\" + patient1Id)).build())\n+                .basedOn(Reference.builder().reference(of(\"CarePlan/\" + tag)).build())\n+                .performed(DateTime.of(now.toString()))\n+                .instantiatesUri(Uri.of(\"1\" + tag))\n+                .code(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"1\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Procedure> entity = Entity.entity(procedure, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Procedure\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the procedure's logical id value.\n+        procedure1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new procedure and verify it.\n+        response = target.path(\"Procedure/\" + procedure1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreatePatient2\"})\n+    public void testCreateProcedure2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        Reference reference = Reference.builder().reference(of(\"Patient/\" + patient2Id)).build();\n+\n+        // Build a new Procedure and add subject reference to patient.\n+        Procedure procedure = TestUtil.getMinimalResource(ResourceType.PROCEDURE, Format.JSON);\n+        procedure = procedure.toBuilder()\n+                .status(ProcedureStatus.COMPLETED)\n+                .subject(reference)\n+                .basedOn(Reference.builder().reference(of(\"ServiceRequest/\" + tag)).build())\n+                .performed(DateTime.of(now.minus(1, ChronoUnit.DAYS).toString()))\n+                .instantiatesUri(Uri.of(\"2\" + tag))\n+                .code(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"2\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Procedure> entity = Entity.entity(procedure, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Procedure\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the procedure's logical id value.\n+        procedure2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new procedure and verify it.\n+        response = target.path(\"Procedure/\" + procedure2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure1\", \"testCreateOrganization1\"})\n+    public void testCreateEncounter1() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Encounter and add reason-reference reference to procedure.\n+        Encounter encounter = TestUtil.getMinimalResource(ResourceType.ENCOUNTER, Format.JSON);\n+        encounter = encounter.toBuilder()\n+                .status(EncounterStatus.FINISHED)\n+                .reasonReference(Reference.builder().reference(of(\"Procedure/\" + procedure1Id)).build())\n+                .serviceProvider(Reference.builder().reference(of(\"Organization/\" + organization1Id)).build())\n+                .period(Period.builder().start(DateTime.of(now.toString())).end(DateTime.of(now.toString())).build())\n+                .length(Duration.builder().system(Uri.of(\"http://unitsofmeasure.org\")).code(Code.of(\"s\")).value(Decimal.of(\"1\" + tag)).build())\n+                .type(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"1\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Encounter> entity = Entity.entity(encounter, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Encounter\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the encounter's logical id value.\n+        encounter1Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new encounter and verify it.\n+        response = target.path(\"Encounter/\" + encounter1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure2\", \"testCreateOrganization2\"})\n+    public void testCreateEncounter2() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        // Build a new Encounter and add reason-reference reference to procedure.\n+        Encounter encounter = TestUtil.getMinimalResource(ResourceType.ENCOUNTER, Format.JSON);\n+        encounter = encounter.toBuilder()\n+                .status(EncounterStatus.FINISHED)\n+                .reasonReference(Reference.builder().reference(of(\"Procedure/\" + procedure2Id)).build())\n+                .serviceProvider(Reference.builder().reference(of(\"Organization/\" + organization2Id)).build())\n+                .period(Period.builder().start(DateTime.of(now.minus(1, ChronoUnit.DAYS).toString())).end(DateTime.of(now.minus(1, ChronoUnit.DAYS).toString())).build())\n+                .length(Duration.builder().system(Uri.of(\"http://unitsofmeasure.org\")).code(Code.of(\"s\")).value(Decimal.of(\"2\" + tag)).build())\n+                .type(CodeableConcept.builder().coding(Coding.builder().code(Code.of(\"2\" + tag)).build()).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Encounter> entity = Entity.entity(encounter, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Encounter\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the encounter's logical id value.\n+        encounter2Id = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new encounter and verify it.\n+        response = target.path(\"Encounter/\" + encounter2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateOrganization1\"})\n+    public void testCreateLocation() throws Exception {\n+        WebTarget target = getWebTarget();\n+\n+        Location location = TestUtil.readExampleResource(\"json/spec/location-example.json\");\n+        location = location.toBuilder()\n+                .managingOrganization(Reference.builder().reference(of(\"Organization/\" + organization1Id)).build())\n+                .build();\n+\n+        // Call the 'create' API.\n+        Entity<Location> entity = Entity.entity(location, FHIRMediaType.APPLICATION_FHIR_JSON);\n+        Response response = target.path(\"Location\").request().post(entity, Response.class);\n+        assertResponse(response, Response.Status.CREATED.getStatusCode());\n+\n+        // Get the location's logical id value.\n+        locationId = getLocationLogicalId(response);\n+\n+        // Next, call the 'read' API to retrieve the new Location and verify it.\n+        response   = target.path(\"Location/\" + locationId).request(FHIRMediaType.APPLICATION_FHIR_JSON).get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+    }\n+\n+    @AfterClass\n+    public void testDeleteResources() {\n+        WebTarget target = getWebTarget();\n+        if (patient1Id != null) {\n+            Response response   = target.path(\"Patient/\" + patient1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (patient2Id != null) {\n+            Response response   = target.path(\"Patient/\" + patient2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (procedure1Id != null) {\n+            Response response   = target.path(\"Procedure/\" + procedure1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (procedure2Id != null) {\n+            Response response   = target.path(\"Procedure/\" + procedure2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (organization1Id != null) {\n+            Response response   = target.path(\"Organization/\" + organization1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (organization2Id != null) {\n+            Response response   = target.path(\"Organization/\" + organization2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (encounter1Id != null) {\n+            Response response   = target.path(\"Encounter/\" + encounter1Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (encounter2Id != null) {\n+            Response response   = target.path(\"Encounter/\" + encounter2Id).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (endpointId != null) {\n+            Response response   = target.path(\"Endpoint/\" + endpointId).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+        if (locationId != null) {\n+            Response response   = target.path(\"Location/\" + locationId).request(FHIRMediaType.APPLICATION_FHIR_JSON).delete();\n+            assertResponse(response, Response.Status.OK.getStatusCode());\n+        }\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithTypeError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"\")\n+                .queryParam(\"_type\", \"Patient\")\n+                .queryParam(\"_has:Procedure:subject:status\", ProcedureStatus.COMPLETED.getValue())\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"system search not supported with _has\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithParseError1() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"An incorrect number of components were specified for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithParseError2() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"An incorrect number of components were specified for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithParseError3() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:extra:_has:Encounter:reason-reference:status\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"An incorrect number of components were specified for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithResourceTypeNotValidError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:BadType:subject:code\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Resource type 'BadType' is not valid for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmNotFoundError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:badSearchParm:code\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter 'badSearchParm' for resource type 'Procedure' was not found.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmNotFoundError2() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:badSearchParm\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter 'badSearchParm' for resource type 'Procedure' was not found.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmNotReferenceError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:code:code\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter 'code' is not of type reference for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmTargetTypeNotValidError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:encounter:code\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter 'encounter' target types do not include expected type 'Patient' for '_has' (reverse chain) search.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmUndefinedModifierError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:code:badModifier\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Undefined Modifier: badModifier\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmUnsupportedModifierError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:code:contains\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Unsupported type/modifier combination: token/contains\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithSearchParmIsResultParmError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:_total\", \"1\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter '_total' for resource type 'Procedure' was not found.\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithChainedSearchParmBadModifierError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:encounter:contains.status\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Modifier: 'CONTAINS' not allowed on chained parameter\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithChainedSearchParmNotReferenceError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:code.status\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Type: 'TOKEN' not allowed on chained parameter\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithChainedSearchParmResourceTypeNotValidError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:part-of:Condition.status\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Modifier resource type [Condition] is not allowed for search parameter [part-of] of resource type [Procedure].\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" })\n+    public void testSearchReverseChainWithChainedSearchParmResourceTypeNotSpecifiedError() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:part-of.status\", \"test\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.BAD_REQUEST.getStatusCode());\n+        assertExceptionOperationOutcome(response.readEntity(OperationOutcome.class),\n+                \"Search parameter: 'part-of' must have resource type name modifier\");\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure1\", \"testCreateProcedure2\"})\n+    public void testSearchSingleReverseChainMultipleResults() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_tag\", tag)\n+                .queryParam(\"_has:Procedure:subject:status\", ProcedureStatus.COMPLETED.getValue())\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 2);\n+        List<String> resourceIds = new ArrayList<>();\n+        for (Bundle.Entry entry : bundle.getEntry()) {\n+            resourceIds.add(entry.getResource().getId());\n+        }\n+        assertTrue(resourceIds.contains(patient1Id));\n+        assertTrue(resourceIds.contains(patient2Id));\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure1\", \"testCreateProcedure2\"})\n+    public void testSearchSingleReverseChainSingleResult() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_tag\", tag)\n+                .queryParam(\"_has:Procedure:subject:_id\", procedure1Id)\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 1);\n+        assertEquals(patient1Id, bundle.getEntry().get(0).getResource().getId());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEncounter1\", \"testCreateEncounter2\"})\n+    public void testSearchMultipleReverseChainMultipleResults() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_tag\", tag)\n+                .queryParam(\"_has:Procedure:subject:_has:Encounter:reason-reference:status\", EncounterStatus.FINISHED.getValue())\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 2);\n+        List<String> resourceIds = new ArrayList<>();\n+        for (Bundle.Entry entry : bundle.getEntry()) {\n+            resourceIds.add(entry.getResource().getId());\n+        }\n+        assertTrue(resourceIds.contains(patient1Id));\n+        assertTrue(resourceIds.contains(patient2Id));\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEncounter1\", \"testCreateEncounter2\"})\n+    public void testSearchMultipleReverseChainSingleResult() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_tag\", tag)\n+                .queryParam(\"_has:Procedure:subject:_has:Encounter:reason-reference:_id\", encounter2Id)\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 1);\n+        assertEquals(patient2Id, bundle.getEntry().get(0).getResource().getId());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEncounter1\", \"testCreateEncounter2\"})\n+    public void testSearchMultipleReverseChainORSearch() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_tag\", tag)\n+                .queryParam(\"_has:Procedure:subject:_has:Encounter:reason-reference:_id\", encounter1Id + \",\" + encounter2Id)\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 2);\n+        List<String> resourceIds = new ArrayList<>();\n+        for (Bundle.Entry entry : bundle.getEntry()) {\n+            resourceIds.add(entry.getResource().getId());\n+        }\n+        assertTrue(resourceIds.contains(patient1Id));\n+        assertTrue(resourceIds.contains(patient2Id));\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEncounter1\", \"testCreateEncounter2\"})\n+    public void testSearchMultipleReverseChainANDSearch() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_tag\", tag)\n+                .queryParam(\"_has:Procedure:subject:_has:Encounter:reason-reference:_id\", encounter1Id, encounter2Id)\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 0);\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEncounter1\", \"testCreateEncounter2\"})\n+    public void testSearchMultipleReverseChainWithChainedSearchParm() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_tag\", tag)\n+                .queryParam(\"_has:Procedure:subject:_has:Encounter:reason-reference:service-provider.name\", tag)\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 2);\n+        List<String> resourceIds = new ArrayList<>();\n+        for (Bundle.Entry entry : bundle.getEntry()) {\n+            resourceIds.add(entry.getResource().getId());\n+        }\n+        assertTrue(resourceIds.contains(patient1Id));\n+        assertTrue(resourceIds.contains(patient2Id));\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEncounter1\", \"testCreateEncounter2\"})\n+    public void testSearchMultipleReverseChainWithChainedSearchParmOfId() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_tag\", tag)\n+                .queryParam(\"_has:Procedure:subject:_has:Encounter:reason-reference:service-provider._id\", organization1Id)\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 1);\n+        assertEquals(patient1Id, bundle.getEntry().get(0).getResource().getId());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEncounter1\", \"testCreateEncounter2\"})\n+    public void testSearchMultipleReverseChainWithMultipleChainedSearchParm() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_tag\", tag)\n+                .queryParam(\"_has:Procedure:subject:_has:Encounter:reason-reference:service-provider.endpoint.name\", tag)\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 2);\n+        List<String> resourceIds = new ArrayList<>();\n+        for (Bundle.Entry entry : bundle.getEntry()) {\n+            resourceIds.add(entry.getResource().getId());\n+        }\n+        assertTrue(resourceIds.contains(patient1Id));\n+        assertTrue(resourceIds.contains(patient2Id));\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure1\", \"testCreateProcedure2\"})\n+    public void testSearchSingleReverseChainWithStringParm() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"given\", \"1\" + tag)\n+                .queryParam(\"_has:Procedure:subject:status\", ProcedureStatus.COMPLETED.getValue())\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 1);\n+        assertEquals(patient1Id, bundle.getEntry().get(0).getResource().getId());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure1\", \"testCreateProcedure2\"})\n+    public void testSearchSingleReverseChainWithTokenParm() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"telecom\", \"1\" + tag)\n+                .queryParam(\"_has:Procedure:subject:status\", ProcedureStatus.COMPLETED.getValue())\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 1);\n+        assertEquals(patient1Id, bundle.getEntry().get(0).getResource().getId());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure1\", \"testCreateProcedure2\"})\n+    public void testSearchSingleReverseChainWithReferenceParm() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"general-practitioner\", \"Practitioner/\" + tag)\n+                .queryParam(\"_has:Procedure:subject:status\", ProcedureStatus.COMPLETED.getValue())\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 1);\n+        assertEquals(patient2Id, bundle.getEntry().get(0).getResource().getId());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure1\", \"testCreateProcedure2\"})\n+    public void testSearchSingleReverseChainWithDateParm() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_tag\", tag)\n+                .queryParam(\"birthdate\", now.minus(1, ChronoUnit.DAYS).toString().substring(0,10))\n+                .queryParam(\"_has:Procedure:subject:status\", ProcedureStatus.COMPLETED.getValue())\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 1);\n+        assertEquals(patient2Id, bundle.getEntry().get(0).getResource().getId());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure1\", \"testCreateProcedure2\"})\n+    public void testSearchSingleReverseChainWithUriParmLast() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:instantiates-uri\", \"1\" + tag)\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 1);\n+        assertEquals(patient1Id, bundle.getEntry().get(0).getResource().getId());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure1\", \"testCreateProcedure2\"})\n+    public void testSearchSingleReverseChainWithDateTimeParmLast() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:date\", now.minus(1, ChronoUnit.DAYS).toString())\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 1);\n+        assertEquals(patient2Id, bundle.getEntry().get(0).getResource().getId());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure1\", \"testCreateProcedure2\"})\n+    public void testSearchSingleReverseChainWithReferenceParmLast() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:based-on\", \"CarePlan/\" + tag)\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 1);\n+        assertEquals(patient1Id, bundle.getEntry().get(0).getResource().getId());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure1\", \"testCreateProcedure2\"})\n+    public void testSearchSingleReverseChainWithTokenParmLast() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:code\", \"2\" + tag)\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 1);\n+        assertEquals(patient2Id, bundle.getEntry().get(0).getResource().getId());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEncounter1\", \"testCreateEncounter2\"})\n+    public void testSearchMultipleReverseChainWithTokenParmLast() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:_has:Encounter:reason-reference:type\", \"1\" + tag)\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 1);\n+        assertEquals(patient1Id, bundle.getEntry().get(0).getResource().getId());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEncounter1\", \"testCreateEncounter2\"})\n+    public void testSearchMultipleReverseChainWithReferenceParmLast() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:_has:Encounter:reason-reference:service-provider\", \"Organization/\" + organization2Id)\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 1);\n+        assertEquals(patient2Id, bundle.getEntry().get(0).getResource().getId());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEncounter1\", \"testCreateEncounter2\"})\n+    public void testSearchMultipleReverseChainWithDateTimeParmLast() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:_has:Encounter:reason-reference:date\", now.toString())\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 1);\n+        assertEquals(patient1Id, bundle.getEntry().get(0).getResource().getId());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateEncounter1\", \"testCreateEncounter2\"})\n+    public void testSearchMultipleReverseChainWithQuantityParmLast() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:_has:Encounter:reason-reference:length\", \"2\" + tag + \"|http://unitsofmeasure.org|s\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 1);\n+        assertEquals(patient2Id, bundle.getEntry().get(0).getResource().getId());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = { \"testCreateLocation\" })\n+    public void SearchMultipleReverseChainWithLocationNear() throws Exception {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Endpoint\")\n+                .queryParam(\"_has:Organization:endpoint:_has:Location:organization:near\", \"42.256500|-83.694810|11.20|km\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 1);\n+        assertEquals(endpointId, bundle.getEntry().get(0).getResource().getId());\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure1\", \"testCreateProcedure2\"})\n+    public void testSearchSingleReverseChainWithInclude() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:instantiates-uri\", \"1\" + tag)\n+                .queryParam(\"_include\", \"Patient:organization\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 2);\n+        List<String> resourceIds = new ArrayList<>();\n+        for (Bundle.Entry entry : bundle.getEntry()) {\n+            resourceIds.add(entry.getResource().getId());\n+        }\n+        assertTrue(resourceIds.contains(patient1Id));\n+        assertTrue(resourceIds.contains(organization1Id));\n+    }\n+\n+    @Test(groups = { \"server-search-reverse-chain\" }, dependsOnMethods = {\"testCreateProcedure1\", \"testCreateProcedure2\"})\n+    public void testSearchSingleReverseChainWithRevInclude() {\n+        WebTarget target = getWebTarget();\n+        Response response =\n+                target.path(\"Patient\")\n+                .queryParam(\"_has:Procedure:subject:instantiates-uri\", \"1\" + tag)\n+                .queryParam(\"_revinclude\", \"Procedure:patient\")\n+                .request(FHIRMediaType.APPLICATION_FHIR_JSON)\n+                .get();\n+        assertResponse(response, Response.Status.OK.getStatusCode());\n+        Bundle bundle = response.readEntity(Bundle.class);\n+\n+        assertNotNull(bundle);\n+        assertTrue(bundle.getEntry().size() == 2);\n+        List<String> resourceIds = new ArrayList<>();\n+        for (Bundle.Entry entry : bundle.getEntry()) {\n+            resourceIds.add(entry.getResource().getId());\n+        }\n+        assertTrue(resourceIds.contains(patient1Id));\n+        assertTrue(resourceIds.contains(procedure1Id));\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "originalPosition": 1033}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzk4NTk4", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-523398598", "createdAt": "2020-11-04T14:14:03Z", "commit": {"oid": "902162ddb39a92a6bd334e2dc3bfc6e856125125"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b12d338ae7e53c778d5a5f7ac499d9f172baf24", "author": {"user": {"login": "michaelwschroeder", "name": "Michael W Schroeder"}}, "url": "https://github.com/IBM/FHIR/commit/3b12d338ae7e53c778d5a5f7ac499d9f172baf24", "committedDate": "2020-11-04T20:31:47Z", "message": "Issue #1218 - address review comments\n\nSigned-off-by: Mike Schroeder <mschroed@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "112012e066c3c60b64d1484a3fe4f1d7f28fefd2", "author": {"user": {"login": "michaelwschroeder", "name": "Michael W Schroeder"}}, "url": "https://github.com/IBM/FHIR/commit/112012e066c3c60b64d1484a3fe4f1d7f28fefd2", "committedDate": "2020-11-04T20:33:29Z", "message": "Issue #1218 - update doc\n\nSigned-off-by: Mike Schroeder <mschroed@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4e8e0dd80b23d9bbb8caff8eaf5ba00ee5b9e4e2", "author": {"user": {"login": "michaelwschroeder", "name": "Michael W Schroeder"}}, "url": "https://github.com/IBM/FHIR/commit/4e8e0dd80b23d9bbb8caff8eaf5ba00ee5b9e4e2", "committedDate": "2020-11-04T21:14:09Z", "message": "Issue #1218 - fix bad substring\n\nSigned-off-by: Mike Schroeder <mschroed@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "82b998e84662a4311af57bf161c282f476463a04", "author": {"user": {"login": "michaelwschroeder", "name": "Michael W Schroeder"}}, "url": "https://github.com/IBM/FHIR/commit/82b998e84662a4311af57bf161c282f476463a04", "committedDate": "2020-11-04T21:41:03Z", "message": "Issue #1218 - fix testcase dateTime precision issue\n\nSigned-off-by: Mike Schroeder <mschroed@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7cf5dad7cb56ff76579a60579b11cc834f380021", "author": {"user": {"login": "michaelwschroeder", "name": "Michael W Schroeder"}}, "url": "https://github.com/IBM/FHIR/commit/7cf5dad7cb56ff76579a60579b11cc834f380021", "committedDate": "2020-11-04T22:01:10Z", "message": "Issue #1218 - additional dateTime precision fix\n\nSigned-off-by: Mike Schroeder <mschroed@us.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0Mjg1OTM1", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-524285935", "createdAt": "2020-11-05T13:59:09Z", "commit": {"oid": "7cf5dad7cb56ff76579a60579b11cc834f380021"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxMzo1OTowOVrOHuEhCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxMzo1OTowOVrOHuEhCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA3MDUzNg==", "bodyText": "I've been trying to keep the constant names identical to the string value for sanity. I don't really want to deviate from this. I think we should use a slightly different convention for prefix/postfix strings. Perhaps something as simple as _RESOURCES = \"_RESOURCES\"", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r518070536", "createdAt": "2020-11-05T13:59:09Z", "author": {"login": "punktilious"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/JDBCConstants.java", "diffHunk": "@@ -36,6 +36,14 @@\n     public static final String DATE_END = \"DATE_END\";\n     public static final String LATITUDE_VALUE = \"LATITUDE_VALUE\";\n     public static final String LONGITUDE_VALUE = \"LONGITUDE_VALUE\";\n+    public static final String RESOURCES = \"_RESOURCES\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7cf5dad7cb56ff76579a60579b11cc834f380021"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0Mjg2NDkx", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-524286491", "createdAt": "2020-11-05T13:59:42Z", "commit": {"oid": "7cf5dad7cb56ff76579a60579b11cc834f380021"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxMzo1OTo0MlrOHuEiyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxMzo1OTo0MlrOHuEiyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA3MDk4Ng==", "bodyText": "Good idea.", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r518070986", "createdAt": "2020-11-05T13:59:42Z", "author": {"login": "punktilious"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/JDBCConstants.java", "diffHunk": "@@ -36,6 +36,14 @@\n     public static final String DATE_END = \"DATE_END\";\n     public static final String LATITUDE_VALUE = \"LATITUDE_VALUE\";\n     public static final String LONGITUDE_VALUE = \"LONGITUDE_VALUE\";\n+    public static final String RESOURCES = \"_RESOURCES\";\n+    public static final String LOGICAL_RESOURCES = \"_LOGICAL_RESOURCES\";\n+    public static final String RESOURCE_ID = \"RESOURCE_ID\";\n+    public static final String LOGICAL_ID = \"LOGICAL_ID\";\n+    public static final String LOGICAL_RESOURCE_ID = \"LOGICAL_RESOURCE_ID\";\n+    public static final String CURRENT_RESOURCE_ID = \"CURRENT_RESOURCE_ID\";\n+    public static final String PARAMETER_NAME_ID = \"PARAMETER_NAME_ID\";\n+    public static final String IS_DELETED_NO = \"IS_DELETED = 'N'\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7cf5dad7cb56ff76579a60579b11cc834f380021"}, "originalPosition": 11}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0Mjk3NTgx", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-524297581", "createdAt": "2020-11-05T14:11:16Z", "commit": {"oid": "7cf5dad7cb56ff76579a60579b11cc834f380021"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNDoxMToxNlrOHuFCuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNDoxMToxNlrOHuFCuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA3OTE2Mw==", "bodyText": "I don't think we should use parens unless required to control precedence.", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r518079163", "createdAt": "2020-11-05T14:11:16Z", "author": {"login": "punktilious"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -1376,12 +1391,268 @@ private SqlQueryData processMissingParm(Class<?> resourceType, QueryParameter qu\n \n         whereClauseSegment.append(\"(SELECT 1 FROM \" + valuesTable + WHERE);\n         this.populateNameIdSubSegment(whereClauseSegment, queryParm.getCode(), valuesTable.toString());\n-        whereClauseSegment.append(\" AND \" + valuesTable + \".LOGICAL_RESOURCE_ID = R.LOGICAL_RESOURCE_ID\"); // correlate the [NOT] EXISTS subquery\n+        whereClauseSegment.append(AND).append(valuesTable).append(\".LOGICAL_RESOURCE_ID = R.LOGICAL_RESOURCE_ID\"); // correlate the [NOT] EXISTS subquery\n         whereClauseSegment.append(RIGHT_PAREN).append(RIGHT_PAREN);\n \n         List<Object> bindVariables = new ArrayList<>();\n         SqlQueryData queryData = new SqlQueryData(whereClauseSegment.toString(), bindVariables);\n         log.exiting(CLASSNAME, METHODNAME);\n         return queryData;\n     }\n+\n+    /**\n+     * Contains special logic for handling reverse chained reference search parameters.\n+     * <p>\n+     * A select statement is built to realize the reverse chaining logic required. Here is a sample\n+     * reverse chained query for a Patient given this search parameter: _has:Observation:patient:code=1234\n+     *\n+     * <pre>\n+     * SELECT\n+     *   CLR0.LOGICAL_ID\n+     * FROM\n+     *   Patient_LOGICAL_RESOURCES AS CLR0\n+     *   JOIN Patient_RESOURCES AS CR0 ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+     * WHERE\n+     *   EXISTS (\n+     *     SELECT\n+     *       1\n+     *     FROM\n+     *       Observation_TOKEN_VALUES_V AS CP1\n+     *       JOIN Observation_LOGICAL_RESOURCES AS CLR1 ON CLR1.LOGICAL_RESOURCE_ID = CP1.LOGICAL_RESOURCE_ID\n+     *       JOIN Observation_RESOURCES AS CR1 ON CR1.RESOURCE_ID = CLR1.CURRENT_RESOURCE_ID AND CR1.IS_DELETED = 'N'\n+     *       JOIN Observation_TOKEN_VALUES_V AS CP2 ON CP2.LOGICAL_RESOURCE_ID = CLR1.LOGICAL_RESOURCE_ID\n+     *       AND (", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7cf5dad7cb56ff76579a60579b11cc834f380021"}, "originalPosition": 201}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0Mjk4MTU3", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-524298157", "createdAt": "2020-11-05T14:11:49Z", "commit": {"oid": "7cf5dad7cb56ff76579a60579b11cc834f380021"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNDoxMTo0OVrOHuFE3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNDoxMTo0OVrOHuFE3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA3OTcxMQ==", "bodyText": "Build", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r518079711", "createdAt": "2020-11-05T14:11:49Z", "author": {"login": "punktilious"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -1376,12 +1391,268 @@ private SqlQueryData processMissingParm(Class<?> resourceType, QueryParameter qu\n \n         whereClauseSegment.append(\"(SELECT 1 FROM \" + valuesTable + WHERE);\n         this.populateNameIdSubSegment(whereClauseSegment, queryParm.getCode(), valuesTable.toString());\n-        whereClauseSegment.append(\" AND \" + valuesTable + \".LOGICAL_RESOURCE_ID = R.LOGICAL_RESOURCE_ID\"); // correlate the [NOT] EXISTS subquery\n+        whereClauseSegment.append(AND).append(valuesTable).append(\".LOGICAL_RESOURCE_ID = R.LOGICAL_RESOURCE_ID\"); // correlate the [NOT] EXISTS subquery\n         whereClauseSegment.append(RIGHT_PAREN).append(RIGHT_PAREN);\n \n         List<Object> bindVariables = new ArrayList<>();\n         SqlQueryData queryData = new SqlQueryData(whereClauseSegment.toString(), bindVariables);\n         log.exiting(CLASSNAME, METHODNAME);\n         return queryData;\n     }\n+\n+    /**\n+     * Contains special logic for handling reverse chained reference search parameters.\n+     * <p>\n+     * A select statement is built to realize the reverse chaining logic required. Here is a sample\n+     * reverse chained query for a Patient given this search parameter: _has:Observation:patient:code=1234\n+     *\n+     * <pre>\n+     * SELECT\n+     *   CLR0.LOGICAL_ID\n+     * FROM\n+     *   Patient_LOGICAL_RESOURCES AS CLR0\n+     *   JOIN Patient_RESOURCES AS CR0 ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+     * WHERE\n+     *   EXISTS (\n+     *     SELECT\n+     *       1\n+     *     FROM\n+     *       Observation_TOKEN_VALUES_V AS CP1\n+     *       JOIN Observation_LOGICAL_RESOURCES AS CLR1 ON CLR1.LOGICAL_RESOURCE_ID = CP1.LOGICAL_RESOURCE_ID\n+     *       JOIN Observation_RESOURCES AS CR1 ON CR1.RESOURCE_ID = CLR1.CURRENT_RESOURCE_ID AND CR1.IS_DELETED = 'N'\n+     *       JOIN Observation_TOKEN_VALUES_V AS CP2 ON CP2.LOGICAL_RESOURCE_ID = CLR1.LOGICAL_RESOURCE_ID\n+     *       AND (\n+     *         CP2.PARAMETER_NAME_ID = 1073\n+     *         AND ((CP2.TOKEN_VALUE = ?))\n+     *       )\n+     *     WHERE\n+     *       CP1.TOKEN_VALUE = CLR0.LOGICAL_ID\n+     *       AND CP1.PARAMETER_NAME_ID = 1274\n+     *       AND CP1.CODE_SYSTEM_ID = 20004\n+     *   )\n+     * </pre>\n+     *\n+     * @see https://www.hl7.org/fhir/search.html#has\n+     * @param resourceType\n+     *                  - The resource type being searched.\n+     * @param queryParm\n+     *                  - A Parameter representing a reverse chained query.\n+     * @return SqlQueryData\n+     *                  - The query segment for a reverse chained parameter reference search.\n+     * @throws Exception\n+     */\n+    @Override\n+    protected SqlQueryData processReverseChainedReferenceParm(Class<?> resourceType, QueryParameter queryParm) throws Exception {\n+        final String METHODNAME = \"processReverseChainedReferenceParm\";\n+        log.entering(CLASSNAME, METHODNAME, queryParm.toString());\n+\n+        String prevChainedResourceVar = null;\n+        String prevChainedLogicalResourceVar = null;\n+        String chainedResourceVar = null;\n+        String chainedLogicalResourceVar = null;\n+        String chainedParmVar = null;\n+        String nextChainedResourceVar = null;\n+        String nextChainedLogicalResourceVar = null;\n+        String nextChainedParmVar = null;\n+        QueryParameter previousParm = null;;\n+        int parmIndex = 0;\n+        int lastParmIndex = queryParm.getChain().size();\n+        boolean chainedParmProcessed = false;\n+        StringBuilder selectSegments = new StringBuilder();\n+        StringBuilder whereClauseSegments = new StringBuilder();\n+        List<Object> bindVariables = new ArrayList<>();\n+\n+        // Loop through the chained query parameters in order\n+        List<QueryParameter> queryParms = queryParm.getChain();\n+        queryParms.add(0, queryParm);\n+        for (QueryParameter currentParm : queryParms) {\n+\n+            prevChainedResourceVar        = CR + parmIndex;\n+            prevChainedLogicalResourceVar = CLR + parmIndex;\n+            chainedResourceVar        = CR + (parmIndex + 1);\n+            chainedLogicalResourceVar = CLR + (parmIndex + 1);\n+            chainedParmVar            = CP + (parmIndex + 1);\n+            nextChainedResourceVar        = CR + (parmIndex + 2);\n+            nextChainedLogicalResourceVar = CLR + (parmIndex + 2);\n+            nextChainedParmVar        = CP + (parmIndex + 2);\n+            StringBuilder whereClauseSegment = new StringBuilder();\n+\n+            if (parmIndex == 0) {\n+                // BUild outer select:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7cf5dad7cb56ff76579a60579b11cc834f380021"}, "originalPosition": 258}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0Mjk5ODc0", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-524299874", "createdAt": "2020-11-05T14:13:35Z", "commit": {"oid": "7cf5dad7cb56ff76579a60579b11cc834f380021"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNDoxMzozNVrOHuFJpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNDoxMzozNVrOHuFJpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA4MDkzMw==", "bodyText": "CODE_SYSTEM_ID", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r518080933", "createdAt": "2020-11-05T14:13:35Z", "author": {"login": "punktilious"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -1376,12 +1391,268 @@ private SqlQueryData processMissingParm(Class<?> resourceType, QueryParameter qu\n \n         whereClauseSegment.append(\"(SELECT 1 FROM \" + valuesTable + WHERE);\n         this.populateNameIdSubSegment(whereClauseSegment, queryParm.getCode(), valuesTable.toString());\n-        whereClauseSegment.append(\" AND \" + valuesTable + \".LOGICAL_RESOURCE_ID = R.LOGICAL_RESOURCE_ID\"); // correlate the [NOT] EXISTS subquery\n+        whereClauseSegment.append(AND).append(valuesTable).append(\".LOGICAL_RESOURCE_ID = R.LOGICAL_RESOURCE_ID\"); // correlate the [NOT] EXISTS subquery\n         whereClauseSegment.append(RIGHT_PAREN).append(RIGHT_PAREN);\n \n         List<Object> bindVariables = new ArrayList<>();\n         SqlQueryData queryData = new SqlQueryData(whereClauseSegment.toString(), bindVariables);\n         log.exiting(CLASSNAME, METHODNAME);\n         return queryData;\n     }\n+\n+    /**\n+     * Contains special logic for handling reverse chained reference search parameters.\n+     * <p>\n+     * A select statement is built to realize the reverse chaining logic required. Here is a sample\n+     * reverse chained query for a Patient given this search parameter: _has:Observation:patient:code=1234\n+     *\n+     * <pre>\n+     * SELECT\n+     *   CLR0.LOGICAL_ID\n+     * FROM\n+     *   Patient_LOGICAL_RESOURCES AS CLR0\n+     *   JOIN Patient_RESOURCES AS CR0 ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+     * WHERE\n+     *   EXISTS (\n+     *     SELECT\n+     *       1\n+     *     FROM\n+     *       Observation_TOKEN_VALUES_V AS CP1\n+     *       JOIN Observation_LOGICAL_RESOURCES AS CLR1 ON CLR1.LOGICAL_RESOURCE_ID = CP1.LOGICAL_RESOURCE_ID\n+     *       JOIN Observation_RESOURCES AS CR1 ON CR1.RESOURCE_ID = CLR1.CURRENT_RESOURCE_ID AND CR1.IS_DELETED = 'N'\n+     *       JOIN Observation_TOKEN_VALUES_V AS CP2 ON CP2.LOGICAL_RESOURCE_ID = CLR1.LOGICAL_RESOURCE_ID\n+     *       AND (\n+     *         CP2.PARAMETER_NAME_ID = 1073\n+     *         AND ((CP2.TOKEN_VALUE = ?))\n+     *       )\n+     *     WHERE\n+     *       CP1.TOKEN_VALUE = CLR0.LOGICAL_ID\n+     *       AND CP1.PARAMETER_NAME_ID = 1274\n+     *       AND CP1.CODE_SYSTEM_ID = 20004\n+     *   )\n+     * </pre>\n+     *\n+     * @see https://www.hl7.org/fhir/search.html#has\n+     * @param resourceType\n+     *                  - The resource type being searched.\n+     * @param queryParm\n+     *                  - A Parameter representing a reverse chained query.\n+     * @return SqlQueryData\n+     *                  - The query segment for a reverse chained parameter reference search.\n+     * @throws Exception\n+     */\n+    @Override\n+    protected SqlQueryData processReverseChainedReferenceParm(Class<?> resourceType, QueryParameter queryParm) throws Exception {\n+        final String METHODNAME = \"processReverseChainedReferenceParm\";\n+        log.entering(CLASSNAME, METHODNAME, queryParm.toString());\n+\n+        String prevChainedResourceVar = null;\n+        String prevChainedLogicalResourceVar = null;\n+        String chainedResourceVar = null;\n+        String chainedLogicalResourceVar = null;\n+        String chainedParmVar = null;\n+        String nextChainedResourceVar = null;\n+        String nextChainedLogicalResourceVar = null;\n+        String nextChainedParmVar = null;\n+        QueryParameter previousParm = null;;\n+        int parmIndex = 0;\n+        int lastParmIndex = queryParm.getChain().size();\n+        boolean chainedParmProcessed = false;\n+        StringBuilder selectSegments = new StringBuilder();\n+        StringBuilder whereClauseSegments = new StringBuilder();\n+        List<Object> bindVariables = new ArrayList<>();\n+\n+        // Loop through the chained query parameters in order\n+        List<QueryParameter> queryParms = queryParm.getChain();\n+        queryParms.add(0, queryParm);\n+        for (QueryParameter currentParm : queryParms) {\n+\n+            prevChainedResourceVar        = CR + parmIndex;\n+            prevChainedLogicalResourceVar = CLR + parmIndex;\n+            chainedResourceVar        = CR + (parmIndex + 1);\n+            chainedLogicalResourceVar = CLR + (parmIndex + 1);\n+            chainedParmVar            = CP + (parmIndex + 1);\n+            nextChainedResourceVar        = CR + (parmIndex + 2);\n+            nextChainedLogicalResourceVar = CLR + (parmIndex + 2);\n+            nextChainedParmVar        = CP + (parmIndex + 2);\n+            StringBuilder whereClauseSegment = new StringBuilder();\n+\n+            if (parmIndex == 0) {\n+                // BUild outer select:\n+                // @formatter:off\n+                //   SELECT CLR0.LOGICAL_ID\n+                //     FROM <resource-type>_LOGICAL_RESOURCES AS CLR0\n+                //     JOIN <resource-type>_RESOURCES AS CR0\n+                //       ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+                //     WHERE\n+                // @formatter:on\n+                selectSegments.append(SELECT).append(prevChainedLogicalResourceVar).append(DOT).append(LOGICAL_ID)\n+                                .append(FROM).append(resourceType.getSimpleName()).append(LOGICAL_RESOURCES).append(AS).append(prevChainedLogicalResourceVar)\n+                                .append(JOIN).append(resourceType.getSimpleName()).append(RESOURCES).append(AS).append(prevChainedResourceVar)\n+                                .append(ON).append(prevChainedResourceVar).append(DOT).append(RESOURCE_ID).append(EQ)\n+                                .append(prevChainedLogicalResourceVar).append(DOT).append(CURRENT_RESOURCE_ID)\n+                                .append(AND).append(prevChainedResourceVar).append(DOT ).append(IS_DELETED_NO)\n+                                .append(WHERE);\n+            }\n+\n+            if (parmIndex < lastParmIndex) {\n+                if (currentParm.isReverseChained()) {\n+                    // Build inner select joins:\n+                    // @formatter:off\n+                    //   EXISTS (SELECT 1\n+                    //     FROM <modifierTypeResourceName>_TOKEN_VALUES_V AS CPx\n+                    //     JOIN <modifierTypeResourceName>_LOGICAL_RESOURCES AS CLRx\n+                    //       ON CLRx.LOGICAL_RESOURCE_ID = CPx.LOGICAL_RESOURCE_ID\n+                    //     JOIN <modifierTypeResourceName>_RESOURCES AS CRx\n+                    //       ON CRx.RESOURCE_ID = CLRx.CURRENT_RESOURCE_ID AND CRx.IS_DELETED = 'N'\n+                    // @formatter:on\n+                    selectSegments.append(EXISTS).append(LEFT_PAREN).append(\"SELECT 1\")\n+                                    .append(FROM).append(currentParm.getModifierResourceTypeName()).append(\"_TOKEN_VALUES_V\").append(AS).append(chainedParmVar)\n+                                    .append(JOIN).append(currentParm.getModifierResourceTypeName()).append(LOGICAL_RESOURCES).append(AS).append(chainedLogicalResourceVar)\n+                                    .append(ON).append(chainedLogicalResourceVar).append(DOT).append(LOGICAL_RESOURCE_ID).append(EQ)\n+                                    .append(chainedParmVar).append(DOT).append(LOGICAL_RESOURCE_ID)\n+                                    .append(JOIN).append(currentParm.getModifierResourceTypeName()).append(RESOURCES).append(AS).append(chainedResourceVar)\n+                                    .append(ON).append(chainedResourceVar).append(DOT).append(RESOURCE_ID).append(EQ)\n+                                    .append(chainedLogicalResourceVar).append(DOT).append(CURRENT_RESOURCE_ID)\n+                                    .append(AND).append(chainedResourceVar).append(DOT).append(IS_DELETED_NO);\n+\n+                    String referencedResourceType = null;\n+                    if (parmIndex == 0) {\n+                        referencedResourceType = resourceType.getSimpleName();\n+                    } else {\n+                        referencedResourceType = previousParm.getModifierResourceTypeName();\n+                    }\n+                    if (parmIndex < lastParmIndex - 1 && currentParm.getNextParameter().isReverseChained()) {\n+                        // Build inner select where clause:\n+                        // @formatter:off\n+                        //   WHERE CPx.TOKEN_VALUE = CLR<x-1>.LOGICAL_ID\n+                        //     AND CPx.PARAMETER_NAME_ID = <parm-name-id>\n+                        //     AND CPx.CDE_SYSTEM_ID = <code-system-id>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7cf5dad7cb56ff76579a60579b11cc834f380021"}, "originalPosition": 307}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0MzAwNjQ1", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-524300645", "createdAt": "2020-11-05T14:14:20Z", "commit": {"oid": "7cf5dad7cb56ff76579a60579b11cc834f380021"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNDoxNDoyMFrOHuFLqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNDoxNDoyMFrOHuFLqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA4MTQ1MQ==", "bodyText": "CODE_SYSTEM_ID", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r518081451", "createdAt": "2020-11-05T14:14:20Z", "author": {"login": "punktilious"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -1376,12 +1391,268 @@ private SqlQueryData processMissingParm(Class<?> resourceType, QueryParameter qu\n \n         whereClauseSegment.append(\"(SELECT 1 FROM \" + valuesTable + WHERE);\n         this.populateNameIdSubSegment(whereClauseSegment, queryParm.getCode(), valuesTable.toString());\n-        whereClauseSegment.append(\" AND \" + valuesTable + \".LOGICAL_RESOURCE_ID = R.LOGICAL_RESOURCE_ID\"); // correlate the [NOT] EXISTS subquery\n+        whereClauseSegment.append(AND).append(valuesTable).append(\".LOGICAL_RESOURCE_ID = R.LOGICAL_RESOURCE_ID\"); // correlate the [NOT] EXISTS subquery\n         whereClauseSegment.append(RIGHT_PAREN).append(RIGHT_PAREN);\n \n         List<Object> bindVariables = new ArrayList<>();\n         SqlQueryData queryData = new SqlQueryData(whereClauseSegment.toString(), bindVariables);\n         log.exiting(CLASSNAME, METHODNAME);\n         return queryData;\n     }\n+\n+    /**\n+     * Contains special logic for handling reverse chained reference search parameters.\n+     * <p>\n+     * A select statement is built to realize the reverse chaining logic required. Here is a sample\n+     * reverse chained query for a Patient given this search parameter: _has:Observation:patient:code=1234\n+     *\n+     * <pre>\n+     * SELECT\n+     *   CLR0.LOGICAL_ID\n+     * FROM\n+     *   Patient_LOGICAL_RESOURCES AS CLR0\n+     *   JOIN Patient_RESOURCES AS CR0 ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+     * WHERE\n+     *   EXISTS (\n+     *     SELECT\n+     *       1\n+     *     FROM\n+     *       Observation_TOKEN_VALUES_V AS CP1\n+     *       JOIN Observation_LOGICAL_RESOURCES AS CLR1 ON CLR1.LOGICAL_RESOURCE_ID = CP1.LOGICAL_RESOURCE_ID\n+     *       JOIN Observation_RESOURCES AS CR1 ON CR1.RESOURCE_ID = CLR1.CURRENT_RESOURCE_ID AND CR1.IS_DELETED = 'N'\n+     *       JOIN Observation_TOKEN_VALUES_V AS CP2 ON CP2.LOGICAL_RESOURCE_ID = CLR1.LOGICAL_RESOURCE_ID\n+     *       AND (\n+     *         CP2.PARAMETER_NAME_ID = 1073\n+     *         AND ((CP2.TOKEN_VALUE = ?))\n+     *       )\n+     *     WHERE\n+     *       CP1.TOKEN_VALUE = CLR0.LOGICAL_ID\n+     *       AND CP1.PARAMETER_NAME_ID = 1274\n+     *       AND CP1.CODE_SYSTEM_ID = 20004\n+     *   )\n+     * </pre>\n+     *\n+     * @see https://www.hl7.org/fhir/search.html#has\n+     * @param resourceType\n+     *                  - The resource type being searched.\n+     * @param queryParm\n+     *                  - A Parameter representing a reverse chained query.\n+     * @return SqlQueryData\n+     *                  - The query segment for a reverse chained parameter reference search.\n+     * @throws Exception\n+     */\n+    @Override\n+    protected SqlQueryData processReverseChainedReferenceParm(Class<?> resourceType, QueryParameter queryParm) throws Exception {\n+        final String METHODNAME = \"processReverseChainedReferenceParm\";\n+        log.entering(CLASSNAME, METHODNAME, queryParm.toString());\n+\n+        String prevChainedResourceVar = null;\n+        String prevChainedLogicalResourceVar = null;\n+        String chainedResourceVar = null;\n+        String chainedLogicalResourceVar = null;\n+        String chainedParmVar = null;\n+        String nextChainedResourceVar = null;\n+        String nextChainedLogicalResourceVar = null;\n+        String nextChainedParmVar = null;\n+        QueryParameter previousParm = null;;\n+        int parmIndex = 0;\n+        int lastParmIndex = queryParm.getChain().size();\n+        boolean chainedParmProcessed = false;\n+        StringBuilder selectSegments = new StringBuilder();\n+        StringBuilder whereClauseSegments = new StringBuilder();\n+        List<Object> bindVariables = new ArrayList<>();\n+\n+        // Loop through the chained query parameters in order\n+        List<QueryParameter> queryParms = queryParm.getChain();\n+        queryParms.add(0, queryParm);\n+        for (QueryParameter currentParm : queryParms) {\n+\n+            prevChainedResourceVar        = CR + parmIndex;\n+            prevChainedLogicalResourceVar = CLR + parmIndex;\n+            chainedResourceVar        = CR + (parmIndex + 1);\n+            chainedLogicalResourceVar = CLR + (parmIndex + 1);\n+            chainedParmVar            = CP + (parmIndex + 1);\n+            nextChainedResourceVar        = CR + (parmIndex + 2);\n+            nextChainedLogicalResourceVar = CLR + (parmIndex + 2);\n+            nextChainedParmVar        = CP + (parmIndex + 2);\n+            StringBuilder whereClauseSegment = new StringBuilder();\n+\n+            if (parmIndex == 0) {\n+                // BUild outer select:\n+                // @formatter:off\n+                //   SELECT CLR0.LOGICAL_ID\n+                //     FROM <resource-type>_LOGICAL_RESOURCES AS CLR0\n+                //     JOIN <resource-type>_RESOURCES AS CR0\n+                //       ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+                //     WHERE\n+                // @formatter:on\n+                selectSegments.append(SELECT).append(prevChainedLogicalResourceVar).append(DOT).append(LOGICAL_ID)\n+                                .append(FROM).append(resourceType.getSimpleName()).append(LOGICAL_RESOURCES).append(AS).append(prevChainedLogicalResourceVar)\n+                                .append(JOIN).append(resourceType.getSimpleName()).append(RESOURCES).append(AS).append(prevChainedResourceVar)\n+                                .append(ON).append(prevChainedResourceVar).append(DOT).append(RESOURCE_ID).append(EQ)\n+                                .append(prevChainedLogicalResourceVar).append(DOT).append(CURRENT_RESOURCE_ID)\n+                                .append(AND).append(prevChainedResourceVar).append(DOT ).append(IS_DELETED_NO)\n+                                .append(WHERE);\n+            }\n+\n+            if (parmIndex < lastParmIndex) {\n+                if (currentParm.isReverseChained()) {\n+                    // Build inner select joins:\n+                    // @formatter:off\n+                    //   EXISTS (SELECT 1\n+                    //     FROM <modifierTypeResourceName>_TOKEN_VALUES_V AS CPx\n+                    //     JOIN <modifierTypeResourceName>_LOGICAL_RESOURCES AS CLRx\n+                    //       ON CLRx.LOGICAL_RESOURCE_ID = CPx.LOGICAL_RESOURCE_ID\n+                    //     JOIN <modifierTypeResourceName>_RESOURCES AS CRx\n+                    //       ON CRx.RESOURCE_ID = CLRx.CURRENT_RESOURCE_ID AND CRx.IS_DELETED = 'N'\n+                    // @formatter:on\n+                    selectSegments.append(EXISTS).append(LEFT_PAREN).append(\"SELECT 1\")\n+                                    .append(FROM).append(currentParm.getModifierResourceTypeName()).append(\"_TOKEN_VALUES_V\").append(AS).append(chainedParmVar)\n+                                    .append(JOIN).append(currentParm.getModifierResourceTypeName()).append(LOGICAL_RESOURCES).append(AS).append(chainedLogicalResourceVar)\n+                                    .append(ON).append(chainedLogicalResourceVar).append(DOT).append(LOGICAL_RESOURCE_ID).append(EQ)\n+                                    .append(chainedParmVar).append(DOT).append(LOGICAL_RESOURCE_ID)\n+                                    .append(JOIN).append(currentParm.getModifierResourceTypeName()).append(RESOURCES).append(AS).append(chainedResourceVar)\n+                                    .append(ON).append(chainedResourceVar).append(DOT).append(RESOURCE_ID).append(EQ)\n+                                    .append(chainedLogicalResourceVar).append(DOT).append(CURRENT_RESOURCE_ID)\n+                                    .append(AND).append(chainedResourceVar).append(DOT).append(IS_DELETED_NO);\n+\n+                    String referencedResourceType = null;\n+                    if (parmIndex == 0) {\n+                        referencedResourceType = resourceType.getSimpleName();\n+                    } else {\n+                        referencedResourceType = previousParm.getModifierResourceTypeName();\n+                    }\n+                    if (parmIndex < lastParmIndex - 1 && currentParm.getNextParameter().isReverseChained()) {\n+                        // Build inner select where clause:\n+                        // @formatter:off\n+                        //   WHERE CPx.TOKEN_VALUE = CLR<x-1>.LOGICAL_ID\n+                        //     AND CPx.PARAMETER_NAME_ID = <parm-name-id>\n+                        //     AND CPx.CDE_SYSTEM_ID = <code-system-id>\n+                        //     AND\n+                        // @formatter:on\n+                        selectSegments.append(WHERE).append(chainedParmVar).append(DOT).append(TOKEN_VALUE).append(EQ)\n+                                        .append(prevChainedLogicalResourceVar).append(DOT).append(LOGICAL_ID).append(AND);\n+                        populateReferenceNameAndCodeSystemIdSubSegment(selectSegments, currentParm.getCode(), referencedResourceType, chainedParmVar);\n+                        selectSegments.append(AND);\n+                    } else {\n+                        // Build final inner select where clause:\n+                        // @formatter:off\n+                        //   WHERE CPx.TOKEN_VALUE = CLR<x-1>.LOGICAL_ID\n+                        //     AND CPx.PARAMETER_NAME_ID = <parm-name-id>\n+                        //     AND CPx.CDE_SYSTEM_ID = <code-system-id>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7cf5dad7cb56ff76579a60579b11cc834f380021"}, "originalPosition": 319}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0MzA3MTAz", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-524307103", "createdAt": "2020-11-05T14:20:47Z", "commit": {"oid": "7cf5dad7cb56ff76579a60579b11cc834f380021"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNDoyMDo0N1rOHuFeqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNDoyMDo0N1rOHuFeqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA4NjMxNA==", "bodyText": "nullCheck is redundant here. getParameterNameId will never return null, although I know it's used in a few places. Just fyi, doesn't need to be changed.", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r518086314", "createdAt": "2020-11-05T14:20:47Z", "author": {"login": "punktilious"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/JDBCQueryBuilder.java", "diffHunk": "@@ -1376,12 +1391,268 @@ private SqlQueryData processMissingParm(Class<?> resourceType, QueryParameter qu\n \n         whereClauseSegment.append(\"(SELECT 1 FROM \" + valuesTable + WHERE);\n         this.populateNameIdSubSegment(whereClauseSegment, queryParm.getCode(), valuesTable.toString());\n-        whereClauseSegment.append(\" AND \" + valuesTable + \".LOGICAL_RESOURCE_ID = R.LOGICAL_RESOURCE_ID\"); // correlate the [NOT] EXISTS subquery\n+        whereClauseSegment.append(AND).append(valuesTable).append(\".LOGICAL_RESOURCE_ID = R.LOGICAL_RESOURCE_ID\"); // correlate the [NOT] EXISTS subquery\n         whereClauseSegment.append(RIGHT_PAREN).append(RIGHT_PAREN);\n \n         List<Object> bindVariables = new ArrayList<>();\n         SqlQueryData queryData = new SqlQueryData(whereClauseSegment.toString(), bindVariables);\n         log.exiting(CLASSNAME, METHODNAME);\n         return queryData;\n     }\n+\n+    /**\n+     * Contains special logic for handling reverse chained reference search parameters.\n+     * <p>\n+     * A select statement is built to realize the reverse chaining logic required. Here is a sample\n+     * reverse chained query for a Patient given this search parameter: _has:Observation:patient:code=1234\n+     *\n+     * <pre>\n+     * SELECT\n+     *   CLR0.LOGICAL_ID\n+     * FROM\n+     *   Patient_LOGICAL_RESOURCES AS CLR0\n+     *   JOIN Patient_RESOURCES AS CR0 ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+     * WHERE\n+     *   EXISTS (\n+     *     SELECT\n+     *       1\n+     *     FROM\n+     *       Observation_TOKEN_VALUES_V AS CP1\n+     *       JOIN Observation_LOGICAL_RESOURCES AS CLR1 ON CLR1.LOGICAL_RESOURCE_ID = CP1.LOGICAL_RESOURCE_ID\n+     *       JOIN Observation_RESOURCES AS CR1 ON CR1.RESOURCE_ID = CLR1.CURRENT_RESOURCE_ID AND CR1.IS_DELETED = 'N'\n+     *       JOIN Observation_TOKEN_VALUES_V AS CP2 ON CP2.LOGICAL_RESOURCE_ID = CLR1.LOGICAL_RESOURCE_ID\n+     *       AND (\n+     *         CP2.PARAMETER_NAME_ID = 1073\n+     *         AND ((CP2.TOKEN_VALUE = ?))\n+     *       )\n+     *     WHERE\n+     *       CP1.TOKEN_VALUE = CLR0.LOGICAL_ID\n+     *       AND CP1.PARAMETER_NAME_ID = 1274\n+     *       AND CP1.CODE_SYSTEM_ID = 20004\n+     *   )\n+     * </pre>\n+     *\n+     * @see https://www.hl7.org/fhir/search.html#has\n+     * @param resourceType\n+     *                  - The resource type being searched.\n+     * @param queryParm\n+     *                  - A Parameter representing a reverse chained query.\n+     * @return SqlQueryData\n+     *                  - The query segment for a reverse chained parameter reference search.\n+     * @throws Exception\n+     */\n+    @Override\n+    protected SqlQueryData processReverseChainedReferenceParm(Class<?> resourceType, QueryParameter queryParm) throws Exception {\n+        final String METHODNAME = \"processReverseChainedReferenceParm\";\n+        log.entering(CLASSNAME, METHODNAME, queryParm.toString());\n+\n+        String prevChainedResourceVar = null;\n+        String prevChainedLogicalResourceVar = null;\n+        String chainedResourceVar = null;\n+        String chainedLogicalResourceVar = null;\n+        String chainedParmVar = null;\n+        String nextChainedResourceVar = null;\n+        String nextChainedLogicalResourceVar = null;\n+        String nextChainedParmVar = null;\n+        QueryParameter previousParm = null;;\n+        int parmIndex = 0;\n+        int lastParmIndex = queryParm.getChain().size();\n+        boolean chainedParmProcessed = false;\n+        StringBuilder selectSegments = new StringBuilder();\n+        StringBuilder whereClauseSegments = new StringBuilder();\n+        List<Object> bindVariables = new ArrayList<>();\n+\n+        // Loop through the chained query parameters in order\n+        List<QueryParameter> queryParms = queryParm.getChain();\n+        queryParms.add(0, queryParm);\n+        for (QueryParameter currentParm : queryParms) {\n+\n+            prevChainedResourceVar        = CR + parmIndex;\n+            prevChainedLogicalResourceVar = CLR + parmIndex;\n+            chainedResourceVar        = CR + (parmIndex + 1);\n+            chainedLogicalResourceVar = CLR + (parmIndex + 1);\n+            chainedParmVar            = CP + (parmIndex + 1);\n+            nextChainedResourceVar        = CR + (parmIndex + 2);\n+            nextChainedLogicalResourceVar = CLR + (parmIndex + 2);\n+            nextChainedParmVar        = CP + (parmIndex + 2);\n+            StringBuilder whereClauseSegment = new StringBuilder();\n+\n+            if (parmIndex == 0) {\n+                // BUild outer select:\n+                // @formatter:off\n+                //   SELECT CLR0.LOGICAL_ID\n+                //     FROM <resource-type>_LOGICAL_RESOURCES AS CLR0\n+                //     JOIN <resource-type>_RESOURCES AS CR0\n+                //       ON CR0.RESOURCE_ID = CLR0.CURRENT_RESOURCE_ID AND CR0.IS_DELETED = 'N'\n+                //     WHERE\n+                // @formatter:on\n+                selectSegments.append(SELECT).append(prevChainedLogicalResourceVar).append(DOT).append(LOGICAL_ID)\n+                                .append(FROM).append(resourceType.getSimpleName()).append(LOGICAL_RESOURCES).append(AS).append(prevChainedLogicalResourceVar)\n+                                .append(JOIN).append(resourceType.getSimpleName()).append(RESOURCES).append(AS).append(prevChainedResourceVar)\n+                                .append(ON).append(prevChainedResourceVar).append(DOT).append(RESOURCE_ID).append(EQ)\n+                                .append(prevChainedLogicalResourceVar).append(DOT).append(CURRENT_RESOURCE_ID)\n+                                .append(AND).append(prevChainedResourceVar).append(DOT ).append(IS_DELETED_NO)\n+                                .append(WHERE);\n+            }\n+\n+            if (parmIndex < lastParmIndex) {\n+                if (currentParm.isReverseChained()) {\n+                    // Build inner select joins:\n+                    // @formatter:off\n+                    //   EXISTS (SELECT 1\n+                    //     FROM <modifierTypeResourceName>_TOKEN_VALUES_V AS CPx\n+                    //     JOIN <modifierTypeResourceName>_LOGICAL_RESOURCES AS CLRx\n+                    //       ON CLRx.LOGICAL_RESOURCE_ID = CPx.LOGICAL_RESOURCE_ID\n+                    //     JOIN <modifierTypeResourceName>_RESOURCES AS CRx\n+                    //       ON CRx.RESOURCE_ID = CLRx.CURRENT_RESOURCE_ID AND CRx.IS_DELETED = 'N'\n+                    // @formatter:on\n+                    selectSegments.append(EXISTS).append(LEFT_PAREN).append(\"SELECT 1\")\n+                                    .append(FROM).append(currentParm.getModifierResourceTypeName()).append(\"_TOKEN_VALUES_V\").append(AS).append(chainedParmVar)\n+                                    .append(JOIN).append(currentParm.getModifierResourceTypeName()).append(LOGICAL_RESOURCES).append(AS).append(chainedLogicalResourceVar)\n+                                    .append(ON).append(chainedLogicalResourceVar).append(DOT).append(LOGICAL_RESOURCE_ID).append(EQ)\n+                                    .append(chainedParmVar).append(DOT).append(LOGICAL_RESOURCE_ID)\n+                                    .append(JOIN).append(currentParm.getModifierResourceTypeName()).append(RESOURCES).append(AS).append(chainedResourceVar)\n+                                    .append(ON).append(chainedResourceVar).append(DOT).append(RESOURCE_ID).append(EQ)\n+                                    .append(chainedLogicalResourceVar).append(DOT).append(CURRENT_RESOURCE_ID)\n+                                    .append(AND).append(chainedResourceVar).append(DOT).append(IS_DELETED_NO);\n+\n+                    String referencedResourceType = null;\n+                    if (parmIndex == 0) {\n+                        referencedResourceType = resourceType.getSimpleName();\n+                    } else {\n+                        referencedResourceType = previousParm.getModifierResourceTypeName();\n+                    }\n+                    if (parmIndex < lastParmIndex - 1 && currentParm.getNextParameter().isReverseChained()) {\n+                        // Build inner select where clause:\n+                        // @formatter:off\n+                        //   WHERE CPx.TOKEN_VALUE = CLR<x-1>.LOGICAL_ID\n+                        //     AND CPx.PARAMETER_NAME_ID = <parm-name-id>\n+                        //     AND CPx.CDE_SYSTEM_ID = <code-system-id>\n+                        //     AND\n+                        // @formatter:on\n+                        selectSegments.append(WHERE).append(chainedParmVar).append(DOT).append(TOKEN_VALUE).append(EQ)\n+                                        .append(prevChainedLogicalResourceVar).append(DOT).append(LOGICAL_ID).append(AND);\n+                        populateReferenceNameAndCodeSystemIdSubSegment(selectSegments, currentParm.getCode(), referencedResourceType, chainedParmVar);\n+                        selectSegments.append(AND);\n+                    } else {\n+                        // Build final inner select where clause:\n+                        // @formatter:off\n+                        //   WHERE CPx.TOKEN_VALUE = CLR<x-1>.LOGICAL_ID\n+                        //     AND CPx.PARAMETER_NAME_ID = <parm-name-id>\n+                        //     AND CPx.CDE_SYSTEM_ID = <code-system-id>\n+                        // @formatter:on\n+                        whereClauseSegment.append(WHERE).append(chainedParmVar).append(DOT).append(TOKEN_VALUE).append(EQ)\n+                                            .append(prevChainedLogicalResourceVar).append(DOT).append(LOGICAL_ID).append(AND);\n+                        populateReferenceNameAndCodeSystemIdSubSegment(whereClauseSegment, currentParm.getCode(), referencedResourceType, chainedParmVar);\n+                    }\n+\n+                    // Add closing right paren for EXISTS\n+                    whereClauseSegment.append(RIGHT_PAREN);\n+                } else if (currentParm.isChained()) {\n+                    // Build chained query\n+                    if (!chainedParmProcessed) {\n+                        // Build initial chain join and select:\n+                        //   SELECT CPx.LOGICAL_RESOURCE_ID FROM <modifierTypeResourceName>_TOKEN_VALUES_V AS CPx WHERE\n+                        selectSegments.append(JOIN ).append(LEFT_PAREN)\n+                                        .append(SELECT).append(chainedParmVar).append(DOT).append(LOGICAL_RESOURCE_ID).append(FROM)\n+                                        .append(previousParm.getModifierResourceTypeName()).append(\"_TOKEN_VALUES_V AS \").append(chainedParmVar)\n+                                        .append(WHERE);\n+                    }\n+\n+                    // Build this piece: CPx.PARAMETER_NAME_ID = <code-id> AND CPx.STR_VALUE IN\n+                    appendMidChainParm(selectSegments, currentParm, chainedParmVar);\n+\n+                    // Build this piece: (SELECT 'resource-type-name' || '/' || CLR<x+1>.LOGICAL_ID ...\n+                    selectSegments.append(LEFT_PAREN);\n+                    appendInnerSelect(selectSegments, currentParm, currentParm.getModifierResourceTypeName(),\n+                        nextChainedResourceVar, nextChainedLogicalResourceVar, nextChainedParmVar);\n+                    whereClauseSegment.append(RIGHT_PAREN);\n+\n+                    if (!chainedParmProcessed) {\n+                        chainedParmProcessed = true;\n+\n+                        // Builds ON clause for join: ) AS CPx ON CPx.LOGICAL_RESOURCE_ID = CLR<x-1>.LOGICAL_RESOURCE_ID\n+                        whereClauseSegment.append(RIGHT_PAREN).append(AS).append(chainedParmVar).append(ON)\n+                                            .append(chainedParmVar).append(DOT).append(LOGICAL_RESOURCE_ID).append(EQ)\n+                                            .append(prevChainedLogicalResourceVar).append(DOT).append(LOGICAL_RESOURCE_ID);\n+                    }\n+                }\n+            } else if (parmIndex == lastParmIndex) {\n+                // This logic processes the LAST parameter in the chain.\n+                SqlQueryData sqlQueryData;\n+                if (!\"_id\".equals(currentParm.getCode())) {\n+                    if (!chainedParmProcessed) {\n+                        // Build this join:\n+                        // @formatter:off\n+                        //   JOIN <modifierTypeResourceName>_<type>_VALUES AS CPx\n+                        //     ON CPx.LOGICAL_RESOURCE_ID = CLR<x-1>.LOGICAL_RESOURCE_ID\n+                        //     AND\n+                        // @formatter:on\n+                        whereClauseSegment.append(JOIN).append(QuerySegmentAggregator.tableName(previousParm.getModifierResourceTypeName(), currentParm))\n+                                            .append(AS).append(chainedParmVar).append(ON).append(chainedParmVar).append(DOT).append(LOGICAL_RESOURCE_ID)\n+                                            .append(EQ).append(prevChainedLogicalResourceVar).append(DOT).append(LOGICAL_RESOURCE_ID).append(AND);\n+                    }\n+                    // Build the rest: (CPx.PARAMETER_NAME_ID=<code-id> AND (CPx.<type>_VALUE=<valueCode>))\n+                    sqlQueryData = buildQueryParm(ModelSupport.getResourceType(previousParm.getModifierResourceTypeName()), currentParm, chainedParmVar);\n+                } else {\n+                    if (!chainedParmProcessed) {\n+                        // Build this join:\n+                        // @formatter:off\n+                        //   JOIN <modifierTypeResourceName>_LOGICAL_RESOURCES AS CLRx\n+                        //     ON CLRx.LOGICAL_RESOURCE_ID = CLR<x-1>.LOGICAL_RESOURCE_ID\n+                        //     AND\n+                        // @formatter:on\n+                        whereClauseSegment.append(JOIN).append(previousParm.getModifierResourceTypeName()).append(LOGICAL_RESOURCES)\n+                                            .append(AS).append(chainedLogicalResourceVar).append(ON)\n+                                            .append(chainedLogicalResourceVar).append(DOT).append(LOGICAL_RESOURCE_ID)\n+                                            .append(EQ).append(prevChainedLogicalResourceVar).append(DOT).append(LOGICAL_RESOURCE_ID).append(AND);\n+                    }\n+                    // Build the rest: CLRx.LOGICAL_ID IN (?)\n+                    sqlQueryData = buildChainedIdClause(currentParm, chainedParmVar);\n+                }\n+\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"chained sqlQueryData[\" + chainedParmVar + \"] = \" + sqlQueryData.getQueryString());\n+                }\n+                whereClauseSegment.append(sqlQueryData.getQueryString());\n+                bindVariables.addAll(sqlQueryData.getBindVariables());\n+           }\n+\n+            // Insert where clause segment in whole\n+            whereClauseSegments.insert(0, whereClauseSegment.toString());\n+\n+            previousParm = currentParm;\n+            parmIndex++;\n+        }\n+\n+        SqlQueryData queryData = new SqlQueryData(whereClauseSegments.insert(0, selectSegments.toString()).toString(), bindVariables);\n+        log.exiting(CLASSNAME, METHODNAME, queryData.getQueryString());\n+        return queryData;\n+    }\n+\n+    /**\n+     * Populates the reference parameter name ID and code system ID sub-segment of the passed where clause segment.\n+     *\n+     * @param whereClauseSegment - the segment to which the sub-segment will be added\n+     * @param queryParmName - the search parameter name\n+     * @param resourceTypeName - the resource type of the reference being followed\n+     * @param parameterTableAlias - the alias for the parameter table e.g. CPx\n+     * @throws FHIRPersistenceException\n+     */\n+    private void populateReferenceNameAndCodeSystemIdSubSegment(StringBuilder whereClauseSegment, String queryParmName,\n+            String resourceTypeName, String parameterTableAlias) throws FHIRPersistenceException {\n+        final String METHODNAME = \"populateReferenceNameAndCodeSystemIdSubSegment\";\n+        log.entering(CLASSNAME, METHODNAME, queryParmName);\n+\n+        Integer parameterNameId = identityCache.getParameterNameId(queryParmName);\n+        Integer codeSystemId = getCodeSystemId(resourceTypeName);\n+\n+        // Build the segment:\n+        // CPx.PARAMETER_NAME_ID = <parameter-name-id> AND CPx.CODE_SYSTEM_ID = <code-system_id>\n+        whereClauseSegment.append(parameterTableAlias).append(DOT).append(PARAMETER_NAME_ID).append(EQ).append(nullCheck(parameterNameId))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7cf5dad7cb56ff76579a60579b11cc834f380021"}, "originalPosition": 429}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0MzExNzg2", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-524311786", "createdAt": "2020-11-05T14:25:19Z", "commit": {"oid": "7cf5dad7cb56ff76579a60579b11cc834f380021"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNDoyNToxOVrOHuFs9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNDoyNToxOVrOHuFs9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA4OTk3Mw==", "bodyText": "from Observation logical resources table. There's also a global (all resources) logical_resources table. Good to distinguish, because the join predicate would be slightly different", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r518089973", "createdAt": "2020-11-05T14:25:19Z", "author": {"login": "punktilious"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/QuerySegmentAggregator.java", "diffHunk": "@@ -555,20 +556,41 @@ protected void buildWhereClause(StringBuilder whereClause, String overrideType)\n                     whereClause.append(whereClauseSegment);\n                 } else {\n                     if (!Type.COMPOSITE.equals(param.getType())) {\n-                        // Join a standard parameter table\n-                        //   JOIN Observation_TOKEN_VALUES AS param0\n-                        //     ON param0.PARAMETER_NAME_ID=1191 AND param0.TOKEN_VALUE = :p1\n-                        //    AND param0.LOGICAL_RESOURCE_ID = LR.LOGICAL_RESOURCE_ID\n-\n                         final String paramTableAlias = \"param\" + i;\n-                        final String onFilter = querySegment.getQueryString().replaceAll(PARAMETER_TABLE_ALIAS + \"\\\\.\", paramTableAlias + \".\");\n-\n-                        whereClause.append(JOIN);\n-                        whereClause.append(tableName(overrideType, param));\n-                        whereClause.append(\" AS \" + paramTableAlias);\n-                        whereClause.append(ON);\n-                        whereClause.append(onFilter);\n-                        whereClause.append(\" AND LR.LOGICAL_RESOURCE_ID = \" + paramTableAlias + \".LOGICAL_RESOURCE_ID\");\n+                        if (param.isReverseChained()) {\n+                            // Join on a select from logical resource table", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7cf5dad7cb56ff76579a60579b11cc834f380021"}, "originalPosition": 27}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0MzE4MjYw", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-524318260", "createdAt": "2020-11-05T14:31:47Z", "commit": {"oid": "7cf5dad7cb56ff76579a60579b11cc834f380021"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNDozMTo0N1rOHuF_bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNDozMTo0N1rOHuF_bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA5NDcwMg==", "bodyText": "I'll raise a backlog issue. QueryParameter could use some Javadoc love.", "url": "https://github.com/IBM/FHIR/pull/1666#discussion_r518094702", "createdAt": "2020-11-05T14:31:47Z", "author": {"login": "punktilious"}, "path": "fhir-search/src/main/java/com/ibm/fhir/search/parameters/QueryParameter.java", "diffHunk": "@@ -44,6 +45,11 @@ public QueryParameter(Type type, String code, Modifier modifier, String modifier\n         this.isInclusionCriteria = isInclusionCriteria;\n     }\n \n+    public QueryParameter(Type type, String code, Modifier modifier, String modifierResourceTypeName, boolean isInclusionCriteria, boolean isReverseChained) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7cf5dad7cb56ff76579a60579b11cc834f380021"}, "originalPosition": 12}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "160a708b5acef30c4bd468a5239d152c4fba137d", "author": {"user": {"login": "michaelwschroeder", "name": "Michael W Schroeder"}}, "url": "https://github.com/IBM/FHIR/commit/160a708b5acef30c4bd468a5239d152c4fba137d", "committedDate": "2020-11-05T16:51:29Z", "message": "Issue #1218 - updates after review comments\n\nSigned-off-by: Mike Schroeder <mschroed@us.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0Nzc4MjAw", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-524778200", "createdAt": "2020-11-06T00:37:26Z", "commit": {"oid": "160a708b5acef30c4bd468a5239d152c4fba137d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI1ODQ5Nzkz", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-525849793", "createdAt": "2020-11-08T22:06:30Z", "commit": {"oid": "160a708b5acef30c4bd468a5239d152c4fba137d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8de7c691542d7272cd364472a55166863650086a", "author": {"user": {"login": "lmsurpre", "name": "Lee Surprenant"}}, "url": "https://github.com/IBM/FHIR/commit/8de7c691542d7272cd364472a55166863650086a", "committedDate": "2020-11-09T03:52:27Z", "message": "issue #1673 - change default ordering\n\nPreviously, we used a default sort of RESOURCE_ID ASC (the row identifier of the resource version being returned).\nWhile investigating #1673, I noticed that removing this sort took this query from 10 seconds down to 3-4 seconds.\n\nHowever, having *some* sort order is important, so that we get consistent page results.\nUpon further inspection, I found that changing the default sort to LOGICAL_RESOURCE_ID (the row identifier of the logical resource row being returned)\nyielded a similar performance boost and so this is the proposed change.\n\nSigned-off-by: Lee Surprenant <lmsurpre@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e38e6a395e6c6dd163a773d4c13a6748a719ec1", "author": {"user": {"login": "lmsurpre", "name": "Lee Surprenant"}}, "url": "https://github.com/IBM/FHIR/commit/9e38e6a395e6c6dd163a773d4c13a6748a719ec1", "committedDate": "2020-11-09T20:14:32Z", "message": "Merge pull request #1678 from IBM/lee-master\n\nSigned-off-by: Lee Surprenant <lmsurpre@us.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NjU3NzUx", "url": "https://github.com/IBM/FHIR/pull/1666#pullrequestreview-526657751", "createdAt": "2020-11-09T21:11:55Z", "commit": {"oid": "9e38e6a395e6c6dd163a773d4c13a6748a719ec1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 748, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}