{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMyNzg2MjIw", "number": 1220, "reviewThreads": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMTo0ODozOFrOEEpjCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMjo1ODoxNFrOEEq4kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMzEwNDczOnYy", "diffSide": "RIGHT", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/api/TenantStatus.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMTo0ODozOFrOGiZwFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMjo1NjowM1rOGib1XQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcyNjY3Ng==", "bodyText": "interesting idea of tenant pooling. that means we can  pre-allocate some tenants and then associate them later with tenant names.", "url": "https://github.com/IBM/FHIR/pull/1220#discussion_r438726676", "createdAt": "2020-06-11T11:48:38Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/api/TenantStatus.java", "diffHunk": "@@ -10,9 +10,9 @@\n  * Tenant Status Enumeration\n  */\n public enum TenantStatus {\n-    PROVISIONING,\n-    FREE,\n-    ALLOCATED,\n-    FROZEN,\n-    DROPPED\n+    PROVISIONING, // in the process of adding the partitions to the schema\n+    FREE,         // unused tenant, available for allocation (e.g. tenant pooling)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15625b8715507454043b8708e63ac7a549483880"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc2MDc5Nw==", "bodyText": "Yes, that was discussed to improve cloud provisioning time for new customers. Still a placeholder, because this requires additional work for cloud integration support.", "url": "https://github.com/IBM/FHIR/pull/1220#discussion_r438760797", "createdAt": "2020-06-11T12:56:03Z", "author": {"login": "punktilious"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/api/TenantStatus.java", "diffHunk": "@@ -10,9 +10,9 @@\n  * Tenant Status Enumeration\n  */\n public enum TenantStatus {\n-    PROVISIONING,\n-    FREE,\n-    ALLOCATED,\n-    FROZEN,\n-    DROPPED\n+    PROVISIONING, // in the process of adding the partitions to the schema\n+    FREE,         // unused tenant, available for allocation (e.g. tenant pooling)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcyNjY3Ng=="}, "originalCommit": {"oid": "15625b8715507454043b8708e63ac7a549483880"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMzEyODU3OnYy", "diffSide": "RIGHT", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/db2/Db2Adapter.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMTo1Njo0OFrOGiZ_Sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNDoyMTowMlrOGifoiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczMDU3MA==", "bodyText": "this does remind me a question, if a new table is added to the schema during the schema upgrade, will the according partitions be created automatically for all tenants in this schema?", "url": "https://github.com/IBM/FHIR/pull/1220#discussion_r438730570", "createdAt": "2020-06-11T11:56:48Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/db2/Db2Adapter.java", "diffHunk": "@@ -365,43 +365,83 @@ public void detachPartition(String schemaName, String tableName, String partitio\n         final String qname = DataDefinitionUtil.getQualifiedName(schemaName, tableName);\n         final String detachedName = DataDefinitionUtil.getQualifiedName(schemaName, intoTableName);\n         final String ddl = \"ALTER TABLE \" + qname + \" DETACH PARTITION \" + partitionName + \" INTO \" + detachedName;\n-        runStatement(ddl);\n+        \n+        try {\n+            runStatement(ddl);\n+        }\n+        catch (DataAccessException x) {\n+            // Suppress the error, in case this is an older version and we have a new table\n+            logger.warning(\"Detach partition skipped for '\" + qname + \"/\" + partitionName + \"'. Reason: \" + x.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15625b8715507454043b8708e63ac7a549483880"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczMzQ3MQ==", "bodyText": "and if loadPartitionInfoMap(partitionInfoMap, schemaName) get partition info from database partition system table, why can we still run into this dataaccesexeption? I mean if a partition already has already been created in a table, not sure why this can fail ...", "url": "https://github.com/IBM/FHIR/pull/1220#discussion_r438733471", "createdAt": "2020-06-11T12:02:51Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/db2/Db2Adapter.java", "diffHunk": "@@ -365,43 +365,83 @@ public void detachPartition(String schemaName, String tableName, String partitio\n         final String qname = DataDefinitionUtil.getQualifiedName(schemaName, tableName);\n         final String detachedName = DataDefinitionUtil.getQualifiedName(schemaName, intoTableName);\n         final String ddl = \"ALTER TABLE \" + qname + \" DETACH PARTITION \" + partitionName + \" INTO \" + detachedName;\n-        runStatement(ddl);\n+        \n+        try {\n+            runStatement(ddl);\n+        }\n+        catch (DataAccessException x) {\n+            // Suppress the error, in case this is an older version and we have a new table\n+            logger.warning(\"Detach partition skipped for '\" + qname + \"/\" + partitionName + \"'. Reason: \" + x.getMessage());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczMDU3MA=="}, "originalCommit": {"oid": "15625b8715507454043b8708e63ac7a549483880"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc2MzUxMQ==", "bodyText": "Good point about adding existing tenant partitions to new tables. I'll create an issue for that. It's fairly easy because all the partitions can be specified in the initial create table DDL.\nRegarding loadPartitionInfoMap, we can still run into an exception there if something goes wrong with the database connection, but at that point it's game over, can't continue.", "url": "https://github.com/IBM/FHIR/pull/1220#discussion_r438763511", "createdAt": "2020-06-11T13:00:50Z", "author": {"login": "punktilious"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/db2/Db2Adapter.java", "diffHunk": "@@ -365,43 +365,83 @@ public void detachPartition(String schemaName, String tableName, String partitio\n         final String qname = DataDefinitionUtil.getQualifiedName(schemaName, tableName);\n         final String detachedName = DataDefinitionUtil.getQualifiedName(schemaName, intoTableName);\n         final String ddl = \"ALTER TABLE \" + qname + \" DETACH PARTITION \" + partitionName + \" INTO \" + detachedName;\n-        runStatement(ddl);\n+        \n+        try {\n+            runStatement(ddl);\n+        }\n+        catch (DataAccessException x) {\n+            // Suppress the error, in case this is an older version and we have a new table\n+            logger.warning(\"Detach partition skipped for '\" + qname + \"/\" + partitionName + \"'. Reason: \" + x.getMessage());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczMDU3MA=="}, "originalCommit": {"oid": "15625b8715507454043b8708e63ac7a549483880"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgyMzA0OA==", "bodyText": "creating an issue for partitions creation for existing tenants for new table is great, thanks!", "url": "https://github.com/IBM/FHIR/pull/1220#discussion_r438823048", "createdAt": "2020-06-11T14:21:02Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/db2/Db2Adapter.java", "diffHunk": "@@ -365,43 +365,83 @@ public void detachPartition(String schemaName, String tableName, String partitio\n         final String qname = DataDefinitionUtil.getQualifiedName(schemaName, tableName);\n         final String detachedName = DataDefinitionUtil.getQualifiedName(schemaName, intoTableName);\n         final String ddl = \"ALTER TABLE \" + qname + \" DETACH PARTITION \" + partitionName + \" INTO \" + detachedName;\n-        runStatement(ddl);\n+        \n+        try {\n+            runStatement(ddl);\n+        }\n+        catch (DataAccessException x) {\n+            // Suppress the error, in case this is an older version and we have a new table\n+            logger.warning(\"Detach partition skipped for '\" + qname + \"/\" + partitionName + \"'. Reason: \" + x.getMessage());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczMDU3MA=="}, "originalCommit": {"oid": "15625b8715507454043b8708e63ac7a549483880"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMzE1MTA5OnYy", "diffSide": "RIGHT", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/db2/Db2Adapter.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMjowNDoyOFrOGiaNVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNToyMjoxOFrOGiiQeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczNDE2Ng==", "bodyText": "format, could you move \"else {\" to the above line", "url": "https://github.com/IBM/FHIR/pull/1220#discussion_r438734166", "createdAt": "2020-06-11T12:04:28Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/db2/Db2Adapter.java", "diffHunk": "@@ -365,43 +365,83 @@ public void detachPartition(String schemaName, String tableName, String partitio\n         final String qname = DataDefinitionUtil.getQualifiedName(schemaName, tableName);\n         final String detachedName = DataDefinitionUtil.getQualifiedName(schemaName, intoTableName);\n         final String ddl = \"ALTER TABLE \" + qname + \" DETACH PARTITION \" + partitionName + \" INTO \" + detachedName;\n-        runStatement(ddl);\n+        \n+        try {\n+            runStatement(ddl);\n+        }\n+        catch (DataAccessException x) {\n+            // Suppress the error, in case this is an older version and we have a new table\n+            logger.warning(\"Detach partition skipped for '\" + qname + \"/\" + partitionName + \"'. Reason: \" + x.getMessage());\n+        }\n     }\n \n     @Override\n-    public void removeTenantPartitions(Collection<Table> tables, String schemaName, int tenantId,\n-            String tenantStagingTable) {\n+    public void removeTenantPartitions(Collection<Table> tables, String schemaName, int tenantId) {\n \n+        // Identify all the partitioned tables contained within schemaName\n         Map<String, PartitionInfo> partitionInfoMap = new HashMap<>();\n         loadPartitionInfoMap(partitionInfoMap, schemaName);\n \n         for (Table t: tables) {\n-            PartitionInfo pi = partitionInfoMap.get(t.getName());\n+            PartitionInfo pi = partitionInfoMap.get(t.getObjectName());\n             if (pi == null) {\n                 // We should only be dealing with partitioned tables at this stage, so this\n                 // is a fatal error\n-                String qualifiedName = DataDefinitionUtil.getQualifiedName(schemaName, t.getName());\n+                String qualifiedName = DataDefinitionUtil.getQualifiedName(schemaName, t.getObjectName());\n                 throw new DataAccessException(\"No partition information found for table: \" + qualifiedName);\n             }\n             else {\n                 final String partitionName = \"TENANT\" + tenantId;\n-                final String targetTableName = DataDefinitionUtil.getQualifiedName(schemaName, t.getName() + \"_\" + partitionName);\n-                removeTenantPartition(schemaName, t.getName(), partitionName, targetTableName, tenantStagingTable);\n+                final String targetTableName = getDetachedPartitionTableName(t, tenantId);\n+                detachPartition(schemaName, t.getObjectName(), partitionName, targetTableName);\n             }\n         }\n     }\n \n-    protected void removeTenantPartition(String schemaName, String tableName, String partitionName, String targetTableName,\n-            String tenantStagingTable) {\n-\n-        // Detach the given partition of the table into the targetTableName (within the same schema).\n-        detachPartition(schemaName, tableName, partitionName, targetTableName);\n+    @Override\n+    public void dropDetachedPartitions(Collection<Table> tables, String schemaName, int tenantId) {\n \n-        // We need to add this target table name to the tenantStagingTable so that we\n-        // can remember to delete it later...an operation which can only be done in\n-        // a new transaction\n-        Db2AddTableToStaging cmd = new Db2AddTableToStaging(schemaName, tenantStagingTable, targetTableName);\n-        runStatement(cmd);\n+        // Only process tables which are partitioned\n+        Map<String, PartitionInfo> partitionInfoMap = new HashMap<>();\n+        loadPartitionInfoMap(partitionInfoMap, schemaName);\n+        \n+        for (Table t : tables) {\n+            PartitionInfo pi = partitionInfoMap.get(t.getObjectName());\n+            if (pi == null) {\n+                // We should only be dealing with partitioned tables at this stage, so this\n+                // is a fatal error\n+                String qualifiedName = DataDefinitionUtil.getQualifiedName(schemaName, t.getObjectName());\n+                throw new DataAccessException(\"No partition information found for table: \" + qualifiedName);\n+            } \n+            else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15625b8715507454043b8708e63ac7a549483880"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc2NDUyNA==", "bodyText": "Have we now officially changed that style? I've been using the other style for everything here.", "url": "https://github.com/IBM/FHIR/pull/1220#discussion_r438764524", "createdAt": "2020-06-11T13:02:38Z", "author": {"login": "punktilious"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/db2/Db2Adapter.java", "diffHunk": "@@ -365,43 +365,83 @@ public void detachPartition(String schemaName, String tableName, String partitio\n         final String qname = DataDefinitionUtil.getQualifiedName(schemaName, tableName);\n         final String detachedName = DataDefinitionUtil.getQualifiedName(schemaName, intoTableName);\n         final String ddl = \"ALTER TABLE \" + qname + \" DETACH PARTITION \" + partitionName + \" INTO \" + detachedName;\n-        runStatement(ddl);\n+        \n+        try {\n+            runStatement(ddl);\n+        }\n+        catch (DataAccessException x) {\n+            // Suppress the error, in case this is an older version and we have a new table\n+            logger.warning(\"Detach partition skipped for '\" + qname + \"/\" + partitionName + \"'. Reason: \" + x.getMessage());\n+        }\n     }\n \n     @Override\n-    public void removeTenantPartitions(Collection<Table> tables, String schemaName, int tenantId,\n-            String tenantStagingTable) {\n+    public void removeTenantPartitions(Collection<Table> tables, String schemaName, int tenantId) {\n \n+        // Identify all the partitioned tables contained within schemaName\n         Map<String, PartitionInfo> partitionInfoMap = new HashMap<>();\n         loadPartitionInfoMap(partitionInfoMap, schemaName);\n \n         for (Table t: tables) {\n-            PartitionInfo pi = partitionInfoMap.get(t.getName());\n+            PartitionInfo pi = partitionInfoMap.get(t.getObjectName());\n             if (pi == null) {\n                 // We should only be dealing with partitioned tables at this stage, so this\n                 // is a fatal error\n-                String qualifiedName = DataDefinitionUtil.getQualifiedName(schemaName, t.getName());\n+                String qualifiedName = DataDefinitionUtil.getQualifiedName(schemaName, t.getObjectName());\n                 throw new DataAccessException(\"No partition information found for table: \" + qualifiedName);\n             }\n             else {\n                 final String partitionName = \"TENANT\" + tenantId;\n-                final String targetTableName = DataDefinitionUtil.getQualifiedName(schemaName, t.getName() + \"_\" + partitionName);\n-                removeTenantPartition(schemaName, t.getName(), partitionName, targetTableName, tenantStagingTable);\n+                final String targetTableName = getDetachedPartitionTableName(t, tenantId);\n+                detachPartition(schemaName, t.getObjectName(), partitionName, targetTableName);\n             }\n         }\n     }\n \n-    protected void removeTenantPartition(String schemaName, String tableName, String partitionName, String targetTableName,\n-            String tenantStagingTable) {\n-\n-        // Detach the given partition of the table into the targetTableName (within the same schema).\n-        detachPartition(schemaName, tableName, partitionName, targetTableName);\n+    @Override\n+    public void dropDetachedPartitions(Collection<Table> tables, String schemaName, int tenantId) {\n \n-        // We need to add this target table name to the tenantStagingTable so that we\n-        // can remember to delete it later...an operation which can only be done in\n-        // a new transaction\n-        Db2AddTableToStaging cmd = new Db2AddTableToStaging(schemaName, tenantStagingTable, targetTableName);\n-        runStatement(cmd);\n+        // Only process tables which are partitioned\n+        Map<String, PartitionInfo> partitionInfoMap = new HashMap<>();\n+        loadPartitionInfoMap(partitionInfoMap, schemaName);\n+        \n+        for (Table t : tables) {\n+            PartitionInfo pi = partitionInfoMap.get(t.getObjectName());\n+            if (pi == null) {\n+                // We should only be dealing with partitioned tables at this stage, so this\n+                // is a fatal error\n+                String qualifiedName = DataDefinitionUtil.getQualifiedName(schemaName, t.getObjectName());\n+                throw new DataAccessException(\"No partition information found for table: \" + qualifiedName);\n+            } \n+            else {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczNDE2Ng=="}, "originalCommit": {"oid": "15625b8715507454043b8708e63ac7a549483880"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgyNDk0Ng==", "bodyText": "yes, Paul reminded me a couple of times about this code style, and I followed your code style when I was changing persistence codes, and I had moved to the suggested code style per comments from Paul.", "url": "https://github.com/IBM/FHIR/pull/1220#discussion_r438824946", "createdAt": "2020-06-11T14:23:47Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/db2/Db2Adapter.java", "diffHunk": "@@ -365,43 +365,83 @@ public void detachPartition(String schemaName, String tableName, String partitio\n         final String qname = DataDefinitionUtil.getQualifiedName(schemaName, tableName);\n         final String detachedName = DataDefinitionUtil.getQualifiedName(schemaName, intoTableName);\n         final String ddl = \"ALTER TABLE \" + qname + \" DETACH PARTITION \" + partitionName + \" INTO \" + detachedName;\n-        runStatement(ddl);\n+        \n+        try {\n+            runStatement(ddl);\n+        }\n+        catch (DataAccessException x) {\n+            // Suppress the error, in case this is an older version and we have a new table\n+            logger.warning(\"Detach partition skipped for '\" + qname + \"/\" + partitionName + \"'. Reason: \" + x.getMessage());\n+        }\n     }\n \n     @Override\n-    public void removeTenantPartitions(Collection<Table> tables, String schemaName, int tenantId,\n-            String tenantStagingTable) {\n+    public void removeTenantPartitions(Collection<Table> tables, String schemaName, int tenantId) {\n \n+        // Identify all the partitioned tables contained within schemaName\n         Map<String, PartitionInfo> partitionInfoMap = new HashMap<>();\n         loadPartitionInfoMap(partitionInfoMap, schemaName);\n \n         for (Table t: tables) {\n-            PartitionInfo pi = partitionInfoMap.get(t.getName());\n+            PartitionInfo pi = partitionInfoMap.get(t.getObjectName());\n             if (pi == null) {\n                 // We should only be dealing with partitioned tables at this stage, so this\n                 // is a fatal error\n-                String qualifiedName = DataDefinitionUtil.getQualifiedName(schemaName, t.getName());\n+                String qualifiedName = DataDefinitionUtil.getQualifiedName(schemaName, t.getObjectName());\n                 throw new DataAccessException(\"No partition information found for table: \" + qualifiedName);\n             }\n             else {\n                 final String partitionName = \"TENANT\" + tenantId;\n-                final String targetTableName = DataDefinitionUtil.getQualifiedName(schemaName, t.getName() + \"_\" + partitionName);\n-                removeTenantPartition(schemaName, t.getName(), partitionName, targetTableName, tenantStagingTable);\n+                final String targetTableName = getDetachedPartitionTableName(t, tenantId);\n+                detachPartition(schemaName, t.getObjectName(), partitionName, targetTableName);\n             }\n         }\n     }\n \n-    protected void removeTenantPartition(String schemaName, String tableName, String partitionName, String targetTableName,\n-            String tenantStagingTable) {\n-\n-        // Detach the given partition of the table into the targetTableName (within the same schema).\n-        detachPartition(schemaName, tableName, partitionName, targetTableName);\n+    @Override\n+    public void dropDetachedPartitions(Collection<Table> tables, String schemaName, int tenantId) {\n \n-        // We need to add this target table name to the tenantStagingTable so that we\n-        // can remember to delete it later...an operation which can only be done in\n-        // a new transaction\n-        Db2AddTableToStaging cmd = new Db2AddTableToStaging(schemaName, tenantStagingTable, targetTableName);\n-        runStatement(cmd);\n+        // Only process tables which are partitioned\n+        Map<String, PartitionInfo> partitionInfoMap = new HashMap<>();\n+        loadPartitionInfoMap(partitionInfoMap, schemaName);\n+        \n+        for (Table t : tables) {\n+            PartitionInfo pi = partitionInfoMap.get(t.getObjectName());\n+            if (pi == null) {\n+                // We should only be dealing with partitioned tables at this stage, so this\n+                // is a fatal error\n+                String qualifiedName = DataDefinitionUtil.getQualifiedName(schemaName, t.getObjectName());\n+                throw new DataAccessException(\"No partition information found for table: \" + qualifiedName);\n+            } \n+            else {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczNDE2Ng=="}, "originalCommit": {"oid": "15625b8715507454043b8708e63ac7a549483880"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg2NjA0Mg==", "bodyText": "done", "url": "https://github.com/IBM/FHIR/pull/1220#discussion_r438866042", "createdAt": "2020-06-11T15:22:18Z", "author": {"login": "punktilious"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/db2/Db2Adapter.java", "diffHunk": "@@ -365,43 +365,83 @@ public void detachPartition(String schemaName, String tableName, String partitio\n         final String qname = DataDefinitionUtil.getQualifiedName(schemaName, tableName);\n         final String detachedName = DataDefinitionUtil.getQualifiedName(schemaName, intoTableName);\n         final String ddl = \"ALTER TABLE \" + qname + \" DETACH PARTITION \" + partitionName + \" INTO \" + detachedName;\n-        runStatement(ddl);\n+        \n+        try {\n+            runStatement(ddl);\n+        }\n+        catch (DataAccessException x) {\n+            // Suppress the error, in case this is an older version and we have a new table\n+            logger.warning(\"Detach partition skipped for '\" + qname + \"/\" + partitionName + \"'. Reason: \" + x.getMessage());\n+        }\n     }\n \n     @Override\n-    public void removeTenantPartitions(Collection<Table> tables, String schemaName, int tenantId,\n-            String tenantStagingTable) {\n+    public void removeTenantPartitions(Collection<Table> tables, String schemaName, int tenantId) {\n \n+        // Identify all the partitioned tables contained within schemaName\n         Map<String, PartitionInfo> partitionInfoMap = new HashMap<>();\n         loadPartitionInfoMap(partitionInfoMap, schemaName);\n \n         for (Table t: tables) {\n-            PartitionInfo pi = partitionInfoMap.get(t.getName());\n+            PartitionInfo pi = partitionInfoMap.get(t.getObjectName());\n             if (pi == null) {\n                 // We should only be dealing with partitioned tables at this stage, so this\n                 // is a fatal error\n-                String qualifiedName = DataDefinitionUtil.getQualifiedName(schemaName, t.getName());\n+                String qualifiedName = DataDefinitionUtil.getQualifiedName(schemaName, t.getObjectName());\n                 throw new DataAccessException(\"No partition information found for table: \" + qualifiedName);\n             }\n             else {\n                 final String partitionName = \"TENANT\" + tenantId;\n-                final String targetTableName = DataDefinitionUtil.getQualifiedName(schemaName, t.getName() + \"_\" + partitionName);\n-                removeTenantPartition(schemaName, t.getName(), partitionName, targetTableName, tenantStagingTable);\n+                final String targetTableName = getDetachedPartitionTableName(t, tenantId);\n+                detachPartition(schemaName, t.getObjectName(), partitionName, targetTableName);\n             }\n         }\n     }\n \n-    protected void removeTenantPartition(String schemaName, String tableName, String partitionName, String targetTableName,\n-            String tenantStagingTable) {\n-\n-        // Detach the given partition of the table into the targetTableName (within the same schema).\n-        detachPartition(schemaName, tableName, partitionName, targetTableName);\n+    @Override\n+    public void dropDetachedPartitions(Collection<Table> tables, String schemaName, int tenantId) {\n \n-        // We need to add this target table name to the tenantStagingTable so that we\n-        // can remember to delete it later...an operation which can only be done in\n-        // a new transaction\n-        Db2AddTableToStaging cmd = new Db2AddTableToStaging(schemaName, tenantStagingTable, targetTableName);\n-        runStatement(cmd);\n+        // Only process tables which are partitioned\n+        Map<String, PartitionInfo> partitionInfoMap = new HashMap<>();\n+        loadPartitionInfoMap(partitionInfoMap, schemaName);\n+        \n+        for (Table t : tables) {\n+            PartitionInfo pi = partitionInfoMap.get(t.getObjectName());\n+            if (pi == null) {\n+                // We should only be dealing with partitioned tables at this stage, so this\n+                // is a fatal error\n+                String qualifiedName = DataDefinitionUtil.getQualifiedName(schemaName, t.getObjectName());\n+                throw new DataAccessException(\"No partition information found for table: \" + qualifiedName);\n+            } \n+            else {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczNDE2Ng=="}, "originalCommit": {"oid": "15625b8715507454043b8708e63ac7a549483880"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMzE1MzA1OnYy", "diffSide": "RIGHT", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/db2/Db2Adapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMjowNToxMlrOGiaOkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNToyMjozMVrOGiiRFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczNDQ4Mg==", "bodyText": "format, could you more \"catch (Exception x) {\" to above line?", "url": "https://github.com/IBM/FHIR/pull/1220#discussion_r438734482", "createdAt": "2020-06-11T12:05:12Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/db2/Db2Adapter.java", "diffHunk": "@@ -365,43 +365,83 @@ public void detachPartition(String schemaName, String tableName, String partitio\n         final String qname = DataDefinitionUtil.getQualifiedName(schemaName, tableName);\n         final String detachedName = DataDefinitionUtil.getQualifiedName(schemaName, intoTableName);\n         final String ddl = \"ALTER TABLE \" + qname + \" DETACH PARTITION \" + partitionName + \" INTO \" + detachedName;\n-        runStatement(ddl);\n+        \n+        try {\n+            runStatement(ddl);\n+        }\n+        catch (DataAccessException x) {\n+            // Suppress the error, in case this is an older version and we have a new table\n+            logger.warning(\"Detach partition skipped for '\" + qname + \"/\" + partitionName + \"'. Reason: \" + x.getMessage());\n+        }\n     }\n \n     @Override\n-    public void removeTenantPartitions(Collection<Table> tables, String schemaName, int tenantId,\n-            String tenantStagingTable) {\n+    public void removeTenantPartitions(Collection<Table> tables, String schemaName, int tenantId) {\n \n+        // Identify all the partitioned tables contained within schemaName\n         Map<String, PartitionInfo> partitionInfoMap = new HashMap<>();\n         loadPartitionInfoMap(partitionInfoMap, schemaName);\n \n         for (Table t: tables) {\n-            PartitionInfo pi = partitionInfoMap.get(t.getName());\n+            PartitionInfo pi = partitionInfoMap.get(t.getObjectName());\n             if (pi == null) {\n                 // We should only be dealing with partitioned tables at this stage, so this\n                 // is a fatal error\n-                String qualifiedName = DataDefinitionUtil.getQualifiedName(schemaName, t.getName());\n+                String qualifiedName = DataDefinitionUtil.getQualifiedName(schemaName, t.getObjectName());\n                 throw new DataAccessException(\"No partition information found for table: \" + qualifiedName);\n             }\n             else {\n                 final String partitionName = \"TENANT\" + tenantId;\n-                final String targetTableName = DataDefinitionUtil.getQualifiedName(schemaName, t.getName() + \"_\" + partitionName);\n-                removeTenantPartition(schemaName, t.getName(), partitionName, targetTableName, tenantStagingTable);\n+                final String targetTableName = getDetachedPartitionTableName(t, tenantId);\n+                detachPartition(schemaName, t.getObjectName(), partitionName, targetTableName);\n             }\n         }\n     }\n \n-    protected void removeTenantPartition(String schemaName, String tableName, String partitionName, String targetTableName,\n-            String tenantStagingTable) {\n-\n-        // Detach the given partition of the table into the targetTableName (within the same schema).\n-        detachPartition(schemaName, tableName, partitionName, targetTableName);\n+    @Override\n+    public void dropDetachedPartitions(Collection<Table> tables, String schemaName, int tenantId) {\n \n-        // We need to add this target table name to the tenantStagingTable so that we\n-        // can remember to delete it later...an operation which can only be done in\n-        // a new transaction\n-        Db2AddTableToStaging cmd = new Db2AddTableToStaging(schemaName, tenantStagingTable, targetTableName);\n-        runStatement(cmd);\n+        // Only process tables which are partitioned\n+        Map<String, PartitionInfo> partitionInfoMap = new HashMap<>();\n+        loadPartitionInfoMap(partitionInfoMap, schemaName);\n+        \n+        for (Table t : tables) {\n+            PartitionInfo pi = partitionInfoMap.get(t.getObjectName());\n+            if (pi == null) {\n+                // We should only be dealing with partitioned tables at this stage, so this\n+                // is a fatal error\n+                String qualifiedName = DataDefinitionUtil.getQualifiedName(schemaName, t.getObjectName());\n+                throw new DataAccessException(\"No partition information found for table: \" + qualifiedName);\n+            } \n+            else {\n+                // drop the table which now represents the detached partition\n+                final String detachedPartitionTableName = getDetachedPartitionTableName(t, tenantId);\n+                try {\n+                    logger.info(\"Dropping detached partition (table): '\" + detachedPartitionTableName + \"'\");\n+                    dropTable(schemaName, detachedPartitionTableName);\n+                } \n+                catch (Exception x) {\n+                    // we want this to be idempotent, so we suppress propagation of any error", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15625b8715507454043b8708e63ac7a549483880"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg2NjE5OQ==", "bodyText": "done", "url": "https://github.com/IBM/FHIR/pull/1220#discussion_r438866199", "createdAt": "2020-06-11T15:22:31Z", "author": {"login": "punktilious"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/db2/Db2Adapter.java", "diffHunk": "@@ -365,43 +365,83 @@ public void detachPartition(String schemaName, String tableName, String partitio\n         final String qname = DataDefinitionUtil.getQualifiedName(schemaName, tableName);\n         final String detachedName = DataDefinitionUtil.getQualifiedName(schemaName, intoTableName);\n         final String ddl = \"ALTER TABLE \" + qname + \" DETACH PARTITION \" + partitionName + \" INTO \" + detachedName;\n-        runStatement(ddl);\n+        \n+        try {\n+            runStatement(ddl);\n+        }\n+        catch (DataAccessException x) {\n+            // Suppress the error, in case this is an older version and we have a new table\n+            logger.warning(\"Detach partition skipped for '\" + qname + \"/\" + partitionName + \"'. Reason: \" + x.getMessage());\n+        }\n     }\n \n     @Override\n-    public void removeTenantPartitions(Collection<Table> tables, String schemaName, int tenantId,\n-            String tenantStagingTable) {\n+    public void removeTenantPartitions(Collection<Table> tables, String schemaName, int tenantId) {\n \n+        // Identify all the partitioned tables contained within schemaName\n         Map<String, PartitionInfo> partitionInfoMap = new HashMap<>();\n         loadPartitionInfoMap(partitionInfoMap, schemaName);\n \n         for (Table t: tables) {\n-            PartitionInfo pi = partitionInfoMap.get(t.getName());\n+            PartitionInfo pi = partitionInfoMap.get(t.getObjectName());\n             if (pi == null) {\n                 // We should only be dealing with partitioned tables at this stage, so this\n                 // is a fatal error\n-                String qualifiedName = DataDefinitionUtil.getQualifiedName(schemaName, t.getName());\n+                String qualifiedName = DataDefinitionUtil.getQualifiedName(schemaName, t.getObjectName());\n                 throw new DataAccessException(\"No partition information found for table: \" + qualifiedName);\n             }\n             else {\n                 final String partitionName = \"TENANT\" + tenantId;\n-                final String targetTableName = DataDefinitionUtil.getQualifiedName(schemaName, t.getName() + \"_\" + partitionName);\n-                removeTenantPartition(schemaName, t.getName(), partitionName, targetTableName, tenantStagingTable);\n+                final String targetTableName = getDetachedPartitionTableName(t, tenantId);\n+                detachPartition(schemaName, t.getObjectName(), partitionName, targetTableName);\n             }\n         }\n     }\n \n-    protected void removeTenantPartition(String schemaName, String tableName, String partitionName, String targetTableName,\n-            String tenantStagingTable) {\n-\n-        // Detach the given partition of the table into the targetTableName (within the same schema).\n-        detachPartition(schemaName, tableName, partitionName, targetTableName);\n+    @Override\n+    public void dropDetachedPartitions(Collection<Table> tables, String schemaName, int tenantId) {\n \n-        // We need to add this target table name to the tenantStagingTable so that we\n-        // can remember to delete it later...an operation which can only be done in\n-        // a new transaction\n-        Db2AddTableToStaging cmd = new Db2AddTableToStaging(schemaName, tenantStagingTable, targetTableName);\n-        runStatement(cmd);\n+        // Only process tables which are partitioned\n+        Map<String, PartitionInfo> partitionInfoMap = new HashMap<>();\n+        loadPartitionInfoMap(partitionInfoMap, schemaName);\n+        \n+        for (Table t : tables) {\n+            PartitionInfo pi = partitionInfoMap.get(t.getObjectName());\n+            if (pi == null) {\n+                // We should only be dealing with partitioned tables at this stage, so this\n+                // is a fatal error\n+                String qualifiedName = DataDefinitionUtil.getQualifiedName(schemaName, t.getObjectName());\n+                throw new DataAccessException(\"No partition information found for table: \" + qualifiedName);\n+            } \n+            else {\n+                // drop the table which now represents the detached partition\n+                final String detachedPartitionTableName = getDetachedPartitionTableName(t, tenantId);\n+                try {\n+                    logger.info(\"Dropping detached partition (table): '\" + detachedPartitionTableName + \"'\");\n+                    dropTable(schemaName, detachedPartitionTableName);\n+                } \n+                catch (Exception x) {\n+                    // we want this to be idempotent, so we suppress propagation of any error", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczNDQ4Mg=="}, "originalCommit": {"oid": "15625b8715507454043b8708e63ac7a549483880"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMzE3NzQwOnYy", "diffSide": "RIGHT", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/db2/Db2Adapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMjoxMzozOVrOGiaeGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNToyMjozOVrOGiiRnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczODQ1Ng==", "bodyText": "format, how about moving \"catch (DataAccessException x) {\" to above line?", "url": "https://github.com/IBM/FHIR/pull/1220#discussion_r438738456", "createdAt": "2020-06-11T12:13:39Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/db2/Db2Adapter.java", "diffHunk": "@@ -365,43 +365,83 @@ public void detachPartition(String schemaName, String tableName, String partitio\n         final String qname = DataDefinitionUtil.getQualifiedName(schemaName, tableName);\n         final String detachedName = DataDefinitionUtil.getQualifiedName(schemaName, intoTableName);\n         final String ddl = \"ALTER TABLE \" + qname + \" DETACH PARTITION \" + partitionName + \" INTO \" + detachedName;\n-        runStatement(ddl);\n+        \n+        try {\n+            runStatement(ddl);\n+        }\n+        catch (DataAccessException x) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15625b8715507454043b8708e63ac7a549483880"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg2NjMzMg==", "bodyText": "done", "url": "https://github.com/IBM/FHIR/pull/1220#discussion_r438866332", "createdAt": "2020-06-11T15:22:39Z", "author": {"login": "punktilious"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/db2/Db2Adapter.java", "diffHunk": "@@ -365,43 +365,83 @@ public void detachPartition(String schemaName, String tableName, String partitio\n         final String qname = DataDefinitionUtil.getQualifiedName(schemaName, tableName);\n         final String detachedName = DataDefinitionUtil.getQualifiedName(schemaName, intoTableName);\n         final String ddl = \"ALTER TABLE \" + qname + \" DETACH PARTITION \" + partitionName + \" INTO \" + detachedName;\n-        runStatement(ddl);\n+        \n+        try {\n+            runStatement(ddl);\n+        }\n+        catch (DataAccessException x) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczODQ1Ng=="}, "originalCommit": {"oid": "15625b8715507454043b8708e63ac7a549483880"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMzE4OTQ5OnYy", "diffSide": "RIGHT", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/model/DataModelVisitor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMjoxNzozNlrOGial0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMzoxMjowOVrOGicaCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc0MDQzMw==", "bodyText": "curious, why using \"visited\" instead of \"visit\"?", "url": "https://github.com/IBM/FHIR/pull/1220#discussion_r438740433", "createdAt": "2020-06-11T12:17:36Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/model/DataModelVisitor.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package com.ibm.fhir.database.utils.model;\n+\n+\n+/**\n+ * Visitor interface used to traverse the PhysicalDataModel\n+ */\n+public interface DataModelVisitor {\n+\n+    /**\n+     * Process a foreign key constraint from the model\n+     * @param fk\n+     */\n+    public void visited(Table fromChildTable, ForeignKeyConstraint fk);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15625b8715507454043b8708e63ac7a549483880"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc3MDE4NA==", "bodyText": "It's on the receiving side. It's just to differentiate from the visit(...) call on the model object itself (e.g. Table) which is the thing being visited. The DataModelVisitor goes to visit(...) each object in the PhysicalDataModel, and each object then tells the visitor, \"hey, you've visited(...) me\". That's the logic I use in my head.", "url": "https://github.com/IBM/FHIR/pull/1220#discussion_r438770184", "createdAt": "2020-06-11T13:12:09Z", "author": {"login": "punktilious"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/model/DataModelVisitor.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package com.ibm.fhir.database.utils.model;\n+\n+\n+/**\n+ * Visitor interface used to traverse the PhysicalDataModel\n+ */\n+public interface DataModelVisitor {\n+\n+    /**\n+     * Process a foreign key constraint from the model\n+     * @param fk\n+     */\n+    public void visited(Table fromChildTable, ForeignKeyConstraint fk);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc0MDQzMw=="}, "originalCommit": {"oid": "15625b8715507454043b8708e63ac7a549483880"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMzIwOTU2OnYy", "diffSide": "RIGHT", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/tenant/DeleteTenantDAO.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMjoyNDoxMlrOGiayjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMjoyNDoxMlrOGiayjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc0MzY5NA==", "bodyText": "move \"catch (SQLException x) {\" to above line?", "url": "https://github.com/IBM/FHIR/pull/1220#discussion_r438743694", "createdAt": "2020-06-11T12:24:12Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/tenant/DeleteTenantDAO.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.tenant;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.database.utils.api.DataAccessException;\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.database.utils.api.TenantStatus;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+\n+/**\n+ * Delete the tenant meta-data after it has been dropped. Deletes\n+ * data in TENANT_KEYS and TENANTS.\n+ */\n+public class DeleteTenantDAO implements IDatabaseStatement {\n+    private final String schemaName;\n+    private final int tenantId;\n+    \n+    /**\n+     * Get partition information for all tables in the tableSchema, using\n+     * the catalogSchema as the schema containing the DATAPARTITIONS system table\n+     * \n+     * @param schemaName the name of the admin schema hosting the tenants and tenant_keys tables\n+     * @param tenantId the id of the tenant to delete\n+     */\n+    public DeleteTenantDAO(String schemaName, int tenantId) {\n+        DataDefinitionUtil.assertValidName(schemaName);\n+        this.schemaName = schemaName;\n+        this.tenantId = tenantId;\n+    }\n+    \n+    @Override\n+    public void run(IDatabaseTranslator translator, Connection c) {\n+        deleteFromTenantKeys(translator, c);\n+        deleteFromTenants(translator, c);\n+    }\n+    \n+    protected void deleteFromTenantKeys(IDatabaseTranslator translator, Connection c) {\n+        final String tableName = DataDefinitionUtil.getQualifiedName(schemaName, \"TENANT_KEYS\");\n+        final String DML = \"\"\n+                + \"   DELETE FROM \" + tableName\n+                + \"    WHERE mt_id = ? \"\n+                ;\n+\n+        try (PreparedStatement ps = c.prepareStatement(DML)) {\n+            ps.setInt(1, tenantId);\n+            ps.executeUpdate();\n+        }\n+        catch (SQLException x) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15625b8715507454043b8708e63ac7a549483880"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMzIxMTQwOnYy", "diffSide": "RIGHT", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/tenant/DeleteTenantDAO.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMjoyNDozN1rOGiazmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNToyMjo1MFrOGiiSLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc0Mzk2Mg==", "bodyText": "move \"catch (SQLException x) {\" to above line?", "url": "https://github.com/IBM/FHIR/pull/1220#discussion_r438743962", "createdAt": "2020-06-11T12:24:37Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/tenant/DeleteTenantDAO.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.tenant;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.database.utils.api.DataAccessException;\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.database.utils.api.TenantStatus;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+\n+/**\n+ * Delete the tenant meta-data after it has been dropped. Deletes\n+ * data in TENANT_KEYS and TENANTS.\n+ */\n+public class DeleteTenantDAO implements IDatabaseStatement {\n+    private final String schemaName;\n+    private final int tenantId;\n+    \n+    /**\n+     * Get partition information for all tables in the tableSchema, using\n+     * the catalogSchema as the schema containing the DATAPARTITIONS system table\n+     * \n+     * @param schemaName the name of the admin schema hosting the tenants and tenant_keys tables\n+     * @param tenantId the id of the tenant to delete\n+     */\n+    public DeleteTenantDAO(String schemaName, int tenantId) {\n+        DataDefinitionUtil.assertValidName(schemaName);\n+        this.schemaName = schemaName;\n+        this.tenantId = tenantId;\n+    }\n+    \n+    @Override\n+    public void run(IDatabaseTranslator translator, Connection c) {\n+        deleteFromTenantKeys(translator, c);\n+        deleteFromTenants(translator, c);\n+    }\n+    \n+    protected void deleteFromTenantKeys(IDatabaseTranslator translator, Connection c) {\n+        final String tableName = DataDefinitionUtil.getQualifiedName(schemaName, \"TENANT_KEYS\");\n+        final String DML = \"\"\n+                + \"   DELETE FROM \" + tableName\n+                + \"    WHERE mt_id = ? \"\n+                ;\n+\n+        try (PreparedStatement ps = c.prepareStatement(DML)) {\n+            ps.setInt(1, tenantId);\n+            ps.executeUpdate();\n+        }\n+        catch (SQLException x) {\n+            // Translate the exception into something a little more meaningful\n+            // for this database type and application\n+            throw translator.translate(x);\n+        }\n+        \n+    }\n+\n+    protected void deleteFromTenants(IDatabaseTranslator translator, Connection c) {\n+        final String tableName = DataDefinitionUtil.getQualifiedName(schemaName, \"TENANTS\");\n+        final String DML = \"\"\n+                + \"   DELETE FROM \" + tableName\n+                + \"    WHERE mt_id = ? \"\n+                + \"      AND tenant_status = ?\"\n+                ;\n+\n+        try (PreparedStatement ps = c.prepareStatement(DML)) {\n+            ps.setInt(1, tenantId);\n+            ps.setString(2, TenantStatus.DROPPED.name());\n+            int rows = ps.executeUpdate();\n+            \n+            if (rows < 1) {\n+                throw new DataAccessException(\"Invalid tenant_id or tenant not DROPPED\");\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15625b8715507454043b8708e63ac7a549483880"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg2NjQ3OA==", "bodyText": "done", "url": "https://github.com/IBM/FHIR/pull/1220#discussion_r438866478", "createdAt": "2020-06-11T15:22:50Z", "author": {"login": "punktilious"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/tenant/DeleteTenantDAO.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.tenant;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.database.utils.api.DataAccessException;\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.database.utils.api.TenantStatus;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+\n+/**\n+ * Delete the tenant meta-data after it has been dropped. Deletes\n+ * data in TENANT_KEYS and TENANTS.\n+ */\n+public class DeleteTenantDAO implements IDatabaseStatement {\n+    private final String schemaName;\n+    private final int tenantId;\n+    \n+    /**\n+     * Get partition information for all tables in the tableSchema, using\n+     * the catalogSchema as the schema containing the DATAPARTITIONS system table\n+     * \n+     * @param schemaName the name of the admin schema hosting the tenants and tenant_keys tables\n+     * @param tenantId the id of the tenant to delete\n+     */\n+    public DeleteTenantDAO(String schemaName, int tenantId) {\n+        DataDefinitionUtil.assertValidName(schemaName);\n+        this.schemaName = schemaName;\n+        this.tenantId = tenantId;\n+    }\n+    \n+    @Override\n+    public void run(IDatabaseTranslator translator, Connection c) {\n+        deleteFromTenantKeys(translator, c);\n+        deleteFromTenants(translator, c);\n+    }\n+    \n+    protected void deleteFromTenantKeys(IDatabaseTranslator translator, Connection c) {\n+        final String tableName = DataDefinitionUtil.getQualifiedName(schemaName, \"TENANT_KEYS\");\n+        final String DML = \"\"\n+                + \"   DELETE FROM \" + tableName\n+                + \"    WHERE mt_id = ? \"\n+                ;\n+\n+        try (PreparedStatement ps = c.prepareStatement(DML)) {\n+            ps.setInt(1, tenantId);\n+            ps.executeUpdate();\n+        }\n+        catch (SQLException x) {\n+            // Translate the exception into something a little more meaningful\n+            // for this database type and application\n+            throw translator.translate(x);\n+        }\n+        \n+    }\n+\n+    protected void deleteFromTenants(IDatabaseTranslator translator, Connection c) {\n+        final String tableName = DataDefinitionUtil.getQualifiedName(schemaName, \"TENANTS\");\n+        final String DML = \"\"\n+                + \"   DELETE FROM \" + tableName\n+                + \"    WHERE mt_id = ? \"\n+                + \"      AND tenant_status = ?\"\n+                ;\n+\n+        try (PreparedStatement ps = c.prepareStatement(DML)) {\n+            ps.setInt(1, tenantId);\n+            ps.setString(2, TenantStatus.DROPPED.name());\n+            int rows = ps.executeUpdate();\n+            \n+            if (rows < 1) {\n+                throw new DataAccessException(\"Invalid tenant_id or tenant not DROPPED\");\n+            }\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc0Mzk2Mg=="}, "originalCommit": {"oid": "15625b8715507454043b8708e63ac7a549483880"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMzIzNTM5OnYy", "diffSide": "RIGHT", "path": "fhir-persistence-schema/docs/DropTenant.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMjozMjozMVrOGibCxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMzoxMzo1NlrOGicekQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc0Nzg0NQ==", "bodyText": "do we add the schema info to the tanant table now? or we still have to visit the system table as you showed me to get the schema info for a tenant.", "url": "https://github.com/IBM/FHIR/pull/1220#discussion_r438747845", "createdAt": "2020-06-11T12:32:31Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-persistence-schema/docs/DropTenant.md", "diffHunk": "@@ -0,0 +1,129 @@\n+# Removing a tenant from the database\n+\n+Use this guide when removing a tenant from the Db2 multi-tenant database. The tenant's data will be removed from the database along with any associated storage.\n+\n+To obtain a list of the tenants currently managed in a given database, run the following:\n+\n+```sh\n+    java -jar schema/fhir-persistence-schema-*-cli.jar \\\n+      --prop-file db2.properties --list-tenants\n+```\n+\n+```\n+ TenantId     Status       TenantName Schema\n+        1  ALLOCATED            test1 FHIRDATA\n+        2  ALLOCATED            test2 FHIRDATA2\n+        3    DROPPED            test3 <not-known>\n+```\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15625b8715507454043b8708e63ac7a549483880"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc3MTM0NQ==", "bodyText": "I join against the syscat.datapartitions table and look for a table there to sniff out the schema.", "url": "https://github.com/IBM/FHIR/pull/1220#discussion_r438771345", "createdAt": "2020-06-11T13:13:56Z", "author": {"login": "punktilious"}, "path": "fhir-persistence-schema/docs/DropTenant.md", "diffHunk": "@@ -0,0 +1,129 @@\n+# Removing a tenant from the database\n+\n+Use this guide when removing a tenant from the Db2 multi-tenant database. The tenant's data will be removed from the database along with any associated storage.\n+\n+To obtain a list of the tenants currently managed in a given database, run the following:\n+\n+```sh\n+    java -jar schema/fhir-persistence-schema-*-cli.jar \\\n+      --prop-file db2.properties --list-tenants\n+```\n+\n+```\n+ TenantId     Status       TenantName Schema\n+        1  ALLOCATED            test1 FHIRDATA\n+        2  ALLOCATED            test2 FHIRDATA2\n+        3    DROPPED            test3 <not-known>\n+```\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc0Nzg0NQ=="}, "originalCommit": {"oid": "15625b8715507454043b8708e63ac7a549483880"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMzI0ODQxOnYy", "diffSide": "RIGHT", "path": "fhir-persistence-schema/docs/DropTenant.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMjozNjozMFrOGibLAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMzoxNjowMVrOGicjgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc0OTk1NQ==", "bodyText": "just curious, could a tenant be partially dropped? e.g, what if the tool fails to finish all steps for whatever reason.", "url": "https://github.com/IBM/FHIR/pull/1220#discussion_r438749955", "createdAt": "2020-06-11T12:36:30Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-persistence-schema/docs/DropTenant.md", "diffHunk": "@@ -0,0 +1,129 @@\n+# Removing a tenant from the database\n+\n+Use this guide when removing a tenant from the Db2 multi-tenant database. The tenant's data will be removed from the database along with any associated storage.\n+\n+To obtain a list of the tenants currently managed in a given database, run the following:\n+\n+```sh\n+    java -jar schema/fhir-persistence-schema-*-cli.jar \\\n+      --prop-file db2.properties --list-tenants\n+```\n+\n+```\n+ TenantId     Status       TenantName Schema\n+        1  ALLOCATED            test1 FHIRDATA\n+        2  ALLOCATED            test2 FHIRDATA2\n+        3    DROPPED            test3 <not-known>\n+```\n+\n+Note that after the tenant is dropped, it is no longer associated with a schema.\n+\n+## Background\n+\n+Tenant data is stored in a Db2 table partition attached to each of the IBM FHIR Server data tables. Removal occurs in two phases:\n+\n+- **Phase 1**. The tenant's partitions are detached from each data table and converted into a stand-alone table.\n+- **Phase 2**. The stand-alone tables are dropped. Once all the tables are dropped, the tablespace will also be dropped.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15625b8715507454043b8708e63ac7a549483880"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc3MjYwOA==", "bodyText": "Yes, that's why I suppress the exceptions, to allow it to be run multiple times. It will only succeed once you can drop the table space (and that exception isn't suppressed). So keep running phase 2 until you don't get an error. Phase 1 includes phase 2, so you could just keep running phase 1...but not recommended, because of all the FK disable/enable stuff that also goes on there. It would extend any maintenance window.", "url": "https://github.com/IBM/FHIR/pull/1220#discussion_r438772608", "createdAt": "2020-06-11T13:16:01Z", "author": {"login": "punktilious"}, "path": "fhir-persistence-schema/docs/DropTenant.md", "diffHunk": "@@ -0,0 +1,129 @@\n+# Removing a tenant from the database\n+\n+Use this guide when removing a tenant from the Db2 multi-tenant database. The tenant's data will be removed from the database along with any associated storage.\n+\n+To obtain a list of the tenants currently managed in a given database, run the following:\n+\n+```sh\n+    java -jar schema/fhir-persistence-schema-*-cli.jar \\\n+      --prop-file db2.properties --list-tenants\n+```\n+\n+```\n+ TenantId     Status       TenantName Schema\n+        1  ALLOCATED            test1 FHIRDATA\n+        2  ALLOCATED            test2 FHIRDATA2\n+        3    DROPPED            test3 <not-known>\n+```\n+\n+Note that after the tenant is dropped, it is no longer associated with a schema.\n+\n+## Background\n+\n+Tenant data is stored in a Db2 table partition attached to each of the IBM FHIR Server data tables. Removal occurs in two phases:\n+\n+- **Phase 1**. The tenant's partitions are detached from each data table and converted into a stand-alone table.\n+- **Phase 2**. The stand-alone tables are dropped. Once all the tables are dropped, the tablespace will also be dropped.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc0OTk1NQ=="}, "originalCommit": {"oid": "15625b8715507454043b8708e63ac7a549483880"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMzI3MzU5OnYy", "diffSide": "RIGHT", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/api/TenantStatus.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMjo0Mzo1M1rOGibapg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMzo1NDoxNVrOGiedJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc1Mzk1OA==", "bodyText": "could we add a locked status to tenant which can help us to create a feature in the future to prevent access to the tenant temporarily?   or maybe we can re-use \"FROZEN\" for the purpose if it's not dedicated to dropped only.", "url": "https://github.com/IBM/FHIR/pull/1220#discussion_r438753958", "createdAt": "2020-06-11T12:43:53Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/api/TenantStatus.java", "diffHunk": "@@ -10,9 +10,9 @@\n  * Tenant Status Enumeration\n  */\n public enum TenantStatus {\n-    PROVISIONING,\n-    FREE,\n-    ALLOCATED,\n-    FROZEN,\n-    DROPPED\n+    PROVISIONING, // in the process of adding the partitions to the schema\n+    FREE,         // unused tenant, available for allocation (e.g. tenant pooling)\n+    ALLOCATED,    // allocated and in use\n+    FROZEN,       // about to be dropped\n+    DROPPED       // all tenant resources have been release", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15625b8715507454043b8708e63ac7a549483880"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgwMzc1MA==", "bodyText": "We can easily add a new status when we implement that new feature. Would need to be supported in the SET_TENANT stored procedure.", "url": "https://github.com/IBM/FHIR/pull/1220#discussion_r438803750", "createdAt": "2020-06-11T13:54:15Z", "author": {"login": "punktilious"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/api/TenantStatus.java", "diffHunk": "@@ -10,9 +10,9 @@\n  * Tenant Status Enumeration\n  */\n public enum TenantStatus {\n-    PROVISIONING,\n-    FREE,\n-    ALLOCATED,\n-    FROZEN,\n-    DROPPED\n+    PROVISIONING, // in the process of adding the partitions to the schema\n+    FREE,         // unused tenant, available for allocation (e.g. tenant pooling)\n+    ALLOCATED,    // allocated and in use\n+    FROZEN,       // about to be dropped\n+    DROPPED       // all tenant resources have been release", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc1Mzk1OA=="}, "originalCommit": {"oid": "15625b8715507454043b8708e63ac7a549483880"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMzMwNTQwOnYy", "diffSide": "RIGHT", "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/app/Main.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMjo1MzowNVrOGibuwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNToyMzowMFrOGiiSmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc1OTEwNQ==", "bodyText": "format ...", "url": "https://github.com/IBM/FHIR/pull/1220#discussion_r438759105", "createdAt": "2020-06-11T12:53:05Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/app/Main.java", "diffHunk": "@@ -697,6 +709,30 @@ protected void allocateTenant() {\n         }\n     }\n \n+    /**\n+     * List the tenants currently configured\n+     */\n+    protected void listTenants() {\n+        if (!MULTITENANT_FEATURE_ENABLED.contains(dbType)) {\n+            return;\n+        }\n+        Db2Adapter adapter = new Db2Adapter(connectionPool);\n+        try (ITransaction tx = TransactionFactory.openTransaction(connectionPool)) {\n+            try {\n+                GetTenantList rtListGetter = new GetTenantList(adminSchemaName);\n+                List<TenantInfo> tenants = adapter.runStatement(rtListGetter);\n+                \n+                System.out.println(TenantInfo.getHeader());\n+                tenants.forEach(t -> System.out.println(t.toString()));\n+            } \n+            catch (DataAccessException x) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15625b8715507454043b8708e63ac7a549483880"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg2NjU4Nw==", "bodyText": "done", "url": "https://github.com/IBM/FHIR/pull/1220#discussion_r438866587", "createdAt": "2020-06-11T15:23:00Z", "author": {"login": "punktilious"}, "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/app/Main.java", "diffHunk": "@@ -697,6 +709,30 @@ protected void allocateTenant() {\n         }\n     }\n \n+    /**\n+     * List the tenants currently configured\n+     */\n+    protected void listTenants() {\n+        if (!MULTITENANT_FEATURE_ENABLED.contains(dbType)) {\n+            return;\n+        }\n+        Db2Adapter adapter = new Db2Adapter(connectionPool);\n+        try (ITransaction tx = TransactionFactory.openTransaction(connectionPool)) {\n+            try {\n+                GetTenantList rtListGetter = new GetTenantList(adminSchemaName);\n+                List<TenantInfo> tenants = adapter.runStatement(rtListGetter);\n+                \n+                System.out.println(TenantInfo.getHeader());\n+                tenants.forEach(t -> System.out.println(t.toString()));\n+            } \n+            catch (DataAccessException x) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc1OTEwNQ=="}, "originalCommit": {"oid": "15625b8715507454043b8708e63ac7a549483880"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMzMxNjg2OnYy", "diffSide": "RIGHT", "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/app/util/CommonUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMjo1NjoxOVrOGib1-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMzoxOTowMFrOGicqWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc2MDk1Mg==", "bodyText": "it's a little bit strange that \"drop-tenant\" doesn't really drop the detached tables. maybe we should change it to \"detach-tenant\"?", "url": "https://github.com/IBM/FHIR/pull/1220#discussion_r438760952", "createdAt": "2020-06-11T12:56:19Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/app/util/CommonUtil.java", "diffHunk": "@@ -116,7 +116,18 @@ public static void printUsage() {\n \n         // Drops a Tenant\n         ps.println(\"--drop-tenant tenantName\");\n-        ps.println(\" * drops the tenant given the tenantName\");\n+        ps.println(\" * (phase 1) drops the tenant given the tenantName\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15625b8715507454043b8708e63ac7a549483880"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc3NDM2MQ==", "bodyText": "It does try to drop the tables. It could potentially succeed in the first call if Db2 were quick enough with its async processes.", "url": "https://github.com/IBM/FHIR/pull/1220#discussion_r438774361", "createdAt": "2020-06-11T13:19:00Z", "author": {"login": "punktilious"}, "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/app/util/CommonUtil.java", "diffHunk": "@@ -116,7 +116,18 @@ public static void printUsage() {\n \n         // Drops a Tenant\n         ps.println(\"--drop-tenant tenantName\");\n-        ps.println(\" * drops the tenant given the tenantName\");\n+        ps.println(\" * (phase 1) drops the tenant given the tenantName\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc2MDk1Mg=="}, "originalCommit": {"oid": "15625b8715507454043b8708e63ac7a549483880"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMzMyMjIxOnYy", "diffSide": "RIGHT", "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/control/GetTenantInfo.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMjo1Nzo1MFrOGib5WQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNToyMzoxNlrOGiiTTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc2MTgxNw==", "bodyText": "format ... move to above line?", "url": "https://github.com/IBM/FHIR/pull/1220#discussion_r438761817", "createdAt": "2020-06-11T12:57:50Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/control/GetTenantInfo.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.schema.control;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.database.utils.api.IDatabaseSupplier;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.database.utils.api.TenantStatus;\n+\n+/**\n+ * Fetch the {@link TenantInfo} for the tenantName. Returns a null\n+ * TenantInfo if the tenant does not exist\n+ */\n+public class GetTenantInfo implements IDatabaseSupplier<TenantInfo> {\n+    private final String adminSchema;\n+    private final String tenantName;\n+\n+    public GetTenantInfo(String adminSchema, String tenantName) {\n+        this.adminSchema = adminSchema;\n+        this.tenantName = tenantName;\n+    }\n+\n+    @Override\n+    public TenantInfo run(IDatabaseTranslator translator, Connection c) {\n+        TenantInfo result;\n+\n+        // We take a look at the catalog to find which schema has partitions\n+        // for each tenant. This would, of course, be easier if the schema\n+        // had been stored as an attribute of the tenant in the first place.\n+        final String SQL = \"\"\n+                + \"SELECT \"\n+                + \"       t.mt_id, t.tenant_name, \"\n+                + \"       t.tenant_status, \"\n+                + \"       dp.tabschema \"\n+                + \"  FROM \" + adminSchema + \".TENANTS AS t \"\n+                + \"LEFT OUTER JOIN syscat.datapartitions dp \"\n+                + \"             ON (dp.tabname = 'LOGICAL_RESOURCES' \"\n+                + \"            AND dp.datapartitionname = CONCAT('TENANT', t.mt_id))\"\n+                + \" WHERE t.tenant_name = ?\";\n+        \n+\n+        try (PreparedStatement s = c.prepareStatement(SQL)) {\n+            s.setString(1, tenantName);\n+            ResultSet rs = s.executeQuery();\n+            if (rs.next()) {\n+                result = new TenantInfo();\n+                result.setTenantId(rs.getInt(1));\n+                result.setTenantName(rs.getString(2));\n+                result.setTenantStatus(TenantStatus.valueOf(rs.getString(3)));\n+                result.setTenantSchema(rs.getString(4));\n+            }\n+            else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15625b8715507454043b8708e63ac7a549483880"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg2Njc2Nw==", "bodyText": "done", "url": "https://github.com/IBM/FHIR/pull/1220#discussion_r438866767", "createdAt": "2020-06-11T15:23:16Z", "author": {"login": "punktilious"}, "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/control/GetTenantInfo.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.schema.control;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.database.utils.api.IDatabaseSupplier;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.database.utils.api.TenantStatus;\n+\n+/**\n+ * Fetch the {@link TenantInfo} for the tenantName. Returns a null\n+ * TenantInfo if the tenant does not exist\n+ */\n+public class GetTenantInfo implements IDatabaseSupplier<TenantInfo> {\n+    private final String adminSchema;\n+    private final String tenantName;\n+\n+    public GetTenantInfo(String adminSchema, String tenantName) {\n+        this.adminSchema = adminSchema;\n+        this.tenantName = tenantName;\n+    }\n+\n+    @Override\n+    public TenantInfo run(IDatabaseTranslator translator, Connection c) {\n+        TenantInfo result;\n+\n+        // We take a look at the catalog to find which schema has partitions\n+        // for each tenant. This would, of course, be easier if the schema\n+        // had been stored as an attribute of the tenant in the first place.\n+        final String SQL = \"\"\n+                + \"SELECT \"\n+                + \"       t.mt_id, t.tenant_name, \"\n+                + \"       t.tenant_status, \"\n+                + \"       dp.tabschema \"\n+                + \"  FROM \" + adminSchema + \".TENANTS AS t \"\n+                + \"LEFT OUTER JOIN syscat.datapartitions dp \"\n+                + \"             ON (dp.tabname = 'LOGICAL_RESOURCES' \"\n+                + \"            AND dp.datapartitionname = CONCAT('TENANT', t.mt_id))\"\n+                + \" WHERE t.tenant_name = ?\";\n+        \n+\n+        try (PreparedStatement s = c.prepareStatement(SQL)) {\n+            s.setString(1, tenantName);\n+            ResultSet rs = s.executeQuery();\n+            if (rs.next()) {\n+                result = new TenantInfo();\n+                result.setTenantId(rs.getInt(1));\n+                result.setTenantName(rs.getString(2));\n+                result.setTenantStatus(TenantStatus.valueOf(rs.getString(3)));\n+                result.setTenantSchema(rs.getString(4));\n+            }\n+            else {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc2MTgxNw=="}, "originalCommit": {"oid": "15625b8715507454043b8708e63ac7a549483880"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMzMyMjY0OnYy", "diffSide": "RIGHT", "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/control/GetTenantInfo.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMjo1Nzo1N1rOGib5nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNToyMzoyNFrOGiiToQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc2MTg4Nw==", "bodyText": "format ...", "url": "https://github.com/IBM/FHIR/pull/1220#discussion_r438761887", "createdAt": "2020-06-11T12:57:57Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/control/GetTenantInfo.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.schema.control;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.database.utils.api.IDatabaseSupplier;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.database.utils.api.TenantStatus;\n+\n+/**\n+ * Fetch the {@link TenantInfo} for the tenantName. Returns a null\n+ * TenantInfo if the tenant does not exist\n+ */\n+public class GetTenantInfo implements IDatabaseSupplier<TenantInfo> {\n+    private final String adminSchema;\n+    private final String tenantName;\n+\n+    public GetTenantInfo(String adminSchema, String tenantName) {\n+        this.adminSchema = adminSchema;\n+        this.tenantName = tenantName;\n+    }\n+\n+    @Override\n+    public TenantInfo run(IDatabaseTranslator translator, Connection c) {\n+        TenantInfo result;\n+\n+        // We take a look at the catalog to find which schema has partitions\n+        // for each tenant. This would, of course, be easier if the schema\n+        // had been stored as an attribute of the tenant in the first place.\n+        final String SQL = \"\"\n+                + \"SELECT \"\n+                + \"       t.mt_id, t.tenant_name, \"\n+                + \"       t.tenant_status, \"\n+                + \"       dp.tabschema \"\n+                + \"  FROM \" + adminSchema + \".TENANTS AS t \"\n+                + \"LEFT OUTER JOIN syscat.datapartitions dp \"\n+                + \"             ON (dp.tabname = 'LOGICAL_RESOURCES' \"\n+                + \"            AND dp.datapartitionname = CONCAT('TENANT', t.mt_id))\"\n+                + \" WHERE t.tenant_name = ?\";\n+        \n+\n+        try (PreparedStatement s = c.prepareStatement(SQL)) {\n+            s.setString(1, tenantName);\n+            ResultSet rs = s.executeQuery();\n+            if (rs.next()) {\n+                result = new TenantInfo();\n+                result.setTenantId(rs.getInt(1));\n+                result.setTenantName(rs.getString(2));\n+                result.setTenantStatus(TenantStatus.valueOf(rs.getString(3)));\n+                result.setTenantSchema(rs.getString(4));\n+            }\n+            else {\n+                result = null;\n+            }\n+        }\n+        catch (SQLException x) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15625b8715507454043b8708e63ac7a549483880"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg2Njg0OQ==", "bodyText": "done", "url": "https://github.com/IBM/FHIR/pull/1220#discussion_r438866849", "createdAt": "2020-06-11T15:23:24Z", "author": {"login": "punktilious"}, "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/control/GetTenantInfo.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.schema.control;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.database.utils.api.IDatabaseSupplier;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.database.utils.api.TenantStatus;\n+\n+/**\n+ * Fetch the {@link TenantInfo} for the tenantName. Returns a null\n+ * TenantInfo if the tenant does not exist\n+ */\n+public class GetTenantInfo implements IDatabaseSupplier<TenantInfo> {\n+    private final String adminSchema;\n+    private final String tenantName;\n+\n+    public GetTenantInfo(String adminSchema, String tenantName) {\n+        this.adminSchema = adminSchema;\n+        this.tenantName = tenantName;\n+    }\n+\n+    @Override\n+    public TenantInfo run(IDatabaseTranslator translator, Connection c) {\n+        TenantInfo result;\n+\n+        // We take a look at the catalog to find which schema has partitions\n+        // for each tenant. This would, of course, be easier if the schema\n+        // had been stored as an attribute of the tenant in the first place.\n+        final String SQL = \"\"\n+                + \"SELECT \"\n+                + \"       t.mt_id, t.tenant_name, \"\n+                + \"       t.tenant_status, \"\n+                + \"       dp.tabschema \"\n+                + \"  FROM \" + adminSchema + \".TENANTS AS t \"\n+                + \"LEFT OUTER JOIN syscat.datapartitions dp \"\n+                + \"             ON (dp.tabname = 'LOGICAL_RESOURCES' \"\n+                + \"            AND dp.datapartitionname = CONCAT('TENANT', t.mt_id))\"\n+                + \" WHERE t.tenant_name = ?\";\n+        \n+\n+        try (PreparedStatement s = c.prepareStatement(SQL)) {\n+            s.setString(1, tenantName);\n+            ResultSet rs = s.executeQuery();\n+            if (rs.next()) {\n+                result = new TenantInfo();\n+                result.setTenantId(rs.getInt(1));\n+                result.setTenantName(rs.getString(2));\n+                result.setTenantStatus(TenantStatus.valueOf(rs.getString(3)));\n+                result.setTenantSchema(rs.getString(4));\n+            }\n+            else {\n+                result = null;\n+            }\n+        }\n+        catch (SQLException x) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc2MTg4Nw=="}, "originalCommit": {"oid": "15625b8715507454043b8708e63ac7a549483880"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMzMyMzcwOnYy", "diffSide": "RIGHT", "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/control/GetTenantList.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMjo1ODoxNFrOGib6Qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNToyMzozNFrOGiiUIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc2MjA1MQ==", "bodyText": "format ...", "url": "https://github.com/IBM/FHIR/pull/1220#discussion_r438762051", "createdAt": "2020-06-11T12:58:14Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/control/GetTenantList.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.schema.control;\n+\n+import java.sql.Connection;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.ibm.fhir.database.utils.api.IDatabaseSupplier;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.database.utils.api.TenantStatus;\n+\n+/**\n+ * Fetch the list of tenants currently configured\n+ */\n+public class GetTenantList implements IDatabaseSupplier<List<TenantInfo>> {\n+    private final String adminSchema;\n+\n+    public GetTenantList(String adminSchema) {\n+        this.adminSchema = adminSchema;\n+    }\n+\n+    @Override\n+    public List<TenantInfo> run(IDatabaseTranslator translator, Connection c) {\n+        List<TenantInfo> result = new ArrayList<>();\n+\n+        // We take a look at the catalog to find which schema has partitions\n+        // for each tenant. This would, of course, be easier if the schema\n+        // had been stored as an attribute of the tenant in the first place.\n+        final String SQL = \"\"\n+                + \"SELECT \"\n+                + \"       t.mt_id, t.tenant_name, \"\n+                + \"       t.tenant_status, \"\n+                + \"       dp.tabschema \"\n+                + \"  FROM \" + adminSchema + \".TENANTS AS t \"\n+                + \"LEFT OUTER JOIN syscat.datapartitions dp \"\n+                + \"             ON (dp.tabname = 'PARAMETER_NAMES' \"\n+                + \"            AND dp.datapartitionname = CONCAT('TENANT', t.mt_id))\"\n+                + \" ORDER BY t.mt_id\";\n+        \n+\n+        try (Statement s = c.createStatement()) {\n+            ResultSet rs = s.executeQuery(SQL);\n+            while (rs.next()) {\n+                TenantInfo dto = new TenantInfo();\n+                dto.setTenantId(rs.getInt(1));\n+                dto.setTenantName(rs.getString(2));\n+                dto.setTenantStatus(TenantStatus.valueOf(rs.getString(3)));\n+                dto.setTenantSchema(rs.getString(4));\n+                result.add(dto);\n+            }\n+        }\n+        catch (SQLException x) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15625b8715507454043b8708e63ac7a549483880"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg2Njk3OA==", "bodyText": "done", "url": "https://github.com/IBM/FHIR/pull/1220#discussion_r438866978", "createdAt": "2020-06-11T15:23:34Z", "author": {"login": "punktilious"}, "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/control/GetTenantList.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.schema.control;\n+\n+import java.sql.Connection;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.ibm.fhir.database.utils.api.IDatabaseSupplier;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.database.utils.api.TenantStatus;\n+\n+/**\n+ * Fetch the list of tenants currently configured\n+ */\n+public class GetTenantList implements IDatabaseSupplier<List<TenantInfo>> {\n+    private final String adminSchema;\n+\n+    public GetTenantList(String adminSchema) {\n+        this.adminSchema = adminSchema;\n+    }\n+\n+    @Override\n+    public List<TenantInfo> run(IDatabaseTranslator translator, Connection c) {\n+        List<TenantInfo> result = new ArrayList<>();\n+\n+        // We take a look at the catalog to find which schema has partitions\n+        // for each tenant. This would, of course, be easier if the schema\n+        // had been stored as an attribute of the tenant in the first place.\n+        final String SQL = \"\"\n+                + \"SELECT \"\n+                + \"       t.mt_id, t.tenant_name, \"\n+                + \"       t.tenant_status, \"\n+                + \"       dp.tabschema \"\n+                + \"  FROM \" + adminSchema + \".TENANTS AS t \"\n+                + \"LEFT OUTER JOIN syscat.datapartitions dp \"\n+                + \"             ON (dp.tabname = 'PARAMETER_NAMES' \"\n+                + \"            AND dp.datapartitionname = CONCAT('TENANT', t.mt_id))\"\n+                + \" ORDER BY t.mt_id\";\n+        \n+\n+        try (Statement s = c.createStatement()) {\n+            ResultSet rs = s.executeQuery(SQL);\n+            while (rs.next()) {\n+                TenantInfo dto = new TenantInfo();\n+                dto.setTenantId(rs.getInt(1));\n+                dto.setTenantName(rs.getString(2));\n+                dto.setTenantStatus(TenantStatus.valueOf(rs.getString(3)));\n+                dto.setTenantSchema(rs.getString(4));\n+                result.add(dto);\n+            }\n+        }\n+        catch (SQLException x) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc2MjA1MQ=="}, "originalCommit": {"oid": "15625b8715507454043b8708e63ac7a549483880"}, "originalPosition": 60}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4883, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}