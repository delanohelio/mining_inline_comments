{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYyODM3NjQx", "number": 1400, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNToyNzoxMVrOEVDSwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNTozODoxNlrOEVDmZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNTA5NTA0OnYy", "diffSide": "RIGHT", "path": "fhir-smart/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNToyNzoxMVrOG7lpqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNTo0MzoxNlrOG7mVdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzNjA0Mg==", "bodyText": "Copyright?", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465136042", "createdAt": "2020-08-04T15:27:11Z", "author": {"login": "prb112"}, "path": "fhir-smart/pom.xml", "diffHunk": "@@ -0,0 +1,77 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!-- THIS PRODUCT CONTAINS RESTRICTED MATERIALS OF IBM 5724-H88, 5724-J08,\n+    5724-I63, 5655-W65, COPYRIGHT International Business Machines Corp., 2014\n+    All Rights Reserved * Licensed Materials - Property of IBM US Government\n+    Users Restricted Rights - Use, duplication or disclosure restricted by GSA\n+    ADP Schedule Contract with IBM Corp. -->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0NzI1Mw==", "bodyText": "fixed", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465147253", "createdAt": "2020-08-04T15:43:16Z", "author": {"login": "lmsurpre"}, "path": "fhir-smart/pom.xml", "diffHunk": "@@ -0,0 +1,77 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!-- THIS PRODUCT CONTAINS RESTRICTED MATERIALS OF IBM 5724-H88, 5724-J08,\n+    5724-I63, 5655-W65, COPYRIGHT International Business Machines Corp., 2014\n+    All Rights Reserved * Licensed Materials - Property of IBM US Government\n+    Users Restricted Rights - Use, duplication or disclosure restricted by GSA\n+    ADP Schedule Contract with IBM Corp. -->", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzNjA0Mg=="}, "originalCommit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNTA5NzQyOnYy", "diffSide": "RIGHT", "path": "fhir-smart/pom.xml", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNToyNzo0MlrOG7lrAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNTo0NzozMFrOG7mhBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzNjM4Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    <version>4.3.2-SNAPSHOT</version>\n          \n          \n            \n                    <version>4.4.0-SNAPSHOT</version>", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465136387", "createdAt": "2020-08-04T15:27:42Z", "author": {"login": "prb112"}, "path": "fhir-smart/pom.xml", "diffHunk": "@@ -0,0 +1,77 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!-- THIS PRODUCT CONTAINS RESTRICTED MATERIALS OF IBM 5724-H88, 5724-J08,\n+    5724-I63, 5655-W65, COPYRIGHT International Business Machines Corp., 2014\n+    All Rights Reserved * Licensed Materials - Property of IBM US Government\n+    Users Restricted Rights - Use, duplication or disclosure restricted by GSA\n+    ADP Schedule Contract with IBM Corp. -->\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <parent>\n+        <groupId>com.ibm.fhir</groupId>\n+        <artifactId>fhir-parent</artifactId>\n+        <version>4.3.2-SNAPSHOT</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1MDIxNA==", "bodyText": "Sure, I can accept your other PR, rebase, and then make this change.", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465150214", "createdAt": "2020-08-04T15:47:30Z", "author": {"login": "lmsurpre"}, "path": "fhir-smart/pom.xml", "diffHunk": "@@ -0,0 +1,77 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!-- THIS PRODUCT CONTAINS RESTRICTED MATERIALS OF IBM 5724-H88, 5724-J08,\n+    5724-I63, 5655-W65, COPYRIGHT International Business Machines Corp., 2014\n+    All Rights Reserved * Licensed Materials - Property of IBM US Government\n+    Users Restricted Rights - Use, duplication or disclosure restricted by GSA\n+    ADP Schedule Contract with IBM Corp. -->\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <parent>\n+        <groupId>com.ibm.fhir</groupId>\n+        <artifactId>fhir-parent</artifactId>\n+        <version>4.3.2-SNAPSHOT</version>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzNjM4Nw=="}, "originalCommit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNTEwNTU1OnYy", "diffSide": "RIGHT", "path": "fhir-smart/src/test/java/com/ibm/fhir/smart/test/AuthzPolicyBackupEnforcementTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNToyOToyM1rOG7lvvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNTo0MzoyOFrOG7mWBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzNzU5Ng==", "bodyText": "copyright", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465137596", "createdAt": "2020-08-04T15:29:23Z", "author": {"login": "prb112"}, "path": "fhir-smart/src/test/java/com/ibm/fhir/smart/test/AuthzPolicyBackupEnforcementTest.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package com.ibm.fhir.smart.test;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0NzM5OA==", "bodyText": "fixed", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465147398", "createdAt": "2020-08-04T15:43:28Z", "author": {"login": "lmsurpre"}, "path": "fhir-smart/src/test/java/com/ibm/fhir/smart/test/AuthzPolicyBackupEnforcementTest.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package com.ibm.fhir.smart.test;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzNzU5Ng=="}, "originalCommit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNTEwNjQ5OnYy", "diffSide": "RIGHT", "path": "fhir-smart/src/test/java/com/ibm/fhir/smart/test/AuthzPolicyBackupEnforcementTest.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNToyOTozNlrOG7lwXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxODowMDowMVrOG7rcyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzNzc1OA==", "bodyText": "Negative test too?", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465137758", "createdAt": "2020-08-04T15:29:36Z", "author": {"login": "prb112"}, "path": "fhir-smart/src/test/java/com/ibm/fhir/smart/test/AuthzPolicyBackupEnforcementTest.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package com.ibm.fhir.smart.test;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.test.TestUtil;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceEvent;\n+import com.ibm.fhir.smart.AuthzPolicyEnforcementPersistenceInterceptor;\n+\n+public class AuthzPolicyBackupEnforcementTest {\n+    AuthzPolicyEnforcementPersistenceInterceptor interceptor;\n+    Patient patient;\n+\n+    @BeforeClass\n+    public void setup() throws Exception {\n+        interceptor = new AuthzPolicyEnforcementPersistenceInterceptor();\n+\n+        patient = TestUtil.readExampleResource(\"json/ibm/minimal/Patient-1.json\");\n+        patient = patient.toBuilder()\n+                .id(\"11111111-1111-1111-1111-111111111111\")\n+                .build();\n+    }\n+\n+    @Test\n+    public void testUserInfoHeader() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0OTU5OA==", "bodyText": "yes, needs much more comprehensive tests in general I think", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465149598", "createdAt": "2020-08-04T15:46:34Z", "author": {"login": "lmsurpre"}, "path": "fhir-smart/src/test/java/com/ibm/fhir/smart/test/AuthzPolicyBackupEnforcementTest.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package com.ibm.fhir.smart.test;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.test.TestUtil;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceEvent;\n+import com.ibm.fhir.smart.AuthzPolicyEnforcementPersistenceInterceptor;\n+\n+public class AuthzPolicyBackupEnforcementTest {\n+    AuthzPolicyEnforcementPersistenceInterceptor interceptor;\n+    Patient patient;\n+\n+    @BeforeClass\n+    public void setup() throws Exception {\n+        interceptor = new AuthzPolicyEnforcementPersistenceInterceptor();\n+\n+        patient = TestUtil.readExampleResource(\"json/ibm/minimal/Patient-1.json\");\n+        patient = patient.toBuilder()\n+                .id(\"11111111-1111-1111-1111-111111111111\")\n+                .build();\n+    }\n+\n+    @Test\n+    public void testUserInfoHeader() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzNzc1OA=="}, "originalCommit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE2MDQ2Nw==", "bodyText": "No problem - is this coming in a separate issue? Should we track an issue for it?", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465160467", "createdAt": "2020-08-04T16:02:37Z", "author": {"login": "prb112"}, "path": "fhir-smart/src/test/java/com/ibm/fhir/smart/test/AuthzPolicyBackupEnforcementTest.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package com.ibm.fhir.smart.test;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.test.TestUtil;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceEvent;\n+import com.ibm.fhir.smart.AuthzPolicyEnforcementPersistenceInterceptor;\n+\n+public class AuthzPolicyBackupEnforcementTest {\n+    AuthzPolicyEnforcementPersistenceInterceptor interceptor;\n+    Patient patient;\n+\n+    @BeforeClass\n+    public void setup() throws Exception {\n+        interceptor = new AuthzPolicyEnforcementPersistenceInterceptor();\n+\n+        patient = TestUtil.readExampleResource(\"json/ibm/minimal/Patient-1.json\");\n+        patient = patient.toBuilder()\n+                .id(\"11111111-1111-1111-1111-111111111111\")\n+                .build();\n+    }\n+\n+    @Test\n+    public void testUserInfoHeader() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzNzc1OA=="}, "originalCommit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIzMTA0OA==", "bodyText": "I just posted another commit here...can you please have a look?", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465231048", "createdAt": "2020-08-04T18:00:01Z", "author": {"login": "lmsurpre"}, "path": "fhir-smart/src/test/java/com/ibm/fhir/smart/test/AuthzPolicyBackupEnforcementTest.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package com.ibm.fhir.smart.test;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.test.TestUtil;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceEvent;\n+import com.ibm.fhir.smart.AuthzPolicyEnforcementPersistenceInterceptor;\n+\n+public class AuthzPolicyBackupEnforcementTest {\n+    AuthzPolicyEnforcementPersistenceInterceptor interceptor;\n+    Patient patient;\n+\n+    @BeforeClass\n+    public void setup() throws Exception {\n+        interceptor = new AuthzPolicyEnforcementPersistenceInterceptor();\n+\n+        patient = TestUtil.readExampleResource(\"json/ibm/minimal/Patient-1.json\");\n+        patient = patient.toBuilder()\n+                .id(\"11111111-1111-1111-1111-111111111111\")\n+                .build();\n+    }\n+\n+    @Test\n+    public void testUserInfoHeader() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzNzc1OA=="}, "originalCommit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNTEyMTUyOnYy", "diffSide": "RIGHT", "path": "fhir-smart/src/main/java/com/ibm/fhir/smart/AuthzPolicyEnforcementPersistenceInterceptor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNTozMjo1MlrOG7l5gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNTo0NDozOFrOG7mZLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0MDA5OA==", "bodyText": "Given John's issues with streams, how does this perform?", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465140098", "createdAt": "2020-08-04T15:32:52Z", "author": {"login": "prb112"}, "path": "fhir-smart/src/main/java/com/ibm/fhir/smart/AuthzPolicyEnforcementPersistenceInterceptor.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019, 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.smart;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import com.auth0.jwt.JWT;\n+import com.auth0.jwt.interfaces.Claim;\n+import com.auth0.jwt.interfaces.DecodedJWT;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Resource;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.code.CompartmentType;\n+import com.ibm.fhir.model.type.code.IssueType;\n+import com.ibm.fhir.model.type.code.ResourceType;\n+import com.ibm.fhir.model.util.FHIRUtil;\n+import com.ibm.fhir.path.FHIRPathNode;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator.EvaluationContext;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceEvent;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceInterceptor;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceInterceptorException;\n+import com.ibm.fhir.search.compartment.CompartmentUtil;\n+import com.ibm.fhir.search.exception.FHIRSearchException;\n+import com.ibm.fhir.search.util.SearchUtil;\n+import com.ibm.fhir.smart.Scope.ContextType;\n+import com.ibm.fhir.smart.Scope.Permission;\n+\n+public class AuthzPolicyEnforcementPersistenceInterceptor implements FHIRPersistenceInterceptor {\n+    private static final Logger log = Logger.getLogger(AuthzPolicyEnforcementPersistenceInterceptor.class.getName());\n+\n+    private static final String BEARER_TOKEN_PREFIX = \"Bearer\";\n+    private static final String PATIENT_REF_PREFIX = \"Patient/\";\n+\n+    @Override\n+    public void beforeCreate(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void beforeDelete(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getPrevFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void beforeUpdate(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        // TODO: do we need to check READ permission on the prevFhirResource as well?\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterRead(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterVread(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterHistory(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        if (event.getFhirResource() instanceof Bundle) {\n+            for ( Bundle.Entry entry : ((Bundle) event.getFhirResource()).getEntry()) {\n+                if (entry.getResource() != null) {\n+                    enforce(entry.getResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+                }\n+            }\n+        } else {\n+            throw new IllegalStateException(\"Expected event resource of type Bundle but found \" +\n+                    event.getFhirResource().getClass().getSimpleName());\n+        }\n+    }\n+\n+    @Override\n+    public void afterSearch(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        if (event.getFhirResource() instanceof Bundle) {\n+            for ( Bundle.Entry entry : ((Bundle) event.getFhirResource()).getEntry()) {\n+                if (entry.getResource() != null) {\n+                    enforce(entry.getResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+                }\n+            }\n+        } else {\n+            throw new IllegalStateException(\"Expected event resource of type Bundle but found \" +\n+                    event.getFhirResource().getClass().getSimpleName());\n+        }\n+    }\n+\n+    /**\n+     * @param event\n+     * @param contextIds\n+     * @param collect\n+     * @throws FHIRPersistenceInterceptorException\n+     */\n+    private void enforce(Resource resource, List<String> contextIds, Permission requiredPermission, List<Scope> approvedScopes)\n+            throws FHIRPersistenceInterceptorException {\n+        Objects.requireNonNull(resource, \"resource\");\n+        Objects.requireNonNull(contextIds, \"contextIds\");\n+\n+        String resourceType = resource.getClass().getSimpleName();\n+        Map<ContextType, List<Scope>> approvedScopeMap = approvedScopes.stream()\n+                // First filter the list to only scopes which grant the required permissions on the passed resourceType\n+                .filter(s -> s.getResourceType() == ResourceType.ValueSet.RESOURCE ||\n+                        s.getResourceType().value().equals(resourceType))\n+                .filter(s -> hasPermission(s.getPermission(),requiredPermission))\n+                // Then group the scopes by their context type\n+                .collect(Collectors.groupingBy(s -> s.getContextType()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0ODIwNg==", "bodyText": "there will typically only be one or two scope strings in the JWT, so I'm really not worried about it", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465148206", "createdAt": "2020-08-04T15:44:38Z", "author": {"login": "lmsurpre"}, "path": "fhir-smart/src/main/java/com/ibm/fhir/smart/AuthzPolicyEnforcementPersistenceInterceptor.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019, 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.smart;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import com.auth0.jwt.JWT;\n+import com.auth0.jwt.interfaces.Claim;\n+import com.auth0.jwt.interfaces.DecodedJWT;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Resource;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.code.CompartmentType;\n+import com.ibm.fhir.model.type.code.IssueType;\n+import com.ibm.fhir.model.type.code.ResourceType;\n+import com.ibm.fhir.model.util.FHIRUtil;\n+import com.ibm.fhir.path.FHIRPathNode;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator.EvaluationContext;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceEvent;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceInterceptor;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceInterceptorException;\n+import com.ibm.fhir.search.compartment.CompartmentUtil;\n+import com.ibm.fhir.search.exception.FHIRSearchException;\n+import com.ibm.fhir.search.util.SearchUtil;\n+import com.ibm.fhir.smart.Scope.ContextType;\n+import com.ibm.fhir.smart.Scope.Permission;\n+\n+public class AuthzPolicyEnforcementPersistenceInterceptor implements FHIRPersistenceInterceptor {\n+    private static final Logger log = Logger.getLogger(AuthzPolicyEnforcementPersistenceInterceptor.class.getName());\n+\n+    private static final String BEARER_TOKEN_PREFIX = \"Bearer\";\n+    private static final String PATIENT_REF_PREFIX = \"Patient/\";\n+\n+    @Override\n+    public void beforeCreate(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void beforeDelete(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getPrevFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void beforeUpdate(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        // TODO: do we need to check READ permission on the prevFhirResource as well?\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterRead(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterVread(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterHistory(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        if (event.getFhirResource() instanceof Bundle) {\n+            for ( Bundle.Entry entry : ((Bundle) event.getFhirResource()).getEntry()) {\n+                if (entry.getResource() != null) {\n+                    enforce(entry.getResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+                }\n+            }\n+        } else {\n+            throw new IllegalStateException(\"Expected event resource of type Bundle but found \" +\n+                    event.getFhirResource().getClass().getSimpleName());\n+        }\n+    }\n+\n+    @Override\n+    public void afterSearch(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        if (event.getFhirResource() instanceof Bundle) {\n+            for ( Bundle.Entry entry : ((Bundle) event.getFhirResource()).getEntry()) {\n+                if (entry.getResource() != null) {\n+                    enforce(entry.getResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+                }\n+            }\n+        } else {\n+            throw new IllegalStateException(\"Expected event resource of type Bundle but found \" +\n+                    event.getFhirResource().getClass().getSimpleName());\n+        }\n+    }\n+\n+    /**\n+     * @param event\n+     * @param contextIds\n+     * @param collect\n+     * @throws FHIRPersistenceInterceptorException\n+     */\n+    private void enforce(Resource resource, List<String> contextIds, Permission requiredPermission, List<Scope> approvedScopes)\n+            throws FHIRPersistenceInterceptorException {\n+        Objects.requireNonNull(resource, \"resource\");\n+        Objects.requireNonNull(contextIds, \"contextIds\");\n+\n+        String resourceType = resource.getClass().getSimpleName();\n+        Map<ContextType, List<Scope>> approvedScopeMap = approvedScopes.stream()\n+                // First filter the list to only scopes which grant the required permissions on the passed resourceType\n+                .filter(s -> s.getResourceType() == ResourceType.ValueSet.RESOURCE ||\n+                        s.getResourceType().value().equals(resourceType))\n+                .filter(s -> hasPermission(s.getPermission(),requiredPermission))\n+                // Then group the scopes by their context type\n+                .collect(Collectors.groupingBy(s -> s.getContextType()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0MDA5OA=="}, "originalCommit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "originalPosition": 128}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNTEyNDgxOnYy", "diffSide": "RIGHT", "path": "fhir-smart/src/main/java/com/ibm/fhir/smart/AuthzPolicyEnforcementPersistenceInterceptor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNTozMzo0M1rOG7l7uQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNjowNDoxMVrOG7nM0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0MDY2NQ==", "bodyText": "FHIRSearchException... shouldn't this be an operation exception?", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465140665", "createdAt": "2020-08-04T15:33:43Z", "author": {"login": "prb112"}, "path": "fhir-smart/src/main/java/com/ibm/fhir/smart/AuthzPolicyEnforcementPersistenceInterceptor.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019, 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.smart;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import com.auth0.jwt.JWT;\n+import com.auth0.jwt.interfaces.Claim;\n+import com.auth0.jwt.interfaces.DecodedJWT;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Resource;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.code.CompartmentType;\n+import com.ibm.fhir.model.type.code.IssueType;\n+import com.ibm.fhir.model.type.code.ResourceType;\n+import com.ibm.fhir.model.util.FHIRUtil;\n+import com.ibm.fhir.path.FHIRPathNode;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator.EvaluationContext;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceEvent;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceInterceptor;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceInterceptorException;\n+import com.ibm.fhir.search.compartment.CompartmentUtil;\n+import com.ibm.fhir.search.exception.FHIRSearchException;\n+import com.ibm.fhir.search.util.SearchUtil;\n+import com.ibm.fhir.smart.Scope.ContextType;\n+import com.ibm.fhir.smart.Scope.Permission;\n+\n+public class AuthzPolicyEnforcementPersistenceInterceptor implements FHIRPersistenceInterceptor {\n+    private static final Logger log = Logger.getLogger(AuthzPolicyEnforcementPersistenceInterceptor.class.getName());\n+\n+    private static final String BEARER_TOKEN_PREFIX = \"Bearer\";\n+    private static final String PATIENT_REF_PREFIX = \"Patient/\";\n+\n+    @Override\n+    public void beforeCreate(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void beforeDelete(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getPrevFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void beforeUpdate(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        // TODO: do we need to check READ permission on the prevFhirResource as well?\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterRead(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterVread(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterHistory(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        if (event.getFhirResource() instanceof Bundle) {\n+            for ( Bundle.Entry entry : ((Bundle) event.getFhirResource()).getEntry()) {\n+                if (entry.getResource() != null) {\n+                    enforce(entry.getResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+                }\n+            }\n+        } else {\n+            throw new IllegalStateException(\"Expected event resource of type Bundle but found \" +\n+                    event.getFhirResource().getClass().getSimpleName());\n+        }\n+    }\n+\n+    @Override\n+    public void afterSearch(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        if (event.getFhirResource() instanceof Bundle) {\n+            for ( Bundle.Entry entry : ((Bundle) event.getFhirResource()).getEntry()) {\n+                if (entry.getResource() != null) {\n+                    enforce(entry.getResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+                }\n+            }\n+        } else {\n+            throw new IllegalStateException(\"Expected event resource of type Bundle but found \" +\n+                    event.getFhirResource().getClass().getSimpleName());\n+        }\n+    }\n+\n+    /**\n+     * @param event\n+     * @param contextIds\n+     * @param collect\n+     * @throws FHIRPersistenceInterceptorException\n+     */\n+    private void enforce(Resource resource, List<String> contextIds, Permission requiredPermission, List<Scope> approvedScopes)\n+            throws FHIRPersistenceInterceptorException {\n+        Objects.requireNonNull(resource, \"resource\");\n+        Objects.requireNonNull(contextIds, \"contextIds\");\n+\n+        String resourceType = resource.getClass().getSimpleName();\n+        Map<ContextType, List<Scope>> approvedScopeMap = approvedScopes.stream()\n+                // First filter the list to only scopes which grant the required permissions on the passed resourceType\n+                .filter(s -> s.getResourceType() == ResourceType.ValueSet.RESOURCE ||\n+                        s.getResourceType().value().equals(resourceType))\n+                .filter(s -> hasPermission(s.getPermission(),requiredPermission))\n+                // Then group the scopes by their context type\n+                .collect(Collectors.groupingBy(s -> s.getContextType()));\n+\n+        if (approvedScopeMap.containsKey(ContextType.PATIENT)) {\n+\n+            // If the target resource is the Patient resource which matches the in-context patient, allow it\n+            if (resource instanceof Patient && resource.getId() != null && contextIds.contains(resource.getId())) {\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Interaction is permitted via scope \" + approvedScopeMap.get(ContextType.PATIENT) +\n+                        \" with patient context '\" + resource.getId() + \"'\");\n+                }\n+                return;\n+            }\n+\n+            // Else, see if the target resource belongs to the Patient compartment of the in-context patient\n+            try {\n+                List<String> inclusionCriteria = CompartmentUtil\n+                        .getCompartmentResourceTypeInclusionCriteria(CompartmentType.PATIENT.getValue(), resourceType);\n+\n+                EvaluationContext resourceContext = new FHIRPathEvaluator.EvaluationContext(resource);\n+\n+                for (String searchParm : inclusionCriteria) {\n+                    try {\n+                        String expression = SearchUtil.getSearchParameter(resourceType, searchParm).getExpression().getValue();\n+                        Collection<FHIRPathNode> nodes = FHIRPathEvaluator.evaluator().evaluate(resourceContext, expression);\n+                        for (FHIRPathNode node : nodes) {\n+                            String patientRefVal = getPatientRefVal(node);\n+                            if (patientRefVal != null && contextIds.contains(patientRefVal)) {\n+                                if (log.isLoggable(Level.FINE)) {\n+                                    log.fine(\"Interaction is permitted via scope \" + approvedScopeMap.get(ContextType.PATIENT) +\n+                                        \" with patient context '\" + patientRefVal + \"'\");\n+                                }\n+                                return;\n+                            }\n+                        }\n+                    } catch (Exception e) {\n+                        log.log(Level.WARNING, \"Unexpected exception while processing inclusionCriteria '\" + searchParm +\n+                                \"' in the Patient compartment for resource type \" + resourceType);\n+                    }\n+                }\n+            } catch (FHIRSearchException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1NDE3Mg==", "bodyText": "this is whats thrown from CompartmentUtil.getCompartmentResourceTypeInclusionCriteria.  Potentially that could get refactored to throw something else, but I think its beyond the scope of this PR.  Please re-open if you disagree.", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465154172", "createdAt": "2020-08-04T15:53:24Z", "author": {"login": "lmsurpre"}, "path": "fhir-smart/src/main/java/com/ibm/fhir/smart/AuthzPolicyEnforcementPersistenceInterceptor.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019, 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.smart;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import com.auth0.jwt.JWT;\n+import com.auth0.jwt.interfaces.Claim;\n+import com.auth0.jwt.interfaces.DecodedJWT;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Resource;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.code.CompartmentType;\n+import com.ibm.fhir.model.type.code.IssueType;\n+import com.ibm.fhir.model.type.code.ResourceType;\n+import com.ibm.fhir.model.util.FHIRUtil;\n+import com.ibm.fhir.path.FHIRPathNode;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator.EvaluationContext;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceEvent;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceInterceptor;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceInterceptorException;\n+import com.ibm.fhir.search.compartment.CompartmentUtil;\n+import com.ibm.fhir.search.exception.FHIRSearchException;\n+import com.ibm.fhir.search.util.SearchUtil;\n+import com.ibm.fhir.smart.Scope.ContextType;\n+import com.ibm.fhir.smart.Scope.Permission;\n+\n+public class AuthzPolicyEnforcementPersistenceInterceptor implements FHIRPersistenceInterceptor {\n+    private static final Logger log = Logger.getLogger(AuthzPolicyEnforcementPersistenceInterceptor.class.getName());\n+\n+    private static final String BEARER_TOKEN_PREFIX = \"Bearer\";\n+    private static final String PATIENT_REF_PREFIX = \"Patient/\";\n+\n+    @Override\n+    public void beforeCreate(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void beforeDelete(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getPrevFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void beforeUpdate(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        // TODO: do we need to check READ permission on the prevFhirResource as well?\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterRead(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterVread(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterHistory(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        if (event.getFhirResource() instanceof Bundle) {\n+            for ( Bundle.Entry entry : ((Bundle) event.getFhirResource()).getEntry()) {\n+                if (entry.getResource() != null) {\n+                    enforce(entry.getResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+                }\n+            }\n+        } else {\n+            throw new IllegalStateException(\"Expected event resource of type Bundle but found \" +\n+                    event.getFhirResource().getClass().getSimpleName());\n+        }\n+    }\n+\n+    @Override\n+    public void afterSearch(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        if (event.getFhirResource() instanceof Bundle) {\n+            for ( Bundle.Entry entry : ((Bundle) event.getFhirResource()).getEntry()) {\n+                if (entry.getResource() != null) {\n+                    enforce(entry.getResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+                }\n+            }\n+        } else {\n+            throw new IllegalStateException(\"Expected event resource of type Bundle but found \" +\n+                    event.getFhirResource().getClass().getSimpleName());\n+        }\n+    }\n+\n+    /**\n+     * @param event\n+     * @param contextIds\n+     * @param collect\n+     * @throws FHIRPersistenceInterceptorException\n+     */\n+    private void enforce(Resource resource, List<String> contextIds, Permission requiredPermission, List<Scope> approvedScopes)\n+            throws FHIRPersistenceInterceptorException {\n+        Objects.requireNonNull(resource, \"resource\");\n+        Objects.requireNonNull(contextIds, \"contextIds\");\n+\n+        String resourceType = resource.getClass().getSimpleName();\n+        Map<ContextType, List<Scope>> approvedScopeMap = approvedScopes.stream()\n+                // First filter the list to only scopes which grant the required permissions on the passed resourceType\n+                .filter(s -> s.getResourceType() == ResourceType.ValueSet.RESOURCE ||\n+                        s.getResourceType().value().equals(resourceType))\n+                .filter(s -> hasPermission(s.getPermission(),requiredPermission))\n+                // Then group the scopes by their context type\n+                .collect(Collectors.groupingBy(s -> s.getContextType()));\n+\n+        if (approvedScopeMap.containsKey(ContextType.PATIENT)) {\n+\n+            // If the target resource is the Patient resource which matches the in-context patient, allow it\n+            if (resource instanceof Patient && resource.getId() != null && contextIds.contains(resource.getId())) {\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Interaction is permitted via scope \" + approvedScopeMap.get(ContextType.PATIENT) +\n+                        \" with patient context '\" + resource.getId() + \"'\");\n+                }\n+                return;\n+            }\n+\n+            // Else, see if the target resource belongs to the Patient compartment of the in-context patient\n+            try {\n+                List<String> inclusionCriteria = CompartmentUtil\n+                        .getCompartmentResourceTypeInclusionCriteria(CompartmentType.PATIENT.getValue(), resourceType);\n+\n+                EvaluationContext resourceContext = new FHIRPathEvaluator.EvaluationContext(resource);\n+\n+                for (String searchParm : inclusionCriteria) {\n+                    try {\n+                        String expression = SearchUtil.getSearchParameter(resourceType, searchParm).getExpression().getValue();\n+                        Collection<FHIRPathNode> nodes = FHIRPathEvaluator.evaluator().evaluate(resourceContext, expression);\n+                        for (FHIRPathNode node : nodes) {\n+                            String patientRefVal = getPatientRefVal(node);\n+                            if (patientRefVal != null && contextIds.contains(patientRefVal)) {\n+                                if (log.isLoggable(Level.FINE)) {\n+                                    log.fine(\"Interaction is permitted via scope \" + approvedScopeMap.get(ContextType.PATIENT) +\n+                                        \" with patient context '\" + patientRefVal + \"'\");\n+                                }\n+                                return;\n+                            }\n+                        }\n+                    } catch (Exception e) {\n+                        log.log(Level.WARNING, \"Unexpected exception while processing inclusionCriteria '\" + searchParm +\n+                                \"' in the Patient compartment for resource type \" + resourceType);\n+                    }\n+                }\n+            } catch (FHIRSearchException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0MDY2NQ=="}, "originalCommit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE2MTQyNA==", "bodyText": "this was more of a confirmation question.", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465161424", "createdAt": "2020-08-04T16:04:11Z", "author": {"login": "prb112"}, "path": "fhir-smart/src/main/java/com/ibm/fhir/smart/AuthzPolicyEnforcementPersistenceInterceptor.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019, 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.smart;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import com.auth0.jwt.JWT;\n+import com.auth0.jwt.interfaces.Claim;\n+import com.auth0.jwt.interfaces.DecodedJWT;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Resource;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.code.CompartmentType;\n+import com.ibm.fhir.model.type.code.IssueType;\n+import com.ibm.fhir.model.type.code.ResourceType;\n+import com.ibm.fhir.model.util.FHIRUtil;\n+import com.ibm.fhir.path.FHIRPathNode;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator.EvaluationContext;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceEvent;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceInterceptor;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceInterceptorException;\n+import com.ibm.fhir.search.compartment.CompartmentUtil;\n+import com.ibm.fhir.search.exception.FHIRSearchException;\n+import com.ibm.fhir.search.util.SearchUtil;\n+import com.ibm.fhir.smart.Scope.ContextType;\n+import com.ibm.fhir.smart.Scope.Permission;\n+\n+public class AuthzPolicyEnforcementPersistenceInterceptor implements FHIRPersistenceInterceptor {\n+    private static final Logger log = Logger.getLogger(AuthzPolicyEnforcementPersistenceInterceptor.class.getName());\n+\n+    private static final String BEARER_TOKEN_PREFIX = \"Bearer\";\n+    private static final String PATIENT_REF_PREFIX = \"Patient/\";\n+\n+    @Override\n+    public void beforeCreate(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void beforeDelete(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getPrevFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void beforeUpdate(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        // TODO: do we need to check READ permission on the prevFhirResource as well?\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterRead(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterVread(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterHistory(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        if (event.getFhirResource() instanceof Bundle) {\n+            for ( Bundle.Entry entry : ((Bundle) event.getFhirResource()).getEntry()) {\n+                if (entry.getResource() != null) {\n+                    enforce(entry.getResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+                }\n+            }\n+        } else {\n+            throw new IllegalStateException(\"Expected event resource of type Bundle but found \" +\n+                    event.getFhirResource().getClass().getSimpleName());\n+        }\n+    }\n+\n+    @Override\n+    public void afterSearch(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        if (event.getFhirResource() instanceof Bundle) {\n+            for ( Bundle.Entry entry : ((Bundle) event.getFhirResource()).getEntry()) {\n+                if (entry.getResource() != null) {\n+                    enforce(entry.getResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+                }\n+            }\n+        } else {\n+            throw new IllegalStateException(\"Expected event resource of type Bundle but found \" +\n+                    event.getFhirResource().getClass().getSimpleName());\n+        }\n+    }\n+\n+    /**\n+     * @param event\n+     * @param contextIds\n+     * @param collect\n+     * @throws FHIRPersistenceInterceptorException\n+     */\n+    private void enforce(Resource resource, List<String> contextIds, Permission requiredPermission, List<Scope> approvedScopes)\n+            throws FHIRPersistenceInterceptorException {\n+        Objects.requireNonNull(resource, \"resource\");\n+        Objects.requireNonNull(contextIds, \"contextIds\");\n+\n+        String resourceType = resource.getClass().getSimpleName();\n+        Map<ContextType, List<Scope>> approvedScopeMap = approvedScopes.stream()\n+                // First filter the list to only scopes which grant the required permissions on the passed resourceType\n+                .filter(s -> s.getResourceType() == ResourceType.ValueSet.RESOURCE ||\n+                        s.getResourceType().value().equals(resourceType))\n+                .filter(s -> hasPermission(s.getPermission(),requiredPermission))\n+                // Then group the scopes by their context type\n+                .collect(Collectors.groupingBy(s -> s.getContextType()));\n+\n+        if (approvedScopeMap.containsKey(ContextType.PATIENT)) {\n+\n+            // If the target resource is the Patient resource which matches the in-context patient, allow it\n+            if (resource instanceof Patient && resource.getId() != null && contextIds.contains(resource.getId())) {\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Interaction is permitted via scope \" + approvedScopeMap.get(ContextType.PATIENT) +\n+                        \" with patient context '\" + resource.getId() + \"'\");\n+                }\n+                return;\n+            }\n+\n+            // Else, see if the target resource belongs to the Patient compartment of the in-context patient\n+            try {\n+                List<String> inclusionCriteria = CompartmentUtil\n+                        .getCompartmentResourceTypeInclusionCriteria(CompartmentType.PATIENT.getValue(), resourceType);\n+\n+                EvaluationContext resourceContext = new FHIRPathEvaluator.EvaluationContext(resource);\n+\n+                for (String searchParm : inclusionCriteria) {\n+                    try {\n+                        String expression = SearchUtil.getSearchParameter(resourceType, searchParm).getExpression().getValue();\n+                        Collection<FHIRPathNode> nodes = FHIRPathEvaluator.evaluator().evaluate(resourceContext, expression);\n+                        for (FHIRPathNode node : nodes) {\n+                            String patientRefVal = getPatientRefVal(node);\n+                            if (patientRefVal != null && contextIds.contains(patientRefVal)) {\n+                                if (log.isLoggable(Level.FINE)) {\n+                                    log.fine(\"Interaction is permitted via scope \" + approvedScopeMap.get(ContextType.PATIENT) +\n+                                        \" with patient context '\" + patientRefVal + \"'\");\n+                                }\n+                                return;\n+                            }\n+                        }\n+                    } catch (Exception e) {\n+                        log.log(Level.WARNING, \"Unexpected exception while processing inclusionCriteria '\" + searchParm +\n+                                \"' in the Patient compartment for resource type \" + resourceType);\n+                    }\n+                }\n+            } catch (FHIRSearchException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0MDY2NQ=="}, "originalCommit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "originalPosition": 167}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNTEzMTk3OnYy", "diffSide": "RIGHT", "path": "fhir-smart/src/main/java/com/ibm/fhir/smart/AuthzPolicyEnforcementPersistenceInterceptor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNTozNToxNVrOG7mACA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNTo1NDowN1rOG7myPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0MTc2OA==", "bodyText": "interesting check...", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465141768", "createdAt": "2020-08-04T15:35:15Z", "author": {"login": "prb112"}, "path": "fhir-smart/src/main/java/com/ibm/fhir/smart/AuthzPolicyEnforcementPersistenceInterceptor.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019, 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.smart;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import com.auth0.jwt.JWT;\n+import com.auth0.jwt.interfaces.Claim;\n+import com.auth0.jwt.interfaces.DecodedJWT;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Resource;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.code.CompartmentType;\n+import com.ibm.fhir.model.type.code.IssueType;\n+import com.ibm.fhir.model.type.code.ResourceType;\n+import com.ibm.fhir.model.util.FHIRUtil;\n+import com.ibm.fhir.path.FHIRPathNode;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator.EvaluationContext;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceEvent;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceInterceptor;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceInterceptorException;\n+import com.ibm.fhir.search.compartment.CompartmentUtil;\n+import com.ibm.fhir.search.exception.FHIRSearchException;\n+import com.ibm.fhir.search.util.SearchUtil;\n+import com.ibm.fhir.smart.Scope.ContextType;\n+import com.ibm.fhir.smart.Scope.Permission;\n+\n+public class AuthzPolicyEnforcementPersistenceInterceptor implements FHIRPersistenceInterceptor {\n+    private static final Logger log = Logger.getLogger(AuthzPolicyEnforcementPersistenceInterceptor.class.getName());\n+\n+    private static final String BEARER_TOKEN_PREFIX = \"Bearer\";\n+    private static final String PATIENT_REF_PREFIX = \"Patient/\";\n+\n+    @Override\n+    public void beforeCreate(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void beforeDelete(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getPrevFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void beforeUpdate(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        // TODO: do we need to check READ permission on the prevFhirResource as well?\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterRead(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterVread(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterHistory(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        if (event.getFhirResource() instanceof Bundle) {\n+            for ( Bundle.Entry entry : ((Bundle) event.getFhirResource()).getEntry()) {\n+                if (entry.getResource() != null) {\n+                    enforce(entry.getResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+                }\n+            }\n+        } else {\n+            throw new IllegalStateException(\"Expected event resource of type Bundle but found \" +\n+                    event.getFhirResource().getClass().getSimpleName());\n+        }\n+    }\n+\n+    @Override\n+    public void afterSearch(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        if (event.getFhirResource() instanceof Bundle) {\n+            for ( Bundle.Entry entry : ((Bundle) event.getFhirResource()).getEntry()) {\n+                if (entry.getResource() != null) {\n+                    enforce(entry.getResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+                }\n+            }\n+        } else {\n+            throw new IllegalStateException(\"Expected event resource of type Bundle but found \" +\n+                    event.getFhirResource().getClass().getSimpleName());\n+        }\n+    }\n+\n+    /**\n+     * @param event\n+     * @param contextIds\n+     * @param collect\n+     * @throws FHIRPersistenceInterceptorException\n+     */\n+    private void enforce(Resource resource, List<String> contextIds, Permission requiredPermission, List<Scope> approvedScopes)\n+            throws FHIRPersistenceInterceptorException {\n+        Objects.requireNonNull(resource, \"resource\");\n+        Objects.requireNonNull(contextIds, \"contextIds\");\n+\n+        String resourceType = resource.getClass().getSimpleName();\n+        Map<ContextType, List<Scope>> approvedScopeMap = approvedScopes.stream()\n+                // First filter the list to only scopes which grant the required permissions on the passed resourceType\n+                .filter(s -> s.getResourceType() == ResourceType.ValueSet.RESOURCE ||\n+                        s.getResourceType().value().equals(resourceType))\n+                .filter(s -> hasPermission(s.getPermission(),requiredPermission))\n+                // Then group the scopes by their context type\n+                .collect(Collectors.groupingBy(s -> s.getContextType()));\n+\n+        if (approvedScopeMap.containsKey(ContextType.PATIENT)) {\n+\n+            // If the target resource is the Patient resource which matches the in-context patient, allow it\n+            if (resource instanceof Patient && resource.getId() != null && contextIds.contains(resource.getId())) {\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Interaction is permitted via scope \" + approvedScopeMap.get(ContextType.PATIENT) +\n+                        \" with patient context '\" + resource.getId() + \"'\");\n+                }\n+                return;\n+            }\n+\n+            // Else, see if the target resource belongs to the Patient compartment of the in-context patient\n+            try {\n+                List<String> inclusionCriteria = CompartmentUtil\n+                        .getCompartmentResourceTypeInclusionCriteria(CompartmentType.PATIENT.getValue(), resourceType);\n+\n+                EvaluationContext resourceContext = new FHIRPathEvaluator.EvaluationContext(resource);\n+\n+                for (String searchParm : inclusionCriteria) {\n+                    try {\n+                        String expression = SearchUtil.getSearchParameter(resourceType, searchParm).getExpression().getValue();\n+                        Collection<FHIRPathNode> nodes = FHIRPathEvaluator.evaluator().evaluate(resourceContext, expression);\n+                        for (FHIRPathNode node : nodes) {\n+                            String patientRefVal = getPatientRefVal(node);\n+                            if (patientRefVal != null && contextIds.contains(patientRefVal)) {\n+                                if (log.isLoggable(Level.FINE)) {\n+                                    log.fine(\"Interaction is permitted via scope \" + approvedScopeMap.get(ContextType.PATIENT) +\n+                                        \" with patient context '\" + patientRefVal + \"'\");\n+                                }\n+                                return;\n+                            }\n+                        }\n+                    } catch (Exception e) {\n+                        log.log(Level.WARNING, \"Unexpected exception while processing inclusionCriteria '\" + searchParm +\n+                                \"' in the Patient compartment for resource type \" + resourceType);\n+                    }\n+                }\n+            } catch (FHIRSearchException e) {\n+                log.log(Level.WARNING, \"Unexpected exception while enforcing authorization policy in the Patient compartment\"\n+                        + \" for resource type \" + resourceType);\n+            }\n+        }\n+\n+        if (approvedScopeMap.containsKey(ContextType.USER)) {\n+            throw new UnsupportedOperationException(\"SMART scopes with context type 'user' are not yet supported.\");\n+        }\n+\n+\n+        String msg = \"Requested interaction is not permitted by any of the passed scopes.\";\n+        throw new FHIRPersistenceInterceptorException(msg)\n+                .withIssue(FHIRUtil.buildOperationOutcomeIssue(msg, IssueType.FORBIDDEN));\n+    }\n+\n+    /**\n+     * @param node\n+     * @return the id to the Patient resource referenced by this node (assuming it is a Reference with a valid\n+     *         reference value); otherwise null\n+     */\n+    private String getPatientRefVal(FHIRPathNode node) {\n+        if (!node.isElementNode() || !node.asElementNode().element().is(Reference.class)) {\n+            throw new IllegalStateException(\"Patient compartment inclusionCriteria expression has returned a non-Reference\");\n+        }\n+        Reference reference = node.asElementNode().element().as(Reference.class);\n+        if (reference.getReference() != null && reference.getReference().hasValue()) {\n+            String refVal = reference.getReference().getValue();\n+            if (refVal != null && refVal.startsWith(PATIENT_REF_PREFIX)) {\n+                return refVal.substring(PATIENT_REF_PREFIX.length());\n+            }\n+        } else if (log.isLoggable(Level.FINE)){\n+            log.fine(\"Skipping non-patient / non-relative reference: '\" + reference + \"'\");\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * @param permission\n+     * @param requiredPermission\n+     * @return true if the grantedPermission includes the requiredPermission; otherwise false\n+     */\n+    private boolean hasPermission(Permission grantedPermission, Permission requiredPermission) {\n+        if (grantedPermission == Permission.ALL) {\n+            return true;\n+        } else {\n+            return grantedPermission == requiredPermission;\n+        }\n+    }\n+\n+    private String getAccessToken() throws FHIRPersistenceInterceptorException {\n+        List<String> list = FHIRRequestContext.get().getHttpHeaders().get(\"Authorization\");\n+        if (list.size() != 1) {\n+            throw new FHIRPersistenceInterceptorException(\"Request must contain exactly one Authorization header.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1NDYyMA==", "bodyText": "just trying to be defensive there, not attached to it.  re-open if you think it should be changed.", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465154620", "createdAt": "2020-08-04T15:54:07Z", "author": {"login": "lmsurpre"}, "path": "fhir-smart/src/main/java/com/ibm/fhir/smart/AuthzPolicyEnforcementPersistenceInterceptor.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019, 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.smart;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import com.auth0.jwt.JWT;\n+import com.auth0.jwt.interfaces.Claim;\n+import com.auth0.jwt.interfaces.DecodedJWT;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Resource;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.code.CompartmentType;\n+import com.ibm.fhir.model.type.code.IssueType;\n+import com.ibm.fhir.model.type.code.ResourceType;\n+import com.ibm.fhir.model.util.FHIRUtil;\n+import com.ibm.fhir.path.FHIRPathNode;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator.EvaluationContext;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceEvent;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceInterceptor;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceInterceptorException;\n+import com.ibm.fhir.search.compartment.CompartmentUtil;\n+import com.ibm.fhir.search.exception.FHIRSearchException;\n+import com.ibm.fhir.search.util.SearchUtil;\n+import com.ibm.fhir.smart.Scope.ContextType;\n+import com.ibm.fhir.smart.Scope.Permission;\n+\n+public class AuthzPolicyEnforcementPersistenceInterceptor implements FHIRPersistenceInterceptor {\n+    private static final Logger log = Logger.getLogger(AuthzPolicyEnforcementPersistenceInterceptor.class.getName());\n+\n+    private static final String BEARER_TOKEN_PREFIX = \"Bearer\";\n+    private static final String PATIENT_REF_PREFIX = \"Patient/\";\n+\n+    @Override\n+    public void beforeCreate(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void beforeDelete(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getPrevFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void beforeUpdate(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        // TODO: do we need to check READ permission on the prevFhirResource as well?\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterRead(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterVread(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterHistory(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        if (event.getFhirResource() instanceof Bundle) {\n+            for ( Bundle.Entry entry : ((Bundle) event.getFhirResource()).getEntry()) {\n+                if (entry.getResource() != null) {\n+                    enforce(entry.getResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+                }\n+            }\n+        } else {\n+            throw new IllegalStateException(\"Expected event resource of type Bundle but found \" +\n+                    event.getFhirResource().getClass().getSimpleName());\n+        }\n+    }\n+\n+    @Override\n+    public void afterSearch(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        if (event.getFhirResource() instanceof Bundle) {\n+            for ( Bundle.Entry entry : ((Bundle) event.getFhirResource()).getEntry()) {\n+                if (entry.getResource() != null) {\n+                    enforce(entry.getResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+                }\n+            }\n+        } else {\n+            throw new IllegalStateException(\"Expected event resource of type Bundle but found \" +\n+                    event.getFhirResource().getClass().getSimpleName());\n+        }\n+    }\n+\n+    /**\n+     * @param event\n+     * @param contextIds\n+     * @param collect\n+     * @throws FHIRPersistenceInterceptorException\n+     */\n+    private void enforce(Resource resource, List<String> contextIds, Permission requiredPermission, List<Scope> approvedScopes)\n+            throws FHIRPersistenceInterceptorException {\n+        Objects.requireNonNull(resource, \"resource\");\n+        Objects.requireNonNull(contextIds, \"contextIds\");\n+\n+        String resourceType = resource.getClass().getSimpleName();\n+        Map<ContextType, List<Scope>> approvedScopeMap = approvedScopes.stream()\n+                // First filter the list to only scopes which grant the required permissions on the passed resourceType\n+                .filter(s -> s.getResourceType() == ResourceType.ValueSet.RESOURCE ||\n+                        s.getResourceType().value().equals(resourceType))\n+                .filter(s -> hasPermission(s.getPermission(),requiredPermission))\n+                // Then group the scopes by their context type\n+                .collect(Collectors.groupingBy(s -> s.getContextType()));\n+\n+        if (approvedScopeMap.containsKey(ContextType.PATIENT)) {\n+\n+            // If the target resource is the Patient resource which matches the in-context patient, allow it\n+            if (resource instanceof Patient && resource.getId() != null && contextIds.contains(resource.getId())) {\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Interaction is permitted via scope \" + approvedScopeMap.get(ContextType.PATIENT) +\n+                        \" with patient context '\" + resource.getId() + \"'\");\n+                }\n+                return;\n+            }\n+\n+            // Else, see if the target resource belongs to the Patient compartment of the in-context patient\n+            try {\n+                List<String> inclusionCriteria = CompartmentUtil\n+                        .getCompartmentResourceTypeInclusionCriteria(CompartmentType.PATIENT.getValue(), resourceType);\n+\n+                EvaluationContext resourceContext = new FHIRPathEvaluator.EvaluationContext(resource);\n+\n+                for (String searchParm : inclusionCriteria) {\n+                    try {\n+                        String expression = SearchUtil.getSearchParameter(resourceType, searchParm).getExpression().getValue();\n+                        Collection<FHIRPathNode> nodes = FHIRPathEvaluator.evaluator().evaluate(resourceContext, expression);\n+                        for (FHIRPathNode node : nodes) {\n+                            String patientRefVal = getPatientRefVal(node);\n+                            if (patientRefVal != null && contextIds.contains(patientRefVal)) {\n+                                if (log.isLoggable(Level.FINE)) {\n+                                    log.fine(\"Interaction is permitted via scope \" + approvedScopeMap.get(ContextType.PATIENT) +\n+                                        \" with patient context '\" + patientRefVal + \"'\");\n+                                }\n+                                return;\n+                            }\n+                        }\n+                    } catch (Exception e) {\n+                        log.log(Level.WARNING, \"Unexpected exception while processing inclusionCriteria '\" + searchParm +\n+                                \"' in the Patient compartment for resource type \" + resourceType);\n+                    }\n+                }\n+            } catch (FHIRSearchException e) {\n+                log.log(Level.WARNING, \"Unexpected exception while enforcing authorization policy in the Patient compartment\"\n+                        + \" for resource type \" + resourceType);\n+            }\n+        }\n+\n+        if (approvedScopeMap.containsKey(ContextType.USER)) {\n+            throw new UnsupportedOperationException(\"SMART scopes with context type 'user' are not yet supported.\");\n+        }\n+\n+\n+        String msg = \"Requested interaction is not permitted by any of the passed scopes.\";\n+        throw new FHIRPersistenceInterceptorException(msg)\n+                .withIssue(FHIRUtil.buildOperationOutcomeIssue(msg, IssueType.FORBIDDEN));\n+    }\n+\n+    /**\n+     * @param node\n+     * @return the id to the Patient resource referenced by this node (assuming it is a Reference with a valid\n+     *         reference value); otherwise null\n+     */\n+    private String getPatientRefVal(FHIRPathNode node) {\n+        if (!node.isElementNode() || !node.asElementNode().element().is(Reference.class)) {\n+            throw new IllegalStateException(\"Patient compartment inclusionCriteria expression has returned a non-Reference\");\n+        }\n+        Reference reference = node.asElementNode().element().as(Reference.class);\n+        if (reference.getReference() != null && reference.getReference().hasValue()) {\n+            String refVal = reference.getReference().getValue();\n+            if (refVal != null && refVal.startsWith(PATIENT_REF_PREFIX)) {\n+                return refVal.substring(PATIENT_REF_PREFIX.length());\n+            }\n+        } else if (log.isLoggable(Level.FINE)){\n+            log.fine(\"Skipping non-patient / non-relative reference: '\" + reference + \"'\");\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * @param permission\n+     * @param requiredPermission\n+     * @return true if the grantedPermission includes the requiredPermission; otherwise false\n+     */\n+    private boolean hasPermission(Permission grantedPermission, Permission requiredPermission) {\n+        if (grantedPermission == Permission.ALL) {\n+            return true;\n+        } else {\n+            return grantedPermission == requiredPermission;\n+        }\n+    }\n+\n+    private String getAccessToken() throws FHIRPersistenceInterceptorException {\n+        List<String> list = FHIRRequestContext.get().getHttpHeaders().get(\"Authorization\");\n+        if (list.size() != 1) {\n+            throw new FHIRPersistenceInterceptorException(\"Request must contain exactly one Authorization header.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0MTc2OA=="}, "originalCommit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "originalPosition": 221}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNTEzNjUyOnYy", "diffSide": "RIGHT", "path": "fhir-smart/.gitignore", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNTozNjoxNlrOG7mCyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNTo1NzoyNVrOG7m7Rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0MjQ3Mg==", "bodyText": "should this perhaps go in a not top-level folder?\nor should this be fhir-auth-smart?\nIs it just going to be scoped to auth intercepting", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465142472", "createdAt": "2020-08-04T15:36:16Z", "author": {"login": "prb112"}, "path": "fhir-smart/.gitignore", "diffHunk": "@@ -0,0 +1,6 @@\n+/.apt_generated/\n+/.settings/\n+/target/\n+/test-output/\n+.factorypath\n+*.log", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1NTQ0MA==", "bodyText": "we already have a top-level .ignore that covers what we'll need...I'll empty this one out", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465155440", "createdAt": "2020-08-04T15:55:20Z", "author": {"login": "lmsurpre"}, "path": "fhir-smart/.gitignore", "diffHunk": "@@ -0,0 +1,6 @@\n+/.apt_generated/\n+/.settings/\n+/target/\n+/test-output/\n+.factorypath\n+*.log", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0MjQ3Mg=="}, "originalCommit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1NjkzNQ==", "bodyText": "done", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465156935", "createdAt": "2020-08-04T15:57:25Z", "author": {"login": "lmsurpre"}, "path": "fhir-smart/.gitignore", "diffHunk": "@@ -0,0 +1,6 @@\n+/.apt_generated/\n+/.settings/\n+/target/\n+/test-output/\n+.factorypath\n+*.log", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0MjQ3Mg=="}, "originalCommit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNTE0Mjc1OnYy", "diffSide": "RIGHT", "path": "fhir-smart/src/main/java/com/ibm/fhir/smart/AuthzPolicyEnforcementPersistenceInterceptor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNTozNzozOVrOG7mGrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNTo0ODowOVrOG7miug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0MzQ3MA==", "bodyText": "small set may be best to have a for loop.... same performance question", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465143470", "createdAt": "2020-08-04T15:37:39Z", "author": {"login": "prb112"}, "path": "fhir-smart/src/main/java/com/ibm/fhir/smart/AuthzPolicyEnforcementPersistenceInterceptor.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019, 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.smart;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import com.auth0.jwt.JWT;\n+import com.auth0.jwt.interfaces.Claim;\n+import com.auth0.jwt.interfaces.DecodedJWT;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Resource;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.code.CompartmentType;\n+import com.ibm.fhir.model.type.code.IssueType;\n+import com.ibm.fhir.model.type.code.ResourceType;\n+import com.ibm.fhir.model.util.FHIRUtil;\n+import com.ibm.fhir.path.FHIRPathNode;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator.EvaluationContext;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceEvent;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceInterceptor;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceInterceptorException;\n+import com.ibm.fhir.search.compartment.CompartmentUtil;\n+import com.ibm.fhir.search.exception.FHIRSearchException;\n+import com.ibm.fhir.search.util.SearchUtil;\n+import com.ibm.fhir.smart.Scope.ContextType;\n+import com.ibm.fhir.smart.Scope.Permission;\n+\n+public class AuthzPolicyEnforcementPersistenceInterceptor implements FHIRPersistenceInterceptor {\n+    private static final Logger log = Logger.getLogger(AuthzPolicyEnforcementPersistenceInterceptor.class.getName());\n+\n+    private static final String BEARER_TOKEN_PREFIX = \"Bearer\";\n+    private static final String PATIENT_REF_PREFIX = \"Patient/\";\n+\n+    @Override\n+    public void beforeCreate(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void beforeDelete(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getPrevFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void beforeUpdate(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        // TODO: do we need to check READ permission on the prevFhirResource as well?\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterRead(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterVread(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterHistory(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        if (event.getFhirResource() instanceof Bundle) {\n+            for ( Bundle.Entry entry : ((Bundle) event.getFhirResource()).getEntry()) {\n+                if (entry.getResource() != null) {\n+                    enforce(entry.getResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+                }\n+            }\n+        } else {\n+            throw new IllegalStateException(\"Expected event resource of type Bundle but found \" +\n+                    event.getFhirResource().getClass().getSimpleName());\n+        }\n+    }\n+\n+    @Override\n+    public void afterSearch(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        if (event.getFhirResource() instanceof Bundle) {\n+            for ( Bundle.Entry entry : ((Bundle) event.getFhirResource()).getEntry()) {\n+                if (entry.getResource() != null) {\n+                    enforce(entry.getResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+                }\n+            }\n+        } else {\n+            throw new IllegalStateException(\"Expected event resource of type Bundle but found \" +\n+                    event.getFhirResource().getClass().getSimpleName());\n+        }\n+    }\n+\n+    /**\n+     * @param event\n+     * @param contextIds\n+     * @param collect\n+     * @throws FHIRPersistenceInterceptorException\n+     */\n+    private void enforce(Resource resource, List<String> contextIds, Permission requiredPermission, List<Scope> approvedScopes)\n+            throws FHIRPersistenceInterceptorException {\n+        Objects.requireNonNull(resource, \"resource\");\n+        Objects.requireNonNull(contextIds, \"contextIds\");\n+\n+        String resourceType = resource.getClass().getSimpleName();\n+        Map<ContextType, List<Scope>> approvedScopeMap = approvedScopes.stream()\n+                // First filter the list to only scopes which grant the required permissions on the passed resourceType\n+                .filter(s -> s.getResourceType() == ResourceType.ValueSet.RESOURCE ||\n+                        s.getResourceType().value().equals(resourceType))\n+                .filter(s -> hasPermission(s.getPermission(),requiredPermission))\n+                // Then group the scopes by their context type\n+                .collect(Collectors.groupingBy(s -> s.getContextType()));\n+\n+        if (approvedScopeMap.containsKey(ContextType.PATIENT)) {\n+\n+            // If the target resource is the Patient resource which matches the in-context patient, allow it\n+            if (resource instanceof Patient && resource.getId() != null && contextIds.contains(resource.getId())) {\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Interaction is permitted via scope \" + approvedScopeMap.get(ContextType.PATIENT) +\n+                        \" with patient context '\" + resource.getId() + \"'\");\n+                }\n+                return;\n+            }\n+\n+            // Else, see if the target resource belongs to the Patient compartment of the in-context patient\n+            try {\n+                List<String> inclusionCriteria = CompartmentUtil\n+                        .getCompartmentResourceTypeInclusionCriteria(CompartmentType.PATIENT.getValue(), resourceType);\n+\n+                EvaluationContext resourceContext = new FHIRPathEvaluator.EvaluationContext(resource);\n+\n+                for (String searchParm : inclusionCriteria) {\n+                    try {\n+                        String expression = SearchUtil.getSearchParameter(resourceType, searchParm).getExpression().getValue();\n+                        Collection<FHIRPathNode> nodes = FHIRPathEvaluator.evaluator().evaluate(resourceContext, expression);\n+                        for (FHIRPathNode node : nodes) {\n+                            String patientRefVal = getPatientRefVal(node);\n+                            if (patientRefVal != null && contextIds.contains(patientRefVal)) {\n+                                if (log.isLoggable(Level.FINE)) {\n+                                    log.fine(\"Interaction is permitted via scope \" + approvedScopeMap.get(ContextType.PATIENT) +\n+                                        \" with patient context '\" + patientRefVal + \"'\");\n+                                }\n+                                return;\n+                            }\n+                        }\n+                    } catch (Exception e) {\n+                        log.log(Level.WARNING, \"Unexpected exception while processing inclusionCriteria '\" + searchParm +\n+                                \"' in the Patient compartment for resource type \" + resourceType);\n+                    }\n+                }\n+            } catch (FHIRSearchException e) {\n+                log.log(Level.WARNING, \"Unexpected exception while enforcing authorization policy in the Patient compartment\"\n+                        + \" for resource type \" + resourceType);\n+            }\n+        }\n+\n+        if (approvedScopeMap.containsKey(ContextType.USER)) {\n+            throw new UnsupportedOperationException(\"SMART scopes with context type 'user' are not yet supported.\");\n+        }\n+\n+\n+        String msg = \"Requested interaction is not permitted by any of the passed scopes.\";\n+        throw new FHIRPersistenceInterceptorException(msg)\n+                .withIssue(FHIRUtil.buildOperationOutcomeIssue(msg, IssueType.FORBIDDEN));\n+    }\n+\n+    /**\n+     * @param node\n+     * @return the id to the Patient resource referenced by this node (assuming it is a Reference with a valid\n+     *         reference value); otherwise null\n+     */\n+    private String getPatientRefVal(FHIRPathNode node) {\n+        if (!node.isElementNode() || !node.asElementNode().element().is(Reference.class)) {\n+            throw new IllegalStateException(\"Patient compartment inclusionCriteria expression has returned a non-Reference\");\n+        }\n+        Reference reference = node.asElementNode().element().as(Reference.class);\n+        if (reference.getReference() != null && reference.getReference().hasValue()) {\n+            String refVal = reference.getReference().getValue();\n+            if (refVal != null && refVal.startsWith(PATIENT_REF_PREFIX)) {\n+                return refVal.substring(PATIENT_REF_PREFIX.length());\n+            }\n+        } else if (log.isLoggable(Level.FINE)){\n+            log.fine(\"Skipping non-patient / non-relative reference: '\" + reference + \"'\");\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * @param permission\n+     * @param requiredPermission\n+     * @return true if the grantedPermission includes the requiredPermission; otherwise false\n+     */\n+    private boolean hasPermission(Permission grantedPermission, Permission requiredPermission) {\n+        if (grantedPermission == Permission.ALL) {\n+            return true;\n+        } else {\n+            return grantedPermission == requiredPermission;\n+        }\n+    }\n+\n+    private String getAccessToken() throws FHIRPersistenceInterceptorException {\n+        List<String> list = FHIRRequestContext.get().getHttpHeaders().get(\"Authorization\");\n+        if (list.size() != 1) {\n+            throw new FHIRPersistenceInterceptorException(\"Request must contain exactly one Authorization header.\");\n+        }\n+        String header = list.get(0);\n+\n+        if (!header.startsWith(BEARER_TOKEN_PREFIX)) {\n+            throw new FHIRPersistenceInterceptorException(\"Authorization header must carry a Bearer token\");\n+        }\n+\n+        return header.substring(BEARER_TOKEN_PREFIX.length()).trim();\n+    }\n+\n+    private List<Scope> getScopesFromToken(DecodedJWT jwt) {\n+        Claim claim = jwt.getClaim(\"scope\");\n+        if (claim.isNull()) {\n+            throw new IllegalArgumentException(\"Authorization token is missing 'scope' claim\");\n+        }\n+\n+        List<String> scopeStrings;\n+        String claimString = claim.asString();\n+\n+        if (claimString != null) {\n+            scopeStrings = Arrays.asList(claim.asString().split(\"\\\\s+\"));\n+        } else {\n+            log.fine(\"Found scope claim was expected to be a string but is not; processing as a list\");\n+            scopeStrings = claim.asList(String.class);\n+        }\n+\n+        return scopeStrings.stream()\n+                .filter(s -> s.matches(Scope.SCOPE_STRING_REGEX))\n+                .map(s -> new Scope(s))\n+                .collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "originalPosition": 251}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1MDY1MA==", "bodyText": "same response.  can change if needed, but I think its fine.", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465150650", "createdAt": "2020-08-04T15:48:09Z", "author": {"login": "lmsurpre"}, "path": "fhir-smart/src/main/java/com/ibm/fhir/smart/AuthzPolicyEnforcementPersistenceInterceptor.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019, 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.smart;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import com.auth0.jwt.JWT;\n+import com.auth0.jwt.interfaces.Claim;\n+import com.auth0.jwt.interfaces.DecodedJWT;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Resource;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.code.CompartmentType;\n+import com.ibm.fhir.model.type.code.IssueType;\n+import com.ibm.fhir.model.type.code.ResourceType;\n+import com.ibm.fhir.model.util.FHIRUtil;\n+import com.ibm.fhir.path.FHIRPathNode;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator.EvaluationContext;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceEvent;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceInterceptor;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceInterceptorException;\n+import com.ibm.fhir.search.compartment.CompartmentUtil;\n+import com.ibm.fhir.search.exception.FHIRSearchException;\n+import com.ibm.fhir.search.util.SearchUtil;\n+import com.ibm.fhir.smart.Scope.ContextType;\n+import com.ibm.fhir.smart.Scope.Permission;\n+\n+public class AuthzPolicyEnforcementPersistenceInterceptor implements FHIRPersistenceInterceptor {\n+    private static final Logger log = Logger.getLogger(AuthzPolicyEnforcementPersistenceInterceptor.class.getName());\n+\n+    private static final String BEARER_TOKEN_PREFIX = \"Bearer\";\n+    private static final String PATIENT_REF_PREFIX = \"Patient/\";\n+\n+    @Override\n+    public void beforeCreate(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void beforeDelete(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getPrevFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void beforeUpdate(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        // TODO: do we need to check READ permission on the prevFhirResource as well?\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterRead(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterVread(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterHistory(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        if (event.getFhirResource() instanceof Bundle) {\n+            for ( Bundle.Entry entry : ((Bundle) event.getFhirResource()).getEntry()) {\n+                if (entry.getResource() != null) {\n+                    enforce(entry.getResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+                }\n+            }\n+        } else {\n+            throw new IllegalStateException(\"Expected event resource of type Bundle but found \" +\n+                    event.getFhirResource().getClass().getSimpleName());\n+        }\n+    }\n+\n+    @Override\n+    public void afterSearch(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        if (event.getFhirResource() instanceof Bundle) {\n+            for ( Bundle.Entry entry : ((Bundle) event.getFhirResource()).getEntry()) {\n+                if (entry.getResource() != null) {\n+                    enforce(entry.getResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+                }\n+            }\n+        } else {\n+            throw new IllegalStateException(\"Expected event resource of type Bundle but found \" +\n+                    event.getFhirResource().getClass().getSimpleName());\n+        }\n+    }\n+\n+    /**\n+     * @param event\n+     * @param contextIds\n+     * @param collect\n+     * @throws FHIRPersistenceInterceptorException\n+     */\n+    private void enforce(Resource resource, List<String> contextIds, Permission requiredPermission, List<Scope> approvedScopes)\n+            throws FHIRPersistenceInterceptorException {\n+        Objects.requireNonNull(resource, \"resource\");\n+        Objects.requireNonNull(contextIds, \"contextIds\");\n+\n+        String resourceType = resource.getClass().getSimpleName();\n+        Map<ContextType, List<Scope>> approvedScopeMap = approvedScopes.stream()\n+                // First filter the list to only scopes which grant the required permissions on the passed resourceType\n+                .filter(s -> s.getResourceType() == ResourceType.ValueSet.RESOURCE ||\n+                        s.getResourceType().value().equals(resourceType))\n+                .filter(s -> hasPermission(s.getPermission(),requiredPermission))\n+                // Then group the scopes by their context type\n+                .collect(Collectors.groupingBy(s -> s.getContextType()));\n+\n+        if (approvedScopeMap.containsKey(ContextType.PATIENT)) {\n+\n+            // If the target resource is the Patient resource which matches the in-context patient, allow it\n+            if (resource instanceof Patient && resource.getId() != null && contextIds.contains(resource.getId())) {\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Interaction is permitted via scope \" + approvedScopeMap.get(ContextType.PATIENT) +\n+                        \" with patient context '\" + resource.getId() + \"'\");\n+                }\n+                return;\n+            }\n+\n+            // Else, see if the target resource belongs to the Patient compartment of the in-context patient\n+            try {\n+                List<String> inclusionCriteria = CompartmentUtil\n+                        .getCompartmentResourceTypeInclusionCriteria(CompartmentType.PATIENT.getValue(), resourceType);\n+\n+                EvaluationContext resourceContext = new FHIRPathEvaluator.EvaluationContext(resource);\n+\n+                for (String searchParm : inclusionCriteria) {\n+                    try {\n+                        String expression = SearchUtil.getSearchParameter(resourceType, searchParm).getExpression().getValue();\n+                        Collection<FHIRPathNode> nodes = FHIRPathEvaluator.evaluator().evaluate(resourceContext, expression);\n+                        for (FHIRPathNode node : nodes) {\n+                            String patientRefVal = getPatientRefVal(node);\n+                            if (patientRefVal != null && contextIds.contains(patientRefVal)) {\n+                                if (log.isLoggable(Level.FINE)) {\n+                                    log.fine(\"Interaction is permitted via scope \" + approvedScopeMap.get(ContextType.PATIENT) +\n+                                        \" with patient context '\" + patientRefVal + \"'\");\n+                                }\n+                                return;\n+                            }\n+                        }\n+                    } catch (Exception e) {\n+                        log.log(Level.WARNING, \"Unexpected exception while processing inclusionCriteria '\" + searchParm +\n+                                \"' in the Patient compartment for resource type \" + resourceType);\n+                    }\n+                }\n+            } catch (FHIRSearchException e) {\n+                log.log(Level.WARNING, \"Unexpected exception while enforcing authorization policy in the Patient compartment\"\n+                        + \" for resource type \" + resourceType);\n+            }\n+        }\n+\n+        if (approvedScopeMap.containsKey(ContextType.USER)) {\n+            throw new UnsupportedOperationException(\"SMART scopes with context type 'user' are not yet supported.\");\n+        }\n+\n+\n+        String msg = \"Requested interaction is not permitted by any of the passed scopes.\";\n+        throw new FHIRPersistenceInterceptorException(msg)\n+                .withIssue(FHIRUtil.buildOperationOutcomeIssue(msg, IssueType.FORBIDDEN));\n+    }\n+\n+    /**\n+     * @param node\n+     * @return the id to the Patient resource referenced by this node (assuming it is a Reference with a valid\n+     *         reference value); otherwise null\n+     */\n+    private String getPatientRefVal(FHIRPathNode node) {\n+        if (!node.isElementNode() || !node.asElementNode().element().is(Reference.class)) {\n+            throw new IllegalStateException(\"Patient compartment inclusionCriteria expression has returned a non-Reference\");\n+        }\n+        Reference reference = node.asElementNode().element().as(Reference.class);\n+        if (reference.getReference() != null && reference.getReference().hasValue()) {\n+            String refVal = reference.getReference().getValue();\n+            if (refVal != null && refVal.startsWith(PATIENT_REF_PREFIX)) {\n+                return refVal.substring(PATIENT_REF_PREFIX.length());\n+            }\n+        } else if (log.isLoggable(Level.FINE)){\n+            log.fine(\"Skipping non-patient / non-relative reference: '\" + reference + \"'\");\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * @param permission\n+     * @param requiredPermission\n+     * @return true if the grantedPermission includes the requiredPermission; otherwise false\n+     */\n+    private boolean hasPermission(Permission grantedPermission, Permission requiredPermission) {\n+        if (grantedPermission == Permission.ALL) {\n+            return true;\n+        } else {\n+            return grantedPermission == requiredPermission;\n+        }\n+    }\n+\n+    private String getAccessToken() throws FHIRPersistenceInterceptorException {\n+        List<String> list = FHIRRequestContext.get().getHttpHeaders().get(\"Authorization\");\n+        if (list.size() != 1) {\n+            throw new FHIRPersistenceInterceptorException(\"Request must contain exactly one Authorization header.\");\n+        }\n+        String header = list.get(0);\n+\n+        if (!header.startsWith(BEARER_TOKEN_PREFIX)) {\n+            throw new FHIRPersistenceInterceptorException(\"Authorization header must carry a Bearer token\");\n+        }\n+\n+        return header.substring(BEARER_TOKEN_PREFIX.length()).trim();\n+    }\n+\n+    private List<Scope> getScopesFromToken(DecodedJWT jwt) {\n+        Claim claim = jwt.getClaim(\"scope\");\n+        if (claim.isNull()) {\n+            throw new IllegalArgumentException(\"Authorization token is missing 'scope' claim\");\n+        }\n+\n+        List<String> scopeStrings;\n+        String claimString = claim.asString();\n+\n+        if (claimString != null) {\n+            scopeStrings = Arrays.asList(claim.asString().split(\"\\\\s+\"));\n+        } else {\n+            log.fine(\"Found scope claim was expected to be a string but is not; processing as a list\");\n+            scopeStrings = claim.asList(String.class);\n+        }\n+\n+        return scopeStrings.stream()\n+                .filter(s -> s.matches(Scope.SCOPE_STRING_REGEX))\n+                .map(s -> new Scope(s))\n+                .collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0MzQ3MA=="}, "originalCommit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "originalPosition": 251}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNTE0NTM0OnYy", "diffSide": "RIGHT", "path": "fhir-smart/src/main/java/com/ibm/fhir/smart/AuthzPolicyEnforcementPersistenceInterceptor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNTozODoxNlrOG7mITQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNjowMTo1MlrOG7nHNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0Mzg4NQ==", "bodyText": "Are you anticipating more than one id?", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465143885", "createdAt": "2020-08-04T15:38:16Z", "author": {"login": "prb112"}, "path": "fhir-smart/src/main/java/com/ibm/fhir/smart/AuthzPolicyEnforcementPersistenceInterceptor.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019, 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.smart;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import com.auth0.jwt.JWT;\n+import com.auth0.jwt.interfaces.Claim;\n+import com.auth0.jwt.interfaces.DecodedJWT;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Resource;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.code.CompartmentType;\n+import com.ibm.fhir.model.type.code.IssueType;\n+import com.ibm.fhir.model.type.code.ResourceType;\n+import com.ibm.fhir.model.util.FHIRUtil;\n+import com.ibm.fhir.path.FHIRPathNode;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator.EvaluationContext;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceEvent;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceInterceptor;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceInterceptorException;\n+import com.ibm.fhir.search.compartment.CompartmentUtil;\n+import com.ibm.fhir.search.exception.FHIRSearchException;\n+import com.ibm.fhir.search.util.SearchUtil;\n+import com.ibm.fhir.smart.Scope.ContextType;\n+import com.ibm.fhir.smart.Scope.Permission;\n+\n+public class AuthzPolicyEnforcementPersistenceInterceptor implements FHIRPersistenceInterceptor {\n+    private static final Logger log = Logger.getLogger(AuthzPolicyEnforcementPersistenceInterceptor.class.getName());\n+\n+    private static final String BEARER_TOKEN_PREFIX = \"Bearer\";\n+    private static final String PATIENT_REF_PREFIX = \"Patient/\";\n+\n+    @Override\n+    public void beforeCreate(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void beforeDelete(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getPrevFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void beforeUpdate(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        // TODO: do we need to check READ permission on the prevFhirResource as well?\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterRead(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterVread(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterHistory(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        if (event.getFhirResource() instanceof Bundle) {\n+            for ( Bundle.Entry entry : ((Bundle) event.getFhirResource()).getEntry()) {\n+                if (entry.getResource() != null) {\n+                    enforce(entry.getResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+                }\n+            }\n+        } else {\n+            throw new IllegalStateException(\"Expected event resource of type Bundle but found \" +\n+                    event.getFhirResource().getClass().getSimpleName());\n+        }\n+    }\n+\n+    @Override\n+    public void afterSearch(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        if (event.getFhirResource() instanceof Bundle) {\n+            for ( Bundle.Entry entry : ((Bundle) event.getFhirResource()).getEntry()) {\n+                if (entry.getResource() != null) {\n+                    enforce(entry.getResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+                }\n+            }\n+        } else {\n+            throw new IllegalStateException(\"Expected event resource of type Bundle but found \" +\n+                    event.getFhirResource().getClass().getSimpleName());\n+        }\n+    }\n+\n+    /**\n+     * @param event\n+     * @param contextIds\n+     * @param collect\n+     * @throws FHIRPersistenceInterceptorException\n+     */\n+    private void enforce(Resource resource, List<String> contextIds, Permission requiredPermission, List<Scope> approvedScopes)\n+            throws FHIRPersistenceInterceptorException {\n+        Objects.requireNonNull(resource, \"resource\");\n+        Objects.requireNonNull(contextIds, \"contextIds\");\n+\n+        String resourceType = resource.getClass().getSimpleName();\n+        Map<ContextType, List<Scope>> approvedScopeMap = approvedScopes.stream()\n+                // First filter the list to only scopes which grant the required permissions on the passed resourceType\n+                .filter(s -> s.getResourceType() == ResourceType.ValueSet.RESOURCE ||\n+                        s.getResourceType().value().equals(resourceType))\n+                .filter(s -> hasPermission(s.getPermission(),requiredPermission))\n+                // Then group the scopes by their context type\n+                .collect(Collectors.groupingBy(s -> s.getContextType()));\n+\n+        if (approvedScopeMap.containsKey(ContextType.PATIENT)) {\n+\n+            // If the target resource is the Patient resource which matches the in-context patient, allow it\n+            if (resource instanceof Patient && resource.getId() != null && contextIds.contains(resource.getId())) {\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Interaction is permitted via scope \" + approvedScopeMap.get(ContextType.PATIENT) +\n+                        \" with patient context '\" + resource.getId() + \"'\");\n+                }\n+                return;\n+            }\n+\n+            // Else, see if the target resource belongs to the Patient compartment of the in-context patient\n+            try {\n+                List<String> inclusionCriteria = CompartmentUtil\n+                        .getCompartmentResourceTypeInclusionCriteria(CompartmentType.PATIENT.getValue(), resourceType);\n+\n+                EvaluationContext resourceContext = new FHIRPathEvaluator.EvaluationContext(resource);\n+\n+                for (String searchParm : inclusionCriteria) {\n+                    try {\n+                        String expression = SearchUtil.getSearchParameter(resourceType, searchParm).getExpression().getValue();\n+                        Collection<FHIRPathNode> nodes = FHIRPathEvaluator.evaluator().evaluate(resourceContext, expression);\n+                        for (FHIRPathNode node : nodes) {\n+                            String patientRefVal = getPatientRefVal(node);\n+                            if (patientRefVal != null && contextIds.contains(patientRefVal)) {\n+                                if (log.isLoggable(Level.FINE)) {\n+                                    log.fine(\"Interaction is permitted via scope \" + approvedScopeMap.get(ContextType.PATIENT) +\n+                                        \" with patient context '\" + patientRefVal + \"'\");\n+                                }\n+                                return;\n+                            }\n+                        }\n+                    } catch (Exception e) {\n+                        log.log(Level.WARNING, \"Unexpected exception while processing inclusionCriteria '\" + searchParm +\n+                                \"' in the Patient compartment for resource type \" + resourceType);\n+                    }\n+                }\n+            } catch (FHIRSearchException e) {\n+                log.log(Level.WARNING, \"Unexpected exception while enforcing authorization policy in the Patient compartment\"\n+                        + \" for resource type \" + resourceType);\n+            }\n+        }\n+\n+        if (approvedScopeMap.containsKey(ContextType.USER)) {\n+            throw new UnsupportedOperationException(\"SMART scopes with context type 'user' are not yet supported.\");\n+        }\n+\n+\n+        String msg = \"Requested interaction is not permitted by any of the passed scopes.\";\n+        throw new FHIRPersistenceInterceptorException(msg)\n+                .withIssue(FHIRUtil.buildOperationOutcomeIssue(msg, IssueType.FORBIDDEN));\n+    }\n+\n+    /**\n+     * @param node\n+     * @return the id to the Patient resource referenced by this node (assuming it is a Reference with a valid\n+     *         reference value); otherwise null\n+     */\n+    private String getPatientRefVal(FHIRPathNode node) {\n+        if (!node.isElementNode() || !node.asElementNode().element().is(Reference.class)) {\n+            throw new IllegalStateException(\"Patient compartment inclusionCriteria expression has returned a non-Reference\");\n+        }\n+        Reference reference = node.asElementNode().element().as(Reference.class);\n+        if (reference.getReference() != null && reference.getReference().hasValue()) {\n+            String refVal = reference.getReference().getValue();\n+            if (refVal != null && refVal.startsWith(PATIENT_REF_PREFIX)) {\n+                return refVal.substring(PATIENT_REF_PREFIX.length());\n+            }\n+        } else if (log.isLoggable(Level.FINE)){\n+            log.fine(\"Skipping non-patient / non-relative reference: '\" + reference + \"'\");\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * @param permission\n+     * @param requiredPermission\n+     * @return true if the grantedPermission includes the requiredPermission; otherwise false\n+     */\n+    private boolean hasPermission(Permission grantedPermission, Permission requiredPermission) {\n+        if (grantedPermission == Permission.ALL) {\n+            return true;\n+        } else {\n+            return grantedPermission == requiredPermission;\n+        }\n+    }\n+\n+    private String getAccessToken() throws FHIRPersistenceInterceptorException {\n+        List<String> list = FHIRRequestContext.get().getHttpHeaders().get(\"Authorization\");\n+        if (list.size() != 1) {\n+            throw new FHIRPersistenceInterceptorException(\"Request must contain exactly one Authorization header.\");\n+        }\n+        String header = list.get(0);\n+\n+        if (!header.startsWith(BEARER_TOKEN_PREFIX)) {\n+            throw new FHIRPersistenceInterceptorException(\"Authorization header must carry a Bearer token\");\n+        }\n+\n+        return header.substring(BEARER_TOKEN_PREFIX.length()).trim();\n+    }\n+\n+    private List<Scope> getScopesFromToken(DecodedJWT jwt) {\n+        Claim claim = jwt.getClaim(\"scope\");\n+        if (claim.isNull()) {\n+            throw new IllegalArgumentException(\"Authorization token is missing 'scope' claim\");\n+        }\n+\n+        List<String> scopeStrings;\n+        String claimString = claim.asString();\n+\n+        if (claimString != null) {\n+            scopeStrings = Arrays.asList(claim.asString().split(\"\\\\s+\"));\n+        } else {\n+            log.fine(\"Found scope claim was expected to be a string but is not; processing as a list\");\n+            scopeStrings = claim.asList(String.class);\n+        }\n+\n+        return scopeStrings.stream()\n+                .filter(s -> s.matches(Scope.SCOPE_STRING_REGEX))\n+                .map(s -> new Scope(s))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private List<String> getPatientIdFromToken(DecodedJWT jwt) {\n+        Claim claim = jwt.getClaim(\"patient_id\");\n+        if (claim.isNull()) {\n+            throw new IllegalArgumentException(\"Authorization token is missing 'patient_id' claim\");\n+        }\n+\n+        String patientId = claim.asString();\n+        if (patientId == null) {\n+            log.fine(\"Found patient_id claim was expected to be a string but is not; processing as a list\");\n+            return claim.asList(String.class);\n+        }\n+\n+        return Collections.singletonList(patientId);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "originalPosition": 267}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1MTE1MA==", "bodyText": "Wanted to leave the door open for it, but could refactor to assume a single patientId is in-scope if desired.", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465151150", "createdAt": "2020-08-04T15:48:57Z", "author": {"login": "lmsurpre"}, "path": "fhir-smart/src/main/java/com/ibm/fhir/smart/AuthzPolicyEnforcementPersistenceInterceptor.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019, 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.smart;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import com.auth0.jwt.JWT;\n+import com.auth0.jwt.interfaces.Claim;\n+import com.auth0.jwt.interfaces.DecodedJWT;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Resource;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.code.CompartmentType;\n+import com.ibm.fhir.model.type.code.IssueType;\n+import com.ibm.fhir.model.type.code.ResourceType;\n+import com.ibm.fhir.model.util.FHIRUtil;\n+import com.ibm.fhir.path.FHIRPathNode;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator.EvaluationContext;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceEvent;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceInterceptor;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceInterceptorException;\n+import com.ibm.fhir.search.compartment.CompartmentUtil;\n+import com.ibm.fhir.search.exception.FHIRSearchException;\n+import com.ibm.fhir.search.util.SearchUtil;\n+import com.ibm.fhir.smart.Scope.ContextType;\n+import com.ibm.fhir.smart.Scope.Permission;\n+\n+public class AuthzPolicyEnforcementPersistenceInterceptor implements FHIRPersistenceInterceptor {\n+    private static final Logger log = Logger.getLogger(AuthzPolicyEnforcementPersistenceInterceptor.class.getName());\n+\n+    private static final String BEARER_TOKEN_PREFIX = \"Bearer\";\n+    private static final String PATIENT_REF_PREFIX = \"Patient/\";\n+\n+    @Override\n+    public void beforeCreate(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void beforeDelete(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getPrevFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void beforeUpdate(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        // TODO: do we need to check READ permission on the prevFhirResource as well?\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterRead(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterVread(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterHistory(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        if (event.getFhirResource() instanceof Bundle) {\n+            for ( Bundle.Entry entry : ((Bundle) event.getFhirResource()).getEntry()) {\n+                if (entry.getResource() != null) {\n+                    enforce(entry.getResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+                }\n+            }\n+        } else {\n+            throw new IllegalStateException(\"Expected event resource of type Bundle but found \" +\n+                    event.getFhirResource().getClass().getSimpleName());\n+        }\n+    }\n+\n+    @Override\n+    public void afterSearch(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        if (event.getFhirResource() instanceof Bundle) {\n+            for ( Bundle.Entry entry : ((Bundle) event.getFhirResource()).getEntry()) {\n+                if (entry.getResource() != null) {\n+                    enforce(entry.getResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+                }\n+            }\n+        } else {\n+            throw new IllegalStateException(\"Expected event resource of type Bundle but found \" +\n+                    event.getFhirResource().getClass().getSimpleName());\n+        }\n+    }\n+\n+    /**\n+     * @param event\n+     * @param contextIds\n+     * @param collect\n+     * @throws FHIRPersistenceInterceptorException\n+     */\n+    private void enforce(Resource resource, List<String> contextIds, Permission requiredPermission, List<Scope> approvedScopes)\n+            throws FHIRPersistenceInterceptorException {\n+        Objects.requireNonNull(resource, \"resource\");\n+        Objects.requireNonNull(contextIds, \"contextIds\");\n+\n+        String resourceType = resource.getClass().getSimpleName();\n+        Map<ContextType, List<Scope>> approvedScopeMap = approvedScopes.stream()\n+                // First filter the list to only scopes which grant the required permissions on the passed resourceType\n+                .filter(s -> s.getResourceType() == ResourceType.ValueSet.RESOURCE ||\n+                        s.getResourceType().value().equals(resourceType))\n+                .filter(s -> hasPermission(s.getPermission(),requiredPermission))\n+                // Then group the scopes by their context type\n+                .collect(Collectors.groupingBy(s -> s.getContextType()));\n+\n+        if (approvedScopeMap.containsKey(ContextType.PATIENT)) {\n+\n+            // If the target resource is the Patient resource which matches the in-context patient, allow it\n+            if (resource instanceof Patient && resource.getId() != null && contextIds.contains(resource.getId())) {\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Interaction is permitted via scope \" + approvedScopeMap.get(ContextType.PATIENT) +\n+                        \" with patient context '\" + resource.getId() + \"'\");\n+                }\n+                return;\n+            }\n+\n+            // Else, see if the target resource belongs to the Patient compartment of the in-context patient\n+            try {\n+                List<String> inclusionCriteria = CompartmentUtil\n+                        .getCompartmentResourceTypeInclusionCriteria(CompartmentType.PATIENT.getValue(), resourceType);\n+\n+                EvaluationContext resourceContext = new FHIRPathEvaluator.EvaluationContext(resource);\n+\n+                for (String searchParm : inclusionCriteria) {\n+                    try {\n+                        String expression = SearchUtil.getSearchParameter(resourceType, searchParm).getExpression().getValue();\n+                        Collection<FHIRPathNode> nodes = FHIRPathEvaluator.evaluator().evaluate(resourceContext, expression);\n+                        for (FHIRPathNode node : nodes) {\n+                            String patientRefVal = getPatientRefVal(node);\n+                            if (patientRefVal != null && contextIds.contains(patientRefVal)) {\n+                                if (log.isLoggable(Level.FINE)) {\n+                                    log.fine(\"Interaction is permitted via scope \" + approvedScopeMap.get(ContextType.PATIENT) +\n+                                        \" with patient context '\" + patientRefVal + \"'\");\n+                                }\n+                                return;\n+                            }\n+                        }\n+                    } catch (Exception e) {\n+                        log.log(Level.WARNING, \"Unexpected exception while processing inclusionCriteria '\" + searchParm +\n+                                \"' in the Patient compartment for resource type \" + resourceType);\n+                    }\n+                }\n+            } catch (FHIRSearchException e) {\n+                log.log(Level.WARNING, \"Unexpected exception while enforcing authorization policy in the Patient compartment\"\n+                        + \" for resource type \" + resourceType);\n+            }\n+        }\n+\n+        if (approvedScopeMap.containsKey(ContextType.USER)) {\n+            throw new UnsupportedOperationException(\"SMART scopes with context type 'user' are not yet supported.\");\n+        }\n+\n+\n+        String msg = \"Requested interaction is not permitted by any of the passed scopes.\";\n+        throw new FHIRPersistenceInterceptorException(msg)\n+                .withIssue(FHIRUtil.buildOperationOutcomeIssue(msg, IssueType.FORBIDDEN));\n+    }\n+\n+    /**\n+     * @param node\n+     * @return the id to the Patient resource referenced by this node (assuming it is a Reference with a valid\n+     *         reference value); otherwise null\n+     */\n+    private String getPatientRefVal(FHIRPathNode node) {\n+        if (!node.isElementNode() || !node.asElementNode().element().is(Reference.class)) {\n+            throw new IllegalStateException(\"Patient compartment inclusionCriteria expression has returned a non-Reference\");\n+        }\n+        Reference reference = node.asElementNode().element().as(Reference.class);\n+        if (reference.getReference() != null && reference.getReference().hasValue()) {\n+            String refVal = reference.getReference().getValue();\n+            if (refVal != null && refVal.startsWith(PATIENT_REF_PREFIX)) {\n+                return refVal.substring(PATIENT_REF_PREFIX.length());\n+            }\n+        } else if (log.isLoggable(Level.FINE)){\n+            log.fine(\"Skipping non-patient / non-relative reference: '\" + reference + \"'\");\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * @param permission\n+     * @param requiredPermission\n+     * @return true if the grantedPermission includes the requiredPermission; otherwise false\n+     */\n+    private boolean hasPermission(Permission grantedPermission, Permission requiredPermission) {\n+        if (grantedPermission == Permission.ALL) {\n+            return true;\n+        } else {\n+            return grantedPermission == requiredPermission;\n+        }\n+    }\n+\n+    private String getAccessToken() throws FHIRPersistenceInterceptorException {\n+        List<String> list = FHIRRequestContext.get().getHttpHeaders().get(\"Authorization\");\n+        if (list.size() != 1) {\n+            throw new FHIRPersistenceInterceptorException(\"Request must contain exactly one Authorization header.\");\n+        }\n+        String header = list.get(0);\n+\n+        if (!header.startsWith(BEARER_TOKEN_PREFIX)) {\n+            throw new FHIRPersistenceInterceptorException(\"Authorization header must carry a Bearer token\");\n+        }\n+\n+        return header.substring(BEARER_TOKEN_PREFIX.length()).trim();\n+    }\n+\n+    private List<Scope> getScopesFromToken(DecodedJWT jwt) {\n+        Claim claim = jwt.getClaim(\"scope\");\n+        if (claim.isNull()) {\n+            throw new IllegalArgumentException(\"Authorization token is missing 'scope' claim\");\n+        }\n+\n+        List<String> scopeStrings;\n+        String claimString = claim.asString();\n+\n+        if (claimString != null) {\n+            scopeStrings = Arrays.asList(claim.asString().split(\"\\\\s+\"));\n+        } else {\n+            log.fine(\"Found scope claim was expected to be a string but is not; processing as a list\");\n+            scopeStrings = claim.asList(String.class);\n+        }\n+\n+        return scopeStrings.stream()\n+                .filter(s -> s.matches(Scope.SCOPE_STRING_REGEX))\n+                .map(s -> new Scope(s))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private List<String> getPatientIdFromToken(DecodedJWT jwt) {\n+        Claim claim = jwt.getClaim(\"patient_id\");\n+        if (claim.isNull()) {\n+            throw new IllegalArgumentException(\"Authorization token is missing 'patient_id' claim\");\n+        }\n+\n+        String patientId = claim.asString();\n+        if (patientId == null) {\n+            log.fine(\"Found patient_id claim was expected to be a string but is not; processing as a list\");\n+            return claim.asList(String.class);\n+        }\n+\n+        return Collections.singletonList(patientId);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0Mzg4NQ=="}, "originalCommit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "originalPosition": 267}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1OTk4OQ==", "bodyText": "No refactoring. This was a question given the multiple potential ids.", "url": "https://github.com/IBM/FHIR/pull/1400#discussion_r465159989", "createdAt": "2020-08-04T16:01:52Z", "author": {"login": "prb112"}, "path": "fhir-smart/src/main/java/com/ibm/fhir/smart/AuthzPolicyEnforcementPersistenceInterceptor.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019, 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.smart;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import com.auth0.jwt.JWT;\n+import com.auth0.jwt.interfaces.Claim;\n+import com.auth0.jwt.interfaces.DecodedJWT;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Patient;\n+import com.ibm.fhir.model.resource.Resource;\n+import com.ibm.fhir.model.type.Reference;\n+import com.ibm.fhir.model.type.code.CompartmentType;\n+import com.ibm.fhir.model.type.code.IssueType;\n+import com.ibm.fhir.model.type.code.ResourceType;\n+import com.ibm.fhir.model.util.FHIRUtil;\n+import com.ibm.fhir.path.FHIRPathNode;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator.EvaluationContext;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceEvent;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceInterceptor;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceInterceptorException;\n+import com.ibm.fhir.search.compartment.CompartmentUtil;\n+import com.ibm.fhir.search.exception.FHIRSearchException;\n+import com.ibm.fhir.search.util.SearchUtil;\n+import com.ibm.fhir.smart.Scope.ContextType;\n+import com.ibm.fhir.smart.Scope.Permission;\n+\n+public class AuthzPolicyEnforcementPersistenceInterceptor implements FHIRPersistenceInterceptor {\n+    private static final Logger log = Logger.getLogger(AuthzPolicyEnforcementPersistenceInterceptor.class.getName());\n+\n+    private static final String BEARER_TOKEN_PREFIX = \"Bearer\";\n+    private static final String PATIENT_REF_PREFIX = \"Patient/\";\n+\n+    @Override\n+    public void beforeCreate(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void beforeDelete(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getPrevFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void beforeUpdate(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        // TODO: do we need to check READ permission on the prevFhirResource as well?\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.WRITE, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterRead(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterVread(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        enforce(event.getFhirResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+    }\n+\n+    @Override\n+    public void afterHistory(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        if (event.getFhirResource() instanceof Bundle) {\n+            for ( Bundle.Entry entry : ((Bundle) event.getFhirResource()).getEntry()) {\n+                if (entry.getResource() != null) {\n+                    enforce(entry.getResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+                }\n+            }\n+        } else {\n+            throw new IllegalStateException(\"Expected event resource of type Bundle but found \" +\n+                    event.getFhirResource().getClass().getSimpleName());\n+        }\n+    }\n+\n+    @Override\n+    public void afterSearch(FHIRPersistenceEvent event) throws FHIRPersistenceInterceptorException {\n+        DecodedJWT jwt = JWT.decode(getAccessToken());\n+        if (event.getFhirResource() instanceof Bundle) {\n+            for ( Bundle.Entry entry : ((Bundle) event.getFhirResource()).getEntry()) {\n+                if (entry.getResource() != null) {\n+                    enforce(entry.getResource(), getPatientIdFromToken(jwt), Permission.READ, getScopesFromToken(jwt));\n+                }\n+            }\n+        } else {\n+            throw new IllegalStateException(\"Expected event resource of type Bundle but found \" +\n+                    event.getFhirResource().getClass().getSimpleName());\n+        }\n+    }\n+\n+    /**\n+     * @param event\n+     * @param contextIds\n+     * @param collect\n+     * @throws FHIRPersistenceInterceptorException\n+     */\n+    private void enforce(Resource resource, List<String> contextIds, Permission requiredPermission, List<Scope> approvedScopes)\n+            throws FHIRPersistenceInterceptorException {\n+        Objects.requireNonNull(resource, \"resource\");\n+        Objects.requireNonNull(contextIds, \"contextIds\");\n+\n+        String resourceType = resource.getClass().getSimpleName();\n+        Map<ContextType, List<Scope>> approvedScopeMap = approvedScopes.stream()\n+                // First filter the list to only scopes which grant the required permissions on the passed resourceType\n+                .filter(s -> s.getResourceType() == ResourceType.ValueSet.RESOURCE ||\n+                        s.getResourceType().value().equals(resourceType))\n+                .filter(s -> hasPermission(s.getPermission(),requiredPermission))\n+                // Then group the scopes by their context type\n+                .collect(Collectors.groupingBy(s -> s.getContextType()));\n+\n+        if (approvedScopeMap.containsKey(ContextType.PATIENT)) {\n+\n+            // If the target resource is the Patient resource which matches the in-context patient, allow it\n+            if (resource instanceof Patient && resource.getId() != null && contextIds.contains(resource.getId())) {\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Interaction is permitted via scope \" + approvedScopeMap.get(ContextType.PATIENT) +\n+                        \" with patient context '\" + resource.getId() + \"'\");\n+                }\n+                return;\n+            }\n+\n+            // Else, see if the target resource belongs to the Patient compartment of the in-context patient\n+            try {\n+                List<String> inclusionCriteria = CompartmentUtil\n+                        .getCompartmentResourceTypeInclusionCriteria(CompartmentType.PATIENT.getValue(), resourceType);\n+\n+                EvaluationContext resourceContext = new FHIRPathEvaluator.EvaluationContext(resource);\n+\n+                for (String searchParm : inclusionCriteria) {\n+                    try {\n+                        String expression = SearchUtil.getSearchParameter(resourceType, searchParm).getExpression().getValue();\n+                        Collection<FHIRPathNode> nodes = FHIRPathEvaluator.evaluator().evaluate(resourceContext, expression);\n+                        for (FHIRPathNode node : nodes) {\n+                            String patientRefVal = getPatientRefVal(node);\n+                            if (patientRefVal != null && contextIds.contains(patientRefVal)) {\n+                                if (log.isLoggable(Level.FINE)) {\n+                                    log.fine(\"Interaction is permitted via scope \" + approvedScopeMap.get(ContextType.PATIENT) +\n+                                        \" with patient context '\" + patientRefVal + \"'\");\n+                                }\n+                                return;\n+                            }\n+                        }\n+                    } catch (Exception e) {\n+                        log.log(Level.WARNING, \"Unexpected exception while processing inclusionCriteria '\" + searchParm +\n+                                \"' in the Patient compartment for resource type \" + resourceType);\n+                    }\n+                }\n+            } catch (FHIRSearchException e) {\n+                log.log(Level.WARNING, \"Unexpected exception while enforcing authorization policy in the Patient compartment\"\n+                        + \" for resource type \" + resourceType);\n+            }\n+        }\n+\n+        if (approvedScopeMap.containsKey(ContextType.USER)) {\n+            throw new UnsupportedOperationException(\"SMART scopes with context type 'user' are not yet supported.\");\n+        }\n+\n+\n+        String msg = \"Requested interaction is not permitted by any of the passed scopes.\";\n+        throw new FHIRPersistenceInterceptorException(msg)\n+                .withIssue(FHIRUtil.buildOperationOutcomeIssue(msg, IssueType.FORBIDDEN));\n+    }\n+\n+    /**\n+     * @param node\n+     * @return the id to the Patient resource referenced by this node (assuming it is a Reference with a valid\n+     *         reference value); otherwise null\n+     */\n+    private String getPatientRefVal(FHIRPathNode node) {\n+        if (!node.isElementNode() || !node.asElementNode().element().is(Reference.class)) {\n+            throw new IllegalStateException(\"Patient compartment inclusionCriteria expression has returned a non-Reference\");\n+        }\n+        Reference reference = node.asElementNode().element().as(Reference.class);\n+        if (reference.getReference() != null && reference.getReference().hasValue()) {\n+            String refVal = reference.getReference().getValue();\n+            if (refVal != null && refVal.startsWith(PATIENT_REF_PREFIX)) {\n+                return refVal.substring(PATIENT_REF_PREFIX.length());\n+            }\n+        } else if (log.isLoggable(Level.FINE)){\n+            log.fine(\"Skipping non-patient / non-relative reference: '\" + reference + \"'\");\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * @param permission\n+     * @param requiredPermission\n+     * @return true if the grantedPermission includes the requiredPermission; otherwise false\n+     */\n+    private boolean hasPermission(Permission grantedPermission, Permission requiredPermission) {\n+        if (grantedPermission == Permission.ALL) {\n+            return true;\n+        } else {\n+            return grantedPermission == requiredPermission;\n+        }\n+    }\n+\n+    private String getAccessToken() throws FHIRPersistenceInterceptorException {\n+        List<String> list = FHIRRequestContext.get().getHttpHeaders().get(\"Authorization\");\n+        if (list.size() != 1) {\n+            throw new FHIRPersistenceInterceptorException(\"Request must contain exactly one Authorization header.\");\n+        }\n+        String header = list.get(0);\n+\n+        if (!header.startsWith(BEARER_TOKEN_PREFIX)) {\n+            throw new FHIRPersistenceInterceptorException(\"Authorization header must carry a Bearer token\");\n+        }\n+\n+        return header.substring(BEARER_TOKEN_PREFIX.length()).trim();\n+    }\n+\n+    private List<Scope> getScopesFromToken(DecodedJWT jwt) {\n+        Claim claim = jwt.getClaim(\"scope\");\n+        if (claim.isNull()) {\n+            throw new IllegalArgumentException(\"Authorization token is missing 'scope' claim\");\n+        }\n+\n+        List<String> scopeStrings;\n+        String claimString = claim.asString();\n+\n+        if (claimString != null) {\n+            scopeStrings = Arrays.asList(claim.asString().split(\"\\\\s+\"));\n+        } else {\n+            log.fine(\"Found scope claim was expected to be a string but is not; processing as a list\");\n+            scopeStrings = claim.asList(String.class);\n+        }\n+\n+        return scopeStrings.stream()\n+                .filter(s -> s.matches(Scope.SCOPE_STRING_REGEX))\n+                .map(s -> new Scope(s))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private List<String> getPatientIdFromToken(DecodedJWT jwt) {\n+        Claim claim = jwt.getClaim(\"patient_id\");\n+        if (claim.isNull()) {\n+            throw new IllegalArgumentException(\"Authorization token is missing 'patient_id' claim\");\n+        }\n+\n+        String patientId = claim.asString();\n+        if (patientId == null) {\n+            log.fine(\"Found patient_id claim was expected to be a string but is not; processing as a list\");\n+            return claim.asList(String.class);\n+        }\n+\n+        return Collections.singletonList(patientId);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0Mzg4NQ=="}, "originalCommit": {"oid": "232a05fd9bb3a5a45087cf2a9c4c51c1b2070e48"}, "originalPosition": 267}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4787, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}