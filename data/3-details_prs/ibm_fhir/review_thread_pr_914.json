{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAxMTM0MDU4", "number": 914, "reviewThreads": {"totalCount": 63, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMjozMTo0MlrODwYpWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNTowNjowNVrODzxnDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMDYyMDQzOnYy", "diffSide": "RIGHT", "path": "docs/src/pages/guides/FHIRServerUsersGuide.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMjozMTo0MlrOGDWqjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMzowOTo1MFrOGDX9EA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3MDI1Mw==", "bodyText": "I think this row is wrong too", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r406170253", "createdAt": "2020-04-09T12:31:42Z", "author": {"login": "lmsurpre"}, "path": "docs/src/pages/guides/FHIRServerUsersGuide.md", "diffHunk": "@@ -1442,7 +1442,7 @@ must restart the server for that change to take effect.\n |`fhirServer/bulkdata/jobParameters/cos.api.key`|Y|Y|\n |`fhirServer/bulkdata/jobParameters/cos.srvinst.id`|Y|Y|\n |`fhirServer/bulkdata/bulkDataBatchJobIdEncryptionKey`|Y|Y|", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aae34e26f731a5ff727a5a875f3f9828f1069987"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE5MTM3Ng==", "bodyText": "this line is correct, the id is encrypted in the bulkdata operation side which is in the fhir-server.", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r406191376", "createdAt": "2020-04-09T13:09:50Z", "author": {"login": "albertwang-ibm"}, "path": "docs/src/pages/guides/FHIRServerUsersGuide.md", "diffHunk": "@@ -1442,7 +1442,7 @@ must restart the server for that change to take effect.\n |`fhirServer/bulkdata/jobParameters/cos.api.key`|Y|Y|\n |`fhirServer/bulkdata/jobParameters/cos.srvinst.id`|Y|Y|\n |`fhirServer/bulkdata/bulkDataBatchJobIdEncryptionKey`|Y|Y|", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3MDI1Mw=="}, "originalCommit": {"oid": "aae34e26f731a5ff727a5a875f3f9828f1069987"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyOTQ1MTgwOnYy", "diffSide": "RIGHT", "path": "fhir-server/liberty-config/server.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxMjoyOTo1N1rOGElGkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxOTowNjoyOVrOGExe8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQ1NTM3OQ==", "bodyText": "for consistency, move this entry one line up (before fhir)\npersistence libraries then fhir", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r407455379", "createdAt": "2020-04-13T12:29:57Z", "author": {"login": "prb112"}, "path": "fhir-server/liberty-config/server.xml", "diffHunk": "@@ -151,6 +151,7 @@\n         <fileset dir=\"${shared.resource.dir}/lib/derby\" includes=\"*.jar\"/>\n         <fileset dir=\"${shared.resource.dir}/lib/db2\" includes=\"*.jar\"/>\n         <fileset dir=\"${shared.resource.dir}/lib/fhir\" includes=\"*.jar\"/>\n+        <fileset dir=\"${shared.resource.dir}/lib/postgresql\" includes=\"*.jar\"/>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "30dc31f428897b014c86cf452b52905e6156ce0c"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY1ODIyNg==", "bodyText": "done", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r407658226", "createdAt": "2020-04-13T19:06:29Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-server/liberty-config/server.xml", "diffHunk": "@@ -151,6 +151,7 @@\n         <fileset dir=\"${shared.resource.dir}/lib/derby\" includes=\"*.jar\"/>\n         <fileset dir=\"${shared.resource.dir}/lib/db2\" includes=\"*.jar\"/>\n         <fileset dir=\"${shared.resource.dir}/lib/fhir\" includes=\"*.jar\"/>\n+        <fileset dir=\"${shared.resource.dir}/lib/postgresql\" includes=\"*.jar\"/>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQ1NTM3OQ=="}, "originalCommit": {"oid": "30dc31f428897b014c86cf452b52905e6156ce0c"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MzA4OTcwOnYy", "diffSide": "RIGHT", "path": "docs/src/pages/guides/FHIRServerUsersGuide.md", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxNDoyNTowNlrOGGn8Cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxNDo0ODoxN1rOGGpD9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTU5ODk4Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ```", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r409598986", "createdAt": "2020-04-16T14:25:06Z", "author": {"login": "prb112"}, "path": "docs/src/pages/guides/FHIRServerUsersGuide.md", "diffHunk": "@@ -1220,9 +1220,81 @@ The JavaBatch user is configured in server.xml and the bulkdata.json:\n \t</security-role>\n </authorization-roles>\n ```\n-Note: The user referenced in the bulkdata.json must have a role of at least batchSubmitter.\n-\n-By default, in-memory Derby database is used for persistence of the JavaBatch Jobs. Instruction is also provided in \"Configuring a Liberty Datasource with API Key\" section of the DB2OnCloudSetup guide to configure DB2 service in IBM Clouds as JavaBatch persistence store. Liberty JavaBatch framework creates DB schema and tables automatically by default for both approaches, and the configured database is created automatically, if the in-memory Apache Derby approach is used.   \n+Note: The user referenced in the fhir-server-config.json must have a role of at least batchSubmitter.\n+\n+By default, in-memory Derby database is used for persistence of the JavaBatch Jobs as configured in batchDs.xml. Instruction is also provided in \"Configuring a Liberty Datasource with API Key\" section of the DB2OnCloudSetup guide to configure DB2 service in IBM Clouds as JavaBatch persistence store. Liberty JavaBatch framework creates DB schema and tables automatically by default for both approaches, and the configured database is created automatically, if the in-memory Apache Derby approach is used.\n+\n+You can also choose to use postgresql or other RDBMS as your Job repository, if taking this approach, you will need to generate the DDL for the job tables first following [IBM Websphere Liberty Batch - Job Repository Configuration](https://www-03.ibm.com/support/techdocs/atsmastr.nsf/WebIndex/WP102716) , then make necessary changes to the generated DDL to make it valid for your RDBMS, and then create the job database, create javabatch user, create jbatch schema and then run the DDL to generate the job tables and enable it in batchDs.xml let's use postgresql as an example:\n+\n+(1) Generate DDL and modify it according to your RDBMS.\n+\n+``` shell\n+ ./ddlGen generate fhir-server\n+```", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdd27c9867e0bff4426c2d54d6ff569fbf9056b3"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTU5OTM4Mw==", "bodyText": "I think you want to add a return.\nhowever, I'm not sure you want to include this here if you give a different sql below.", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r409599383", "createdAt": "2020-04-16T14:25:37Z", "author": {"login": "prb112"}, "path": "docs/src/pages/guides/FHIRServerUsersGuide.md", "diffHunk": "@@ -1220,9 +1220,81 @@ The JavaBatch user is configured in server.xml and the bulkdata.json:\n \t</security-role>\n </authorization-roles>\n ```\n-Note: The user referenced in the bulkdata.json must have a role of at least batchSubmitter.\n-\n-By default, in-memory Derby database is used for persistence of the JavaBatch Jobs. Instruction is also provided in \"Configuring a Liberty Datasource with API Key\" section of the DB2OnCloudSetup guide to configure DB2 service in IBM Clouds as JavaBatch persistence store. Liberty JavaBatch framework creates DB schema and tables automatically by default for both approaches, and the configured database is created automatically, if the in-memory Apache Derby approach is used.   \n+Note: The user referenced in the fhir-server-config.json must have a role of at least batchSubmitter.\n+\n+By default, in-memory Derby database is used for persistence of the JavaBatch Jobs as configured in batchDs.xml. Instruction is also provided in \"Configuring a Liberty Datasource with API Key\" section of the DB2OnCloudSetup guide to configure DB2 service in IBM Clouds as JavaBatch persistence store. Liberty JavaBatch framework creates DB schema and tables automatically by default for both approaches, and the configured database is created automatically, if the in-memory Apache Derby approach is used.\n+\n+You can also choose to use postgresql or other RDBMS as your Job repository, if taking this approach, you will need to generate the DDL for the job tables first following [IBM Websphere Liberty Batch - Job Repository Configuration](https://www-03.ibm.com/support/techdocs/atsmastr.nsf/WebIndex/WP102716) , then make necessary changes to the generated DDL to make it valid for your RDBMS, and then create the job database, create javabatch user, create jbatch schema and then run the DDL to generate the job tables and enable it in batchDs.xml let's use postgresql as an example:\n+\n+(1) Generate DDL and modify it according to your RDBMS.\n+\n+``` shell\n+ ./ddlGen generate fhir-server\n+```", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTU5ODk4Ng=="}, "originalCommit": {"oid": "cdd27c9867e0bff4426c2d54d6ff569fbf9056b3"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYxNzM5OA==", "bodyText": "this is only command for (1), the following is a modified ddl version for postgresql.", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r409617398", "createdAt": "2020-04-16T14:48:17Z", "author": {"login": "albertwang-ibm"}, "path": "docs/src/pages/guides/FHIRServerUsersGuide.md", "diffHunk": "@@ -1220,9 +1220,81 @@ The JavaBatch user is configured in server.xml and the bulkdata.json:\n \t</security-role>\n </authorization-roles>\n ```\n-Note: The user referenced in the bulkdata.json must have a role of at least batchSubmitter.\n-\n-By default, in-memory Derby database is used for persistence of the JavaBatch Jobs. Instruction is also provided in \"Configuring a Liberty Datasource with API Key\" section of the DB2OnCloudSetup guide to configure DB2 service in IBM Clouds as JavaBatch persistence store. Liberty JavaBatch framework creates DB schema and tables automatically by default for both approaches, and the configured database is created automatically, if the in-memory Apache Derby approach is used.   \n+Note: The user referenced in the fhir-server-config.json must have a role of at least batchSubmitter.\n+\n+By default, in-memory Derby database is used for persistence of the JavaBatch Jobs as configured in batchDs.xml. Instruction is also provided in \"Configuring a Liberty Datasource with API Key\" section of the DB2OnCloudSetup guide to configure DB2 service in IBM Clouds as JavaBatch persistence store. Liberty JavaBatch framework creates DB schema and tables automatically by default for both approaches, and the configured database is created automatically, if the in-memory Apache Derby approach is used.\n+\n+You can also choose to use postgresql or other RDBMS as your Job repository, if taking this approach, you will need to generate the DDL for the job tables first following [IBM Websphere Liberty Batch - Job Repository Configuration](https://www-03.ibm.com/support/techdocs/atsmastr.nsf/WebIndex/WP102716) , then make necessary changes to the generated DDL to make it valid for your RDBMS, and then create the job database, create javabatch user, create jbatch schema and then run the DDL to generate the job tables and enable it in batchDs.xml let's use postgresql as an example:\n+\n+(1) Generate DDL and modify it according to your RDBMS.\n+\n+``` shell\n+ ./ddlGen generate fhir-server\n+```", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTU5ODk4Ng=="}, "originalCommit": {"oid": "cdd27c9867e0bff4426c2d54d6ff569fbf9056b3"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MzA5MjkzOnYy", "diffSide": "RIGHT", "path": "docs/src/pages/guides/FHIRServerUsersGuide.md", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxNDoyNTo0OFrOGGn-IQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwMjo1MDozN1rOGG-GlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTU5OTUyMQ==", "bodyText": "I think this should be a file in fhir-persistence-schema", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r409599521", "createdAt": "2020-04-16T14:25:48Z", "author": {"login": "prb112"}, "path": "docs/src/pages/guides/FHIRServerUsersGuide.md", "diffHunk": "@@ -1220,9 +1220,81 @@ The JavaBatch user is configured in server.xml and the bulkdata.json:\n \t</security-role>\n </authorization-roles>\n ```\n-Note: The user referenced in the bulkdata.json must have a role of at least batchSubmitter.\n-\n-By default, in-memory Derby database is used for persistence of the JavaBatch Jobs. Instruction is also provided in \"Configuring a Liberty Datasource with API Key\" section of the DB2OnCloudSetup guide to configure DB2 service in IBM Clouds as JavaBatch persistence store. Liberty JavaBatch framework creates DB schema and tables automatically by default for both approaches, and the configured database is created automatically, if the in-memory Apache Derby approach is used.   \n+Note: The user referenced in the fhir-server-config.json must have a role of at least batchSubmitter.\n+\n+By default, in-memory Derby database is used for persistence of the JavaBatch Jobs as configured in batchDs.xml. Instruction is also provided in \"Configuring a Liberty Datasource with API Key\" section of the DB2OnCloudSetup guide to configure DB2 service in IBM Clouds as JavaBatch persistence store. Liberty JavaBatch framework creates DB schema and tables automatically by default for both approaches, and the configured database is created automatically, if the in-memory Apache Derby approach is used.\n+\n+You can also choose to use postgresql or other RDBMS as your Job repository, if taking this approach, you will need to generate the DDL for the job tables first following [IBM Websphere Liberty Batch - Job Repository Configuration](https://www-03.ibm.com/support/techdocs/atsmastr.nsf/WebIndex/WP102716) , then make necessary changes to the generated DDL to make it valid for your RDBMS, and then create the job database, create javabatch user, create jbatch schema and then run the DDL to generate the job tables and enable it in batchDs.xml let's use postgresql as an example:\n+\n+(1) Generate DDL and modify it according to your RDBMS.\n+\n+``` shell\n+ ./ddlGen generate fhir-server\n+```\n+Following is a modified version for postgresql:\n+\n+``` shell", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdd27c9867e0bff4426c2d54d6ff569fbf9056b3"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYwNDU1OQ==", "bodyText": "I thought about this also but I hesitated to do so, because this schema project is for schemas of fhir server data sources themselves, and seems either the bulkdata job and operation projects are not the right place for the DDL, so I choose to paste it into the document.", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r409604559", "createdAt": "2020-04-16T14:32:00Z", "author": {"login": "albertwang-ibm"}, "path": "docs/src/pages/guides/FHIRServerUsersGuide.md", "diffHunk": "@@ -1220,9 +1220,81 @@ The JavaBatch user is configured in server.xml and the bulkdata.json:\n \t</security-role>\n </authorization-roles>\n ```\n-Note: The user referenced in the bulkdata.json must have a role of at least batchSubmitter.\n-\n-By default, in-memory Derby database is used for persistence of the JavaBatch Jobs. Instruction is also provided in \"Configuring a Liberty Datasource with API Key\" section of the DB2OnCloudSetup guide to configure DB2 service in IBM Clouds as JavaBatch persistence store. Liberty JavaBatch framework creates DB schema and tables automatically by default for both approaches, and the configured database is created automatically, if the in-memory Apache Derby approach is used.   \n+Note: The user referenced in the fhir-server-config.json must have a role of at least batchSubmitter.\n+\n+By default, in-memory Derby database is used for persistence of the JavaBatch Jobs as configured in batchDs.xml. Instruction is also provided in \"Configuring a Liberty Datasource with API Key\" section of the DB2OnCloudSetup guide to configure DB2 service in IBM Clouds as JavaBatch persistence store. Liberty JavaBatch framework creates DB schema and tables automatically by default for both approaches, and the configured database is created automatically, if the in-memory Apache Derby approach is used.\n+\n+You can also choose to use postgresql or other RDBMS as your Job repository, if taking this approach, you will need to generate the DDL for the job tables first following [IBM Websphere Liberty Batch - Job Repository Configuration](https://www-03.ibm.com/support/techdocs/atsmastr.nsf/WebIndex/WP102716) , then make necessary changes to the generated DDL to make it valid for your RDBMS, and then create the job database, create javabatch user, create jbatch schema and then run the DDL to generate the job tables and enable it in batchDs.xml let's use postgresql as an example:\n+\n+(1) Generate DDL and modify it according to your RDBMS.\n+\n+``` shell\n+ ./ddlGen generate fhir-server\n+```\n+Following is a modified version for postgresql:\n+\n+``` shell", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTU5OTUyMQ=="}, "originalCommit": {"oid": "cdd27c9867e0bff4426c2d54d6ff569fbf9056b3"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYzNjk1OA==", "bodyText": "Great point.  The webapp makes sense to me.", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r409636958", "createdAt": "2020-04-16T15:13:38Z", "author": {"login": "prb112"}, "path": "docs/src/pages/guides/FHIRServerUsersGuide.md", "diffHunk": "@@ -1220,9 +1220,81 @@ The JavaBatch user is configured in server.xml and the bulkdata.json:\n \t</security-role>\n </authorization-roles>\n ```\n-Note: The user referenced in the bulkdata.json must have a role of at least batchSubmitter.\n-\n-By default, in-memory Derby database is used for persistence of the JavaBatch Jobs. Instruction is also provided in \"Configuring a Liberty Datasource with API Key\" section of the DB2OnCloudSetup guide to configure DB2 service in IBM Clouds as JavaBatch persistence store. Liberty JavaBatch framework creates DB schema and tables automatically by default for both approaches, and the configured database is created automatically, if the in-memory Apache Derby approach is used.   \n+Note: The user referenced in the fhir-server-config.json must have a role of at least batchSubmitter.\n+\n+By default, in-memory Derby database is used for persistence of the JavaBatch Jobs as configured in batchDs.xml. Instruction is also provided in \"Configuring a Liberty Datasource with API Key\" section of the DB2OnCloudSetup guide to configure DB2 service in IBM Clouds as JavaBatch persistence store. Liberty JavaBatch framework creates DB schema and tables automatically by default for both approaches, and the configured database is created automatically, if the in-memory Apache Derby approach is used.\n+\n+You can also choose to use postgresql or other RDBMS as your Job repository, if taking this approach, you will need to generate the DDL for the job tables first following [IBM Websphere Liberty Batch - Job Repository Configuration](https://www-03.ibm.com/support/techdocs/atsmastr.nsf/WebIndex/WP102716) , then make necessary changes to the generated DDL to make it valid for your RDBMS, and then create the job database, create javabatch user, create jbatch schema and then run the DDL to generate the job tables and enable it in batchDs.xml let's use postgresql as an example:\n+\n+(1) Generate DDL and modify it according to your RDBMS.\n+\n+``` shell\n+ ./ddlGen generate fhir-server\n+```\n+Following is a modified version for postgresql:\n+\n+``` shell", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTU5OTUyMQ=="}, "originalCommit": {"oid": "cdd27c9867e0bff4426c2d54d6ff569fbf9056b3"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY2ODk1OQ==", "bodyText": "OK, will add this DDL to the webapp project.", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r409668959", "createdAt": "2020-04-16T15:57:24Z", "author": {"login": "albertwang-ibm"}, "path": "docs/src/pages/guides/FHIRServerUsersGuide.md", "diffHunk": "@@ -1220,9 +1220,81 @@ The JavaBatch user is configured in server.xml and the bulkdata.json:\n \t</security-role>\n </authorization-roles>\n ```\n-Note: The user referenced in the bulkdata.json must have a role of at least batchSubmitter.\n-\n-By default, in-memory Derby database is used for persistence of the JavaBatch Jobs. Instruction is also provided in \"Configuring a Liberty Datasource with API Key\" section of the DB2OnCloudSetup guide to configure DB2 service in IBM Clouds as JavaBatch persistence store. Liberty JavaBatch framework creates DB schema and tables automatically by default for both approaches, and the configured database is created automatically, if the in-memory Apache Derby approach is used.   \n+Note: The user referenced in the fhir-server-config.json must have a role of at least batchSubmitter.\n+\n+By default, in-memory Derby database is used for persistence of the JavaBatch Jobs as configured in batchDs.xml. Instruction is also provided in \"Configuring a Liberty Datasource with API Key\" section of the DB2OnCloudSetup guide to configure DB2 service in IBM Clouds as JavaBatch persistence store. Liberty JavaBatch framework creates DB schema and tables automatically by default for both approaches, and the configured database is created automatically, if the in-memory Apache Derby approach is used.\n+\n+You can also choose to use postgresql or other RDBMS as your Job repository, if taking this approach, you will need to generate the DDL for the job tables first following [IBM Websphere Liberty Batch - Job Repository Configuration](https://www-03.ibm.com/support/techdocs/atsmastr.nsf/WebIndex/WP102716) , then make necessary changes to the generated DDL to make it valid for your RDBMS, and then create the job database, create javabatch user, create jbatch schema and then run the DDL to generate the job tables and enable it in batchDs.xml let's use postgresql as an example:\n+\n+(1) Generate DDL and modify it according to your RDBMS.\n+\n+``` shell\n+ ./ddlGen generate fhir-server\n+```\n+Following is a modified version for postgresql:\n+\n+``` shell", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTU5OTUyMQ=="}, "originalCommit": {"oid": "cdd27c9867e0bff4426c2d54d6ff569fbf9056b3"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk2MjEzMw==", "bodyText": "done", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r409962133", "createdAt": "2020-04-17T02:50:37Z", "author": {"login": "albertwang-ibm"}, "path": "docs/src/pages/guides/FHIRServerUsersGuide.md", "diffHunk": "@@ -1220,9 +1220,81 @@ The JavaBatch user is configured in server.xml and the bulkdata.json:\n \t</security-role>\n </authorization-roles>\n ```\n-Note: The user referenced in the bulkdata.json must have a role of at least batchSubmitter.\n-\n-By default, in-memory Derby database is used for persistence of the JavaBatch Jobs. Instruction is also provided in \"Configuring a Liberty Datasource with API Key\" section of the DB2OnCloudSetup guide to configure DB2 service in IBM Clouds as JavaBatch persistence store. Liberty JavaBatch framework creates DB schema and tables automatically by default for both approaches, and the configured database is created automatically, if the in-memory Apache Derby approach is used.   \n+Note: The user referenced in the fhir-server-config.json must have a role of at least batchSubmitter.\n+\n+By default, in-memory Derby database is used for persistence of the JavaBatch Jobs as configured in batchDs.xml. Instruction is also provided in \"Configuring a Liberty Datasource with API Key\" section of the DB2OnCloudSetup guide to configure DB2 service in IBM Clouds as JavaBatch persistence store. Liberty JavaBatch framework creates DB schema and tables automatically by default for both approaches, and the configured database is created automatically, if the in-memory Apache Derby approach is used.\n+\n+You can also choose to use postgresql or other RDBMS as your Job repository, if taking this approach, you will need to generate the DDL for the job tables first following [IBM Websphere Liberty Batch - Job Repository Configuration](https://www-03.ibm.com/support/techdocs/atsmastr.nsf/WebIndex/WP102716) , then make necessary changes to the generated DDL to make it valid for your RDBMS, and then create the job database, create javabatch user, create jbatch schema and then run the DDL to generate the job tables and enable it in batchDs.xml let's use postgresql as an example:\n+\n+(1) Generate DDL and modify it according to your RDBMS.\n+\n+``` shell\n+ ./ddlGen generate fhir-server\n+```\n+Following is a modified version for postgresql:\n+\n+``` shell", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTU5OTUyMQ=="}, "originalCommit": {"oid": "cdd27c9867e0bff4426c2d54d6ff569fbf9056b3"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MzA5Nzk3OnYy", "diffSide": "RIGHT", "path": "docs/src/pages/guides/FHIRServerUsersGuide.md", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxNDoyNjo1NVrOGGoBhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxNToxNTozNlrOGGqWKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYwMDM4OQ==", "bodyText": "How is this not tenant specific?  I thought each tenant is able to override", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r409600389", "createdAt": "2020-04-16T14:26:55Z", "author": {"login": "prb112"}, "path": "docs/src/pages/guides/FHIRServerUsersGuide.md", "diffHunk": "@@ -1442,7 +1514,7 @@ must restart the server for that change to take effect.\n |`fhirServer/bulkdata/jobParameters/cos.api.key`|Y|Y|\n |`fhirServer/bulkdata/jobParameters/cos.srvinst.id`|Y|Y|\n |`fhirServer/bulkdata/bulkDataBatchJobIdEncryptionKey`|Y|Y|\n-|`fhirServer/bulkdata/isExportPublic`|Y|Y|\n+|`fhirServer/bulkdata/isExportPublic`|N|Y|", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdd27c9867e0bff4426c2d54d6ff569fbf9056b3"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYwNTk0MA==", "bodyText": "For now, it's not tenant specific, the config is always gotten from the default config. but we can change codes to make it tenant specific if need in the future.", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r409605940", "createdAt": "2020-04-16T14:33:48Z", "author": {"login": "albertwang-ibm"}, "path": "docs/src/pages/guides/FHIRServerUsersGuide.md", "diffHunk": "@@ -1442,7 +1514,7 @@ must restart the server for that change to take effect.\n |`fhirServer/bulkdata/jobParameters/cos.api.key`|Y|Y|\n |`fhirServer/bulkdata/jobParameters/cos.srvinst.id`|Y|Y|\n |`fhirServer/bulkdata/bulkDataBatchJobIdEncryptionKey`|Y|Y|\n-|`fhirServer/bulkdata/isExportPublic`|Y|Y|\n+|`fhirServer/bulkdata/isExportPublic`|N|Y|", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYwMDM4OQ=="}, "originalCommit": {"oid": "cdd27c9867e0bff4426c2d54d6ff569fbf9056b3"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYzODQ0MA==", "bodyText": "got it. It's where you call it there is no 'tenant' and therefore always default.", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r409638440", "createdAt": "2020-04-16T15:15:36Z", "author": {"login": "prb112"}, "path": "docs/src/pages/guides/FHIRServerUsersGuide.md", "diffHunk": "@@ -1442,7 +1514,7 @@ must restart the server for that change to take effect.\n |`fhirServer/bulkdata/jobParameters/cos.api.key`|Y|Y|\n |`fhirServer/bulkdata/jobParameters/cos.srvinst.id`|Y|Y|\n |`fhirServer/bulkdata/bulkDataBatchJobIdEncryptionKey`|Y|Y|\n-|`fhirServer/bulkdata/isExportPublic`|Y|Y|\n+|`fhirServer/bulkdata/isExportPublic`|N|Y|", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYwMDM4OQ=="}, "originalCommit": {"oid": "cdd27c9867e0bff4426c2d54d6ff569fbf9056b3"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MzEzMjgwOnYy", "diffSide": "RIGHT", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/api/IDatabaseTypeAdapter.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxNDozNDowMVrOGGoX3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwMjo1MToyNVrOGG-HYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYwNjExMQ==", "bodyText": "Default is recommended to come second...\nhttps://stackoverflow.com/a/16732059/1873438", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r409606111", "createdAt": "2020-04-16T14:34:01Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/api/IDatabaseTypeAdapter.java", "diffHunk": "@@ -27,6 +27,14 @@\n      */\n     public String blobClause(long size, int inlineSize);\n \n+    /**\n+     * Generate a clause for double data type\n+     * @return\n+     */\n+    default public String doubleClause() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdd27c9867e0bff4426c2d54d6ff569fbf9056b3"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYxODIwMw==", "bodyText": "good to know this, was just thinking to align with existing codes. let me fix them", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r409618203", "createdAt": "2020-04-16T14:49:20Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/api/IDatabaseTypeAdapter.java", "diffHunk": "@@ -27,6 +27,14 @@\n      */\n     public String blobClause(long size, int inlineSize);\n \n+    /**\n+     * Generate a clause for double data type\n+     * @return\n+     */\n+    default public String doubleClause() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYwNjExMQ=="}, "originalCommit": {"oid": "cdd27c9867e0bff4426c2d54d6ff569fbf9056b3"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYzODg2MA==", "bodyText": "I saw this warning in SonarLint", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r409638860", "createdAt": "2020-04-16T15:16:11Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/api/IDatabaseTypeAdapter.java", "diffHunk": "@@ -27,6 +27,14 @@\n      */\n     public String blobClause(long size, int inlineSize);\n \n+    /**\n+     * Generate a clause for double data type\n+     * @return\n+     */\n+    default public String doubleClause() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYwNjExMQ=="}, "originalCommit": {"oid": "cdd27c9867e0bff4426c2d54d6ff569fbf9056b3"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk2MjMzOA==", "bodyText": "done", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r409962338", "createdAt": "2020-04-17T02:51:25Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/api/IDatabaseTypeAdapter.java", "diffHunk": "@@ -27,6 +27,14 @@\n      */\n     public String blobClause(long size, int inlineSize);\n \n+    /**\n+     * Generate a clause for double data type\n+     * @return\n+     */\n+    default public String doubleClause() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYwNjExMQ=="}, "originalCommit": {"oid": "cdd27c9867e0bff4426c2d54d6ff569fbf9056b3"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MzEzNzk5OnYy", "diffSide": "RIGHT", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/AddColumn.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxNDozNTowNFrOGGobCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxMjoxNDowMVrOGHLiIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYwNjkyMw==", "bodyText": "why is a null being cast?", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r409606923", "createdAt": "2020-04-16T14:35:04Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/AddColumn.java", "diffHunk": "@@ -38,7 +43,19 @@ public AddColumn(String schemaName, String tableName, ColumnBase column) {\n     @Override\n     public void run(IDatabaseTranslator translator, Connection c) {\n         String qname = DataDefinitionUtil.getQualifiedName(schemaName, tableName);\n-        String ddl = \"ALTER TABLE \" + qname + \" ADD COLUMN \" + columnDef(column);\n+\n+        // DatabaseTypeAdapter is needed to find the correct data type for the column.\n+        IDatabaseTypeAdapter dbAdapter = null;\n+        String driveClassName = translator.getDriverClassName();\n+        if (driveClassName.contains(\"db2\")) {\n+            dbAdapter = new Db2Adapter((IConnectionProvider)null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdd27c9867e0bff4426c2d54d6ff569fbf9056b3"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYwNzQ3NQ==", "bodyText": "this code doesn't really fit the pattern.", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r409607475", "createdAt": "2020-04-16T14:35:50Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/AddColumn.java", "diffHunk": "@@ -38,7 +43,19 @@ public AddColumn(String schemaName, String tableName, ColumnBase column) {\n     @Override\n     public void run(IDatabaseTranslator translator, Connection c) {\n         String qname = DataDefinitionUtil.getQualifiedName(schemaName, tableName);\n-        String ddl = \"ALTER TABLE \" + qname + \" ADD COLUMN \" + columnDef(column);\n+\n+        // DatabaseTypeAdapter is needed to find the correct data type for the column.\n+        IDatabaseTypeAdapter dbAdapter = null;\n+        String driveClassName = translator.getDriverClassName();\n+        if (driveClassName.contains(\"db2\")) {\n+            dbAdapter = new Db2Adapter((IConnectionProvider)null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYwNjkyMw=="}, "originalCommit": {"oid": "cdd27c9867e0bff4426c2d54d6ff569fbf9056b3"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYxNjA2MA==", "bodyText": "yeah, I hate this also, more like a hack, but this is the easy way to pass a suitable IDatabaseTypeAdapter to allow the codes work correctly, the old code doesn't work properly...", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r409616060", "createdAt": "2020-04-16T14:46:37Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/AddColumn.java", "diffHunk": "@@ -38,7 +43,19 @@ public AddColumn(String schemaName, String tableName, ColumnBase column) {\n     @Override\n     public void run(IDatabaseTranslator translator, Connection c) {\n         String qname = DataDefinitionUtil.getQualifiedName(schemaName, tableName);\n-        String ddl = \"ALTER TABLE \" + qname + \" ADD COLUMN \" + columnDef(column);\n+\n+        // DatabaseTypeAdapter is needed to find the correct data type for the column.\n+        IDatabaseTypeAdapter dbAdapter = null;\n+        String driveClassName = translator.getDriverClassName();\n+        if (driveClassName.contains(\"db2\")) {\n+            dbAdapter = new Db2Adapter((IConnectionProvider)null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYwNjkyMw=="}, "originalCommit": {"oid": "cdd27c9867e0bff4426c2d54d6ff569fbf9056b3"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE4MjE3OA==", "bodyText": "added new constructor for the db adapters to make the codes better.", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r410182178", "createdAt": "2020-04-17T12:14:01Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/AddColumn.java", "diffHunk": "@@ -38,7 +43,19 @@ public AddColumn(String schemaName, String tableName, ColumnBase column) {\n     @Override\n     public void run(IDatabaseTranslator translator, Connection c) {\n         String qname = DataDefinitionUtil.getQualifiedName(schemaName, tableName);\n-        String ddl = \"ALTER TABLE \" + qname + \" ADD COLUMN \" + columnDef(column);\n+\n+        // DatabaseTypeAdapter is needed to find the correct data type for the column.\n+        IDatabaseTypeAdapter dbAdapter = null;\n+        String driveClassName = translator.getDriverClassName();\n+        if (driveClassName.contains(\"db2\")) {\n+            dbAdapter = new Db2Adapter((IConnectionProvider)null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYwNjkyMw=="}, "originalCommit": {"oid": "cdd27c9867e0bff4426c2d54d6ff569fbf9056b3"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MzYyNzM2OnYy", "diffSide": "RIGHT", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlTranslator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxNjoyMzoxM1rOGGtSDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwMjo1MTozNlrOGG-HiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY4NjU0Mw==", "bodyText": "throw UnsupportedOperation", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r409686543", "createdAt": "2020-04-16T16:23:13Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlTranslator.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.sql.SQLException;\n+import java.util.Properties;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.ConnectionDetails;\n+import com.ibm.fhir.database.utils.api.ConnectionException;\n+import com.ibm.fhir.database.utils.api.DataAccessException;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.database.utils.api.LockException;\n+import com.ibm.fhir.database.utils.api.UndefinedNameException;\n+import com.ibm.fhir.database.utils.api.UniqueConstraintViolationException;\n+\n+/**\n+ * translates database access to PostgreSql supported access.\n+ */\n+public class PostgreSqlTranslator implements IDatabaseTranslator {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlTranslator.class.getName());\n+\n+    @Override\n+    public String addForUpdate(String sql) {\n+        return sql + \" FOR UPDATE\";\n+    }\n+\n+    @Override\n+    public boolean isDerby() {\n+        return false;\n+    }\n+\n+    @Override\n+    public String globalTempTableName(String tableName) {\n+        return \"SYSTEM.\" + tableName;\n+    }\n+\n+    @Override\n+    public String createGlobalTempTable(String ddl) {\n+        return \"DECLARE \" + ddl;\n+    }\n+\n+    @Override\n+    public boolean isDuplicate(SQLException x) {\n+        // Class Code 23: Constraint Violation\n+        return \"23505\".equals(x.getSQLState());\n+    }\n+\n+    @Override\n+    public boolean isAlreadyExists(SQLException x) {\n+        return \"42710\".equals(x.getSQLState());\n+    }\n+\n+    @Override\n+    public boolean isLockTimeout(SQLException x) {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isDeadlock(SQLException x) {\n+        final String sqlState = x.getSQLState();\n+        return \"40XL1\".equals(sqlState) || \"40XL2\".equals(sqlState);\n+    }\n+\n+    @Override\n+    public boolean isConnectionError(SQLException x) {\n+        String sqlState = x.getSQLState();\n+        return sqlState != null && sqlState.startsWith(\"08\");\n+    }\n+\n+    @Override\n+    public DataAccessException translate(SQLException x) {\n+        if (isDeadlock(x)) {\n+            return new LockException(x, true);\n+        }\n+        else if (isLockTimeout(x)) {\n+            return new LockException(x, false);\n+        }\n+        else if (isConnectionError(x)) {\n+            return new ConnectionException(x);\n+        }\n+        else if (isDuplicate(x)) {\n+            return new UniqueConstraintViolationException(x);\n+        }\n+        else if (isUndefinedName(x)) {\n+            return new UndefinedNameException(x);\n+        }\n+        else {\n+            return new DataAccessException(x);\n+        }\n+    }\n+\n+    @Override\n+    public boolean isUndefinedName(SQLException x) {\n+        return \"42X05\".equals(x.getSQLState());\n+    }\n+\n+    @Override\n+    public void fillProperties(Properties p, ConnectionDetails cd) {\n+        p.put(\"user\", cd.getUser());\n+        p.put(\"password\", cd.getPassword());\n+\n+        if (cd.isSsl()) {\n+            p.put(\"sslConnection\", \"true\");\n+        }\n+\n+        if (cd.isHA()) {\n+            logger.warning(\"No HA support for PostgreSql\");\n+        }\n+    }\n+\n+    @Override\n+    public String timestampDiff(String left, String right, String alias) {\n+        if (alias == null || alias.isEmpty()) {\n+            return String.format(\"{fn timestampdiff(SQL_TSI_SECOND, %s, %s)}\", left, right);\n+        }\n+        else {\n+            return String.format(\"{fn timestampdiff(SQL_TSI_SECOND, %s, %s)} AS %s\", left, right, alias);\n+        }\n+    }\n+\n+    @Override\n+    public String createSequence(String name, int cache) {\n+        // cache isn't supported by PostgreSql\n+        return \"CREATE SEQUENCE \" + name;\n+    }\n+\n+    @Override\n+    public String reorgTableCommand(String tableName) {\n+        // REORG TABLE not supported by PostgreSql, so return null\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3ea7ce045570353246610b88513f4f19c17f134"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk2MjM3Nw==", "bodyText": "done", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r409962377", "createdAt": "2020-04-17T02:51:36Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlTranslator.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.sql.SQLException;\n+import java.util.Properties;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.ConnectionDetails;\n+import com.ibm.fhir.database.utils.api.ConnectionException;\n+import com.ibm.fhir.database.utils.api.DataAccessException;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.database.utils.api.LockException;\n+import com.ibm.fhir.database.utils.api.UndefinedNameException;\n+import com.ibm.fhir.database.utils.api.UniqueConstraintViolationException;\n+\n+/**\n+ * translates database access to PostgreSql supported access.\n+ */\n+public class PostgreSqlTranslator implements IDatabaseTranslator {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlTranslator.class.getName());\n+\n+    @Override\n+    public String addForUpdate(String sql) {\n+        return sql + \" FOR UPDATE\";\n+    }\n+\n+    @Override\n+    public boolean isDerby() {\n+        return false;\n+    }\n+\n+    @Override\n+    public String globalTempTableName(String tableName) {\n+        return \"SYSTEM.\" + tableName;\n+    }\n+\n+    @Override\n+    public String createGlobalTempTable(String ddl) {\n+        return \"DECLARE \" + ddl;\n+    }\n+\n+    @Override\n+    public boolean isDuplicate(SQLException x) {\n+        // Class Code 23: Constraint Violation\n+        return \"23505\".equals(x.getSQLState());\n+    }\n+\n+    @Override\n+    public boolean isAlreadyExists(SQLException x) {\n+        return \"42710\".equals(x.getSQLState());\n+    }\n+\n+    @Override\n+    public boolean isLockTimeout(SQLException x) {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isDeadlock(SQLException x) {\n+        final String sqlState = x.getSQLState();\n+        return \"40XL1\".equals(sqlState) || \"40XL2\".equals(sqlState);\n+    }\n+\n+    @Override\n+    public boolean isConnectionError(SQLException x) {\n+        String sqlState = x.getSQLState();\n+        return sqlState != null && sqlState.startsWith(\"08\");\n+    }\n+\n+    @Override\n+    public DataAccessException translate(SQLException x) {\n+        if (isDeadlock(x)) {\n+            return new LockException(x, true);\n+        }\n+        else if (isLockTimeout(x)) {\n+            return new LockException(x, false);\n+        }\n+        else if (isConnectionError(x)) {\n+            return new ConnectionException(x);\n+        }\n+        else if (isDuplicate(x)) {\n+            return new UniqueConstraintViolationException(x);\n+        }\n+        else if (isUndefinedName(x)) {\n+            return new UndefinedNameException(x);\n+        }\n+        else {\n+            return new DataAccessException(x);\n+        }\n+    }\n+\n+    @Override\n+    public boolean isUndefinedName(SQLException x) {\n+        return \"42X05\".equals(x.getSQLState());\n+    }\n+\n+    @Override\n+    public void fillProperties(Properties p, ConnectionDetails cd) {\n+        p.put(\"user\", cd.getUser());\n+        p.put(\"password\", cd.getPassword());\n+\n+        if (cd.isSsl()) {\n+            p.put(\"sslConnection\", \"true\");\n+        }\n+\n+        if (cd.isHA()) {\n+            logger.warning(\"No HA support for PostgreSql\");\n+        }\n+    }\n+\n+    @Override\n+    public String timestampDiff(String left, String right, String alias) {\n+        if (alias == null || alias.isEmpty()) {\n+            return String.format(\"{fn timestampdiff(SQL_TSI_SECOND, %s, %s)}\", left, right);\n+        }\n+        else {\n+            return String.format(\"{fn timestampdiff(SQL_TSI_SECOND, %s, %s)} AS %s\", left, right, alias);\n+        }\n+    }\n+\n+    @Override\n+    public String createSequence(String name, int cache) {\n+        // cache isn't supported by PostgreSql\n+        return \"CREATE SEQUENCE \" + name;\n+    }\n+\n+    @Override\n+    public String reorgTableCommand(String tableName) {\n+        // REORG TABLE not supported by PostgreSql, so return null\n+        return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY4NjU0Mw=="}, "originalCommit": {"oid": "c3ea7ce045570353246610b88513f4f19c17f134"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NTUwODM5OnYy", "diffSide": "RIGHT", "path": "docs/src/pages/guides/FHIRServerUsersGuide.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMjo1NTowNlrOGITBzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMjo1NTowNlrOGITBzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM1MzU1MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            or you can simply use this sample DDL file: fhir-bulkimportexport-webapp/src/test/resources/batchPersistence-postgresql.ddl\n          \n          \n            \n            or you can simply use this sample DDL file: [fhir-bulkimportexport-webapp/src/test/resources/batchPersistence-postgresql.ddl](https://github.com/IBM/FHIR/tree/master/fhir-bulkimportexport-webapp/src/test/resources/batchPersistence-postgresql.ddl)", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411353551", "createdAt": "2020-04-20T12:55:06Z", "author": {"login": "prb112"}, "path": "docs/src/pages/guides/FHIRServerUsersGuide.md", "diffHunk": "@@ -1220,9 +1220,56 @@ The JavaBatch user is configured in server.xml and the bulkdata.json:\n \t</security-role>\n </authorization-roles>\n ```\n-Note: The user referenced in the bulkdata.json must have a role of at least batchSubmitter.\n+Note: The user referenced in the fhir-server-config.json must have a role of at least batchSubmitter.\n \n-By default, in-memory Derby database is used for persistence of the JavaBatch Jobs. Instruction is also provided in \"Configuring a Liberty Datasource with API Key\" section of the DB2OnCloudSetup guide to configure DB2 service in IBM Clouds as JavaBatch persistence store. Liberty JavaBatch framework creates DB schema and tables automatically by default for both approaches, and the configured database is created automatically, if the in-memory Apache Derby approach is used.   \n+By default, in-memory Derby database is used for persistence of the JavaBatch Jobs as configured in batchDs.xml. Instruction is also provided in \"Configuring a Liberty Datasource with API Key\" section of the DB2OnCloudSetup guide to configure DB2 service in IBM Clouds as JavaBatch persistence store. Liberty JavaBatch framework creates DB schema and tables automatically by default for both approaches, and the configured database is created automatically, if the in-memory Apache Derby approach is used.\n+\n+You can also choose to use postgresql or other RDBMS as your Job repository, if taking this approach, you will need to generate the DDL for the job tables first following [IBM Websphere Liberty Batch - Job Repository Configuration](https://www-03.ibm.com/support/techdocs/atsmastr.nsf/WebIndex/WP102716) , then make necessary changes to the generated DDL to make it valid for your RDBMS, and then create the job database, create javabatch user, create jbatch schema and then run the DDL to generate the job tables and enable it in batchDs.xml. let's use postgresql as an example:\n+\n+(1) Generate DDL and modify it according to your RDBMS.\n+\n+``` shell\n+ ./ddlGen generate fhir-server\n+```\n+then modify the generated DLL file to make it valid for postgresql. \n+or you can simply use this sample DDL file: fhir-bulkimportexport-webapp/src/test/resources/batchPersistence-postgresql.ddl", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NTUxMDU3OnYy", "diffSide": "RIGHT", "path": "docs/src/pages/guides/FHIRServerUsersGuide.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMjo1NTozMFrOGITC-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMjo1NTozMFrOGITC-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM1Mzg0OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ```\n          \n          \n            \n            ``` xml", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411353848", "createdAt": "2020-04-20T12:55:30Z", "author": {"login": "prb112"}, "path": "docs/src/pages/guides/FHIRServerUsersGuide.md", "diffHunk": "@@ -1220,9 +1220,56 @@ The JavaBatch user is configured in server.xml and the bulkdata.json:\n \t</security-role>\n </authorization-roles>\n ```\n-Note: The user referenced in the bulkdata.json must have a role of at least batchSubmitter.\n+Note: The user referenced in the fhir-server-config.json must have a role of at least batchSubmitter.\n \n-By default, in-memory Derby database is used for persistence of the JavaBatch Jobs. Instruction is also provided in \"Configuring a Liberty Datasource with API Key\" section of the DB2OnCloudSetup guide to configure DB2 service in IBM Clouds as JavaBatch persistence store. Liberty JavaBatch framework creates DB schema and tables automatically by default for both approaches, and the configured database is created automatically, if the in-memory Apache Derby approach is used.   \n+By default, in-memory Derby database is used for persistence of the JavaBatch Jobs as configured in batchDs.xml. Instruction is also provided in \"Configuring a Liberty Datasource with API Key\" section of the DB2OnCloudSetup guide to configure DB2 service in IBM Clouds as JavaBatch persistence store. Liberty JavaBatch framework creates DB schema and tables automatically by default for both approaches, and the configured database is created automatically, if the in-memory Apache Derby approach is used.\n+\n+You can also choose to use postgresql or other RDBMS as your Job repository, if taking this approach, you will need to generate the DDL for the job tables first following [IBM Websphere Liberty Batch - Job Repository Configuration](https://www-03.ibm.com/support/techdocs/atsmastr.nsf/WebIndex/WP102716) , then make necessary changes to the generated DDL to make it valid for your RDBMS, and then create the job database, create javabatch user, create jbatch schema and then run the DDL to generate the job tables and enable it in batchDs.xml. let's use postgresql as an example:\n+\n+(1) Generate DDL and modify it according to your RDBMS.\n+\n+``` shell\n+ ./ddlGen generate fhir-server\n+```\n+then modify the generated DLL file to make it valid for postgresql. \n+or you can simply use this sample DDL file: fhir-bulkimportexport-webapp/src/test/resources/batchPersistence-postgresql.ddl\n+\n+(2) Create the Job database and user.  \n+\n+``` shell\n+psql postgres\n+>postgres=# create database jobdb;\n+>postgres=# create user javabatch with password 'change-password';\n+>postgres=# grant all privileges on database jobdb to javabatch;\n+```\n+(3) Create jbatch schema.\n+\n+``` shell\n+psql -d jobdb -U javabatch\n+jobdb=> CREATE SCHEMA jbatch;\n+```\n+(4) Run the modified DDL with javabatch user against the job database.\n+\n+``` shell\n+psql -v ON_ERROR_STOP=1 -1 -U javabatch -f batchPersistence-postgresql.ddl -d jobdb\n+```\n+(5) Enable postgresql job repository in batchDs.xml as following.\n+\n+```", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NTUyOTg5OnYy", "diffSide": "RIGHT", "path": "fhir-bulkimportexport-webapp/src/test/resources/batchPersistence-postgresql.ddl", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMjo1OTo0MVrOGITOEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMjo1OTo0MVrOGITOEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM1NjY5MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            -- to 4.10.1 of IBM FHIR Server User's Guide about how this DDL is used.\n          \n          \n            \n            -- to 4.10.1 of IBM FHIR Server User's Guide about how this DDL is used.\n          \n          \n            \n            -- \n          \n          \n            \n            -- This DDL is modified with a larger JOB_PARAMETER.VALUE VARCHAR size of 4096.", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411356691", "createdAt": "2020-04-20T12:59:41Z", "author": {"login": "prb112"}, "path": "fhir-bulkimportexport-webapp/src/test/resources/batchPersistence-postgresql.ddl", "diffHunk": "@@ -0,0 +1,35 @@\n+-------------------------------------------------------------------------------\n+-- (C) Copyright IBM Corp. 2020\n+--\n+-- SPDX-License-Identifier: Apache-2.0\n+-------------------------------------------------------------------------------\n+\n+-- ----------------------------------------------------------------------------\n+-- Sample DDL for generating javabatch job tables for postgresql, please refer\n+-- to 4.10.1 of IBM FHIR Server User's Guide about how this DDL is used.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NTg4OTA5OnYy", "diffSide": "RIGHT", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/AddColumn.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoxMjoxN1rOGIWihQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNTo0MjozMVrOGIa8Vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxMTA3Nw==", "bodyText": "I suggest putting this in CommonDatabaseAdapter as a common method", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411411077", "createdAt": "2020-04-20T14:12:17Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/AddColumn.java", "diffHunk": "@@ -38,7 +42,19 @@ public AddColumn(String schemaName, String tableName, ColumnBase column) {\n     @Override\n     public void run(IDatabaseTranslator translator, Connection c) {\n         String qname = DataDefinitionUtil.getQualifiedName(schemaName, tableName);\n-        String ddl = \"ALTER TABLE \" + qname + \" ADD COLUMN \" + columnDef(column);\n+\n+        // DatabaseTypeAdapter is needed to find the correct data type for the column.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ4MzIyMw==", "bodyText": "because this is used by AddColumn only, so let's keep it here for now, if we can move whenever we need in the future.", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411483223", "createdAt": "2020-04-20T15:42:31Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/AddColumn.java", "diffHunk": "@@ -38,7 +42,19 @@ public AddColumn(String schemaName, String tableName, ColumnBase column) {\n     @Override\n     public void run(IDatabaseTranslator translator, Connection c) {\n         String qname = DataDefinitionUtil.getQualifiedName(schemaName, tableName);\n-        String ddl = \"ALTER TABLE \" + qname + \" ADD COLUMN \" + columnDef(column);\n+\n+        // DatabaseTypeAdapter is needed to find the correct data type for the column.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxMTA3Nw=="}, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NTg5ODA4OnYy", "diffSide": "LEFT", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/DataDefinitionUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoxMzo1OVrOGIWoAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxOTo0NjoxM1rOGIkyWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxMjQ4Mw==", "bodyText": "This is good defensive programming.  it's actually checking against a whitelist, and prevents any injection, since this is bundled/shipped, it's worth keeping, and adding a postgres branching logic.", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411412483", "createdAt": "2020-04-20T14:13:59Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/DataDefinitionUtil.java", "diffHunk": "@@ -34,59 +34,61 @@\n      */\n     public static String createUniqueIndex(String schemaName, String tableName, String indexName, List<String> indexColumns,\n             List<String> includeColumns) {\n-        \n+\n         StringBuilder result = new StringBuilder();\n         result.append(createUniqueIndex(schemaName, tableName, indexName, indexColumns));\n         result.append(\" INCLUDE (\");\n         result.append(join(includeColumns));\n         result.append(\")\");\n-        \n+\n         return result.toString();\n     }\n \n     /**\n-     * \n+     *\n      * @param schemaName\n      * @param tableName\n      * @param indexName\n      * @param indexColumns\n      * @return\n      */\n     public static String createUniqueIndex(String schemaName, String tableName, String indexName, List<String> indexColumns) {\n-        \n+\n         StringBuilder result = new StringBuilder();\n         result.append(\"CREATE UNIQUE INDEX \");\n-        result.append(getQualifiedName(schemaName, indexName));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY0NDUwNg==", "bodyText": "good idea. added logic to do this for postgresql only.", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411644506", "createdAt": "2020-04-20T19:46:13Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/DataDefinitionUtil.java", "diffHunk": "@@ -34,59 +34,61 @@\n      */\n     public static String createUniqueIndex(String schemaName, String tableName, String indexName, List<String> indexColumns,\n             List<String> includeColumns) {\n-        \n+\n         StringBuilder result = new StringBuilder();\n         result.append(createUniqueIndex(schemaName, tableName, indexName, indexColumns));\n         result.append(\" INCLUDE (\");\n         result.append(join(includeColumns));\n         result.append(\")\");\n-        \n+\n         return result.toString();\n     }\n \n     /**\n-     * \n+     *\n      * @param schemaName\n      * @param tableName\n      * @param indexName\n      * @param indexColumns\n      * @return\n      */\n     public static String createUniqueIndex(String schemaName, String tableName, String indexName, List<String> indexColumns) {\n-        \n+\n         StringBuilder result = new StringBuilder();\n         result.append(\"CREATE UNIQUE INDEX \");\n-        result.append(getQualifiedName(schemaName, indexName));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxMjQ4Mw=="}, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NTkwMjczOnYy", "diffSide": "LEFT", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/DataDefinitionUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoxNDo1MlrOGIWqzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxOTo0NjoyMlrOGIkyvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxMzE5Nw==", "bodyText": "This is good defensive programming. it's actually checking against a whitelist, and prevents any injection, since this is bundled/shipped, it's worth keeping, and adding a postgres branching logic.", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411413197", "createdAt": "2020-04-20T14:14:52Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/DataDefinitionUtil.java", "diffHunk": "@@ -34,59 +34,61 @@\n      */\n     public static String createUniqueIndex(String schemaName, String tableName, String indexName, List<String> indexColumns,\n             List<String> includeColumns) {\n-        \n+\n         StringBuilder result = new StringBuilder();\n         result.append(createUniqueIndex(schemaName, tableName, indexName, indexColumns));\n         result.append(\" INCLUDE (\");\n         result.append(join(includeColumns));\n         result.append(\")\");\n-        \n+\n         return result.toString();\n     }\n \n     /**\n-     * \n+     *\n      * @param schemaName\n      * @param tableName\n      * @param indexName\n      * @param indexColumns\n      * @return\n      */\n     public static String createUniqueIndex(String schemaName, String tableName, String indexName, List<String> indexColumns) {\n-        \n+\n         StringBuilder result = new StringBuilder();\n         result.append(\"CREATE UNIQUE INDEX \");\n-        result.append(getQualifiedName(schemaName, indexName));\n+        // Postgresql doesn't support index name prefixed with the schema name.\n+        result.append(indexName);\n         result.append(\" ON \");\n         result.append(getQualifiedName(schemaName, tableName));\n         result.append(\"(\");\n         result.append(join(indexColumns));\n         result.append(\")\");\n-                \n+\n         return result.toString();\n     }\n \n \n     /**\n      * Create the DDL for a plain old index\n-     * \n+     *\n      * @param schemaName\n      * @param tableName\n      * @param indexName\n      * @param indexColumns\n      * @return\n      */\n     public static String createIndex(String schemaName, String tableName, String indexName, List<String> indexColumns) {\n-                \n+\n         StringBuilder result = new StringBuilder();\n         result.append(\"CREATE INDEX \");\n-        result.append(getQualifiedName(schemaName, indexName));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY0NDYwNw==", "bodyText": "good idea. added logic to do this for postgresql only.", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411644607", "createdAt": "2020-04-20T19:46:22Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/DataDefinitionUtil.java", "diffHunk": "@@ -34,59 +34,61 @@\n      */\n     public static String createUniqueIndex(String schemaName, String tableName, String indexName, List<String> indexColumns,\n             List<String> includeColumns) {\n-        \n+\n         StringBuilder result = new StringBuilder();\n         result.append(createUniqueIndex(schemaName, tableName, indexName, indexColumns));\n         result.append(\" INCLUDE (\");\n         result.append(join(includeColumns));\n         result.append(\")\");\n-        \n+\n         return result.toString();\n     }\n \n     /**\n-     * \n+     *\n      * @param schemaName\n      * @param tableName\n      * @param indexName\n      * @param indexColumns\n      * @return\n      */\n     public static String createUniqueIndex(String schemaName, String tableName, String indexName, List<String> indexColumns) {\n-        \n+\n         StringBuilder result = new StringBuilder();\n         result.append(\"CREATE UNIQUE INDEX \");\n-        result.append(getQualifiedName(schemaName, indexName));\n+        // Postgresql doesn't support index name prefixed with the schema name.\n+        result.append(indexName);\n         result.append(\" ON \");\n         result.append(getQualifiedName(schemaName, tableName));\n         result.append(\"(\");\n         result.append(join(indexColumns));\n         result.append(\")\");\n-                \n+\n         return result.toString();\n     }\n \n \n     /**\n      * Create the DDL for a plain old index\n-     * \n+     *\n      * @param schemaName\n      * @param tableName\n      * @param indexName\n      * @param indexColumns\n      * @return\n      */\n     public static String createIndex(String schemaName, String tableName, String indexName, List<String> indexColumns) {\n-                \n+\n         StringBuilder result = new StringBuilder();\n         result.append(\"CREATE INDEX \");\n-        result.append(getQualifiedName(schemaName, indexName));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxMzE5Nw=="}, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NTkwNzQ4OnYy", "diffSide": "RIGHT", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlAdapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoxNTo1NVrOGIWt8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNTo0NjoyNlrOGIbIWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxNDAwMQ==", "bodyText": "extra line.", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411414001", "createdAt": "2020-04-20T14:15:55Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlAdapter.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Supplier;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseTarget;\n+import com.ibm.fhir.database.utils.common.AddForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.common.CommonDatabaseAdapter;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+import com.ibm.fhir.database.utils.model.ColumnBase;\n+import com.ibm.fhir.database.utils.model.ForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.model.IdentityDef;\n+import com.ibm.fhir.database.utils.model.PrimaryKeyDef;\n+import com.ibm.fhir.database.utils.model.Table;\n+\n+/**\n+ * A PostgreSql database target\n+ */\n+public class PostgreSqlAdapter extends CommonDatabaseAdapter {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlAdapter.class.getName());\n+\n+    // Different warning messages we track so that we only have to report them once\n+    private enum MessageKey {\n+        MULTITENANCY, CREATE_VAR, CREATE_PERM, ENABLE_ROW_ACCESS, DISABLE_ROW_ACCESS, PARTITIONING,\n+        ROW_TYPE, ROW_ARR_TYPE, DROP_TYPE, CREATE_PROC, DROP_PROC, TABLESPACE\n+    }\n+\n+    // Just warn once for each unique message key. This cleans up build logs a lot\n+    private static final Set<MessageKey> warned = ConcurrentHashMap.newKeySet();\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ4NjI5Nw==", "bodyText": "done", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411486297", "createdAt": "2020-04-20T15:46:26Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlAdapter.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Supplier;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseTarget;\n+import com.ibm.fhir.database.utils.common.AddForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.common.CommonDatabaseAdapter;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+import com.ibm.fhir.database.utils.model.ColumnBase;\n+import com.ibm.fhir.database.utils.model.ForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.model.IdentityDef;\n+import com.ibm.fhir.database.utils.model.PrimaryKeyDef;\n+import com.ibm.fhir.database.utils.model.Table;\n+\n+/**\n+ * A PostgreSql database target\n+ */\n+public class PostgreSqlAdapter extends CommonDatabaseAdapter {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlAdapter.class.getName());\n+\n+    // Different warning messages we track so that we only have to report them once\n+    private enum MessageKey {\n+        MULTITENANCY, CREATE_VAR, CREATE_PERM, ENABLE_ROW_ACCESS, DISABLE_ROW_ACCESS, PARTITIONING,\n+        ROW_TYPE, ROW_ARR_TYPE, DROP_TYPE, CREATE_PROC, DROP_PROC, TABLESPACE\n+    }\n+\n+    // Just warn once for each unique message key. This cleans up build logs a lot\n+    private static final Set<MessageKey> warned = ConcurrentHashMap.newKeySet();\n+\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxNDAwMQ=="}, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NTkwOTE5OnYy", "diffSide": "RIGHT", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlAdapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoxNjowOVrOGIWu2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNTo0NzoyM1rOGIbLKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxNDIzNA==", "bodyText": "best to have each entry on a single line", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411414234", "createdAt": "2020-04-20T14:16:09Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlAdapter.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Supplier;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseTarget;\n+import com.ibm.fhir.database.utils.common.AddForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.common.CommonDatabaseAdapter;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+import com.ibm.fhir.database.utils.model.ColumnBase;\n+import com.ibm.fhir.database.utils.model.ForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.model.IdentityDef;\n+import com.ibm.fhir.database.utils.model.PrimaryKeyDef;\n+import com.ibm.fhir.database.utils.model.Table;\n+\n+/**\n+ * A PostgreSql database target\n+ */\n+public class PostgreSqlAdapter extends CommonDatabaseAdapter {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlAdapter.class.getName());\n+\n+    // Different warning messages we track so that we only have to report them once\n+    private enum MessageKey {\n+        MULTITENANCY, CREATE_VAR, CREATE_PERM, ENABLE_ROW_ACCESS, DISABLE_ROW_ACCESS, PARTITIONING,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ4NzAxNg==", "bodyText": "done", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411487016", "createdAt": "2020-04-20T15:47:23Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlAdapter.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Supplier;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseTarget;\n+import com.ibm.fhir.database.utils.common.AddForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.common.CommonDatabaseAdapter;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+import com.ibm.fhir.database.utils.model.ColumnBase;\n+import com.ibm.fhir.database.utils.model.ForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.model.IdentityDef;\n+import com.ibm.fhir.database.utils.model.PrimaryKeyDef;\n+import com.ibm.fhir.database.utils.model.Table;\n+\n+/**\n+ * A PostgreSql database target\n+ */\n+public class PostgreSqlAdapter extends CommonDatabaseAdapter {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlAdapter.class.getName());\n+\n+    // Different warning messages we track so that we only have to report them once\n+    private enum MessageKey {\n+        MULTITENANCY, CREATE_VAR, CREATE_PERM, ENABLE_ROW_ACCESS, DISABLE_ROW_ACCESS, PARTITIONING,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxNDIzNA=="}, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NTkxMjU5OnYy", "diffSide": "RIGHT", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlAdapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoxNjo0N1rOGIWw6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNTo0Nzo1M1rOGIbMmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxNDc2Mw==", "bodyText": "Extra line", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411414763", "createdAt": "2020-04-20T14:16:47Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlAdapter.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Supplier;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseTarget;\n+import com.ibm.fhir.database.utils.common.AddForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.common.CommonDatabaseAdapter;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+import com.ibm.fhir.database.utils.model.ColumnBase;\n+import com.ibm.fhir.database.utils.model.ForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.model.IdentityDef;\n+import com.ibm.fhir.database.utils.model.PrimaryKeyDef;\n+import com.ibm.fhir.database.utils.model.Table;\n+\n+/**\n+ * A PostgreSql database target\n+ */\n+public class PostgreSqlAdapter extends CommonDatabaseAdapter {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlAdapter.class.getName());\n+\n+    // Different warning messages we track so that we only have to report them once\n+    private enum MessageKey {\n+        MULTITENANCY, CREATE_VAR, CREATE_PERM, ENABLE_ROW_ACCESS, DISABLE_ROW_ACCESS, PARTITIONING,\n+        ROW_TYPE, ROW_ARR_TYPE, DROP_TYPE, CREATE_PROC, DROP_PROC, TABLESPACE\n+    }\n+\n+    // Just warn once for each unique message key. This cleans up build logs a lot\n+    private static final Set<MessageKey> warned = ConcurrentHashMap.newKeySet();\n+\n+\n+    /**\n+     * Public constructor\n+     * @param tgt the target database we want to manage\n+     */\n+    public PostgreSqlAdapter(IDatabaseTarget tgt) {\n+        super(tgt, new PostgreSqlTranslator());\n+    }\n+\n+    public PostgreSqlAdapter(IConnectionProvider cp) {\n+        super(cp, new PostgreSqlTranslator());\n+    }\n+\n+    public PostgreSqlAdapter() {\n+        super();\n+    }\n+\n+    /**\n+     * Once write each warning message once\n+     * @param msg\n+     */\n+    public void warnOnce(MessageKey messageKey, String msg) {\n+        if (logger.isLoggable(Level.WARNING) && !warned.contains(messageKey)) {\n+            warned.add(messageKey);\n+            logger.warning(\"[ONCE] \" + msg);\n+        }\n+    }\n+\n+    @Override\n+    public void createTable(String schemaName, String name, String tenantColumnName, List<ColumnBase> columns, PrimaryKeyDef primaryKey,\n+            IdentityDef identity, String tablespaceName) {\n+\n+        // PostgreSql doesn't support partitioning, so we ignore tenantColumnName\n+        if (tenantColumnName != null) {\n+            warnOnce(MessageKey.MULTITENANCY, \"PostgreSql does support not multi-tenancy: \" + name);\n+        }\n+\n+        // We also ignore tablespace for PostgreSql\n+        String ddl = buildCreateTableStatement(schemaName, name, columns, primaryKey, identity, null);\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ4NzM4Ng==", "bodyText": "done", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411487386", "createdAt": "2020-04-20T15:47:53Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlAdapter.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Supplier;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseTarget;\n+import com.ibm.fhir.database.utils.common.AddForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.common.CommonDatabaseAdapter;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+import com.ibm.fhir.database.utils.model.ColumnBase;\n+import com.ibm.fhir.database.utils.model.ForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.model.IdentityDef;\n+import com.ibm.fhir.database.utils.model.PrimaryKeyDef;\n+import com.ibm.fhir.database.utils.model.Table;\n+\n+/**\n+ * A PostgreSql database target\n+ */\n+public class PostgreSqlAdapter extends CommonDatabaseAdapter {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlAdapter.class.getName());\n+\n+    // Different warning messages we track so that we only have to report them once\n+    private enum MessageKey {\n+        MULTITENANCY, CREATE_VAR, CREATE_PERM, ENABLE_ROW_ACCESS, DISABLE_ROW_ACCESS, PARTITIONING,\n+        ROW_TYPE, ROW_ARR_TYPE, DROP_TYPE, CREATE_PROC, DROP_PROC, TABLESPACE\n+    }\n+\n+    // Just warn once for each unique message key. This cleans up build logs a lot\n+    private static final Set<MessageKey> warned = ConcurrentHashMap.newKeySet();\n+\n+\n+    /**\n+     * Public constructor\n+     * @param tgt the target database we want to manage\n+     */\n+    public PostgreSqlAdapter(IDatabaseTarget tgt) {\n+        super(tgt, new PostgreSqlTranslator());\n+    }\n+\n+    public PostgreSqlAdapter(IConnectionProvider cp) {\n+        super(cp, new PostgreSqlTranslator());\n+    }\n+\n+    public PostgreSqlAdapter() {\n+        super();\n+    }\n+\n+    /**\n+     * Once write each warning message once\n+     * @param msg\n+     */\n+    public void warnOnce(MessageKey messageKey, String msg) {\n+        if (logger.isLoggable(Level.WARNING) && !warned.contains(messageKey)) {\n+            warned.add(messageKey);\n+            logger.warning(\"[ONCE] \" + msg);\n+        }\n+    }\n+\n+    @Override\n+    public void createTable(String schemaName, String name, String tenantColumnName, List<ColumnBase> columns, PrimaryKeyDef primaryKey,\n+            IdentityDef identity, String tablespaceName) {\n+\n+        // PostgreSql doesn't support partitioning, so we ignore tenantColumnName\n+        if (tenantColumnName != null) {\n+            warnOnce(MessageKey.MULTITENANCY, \"PostgreSql does support not multi-tenancy: \" + name);\n+        }\n+\n+        // We also ignore tablespace for PostgreSql\n+        String ddl = buildCreateTableStatement(schemaName, name, columns, primaryKey, identity, null);\n+\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxNDc2Mw=="}, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NTkxNTAzOnYy", "diffSide": "RIGHT", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlAdapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoxNzoxN1rOGIWygA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNTo0ODozNlrOGIbO4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxNTE2OA==", "bodyText": "line space is not needed", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411415168", "createdAt": "2020-04-20T14:17:17Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlAdapter.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Supplier;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseTarget;\n+import com.ibm.fhir.database.utils.common.AddForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.common.CommonDatabaseAdapter;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+import com.ibm.fhir.database.utils.model.ColumnBase;\n+import com.ibm.fhir.database.utils.model.ForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.model.IdentityDef;\n+import com.ibm.fhir.database.utils.model.PrimaryKeyDef;\n+import com.ibm.fhir.database.utils.model.Table;\n+\n+/**\n+ * A PostgreSql database target\n+ */\n+public class PostgreSqlAdapter extends CommonDatabaseAdapter {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlAdapter.class.getName());\n+\n+    // Different warning messages we track so that we only have to report them once\n+    private enum MessageKey {\n+        MULTITENANCY, CREATE_VAR, CREATE_PERM, ENABLE_ROW_ACCESS, DISABLE_ROW_ACCESS, PARTITIONING,\n+        ROW_TYPE, ROW_ARR_TYPE, DROP_TYPE, CREATE_PROC, DROP_PROC, TABLESPACE\n+    }\n+\n+    // Just warn once for each unique message key. This cleans up build logs a lot\n+    private static final Set<MessageKey> warned = ConcurrentHashMap.newKeySet();\n+\n+\n+    /**\n+     * Public constructor\n+     * @param tgt the target database we want to manage\n+     */\n+    public PostgreSqlAdapter(IDatabaseTarget tgt) {\n+        super(tgt, new PostgreSqlTranslator());\n+    }\n+\n+    public PostgreSqlAdapter(IConnectionProvider cp) {\n+        super(cp, new PostgreSqlTranslator());\n+    }\n+\n+    public PostgreSqlAdapter() {\n+        super();\n+    }\n+\n+    /**\n+     * Once write each warning message once\n+     * @param msg\n+     */\n+    public void warnOnce(MessageKey messageKey, String msg) {\n+        if (logger.isLoggable(Level.WARNING) && !warned.contains(messageKey)) {\n+            warned.add(messageKey);\n+            logger.warning(\"[ONCE] \" + msg);\n+        }\n+    }\n+\n+    @Override\n+    public void createTable(String schemaName, String name, String tenantColumnName, List<ColumnBase> columns, PrimaryKeyDef primaryKey,\n+            IdentityDef identity, String tablespaceName) {\n+\n+        // PostgreSql doesn't support partitioning, so we ignore tenantColumnName\n+        if (tenantColumnName != null) {\n+            warnOnce(MessageKey.MULTITENANCY, \"PostgreSql does support not multi-tenancy: \" + name);\n+        }\n+\n+        // We also ignore tablespace for PostgreSql\n+        String ddl = buildCreateTableStatement(schemaName, name, columns, primaryKey, identity, null);\n+\n+\n+        runStatement(ddl);\n+    }\n+\n+    @Override\n+    public void createUniqueIndex(String schemaName, String tableName, String indexName, String tenantColumnName, List<String> indexColumns,\n+            List<String> includeColumns) {\n+\n+        // PostgreSql doesn't support include columns, so we just have to create a normal index\n+        createUniqueIndex(schemaName, tableName, indexName, tenantColumnName, indexColumns);\n+    }\n+\n+    @Override\n+    public void createIntVariable(String schemaName, String variableName) {\n+        warnOnce(MessageKey.CREATE_VAR, \"PostgreSql does not support CREATE VARIABLE for: \" + variableName);\n+    }\n+\n+    @Override\n+    public void createOrReplacePermission(String schemaName, String permissionName, String tableName, String predicate) {\n+        warnOnce(MessageKey.CREATE_PERM, \"PostgreSql does not support CREATE PERMISSION for: \" + permissionName);\n+    }\n+\n+    @Override\n+    public void activateRowAccessControl(String schemaName, String tableName) {\n+        warnOnce(MessageKey.ENABLE_ROW_ACCESS, \"PostgreSql does not support ROW ACCESS CONTROL for table: \" + tableName);\n+    }\n+\n+    @Override\n+    public void setIntVariable(String schemaName, String variableName, int value) {\n+        // As this is a runtime issue, we throw as an exception instead of\n+        // simply logging a warning. This shouldn't be called in the case\n+        // of a PostgreSql database\n+        throw new IllegalStateException(\"setIntVariable not supported on PostgreSql for: \" + variableName);\n+    }\n+\n+    @Override\n+    public void deactivateRowAccessControl(String schemaName, String tableName) {\n+        warnOnce(MessageKey.DISABLE_ROW_ACCESS, \"PostgreSql does not support ROW ACCESS CONTROL for table: \" + tableName);\n+    }\n+\n+    @Override\n+    public void createTenantPartitions(Collection<Table> tables, String schemaName, int newTenantId, int extentSizeKB) {\n+        warnOnce(MessageKey.PARTITIONING, \"PostgreSql does not support tenant partitioning\");\n+    }\n+\n+    @Override\n+    public void createRowType(String schemaName, String typeName, List<ColumnBase> columns) {\n+        warnOnce(MessageKey.ROW_TYPE, \"Create row type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createArrType(String schemaName, String typeName, String valueType, int arraySize) {\n+        warnOnce(MessageKey.ROW_ARR_TYPE, \"Create array row type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropType(String schemaName, String typeName) {\n+        warnOnce(MessageKey.DROP_TYPE, \"Drop type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createOrReplaceProcedure(String schemaName, String procedureName, Supplier<String> supplier) {\n+        warnOnce(MessageKey.CREATE_PROC, \"Create procedure not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropProcedure(String schemaName, String procedureName) {\n+        warnOnce(MessageKey.DROP_PROC, \"Drop procedure not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createTablespace(String tablespaceName) {\n+        warnOnce(MessageKey.TABLESPACE, \"Create tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropTablespace(String tablespaceName) {\n+        warnOnce(MessageKey.TABLESPACE, \"Drop tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void detachPartition(String schemaName, String tableName, String partitionName, String newTableName) {\n+        warnOnce(MessageKey.PARTITIONING, \"Detach partition not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void removeTenantPartitions(Collection<Table> tables, String schemaName, int tenantId,\n+            String tenantStagingTable) {\n+        warnOnce(MessageKey.PARTITIONING, \"Remove tenant partitions not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createTablespace(String tablespaceName, int extentSizeKB) {\n+        warnOnce(MessageKey.TABLESPACE, \"Create tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public boolean doesTableExist(String schemaName, String tableName) {\n+        PostgreSqlDoesTableExist dao = new PostgreSqlDoesTableExist(schemaName, tableName);\n+        return runStatement(dao);\n+    }\n+\n+    @Override\n+    public void createSequence(String schemaName, String sequenceName, int cache) {\n+        /* CREATE SEQUENCE fhir_sequence\n+         *     AS BIGINT\n+         *     START WITH 1\n+         *     CACHE 1000\n+         *     NO CYCLE;\n+        */\n+        // PostgreSql doesn't support CACHE\n+        final String sname = DataDefinitionUtil.getQualifiedName(schemaName, sequenceName);\n+        final String ddl = \"CREATE SEQUENCE \" + sname + \" AS BIGINT START WITH 1 NO CYCLE\";\n+        runStatement(ddl);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ4Nzk2OQ==", "bodyText": "done", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411487969", "createdAt": "2020-04-20T15:48:36Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlAdapter.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Supplier;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseTarget;\n+import com.ibm.fhir.database.utils.common.AddForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.common.CommonDatabaseAdapter;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+import com.ibm.fhir.database.utils.model.ColumnBase;\n+import com.ibm.fhir.database.utils.model.ForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.model.IdentityDef;\n+import com.ibm.fhir.database.utils.model.PrimaryKeyDef;\n+import com.ibm.fhir.database.utils.model.Table;\n+\n+/**\n+ * A PostgreSql database target\n+ */\n+public class PostgreSqlAdapter extends CommonDatabaseAdapter {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlAdapter.class.getName());\n+\n+    // Different warning messages we track so that we only have to report them once\n+    private enum MessageKey {\n+        MULTITENANCY, CREATE_VAR, CREATE_PERM, ENABLE_ROW_ACCESS, DISABLE_ROW_ACCESS, PARTITIONING,\n+        ROW_TYPE, ROW_ARR_TYPE, DROP_TYPE, CREATE_PROC, DROP_PROC, TABLESPACE\n+    }\n+\n+    // Just warn once for each unique message key. This cleans up build logs a lot\n+    private static final Set<MessageKey> warned = ConcurrentHashMap.newKeySet();\n+\n+\n+    /**\n+     * Public constructor\n+     * @param tgt the target database we want to manage\n+     */\n+    public PostgreSqlAdapter(IDatabaseTarget tgt) {\n+        super(tgt, new PostgreSqlTranslator());\n+    }\n+\n+    public PostgreSqlAdapter(IConnectionProvider cp) {\n+        super(cp, new PostgreSqlTranslator());\n+    }\n+\n+    public PostgreSqlAdapter() {\n+        super();\n+    }\n+\n+    /**\n+     * Once write each warning message once\n+     * @param msg\n+     */\n+    public void warnOnce(MessageKey messageKey, String msg) {\n+        if (logger.isLoggable(Level.WARNING) && !warned.contains(messageKey)) {\n+            warned.add(messageKey);\n+            logger.warning(\"[ONCE] \" + msg);\n+        }\n+    }\n+\n+    @Override\n+    public void createTable(String schemaName, String name, String tenantColumnName, List<ColumnBase> columns, PrimaryKeyDef primaryKey,\n+            IdentityDef identity, String tablespaceName) {\n+\n+        // PostgreSql doesn't support partitioning, so we ignore tenantColumnName\n+        if (tenantColumnName != null) {\n+            warnOnce(MessageKey.MULTITENANCY, \"PostgreSql does support not multi-tenancy: \" + name);\n+        }\n+\n+        // We also ignore tablespace for PostgreSql\n+        String ddl = buildCreateTableStatement(schemaName, name, columns, primaryKey, identity, null);\n+\n+\n+        runStatement(ddl);\n+    }\n+\n+    @Override\n+    public void createUniqueIndex(String schemaName, String tableName, String indexName, String tenantColumnName, List<String> indexColumns,\n+            List<String> includeColumns) {\n+\n+        // PostgreSql doesn't support include columns, so we just have to create a normal index\n+        createUniqueIndex(schemaName, tableName, indexName, tenantColumnName, indexColumns);\n+    }\n+\n+    @Override\n+    public void createIntVariable(String schemaName, String variableName) {\n+        warnOnce(MessageKey.CREATE_VAR, \"PostgreSql does not support CREATE VARIABLE for: \" + variableName);\n+    }\n+\n+    @Override\n+    public void createOrReplacePermission(String schemaName, String permissionName, String tableName, String predicate) {\n+        warnOnce(MessageKey.CREATE_PERM, \"PostgreSql does not support CREATE PERMISSION for: \" + permissionName);\n+    }\n+\n+    @Override\n+    public void activateRowAccessControl(String schemaName, String tableName) {\n+        warnOnce(MessageKey.ENABLE_ROW_ACCESS, \"PostgreSql does not support ROW ACCESS CONTROL for table: \" + tableName);\n+    }\n+\n+    @Override\n+    public void setIntVariable(String schemaName, String variableName, int value) {\n+        // As this is a runtime issue, we throw as an exception instead of\n+        // simply logging a warning. This shouldn't be called in the case\n+        // of a PostgreSql database\n+        throw new IllegalStateException(\"setIntVariable not supported on PostgreSql for: \" + variableName);\n+    }\n+\n+    @Override\n+    public void deactivateRowAccessControl(String schemaName, String tableName) {\n+        warnOnce(MessageKey.DISABLE_ROW_ACCESS, \"PostgreSql does not support ROW ACCESS CONTROL for table: \" + tableName);\n+    }\n+\n+    @Override\n+    public void createTenantPartitions(Collection<Table> tables, String schemaName, int newTenantId, int extentSizeKB) {\n+        warnOnce(MessageKey.PARTITIONING, \"PostgreSql does not support tenant partitioning\");\n+    }\n+\n+    @Override\n+    public void createRowType(String schemaName, String typeName, List<ColumnBase> columns) {\n+        warnOnce(MessageKey.ROW_TYPE, \"Create row type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createArrType(String schemaName, String typeName, String valueType, int arraySize) {\n+        warnOnce(MessageKey.ROW_ARR_TYPE, \"Create array row type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropType(String schemaName, String typeName) {\n+        warnOnce(MessageKey.DROP_TYPE, \"Drop type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createOrReplaceProcedure(String schemaName, String procedureName, Supplier<String> supplier) {\n+        warnOnce(MessageKey.CREATE_PROC, \"Create procedure not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropProcedure(String schemaName, String procedureName) {\n+        warnOnce(MessageKey.DROP_PROC, \"Drop procedure not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createTablespace(String tablespaceName) {\n+        warnOnce(MessageKey.TABLESPACE, \"Create tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropTablespace(String tablespaceName) {\n+        warnOnce(MessageKey.TABLESPACE, \"Drop tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void detachPartition(String schemaName, String tableName, String partitionName, String newTableName) {\n+        warnOnce(MessageKey.PARTITIONING, \"Detach partition not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void removeTenantPartitions(Collection<Table> tables, String schemaName, int tenantId,\n+            String tenantStagingTable) {\n+        warnOnce(MessageKey.PARTITIONING, \"Remove tenant partitions not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createTablespace(String tablespaceName, int extentSizeKB) {\n+        warnOnce(MessageKey.TABLESPACE, \"Create tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public boolean doesTableExist(String schemaName, String tableName) {\n+        PostgreSqlDoesTableExist dao = new PostgreSqlDoesTableExist(schemaName, tableName);\n+        return runStatement(dao);\n+    }\n+\n+    @Override\n+    public void createSequence(String schemaName, String sequenceName, int cache) {\n+        /* CREATE SEQUENCE fhir_sequence\n+         *     AS BIGINT\n+         *     START WITH 1\n+         *     CACHE 1000\n+         *     NO CYCLE;\n+        */\n+        // PostgreSql doesn't support CACHE\n+        final String sname = DataDefinitionUtil.getQualifiedName(schemaName, sequenceName);\n+        final String ddl = \"CREATE SEQUENCE \" + sname + \" AS BIGINT START WITH 1 NO CYCLE\";\n+        runStatement(ddl);\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxNTE2OA=="}, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 198}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NTkxOTU1OnYy", "diffSide": "RIGHT", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlAdapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoxODoxMFrOGIW1OA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNTo1NDowM1rOGIbf1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxNTg2NA==", "bodyText": "start at 1000 always.  it give space to use the ID with specific mappings. for instance RESOURCE_TYPE are hard coded, and we don't want it to client.", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411415864", "createdAt": "2020-04-20T14:18:10Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlAdapter.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Supplier;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseTarget;\n+import com.ibm.fhir.database.utils.common.AddForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.common.CommonDatabaseAdapter;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+import com.ibm.fhir.database.utils.model.ColumnBase;\n+import com.ibm.fhir.database.utils.model.ForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.model.IdentityDef;\n+import com.ibm.fhir.database.utils.model.PrimaryKeyDef;\n+import com.ibm.fhir.database.utils.model.Table;\n+\n+/**\n+ * A PostgreSql database target\n+ */\n+public class PostgreSqlAdapter extends CommonDatabaseAdapter {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlAdapter.class.getName());\n+\n+    // Different warning messages we track so that we only have to report them once\n+    private enum MessageKey {\n+        MULTITENANCY, CREATE_VAR, CREATE_PERM, ENABLE_ROW_ACCESS, DISABLE_ROW_ACCESS, PARTITIONING,\n+        ROW_TYPE, ROW_ARR_TYPE, DROP_TYPE, CREATE_PROC, DROP_PROC, TABLESPACE\n+    }\n+\n+    // Just warn once for each unique message key. This cleans up build logs a lot\n+    private static final Set<MessageKey> warned = ConcurrentHashMap.newKeySet();\n+\n+\n+    /**\n+     * Public constructor\n+     * @param tgt the target database we want to manage\n+     */\n+    public PostgreSqlAdapter(IDatabaseTarget tgt) {\n+        super(tgt, new PostgreSqlTranslator());\n+    }\n+\n+    public PostgreSqlAdapter(IConnectionProvider cp) {\n+        super(cp, new PostgreSqlTranslator());\n+    }\n+\n+    public PostgreSqlAdapter() {\n+        super();\n+    }\n+\n+    /**\n+     * Once write each warning message once\n+     * @param msg\n+     */\n+    public void warnOnce(MessageKey messageKey, String msg) {\n+        if (logger.isLoggable(Level.WARNING) && !warned.contains(messageKey)) {\n+            warned.add(messageKey);\n+            logger.warning(\"[ONCE] \" + msg);\n+        }\n+    }\n+\n+    @Override\n+    public void createTable(String schemaName, String name, String tenantColumnName, List<ColumnBase> columns, PrimaryKeyDef primaryKey,\n+            IdentityDef identity, String tablespaceName) {\n+\n+        // PostgreSql doesn't support partitioning, so we ignore tenantColumnName\n+        if (tenantColumnName != null) {\n+            warnOnce(MessageKey.MULTITENANCY, \"PostgreSql does support not multi-tenancy: \" + name);\n+        }\n+\n+        // We also ignore tablespace for PostgreSql\n+        String ddl = buildCreateTableStatement(schemaName, name, columns, primaryKey, identity, null);\n+\n+\n+        runStatement(ddl);\n+    }\n+\n+    @Override\n+    public void createUniqueIndex(String schemaName, String tableName, String indexName, String tenantColumnName, List<String> indexColumns,\n+            List<String> includeColumns) {\n+\n+        // PostgreSql doesn't support include columns, so we just have to create a normal index\n+        createUniqueIndex(schemaName, tableName, indexName, tenantColumnName, indexColumns);\n+    }\n+\n+    @Override\n+    public void createIntVariable(String schemaName, String variableName) {\n+        warnOnce(MessageKey.CREATE_VAR, \"PostgreSql does not support CREATE VARIABLE for: \" + variableName);\n+    }\n+\n+    @Override\n+    public void createOrReplacePermission(String schemaName, String permissionName, String tableName, String predicate) {\n+        warnOnce(MessageKey.CREATE_PERM, \"PostgreSql does not support CREATE PERMISSION for: \" + permissionName);\n+    }\n+\n+    @Override\n+    public void activateRowAccessControl(String schemaName, String tableName) {\n+        warnOnce(MessageKey.ENABLE_ROW_ACCESS, \"PostgreSql does not support ROW ACCESS CONTROL for table: \" + tableName);\n+    }\n+\n+    @Override\n+    public void setIntVariable(String schemaName, String variableName, int value) {\n+        // As this is a runtime issue, we throw as an exception instead of\n+        // simply logging a warning. This shouldn't be called in the case\n+        // of a PostgreSql database\n+        throw new IllegalStateException(\"setIntVariable not supported on PostgreSql for: \" + variableName);\n+    }\n+\n+    @Override\n+    public void deactivateRowAccessControl(String schemaName, String tableName) {\n+        warnOnce(MessageKey.DISABLE_ROW_ACCESS, \"PostgreSql does not support ROW ACCESS CONTROL for table: \" + tableName);\n+    }\n+\n+    @Override\n+    public void createTenantPartitions(Collection<Table> tables, String schemaName, int newTenantId, int extentSizeKB) {\n+        warnOnce(MessageKey.PARTITIONING, \"PostgreSql does not support tenant partitioning\");\n+    }\n+\n+    @Override\n+    public void createRowType(String schemaName, String typeName, List<ColumnBase> columns) {\n+        warnOnce(MessageKey.ROW_TYPE, \"Create row type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createArrType(String schemaName, String typeName, String valueType, int arraySize) {\n+        warnOnce(MessageKey.ROW_ARR_TYPE, \"Create array row type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropType(String schemaName, String typeName) {\n+        warnOnce(MessageKey.DROP_TYPE, \"Drop type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createOrReplaceProcedure(String schemaName, String procedureName, Supplier<String> supplier) {\n+        warnOnce(MessageKey.CREATE_PROC, \"Create procedure not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropProcedure(String schemaName, String procedureName) {\n+        warnOnce(MessageKey.DROP_PROC, \"Drop procedure not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createTablespace(String tablespaceName) {\n+        warnOnce(MessageKey.TABLESPACE, \"Create tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropTablespace(String tablespaceName) {\n+        warnOnce(MessageKey.TABLESPACE, \"Drop tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void detachPartition(String schemaName, String tableName, String partitionName, String newTableName) {\n+        warnOnce(MessageKey.PARTITIONING, \"Detach partition not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void removeTenantPartitions(Collection<Table> tables, String schemaName, int tenantId,\n+            String tenantStagingTable) {\n+        warnOnce(MessageKey.PARTITIONING, \"Remove tenant partitions not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createTablespace(String tablespaceName, int extentSizeKB) {\n+        warnOnce(MessageKey.TABLESPACE, \"Create tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public boolean doesTableExist(String schemaName, String tableName) {\n+        PostgreSqlDoesTableExist dao = new PostgreSqlDoesTableExist(schemaName, tableName);\n+        return runStatement(dao);\n+    }\n+\n+    @Override\n+    public void createSequence(String schemaName, String sequenceName, int cache) {\n+        /* CREATE SEQUENCE fhir_sequence\n+         *     AS BIGINT\n+         *     START WITH 1\n+         *     CACHE 1000\n+         *     NO CYCLE;\n+        */\n+        // PostgreSql doesn't support CACHE\n+        final String sname = DataDefinitionUtil.getQualifiedName(schemaName, sequenceName);\n+        final String ddl = \"CREATE SEQUENCE \" + sname + \" AS BIGINT START WITH 1 NO CYCLE\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ5MjMxMA==", "bodyText": "done", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411492310", "createdAt": "2020-04-20T15:54:03Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlAdapter.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Supplier;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseTarget;\n+import com.ibm.fhir.database.utils.common.AddForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.common.CommonDatabaseAdapter;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+import com.ibm.fhir.database.utils.model.ColumnBase;\n+import com.ibm.fhir.database.utils.model.ForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.model.IdentityDef;\n+import com.ibm.fhir.database.utils.model.PrimaryKeyDef;\n+import com.ibm.fhir.database.utils.model.Table;\n+\n+/**\n+ * A PostgreSql database target\n+ */\n+public class PostgreSqlAdapter extends CommonDatabaseAdapter {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlAdapter.class.getName());\n+\n+    // Different warning messages we track so that we only have to report them once\n+    private enum MessageKey {\n+        MULTITENANCY, CREATE_VAR, CREATE_PERM, ENABLE_ROW_ACCESS, DISABLE_ROW_ACCESS, PARTITIONING,\n+        ROW_TYPE, ROW_ARR_TYPE, DROP_TYPE, CREATE_PROC, DROP_PROC, TABLESPACE\n+    }\n+\n+    // Just warn once for each unique message key. This cleans up build logs a lot\n+    private static final Set<MessageKey> warned = ConcurrentHashMap.newKeySet();\n+\n+\n+    /**\n+     * Public constructor\n+     * @param tgt the target database we want to manage\n+     */\n+    public PostgreSqlAdapter(IDatabaseTarget tgt) {\n+        super(tgt, new PostgreSqlTranslator());\n+    }\n+\n+    public PostgreSqlAdapter(IConnectionProvider cp) {\n+        super(cp, new PostgreSqlTranslator());\n+    }\n+\n+    public PostgreSqlAdapter() {\n+        super();\n+    }\n+\n+    /**\n+     * Once write each warning message once\n+     * @param msg\n+     */\n+    public void warnOnce(MessageKey messageKey, String msg) {\n+        if (logger.isLoggable(Level.WARNING) && !warned.contains(messageKey)) {\n+            warned.add(messageKey);\n+            logger.warning(\"[ONCE] \" + msg);\n+        }\n+    }\n+\n+    @Override\n+    public void createTable(String schemaName, String name, String tenantColumnName, List<ColumnBase> columns, PrimaryKeyDef primaryKey,\n+            IdentityDef identity, String tablespaceName) {\n+\n+        // PostgreSql doesn't support partitioning, so we ignore tenantColumnName\n+        if (tenantColumnName != null) {\n+            warnOnce(MessageKey.MULTITENANCY, \"PostgreSql does support not multi-tenancy: \" + name);\n+        }\n+\n+        // We also ignore tablespace for PostgreSql\n+        String ddl = buildCreateTableStatement(schemaName, name, columns, primaryKey, identity, null);\n+\n+\n+        runStatement(ddl);\n+    }\n+\n+    @Override\n+    public void createUniqueIndex(String schemaName, String tableName, String indexName, String tenantColumnName, List<String> indexColumns,\n+            List<String> includeColumns) {\n+\n+        // PostgreSql doesn't support include columns, so we just have to create a normal index\n+        createUniqueIndex(schemaName, tableName, indexName, tenantColumnName, indexColumns);\n+    }\n+\n+    @Override\n+    public void createIntVariable(String schemaName, String variableName) {\n+        warnOnce(MessageKey.CREATE_VAR, \"PostgreSql does not support CREATE VARIABLE for: \" + variableName);\n+    }\n+\n+    @Override\n+    public void createOrReplacePermission(String schemaName, String permissionName, String tableName, String predicate) {\n+        warnOnce(MessageKey.CREATE_PERM, \"PostgreSql does not support CREATE PERMISSION for: \" + permissionName);\n+    }\n+\n+    @Override\n+    public void activateRowAccessControl(String schemaName, String tableName) {\n+        warnOnce(MessageKey.ENABLE_ROW_ACCESS, \"PostgreSql does not support ROW ACCESS CONTROL for table: \" + tableName);\n+    }\n+\n+    @Override\n+    public void setIntVariable(String schemaName, String variableName, int value) {\n+        // As this is a runtime issue, we throw as an exception instead of\n+        // simply logging a warning. This shouldn't be called in the case\n+        // of a PostgreSql database\n+        throw new IllegalStateException(\"setIntVariable not supported on PostgreSql for: \" + variableName);\n+    }\n+\n+    @Override\n+    public void deactivateRowAccessControl(String schemaName, String tableName) {\n+        warnOnce(MessageKey.DISABLE_ROW_ACCESS, \"PostgreSql does not support ROW ACCESS CONTROL for table: \" + tableName);\n+    }\n+\n+    @Override\n+    public void createTenantPartitions(Collection<Table> tables, String schemaName, int newTenantId, int extentSizeKB) {\n+        warnOnce(MessageKey.PARTITIONING, \"PostgreSql does not support tenant partitioning\");\n+    }\n+\n+    @Override\n+    public void createRowType(String schemaName, String typeName, List<ColumnBase> columns) {\n+        warnOnce(MessageKey.ROW_TYPE, \"Create row type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createArrType(String schemaName, String typeName, String valueType, int arraySize) {\n+        warnOnce(MessageKey.ROW_ARR_TYPE, \"Create array row type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropType(String schemaName, String typeName) {\n+        warnOnce(MessageKey.DROP_TYPE, \"Drop type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createOrReplaceProcedure(String schemaName, String procedureName, Supplier<String> supplier) {\n+        warnOnce(MessageKey.CREATE_PROC, \"Create procedure not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropProcedure(String schemaName, String procedureName) {\n+        warnOnce(MessageKey.DROP_PROC, \"Drop procedure not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createTablespace(String tablespaceName) {\n+        warnOnce(MessageKey.TABLESPACE, \"Create tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropTablespace(String tablespaceName) {\n+        warnOnce(MessageKey.TABLESPACE, \"Drop tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void detachPartition(String schemaName, String tableName, String partitionName, String newTableName) {\n+        warnOnce(MessageKey.PARTITIONING, \"Detach partition not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void removeTenantPartitions(Collection<Table> tables, String schemaName, int tenantId,\n+            String tenantStagingTable) {\n+        warnOnce(MessageKey.PARTITIONING, \"Remove tenant partitions not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createTablespace(String tablespaceName, int extentSizeKB) {\n+        warnOnce(MessageKey.TABLESPACE, \"Create tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public boolean doesTableExist(String schemaName, String tableName) {\n+        PostgreSqlDoesTableExist dao = new PostgreSqlDoesTableExist(schemaName, tableName);\n+        return runStatement(dao);\n+    }\n+\n+    @Override\n+    public void createSequence(String schemaName, String sequenceName, int cache) {\n+        /* CREATE SEQUENCE fhir_sequence\n+         *     AS BIGINT\n+         *     START WITH 1\n+         *     CACHE 1000\n+         *     NO CYCLE;\n+        */\n+        // PostgreSql doesn't support CACHE\n+        final String sname = DataDefinitionUtil.getQualifiedName(schemaName, sequenceName);\n+        final String ddl = \"CREATE SEQUENCE \" + sname + \" AS BIGINT START WITH 1 NO CYCLE\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxNTg2NA=="}, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 196}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NTkyMDIxOnYy", "diffSide": "RIGHT", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlAdapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoxODoxOFrOGIW1ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNTo1NTowM1rOGIbi2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxNTk3MQ==", "bodyText": "Remove cache line", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411415971", "createdAt": "2020-04-20T14:18:18Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlAdapter.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Supplier;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseTarget;\n+import com.ibm.fhir.database.utils.common.AddForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.common.CommonDatabaseAdapter;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+import com.ibm.fhir.database.utils.model.ColumnBase;\n+import com.ibm.fhir.database.utils.model.ForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.model.IdentityDef;\n+import com.ibm.fhir.database.utils.model.PrimaryKeyDef;\n+import com.ibm.fhir.database.utils.model.Table;\n+\n+/**\n+ * A PostgreSql database target\n+ */\n+public class PostgreSqlAdapter extends CommonDatabaseAdapter {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlAdapter.class.getName());\n+\n+    // Different warning messages we track so that we only have to report them once\n+    private enum MessageKey {\n+        MULTITENANCY, CREATE_VAR, CREATE_PERM, ENABLE_ROW_ACCESS, DISABLE_ROW_ACCESS, PARTITIONING,\n+        ROW_TYPE, ROW_ARR_TYPE, DROP_TYPE, CREATE_PROC, DROP_PROC, TABLESPACE\n+    }\n+\n+    // Just warn once for each unique message key. This cleans up build logs a lot\n+    private static final Set<MessageKey> warned = ConcurrentHashMap.newKeySet();\n+\n+\n+    /**\n+     * Public constructor\n+     * @param tgt the target database we want to manage\n+     */\n+    public PostgreSqlAdapter(IDatabaseTarget tgt) {\n+        super(tgt, new PostgreSqlTranslator());\n+    }\n+\n+    public PostgreSqlAdapter(IConnectionProvider cp) {\n+        super(cp, new PostgreSqlTranslator());\n+    }\n+\n+    public PostgreSqlAdapter() {\n+        super();\n+    }\n+\n+    /**\n+     * Once write each warning message once\n+     * @param msg\n+     */\n+    public void warnOnce(MessageKey messageKey, String msg) {\n+        if (logger.isLoggable(Level.WARNING) && !warned.contains(messageKey)) {\n+            warned.add(messageKey);\n+            logger.warning(\"[ONCE] \" + msg);\n+        }\n+    }\n+\n+    @Override\n+    public void createTable(String schemaName, String name, String tenantColumnName, List<ColumnBase> columns, PrimaryKeyDef primaryKey,\n+            IdentityDef identity, String tablespaceName) {\n+\n+        // PostgreSql doesn't support partitioning, so we ignore tenantColumnName\n+        if (tenantColumnName != null) {\n+            warnOnce(MessageKey.MULTITENANCY, \"PostgreSql does support not multi-tenancy: \" + name);\n+        }\n+\n+        // We also ignore tablespace for PostgreSql\n+        String ddl = buildCreateTableStatement(schemaName, name, columns, primaryKey, identity, null);\n+\n+\n+        runStatement(ddl);\n+    }\n+\n+    @Override\n+    public void createUniqueIndex(String schemaName, String tableName, String indexName, String tenantColumnName, List<String> indexColumns,\n+            List<String> includeColumns) {\n+\n+        // PostgreSql doesn't support include columns, so we just have to create a normal index\n+        createUniqueIndex(schemaName, tableName, indexName, tenantColumnName, indexColumns);\n+    }\n+\n+    @Override\n+    public void createIntVariable(String schemaName, String variableName) {\n+        warnOnce(MessageKey.CREATE_VAR, \"PostgreSql does not support CREATE VARIABLE for: \" + variableName);\n+    }\n+\n+    @Override\n+    public void createOrReplacePermission(String schemaName, String permissionName, String tableName, String predicate) {\n+        warnOnce(MessageKey.CREATE_PERM, \"PostgreSql does not support CREATE PERMISSION for: \" + permissionName);\n+    }\n+\n+    @Override\n+    public void activateRowAccessControl(String schemaName, String tableName) {\n+        warnOnce(MessageKey.ENABLE_ROW_ACCESS, \"PostgreSql does not support ROW ACCESS CONTROL for table: \" + tableName);\n+    }\n+\n+    @Override\n+    public void setIntVariable(String schemaName, String variableName, int value) {\n+        // As this is a runtime issue, we throw as an exception instead of\n+        // simply logging a warning. This shouldn't be called in the case\n+        // of a PostgreSql database\n+        throw new IllegalStateException(\"setIntVariable not supported on PostgreSql for: \" + variableName);\n+    }\n+\n+    @Override\n+    public void deactivateRowAccessControl(String schemaName, String tableName) {\n+        warnOnce(MessageKey.DISABLE_ROW_ACCESS, \"PostgreSql does not support ROW ACCESS CONTROL for table: \" + tableName);\n+    }\n+\n+    @Override\n+    public void createTenantPartitions(Collection<Table> tables, String schemaName, int newTenantId, int extentSizeKB) {\n+        warnOnce(MessageKey.PARTITIONING, \"PostgreSql does not support tenant partitioning\");\n+    }\n+\n+    @Override\n+    public void createRowType(String schemaName, String typeName, List<ColumnBase> columns) {\n+        warnOnce(MessageKey.ROW_TYPE, \"Create row type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createArrType(String schemaName, String typeName, String valueType, int arraySize) {\n+        warnOnce(MessageKey.ROW_ARR_TYPE, \"Create array row type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropType(String schemaName, String typeName) {\n+        warnOnce(MessageKey.DROP_TYPE, \"Drop type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createOrReplaceProcedure(String schemaName, String procedureName, Supplier<String> supplier) {\n+        warnOnce(MessageKey.CREATE_PROC, \"Create procedure not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropProcedure(String schemaName, String procedureName) {\n+        warnOnce(MessageKey.DROP_PROC, \"Drop procedure not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createTablespace(String tablespaceName) {\n+        warnOnce(MessageKey.TABLESPACE, \"Create tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropTablespace(String tablespaceName) {\n+        warnOnce(MessageKey.TABLESPACE, \"Drop tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void detachPartition(String schemaName, String tableName, String partitionName, String newTableName) {\n+        warnOnce(MessageKey.PARTITIONING, \"Detach partition not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void removeTenantPartitions(Collection<Table> tables, String schemaName, int tenantId,\n+            String tenantStagingTable) {\n+        warnOnce(MessageKey.PARTITIONING, \"Remove tenant partitions not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createTablespace(String tablespaceName, int extentSizeKB) {\n+        warnOnce(MessageKey.TABLESPACE, \"Create tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public boolean doesTableExist(String schemaName, String tableName) {\n+        PostgreSqlDoesTableExist dao = new PostgreSqlDoesTableExist(schemaName, tableName);\n+        return runStatement(dao);\n+    }\n+\n+    @Override\n+    public void createSequence(String schemaName, String sequenceName, int cache) {\n+        /* CREATE SEQUENCE fhir_sequence\n+         *     AS BIGINT\n+         *     START WITH 1\n+         *     CACHE 1000", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ5MzA4Mw==", "bodyText": "added cache support to the sql. done", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411493083", "createdAt": "2020-04-20T15:55:03Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlAdapter.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Supplier;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseTarget;\n+import com.ibm.fhir.database.utils.common.AddForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.common.CommonDatabaseAdapter;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+import com.ibm.fhir.database.utils.model.ColumnBase;\n+import com.ibm.fhir.database.utils.model.ForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.model.IdentityDef;\n+import com.ibm.fhir.database.utils.model.PrimaryKeyDef;\n+import com.ibm.fhir.database.utils.model.Table;\n+\n+/**\n+ * A PostgreSql database target\n+ */\n+public class PostgreSqlAdapter extends CommonDatabaseAdapter {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlAdapter.class.getName());\n+\n+    // Different warning messages we track so that we only have to report them once\n+    private enum MessageKey {\n+        MULTITENANCY, CREATE_VAR, CREATE_PERM, ENABLE_ROW_ACCESS, DISABLE_ROW_ACCESS, PARTITIONING,\n+        ROW_TYPE, ROW_ARR_TYPE, DROP_TYPE, CREATE_PROC, DROP_PROC, TABLESPACE\n+    }\n+\n+    // Just warn once for each unique message key. This cleans up build logs a lot\n+    private static final Set<MessageKey> warned = ConcurrentHashMap.newKeySet();\n+\n+\n+    /**\n+     * Public constructor\n+     * @param tgt the target database we want to manage\n+     */\n+    public PostgreSqlAdapter(IDatabaseTarget tgt) {\n+        super(tgt, new PostgreSqlTranslator());\n+    }\n+\n+    public PostgreSqlAdapter(IConnectionProvider cp) {\n+        super(cp, new PostgreSqlTranslator());\n+    }\n+\n+    public PostgreSqlAdapter() {\n+        super();\n+    }\n+\n+    /**\n+     * Once write each warning message once\n+     * @param msg\n+     */\n+    public void warnOnce(MessageKey messageKey, String msg) {\n+        if (logger.isLoggable(Level.WARNING) && !warned.contains(messageKey)) {\n+            warned.add(messageKey);\n+            logger.warning(\"[ONCE] \" + msg);\n+        }\n+    }\n+\n+    @Override\n+    public void createTable(String schemaName, String name, String tenantColumnName, List<ColumnBase> columns, PrimaryKeyDef primaryKey,\n+            IdentityDef identity, String tablespaceName) {\n+\n+        // PostgreSql doesn't support partitioning, so we ignore tenantColumnName\n+        if (tenantColumnName != null) {\n+            warnOnce(MessageKey.MULTITENANCY, \"PostgreSql does support not multi-tenancy: \" + name);\n+        }\n+\n+        // We also ignore tablespace for PostgreSql\n+        String ddl = buildCreateTableStatement(schemaName, name, columns, primaryKey, identity, null);\n+\n+\n+        runStatement(ddl);\n+    }\n+\n+    @Override\n+    public void createUniqueIndex(String schemaName, String tableName, String indexName, String tenantColumnName, List<String> indexColumns,\n+            List<String> includeColumns) {\n+\n+        // PostgreSql doesn't support include columns, so we just have to create a normal index\n+        createUniqueIndex(schemaName, tableName, indexName, tenantColumnName, indexColumns);\n+    }\n+\n+    @Override\n+    public void createIntVariable(String schemaName, String variableName) {\n+        warnOnce(MessageKey.CREATE_VAR, \"PostgreSql does not support CREATE VARIABLE for: \" + variableName);\n+    }\n+\n+    @Override\n+    public void createOrReplacePermission(String schemaName, String permissionName, String tableName, String predicate) {\n+        warnOnce(MessageKey.CREATE_PERM, \"PostgreSql does not support CREATE PERMISSION for: \" + permissionName);\n+    }\n+\n+    @Override\n+    public void activateRowAccessControl(String schemaName, String tableName) {\n+        warnOnce(MessageKey.ENABLE_ROW_ACCESS, \"PostgreSql does not support ROW ACCESS CONTROL for table: \" + tableName);\n+    }\n+\n+    @Override\n+    public void setIntVariable(String schemaName, String variableName, int value) {\n+        // As this is a runtime issue, we throw as an exception instead of\n+        // simply logging a warning. This shouldn't be called in the case\n+        // of a PostgreSql database\n+        throw new IllegalStateException(\"setIntVariable not supported on PostgreSql for: \" + variableName);\n+    }\n+\n+    @Override\n+    public void deactivateRowAccessControl(String schemaName, String tableName) {\n+        warnOnce(MessageKey.DISABLE_ROW_ACCESS, \"PostgreSql does not support ROW ACCESS CONTROL for table: \" + tableName);\n+    }\n+\n+    @Override\n+    public void createTenantPartitions(Collection<Table> tables, String schemaName, int newTenantId, int extentSizeKB) {\n+        warnOnce(MessageKey.PARTITIONING, \"PostgreSql does not support tenant partitioning\");\n+    }\n+\n+    @Override\n+    public void createRowType(String schemaName, String typeName, List<ColumnBase> columns) {\n+        warnOnce(MessageKey.ROW_TYPE, \"Create row type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createArrType(String schemaName, String typeName, String valueType, int arraySize) {\n+        warnOnce(MessageKey.ROW_ARR_TYPE, \"Create array row type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropType(String schemaName, String typeName) {\n+        warnOnce(MessageKey.DROP_TYPE, \"Drop type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createOrReplaceProcedure(String schemaName, String procedureName, Supplier<String> supplier) {\n+        warnOnce(MessageKey.CREATE_PROC, \"Create procedure not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropProcedure(String schemaName, String procedureName) {\n+        warnOnce(MessageKey.DROP_PROC, \"Drop procedure not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createTablespace(String tablespaceName) {\n+        warnOnce(MessageKey.TABLESPACE, \"Create tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropTablespace(String tablespaceName) {\n+        warnOnce(MessageKey.TABLESPACE, \"Drop tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void detachPartition(String schemaName, String tableName, String partitionName, String newTableName) {\n+        warnOnce(MessageKey.PARTITIONING, \"Detach partition not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void removeTenantPartitions(Collection<Table> tables, String schemaName, int tenantId,\n+            String tenantStagingTable) {\n+        warnOnce(MessageKey.PARTITIONING, \"Remove tenant partitions not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createTablespace(String tablespaceName, int extentSizeKB) {\n+        warnOnce(MessageKey.TABLESPACE, \"Create tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public boolean doesTableExist(String schemaName, String tableName) {\n+        PostgreSqlDoesTableExist dao = new PostgreSqlDoesTableExist(schemaName, tableName);\n+        return runStatement(dao);\n+    }\n+\n+    @Override\n+    public void createSequence(String schemaName, String sequenceName, int cache) {\n+        /* CREATE SEQUENCE fhir_sequence\n+         *     AS BIGINT\n+         *     START WITH 1\n+         *     CACHE 1000", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxNTk3MQ=="}, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 191}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NTkyMTQ1OnYy", "diffSide": "RIGHT", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlAdapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoxODozMFrOGIW2WQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNTo1NTozM1rOGIbkjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxNjE1Mw==", "bodyText": "move to 1000  per following comments", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411416153", "createdAt": "2020-04-20T14:18:30Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlAdapter.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Supplier;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseTarget;\n+import com.ibm.fhir.database.utils.common.AddForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.common.CommonDatabaseAdapter;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+import com.ibm.fhir.database.utils.model.ColumnBase;\n+import com.ibm.fhir.database.utils.model.ForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.model.IdentityDef;\n+import com.ibm.fhir.database.utils.model.PrimaryKeyDef;\n+import com.ibm.fhir.database.utils.model.Table;\n+\n+/**\n+ * A PostgreSql database target\n+ */\n+public class PostgreSqlAdapter extends CommonDatabaseAdapter {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlAdapter.class.getName());\n+\n+    // Different warning messages we track so that we only have to report them once\n+    private enum MessageKey {\n+        MULTITENANCY, CREATE_VAR, CREATE_PERM, ENABLE_ROW_ACCESS, DISABLE_ROW_ACCESS, PARTITIONING,\n+        ROW_TYPE, ROW_ARR_TYPE, DROP_TYPE, CREATE_PROC, DROP_PROC, TABLESPACE\n+    }\n+\n+    // Just warn once for each unique message key. This cleans up build logs a lot\n+    private static final Set<MessageKey> warned = ConcurrentHashMap.newKeySet();\n+\n+\n+    /**\n+     * Public constructor\n+     * @param tgt the target database we want to manage\n+     */\n+    public PostgreSqlAdapter(IDatabaseTarget tgt) {\n+        super(tgt, new PostgreSqlTranslator());\n+    }\n+\n+    public PostgreSqlAdapter(IConnectionProvider cp) {\n+        super(cp, new PostgreSqlTranslator());\n+    }\n+\n+    public PostgreSqlAdapter() {\n+        super();\n+    }\n+\n+    /**\n+     * Once write each warning message once\n+     * @param msg\n+     */\n+    public void warnOnce(MessageKey messageKey, String msg) {\n+        if (logger.isLoggable(Level.WARNING) && !warned.contains(messageKey)) {\n+            warned.add(messageKey);\n+            logger.warning(\"[ONCE] \" + msg);\n+        }\n+    }\n+\n+    @Override\n+    public void createTable(String schemaName, String name, String tenantColumnName, List<ColumnBase> columns, PrimaryKeyDef primaryKey,\n+            IdentityDef identity, String tablespaceName) {\n+\n+        // PostgreSql doesn't support partitioning, so we ignore tenantColumnName\n+        if (tenantColumnName != null) {\n+            warnOnce(MessageKey.MULTITENANCY, \"PostgreSql does support not multi-tenancy: \" + name);\n+        }\n+\n+        // We also ignore tablespace for PostgreSql\n+        String ddl = buildCreateTableStatement(schemaName, name, columns, primaryKey, identity, null);\n+\n+\n+        runStatement(ddl);\n+    }\n+\n+    @Override\n+    public void createUniqueIndex(String schemaName, String tableName, String indexName, String tenantColumnName, List<String> indexColumns,\n+            List<String> includeColumns) {\n+\n+        // PostgreSql doesn't support include columns, so we just have to create a normal index\n+        createUniqueIndex(schemaName, tableName, indexName, tenantColumnName, indexColumns);\n+    }\n+\n+    @Override\n+    public void createIntVariable(String schemaName, String variableName) {\n+        warnOnce(MessageKey.CREATE_VAR, \"PostgreSql does not support CREATE VARIABLE for: \" + variableName);\n+    }\n+\n+    @Override\n+    public void createOrReplacePermission(String schemaName, String permissionName, String tableName, String predicate) {\n+        warnOnce(MessageKey.CREATE_PERM, \"PostgreSql does not support CREATE PERMISSION for: \" + permissionName);\n+    }\n+\n+    @Override\n+    public void activateRowAccessControl(String schemaName, String tableName) {\n+        warnOnce(MessageKey.ENABLE_ROW_ACCESS, \"PostgreSql does not support ROW ACCESS CONTROL for table: \" + tableName);\n+    }\n+\n+    @Override\n+    public void setIntVariable(String schemaName, String variableName, int value) {\n+        // As this is a runtime issue, we throw as an exception instead of\n+        // simply logging a warning. This shouldn't be called in the case\n+        // of a PostgreSql database\n+        throw new IllegalStateException(\"setIntVariable not supported on PostgreSql for: \" + variableName);\n+    }\n+\n+    @Override\n+    public void deactivateRowAccessControl(String schemaName, String tableName) {\n+        warnOnce(MessageKey.DISABLE_ROW_ACCESS, \"PostgreSql does not support ROW ACCESS CONTROL for table: \" + tableName);\n+    }\n+\n+    @Override\n+    public void createTenantPartitions(Collection<Table> tables, String schemaName, int newTenantId, int extentSizeKB) {\n+        warnOnce(MessageKey.PARTITIONING, \"PostgreSql does not support tenant partitioning\");\n+    }\n+\n+    @Override\n+    public void createRowType(String schemaName, String typeName, List<ColumnBase> columns) {\n+        warnOnce(MessageKey.ROW_TYPE, \"Create row type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createArrType(String schemaName, String typeName, String valueType, int arraySize) {\n+        warnOnce(MessageKey.ROW_ARR_TYPE, \"Create array row type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropType(String schemaName, String typeName) {\n+        warnOnce(MessageKey.DROP_TYPE, \"Drop type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createOrReplaceProcedure(String schemaName, String procedureName, Supplier<String> supplier) {\n+        warnOnce(MessageKey.CREATE_PROC, \"Create procedure not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropProcedure(String schemaName, String procedureName) {\n+        warnOnce(MessageKey.DROP_PROC, \"Drop procedure not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createTablespace(String tablespaceName) {\n+        warnOnce(MessageKey.TABLESPACE, \"Create tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropTablespace(String tablespaceName) {\n+        warnOnce(MessageKey.TABLESPACE, \"Drop tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void detachPartition(String schemaName, String tableName, String partitionName, String newTableName) {\n+        warnOnce(MessageKey.PARTITIONING, \"Detach partition not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void removeTenantPartitions(Collection<Table> tables, String schemaName, int tenantId,\n+            String tenantStagingTable) {\n+        warnOnce(MessageKey.PARTITIONING, \"Remove tenant partitions not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createTablespace(String tablespaceName, int extentSizeKB) {\n+        warnOnce(MessageKey.TABLESPACE, \"Create tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public boolean doesTableExist(String schemaName, String tableName) {\n+        PostgreSqlDoesTableExist dao = new PostgreSqlDoesTableExist(schemaName, tableName);\n+        return runStatement(dao);\n+    }\n+\n+    @Override\n+    public void createSequence(String schemaName, String sequenceName, int cache) {\n+        /* CREATE SEQUENCE fhir_sequence\n+         *     AS BIGINT\n+         *     START WITH 1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ5MzUxOQ==", "bodyText": "done", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411493519", "createdAt": "2020-04-20T15:55:33Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlAdapter.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Supplier;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseTarget;\n+import com.ibm.fhir.database.utils.common.AddForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.common.CommonDatabaseAdapter;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+import com.ibm.fhir.database.utils.model.ColumnBase;\n+import com.ibm.fhir.database.utils.model.ForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.model.IdentityDef;\n+import com.ibm.fhir.database.utils.model.PrimaryKeyDef;\n+import com.ibm.fhir.database.utils.model.Table;\n+\n+/**\n+ * A PostgreSql database target\n+ */\n+public class PostgreSqlAdapter extends CommonDatabaseAdapter {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlAdapter.class.getName());\n+\n+    // Different warning messages we track so that we only have to report them once\n+    private enum MessageKey {\n+        MULTITENANCY, CREATE_VAR, CREATE_PERM, ENABLE_ROW_ACCESS, DISABLE_ROW_ACCESS, PARTITIONING,\n+        ROW_TYPE, ROW_ARR_TYPE, DROP_TYPE, CREATE_PROC, DROP_PROC, TABLESPACE\n+    }\n+\n+    // Just warn once for each unique message key. This cleans up build logs a lot\n+    private static final Set<MessageKey> warned = ConcurrentHashMap.newKeySet();\n+\n+\n+    /**\n+     * Public constructor\n+     * @param tgt the target database we want to manage\n+     */\n+    public PostgreSqlAdapter(IDatabaseTarget tgt) {\n+        super(tgt, new PostgreSqlTranslator());\n+    }\n+\n+    public PostgreSqlAdapter(IConnectionProvider cp) {\n+        super(cp, new PostgreSqlTranslator());\n+    }\n+\n+    public PostgreSqlAdapter() {\n+        super();\n+    }\n+\n+    /**\n+     * Once write each warning message once\n+     * @param msg\n+     */\n+    public void warnOnce(MessageKey messageKey, String msg) {\n+        if (logger.isLoggable(Level.WARNING) && !warned.contains(messageKey)) {\n+            warned.add(messageKey);\n+            logger.warning(\"[ONCE] \" + msg);\n+        }\n+    }\n+\n+    @Override\n+    public void createTable(String schemaName, String name, String tenantColumnName, List<ColumnBase> columns, PrimaryKeyDef primaryKey,\n+            IdentityDef identity, String tablespaceName) {\n+\n+        // PostgreSql doesn't support partitioning, so we ignore tenantColumnName\n+        if (tenantColumnName != null) {\n+            warnOnce(MessageKey.MULTITENANCY, \"PostgreSql does support not multi-tenancy: \" + name);\n+        }\n+\n+        // We also ignore tablespace for PostgreSql\n+        String ddl = buildCreateTableStatement(schemaName, name, columns, primaryKey, identity, null);\n+\n+\n+        runStatement(ddl);\n+    }\n+\n+    @Override\n+    public void createUniqueIndex(String schemaName, String tableName, String indexName, String tenantColumnName, List<String> indexColumns,\n+            List<String> includeColumns) {\n+\n+        // PostgreSql doesn't support include columns, so we just have to create a normal index\n+        createUniqueIndex(schemaName, tableName, indexName, tenantColumnName, indexColumns);\n+    }\n+\n+    @Override\n+    public void createIntVariable(String schemaName, String variableName) {\n+        warnOnce(MessageKey.CREATE_VAR, \"PostgreSql does not support CREATE VARIABLE for: \" + variableName);\n+    }\n+\n+    @Override\n+    public void createOrReplacePermission(String schemaName, String permissionName, String tableName, String predicate) {\n+        warnOnce(MessageKey.CREATE_PERM, \"PostgreSql does not support CREATE PERMISSION for: \" + permissionName);\n+    }\n+\n+    @Override\n+    public void activateRowAccessControl(String schemaName, String tableName) {\n+        warnOnce(MessageKey.ENABLE_ROW_ACCESS, \"PostgreSql does not support ROW ACCESS CONTROL for table: \" + tableName);\n+    }\n+\n+    @Override\n+    public void setIntVariable(String schemaName, String variableName, int value) {\n+        // As this is a runtime issue, we throw as an exception instead of\n+        // simply logging a warning. This shouldn't be called in the case\n+        // of a PostgreSql database\n+        throw new IllegalStateException(\"setIntVariable not supported on PostgreSql for: \" + variableName);\n+    }\n+\n+    @Override\n+    public void deactivateRowAccessControl(String schemaName, String tableName) {\n+        warnOnce(MessageKey.DISABLE_ROW_ACCESS, \"PostgreSql does not support ROW ACCESS CONTROL for table: \" + tableName);\n+    }\n+\n+    @Override\n+    public void createTenantPartitions(Collection<Table> tables, String schemaName, int newTenantId, int extentSizeKB) {\n+        warnOnce(MessageKey.PARTITIONING, \"PostgreSql does not support tenant partitioning\");\n+    }\n+\n+    @Override\n+    public void createRowType(String schemaName, String typeName, List<ColumnBase> columns) {\n+        warnOnce(MessageKey.ROW_TYPE, \"Create row type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createArrType(String schemaName, String typeName, String valueType, int arraySize) {\n+        warnOnce(MessageKey.ROW_ARR_TYPE, \"Create array row type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropType(String schemaName, String typeName) {\n+        warnOnce(MessageKey.DROP_TYPE, \"Drop type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createOrReplaceProcedure(String schemaName, String procedureName, Supplier<String> supplier) {\n+        warnOnce(MessageKey.CREATE_PROC, \"Create procedure not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropProcedure(String schemaName, String procedureName) {\n+        warnOnce(MessageKey.DROP_PROC, \"Drop procedure not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createTablespace(String tablespaceName) {\n+        warnOnce(MessageKey.TABLESPACE, \"Create tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropTablespace(String tablespaceName) {\n+        warnOnce(MessageKey.TABLESPACE, \"Drop tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void detachPartition(String schemaName, String tableName, String partitionName, String newTableName) {\n+        warnOnce(MessageKey.PARTITIONING, \"Detach partition not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void removeTenantPartitions(Collection<Table> tables, String schemaName, int tenantId,\n+            String tenantStagingTable) {\n+        warnOnce(MessageKey.PARTITIONING, \"Remove tenant partitions not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createTablespace(String tablespaceName, int extentSizeKB) {\n+        warnOnce(MessageKey.TABLESPACE, \"Create tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public boolean doesTableExist(String schemaName, String tableName) {\n+        PostgreSqlDoesTableExist dao = new PostgreSqlDoesTableExist(schemaName, tableName);\n+        return runStatement(dao);\n+    }\n+\n+    @Override\n+    public void createSequence(String schemaName, String sequenceName, int cache) {\n+        /* CREATE SEQUENCE fhir_sequence\n+         *     AS BIGINT\n+         *     START WITH 1", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxNjE1Mw=="}, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 190}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NTkyOTA1OnYy", "diffSide": "RIGHT", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlDoesTableExist.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoyMDowM1rOGIW7JA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoyMDowM1rOGIW7JA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxNzM4MA==", "bodyText": "remove line\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411417380", "createdAt": "2020-04-20T14:20:03Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlDoesTableExist.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.database.utils.api.IDatabaseSupplier;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+\n+/**\n+ * For this implementation we simply run a select against the table\n+ * and see if it kicks back with an error (which isn't related to\n+ * connection failure).\n+ */\n+public class PostgreSqlDoesTableExist implements IDatabaseSupplier<Boolean> {\n+\n+    // The schema of the table\n+    private final String schemaName;\n+\n+    // The name of the table\n+    private final String tableName;\n+\n+    /**\n+     * Public constructor\n+     * @param schemaName\n+     * @param tableName\n+     */\n+    public PostgreSqlDoesTableExist(String schemaName, String tableName) {\n+        this.schemaName = DataDefinitionUtil.assertValidName(schemaName);\n+        this.tableName = DataDefinitionUtil.assertValidName(tableName);\n+    }\n+\n+    @Override\n+    public Boolean run(IDatabaseTranslator translator, Connection c) {\n+        Boolean result;\n+        // For PostgreSQL, identifier names are always in lowercase unless they are surround with double quotes.\n+        final String sql = \"SELECT EXISTS (\" +\n+                \"SELECT FROM information_schema.tables \" +\n+                \"WHERE  LOWER(table_schema) = LOWER('\" + schemaName +\n+                \"') AND LOWER(table_name) = LOWER('\" + tableName + \"'))\";\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NTkzMzkwOnYy", "diffSide": "RIGHT", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlDoesTableExist.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoyMTowNFrOGIW-Jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoyMTowNFrOGIW-Jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxODE1MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        }\n          \n          \n            \n                        else {\n          \n          \n            \n                        } else {", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411418150", "createdAt": "2020-04-20T14:21:04Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlDoesTableExist.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.database.utils.api.IDatabaseSupplier;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+\n+/**\n+ * For this implementation we simply run a select against the table\n+ * and see if it kicks back with an error (which isn't related to\n+ * connection failure).\n+ */\n+public class PostgreSqlDoesTableExist implements IDatabaseSupplier<Boolean> {\n+\n+    // The schema of the table\n+    private final String schemaName;\n+\n+    // The name of the table\n+    private final String tableName;\n+\n+    /**\n+     * Public constructor\n+     * @param schemaName\n+     * @param tableName\n+     */\n+    public PostgreSqlDoesTableExist(String schemaName, String tableName) {\n+        this.schemaName = DataDefinitionUtil.assertValidName(schemaName);\n+        this.tableName = DataDefinitionUtil.assertValidName(tableName);\n+    }\n+\n+    @Override\n+    public Boolean run(IDatabaseTranslator translator, Connection c) {\n+        Boolean result;\n+        // For PostgreSQL, identifier names are always in lowercase unless they are surround with double quotes.\n+        final String sql = \"SELECT EXISTS (\" +\n+                \"SELECT FROM information_schema.tables \" +\n+                \"WHERE  LOWER(table_schema) = LOWER('\" + schemaName +\n+                \"') AND LOWER(table_name) = LOWER('\" + tableName + \"'))\";\n+\n+\n+        try (PreparedStatement ps = c.prepareStatement(sql)) {\n+            ResultSet rs = ps.executeQuery();\n+            if (rs.next()) {\n+                result = rs.getBoolean(1);\n+            }\n+            else {\n+                result = false;\n+            }\n+        }\n+        catch (SQLException x) {\n+            if (translator.isConnectionError(x)) {\n+                throw translator.translate(x);\n+            }\n+            else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NTkzNTA3OnYy", "diffSide": "RIGHT", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlDoesTableExist.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoyMToxNlrOGIW-4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoyMjozOVrOGIXDaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxODMzNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        }\n          \n          \n            \n                        else {\n          \n          \n            \n                            result = false;\n          \n          \n            \n                        } else {\n          \n          \n            \n                            result = false;", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411418337", "createdAt": "2020-04-20T14:21:16Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlDoesTableExist.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.database.utils.api.IDatabaseSupplier;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+\n+/**\n+ * For this implementation we simply run a select against the table\n+ * and see if it kicks back with an error (which isn't related to\n+ * connection failure).\n+ */\n+public class PostgreSqlDoesTableExist implements IDatabaseSupplier<Boolean> {\n+\n+    // The schema of the table\n+    private final String schemaName;\n+\n+    // The name of the table\n+    private final String tableName;\n+\n+    /**\n+     * Public constructor\n+     * @param schemaName\n+     * @param tableName\n+     */\n+    public PostgreSqlDoesTableExist(String schemaName, String tableName) {\n+        this.schemaName = DataDefinitionUtil.assertValidName(schemaName);\n+        this.tableName = DataDefinitionUtil.assertValidName(tableName);\n+    }\n+\n+    @Override\n+    public Boolean run(IDatabaseTranslator translator, Connection c) {\n+        Boolean result;\n+        // For PostgreSQL, identifier names are always in lowercase unless they are surround with double quotes.\n+        final String sql = \"SELECT EXISTS (\" +\n+                \"SELECT FROM information_schema.tables \" +\n+                \"WHERE  LOWER(table_schema) = LOWER('\" + schemaName +\n+                \"') AND LOWER(table_name) = LOWER('\" + tableName + \"'))\";\n+\n+\n+        try (PreparedStatement ps = c.prepareStatement(sql)) {\n+            ResultSet rs = ps.executeQuery();\n+            if (rs.next()) {\n+                result = rs.getBoolean(1);\n+            }\n+            else {\n+                result = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxOTQ5Ng==", "bodyText": "this else is the one which can be avoided with a declaration of a default outcome to Boolean result;", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411419496", "createdAt": "2020-04-20T14:22:39Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlDoesTableExist.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.database.utils.api.IDatabaseSupplier;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+\n+/**\n+ * For this implementation we simply run a select against the table\n+ * and see if it kicks back with an error (which isn't related to\n+ * connection failure).\n+ */\n+public class PostgreSqlDoesTableExist implements IDatabaseSupplier<Boolean> {\n+\n+    // The schema of the table\n+    private final String schemaName;\n+\n+    // The name of the table\n+    private final String tableName;\n+\n+    /**\n+     * Public constructor\n+     * @param schemaName\n+     * @param tableName\n+     */\n+    public PostgreSqlDoesTableExist(String schemaName, String tableName) {\n+        this.schemaName = DataDefinitionUtil.assertValidName(schemaName);\n+        this.tableName = DataDefinitionUtil.assertValidName(tableName);\n+    }\n+\n+    @Override\n+    public Boolean run(IDatabaseTranslator translator, Connection c) {\n+        Boolean result;\n+        // For PostgreSQL, identifier names are always in lowercase unless they are surround with double quotes.\n+        final String sql = \"SELECT EXISTS (\" +\n+                \"SELECT FROM information_schema.tables \" +\n+                \"WHERE  LOWER(table_schema) = LOWER('\" + schemaName +\n+                \"') AND LOWER(table_name) = LOWER('\" + tableName + \"'))\";\n+\n+\n+        try (PreparedStatement ps = c.prepareStatement(sql)) {\n+            ResultSet rs = ps.executeQuery();\n+            if (rs.next()) {\n+                result = rs.getBoolean(1);\n+            }\n+            else {\n+                result = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxODMzNw=="}, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NTkzOTYxOnYy", "diffSide": "RIGHT", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlDoesTableExist.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoyMTo1N1rOGIXBZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNTo1ODo1MlrOGIbu4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxODk4Mw==", "bodyText": "you can set to Boolean.False here, and avoid an extra branch down below.", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411418983", "createdAt": "2020-04-20T14:21:57Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlDoesTableExist.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.database.utils.api.IDatabaseSupplier;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+\n+/**\n+ * For this implementation we simply run a select against the table\n+ * and see if it kicks back with an error (which isn't related to\n+ * connection failure).\n+ */\n+public class PostgreSqlDoesTableExist implements IDatabaseSupplier<Boolean> {\n+\n+    // The schema of the table\n+    private final String schemaName;\n+\n+    // The name of the table\n+    private final String tableName;\n+\n+    /**\n+     * Public constructor\n+     * @param schemaName\n+     * @param tableName\n+     */\n+    public PostgreSqlDoesTableExist(String schemaName, String tableName) {\n+        this.schemaName = DataDefinitionUtil.assertValidName(schemaName);\n+        this.tableName = DataDefinitionUtil.assertValidName(tableName);\n+    }\n+\n+    @Override\n+    public Boolean run(IDatabaseTranslator translator, Connection c) {\n+        Boolean result;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ5NjE2Mw==", "bodyText": "just followed the old codes pattern, make sense to change. done", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411496163", "createdAt": "2020-04-20T15:58:52Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlDoesTableExist.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.database.utils.api.IDatabaseSupplier;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+\n+/**\n+ * For this implementation we simply run a select against the table\n+ * and see if it kicks back with an error (which isn't related to\n+ * connection failure).\n+ */\n+public class PostgreSqlDoesTableExist implements IDatabaseSupplier<Boolean> {\n+\n+    // The schema of the table\n+    private final String schemaName;\n+\n+    // The name of the table\n+    private final String tableName;\n+\n+    /**\n+     * Public constructor\n+     * @param schemaName\n+     * @param tableName\n+     */\n+    public PostgreSqlDoesTableExist(String schemaName, String tableName) {\n+        this.schemaName = DataDefinitionUtil.assertValidName(schemaName);\n+        this.tableName = DataDefinitionUtil.assertValidName(tableName);\n+    }\n+\n+    @Override\n+    public Boolean run(IDatabaseTranslator translator, Connection c) {\n+        Boolean result;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxODk4Mw=="}, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NTk1MTUxOnYy", "diffSide": "RIGHT", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlTranslator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoyNDoxOFrOGIXIeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoyNDo0M1rOGIXJvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyMDc5NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // Class Code 23: Constraint Violation\n          \n          \n            \n                    // Class Code 23: Constraint Violation\n          \n          \n            \n                    // Refer to https://www.postgresql.org/docs/12/errcodes-appendix.html for more detail\n          \n      \n    \n    \n  \n\nI always want to know more, the link will help me (since I'm new )", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411420794", "createdAt": "2020-04-20T14:24:18Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlTranslator.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.sql.SQLException;\n+import java.util.Properties;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.ConnectionDetails;\n+import com.ibm.fhir.database.utils.api.ConnectionException;\n+import com.ibm.fhir.database.utils.api.DataAccessException;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.database.utils.api.LockException;\n+import com.ibm.fhir.database.utils.api.UndefinedNameException;\n+import com.ibm.fhir.database.utils.api.UniqueConstraintViolationException;\n+\n+/**\n+ * translates database access to PostgreSql supported access.\n+ */\n+public class PostgreSqlTranslator implements IDatabaseTranslator {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlTranslator.class.getName());\n+\n+    @Override\n+    public String addForUpdate(String sql) {\n+        return sql + \" FOR UPDATE\";\n+    }\n+\n+    @Override\n+    public boolean isDerby() {\n+        return false;\n+    }\n+\n+    @Override\n+    public String globalTempTableName(String tableName) {\n+        return \"SYSTEM.\" + tableName;\n+    }\n+\n+    @Override\n+    public String createGlobalTempTable(String ddl) {\n+        return \"DECLARE \" + ddl;\n+    }\n+\n+    @Override\n+    public boolean isDuplicate(SQLException x) {\n+        // Class Code 23: Constraint Violation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyMTExOA==", "bodyText": "It could be referenced at the top of the class.", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411421118", "createdAt": "2020-04-20T14:24:43Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlTranslator.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.sql.SQLException;\n+import java.util.Properties;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.ConnectionDetails;\n+import com.ibm.fhir.database.utils.api.ConnectionException;\n+import com.ibm.fhir.database.utils.api.DataAccessException;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.database.utils.api.LockException;\n+import com.ibm.fhir.database.utils.api.UndefinedNameException;\n+import com.ibm.fhir.database.utils.api.UniqueConstraintViolationException;\n+\n+/**\n+ * translates database access to PostgreSql supported access.\n+ */\n+public class PostgreSqlTranslator implements IDatabaseTranslator {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlTranslator.class.getName());\n+\n+    @Override\n+    public String addForUpdate(String sql) {\n+        return sql + \" FOR UPDATE\";\n+    }\n+\n+    @Override\n+    public boolean isDerby() {\n+        return false;\n+    }\n+\n+    @Override\n+    public String globalTempTableName(String tableName) {\n+        return \"SYSTEM.\" + tableName;\n+    }\n+\n+    @Override\n+    public String createGlobalTempTable(String ddl) {\n+        return \"DECLARE \" + ddl;\n+    }\n+\n+    @Override\n+    public boolean isDuplicate(SQLException x) {\n+        // Class Code 23: Constraint Violation", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyMDc5NA=="}, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NTk1Nzk3OnYy", "diffSide": "RIGHT", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlTranslator.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoyNTozM1rOGIXMgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0NzozOFrOGIYQHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyMTgyNg==", "bodyText": "do we ever need to pass other properties in? How do we handle in Derby and Db2?", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411421826", "createdAt": "2020-04-20T14:25:33Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlTranslator.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.sql.SQLException;\n+import java.util.Properties;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.ConnectionDetails;\n+import com.ibm.fhir.database.utils.api.ConnectionException;\n+import com.ibm.fhir.database.utils.api.DataAccessException;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.database.utils.api.LockException;\n+import com.ibm.fhir.database.utils.api.UndefinedNameException;\n+import com.ibm.fhir.database.utils.api.UniqueConstraintViolationException;\n+\n+/**\n+ * translates database access to PostgreSql supported access.\n+ */\n+public class PostgreSqlTranslator implements IDatabaseTranslator {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlTranslator.class.getName());\n+\n+    @Override\n+    public String addForUpdate(String sql) {\n+        return sql + \" FOR UPDATE\";\n+    }\n+\n+    @Override\n+    public boolean isDerby() {\n+        return false;\n+    }\n+\n+    @Override\n+    public String globalTempTableName(String tableName) {\n+        return \"SYSTEM.\" + tableName;\n+    }\n+\n+    @Override\n+    public String createGlobalTempTable(String ddl) {\n+        return \"DECLARE \" + ddl;\n+    }\n+\n+    @Override\n+    public boolean isDuplicate(SQLException x) {\n+        // Class Code 23: Constraint Violation\n+        return \"23505\".equals(x.getSQLState());\n+    }\n+\n+    @Override\n+    public boolean isAlreadyExists(SQLException x) {\n+        return \"42710\".equals(x.getSQLState());\n+    }\n+\n+    @Override\n+    public boolean isLockTimeout(SQLException x) {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isDeadlock(SQLException x) {\n+        final String sqlState = x.getSQLState();\n+        return \"40XL1\".equals(sqlState) || \"40XL2\".equals(sqlState);\n+    }\n+\n+    @Override\n+    public boolean isConnectionError(SQLException x) {\n+        String sqlState = x.getSQLState();\n+        return sqlState != null && sqlState.startsWith(\"08\");\n+    }\n+\n+    @Override\n+    public DataAccessException translate(SQLException x) {\n+        if (isDeadlock(x)) {\n+            return new LockException(x, true);\n+        }\n+        else if (isLockTimeout(x)) {\n+            return new LockException(x, false);\n+        }\n+        else if (isConnectionError(x)) {\n+            return new ConnectionException(x);\n+        }\n+        else if (isDuplicate(x)) {\n+            return new UniqueConstraintViolationException(x);\n+        }\n+        else if (isUndefinedName(x)) {\n+            return new UndefinedNameException(x);\n+        }\n+        else {\n+            return new DataAccessException(x);\n+        }\n+    }\n+\n+    @Override\n+    public boolean isUndefinedName(SQLException x) {\n+        return \"42X05\".equals(x.getSQLState());\n+    }\n+\n+    @Override\n+    public void fillProperties(Properties p, ConnectionDetails cd) {\n+        p.put(\"user\", cd.getUser());\n+        p.put(\"password\", cd.getPassword());\n+\n+        if (cd.isSsl()) {\n+            p.put(\"sslConnection\", \"true\");\n+        }\n+\n+        if (cd.isHA()) {\n+            logger.warning(\"No HA support for PostgreSql\");\n+        }\n+    }\n+\n+    @Override\n+    public String timestampDiff(String left, String right, String alias) {\n+        if (alias == null || alias.isEmpty()) {\n+            return String.format(\"{fn timestampdiff(SQL_TSI_SECOND, %s, %s)}\", left, right);\n+        }\n+        else {\n+            return String.format(\"{fn timestampdiff(SQL_TSI_SECOND, %s, %s)} AS %s\", left, right, alias);\n+        }\n+    }\n+\n+    @Override\n+    public String createSequence(String name, int cache) {\n+        // cache isn't supported by PostgreSql\n+        return \"CREATE SEQUENCE \" + name;\n+    }\n+\n+    @Override\n+    public String reorgTableCommand(String tableName) {\n+        // REORG TABLE not supported by PostgreSql\n+        throw new UnsupportedOperationException(\"reorg table is not supported!\");\n+    }\n+\n+    @Override\n+    public String getDriverClassName() {\n+        return \"org.postgresql.Driver\";\n+    }\n+\n+    @Override\n+    public String getUrl(Properties connectionProperties) {\n+        PostgreSqlPropertyAdapter adapter = new PostgreSqlPropertyAdapter(connectionProperties);\n+\n+        return \"jdbc:postgresql://\" + adapter.getHost() + \":\" + adapter.getPort() + \"/\" + adapter.getDatabase();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzNTk5Ng==", "bodyText": "similar in derby and db2, for db2, it uses more properties to support dashdb.", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411435996", "createdAt": "2020-04-20T14:43:34Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlTranslator.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.sql.SQLException;\n+import java.util.Properties;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.ConnectionDetails;\n+import com.ibm.fhir.database.utils.api.ConnectionException;\n+import com.ibm.fhir.database.utils.api.DataAccessException;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.database.utils.api.LockException;\n+import com.ibm.fhir.database.utils.api.UndefinedNameException;\n+import com.ibm.fhir.database.utils.api.UniqueConstraintViolationException;\n+\n+/**\n+ * translates database access to PostgreSql supported access.\n+ */\n+public class PostgreSqlTranslator implements IDatabaseTranslator {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlTranslator.class.getName());\n+\n+    @Override\n+    public String addForUpdate(String sql) {\n+        return sql + \" FOR UPDATE\";\n+    }\n+\n+    @Override\n+    public boolean isDerby() {\n+        return false;\n+    }\n+\n+    @Override\n+    public String globalTempTableName(String tableName) {\n+        return \"SYSTEM.\" + tableName;\n+    }\n+\n+    @Override\n+    public String createGlobalTempTable(String ddl) {\n+        return \"DECLARE \" + ddl;\n+    }\n+\n+    @Override\n+    public boolean isDuplicate(SQLException x) {\n+        // Class Code 23: Constraint Violation\n+        return \"23505\".equals(x.getSQLState());\n+    }\n+\n+    @Override\n+    public boolean isAlreadyExists(SQLException x) {\n+        return \"42710\".equals(x.getSQLState());\n+    }\n+\n+    @Override\n+    public boolean isLockTimeout(SQLException x) {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isDeadlock(SQLException x) {\n+        final String sqlState = x.getSQLState();\n+        return \"40XL1\".equals(sqlState) || \"40XL2\".equals(sqlState);\n+    }\n+\n+    @Override\n+    public boolean isConnectionError(SQLException x) {\n+        String sqlState = x.getSQLState();\n+        return sqlState != null && sqlState.startsWith(\"08\");\n+    }\n+\n+    @Override\n+    public DataAccessException translate(SQLException x) {\n+        if (isDeadlock(x)) {\n+            return new LockException(x, true);\n+        }\n+        else if (isLockTimeout(x)) {\n+            return new LockException(x, false);\n+        }\n+        else if (isConnectionError(x)) {\n+            return new ConnectionException(x);\n+        }\n+        else if (isDuplicate(x)) {\n+            return new UniqueConstraintViolationException(x);\n+        }\n+        else if (isUndefinedName(x)) {\n+            return new UndefinedNameException(x);\n+        }\n+        else {\n+            return new DataAccessException(x);\n+        }\n+    }\n+\n+    @Override\n+    public boolean isUndefinedName(SQLException x) {\n+        return \"42X05\".equals(x.getSQLState());\n+    }\n+\n+    @Override\n+    public void fillProperties(Properties p, ConnectionDetails cd) {\n+        p.put(\"user\", cd.getUser());\n+        p.put(\"password\", cd.getPassword());\n+\n+        if (cd.isSsl()) {\n+            p.put(\"sslConnection\", \"true\");\n+        }\n+\n+        if (cd.isHA()) {\n+            logger.warning(\"No HA support for PostgreSql\");\n+        }\n+    }\n+\n+    @Override\n+    public String timestampDiff(String left, String right, String alias) {\n+        if (alias == null || alias.isEmpty()) {\n+            return String.format(\"{fn timestampdiff(SQL_TSI_SECOND, %s, %s)}\", left, right);\n+        }\n+        else {\n+            return String.format(\"{fn timestampdiff(SQL_TSI_SECOND, %s, %s)} AS %s\", left, right, alias);\n+        }\n+    }\n+\n+    @Override\n+    public String createSequence(String name, int cache) {\n+        // cache isn't supported by PostgreSql\n+        return \"CREATE SEQUENCE \" + name;\n+    }\n+\n+    @Override\n+    public String reorgTableCommand(String tableName) {\n+        // REORG TABLE not supported by PostgreSql\n+        throw new UnsupportedOperationException(\"reorg table is not supported!\");\n+    }\n+\n+    @Override\n+    public String getDriverClassName() {\n+        return \"org.postgresql.Driver\";\n+    }\n+\n+    @Override\n+    public String getUrl(Properties connectionProperties) {\n+        PostgreSqlPropertyAdapter adapter = new PostgreSqlPropertyAdapter(connectionProperties);\n+\n+        return \"jdbc:postgresql://\" + adapter.getHost() + \":\" + adapter.getPort() + \"/\" + adapter.getDatabase();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyMTgyNg=="}, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzOTEzMw==", "bodyText": "OK, this was a curiosity question.  NO worries", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411439133", "createdAt": "2020-04-20T14:47:38Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlTranslator.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.sql.SQLException;\n+import java.util.Properties;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.ConnectionDetails;\n+import com.ibm.fhir.database.utils.api.ConnectionException;\n+import com.ibm.fhir.database.utils.api.DataAccessException;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.database.utils.api.LockException;\n+import com.ibm.fhir.database.utils.api.UndefinedNameException;\n+import com.ibm.fhir.database.utils.api.UniqueConstraintViolationException;\n+\n+/**\n+ * translates database access to PostgreSql supported access.\n+ */\n+public class PostgreSqlTranslator implements IDatabaseTranslator {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlTranslator.class.getName());\n+\n+    @Override\n+    public String addForUpdate(String sql) {\n+        return sql + \" FOR UPDATE\";\n+    }\n+\n+    @Override\n+    public boolean isDerby() {\n+        return false;\n+    }\n+\n+    @Override\n+    public String globalTempTableName(String tableName) {\n+        return \"SYSTEM.\" + tableName;\n+    }\n+\n+    @Override\n+    public String createGlobalTempTable(String ddl) {\n+        return \"DECLARE \" + ddl;\n+    }\n+\n+    @Override\n+    public boolean isDuplicate(SQLException x) {\n+        // Class Code 23: Constraint Violation\n+        return \"23505\".equals(x.getSQLState());\n+    }\n+\n+    @Override\n+    public boolean isAlreadyExists(SQLException x) {\n+        return \"42710\".equals(x.getSQLState());\n+    }\n+\n+    @Override\n+    public boolean isLockTimeout(SQLException x) {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isDeadlock(SQLException x) {\n+        final String sqlState = x.getSQLState();\n+        return \"40XL1\".equals(sqlState) || \"40XL2\".equals(sqlState);\n+    }\n+\n+    @Override\n+    public boolean isConnectionError(SQLException x) {\n+        String sqlState = x.getSQLState();\n+        return sqlState != null && sqlState.startsWith(\"08\");\n+    }\n+\n+    @Override\n+    public DataAccessException translate(SQLException x) {\n+        if (isDeadlock(x)) {\n+            return new LockException(x, true);\n+        }\n+        else if (isLockTimeout(x)) {\n+            return new LockException(x, false);\n+        }\n+        else if (isConnectionError(x)) {\n+            return new ConnectionException(x);\n+        }\n+        else if (isDuplicate(x)) {\n+            return new UniqueConstraintViolationException(x);\n+        }\n+        else if (isUndefinedName(x)) {\n+            return new UndefinedNameException(x);\n+        }\n+        else {\n+            return new DataAccessException(x);\n+        }\n+    }\n+\n+    @Override\n+    public boolean isUndefinedName(SQLException x) {\n+        return \"42X05\".equals(x.getSQLState());\n+    }\n+\n+    @Override\n+    public void fillProperties(Properties p, ConnectionDetails cd) {\n+        p.put(\"user\", cd.getUser());\n+        p.put(\"password\", cd.getPassword());\n+\n+        if (cd.isSsl()) {\n+            p.put(\"sslConnection\", \"true\");\n+        }\n+\n+        if (cd.isHA()) {\n+            logger.warning(\"No HA support for PostgreSql\");\n+        }\n+    }\n+\n+    @Override\n+    public String timestampDiff(String left, String right, String alias) {\n+        if (alias == null || alias.isEmpty()) {\n+            return String.format(\"{fn timestampdiff(SQL_TSI_SECOND, %s, %s)}\", left, right);\n+        }\n+        else {\n+            return String.format(\"{fn timestampdiff(SQL_TSI_SECOND, %s, %s)} AS %s\", left, right, alias);\n+        }\n+    }\n+\n+    @Override\n+    public String createSequence(String name, int cache) {\n+        // cache isn't supported by PostgreSql\n+        return \"CREATE SEQUENCE \" + name;\n+    }\n+\n+    @Override\n+    public String reorgTableCommand(String tableName) {\n+        // REORG TABLE not supported by PostgreSql\n+        throw new UnsupportedOperationException(\"reorg table is not supported!\");\n+    }\n+\n+    @Override\n+    public String getDriverClassName() {\n+        return \"org.postgresql.Driver\";\n+    }\n+\n+    @Override\n+    public String getUrl(Properties connectionProperties) {\n+        PostgreSqlPropertyAdapter adapter = new PostgreSqlPropertyAdapter(connectionProperties);\n+\n+        return \"jdbc:postgresql://\" + adapter.getHost() + \":\" + adapter.getPort() + \"/\" + adapter.getDatabase();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyMTgyNg=="}, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 147}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NTk2NzAyOnYy", "diffSide": "RIGHT", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/version/AddVersionDAO.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoyNzoyMVrOGIXR_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNjowNjoxOVrOGIcHEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyMzIzMA==", "bodyText": "If I could suggest a flip of the code here.  if-then-else can come before, and be assigned to a value.\nthen the builder can be automatically assigned to the InsertStatement", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411423230", "createdAt": "2020-04-20T14:27:21Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/version/AddVersionDAO.java", "diffHunk": "@@ -38,14 +38,18 @@ public AddVersionDAO(String adminSchemaName, String schemaName, String type, Str\n \n     @Override\n     public void run(IDatabaseTranslator translator, Connection c) {\n-\n-        final InsertStatement ins = InsertStatement.builder(adminSchemaName, SchemaConstants.VERSION_HISTORY)\n+        InsertStatement.Builder insBuilder = InsertStatement.builder(adminSchemaName, SchemaConstants.VERSION_HISTORY)\n                 .addColumn(SchemaConstants.SCHEMA_NAME)\n                 .addColumn(SchemaConstants.OBJECT_TYPE)\n                 .addColumn(SchemaConstants.OBJECT_NAME)\n-                .addColumn(SchemaConstants.VERSION)\n-                .addColumn(SchemaConstants.APPLIED, \"CURRENT TIMESTAMP\")\n-                .build();\n+                .addColumn(SchemaConstants.VERSION);\n+        if (translator.getDriverClassName().contains(\"postgresql\")) {\n+            insBuilder = insBuilder.addColumn(SchemaConstants.APPLIED, \"CURRENT_TIMESTAMP\");\n+        } else {\n+            insBuilder = insBuilder.addColumn(SchemaConstants.APPLIED, \"CURRENT TIMESTAMP\");\n+        }\n+\n+        final InsertStatement ins = insBuilder.build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUwMjM1NA==", "bodyText": "make sense, done", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411502354", "createdAt": "2020-04-20T16:06:19Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/version/AddVersionDAO.java", "diffHunk": "@@ -38,14 +38,18 @@ public AddVersionDAO(String adminSchemaName, String schemaName, String type, Str\n \n     @Override\n     public void run(IDatabaseTranslator translator, Connection c) {\n-\n-        final InsertStatement ins = InsertStatement.builder(adminSchemaName, SchemaConstants.VERSION_HISTORY)\n+        InsertStatement.Builder insBuilder = InsertStatement.builder(adminSchemaName, SchemaConstants.VERSION_HISTORY)\n                 .addColumn(SchemaConstants.SCHEMA_NAME)\n                 .addColumn(SchemaConstants.OBJECT_TYPE)\n                 .addColumn(SchemaConstants.OBJECT_NAME)\n-                .addColumn(SchemaConstants.VERSION)\n-                .addColumn(SchemaConstants.APPLIED, \"CURRENT TIMESTAMP\")\n-                .build();\n+                .addColumn(SchemaConstants.VERSION);\n+        if (translator.getDriverClassName().contains(\"postgresql\")) {\n+            insBuilder = insBuilder.addColumn(SchemaConstants.APPLIED, \"CURRENT_TIMESTAMP\");\n+        } else {\n+            insBuilder = insBuilder.addColumn(SchemaConstants.APPLIED, \"CURRENT TIMESTAMP\");\n+        }\n+\n+        final InsertStatement ins = insBuilder.build();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyMzIzMA=="}, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NTk3MjQ2OnYy", "diffSide": "RIGHT", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/FHIRResourceDAOFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoyODoyOFrOGIXVLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoyODoyOFrOGIXVLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyNDA0Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public enum FHIRResourceDAOType {\n          \n          \n            \n                // The various DAO Types that are used in the JDBC Persistence layer. \n          \n          \n            \n                public enum DAOType {", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411424047", "createdAt": "2020-04-20T14:28:28Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/FHIRResourceDAOFactory.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.persistence.jdbc.dao.api.ResourceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyResourceDAO;\n+import com.ibm.fhir.persistence.jdbc.postgresql.PostgreSqlResourceDAO;\n+\n+public class FHIRResourceDAOFactory {\n+\n+    public enum FHIRResourceDAOType {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NTk3NjA4OnYy", "diffSide": "RIGHT", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/FHIRResourceDAOFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoyOTowNVrOGIXXRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoyOTowNVrOGIXXRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyNDU4MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n      \n    \n    \n  \n\nextra line", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411424581", "createdAt": "2020-04-20T14:29:05Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/FHIRResourceDAOFactory.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.persistence.jdbc.dao.api.ResourceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyResourceDAO;\n+import com.ibm.fhir.persistence.jdbc.postgresql.PostgreSqlResourceDAO;\n+\n+public class FHIRResourceDAOFactory {\n+\n+    public enum FHIRResourceDAOType {\n+        DB2(\"db2\"),\n+        DERBY(\"derby\"),\n+        POSTGRESQL(\"postgresql\");\n+\n+        private final String value;\n+\n+        FHIRResourceDAOType(String value) {\n+            this.value = value;\n+        }\n+\n+        public String value() {\n+            return value;\n+        }\n+\n+        public static FHIRResourceDAOType of(Connection con) throws SQLException, IllegalArgumentException {\n+            String dbUrl = con.getMetaData().getURL();\n+            dbUrl = dbUrl.toLowerCase();\n+            if (dbUrl.contains(DB2.value)) {\n+                return DB2;\n+            } else if (dbUrl.contains(DERBY.value)) {\n+                return DERBY;\n+            } else if (dbUrl.contains(POSTGRESQL.value)) {\n+                return POSTGRESQL;\n+            } else {\n+                throw new IllegalArgumentException(dbUrl);\n+            }\n+\n+        }\n+    }\n+\n+   public static ResourceDAO getResourceDAO (Connection con, TransactionSynchronizationRegistry trxSynchRegistry) throws IllegalArgumentException, SQLException {\n+        ResourceDAO resourceDAO = null;\n+        switch (FHIRResourceDAOType.of(con)) {\n+            case DB2:\n+                resourceDAO = new ResourceDAOImpl(trxSynchRegistry);\n+                break;\n+            case DERBY:\n+                resourceDAO = new DerbyResourceDAO(trxSynchRegistry);\n+                break;\n+            case POSTGRESQL:\n+                resourceDAO = new PostgreSqlResourceDAO(trxSynchRegistry);\n+                break;\n+        }\n+        return resourceDAO;\n+    }\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NTk4MTcwOnYy", "diffSide": "RIGHT", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/FHIRResourceDAOFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozMDoxMVrOGIXawQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozMDoxMVrOGIXawQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyNTQ3Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               public static ResourceDAO getResourceDAO (Connection con, TransactionSynchronizationRegistry trxSynchRegistry) throws IllegalArgumentException, SQLException {\n          \n          \n            \n               public static ResourceDAO getResourceDAO (Connection conn, TransactionSynchronizationRegistry trxSynchRegistry) throws IllegalArgumentException, SQLException {\n          \n      \n    \n    \n  \n\nI was advised this a long time ago. don't use con.  Con is actually a reserved word on windows.  And a swear in another language.  Search con french. use conn", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411425473", "createdAt": "2020-04-20T14:30:11Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/FHIRResourceDAOFactory.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.persistence.jdbc.dao.api.ResourceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyResourceDAO;\n+import com.ibm.fhir.persistence.jdbc.postgresql.PostgreSqlResourceDAO;\n+\n+public class FHIRResourceDAOFactory {\n+\n+    public enum FHIRResourceDAOType {\n+        DB2(\"db2\"),\n+        DERBY(\"derby\"),\n+        POSTGRESQL(\"postgresql\");\n+\n+        private final String value;\n+\n+        FHIRResourceDAOType(String value) {\n+            this.value = value;\n+        }\n+\n+        public String value() {\n+            return value;\n+        }\n+\n+        public static FHIRResourceDAOType of(Connection con) throws SQLException, IllegalArgumentException {\n+            String dbUrl = con.getMetaData().getURL();\n+            dbUrl = dbUrl.toLowerCase();\n+            if (dbUrl.contains(DB2.value)) {\n+                return DB2;\n+            } else if (dbUrl.contains(DERBY.value)) {\n+                return DERBY;\n+            } else if (dbUrl.contains(POSTGRESQL.value)) {\n+                return POSTGRESQL;\n+            } else {\n+                throw new IllegalArgumentException(dbUrl);\n+            }\n+\n+        }\n+    }\n+\n+   public static ResourceDAO getResourceDAO (Connection con, TransactionSynchronizationRegistry trxSynchRegistry) throws IllegalArgumentException, SQLException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NTk4MzA2OnYy", "diffSide": "RIGHT", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/FHIRResourceDAOFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozMDoyN1rOGIXbkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNjoxMjoxMlrOGIcYDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyNTY4Mg==", "bodyText": "same comment as above", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411425682", "createdAt": "2020-04-20T14:30:27Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/FHIRResourceDAOFactory.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.persistence.jdbc.dao.api.ResourceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyResourceDAO;\n+import com.ibm.fhir.persistence.jdbc.postgresql.PostgreSqlResourceDAO;\n+\n+public class FHIRResourceDAOFactory {\n+\n+    public enum FHIRResourceDAOType {\n+        DB2(\"db2\"),\n+        DERBY(\"derby\"),\n+        POSTGRESQL(\"postgresql\");\n+\n+        private final String value;\n+\n+        FHIRResourceDAOType(String value) {\n+            this.value = value;\n+        }\n+\n+        public String value() {\n+            return value;\n+        }\n+\n+        public static FHIRResourceDAOType of(Connection con) throws SQLException, IllegalArgumentException {\n+            String dbUrl = con.getMetaData().getURL();\n+            dbUrl = dbUrl.toLowerCase();\n+            if (dbUrl.contains(DB2.value)) {\n+                return DB2;\n+            } else if (dbUrl.contains(DERBY.value)) {\n+                return DERBY;\n+            } else if (dbUrl.contains(POSTGRESQL.value)) {\n+                return POSTGRESQL;\n+            } else {\n+                throw new IllegalArgumentException(dbUrl);\n+            }\n+\n+        }\n+    }\n+\n+   public static ResourceDAO getResourceDAO (Connection con, TransactionSynchronizationRegistry trxSynchRegistry) throws IllegalArgumentException, SQLException {\n+        ResourceDAO resourceDAO = null;\n+        switch (FHIRResourceDAOType.of(con)) {\n+            case DB2:\n+                resourceDAO = new ResourceDAOImpl(trxSynchRegistry);\n+                break;\n+            case DERBY:\n+                resourceDAO = new DerbyResourceDAO(trxSynchRegistry);\n+                break;\n+            case POSTGRESQL:\n+                resourceDAO = new PostgreSqlResourceDAO(trxSynchRegistry);\n+                break;\n+        }\n+        return resourceDAO;\n+    }\n+\n+\n+    public static ResourceDAO getResourceDAO (Connection con) throws IllegalArgumentException, SQLException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUwNjcwMA==", "bodyText": "done", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411506700", "createdAt": "2020-04-20T16:12:12Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/FHIRResourceDAOFactory.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.persistence.jdbc.dao.api.ResourceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyResourceDAO;\n+import com.ibm.fhir.persistence.jdbc.postgresql.PostgreSqlResourceDAO;\n+\n+public class FHIRResourceDAOFactory {\n+\n+    public enum FHIRResourceDAOType {\n+        DB2(\"db2\"),\n+        DERBY(\"derby\"),\n+        POSTGRESQL(\"postgresql\");\n+\n+        private final String value;\n+\n+        FHIRResourceDAOType(String value) {\n+            this.value = value;\n+        }\n+\n+        public String value() {\n+            return value;\n+        }\n+\n+        public static FHIRResourceDAOType of(Connection con) throws SQLException, IllegalArgumentException {\n+            String dbUrl = con.getMetaData().getURL();\n+            dbUrl = dbUrl.toLowerCase();\n+            if (dbUrl.contains(DB2.value)) {\n+                return DB2;\n+            } else if (dbUrl.contains(DERBY.value)) {\n+                return DERBY;\n+            } else if (dbUrl.contains(POSTGRESQL.value)) {\n+                return POSTGRESQL;\n+            } else {\n+                throw new IllegalArgumentException(dbUrl);\n+            }\n+\n+        }\n+    }\n+\n+   public static ResourceDAO getResourceDAO (Connection con, TransactionSynchronizationRegistry trxSynchRegistry) throws IllegalArgumentException, SQLException {\n+        ResourceDAO resourceDAO = null;\n+        switch (FHIRResourceDAOType.of(con)) {\n+            case DB2:\n+                resourceDAO = new ResourceDAOImpl(trxSynchRegistry);\n+                break;\n+            case DERBY:\n+                resourceDAO = new DerbyResourceDAO(trxSynchRegistry);\n+                break;\n+            case POSTGRESQL:\n+                resourceDAO = new PostgreSqlResourceDAO(trxSynchRegistry);\n+                break;\n+        }\n+        return resourceDAO;\n+    }\n+\n+\n+    public static ResourceDAO getResourceDAO (Connection con) throws IllegalArgumentException, SQLException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyNTY4Mg=="}, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NTk5MTI5OnYy", "diffSide": "RIGHT", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/dao/impl/ResourceDAOImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozMjowM1rOGIXgmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNjoxNDoxMFrOGIcd9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyNjk2OA==", "bodyText": "This feels like it should go into the another class", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411426968", "createdAt": "2020-04-20T14:32:03Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/dao/impl/ResourceDAOImpl.java", "diffHunk": "@@ -459,40 +461,19 @@ public void addResourceTypeCacheCandidate(String resourceType, Integer resourceT\n \n     }\n \n-    @Override\n-    public Resource insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n-            throws FHIRPersistenceException {\n-        final String METHODNAME = \"insert(Resource, List<ExtractedParameterValue>\";\n-        log.entering(CLASSNAME, METHODNAME);\n+    public boolean isPostgreSqlDatabase() throws FHIRPersistenceDBConnectException, SQLException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUwODIxNA==", "bodyText": "good catch, I forgot to remove it. it should have been dropped in my refactoring. done", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411508214", "createdAt": "2020-04-20T16:14:10Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/dao/impl/ResourceDAOImpl.java", "diffHunk": "@@ -459,40 +461,19 @@ public void addResourceTypeCacheCandidate(String resourceType, Integer resourceT\n \n     }\n \n-    @Override\n-    public Resource insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n-            throws FHIRPersistenceException {\n-        final String METHODNAME = \"insert(Resource, List<ExtractedParameterValue>\";\n-        log.entering(CLASSNAME, METHODNAME);\n+    public boolean isPostgreSqlDatabase() throws FHIRPersistenceDBConnectException, SQLException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyNjk2OA=="}, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NjAwMDA3OnYy", "diffSide": "RIGHT", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/FhirRefSequenceDAOImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozMzo0NlrOGIXl6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozMzo0NlrOGIXl6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyODMyOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        }\n          \n          \n            \n                        else {\n          \n          \n            \n                        } else {", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411428329", "createdAt": "2020-04-20T14:33:46Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/FhirRefSequenceDAOImpl.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+\n+/**\n+ * DAO to obtain the next value from FHIR_REF_SEQUENCE\n+ *\n+ */\n+public class FhirRefSequenceDAOImpl implements FhirRefSequenceDAO {\n+    private final Connection conn;\n+\n+    /**\n+     * Public constructor\n+     */\n+    public FhirRefSequenceDAOImpl(Connection c) {\n+        this.conn = c;\n+    }\n+\n+    @Override\n+    public int nextValue() throws SQLException {\n+        int result;\n+        final String SEQ = \"select nextval('fhir_ref_sequence')\";\n+\n+        try (PreparedStatement stmt = conn.prepareStatement(SEQ)) {\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                result = rs.getInt(1);\n+            }\n+            else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NjAwMTYzOnYy", "diffSide": "RIGHT", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/FhirSequenceDAOImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozNDowM1rOGIXm2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozNDowM1rOGIXm2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyODU2OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411428569", "createdAt": "2020-04-20T14:34:03Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/FhirSequenceDAOImpl.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirSequenceDAO;\n+\n+/**\n+ * DAO to obtain the next value from FHIR_SEQUENCE\n+ *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NjAwOTg2OnYy", "diffSide": "RIGHT", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlParameterNamesDAO.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozNTo0MlrOGIXrsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozNTo0MlrOGIXrsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyOTgwOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411429809", "createdAt": "2020-04-20T14:35:42Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlParameterNamesDAO.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterNameDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+\n+public class PostgreSqlParameterNamesDAO extends ParameterNameDAOImpl {\n+    private final FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    public PostgreSqlParameterNamesDAO(Connection c, FhirRefSequenceDAO fsd) {\n+        super(c);\n+        this.fhirRefSequenceDAO = fsd;\n+    }\n+\n+    @Override\n+    public int readOrAddParameterNameId(String parameterName) throws FHIRPersistenceDataAccessException  {\n+        // As the system is concurrent, we have to handle cases where another thread\n+        // might create the entry after we selected and found nothing\n+        Integer result = getParameterId(parameterName);\n+\n+        // Create the resource if we don't have it already (set by the continue handler)\n+        if (result == null) {\n+            try {\n+                result = fhirRefSequenceDAO.nextValue();\n+\n+                final String INS = \"INSERT INTO parameter_names (parameter_name_id, parameter_name) VALUES (?, ?)\";\n+                try (PreparedStatement stmt = getConnection().prepareStatement(INS)) {\n+                    // bind parameters\n+                    stmt.setInt(1, result);\n+                    stmt.setString(2, parameterName);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (\"23505\".equals(e.getSQLState())) {\n+                    // another thread snuck in and created the record, so we need to fetch the correct id\n+                    result = getParameterId(parameterName);\n+\n+                    if (result == null) {\n+                        // would be extremely weird, but good to protect against anyway\n+                        throw new IllegalStateException(\"No parameter id returned after duplicate found!\");\n+                    }\n+                }\n+                else {\n+                    throw new FHIRPersistenceDataAccessException(\"parameterName=\" + parameterName, e);\n+                }\n+            }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NjAxMzM4OnYy", "diffSide": "RIGHT", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlParameterNamesDAO.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozNjoyNlrOGIXt4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNjoxNToyMlrOGIchYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMDM3MA==", "bodyText": "is sql1 special ? just curious about sql1 meaning.", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411430370", "createdAt": "2020-04-20T14:36:26Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlParameterNamesDAO.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterNameDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+\n+public class PostgreSqlParameterNamesDAO extends ParameterNameDAOImpl {\n+    private final FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    public PostgreSqlParameterNamesDAO(Connection c, FhirRefSequenceDAO fsd) {\n+        super(c);\n+        this.fhirRefSequenceDAO = fsd;\n+    }\n+\n+    @Override\n+    public int readOrAddParameterNameId(String parameterName) throws FHIRPersistenceDataAccessException  {\n+        // As the system is concurrent, we have to handle cases where another thread\n+        // might create the entry after we selected and found nothing\n+        Integer result = getParameterId(parameterName);\n+\n+        // Create the resource if we don't have it already (set by the continue handler)\n+        if (result == null) {\n+            try {\n+                result = fhirRefSequenceDAO.nextValue();\n+\n+                final String INS = \"INSERT INTO parameter_names (parameter_name_id, parameter_name) VALUES (?, ?)\";\n+                try (PreparedStatement stmt = getConnection().prepareStatement(INS)) {\n+                    // bind parameters\n+                    stmt.setInt(1, result);\n+                    stmt.setString(2, parameterName);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (\"23505\".equals(e.getSQLState())) {\n+                    // another thread snuck in and created the record, so we need to fetch the correct id\n+                    result = getParameterId(parameterName);\n+\n+                    if (result == null) {\n+                        // would be extremely weird, but good to protect against anyway\n+                        throw new IllegalStateException(\"No parameter id returned after duplicate found!\");\n+                    }\n+                }\n+                else {\n+                    throw new FHIRPersistenceDataAccessException(\"parameterName=\" + parameterName, e);\n+                }\n+            }\n+\n+        }\n+\n+        // cannot be null, so safe to return as an int\n+        return result;\n+    }\n+\n+    /**\n+     * Read the id for the named type\n+     * @param parameterName\n+     * @return the database id, or null if the named record is not found\n+     * @throws FHIRPersistenceDataAccessException\n+     */\n+    protected Integer getParameterId(String parameterName) throws FHIRPersistenceDataAccessException {\n+        Integer result;\n+\n+        String sql1 = \"SELECT parameter_name_id FROM parameter_names WHERE parameter_name = ?\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUwOTA4OA==", "bodyText": "not really, let me change to sql. done", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411509088", "createdAt": "2020-04-20T16:15:22Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlParameterNamesDAO.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterNameDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+\n+public class PostgreSqlParameterNamesDAO extends ParameterNameDAOImpl {\n+    private final FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    public PostgreSqlParameterNamesDAO(Connection c, FhirRefSequenceDAO fsd) {\n+        super(c);\n+        this.fhirRefSequenceDAO = fsd;\n+    }\n+\n+    @Override\n+    public int readOrAddParameterNameId(String parameterName) throws FHIRPersistenceDataAccessException  {\n+        // As the system is concurrent, we have to handle cases where another thread\n+        // might create the entry after we selected and found nothing\n+        Integer result = getParameterId(parameterName);\n+\n+        // Create the resource if we don't have it already (set by the continue handler)\n+        if (result == null) {\n+            try {\n+                result = fhirRefSequenceDAO.nextValue();\n+\n+                final String INS = \"INSERT INTO parameter_names (parameter_name_id, parameter_name) VALUES (?, ?)\";\n+                try (PreparedStatement stmt = getConnection().prepareStatement(INS)) {\n+                    // bind parameters\n+                    stmt.setInt(1, result);\n+                    stmt.setString(2, parameterName);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (\"23505\".equals(e.getSQLState())) {\n+                    // another thread snuck in and created the record, so we need to fetch the correct id\n+                    result = getParameterId(parameterName);\n+\n+                    if (result == null) {\n+                        // would be extremely weird, but good to protect against anyway\n+                        throw new IllegalStateException(\"No parameter id returned after duplicate found!\");\n+                    }\n+                }\n+                else {\n+                    throw new FHIRPersistenceDataAccessException(\"parameterName=\" + parameterName, e);\n+                }\n+            }\n+\n+        }\n+\n+        // cannot be null, so safe to return as an int\n+        return result;\n+    }\n+\n+    /**\n+     * Read the id for the named type\n+     * @param parameterName\n+     * @return the database id, or null if the named record is not found\n+     * @throws FHIRPersistenceDataAccessException\n+     */\n+    protected Integer getParameterId(String parameterName) throws FHIRPersistenceDataAccessException {\n+        Integer result;\n+\n+        String sql1 = \"SELECT parameter_name_id FROM parameter_names WHERE parameter_name = ?\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMDM3MA=="}, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NjAxNDAzOnYy", "diffSide": "RIGHT", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlParameterNamesDAO.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozNjozNlrOGIXuVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozNjozNlrOGIXuVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMDQ4Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    }\n          \n          \n            \n                    catch (SQLException x) {\n          \n          \n            \n                    } catch (SQLException x) {", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411430486", "createdAt": "2020-04-20T14:36:36Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlParameterNamesDAO.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterNameDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+\n+public class PostgreSqlParameterNamesDAO extends ParameterNameDAOImpl {\n+    private final FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    public PostgreSqlParameterNamesDAO(Connection c, FhirRefSequenceDAO fsd) {\n+        super(c);\n+        this.fhirRefSequenceDAO = fsd;\n+    }\n+\n+    @Override\n+    public int readOrAddParameterNameId(String parameterName) throws FHIRPersistenceDataAccessException  {\n+        // As the system is concurrent, we have to handle cases where another thread\n+        // might create the entry after we selected and found nothing\n+        Integer result = getParameterId(parameterName);\n+\n+        // Create the resource if we don't have it already (set by the continue handler)\n+        if (result == null) {\n+            try {\n+                result = fhirRefSequenceDAO.nextValue();\n+\n+                final String INS = \"INSERT INTO parameter_names (parameter_name_id, parameter_name) VALUES (?, ?)\";\n+                try (PreparedStatement stmt = getConnection().prepareStatement(INS)) {\n+                    // bind parameters\n+                    stmt.setInt(1, result);\n+                    stmt.setString(2, parameterName);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (\"23505\".equals(e.getSQLState())) {\n+                    // another thread snuck in and created the record, so we need to fetch the correct id\n+                    result = getParameterId(parameterName);\n+\n+                    if (result == null) {\n+                        // would be extremely weird, but good to protect against anyway\n+                        throw new IllegalStateException(\"No parameter id returned after duplicate found!\");\n+                    }\n+                }\n+                else {\n+                    throw new FHIRPersistenceDataAccessException(\"parameterName=\" + parameterName, e);\n+                }\n+            }\n+\n+        }\n+\n+        // cannot be null, so safe to return as an int\n+        return result;\n+    }\n+\n+    /**\n+     * Read the id for the named type\n+     * @param parameterName\n+     * @return the database id, or null if the named record is not found\n+     * @throws FHIRPersistenceDataAccessException\n+     */\n+    protected Integer getParameterId(String parameterName) throws FHIRPersistenceDataAccessException {\n+        Integer result;\n+\n+        String sql1 = \"SELECT parameter_name_id FROM parameter_names WHERE parameter_name = ?\";\n+\n+        try (PreparedStatement stmt = getConnection().prepareStatement(sql1)) {\n+            stmt.setString(1, parameterName);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                result = rs.getInt(1);\n+            }\n+            else {\n+                result = null;\n+            }\n+        }\n+        catch (SQLException x) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NjAxNTI4OnYy", "diffSide": "RIGHT", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlParameterNamesDAO.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozNjo1MFrOGIXvFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozNjo1MFrOGIXvFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMDY3OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        }\n          \n          \n            \n                        else {\n          \n          \n            \n                        }  else {", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411430678", "createdAt": "2020-04-20T14:36:50Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlParameterNamesDAO.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterNameDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+\n+public class PostgreSqlParameterNamesDAO extends ParameterNameDAOImpl {\n+    private final FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    public PostgreSqlParameterNamesDAO(Connection c, FhirRefSequenceDAO fsd) {\n+        super(c);\n+        this.fhirRefSequenceDAO = fsd;\n+    }\n+\n+    @Override\n+    public int readOrAddParameterNameId(String parameterName) throws FHIRPersistenceDataAccessException  {\n+        // As the system is concurrent, we have to handle cases where another thread\n+        // might create the entry after we selected and found nothing\n+        Integer result = getParameterId(parameterName);\n+\n+        // Create the resource if we don't have it already (set by the continue handler)\n+        if (result == null) {\n+            try {\n+                result = fhirRefSequenceDAO.nextValue();\n+\n+                final String INS = \"INSERT INTO parameter_names (parameter_name_id, parameter_name) VALUES (?, ?)\";\n+                try (PreparedStatement stmt = getConnection().prepareStatement(INS)) {\n+                    // bind parameters\n+                    stmt.setInt(1, result);\n+                    stmt.setString(2, parameterName);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (\"23505\".equals(e.getSQLState())) {\n+                    // another thread snuck in and created the record, so we need to fetch the correct id\n+                    result = getParameterId(parameterName);\n+\n+                    if (result == null) {\n+                        // would be extremely weird, but good to protect against anyway\n+                        throw new IllegalStateException(\"No parameter id returned after duplicate found!\");\n+                    }\n+                }\n+                else {\n+                    throw new FHIRPersistenceDataAccessException(\"parameterName=\" + parameterName, e);\n+                }\n+            }\n+\n+        }\n+\n+        // cannot be null, so safe to return as an int\n+        return result;\n+    }\n+\n+    /**\n+     * Read the id for the named type\n+     * @param parameterName\n+     * @return the database id, or null if the named record is not found\n+     * @throws FHIRPersistenceDataAccessException\n+     */\n+    protected Integer getParameterId(String parameterName) throws FHIRPersistenceDataAccessException {\n+        Integer result;\n+\n+        String sql1 = \"SELECT parameter_name_id FROM parameter_names WHERE parameter_name = ?\";\n+\n+        try (PreparedStatement stmt = getConnection().prepareStatement(sql1)) {\n+            stmt.setString(1, parameterName);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                result = rs.getInt(1);\n+            }\n+            else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NjAxOTAxOnYy", "diffSide": "RIGHT", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozNzo0NVrOGIXxlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNjoxODowNlrOGIcpMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMTMxOQ==", "bodyText": "Do we want to use DSTU2 reference? I think we should remove.", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411431319", "createdAt": "2020-04-20T14:37:45Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,533 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an Apache PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMjE5OQ==", "bodyText": "Also we probably just want to reference db2, we haven't used GTTs recently.", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411432199", "createdAt": "2020-04-20T14:38:50Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,533 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an Apache PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMTMxOQ=="}, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUxMTA4OA==", "bodyText": "updated the comments, done", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411511088", "createdAt": "2020-04-20T16:18:06Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,533 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an Apache PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMTMxOQ=="}, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NjAyMjg5OnYy", "diffSide": "RIGHT", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozODozMFrOGIXz9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozODozMFrOGIXz9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMTkyNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Data access object for writing FHIR resources to an Apache PostgreSql database.\n          \n          \n            \n             * Data access object for writing FHIR resources to an PostgreSql database.", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411431925", "createdAt": "2020-04-20T14:38:30Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,533 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an Apache PostgreSql database.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NjAyNjI3OnYy", "diffSide": "RIGHT", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozOToxMFrOGIX19g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozOToxMFrOGIX19g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMjQzOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411432438", "createdAt": "2020-04-20T14:39:10Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,533 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an Apache PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NjAzMTA3OnYy", "diffSide": "RIGHT", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0MDowM1rOGIX4yA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0MDowM1rOGIX4yA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMzE2MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        }\n          \n          \n            \n                        else {\n          \n          \n            \n                        } else {", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411433160", "createdAt": "2020-04-20T14:40:03Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,533 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an Apache PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+\n+    }\n+\n+    /**\n+     * Store the resource in the database, creating a new logical_resource entry if this is\n+     * the first version of this resource, or creating a new resource entry if this a new\n+     * version of an existing logical resource. The logic tracks closely the DB2 stored\n+     * procedure implementation, including locking of the logical_resource and handling\n+     * concurrency issues using the standard insert-or-update pattern:\n+     * <pre>\n+     *   SELECT FOR UPDATE                 -- try and get a write lock\n+     *   IF NOT FOUND THEN                 -- doesn't exist, so we don't have a lock\n+     *     INSERT new logical resource     -- create the record - if OK, we own the lock\n+     *     IF DUPLICATE THEN               -- someone else beat us to the create\n+     *       SELECT FOR UPDATE             -- so we need to try again for a write lock\n+     *     ...\n+     *   ...\n+     * </pre>\n+     *\n+     * This works because we never delete a logical_resource record, and so don't have to deal\n+     * with concurrency issues caused when deletes are mingled with inserts/updates\n+     *\n+     * Note the execution flow aligns very closely with the DB2 stored procedure\n+     * implementation (fhir-persistence-schema/src/main/resources/add_any_resource.sql)\n+     *\n+     * @param tablePrefix\n+     * @param parameters\n+     * @param p_logical_id\n+     * @param p_payload\n+     * @param p_last_updated\n+     * @param p_is_deleted\n+     * @param p_source_key\n+     * @param p_version\n+     *\n+     * @return the resource_id for the entry we created\n+     * @throws Exception\n+     */\n+    public long storeResource(String tablePrefix, List<ExtractedParameterValue> parameters, String p_logical_id, byte[] p_payload, Timestamp p_last_updated, boolean p_is_deleted,\n+        String p_source_key, Integer p_version, Connection conn) throws Exception {\n+\n+        final String METHODNAME = \"storeResource() for \" + tablePrefix + \" resource\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Long v_logical_resource_id = null;\n+        Long v_current_resource_id = null;\n+        Long v_resource_id = null;\n+        Integer v_resource_type_id = null;\n+        boolean v_new_resource = false;\n+        boolean v_not_found = false;\n+        boolean v_duplicate = false;\n+        int v_version = 0;\n+        int v_insert_version = 0;\n+\n+        String v_resource_type = tablePrefix;\n+\n+        // Map the resource type name to the normalized id value in the database\n+        v_resource_type_id = getResourceTypeId(v_resource_type, conn);\n+        if (v_resource_type_id == null) {\n+            // programming error, as this should've been created earlier\n+            throw new IllegalStateException(\"resource type not found: \" + v_resource_type);\n+        }\n+\n+        // Get a lock at the system-wide logical resource level. Note the Derby-specific syntax\n+        final String SELECT_FOR_UPDATE = \"SELECT logical_resource_id FROM logical_resources WHERE resource_type_id = ? AND logical_id = ? FOR UPDATE\";\n+        try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+            stmt.setInt(1, v_resource_type_id);\n+            stmt.setString(2, p_logical_id);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                v_logical_resource_id = rs.getLong(1);\n+            }\n+            else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 244}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NjAzMjE5OnYy", "diffSide": "RIGHT", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0MDoxNFrOGIX5bQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0MDoxNFrOGIX5bQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMzMyNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            }\n          \n          \n            \n                            else {\n          \n          \n            \n                            } else {", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411433325", "createdAt": "2020-04-20T14:40:14Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,533 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an Apache PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+\n+    }\n+\n+    /**\n+     * Store the resource in the database, creating a new logical_resource entry if this is\n+     * the first version of this resource, or creating a new resource entry if this a new\n+     * version of an existing logical resource. The logic tracks closely the DB2 stored\n+     * procedure implementation, including locking of the logical_resource and handling\n+     * concurrency issues using the standard insert-or-update pattern:\n+     * <pre>\n+     *   SELECT FOR UPDATE                 -- try and get a write lock\n+     *   IF NOT FOUND THEN                 -- doesn't exist, so we don't have a lock\n+     *     INSERT new logical resource     -- create the record - if OK, we own the lock\n+     *     IF DUPLICATE THEN               -- someone else beat us to the create\n+     *       SELECT FOR UPDATE             -- so we need to try again for a write lock\n+     *     ...\n+     *   ...\n+     * </pre>\n+     *\n+     * This works because we never delete a logical_resource record, and so don't have to deal\n+     * with concurrency issues caused when deletes are mingled with inserts/updates\n+     *\n+     * Note the execution flow aligns very closely with the DB2 stored procedure\n+     * implementation (fhir-persistence-schema/src/main/resources/add_any_resource.sql)\n+     *\n+     * @param tablePrefix\n+     * @param parameters\n+     * @param p_logical_id\n+     * @param p_payload\n+     * @param p_last_updated\n+     * @param p_is_deleted\n+     * @param p_source_key\n+     * @param p_version\n+     *\n+     * @return the resource_id for the entry we created\n+     * @throws Exception\n+     */\n+    public long storeResource(String tablePrefix, List<ExtractedParameterValue> parameters, String p_logical_id, byte[] p_payload, Timestamp p_last_updated, boolean p_is_deleted,\n+        String p_source_key, Integer p_version, Connection conn) throws Exception {\n+\n+        final String METHODNAME = \"storeResource() for \" + tablePrefix + \" resource\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Long v_logical_resource_id = null;\n+        Long v_current_resource_id = null;\n+        Long v_resource_id = null;\n+        Integer v_resource_type_id = null;\n+        boolean v_new_resource = false;\n+        boolean v_not_found = false;\n+        boolean v_duplicate = false;\n+        int v_version = 0;\n+        int v_insert_version = 0;\n+\n+        String v_resource_type = tablePrefix;\n+\n+        // Map the resource type name to the normalized id value in the database\n+        v_resource_type_id = getResourceTypeId(v_resource_type, conn);\n+        if (v_resource_type_id == null) {\n+            // programming error, as this should've been created earlier\n+            throw new IllegalStateException(\"resource type not found: \" + v_resource_type);\n+        }\n+\n+        // Get a lock at the system-wide logical resource level. Note the Derby-specific syntax\n+        final String SELECT_FOR_UPDATE = \"SELECT logical_resource_id FROM logical_resources WHERE resource_type_id = ? AND logical_id = ? FOR UPDATE\";\n+        try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+            stmt.setInt(1, v_resource_type_id);\n+            stmt.setString(2, p_logical_id);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                v_logical_resource_id = rs.getLong(1);\n+            }\n+            else {\n+                v_not_found = true;\n+                v_logical_resource_id = -1L; // just to be careful\n+            }\n+        }\n+\n+        // Create the logical resource if we don't have it already\n+        if (v_not_found) {\n+            // grab the id we want to use for the new logical resource instance\n+            final String sql2 = \"SELECT nextval('fhir_sequence')\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_logical_resource_id = res.getLong(1);\n+                }\n+                else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 259}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NjAzNDA3OnYy", "diffSide": "RIGHT", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0MDozNFrOGIX6iA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0MDozNFrOGIX6iA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMzYwOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            }\n          \n          \n            \n                            else {\n          \n          \n            \n                            }  else {", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411433608", "createdAt": "2020-04-20T14:40:34Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,533 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an Apache PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+\n+    }\n+\n+    /**\n+     * Store the resource in the database, creating a new logical_resource entry if this is\n+     * the first version of this resource, or creating a new resource entry if this a new\n+     * version of an existing logical resource. The logic tracks closely the DB2 stored\n+     * procedure implementation, including locking of the logical_resource and handling\n+     * concurrency issues using the standard insert-or-update pattern:\n+     * <pre>\n+     *   SELECT FOR UPDATE                 -- try and get a write lock\n+     *   IF NOT FOUND THEN                 -- doesn't exist, so we don't have a lock\n+     *     INSERT new logical resource     -- create the record - if OK, we own the lock\n+     *     IF DUPLICATE THEN               -- someone else beat us to the create\n+     *       SELECT FOR UPDATE             -- so we need to try again for a write lock\n+     *     ...\n+     *   ...\n+     * </pre>\n+     *\n+     * This works because we never delete a logical_resource record, and so don't have to deal\n+     * with concurrency issues caused when deletes are mingled with inserts/updates\n+     *\n+     * Note the execution flow aligns very closely with the DB2 stored procedure\n+     * implementation (fhir-persistence-schema/src/main/resources/add_any_resource.sql)\n+     *\n+     * @param tablePrefix\n+     * @param parameters\n+     * @param p_logical_id\n+     * @param p_payload\n+     * @param p_last_updated\n+     * @param p_is_deleted\n+     * @param p_source_key\n+     * @param p_version\n+     *\n+     * @return the resource_id for the entry we created\n+     * @throws Exception\n+     */\n+    public long storeResource(String tablePrefix, List<ExtractedParameterValue> parameters, String p_logical_id, byte[] p_payload, Timestamp p_last_updated, boolean p_is_deleted,\n+        String p_source_key, Integer p_version, Connection conn) throws Exception {\n+\n+        final String METHODNAME = \"storeResource() for \" + tablePrefix + \" resource\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Long v_logical_resource_id = null;\n+        Long v_current_resource_id = null;\n+        Long v_resource_id = null;\n+        Integer v_resource_type_id = null;\n+        boolean v_new_resource = false;\n+        boolean v_not_found = false;\n+        boolean v_duplicate = false;\n+        int v_version = 0;\n+        int v_insert_version = 0;\n+\n+        String v_resource_type = tablePrefix;\n+\n+        // Map the resource type name to the normalized id value in the database\n+        v_resource_type_id = getResourceTypeId(v_resource_type, conn);\n+        if (v_resource_type_id == null) {\n+            // programming error, as this should've been created earlier\n+            throw new IllegalStateException(\"resource type not found: \" + v_resource_type);\n+        }\n+\n+        // Get a lock at the system-wide logical resource level. Note the Derby-specific syntax\n+        final String SELECT_FOR_UPDATE = \"SELECT logical_resource_id FROM logical_resources WHERE resource_type_id = ? AND logical_id = ? FOR UPDATE\";\n+        try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+            stmt.setInt(1, v_resource_type_id);\n+            stmt.setString(2, p_logical_id);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                v_logical_resource_id = rs.getLong(1);\n+            }\n+            else {\n+                v_not_found = true;\n+                v_logical_resource_id = -1L; // just to be careful\n+            }\n+        }\n+\n+        // Create the logical resource if we don't have it already\n+        if (v_not_found) {\n+            // grab the id we want to use for the new logical resource instance\n+            final String sql2 = \"SELECT nextval('fhir_sequence')\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_logical_resource_id = res.getLong(1);\n+                }\n+                else {\n+                    // not going to happen, unless someone butchers the statement being executed\n+                    throw new IllegalStateException(\"VALUES failed to return a row: \" + sql2);\n+                }\n+            }\n+\n+            try {\n+                // insert the system-wide logical resource record.\n+                final String sql3 = \"INSERT INTO logical_resources (logical_resource_id, resource_type_id, logical_id) VALUES (?, ?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setInt(2, v_resource_type_id);\n+                    stmt.setString(3, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (translator.isDuplicate(e)) {\n+                    v_duplicate = true;\n+                }\n+                else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 279}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NjAzNDk5OnYy", "diffSide": "RIGHT", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0MDo0NlrOGIX7KA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0MDo0NlrOGIX7KA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMzc2OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                }\n          \n          \n            \n                                else {\n          \n          \n            \n                                    // Extremely unlikely as we should never delete logical resource records\n          \n          \n            \n                                } else {\n          \n          \n            \n                                    // Extremely unlikely as we should never delete logical resource records", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411433768", "createdAt": "2020-04-20T14:40:46Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,533 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an Apache PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+\n+    }\n+\n+    /**\n+     * Store the resource in the database, creating a new logical_resource entry if this is\n+     * the first version of this resource, or creating a new resource entry if this a new\n+     * version of an existing logical resource. The logic tracks closely the DB2 stored\n+     * procedure implementation, including locking of the logical_resource and handling\n+     * concurrency issues using the standard insert-or-update pattern:\n+     * <pre>\n+     *   SELECT FOR UPDATE                 -- try and get a write lock\n+     *   IF NOT FOUND THEN                 -- doesn't exist, so we don't have a lock\n+     *     INSERT new logical resource     -- create the record - if OK, we own the lock\n+     *     IF DUPLICATE THEN               -- someone else beat us to the create\n+     *       SELECT FOR UPDATE             -- so we need to try again for a write lock\n+     *     ...\n+     *   ...\n+     * </pre>\n+     *\n+     * This works because we never delete a logical_resource record, and so don't have to deal\n+     * with concurrency issues caused when deletes are mingled with inserts/updates\n+     *\n+     * Note the execution flow aligns very closely with the DB2 stored procedure\n+     * implementation (fhir-persistence-schema/src/main/resources/add_any_resource.sql)\n+     *\n+     * @param tablePrefix\n+     * @param parameters\n+     * @param p_logical_id\n+     * @param p_payload\n+     * @param p_last_updated\n+     * @param p_is_deleted\n+     * @param p_source_key\n+     * @param p_version\n+     *\n+     * @return the resource_id for the entry we created\n+     * @throws Exception\n+     */\n+    public long storeResource(String tablePrefix, List<ExtractedParameterValue> parameters, String p_logical_id, byte[] p_payload, Timestamp p_last_updated, boolean p_is_deleted,\n+        String p_source_key, Integer p_version, Connection conn) throws Exception {\n+\n+        final String METHODNAME = \"storeResource() for \" + tablePrefix + \" resource\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Long v_logical_resource_id = null;\n+        Long v_current_resource_id = null;\n+        Long v_resource_id = null;\n+        Integer v_resource_type_id = null;\n+        boolean v_new_resource = false;\n+        boolean v_not_found = false;\n+        boolean v_duplicate = false;\n+        int v_version = 0;\n+        int v_insert_version = 0;\n+\n+        String v_resource_type = tablePrefix;\n+\n+        // Map the resource type name to the normalized id value in the database\n+        v_resource_type_id = getResourceTypeId(v_resource_type, conn);\n+        if (v_resource_type_id == null) {\n+            // programming error, as this should've been created earlier\n+            throw new IllegalStateException(\"resource type not found: \" + v_resource_type);\n+        }\n+\n+        // Get a lock at the system-wide logical resource level. Note the Derby-specific syntax\n+        final String SELECT_FOR_UPDATE = \"SELECT logical_resource_id FROM logical_resources WHERE resource_type_id = ? AND logical_id = ? FOR UPDATE\";\n+        try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+            stmt.setInt(1, v_resource_type_id);\n+            stmt.setString(2, p_logical_id);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                v_logical_resource_id = rs.getLong(1);\n+            }\n+            else {\n+                v_not_found = true;\n+                v_logical_resource_id = -1L; // just to be careful\n+            }\n+        }\n+\n+        // Create the logical resource if we don't have it already\n+        if (v_not_found) {\n+            // grab the id we want to use for the new logical resource instance\n+            final String sql2 = \"SELECT nextval('fhir_sequence')\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_logical_resource_id = res.getLong(1);\n+                }\n+                else {\n+                    // not going to happen, unless someone butchers the statement being executed\n+                    throw new IllegalStateException(\"VALUES failed to return a row: \" + sql2);\n+                }\n+            }\n+\n+            try {\n+                // insert the system-wide logical resource record.\n+                final String sql3 = \"INSERT INTO logical_resources (logical_resource_id, resource_type_id, logical_id) VALUES (?, ?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setInt(2, v_resource_type_id);\n+                    stmt.setString(3, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (translator.isDuplicate(e)) {\n+                    v_duplicate = true;\n+                }\n+                else {\n+                    throw e;\n+                }\n+            }\n+\n+            /**\n+             * remember that we have a concurrent system...so there is a possibility\n+             * that another thread snuck in before us and created the logical resource. This\n+             * is easy to handle, just turn around and read it\n+             */\n+            if (v_duplicate) {\n+                try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+                    // bind parameters\n+                    stmt.setInt(1, v_resource_type_id);\n+                    stmt.setString(2, p_logical_id);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        v_logical_resource_id = res.getLong(1);\n+                    }\n+                    else {\n+                        // Extremely unlikely as we should never delete logical resource records", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 299}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NjAzNjI2OnYy", "diffSide": "RIGHT", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0MDo1OFrOGIX72Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0MDo1OFrOGIX72Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMzk0NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        }\n          \n          \n            \n                        else {\n          \n          \n            \n                        } else {", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411433945", "createdAt": "2020-04-20T14:40:58Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,533 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an Apache PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+\n+    }\n+\n+    /**\n+     * Store the resource in the database, creating a new logical_resource entry if this is\n+     * the first version of this resource, or creating a new resource entry if this a new\n+     * version of an existing logical resource. The logic tracks closely the DB2 stored\n+     * procedure implementation, including locking of the logical_resource and handling\n+     * concurrency issues using the standard insert-or-update pattern:\n+     * <pre>\n+     *   SELECT FOR UPDATE                 -- try and get a write lock\n+     *   IF NOT FOUND THEN                 -- doesn't exist, so we don't have a lock\n+     *     INSERT new logical resource     -- create the record - if OK, we own the lock\n+     *     IF DUPLICATE THEN               -- someone else beat us to the create\n+     *       SELECT FOR UPDATE             -- so we need to try again for a write lock\n+     *     ...\n+     *   ...\n+     * </pre>\n+     *\n+     * This works because we never delete a logical_resource record, and so don't have to deal\n+     * with concurrency issues caused when deletes are mingled with inserts/updates\n+     *\n+     * Note the execution flow aligns very closely with the DB2 stored procedure\n+     * implementation (fhir-persistence-schema/src/main/resources/add_any_resource.sql)\n+     *\n+     * @param tablePrefix\n+     * @param parameters\n+     * @param p_logical_id\n+     * @param p_payload\n+     * @param p_last_updated\n+     * @param p_is_deleted\n+     * @param p_source_key\n+     * @param p_version\n+     *\n+     * @return the resource_id for the entry we created\n+     * @throws Exception\n+     */\n+    public long storeResource(String tablePrefix, List<ExtractedParameterValue> parameters, String p_logical_id, byte[] p_payload, Timestamp p_last_updated, boolean p_is_deleted,\n+        String p_source_key, Integer p_version, Connection conn) throws Exception {\n+\n+        final String METHODNAME = \"storeResource() for \" + tablePrefix + \" resource\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Long v_logical_resource_id = null;\n+        Long v_current_resource_id = null;\n+        Long v_resource_id = null;\n+        Integer v_resource_type_id = null;\n+        boolean v_new_resource = false;\n+        boolean v_not_found = false;\n+        boolean v_duplicate = false;\n+        int v_version = 0;\n+        int v_insert_version = 0;\n+\n+        String v_resource_type = tablePrefix;\n+\n+        // Map the resource type name to the normalized id value in the database\n+        v_resource_type_id = getResourceTypeId(v_resource_type, conn);\n+        if (v_resource_type_id == null) {\n+            // programming error, as this should've been created earlier\n+            throw new IllegalStateException(\"resource type not found: \" + v_resource_type);\n+        }\n+\n+        // Get a lock at the system-wide logical resource level. Note the Derby-specific syntax\n+        final String SELECT_FOR_UPDATE = \"SELECT logical_resource_id FROM logical_resources WHERE resource_type_id = ? AND logical_id = ? FOR UPDATE\";\n+        try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+            stmt.setInt(1, v_resource_type_id);\n+            stmt.setString(2, p_logical_id);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                v_logical_resource_id = rs.getLong(1);\n+            }\n+            else {\n+                v_not_found = true;\n+                v_logical_resource_id = -1L; // just to be careful\n+            }\n+        }\n+\n+        // Create the logical resource if we don't have it already\n+        if (v_not_found) {\n+            // grab the id we want to use for the new logical resource instance\n+            final String sql2 = \"SELECT nextval('fhir_sequence')\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_logical_resource_id = res.getLong(1);\n+                }\n+                else {\n+                    // not going to happen, unless someone butchers the statement being executed\n+                    throw new IllegalStateException(\"VALUES failed to return a row: \" + sql2);\n+                }\n+            }\n+\n+            try {\n+                // insert the system-wide logical resource record.\n+                final String sql3 = \"INSERT INTO logical_resources (logical_resource_id, resource_type_id, logical_id) VALUES (?, ?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setInt(2, v_resource_type_id);\n+                    stmt.setString(3, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (translator.isDuplicate(e)) {\n+                    v_duplicate = true;\n+                }\n+                else {\n+                    throw e;\n+                }\n+            }\n+\n+            /**\n+             * remember that we have a concurrent system...so there is a possibility\n+             * that another thread snuck in before us and created the logical resource. This\n+             * is easy to handle, just turn around and read it\n+             */\n+            if (v_duplicate) {\n+                try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+                    // bind parameters\n+                    stmt.setInt(1, v_resource_type_id);\n+                    stmt.setString(2, p_logical_id);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        v_logical_resource_id = res.getLong(1);\n+                    }\n+                    else {\n+                        // Extremely unlikely as we should never delete logical resource records\n+                        throw new IllegalStateException(\"Logical resource was deleted: \" + tablePrefix + \"/\" + p_logical_id);\n+                    }\n+                }\n+            }\n+            else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 304}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NjAzNzgzOnYy", "diffSide": "RIGHT", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0MToxNVrOGIX8zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0MToxNVrOGIX8zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzNDE5MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            }\n          \n          \n            \n                            else {\n          \n          \n            \n                            } else {", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411434191", "createdAt": "2020-04-20T14:41:15Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,533 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an Apache PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+\n+    }\n+\n+    /**\n+     * Store the resource in the database, creating a new logical_resource entry if this is\n+     * the first version of this resource, or creating a new resource entry if this a new\n+     * version of an existing logical resource. The logic tracks closely the DB2 stored\n+     * procedure implementation, including locking of the logical_resource and handling\n+     * concurrency issues using the standard insert-or-update pattern:\n+     * <pre>\n+     *   SELECT FOR UPDATE                 -- try and get a write lock\n+     *   IF NOT FOUND THEN                 -- doesn't exist, so we don't have a lock\n+     *     INSERT new logical resource     -- create the record - if OK, we own the lock\n+     *     IF DUPLICATE THEN               -- someone else beat us to the create\n+     *       SELECT FOR UPDATE             -- so we need to try again for a write lock\n+     *     ...\n+     *   ...\n+     * </pre>\n+     *\n+     * This works because we never delete a logical_resource record, and so don't have to deal\n+     * with concurrency issues caused when deletes are mingled with inserts/updates\n+     *\n+     * Note the execution flow aligns very closely with the DB2 stored procedure\n+     * implementation (fhir-persistence-schema/src/main/resources/add_any_resource.sql)\n+     *\n+     * @param tablePrefix\n+     * @param parameters\n+     * @param p_logical_id\n+     * @param p_payload\n+     * @param p_last_updated\n+     * @param p_is_deleted\n+     * @param p_source_key\n+     * @param p_version\n+     *\n+     * @return the resource_id for the entry we created\n+     * @throws Exception\n+     */\n+    public long storeResource(String tablePrefix, List<ExtractedParameterValue> parameters, String p_logical_id, byte[] p_payload, Timestamp p_last_updated, boolean p_is_deleted,\n+        String p_source_key, Integer p_version, Connection conn) throws Exception {\n+\n+        final String METHODNAME = \"storeResource() for \" + tablePrefix + \" resource\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Long v_logical_resource_id = null;\n+        Long v_current_resource_id = null;\n+        Long v_resource_id = null;\n+        Integer v_resource_type_id = null;\n+        boolean v_new_resource = false;\n+        boolean v_not_found = false;\n+        boolean v_duplicate = false;\n+        int v_version = 0;\n+        int v_insert_version = 0;\n+\n+        String v_resource_type = tablePrefix;\n+\n+        // Map the resource type name to the normalized id value in the database\n+        v_resource_type_id = getResourceTypeId(v_resource_type, conn);\n+        if (v_resource_type_id == null) {\n+            // programming error, as this should've been created earlier\n+            throw new IllegalStateException(\"resource type not found: \" + v_resource_type);\n+        }\n+\n+        // Get a lock at the system-wide logical resource level. Note the Derby-specific syntax\n+        final String SELECT_FOR_UPDATE = \"SELECT logical_resource_id FROM logical_resources WHERE resource_type_id = ? AND logical_id = ? FOR UPDATE\";\n+        try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+            stmt.setInt(1, v_resource_type_id);\n+            stmt.setString(2, p_logical_id);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                v_logical_resource_id = rs.getLong(1);\n+            }\n+            else {\n+                v_not_found = true;\n+                v_logical_resource_id = -1L; // just to be careful\n+            }\n+        }\n+\n+        // Create the logical resource if we don't have it already\n+        if (v_not_found) {\n+            // grab the id we want to use for the new logical resource instance\n+            final String sql2 = \"SELECT nextval('fhir_sequence')\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_logical_resource_id = res.getLong(1);\n+                }\n+                else {\n+                    // not going to happen, unless someone butchers the statement being executed\n+                    throw new IllegalStateException(\"VALUES failed to return a row: \" + sql2);\n+                }\n+            }\n+\n+            try {\n+                // insert the system-wide logical resource record.\n+                final String sql3 = \"INSERT INTO logical_resources (logical_resource_id, resource_type_id, logical_id) VALUES (?, ?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setInt(2, v_resource_type_id);\n+                    stmt.setString(3, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (translator.isDuplicate(e)) {\n+                    v_duplicate = true;\n+                }\n+                else {\n+                    throw e;\n+                }\n+            }\n+\n+            /**\n+             * remember that we have a concurrent system...so there is a possibility\n+             * that another thread snuck in before us and created the logical resource. This\n+             * is easy to handle, just turn around and read it\n+             */\n+            if (v_duplicate) {\n+                try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+                    // bind parameters\n+                    stmt.setInt(1, v_resource_type_id);\n+                    stmt.setString(2, p_logical_id);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        v_logical_resource_id = res.getLong(1);\n+                    }\n+                    else {\n+                        // Extremely unlikely as we should never delete logical resource records\n+                        throw new IllegalStateException(\"Logical resource was deleted: \" + tablePrefix + \"/\" + p_logical_id);\n+                    }\n+                }\n+            }\n+            else {\n+                v_new_resource = true;\n+\n+                // Insert the resource-specific logical resource record. Remember that logical_id is denormalized\n+                // so it gets stored again here for convenience\n+                final String sql3 = \"INSERT INTO \" + tablePrefix + \"_logical_resources (logical_resource_id, logical_id) VALUES (?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setString(2, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            }\n+        }\n+\n+        if (!v_new_resource) {\n+            // existing resource.  We need to know the current version from the\n+            // resource-specific logical resources table.\n+            final String sql3 = \"SELECT current_resource_id FROM \" + tablePrefix + \"_logical_resources WHERE logical_resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                stmt.setLong(1, v_logical_resource_id);\n+                ResultSet rs = stmt.executeQuery();\n+                if (rs.next()) {\n+                    v_current_resource_id = rs.getLong(1);\n+                }\n+                else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 329}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NjAzOTIxOnYy", "diffSide": "RIGHT", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0MTozMFrOGIX9ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0MTozMFrOGIX9ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzNDQwMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            }\n          \n          \n            \n                            else {\n          \n          \n            \n                            } else {", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411434403", "createdAt": "2020-04-20T14:41:30Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,533 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an Apache PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+\n+    }\n+\n+    /**\n+     * Store the resource in the database, creating a new logical_resource entry if this is\n+     * the first version of this resource, or creating a new resource entry if this a new\n+     * version of an existing logical resource. The logic tracks closely the DB2 stored\n+     * procedure implementation, including locking of the logical_resource and handling\n+     * concurrency issues using the standard insert-or-update pattern:\n+     * <pre>\n+     *   SELECT FOR UPDATE                 -- try and get a write lock\n+     *   IF NOT FOUND THEN                 -- doesn't exist, so we don't have a lock\n+     *     INSERT new logical resource     -- create the record - if OK, we own the lock\n+     *     IF DUPLICATE THEN               -- someone else beat us to the create\n+     *       SELECT FOR UPDATE             -- so we need to try again for a write lock\n+     *     ...\n+     *   ...\n+     * </pre>\n+     *\n+     * This works because we never delete a logical_resource record, and so don't have to deal\n+     * with concurrency issues caused when deletes are mingled with inserts/updates\n+     *\n+     * Note the execution flow aligns very closely with the DB2 stored procedure\n+     * implementation (fhir-persistence-schema/src/main/resources/add_any_resource.sql)\n+     *\n+     * @param tablePrefix\n+     * @param parameters\n+     * @param p_logical_id\n+     * @param p_payload\n+     * @param p_last_updated\n+     * @param p_is_deleted\n+     * @param p_source_key\n+     * @param p_version\n+     *\n+     * @return the resource_id for the entry we created\n+     * @throws Exception\n+     */\n+    public long storeResource(String tablePrefix, List<ExtractedParameterValue> parameters, String p_logical_id, byte[] p_payload, Timestamp p_last_updated, boolean p_is_deleted,\n+        String p_source_key, Integer p_version, Connection conn) throws Exception {\n+\n+        final String METHODNAME = \"storeResource() for \" + tablePrefix + \" resource\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Long v_logical_resource_id = null;\n+        Long v_current_resource_id = null;\n+        Long v_resource_id = null;\n+        Integer v_resource_type_id = null;\n+        boolean v_new_resource = false;\n+        boolean v_not_found = false;\n+        boolean v_duplicate = false;\n+        int v_version = 0;\n+        int v_insert_version = 0;\n+\n+        String v_resource_type = tablePrefix;\n+\n+        // Map the resource type name to the normalized id value in the database\n+        v_resource_type_id = getResourceTypeId(v_resource_type, conn);\n+        if (v_resource_type_id == null) {\n+            // programming error, as this should've been created earlier\n+            throw new IllegalStateException(\"resource type not found: \" + v_resource_type);\n+        }\n+\n+        // Get a lock at the system-wide logical resource level. Note the Derby-specific syntax\n+        final String SELECT_FOR_UPDATE = \"SELECT logical_resource_id FROM logical_resources WHERE resource_type_id = ? AND logical_id = ? FOR UPDATE\";\n+        try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+            stmt.setInt(1, v_resource_type_id);\n+            stmt.setString(2, p_logical_id);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                v_logical_resource_id = rs.getLong(1);\n+            }\n+            else {\n+                v_not_found = true;\n+                v_logical_resource_id = -1L; // just to be careful\n+            }\n+        }\n+\n+        // Create the logical resource if we don't have it already\n+        if (v_not_found) {\n+            // grab the id we want to use for the new logical resource instance\n+            final String sql2 = \"SELECT nextval('fhir_sequence')\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_logical_resource_id = res.getLong(1);\n+                }\n+                else {\n+                    // not going to happen, unless someone butchers the statement being executed\n+                    throw new IllegalStateException(\"VALUES failed to return a row: \" + sql2);\n+                }\n+            }\n+\n+            try {\n+                // insert the system-wide logical resource record.\n+                final String sql3 = \"INSERT INTO logical_resources (logical_resource_id, resource_type_id, logical_id) VALUES (?, ?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setInt(2, v_resource_type_id);\n+                    stmt.setString(3, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (translator.isDuplicate(e)) {\n+                    v_duplicate = true;\n+                }\n+                else {\n+                    throw e;\n+                }\n+            }\n+\n+            /**\n+             * remember that we have a concurrent system...so there is a possibility\n+             * that another thread snuck in before us and created the logical resource. This\n+             * is easy to handle, just turn around and read it\n+             */\n+            if (v_duplicate) {\n+                try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+                    // bind parameters\n+                    stmt.setInt(1, v_resource_type_id);\n+                    stmt.setString(2, p_logical_id);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        v_logical_resource_id = res.getLong(1);\n+                    }\n+                    else {\n+                        // Extremely unlikely as we should never delete logical resource records\n+                        throw new IllegalStateException(\"Logical resource was deleted: \" + tablePrefix + \"/\" + p_logical_id);\n+                    }\n+                }\n+            }\n+            else {\n+                v_new_resource = true;\n+\n+                // Insert the resource-specific logical resource record. Remember that logical_id is denormalized\n+                // so it gets stored again here for convenience\n+                final String sql3 = \"INSERT INTO \" + tablePrefix + \"_logical_resources (logical_resource_id, logical_id) VALUES (?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setString(2, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            }\n+        }\n+\n+        if (!v_new_resource) {\n+            // existing resource.  We need to know the current version from the\n+            // resource-specific logical resources table.\n+            final String sql3 = \"SELECT current_resource_id FROM \" + tablePrefix + \"_logical_resources WHERE logical_resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                stmt.setLong(1, v_logical_resource_id);\n+                ResultSet rs = stmt.executeQuery();\n+                if (rs.next()) {\n+                    v_current_resource_id = rs.getLong(1);\n+                }\n+                else {\n+                    // This database is broken, because we shouldn't have logical_resource records without\n+                    // corresponding resource-specific logical_resource records.\n+                    throw new SQLException(\"Logical_id record '\" + p_logical_id + \"' missing for resource \" + tablePrefix);\n+                }\n+            }\n+\n+            // so if we are storing a specific version, do a quick check to make\n+            // sure that this version doesn't currently exist. This is only done when processing\n+            // replication messages which might be duplicated. We want the operation to be idempotent,\n+            // so if the resource already exists, we don't need to do anything else.\n+\n+            if (p_version != null) {\n+                final String sqlStmt = \"SELECT resource_id FROM \" + tablePrefix + \"_resources dr WHERE dr.logical_resource_id = ? AND dr.version_id = ?\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sqlStmt)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setLong(2, p_version);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        // this version of this resource already exists, so we bail out right away\n+                        v_resource_id = res.getLong(1);\n+                        return v_resource_id;\n+                    }\n+                }\n+            }\n+\n+            // Grab the version value for the current version (identified by v_current_resource_id)\n+            final String sql4 = \"SELECT version_id FROM \" + tablePrefix + \"_resources WHERE resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql4)) {\n+                stmt.setLong(1, v_current_resource_id);\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_version = res.getInt(1);\n+                }\n+                else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 364}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NjAzOTkwOnYy", "diffSide": "RIGHT", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0MTo0MFrOGIX-GQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0MTo0MFrOGIX-GQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzNDUyMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    }\n          \n          \n            \n                    else {\n          \n          \n            \n                    } else {", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411434521", "createdAt": "2020-04-20T14:41:40Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,533 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an Apache PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+\n+    }\n+\n+    /**\n+     * Store the resource in the database, creating a new logical_resource entry if this is\n+     * the first version of this resource, or creating a new resource entry if this a new\n+     * version of an existing logical resource. The logic tracks closely the DB2 stored\n+     * procedure implementation, including locking of the logical_resource and handling\n+     * concurrency issues using the standard insert-or-update pattern:\n+     * <pre>\n+     *   SELECT FOR UPDATE                 -- try and get a write lock\n+     *   IF NOT FOUND THEN                 -- doesn't exist, so we don't have a lock\n+     *     INSERT new logical resource     -- create the record - if OK, we own the lock\n+     *     IF DUPLICATE THEN               -- someone else beat us to the create\n+     *       SELECT FOR UPDATE             -- so we need to try again for a write lock\n+     *     ...\n+     *   ...\n+     * </pre>\n+     *\n+     * This works because we never delete a logical_resource record, and so don't have to deal\n+     * with concurrency issues caused when deletes are mingled with inserts/updates\n+     *\n+     * Note the execution flow aligns very closely with the DB2 stored procedure\n+     * implementation (fhir-persistence-schema/src/main/resources/add_any_resource.sql)\n+     *\n+     * @param tablePrefix\n+     * @param parameters\n+     * @param p_logical_id\n+     * @param p_payload\n+     * @param p_last_updated\n+     * @param p_is_deleted\n+     * @param p_source_key\n+     * @param p_version\n+     *\n+     * @return the resource_id for the entry we created\n+     * @throws Exception\n+     */\n+    public long storeResource(String tablePrefix, List<ExtractedParameterValue> parameters, String p_logical_id, byte[] p_payload, Timestamp p_last_updated, boolean p_is_deleted,\n+        String p_source_key, Integer p_version, Connection conn) throws Exception {\n+\n+        final String METHODNAME = \"storeResource() for \" + tablePrefix + \" resource\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Long v_logical_resource_id = null;\n+        Long v_current_resource_id = null;\n+        Long v_resource_id = null;\n+        Integer v_resource_type_id = null;\n+        boolean v_new_resource = false;\n+        boolean v_not_found = false;\n+        boolean v_duplicate = false;\n+        int v_version = 0;\n+        int v_insert_version = 0;\n+\n+        String v_resource_type = tablePrefix;\n+\n+        // Map the resource type name to the normalized id value in the database\n+        v_resource_type_id = getResourceTypeId(v_resource_type, conn);\n+        if (v_resource_type_id == null) {\n+            // programming error, as this should've been created earlier\n+            throw new IllegalStateException(\"resource type not found: \" + v_resource_type);\n+        }\n+\n+        // Get a lock at the system-wide logical resource level. Note the Derby-specific syntax\n+        final String SELECT_FOR_UPDATE = \"SELECT logical_resource_id FROM logical_resources WHERE resource_type_id = ? AND logical_id = ? FOR UPDATE\";\n+        try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+            stmt.setInt(1, v_resource_type_id);\n+            stmt.setString(2, p_logical_id);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                v_logical_resource_id = rs.getLong(1);\n+            }\n+            else {\n+                v_not_found = true;\n+                v_logical_resource_id = -1L; // just to be careful\n+            }\n+        }\n+\n+        // Create the logical resource if we don't have it already\n+        if (v_not_found) {\n+            // grab the id we want to use for the new logical resource instance\n+            final String sql2 = \"SELECT nextval('fhir_sequence')\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_logical_resource_id = res.getLong(1);\n+                }\n+                else {\n+                    // not going to happen, unless someone butchers the statement being executed\n+                    throw new IllegalStateException(\"VALUES failed to return a row: \" + sql2);\n+                }\n+            }\n+\n+            try {\n+                // insert the system-wide logical resource record.\n+                final String sql3 = \"INSERT INTO logical_resources (logical_resource_id, resource_type_id, logical_id) VALUES (?, ?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setInt(2, v_resource_type_id);\n+                    stmt.setString(3, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (translator.isDuplicate(e)) {\n+                    v_duplicate = true;\n+                }\n+                else {\n+                    throw e;\n+                }\n+            }\n+\n+            /**\n+             * remember that we have a concurrent system...so there is a possibility\n+             * that another thread snuck in before us and created the logical resource. This\n+             * is easy to handle, just turn around and read it\n+             */\n+            if (v_duplicate) {\n+                try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+                    // bind parameters\n+                    stmt.setInt(1, v_resource_type_id);\n+                    stmt.setString(2, p_logical_id);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        v_logical_resource_id = res.getLong(1);\n+                    }\n+                    else {\n+                        // Extremely unlikely as we should never delete logical resource records\n+                        throw new IllegalStateException(\"Logical resource was deleted: \" + tablePrefix + \"/\" + p_logical_id);\n+                    }\n+                }\n+            }\n+            else {\n+                v_new_resource = true;\n+\n+                // Insert the resource-specific logical resource record. Remember that logical_id is denormalized\n+                // so it gets stored again here for convenience\n+                final String sql3 = \"INSERT INTO \" + tablePrefix + \"_logical_resources (logical_resource_id, logical_id) VALUES (?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setString(2, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            }\n+        }\n+\n+        if (!v_new_resource) {\n+            // existing resource.  We need to know the current version from the\n+            // resource-specific logical resources table.\n+            final String sql3 = \"SELECT current_resource_id FROM \" + tablePrefix + \"_logical_resources WHERE logical_resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                stmt.setLong(1, v_logical_resource_id);\n+                ResultSet rs = stmt.executeQuery();\n+                if (rs.next()) {\n+                    v_current_resource_id = rs.getLong(1);\n+                }\n+                else {\n+                    // This database is broken, because we shouldn't have logical_resource records without\n+                    // corresponding resource-specific logical_resource records.\n+                    throw new SQLException(\"Logical_id record '\" + p_logical_id + \"' missing for resource \" + tablePrefix);\n+                }\n+            }\n+\n+            // so if we are storing a specific version, do a quick check to make\n+            // sure that this version doesn't currently exist. This is only done when processing\n+            // replication messages which might be duplicated. We want the operation to be idempotent,\n+            // so if the resource already exists, we don't need to do anything else.\n+\n+            if (p_version != null) {\n+                final String sqlStmt = \"SELECT resource_id FROM \" + tablePrefix + \"_resources dr WHERE dr.logical_resource_id = ? AND dr.version_id = ?\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sqlStmt)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setLong(2, p_version);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        // this version of this resource already exists, so we bail out right away\n+                        v_resource_id = res.getLong(1);\n+                        return v_resource_id;\n+                    }\n+                }\n+            }\n+\n+            // Grab the version value for the current version (identified by v_current_resource_id)\n+            final String sql4 = \"SELECT version_id FROM \" + tablePrefix + \"_resources WHERE resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql4)) {\n+                stmt.setLong(1, v_current_resource_id);\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_version = res.getInt(1);\n+                }\n+                else {\n+                    throw new IllegalStateException(\"current resource not found: \"\n+                            + tablePrefix + \"_resources.resource_id=\" + v_current_resource_id);\n+                }\n+            }\n+\n+            //If we have been passed a version number, this means that this is a replicated\n+            //resource, and so we only need to delete parameters if the given version is\n+            // later than the current version\n+            if (p_version == null || p_version > v_version) {\n+                // existing resource, so need to delete all its parameters\n+                // delete composites first, or else the foreign keys there restrict deletes on referenced tables\n+                deleteFromParameterTable(conn, tablePrefix + \"_composites\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_str_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_number_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_date_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_latlng_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_token_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_quantity_values\", v_logical_resource_id);\n+            }\n+        }\n+\n+        // Persist the data using the given version number if required\n+        if (p_version != null) {\n+            v_insert_version = p_version;\n+        }\n+        else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 390}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NjA0MTA1OnYy", "diffSide": "RIGHT", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0MTo0OVrOGIX-qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0MTo0OVrOGIX-qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzNDY2Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        }\n          \n          \n            \n                        else {\n          \n          \n            \n                        } else {", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411434667", "createdAt": "2020-04-20T14:41:49Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,533 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an Apache PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+\n+    }\n+\n+    /**\n+     * Store the resource in the database, creating a new logical_resource entry if this is\n+     * the first version of this resource, or creating a new resource entry if this a new\n+     * version of an existing logical resource. The logic tracks closely the DB2 stored\n+     * procedure implementation, including locking of the logical_resource and handling\n+     * concurrency issues using the standard insert-or-update pattern:\n+     * <pre>\n+     *   SELECT FOR UPDATE                 -- try and get a write lock\n+     *   IF NOT FOUND THEN                 -- doesn't exist, so we don't have a lock\n+     *     INSERT new logical resource     -- create the record - if OK, we own the lock\n+     *     IF DUPLICATE THEN               -- someone else beat us to the create\n+     *       SELECT FOR UPDATE             -- so we need to try again for a write lock\n+     *     ...\n+     *   ...\n+     * </pre>\n+     *\n+     * This works because we never delete a logical_resource record, and so don't have to deal\n+     * with concurrency issues caused when deletes are mingled with inserts/updates\n+     *\n+     * Note the execution flow aligns very closely with the DB2 stored procedure\n+     * implementation (fhir-persistence-schema/src/main/resources/add_any_resource.sql)\n+     *\n+     * @param tablePrefix\n+     * @param parameters\n+     * @param p_logical_id\n+     * @param p_payload\n+     * @param p_last_updated\n+     * @param p_is_deleted\n+     * @param p_source_key\n+     * @param p_version\n+     *\n+     * @return the resource_id for the entry we created\n+     * @throws Exception\n+     */\n+    public long storeResource(String tablePrefix, List<ExtractedParameterValue> parameters, String p_logical_id, byte[] p_payload, Timestamp p_last_updated, boolean p_is_deleted,\n+        String p_source_key, Integer p_version, Connection conn) throws Exception {\n+\n+        final String METHODNAME = \"storeResource() for \" + tablePrefix + \" resource\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Long v_logical_resource_id = null;\n+        Long v_current_resource_id = null;\n+        Long v_resource_id = null;\n+        Integer v_resource_type_id = null;\n+        boolean v_new_resource = false;\n+        boolean v_not_found = false;\n+        boolean v_duplicate = false;\n+        int v_version = 0;\n+        int v_insert_version = 0;\n+\n+        String v_resource_type = tablePrefix;\n+\n+        // Map the resource type name to the normalized id value in the database\n+        v_resource_type_id = getResourceTypeId(v_resource_type, conn);\n+        if (v_resource_type_id == null) {\n+            // programming error, as this should've been created earlier\n+            throw new IllegalStateException(\"resource type not found: \" + v_resource_type);\n+        }\n+\n+        // Get a lock at the system-wide logical resource level. Note the Derby-specific syntax\n+        final String SELECT_FOR_UPDATE = \"SELECT logical_resource_id FROM logical_resources WHERE resource_type_id = ? AND logical_id = ? FOR UPDATE\";\n+        try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+            stmt.setInt(1, v_resource_type_id);\n+            stmt.setString(2, p_logical_id);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                v_logical_resource_id = rs.getLong(1);\n+            }\n+            else {\n+                v_not_found = true;\n+                v_logical_resource_id = -1L; // just to be careful\n+            }\n+        }\n+\n+        // Create the logical resource if we don't have it already\n+        if (v_not_found) {\n+            // grab the id we want to use for the new logical resource instance\n+            final String sql2 = \"SELECT nextval('fhir_sequence')\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_logical_resource_id = res.getLong(1);\n+                }\n+                else {\n+                    // not going to happen, unless someone butchers the statement being executed\n+                    throw new IllegalStateException(\"VALUES failed to return a row: \" + sql2);\n+                }\n+            }\n+\n+            try {\n+                // insert the system-wide logical resource record.\n+                final String sql3 = \"INSERT INTO logical_resources (logical_resource_id, resource_type_id, logical_id) VALUES (?, ?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setInt(2, v_resource_type_id);\n+                    stmt.setString(3, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (translator.isDuplicate(e)) {\n+                    v_duplicate = true;\n+                }\n+                else {\n+                    throw e;\n+                }\n+            }\n+\n+            /**\n+             * remember that we have a concurrent system...so there is a possibility\n+             * that another thread snuck in before us and created the logical resource. This\n+             * is easy to handle, just turn around and read it\n+             */\n+            if (v_duplicate) {\n+                try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+                    // bind parameters\n+                    stmt.setInt(1, v_resource_type_id);\n+                    stmt.setString(2, p_logical_id);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        v_logical_resource_id = res.getLong(1);\n+                    }\n+                    else {\n+                        // Extremely unlikely as we should never delete logical resource records\n+                        throw new IllegalStateException(\"Logical resource was deleted: \" + tablePrefix + \"/\" + p_logical_id);\n+                    }\n+                }\n+            }\n+            else {\n+                v_new_resource = true;\n+\n+                // Insert the resource-specific logical resource record. Remember that logical_id is denormalized\n+                // so it gets stored again here for convenience\n+                final String sql3 = \"INSERT INTO \" + tablePrefix + \"_logical_resources (logical_resource_id, logical_id) VALUES (?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setString(2, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            }\n+        }\n+\n+        if (!v_new_resource) {\n+            // existing resource.  We need to know the current version from the\n+            // resource-specific logical resources table.\n+            final String sql3 = \"SELECT current_resource_id FROM \" + tablePrefix + \"_logical_resources WHERE logical_resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                stmt.setLong(1, v_logical_resource_id);\n+                ResultSet rs = stmt.executeQuery();\n+                if (rs.next()) {\n+                    v_current_resource_id = rs.getLong(1);\n+                }\n+                else {\n+                    // This database is broken, because we shouldn't have logical_resource records without\n+                    // corresponding resource-specific logical_resource records.\n+                    throw new SQLException(\"Logical_id record '\" + p_logical_id + \"' missing for resource \" + tablePrefix);\n+                }\n+            }\n+\n+            // so if we are storing a specific version, do a quick check to make\n+            // sure that this version doesn't currently exist. This is only done when processing\n+            // replication messages which might be duplicated. We want the operation to be idempotent,\n+            // so if the resource already exists, we don't need to do anything else.\n+\n+            if (p_version != null) {\n+                final String sqlStmt = \"SELECT resource_id FROM \" + tablePrefix + \"_resources dr WHERE dr.logical_resource_id = ? AND dr.version_id = ?\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sqlStmt)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setLong(2, p_version);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        // this version of this resource already exists, so we bail out right away\n+                        v_resource_id = res.getLong(1);\n+                        return v_resource_id;\n+                    }\n+                }\n+            }\n+\n+            // Grab the version value for the current version (identified by v_current_resource_id)\n+            final String sql4 = \"SELECT version_id FROM \" + tablePrefix + \"_resources WHERE resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql4)) {\n+                stmt.setLong(1, v_current_resource_id);\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_version = res.getInt(1);\n+                }\n+                else {\n+                    throw new IllegalStateException(\"current resource not found: \"\n+                            + tablePrefix + \"_resources.resource_id=\" + v_current_resource_id);\n+                }\n+            }\n+\n+            //If we have been passed a version number, this means that this is a replicated\n+            //resource, and so we only need to delete parameters if the given version is\n+            // later than the current version\n+            if (p_version == null || p_version > v_version) {\n+                // existing resource, so need to delete all its parameters\n+                // delete composites first, or else the foreign keys there restrict deletes on referenced tables\n+                deleteFromParameterTable(conn, tablePrefix + \"_composites\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_str_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_number_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_date_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_latlng_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_token_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_quantity_values\", v_logical_resource_id);\n+            }\n+        }\n+\n+        // Persist the data using the given version number if required\n+        if (p_version != null) {\n+            v_insert_version = p_version;\n+        }\n+        else {\n+            // remember we have a write (update) lock on the logical version, so we can safely calculate\n+            // the next version value here\n+            v_insert_version = v_version + 1;\n+\n+        }\n+\n+        /**\n+         * Create the new resource version.\n+         * Alpha version uses last_updated time from the app-server, so we keep that here\n+         */\n+        String sql2 = \"SELECT nextval('fhir_sequence')\";\n+        try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+            ResultSet res = stmt.executeQuery();\n+            if (res.next()) {\n+                v_resource_id = res.getLong(1); //Assign result of the above query\n+            }\n+            else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 407}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NjA0MTkyOnYy", "diffSide": "RIGHT", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0MjowM1rOGIX_Ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0MjowM1rOGIX_Ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzNDgxMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        }\n          \n          \n            \n                        else {\n          \n          \n            \n                            result = null;\n          \n          \n            \n                        } else {\n          \n          \n            \n                            result = null;", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411434811", "createdAt": "2020-04-20T14:42:03Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,533 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an Apache PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+\n+    }\n+\n+    /**\n+     * Store the resource in the database, creating a new logical_resource entry if this is\n+     * the first version of this resource, or creating a new resource entry if this a new\n+     * version of an existing logical resource. The logic tracks closely the DB2 stored\n+     * procedure implementation, including locking of the logical_resource and handling\n+     * concurrency issues using the standard insert-or-update pattern:\n+     * <pre>\n+     *   SELECT FOR UPDATE                 -- try and get a write lock\n+     *   IF NOT FOUND THEN                 -- doesn't exist, so we don't have a lock\n+     *     INSERT new logical resource     -- create the record - if OK, we own the lock\n+     *     IF DUPLICATE THEN               -- someone else beat us to the create\n+     *       SELECT FOR UPDATE             -- so we need to try again for a write lock\n+     *     ...\n+     *   ...\n+     * </pre>\n+     *\n+     * This works because we never delete a logical_resource record, and so don't have to deal\n+     * with concurrency issues caused when deletes are mingled with inserts/updates\n+     *\n+     * Note the execution flow aligns very closely with the DB2 stored procedure\n+     * implementation (fhir-persistence-schema/src/main/resources/add_any_resource.sql)\n+     *\n+     * @param tablePrefix\n+     * @param parameters\n+     * @param p_logical_id\n+     * @param p_payload\n+     * @param p_last_updated\n+     * @param p_is_deleted\n+     * @param p_source_key\n+     * @param p_version\n+     *\n+     * @return the resource_id for the entry we created\n+     * @throws Exception\n+     */\n+    public long storeResource(String tablePrefix, List<ExtractedParameterValue> parameters, String p_logical_id, byte[] p_payload, Timestamp p_last_updated, boolean p_is_deleted,\n+        String p_source_key, Integer p_version, Connection conn) throws Exception {\n+\n+        final String METHODNAME = \"storeResource() for \" + tablePrefix + \" resource\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Long v_logical_resource_id = null;\n+        Long v_current_resource_id = null;\n+        Long v_resource_id = null;\n+        Integer v_resource_type_id = null;\n+        boolean v_new_resource = false;\n+        boolean v_not_found = false;\n+        boolean v_duplicate = false;\n+        int v_version = 0;\n+        int v_insert_version = 0;\n+\n+        String v_resource_type = tablePrefix;\n+\n+        // Map the resource type name to the normalized id value in the database\n+        v_resource_type_id = getResourceTypeId(v_resource_type, conn);\n+        if (v_resource_type_id == null) {\n+            // programming error, as this should've been created earlier\n+            throw new IllegalStateException(\"resource type not found: \" + v_resource_type);\n+        }\n+\n+        // Get a lock at the system-wide logical resource level. Note the Derby-specific syntax\n+        final String SELECT_FOR_UPDATE = \"SELECT logical_resource_id FROM logical_resources WHERE resource_type_id = ? AND logical_id = ? FOR UPDATE\";\n+        try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+            stmt.setInt(1, v_resource_type_id);\n+            stmt.setString(2, p_logical_id);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                v_logical_resource_id = rs.getLong(1);\n+            }\n+            else {\n+                v_not_found = true;\n+                v_logical_resource_id = -1L; // just to be careful\n+            }\n+        }\n+\n+        // Create the logical resource if we don't have it already\n+        if (v_not_found) {\n+            // grab the id we want to use for the new logical resource instance\n+            final String sql2 = \"SELECT nextval('fhir_sequence')\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_logical_resource_id = res.getLong(1);\n+                }\n+                else {\n+                    // not going to happen, unless someone butchers the statement being executed\n+                    throw new IllegalStateException(\"VALUES failed to return a row: \" + sql2);\n+                }\n+            }\n+\n+            try {\n+                // insert the system-wide logical resource record.\n+                final String sql3 = \"INSERT INTO logical_resources (logical_resource_id, resource_type_id, logical_id) VALUES (?, ?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setInt(2, v_resource_type_id);\n+                    stmt.setString(3, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (translator.isDuplicate(e)) {\n+                    v_duplicate = true;\n+                }\n+                else {\n+                    throw e;\n+                }\n+            }\n+\n+            /**\n+             * remember that we have a concurrent system...so there is a possibility\n+             * that another thread snuck in before us and created the logical resource. This\n+             * is easy to handle, just turn around and read it\n+             */\n+            if (v_duplicate) {\n+                try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+                    // bind parameters\n+                    stmt.setInt(1, v_resource_type_id);\n+                    stmt.setString(2, p_logical_id);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        v_logical_resource_id = res.getLong(1);\n+                    }\n+                    else {\n+                        // Extremely unlikely as we should never delete logical resource records\n+                        throw new IllegalStateException(\"Logical resource was deleted: \" + tablePrefix + \"/\" + p_logical_id);\n+                    }\n+                }\n+            }\n+            else {\n+                v_new_resource = true;\n+\n+                // Insert the resource-specific logical resource record. Remember that logical_id is denormalized\n+                // so it gets stored again here for convenience\n+                final String sql3 = \"INSERT INTO \" + tablePrefix + \"_logical_resources (logical_resource_id, logical_id) VALUES (?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setString(2, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            }\n+        }\n+\n+        if (!v_new_resource) {\n+            // existing resource.  We need to know the current version from the\n+            // resource-specific logical resources table.\n+            final String sql3 = \"SELECT current_resource_id FROM \" + tablePrefix + \"_logical_resources WHERE logical_resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                stmt.setLong(1, v_logical_resource_id);\n+                ResultSet rs = stmt.executeQuery();\n+                if (rs.next()) {\n+                    v_current_resource_id = rs.getLong(1);\n+                }\n+                else {\n+                    // This database is broken, because we shouldn't have logical_resource records without\n+                    // corresponding resource-specific logical_resource records.\n+                    throw new SQLException(\"Logical_id record '\" + p_logical_id + \"' missing for resource \" + tablePrefix);\n+                }\n+            }\n+\n+            // so if we are storing a specific version, do a quick check to make\n+            // sure that this version doesn't currently exist. This is only done when processing\n+            // replication messages which might be duplicated. We want the operation to be idempotent,\n+            // so if the resource already exists, we don't need to do anything else.\n+\n+            if (p_version != null) {\n+                final String sqlStmt = \"SELECT resource_id FROM \" + tablePrefix + \"_resources dr WHERE dr.logical_resource_id = ? AND dr.version_id = ?\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sqlStmt)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setLong(2, p_version);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        // this version of this resource already exists, so we bail out right away\n+                        v_resource_id = res.getLong(1);\n+                        return v_resource_id;\n+                    }\n+                }\n+            }\n+\n+            // Grab the version value for the current version (identified by v_current_resource_id)\n+            final String sql4 = \"SELECT version_id FROM \" + tablePrefix + \"_resources WHERE resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql4)) {\n+                stmt.setLong(1, v_current_resource_id);\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_version = res.getInt(1);\n+                }\n+                else {\n+                    throw new IllegalStateException(\"current resource not found: \"\n+                            + tablePrefix + \"_resources.resource_id=\" + v_current_resource_id);\n+                }\n+            }\n+\n+            //If we have been passed a version number, this means that this is a replicated\n+            //resource, and so we only need to delete parameters if the given version is\n+            // later than the current version\n+            if (p_version == null || p_version > v_version) {\n+                // existing resource, so need to delete all its parameters\n+                // delete composites first, or else the foreign keys there restrict deletes on referenced tables\n+                deleteFromParameterTable(conn, tablePrefix + \"_composites\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_str_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_number_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_date_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_latlng_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_token_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_quantity_values\", v_logical_resource_id);\n+            }\n+        }\n+\n+        // Persist the data using the given version number if required\n+        if (p_version != null) {\n+            v_insert_version = p_version;\n+        }\n+        else {\n+            // remember we have a write (update) lock on the logical version, so we can safely calculate\n+            // the next version value here\n+            v_insert_version = v_version + 1;\n+\n+        }\n+\n+        /**\n+         * Create the new resource version.\n+         * Alpha version uses last_updated time from the app-server, so we keep that here\n+         */\n+        String sql2 = \"SELECT nextval('fhir_sequence')\";\n+        try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+            ResultSet res = stmt.executeQuery();\n+            if (res.next()) {\n+                v_resource_id = res.getLong(1); //Assign result of the above query\n+            }\n+            else {\n+                // unlikely\n+                throw new IllegalStateException(\"no row returned: \" + sql2);\n+            }\n+        }\n+\n+        // Finally we get to the big resource data insert\n+        String sql3 = \"INSERT INTO \" + tablePrefix + \"_resources (resource_id, logical_resource_id, version_id, data, last_updated, is_deleted) \"\n+                + \"VALUES (?,?,?,?,?,?)\";\n+        try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+            // bind parameters\n+            stmt.setLong(1, v_resource_id);\n+            stmt.setLong(2, v_logical_resource_id);\n+            stmt.setInt(3, v_insert_version);\n+            stmt.setBytes(4, p_payload);\n+            stmt.setTimestamp(5, p_last_updated, UTC);\n+            stmt.setString(6, p_is_deleted ? \"Y\" : \"N\");\n+            stmt.executeUpdate();\n+        }\n+\n+        if (p_version == null || p_version > v_version) {\n+            //only update the logical resource if the resource we are adding supercedes the\n+            //current resource\n+            String sql4 = \"UPDATE \" + tablePrefix + \"_logical_resources SET current_resource_id = ? WHERE logical_resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql4)) {\n+                // bind parameters\n+                stmt.setLong(1, v_resource_id);\n+                stmt.setLong(2, v_logical_resource_id);\n+                stmt.executeUpdate();\n+            }\n+\n+            // To keep things simple for the Derby use-case, we just use a visitor to\n+            // handle inserts of parameters directly in the resource parameter tables.\n+            // Note we don't get any parameters for the resource soft-delete operation\n+            if (parameters != null) {\n+                // Derby doesn't support partitioned multi-tenancy, so we disable it on the DAO:\n+                try (ParameterVisitorBatchDAO pvd = new ParameterVisitorBatchDAO(conn, null, tablePrefix, false, v_logical_resource_id, 100,\n+                    new ParameterNameCacheAdapter(parameterNameDAO), new CodeSystemCacheAdapter(codeSystemDAO))) {\n+                    for (ExtractedParameterValue p: parameters) {\n+                        p.accept(pvd);\n+                    }\n+                }\n+            }\n+        }\n+        logger.exiting(CLASSNAME, METHODNAME);\n+        return v_resource_id;\n+    }\n+\n+\n+    /**\n+     * Delete all parameters for the given resourceId from the parameters table\n+     *\n+     * @param conn\n+     * @param tableName\n+     * @param logicalResourceId\n+     * @throws SQLException\n+     */\n+    protected void deleteFromParameterTable(Connection conn, String tableName, long logicalResourceId) throws SQLException {\n+        final String delStrValues = \"DELETE FROM \" + tableName + \" WHERE logical_resource_id = ?\";\n+        try (PreparedStatement stmt = conn.prepareStatement(delStrValues)) {\n+            // bind parameters\n+            stmt.setLong(1, logicalResourceId);\n+            stmt.executeUpdate();\n+        }\n+\n+    }\n+\n+    /**\n+     * Read the id for the named type\n+     * @param resourceTypeName\n+     * @return the database id, or null if the named record is not found\n+     * @throws SQLException\n+     */\n+    protected Integer getResourceTypeId(String resourceTypeName, Connection conn) throws SQLException {\n+        Integer result;\n+\n+        final String sql1 = \"SELECT resource_type_id FROM resource_types WHERE resource_type = ?\";\n+\n+        try (PreparedStatement stmt = conn.prepareStatement(sql1)) {\n+            stmt.setString(1, resourceTypeName);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                result = rs.getInt(1);\n+            }\n+            else {\n+                result = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 492}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NjA1MTY0OnYy", "diffSide": "RIGHT", "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/app/Main.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0Mzo1N1rOGIYFLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNzo1ODowNFrOGIgxwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzNjMzMw==", "bodyText": "no grants?\nIf we are not implementing here, we should create a backlog issue.", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411436333", "createdAt": "2020-04-20T14:43:57Z", "author": {"login": "prb112"}, "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/app/Main.java", "diffHunk": "@@ -765,7 +778,7 @@ protected void process() {\n      * @param groupName\n      */\n     protected void grantPrivileges(String groupName) {\n-        if (dbType == DbType.DERBY) {\n+        if (dbType == DbType.DERBY || dbType == DbType.POSTGRESQL) {\n             return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ0NDY0NQ==", "bodyText": "yes, not needed in my test for the postgresql support.\naccording to my instruction, fhirserver user is grant full access to the database, and also create/update schema uses fhirserver user. so seems no access issue for postgresql so far.", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411444645", "createdAt": "2020-04-20T14:54:16Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/app/Main.java", "diffHunk": "@@ -765,7 +778,7 @@ protected void process() {\n      * @param groupName\n      */\n     protected void grantPrivileges(String groupName) {\n-        if (dbType == DbType.DERBY) {\n+        if (dbType == DbType.DERBY || dbType == DbType.POSTGRESQL) {\n             return;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzNjMzMw=="}, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU3ODgxOA==", "bodyText": "added issue #946 for this", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411578818", "createdAt": "2020-04-20T17:58:04Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/app/Main.java", "diffHunk": "@@ -765,7 +778,7 @@ protected void process() {\n      * @param groupName\n      */\n     protected void grantPrivileges(String groupName) {\n-        if (dbType == DbType.DERBY) {\n+        if (dbType == DbType.DERBY || dbType == DbType.POSTGRESQL) {\n             return;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzNjMzMw=="}, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NjA1NTQ1OnYy", "diffSide": "RIGHT", "path": "fhir-persistence-jdbc/src/test/resources/test.jdbc-perform.properties", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0NDo0OFrOGIYHlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0NDo0OFrOGIYHlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzNjk1MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411436951", "createdAt": "2020-04-20T14:44:48Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/test/resources/test.jdbc-perform.properties", "diffHunk": "@@ -6,14 +6,23 @@\n #Don't need any configuration for derby embedded\n \n #Derby network properties\n-#dbUrl=jdbc:derby://localhost:1527/fhirdb\n+#dbUrl = jdbc:derby://localhost:1527/fhirdb\n \n #DB2 properties\n-dbDriverName=com.ibm.db2.jcc.DB2Driver\n-db.host=localhost\n-db.port=50000\n-db.database=fhirdb\n-user=db2inst1\n-password=change-password\n+db.host = localhost\n+db.port = 50000\n+db.database = fhirdb\n+user = db2inst1\n+password = change-password\n+\n+#PostgreSql properties\n+#db.host = localhost\n+#db.port = 5432\n+#db.database = fhirdb\n+#user = postgre\n+#password = change-password\n+\n+\n+#Common properties\n updateCreateEnabled=true\n-schemaName=FHIRDATA\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NjA3NTM3OnYy", "diffSide": "RIGHT", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/FHIRResourceDAOFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0ODozOFrOGIYTkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0OToxMlrOGIYVYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ0MDAxNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    public static FHIRResourceDAOType of(Connection con) throws SQLException, IllegalArgumentException {\n          \n          \n            \n                        String dbUrl = con.getMetaData().getURL();\n          \n          \n            \n                        dbUrl = dbUrl.toLowerCase();\n          \n          \n            \n                        if (dbUrl.contains(DB2.value)) {\n          \n          \n            \n                            return DB2;\n          \n          \n            \n                        } else if (dbUrl.contains(DERBY.value)) {\n          \n          \n            \n                            return DERBY;\n          \n          \n            \n                        } else if (dbUrl.contains(POSTGRESQL.value)) {\n          \n          \n            \n                            return POSTGRESQL;\n          \n          \n            \n                        } else {\n          \n          \n            \n                            throw new IllegalArgumentException(dbUrl);\n          \n          \n            \n                        }\n          \n          \n            \n            \n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n                    public static FHIRResourceDAOType of(Connection conn) throws SQLException, IllegalArgumentException {\n          \n          \n            \n                        String dbUrl = conn.getMetaData().getURL();\n          \n          \n            \n                        dbUrl = dbUrl.toLowerCase();\n          \n          \n            \n                        if (dbUrl.contains(DB2.value)) {\n          \n          \n            \n                            return DB2;\n          \n          \n            \n                        } else if (dbUrl.contains(DERBY.value)) {\n          \n          \n            \n                            return DERBY;\n          \n          \n            \n                        } else if (dbUrl.contains(POSTGRESQL.value)) {\n          \n          \n            \n                            return POSTGRESQL;\n          \n          \n            \n                        } else {\n          \n          \n            \n                            throw new IllegalArgumentException(dbUrl);\n          \n          \n            \n                        }\n          \n          \n            \n            \n          \n          \n            \n                    }\n          \n          \n            \n                }", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411440016", "createdAt": "2020-04-20T14:48:38Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/FHIRResourceDAOFactory.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.persistence.jdbc.dao.api.ResourceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyResourceDAO;\n+import com.ibm.fhir.persistence.jdbc.postgresql.PostgreSqlResourceDAO;\n+\n+public class FHIRResourceDAOFactory {\n+\n+    // The various DAO Types that are used in the JDBC Persistence layer. \n+    public enum DAOType {\n+        DB2(\"db2\"),\n+        DERBY(\"derby\"),\n+        POSTGRESQL(\"postgresql\");\n+\n+        private final String value;\n+\n+        FHIRResourceDAOType(String value) {\n+            this.value = value;\n+        }\n+\n+        public String value() {\n+            return value;\n+        }\n+\n+        public static FHIRResourceDAOType of(Connection con) throws SQLException, IllegalArgumentException {\n+            String dbUrl = con.getMetaData().getURL();\n+            dbUrl = dbUrl.toLowerCase();\n+            if (dbUrl.contains(DB2.value)) {\n+                return DB2;\n+            } else if (dbUrl.contains(DERBY.value)) {\n+                return DERBY;\n+            } else if (dbUrl.contains(POSTGRESQL.value)) {\n+                return POSTGRESQL;\n+            } else {\n+                throw new IllegalArgumentException(dbUrl);\n+            }\n+\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91735b41e84b1932c6512ca41ddbfbd33c4ce73a"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ0MDQ4Mw==", "bodyText": "might be worthwhile to have a null check at the very beginning.", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411440483", "createdAt": "2020-04-20T14:49:12Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/FHIRResourceDAOFactory.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.persistence.jdbc.dao.api.ResourceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyResourceDAO;\n+import com.ibm.fhir.persistence.jdbc.postgresql.PostgreSqlResourceDAO;\n+\n+public class FHIRResourceDAOFactory {\n+\n+    // The various DAO Types that are used in the JDBC Persistence layer. \n+    public enum DAOType {\n+        DB2(\"db2\"),\n+        DERBY(\"derby\"),\n+        POSTGRESQL(\"postgresql\");\n+\n+        private final String value;\n+\n+        FHIRResourceDAOType(String value) {\n+            this.value = value;\n+        }\n+\n+        public String value() {\n+            return value;\n+        }\n+\n+        public static FHIRResourceDAOType of(Connection con) throws SQLException, IllegalArgumentException {\n+            String dbUrl = con.getMetaData().getURL();\n+            dbUrl = dbUrl.toLowerCase();\n+            if (dbUrl.contains(DB2.value)) {\n+                return DB2;\n+            } else if (dbUrl.contains(DERBY.value)) {\n+                return DERBY;\n+            } else if (dbUrl.contains(POSTGRESQL.value)) {\n+                return POSTGRESQL;\n+            } else {\n+                throw new IllegalArgumentException(dbUrl);\n+            }\n+\n+        }\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ0MDAxNg=="}, "originalCommit": {"oid": "91735b41e84b1932c6512ca41ddbfbd33c4ce73a"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NjA4MjI0OnYy", "diffSide": "RIGHT", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/FHIRResourceDAOFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo1MDowMFrOGIYX2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo1MDowMFrOGIYX2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ0MTExMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static ResourceDAO getResourceDAO (Connection con) throws IllegalArgumentException, SQLException {\n          \n          \n            \n                    ResourceDAO resourceDAO = null;\n          \n          \n            \n                    switch (FHIRResourceDAOType.of(con)) {\n          \n          \n            \n                        case DB2:\n          \n          \n            \n                            resourceDAO = new ResourceDAOImpl(con);\n          \n          \n            \n                            break;\n          \n          \n            \n                        case DERBY:\n          \n          \n            \n                            resourceDAO = new DerbyResourceDAO(con);\n          \n          \n            \n                            break;\n          \n          \n            \n                        case POSTGRESQL:\n          \n          \n            \n                            resourceDAO = new PostgreSqlResourceDAO(con);\n          \n          \n            \n                            break;\n          \n          \n            \n                    }\n          \n          \n            \n                    return resourceDAO;\n          \n          \n            \n                }\n          \n          \n            \n                public static ResourceDAO getResourceDAO (Connection conn) throws IllegalArgumentException, SQLException {\n          \n          \n            \n                    ResourceDAO resourceDAO = null;\n          \n          \n            \n                    switch (FHIRResourceDAOType.of(conn)) {\n          \n          \n            \n                        case DB2:\n          \n          \n            \n                            resourceDAO = new ResourceDAOImpl(conn);\n          \n          \n            \n                            break;\n          \n          \n            \n                        case DERBY:\n          \n          \n            \n                            resourceDAO = new DerbyResourceDAO(conn);\n          \n          \n            \n                            break;\n          \n          \n            \n                        case POSTGRESQL:\n          \n          \n            \n                            resourceDAO = new PostgreSqlResourceDAO(conn);\n          \n          \n            \n                            break;\n          \n          \n            \n                    }\n          \n          \n            \n                    return resourceDAO;\n          \n          \n            \n                }", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411441113", "createdAt": "2020-04-20T14:50:00Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/FHIRResourceDAOFactory.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.persistence.jdbc.dao.api.ResourceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyResourceDAO;\n+import com.ibm.fhir.persistence.jdbc.postgresql.PostgreSqlResourceDAO;\n+\n+public class FHIRResourceDAOFactory {\n+\n+    // The various DAO Types that are used in the JDBC Persistence layer. \n+    public enum DAOType {\n+        DB2(\"db2\"),\n+        DERBY(\"derby\"),\n+        POSTGRESQL(\"postgresql\");\n+\n+        private final String value;\n+\n+        FHIRResourceDAOType(String value) {\n+            this.value = value;\n+        }\n+\n+        public String value() {\n+            return value;\n+        }\n+\n+        public static FHIRResourceDAOType of(Connection con) throws SQLException, IllegalArgumentException {\n+            String dbUrl = con.getMetaData().getURL();\n+            dbUrl = dbUrl.toLowerCase();\n+            if (dbUrl.contains(DB2.value)) {\n+                return DB2;\n+            } else if (dbUrl.contains(DERBY.value)) {\n+                return DERBY;\n+            } else if (dbUrl.contains(POSTGRESQL.value)) {\n+                return POSTGRESQL;\n+            } else {\n+                throw new IllegalArgumentException(dbUrl);\n+            }\n+\n+        }\n+    }\n+\n+   public static ResourceDAO getResourceDAO (Connection conn, TransactionSynchronizationRegistry trxSynchRegistry) throws IllegalArgumentException, SQLException {\n+        ResourceDAO resourceDAO = null;\n+        switch (FHIRResourceDAOType.of(con)) {\n+            case DB2:\n+                resourceDAO = new ResourceDAOImpl(trxSynchRegistry);\n+                break;\n+            case DERBY:\n+                resourceDAO = new DerbyResourceDAO(trxSynchRegistry);\n+                break;\n+            case POSTGRESQL:\n+                resourceDAO = new PostgreSqlResourceDAO(trxSynchRegistry);\n+                break;\n+        }\n+        return resourceDAO;\n+    }\n+\n+    public static ResourceDAO getResourceDAO (Connection con) throws IllegalArgumentException, SQLException {\n+        ResourceDAO resourceDAO = null;\n+        switch (FHIRResourceDAOType.of(con)) {\n+            case DB2:\n+                resourceDAO = new ResourceDAOImpl(con);\n+                break;\n+            case DERBY:\n+                resourceDAO = new DerbyResourceDAO(con);\n+                break;\n+            case POSTGRESQL:\n+                resourceDAO = new PostgreSqlResourceDAO(con);\n+                break;\n+        }\n+        return resourceDAO;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91735b41e84b1932c6512ca41ddbfbd33c4ce73a"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NjA4NzQwOnYy", "diffSide": "RIGHT", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/FhirSequenceDAOImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo1MDo1OFrOGIYa7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo1MDo1OFrOGIYa7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ0MTkwMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        }\n          \n          \n            \n                        else {\n          \n          \n            \n                        } else {", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411441900", "createdAt": "2020-04-20T14:50:58Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/FhirSequenceDAOImpl.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirSequenceDAO;\n+\n+/**\n+ * DAO to obtain the next value from FHIR_SEQUENCE\n+ */\n+public class FhirSequenceDAOImpl implements FhirSequenceDAO {\n+    private final Connection conn;\n+\n+    /**\n+     * Public constructor\n+     */\n+    public FhirSequenceDAOImpl(Connection c) {\n+        this.conn = c;\n+    }\n+\n+    @Override\n+    public long nextValue() throws SQLException {\n+        long result;\n+        final String SEQ = \"select nextval('fhir_sequence')\";\n+\n+        try (PreparedStatement stmt = conn.prepareStatement(SEQ)) {\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                result = rs.getLong(1);\n+            }\n+            else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "861db13b68349b21a0bfcaff0945ee48d74fde2c"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NjE0MzIxOnYy", "diffSide": "RIGHT", "path": "fhir-persistence-schema/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNTowMTozN1rOGIY8lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNTowMTozN1rOGIY8lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ1MDUxOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Builds and manages the multi-tenant FHIR R4 RDBMS schema (Db2), includes creates and updates schema for PostgreSql, also includes Derby support for use in tests.\n          \n          \n            \n            Builds and manages the multi-tenant FHIR R4 RDBMS schema for Db2 and PostgreSQL and includes Derby support for testing.", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411450519", "createdAt": "2020-04-20T15:01:37Z", "author": {"login": "prb112"}, "path": "fhir-persistence-schema/README.md", "diffHunk": "@@ -1,13 +1,13 @@\n # IBM FHIR Server - fhir-persistence-schema\n \n-Builds and manages the multi-tenant FHIR R4 RDBMS schema (Db2). Includes Derby support for use in tests.\n+Builds and manages the multi-tenant FHIR R4 RDBMS schema (Db2), includes creates and updates schema for PostgreSql, also includes Derby support for use in tests.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "861db13b68349b21a0bfcaff0945ee48d74fde2c"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NjE0ODM4OnYy", "diffSide": "RIGHT", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNTowMjozNlrOGIY_mQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNTowMjozNlrOGIY_mQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ1MTI4OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n      \n    \n    \n  \n\nunneeded line", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411451289", "createdAt": "2020-04-20T15:02:36Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,524 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "861db13b68349b21a0bfcaff0945ee48d74fde2c"}, "originalPosition": 173}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NjE2MTk0OnYy", "diffSide": "RIGHT", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNTowNTowMlrOGIZHkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNTowNTowMlrOGIZHkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ1MzMyOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * Alpha version uses last_updated time from the app-server, so we keep that here\n          \n          \n            \n                     * uses last_updated time from the app-server, so we have consistency between the various DAOs", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411453328", "createdAt": "2020-04-20T15:05:02Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,524 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+\n+    }\n+\n+    /**\n+     * Store the resource in the database, creating a new logical_resource entry if this is\n+     * the first version of this resource, or creating a new resource entry if this a new\n+     * version of an existing logical resource. The logic tracks closely the DB2 stored\n+     * procedure implementation, including locking of the logical_resource and handling\n+     * concurrency issues using the standard insert-or-update pattern:\n+     * <pre>\n+     *   SELECT FOR UPDATE                 -- try and get a write lock\n+     *   IF NOT FOUND THEN                 -- doesn't exist, so we don't have a lock\n+     *     INSERT new logical resource     -- create the record - if OK, we own the lock\n+     *     IF DUPLICATE THEN               -- someone else beat us to the create\n+     *       SELECT FOR UPDATE             -- so we need to try again for a write lock\n+     *     ...\n+     *   ...\n+     * </pre>\n+     *\n+     * This works because we never delete a logical_resource record, and so don't have to deal\n+     * with concurrency issues caused when deletes are mingled with inserts/updates\n+     *\n+     * Note the execution flow aligns very closely with the DB2 stored procedure\n+     * implementation (fhir-persistence-schema/src/main/resources/add_any_resource.sql)\n+     *\n+     * @param tablePrefix\n+     * @param parameters\n+     * @param p_logical_id\n+     * @param p_payload\n+     * @param p_last_updated\n+     * @param p_is_deleted\n+     * @param p_source_key\n+     * @param p_version\n+     *\n+     * @return the resource_id for the entry we created\n+     * @throws Exception\n+     */\n+    public long storeResource(String tablePrefix, List<ExtractedParameterValue> parameters, String p_logical_id, byte[] p_payload, Timestamp p_last_updated, boolean p_is_deleted,\n+        String p_source_key, Integer p_version, Connection conn) throws Exception {\n+\n+        final String METHODNAME = \"storeResource() for \" + tablePrefix + \" resource\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Long v_logical_resource_id = null;\n+        Long v_current_resource_id = null;\n+        Long v_resource_id = null;\n+        Integer v_resource_type_id = null;\n+        boolean v_new_resource = false;\n+        boolean v_not_found = false;\n+        boolean v_duplicate = false;\n+        int v_version = 0;\n+        int v_insert_version = 0;\n+\n+        String v_resource_type = tablePrefix;\n+\n+        // Map the resource type name to the normalized id value in the database\n+        v_resource_type_id = getResourceTypeId(v_resource_type, conn);\n+        if (v_resource_type_id == null) {\n+            // programming error, as this should've been created earlier\n+            throw new IllegalStateException(\"resource type not found: \" + v_resource_type);\n+        }\n+\n+        // Get a lock at the system-wide logical resource level. Note the Derby-specific syntax\n+        final String SELECT_FOR_UPDATE = \"SELECT logical_resource_id FROM logical_resources WHERE resource_type_id = ? AND logical_id = ? FOR UPDATE\";\n+        try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+            stmt.setInt(1, v_resource_type_id);\n+            stmt.setString(2, p_logical_id);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                v_logical_resource_id = rs.getLong(1);\n+            } else {\n+                v_not_found = true;\n+                v_logical_resource_id = -1L; // just to be careful\n+            }\n+        }\n+\n+        // Create the logical resource if we don't have it already\n+        if (v_not_found) {\n+            // grab the id we want to use for the new logical resource instance\n+            final String sql2 = \"SELECT nextval('fhir_sequence')\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_logical_resource_id = res.getLong(1);\n+                } else {\n+                    // not going to happen, unless someone butchers the statement being executed\n+                    throw new IllegalStateException(\"VALUES failed to return a row: \" + sql2);\n+                }\n+            }\n+\n+            try {\n+                // insert the system-wide logical resource record.\n+                final String sql3 = \"INSERT INTO logical_resources (logical_resource_id, resource_type_id, logical_id) VALUES (?, ?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setInt(2, v_resource_type_id);\n+                    stmt.setString(3, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (translator.isDuplicate(e)) {\n+                    v_duplicate = true;\n+                }  else {\n+                    throw e;\n+                }\n+            }\n+\n+            /**\n+             * remember that we have a concurrent system...so there is a possibility\n+             * that another thread snuck in before us and created the logical resource. This\n+             * is easy to handle, just turn around and read it\n+             */\n+            if (v_duplicate) {\n+                try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+                    // bind parameters\n+                    stmt.setInt(1, v_resource_type_id);\n+                    stmt.setString(2, p_logical_id);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        v_logical_resource_id = res.getLong(1);\n+                    } else {\n+                        // Extremely unlikely as we should never delete logical resource records\n+                        throw new IllegalStateException(\"Logical resource was deleted: \" + tablePrefix + \"/\" + p_logical_id);\n+                    }\n+                }\n+            } else {\n+                v_new_resource = true;\n+\n+                // Insert the resource-specific logical resource record. Remember that logical_id is denormalized\n+                // so it gets stored again here for convenience\n+                final String sql3 = \"INSERT INTO \" + tablePrefix + \"_logical_resources (logical_resource_id, logical_id) VALUES (?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setString(2, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            }\n+        }\n+\n+        if (!v_new_resource) {\n+            // existing resource.  We need to know the current version from the\n+            // resource-specific logical resources table.\n+            final String sql3 = \"SELECT current_resource_id FROM \" + tablePrefix + \"_logical_resources WHERE logical_resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                stmt.setLong(1, v_logical_resource_id);\n+                ResultSet rs = stmt.executeQuery();\n+                if (rs.next()) {\n+                    v_current_resource_id = rs.getLong(1);\n+                }\n+                else {\n+                    // This database is broken, because we shouldn't have logical_resource records without\n+                    // corresponding resource-specific logical_resource records.\n+                    throw new SQLException(\"Logical_id record '\" + p_logical_id + \"' missing for resource \" + tablePrefix);\n+                }\n+            }\n+\n+            // so if we are storing a specific version, do a quick check to make\n+            // sure that this version doesn't currently exist. This is only done when processing\n+            // replication messages which might be duplicated. We want the operation to be idempotent,\n+            // so if the resource already exists, we don't need to do anything else.\n+\n+            if (p_version != null) {\n+                final String sqlStmt = \"SELECT resource_id FROM \" + tablePrefix + \"_resources dr WHERE dr.logical_resource_id = ? AND dr.version_id = ?\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sqlStmt)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setLong(2, p_version);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        // this version of this resource already exists, so we bail out right away\n+                        v_resource_id = res.getLong(1);\n+                        return v_resource_id;\n+                    }\n+                }\n+            }\n+\n+            // Grab the version value for the current version (identified by v_current_resource_id)\n+            final String sql4 = \"SELECT version_id FROM \" + tablePrefix + \"_resources WHERE resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql4)) {\n+                stmt.setLong(1, v_current_resource_id);\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_version = res.getInt(1);\n+                } else {\n+                    throw new IllegalStateException(\"current resource not found: \"\n+                            + tablePrefix + \"_resources.resource_id=\" + v_current_resource_id);\n+                }\n+            }\n+\n+            //If we have been passed a version number, this means that this is a replicated\n+            //resource, and so we only need to delete parameters if the given version is\n+            // later than the current version\n+            if (p_version == null || p_version > v_version) {\n+                // existing resource, so need to delete all its parameters\n+                // delete composites first, or else the foreign keys there restrict deletes on referenced tables\n+                deleteFromParameterTable(conn, tablePrefix + \"_composites\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_str_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_number_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_date_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_latlng_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_token_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_quantity_values\", v_logical_resource_id);\n+            }\n+        }\n+\n+        // Persist the data using the given version number if required\n+        if (p_version != null) {\n+            v_insert_version = p_version;\n+        } else {\n+            // remember we have a write (update) lock on the logical version, so we can safely calculate\n+            // the next version value here\n+            v_insert_version = v_version + 1;\n+\n+        }\n+\n+        /**\n+         * Create the new resource version.\n+         * Alpha version uses last_updated time from the app-server, so we keep that here", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "861db13b68349b21a0bfcaff0945ee48d74fde2c"}, "originalPosition": 392}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NjE2NDk2OnYy", "diffSide": "RIGHT", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNTowNTozM1rOGIZJRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNTowNTozM1rOGIZJRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ1Mzc2Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411453767", "createdAt": "2020-04-20T15:05:33Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,524 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+\n+    }\n+\n+    /**\n+     * Store the resource in the database, creating a new logical_resource entry if this is\n+     * the first version of this resource, or creating a new resource entry if this a new\n+     * version of an existing logical resource. The logic tracks closely the DB2 stored\n+     * procedure implementation, including locking of the logical_resource and handling\n+     * concurrency issues using the standard insert-or-update pattern:\n+     * <pre>\n+     *   SELECT FOR UPDATE                 -- try and get a write lock\n+     *   IF NOT FOUND THEN                 -- doesn't exist, so we don't have a lock\n+     *     INSERT new logical resource     -- create the record - if OK, we own the lock\n+     *     IF DUPLICATE THEN               -- someone else beat us to the create\n+     *       SELECT FOR UPDATE             -- so we need to try again for a write lock\n+     *     ...\n+     *   ...\n+     * </pre>\n+     *\n+     * This works because we never delete a logical_resource record, and so don't have to deal\n+     * with concurrency issues caused when deletes are mingled with inserts/updates\n+     *\n+     * Note the execution flow aligns very closely with the DB2 stored procedure\n+     * implementation (fhir-persistence-schema/src/main/resources/add_any_resource.sql)\n+     *\n+     * @param tablePrefix\n+     * @param parameters\n+     * @param p_logical_id\n+     * @param p_payload\n+     * @param p_last_updated\n+     * @param p_is_deleted\n+     * @param p_source_key\n+     * @param p_version\n+     *\n+     * @return the resource_id for the entry we created\n+     * @throws Exception\n+     */\n+    public long storeResource(String tablePrefix, List<ExtractedParameterValue> parameters, String p_logical_id, byte[] p_payload, Timestamp p_last_updated, boolean p_is_deleted,\n+        String p_source_key, Integer p_version, Connection conn) throws Exception {\n+\n+        final String METHODNAME = \"storeResource() for \" + tablePrefix + \" resource\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Long v_logical_resource_id = null;\n+        Long v_current_resource_id = null;\n+        Long v_resource_id = null;\n+        Integer v_resource_type_id = null;\n+        boolean v_new_resource = false;\n+        boolean v_not_found = false;\n+        boolean v_duplicate = false;\n+        int v_version = 0;\n+        int v_insert_version = 0;\n+\n+        String v_resource_type = tablePrefix;\n+\n+        // Map the resource type name to the normalized id value in the database\n+        v_resource_type_id = getResourceTypeId(v_resource_type, conn);\n+        if (v_resource_type_id == null) {\n+            // programming error, as this should've been created earlier\n+            throw new IllegalStateException(\"resource type not found: \" + v_resource_type);\n+        }\n+\n+        // Get a lock at the system-wide logical resource level. Note the Derby-specific syntax\n+        final String SELECT_FOR_UPDATE = \"SELECT logical_resource_id FROM logical_resources WHERE resource_type_id = ? AND logical_id = ? FOR UPDATE\";\n+        try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+            stmt.setInt(1, v_resource_type_id);\n+            stmt.setString(2, p_logical_id);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                v_logical_resource_id = rs.getLong(1);\n+            } else {\n+                v_not_found = true;\n+                v_logical_resource_id = -1L; // just to be careful\n+            }\n+        }\n+\n+        // Create the logical resource if we don't have it already\n+        if (v_not_found) {\n+            // grab the id we want to use for the new logical resource instance\n+            final String sql2 = \"SELECT nextval('fhir_sequence')\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_logical_resource_id = res.getLong(1);\n+                } else {\n+                    // not going to happen, unless someone butchers the statement being executed\n+                    throw new IllegalStateException(\"VALUES failed to return a row: \" + sql2);\n+                }\n+            }\n+\n+            try {\n+                // insert the system-wide logical resource record.\n+                final String sql3 = \"INSERT INTO logical_resources (logical_resource_id, resource_type_id, logical_id) VALUES (?, ?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setInt(2, v_resource_type_id);\n+                    stmt.setString(3, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (translator.isDuplicate(e)) {\n+                    v_duplicate = true;\n+                }  else {\n+                    throw e;\n+                }\n+            }\n+\n+            /**\n+             * remember that we have a concurrent system...so there is a possibility\n+             * that another thread snuck in before us and created the logical resource. This\n+             * is easy to handle, just turn around and read it\n+             */\n+            if (v_duplicate) {\n+                try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+                    // bind parameters\n+                    stmt.setInt(1, v_resource_type_id);\n+                    stmt.setString(2, p_logical_id);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        v_logical_resource_id = res.getLong(1);\n+                    } else {\n+                        // Extremely unlikely as we should never delete logical resource records\n+                        throw new IllegalStateException(\"Logical resource was deleted: \" + tablePrefix + \"/\" + p_logical_id);\n+                    }\n+                }\n+            } else {\n+                v_new_resource = true;\n+\n+                // Insert the resource-specific logical resource record. Remember that logical_id is denormalized\n+                // so it gets stored again here for convenience\n+                final String sql3 = \"INSERT INTO \" + tablePrefix + \"_logical_resources (logical_resource_id, logical_id) VALUES (?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setString(2, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            }\n+        }\n+\n+        if (!v_new_resource) {\n+            // existing resource.  We need to know the current version from the\n+            // resource-specific logical resources table.\n+            final String sql3 = \"SELECT current_resource_id FROM \" + tablePrefix + \"_logical_resources WHERE logical_resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                stmt.setLong(1, v_logical_resource_id);\n+                ResultSet rs = stmt.executeQuery();\n+                if (rs.next()) {\n+                    v_current_resource_id = rs.getLong(1);\n+                }\n+                else {\n+                    // This database is broken, because we shouldn't have logical_resource records without\n+                    // corresponding resource-specific logical_resource records.\n+                    throw new SQLException(\"Logical_id record '\" + p_logical_id + \"' missing for resource \" + tablePrefix);\n+                }\n+            }\n+\n+            // so if we are storing a specific version, do a quick check to make\n+            // sure that this version doesn't currently exist. This is only done when processing\n+            // replication messages which might be duplicated. We want the operation to be idempotent,\n+            // so if the resource already exists, we don't need to do anything else.\n+\n+            if (p_version != null) {\n+                final String sqlStmt = \"SELECT resource_id FROM \" + tablePrefix + \"_resources dr WHERE dr.logical_resource_id = ? AND dr.version_id = ?\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sqlStmt)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setLong(2, p_version);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        // this version of this resource already exists, so we bail out right away\n+                        v_resource_id = res.getLong(1);\n+                        return v_resource_id;\n+                    }\n+                }\n+            }\n+\n+            // Grab the version value for the current version (identified by v_current_resource_id)\n+            final String sql4 = \"SELECT version_id FROM \" + tablePrefix + \"_resources WHERE resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql4)) {\n+                stmt.setLong(1, v_current_resource_id);\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_version = res.getInt(1);\n+                } else {\n+                    throw new IllegalStateException(\"current resource not found: \"\n+                            + tablePrefix + \"_resources.resource_id=\" + v_current_resource_id);\n+                }\n+            }\n+\n+            //If we have been passed a version number, this means that this is a replicated\n+            //resource, and so we only need to delete parameters if the given version is\n+            // later than the current version\n+            if (p_version == null || p_version > v_version) {\n+                // existing resource, so need to delete all its parameters\n+                // delete composites first, or else the foreign keys there restrict deletes on referenced tables\n+                deleteFromParameterTable(conn, tablePrefix + \"_composites\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_str_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_number_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_date_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_latlng_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_token_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_quantity_values\", v_logical_resource_id);\n+            }\n+        }\n+\n+        // Persist the data using the given version number if required\n+        if (p_version != null) {\n+            v_insert_version = p_version;\n+        } else {\n+            // remember we have a write (update) lock on the logical version, so we can safely calculate\n+            // the next version value here\n+            v_insert_version = v_version + 1;\n+\n+        }\n+\n+        /**\n+         * Create the new resource version.\n+         * Alpha version uses last_updated time from the app-server, so we keep that here\n+         */\n+        String sql2 = \"SELECT nextval('fhir_sequence')\";\n+        try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+            ResultSet res = stmt.executeQuery();\n+            if (res.next()) {\n+                v_resource_id = res.getLong(1); //Assign result of the above query\n+            } else {\n+                // unlikely\n+                throw new IllegalStateException(\"no row returned: \" + sql2);\n+            }\n+        }\n+\n+        // Finally we get to the big resource data insert\n+        String sql3 = \"INSERT INTO \" + tablePrefix + \"_resources (resource_id, logical_resource_id, version_id, data, last_updated, is_deleted) \"\n+                + \"VALUES (?,?,?,?,?,?)\";\n+        try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+            // bind parameters\n+            stmt.setLong(1, v_resource_id);\n+            stmt.setLong(2, v_logical_resource_id);\n+            stmt.setInt(3, v_insert_version);\n+            stmt.setBytes(4, p_payload);\n+            stmt.setTimestamp(5, p_last_updated, UTC);\n+            stmt.setString(6, p_is_deleted ? \"Y\" : \"N\");\n+            stmt.executeUpdate();\n+        }\n+\n+        if (p_version == null || p_version > v_version) {\n+            //only update the logical resource if the resource we are adding supercedes the\n+            //current resource\n+            String sql4 = \"UPDATE \" + tablePrefix + \"_logical_resources SET current_resource_id = ? WHERE logical_resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql4)) {\n+                // bind parameters\n+                stmt.setLong(1, v_resource_id);\n+                stmt.setLong(2, v_logical_resource_id);\n+                stmt.executeUpdate();\n+            }\n+\n+            // To keep things simple for the Derby use-case, we just use a visitor to\n+            // handle inserts of parameters directly in the resource parameter tables.\n+            // Note we don't get any parameters for the resource soft-delete operation\n+            if (parameters != null) {\n+                // Derby doesn't support partitioned multi-tenancy, so we disable it on the DAO:\n+                try (ParameterVisitorBatchDAO pvd = new ParameterVisitorBatchDAO(conn, null, tablePrefix, false, v_logical_resource_id, 100,\n+                    new ParameterNameCacheAdapter(parameterNameDAO), new CodeSystemCacheAdapter(codeSystemDAO))) {\n+                    for (ExtractedParameterValue p: parameters) {\n+                        p.accept(pvd);\n+                    }\n+                }\n+            }\n+        }\n+        logger.exiting(CLASSNAME, METHODNAME);\n+        return v_resource_id;\n+    }\n+\n+\n+    /**\n+     * Delete all parameters for the given resourceId from the parameters table\n+     *\n+     * @param conn\n+     * @param tableName\n+     * @param logicalResourceId\n+     * @throws SQLException\n+     */\n+    protected void deleteFromParameterTable(Connection conn, String tableName, long logicalResourceId) throws SQLException {\n+        final String delStrValues = \"DELETE FROM \" + tableName + \" WHERE logical_resource_id = ?\";\n+        try (PreparedStatement stmt = conn.prepareStatement(delStrValues)) {\n+            // bind parameters\n+            stmt.setLong(1, logicalResourceId);\n+            stmt.executeUpdate();\n+        }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "861db13b68349b21a0bfcaff0945ee48d74fde2c"}, "originalPosition": 463}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NjE2NjM1OnYy", "diffSide": "RIGHT", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNTowNTo0OVrOGIZKEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNTowNTo0OVrOGIZKEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ1Mzk3MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Integer result;\n          \n          \n            \n                    Integer result = null;", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411453971", "createdAt": "2020-04-20T15:05:49Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,524 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+\n+    }\n+\n+    /**\n+     * Store the resource in the database, creating a new logical_resource entry if this is\n+     * the first version of this resource, or creating a new resource entry if this a new\n+     * version of an existing logical resource. The logic tracks closely the DB2 stored\n+     * procedure implementation, including locking of the logical_resource and handling\n+     * concurrency issues using the standard insert-or-update pattern:\n+     * <pre>\n+     *   SELECT FOR UPDATE                 -- try and get a write lock\n+     *   IF NOT FOUND THEN                 -- doesn't exist, so we don't have a lock\n+     *     INSERT new logical resource     -- create the record - if OK, we own the lock\n+     *     IF DUPLICATE THEN               -- someone else beat us to the create\n+     *       SELECT FOR UPDATE             -- so we need to try again for a write lock\n+     *     ...\n+     *   ...\n+     * </pre>\n+     *\n+     * This works because we never delete a logical_resource record, and so don't have to deal\n+     * with concurrency issues caused when deletes are mingled with inserts/updates\n+     *\n+     * Note the execution flow aligns very closely with the DB2 stored procedure\n+     * implementation (fhir-persistence-schema/src/main/resources/add_any_resource.sql)\n+     *\n+     * @param tablePrefix\n+     * @param parameters\n+     * @param p_logical_id\n+     * @param p_payload\n+     * @param p_last_updated\n+     * @param p_is_deleted\n+     * @param p_source_key\n+     * @param p_version\n+     *\n+     * @return the resource_id for the entry we created\n+     * @throws Exception\n+     */\n+    public long storeResource(String tablePrefix, List<ExtractedParameterValue> parameters, String p_logical_id, byte[] p_payload, Timestamp p_last_updated, boolean p_is_deleted,\n+        String p_source_key, Integer p_version, Connection conn) throws Exception {\n+\n+        final String METHODNAME = \"storeResource() for \" + tablePrefix + \" resource\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Long v_logical_resource_id = null;\n+        Long v_current_resource_id = null;\n+        Long v_resource_id = null;\n+        Integer v_resource_type_id = null;\n+        boolean v_new_resource = false;\n+        boolean v_not_found = false;\n+        boolean v_duplicate = false;\n+        int v_version = 0;\n+        int v_insert_version = 0;\n+\n+        String v_resource_type = tablePrefix;\n+\n+        // Map the resource type name to the normalized id value in the database\n+        v_resource_type_id = getResourceTypeId(v_resource_type, conn);\n+        if (v_resource_type_id == null) {\n+            // programming error, as this should've been created earlier\n+            throw new IllegalStateException(\"resource type not found: \" + v_resource_type);\n+        }\n+\n+        // Get a lock at the system-wide logical resource level. Note the Derby-specific syntax\n+        final String SELECT_FOR_UPDATE = \"SELECT logical_resource_id FROM logical_resources WHERE resource_type_id = ? AND logical_id = ? FOR UPDATE\";\n+        try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+            stmt.setInt(1, v_resource_type_id);\n+            stmt.setString(2, p_logical_id);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                v_logical_resource_id = rs.getLong(1);\n+            } else {\n+                v_not_found = true;\n+                v_logical_resource_id = -1L; // just to be careful\n+            }\n+        }\n+\n+        // Create the logical resource if we don't have it already\n+        if (v_not_found) {\n+            // grab the id we want to use for the new logical resource instance\n+            final String sql2 = \"SELECT nextval('fhir_sequence')\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_logical_resource_id = res.getLong(1);\n+                } else {\n+                    // not going to happen, unless someone butchers the statement being executed\n+                    throw new IllegalStateException(\"VALUES failed to return a row: \" + sql2);\n+                }\n+            }\n+\n+            try {\n+                // insert the system-wide logical resource record.\n+                final String sql3 = \"INSERT INTO logical_resources (logical_resource_id, resource_type_id, logical_id) VALUES (?, ?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setInt(2, v_resource_type_id);\n+                    stmt.setString(3, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (translator.isDuplicate(e)) {\n+                    v_duplicate = true;\n+                }  else {\n+                    throw e;\n+                }\n+            }\n+\n+            /**\n+             * remember that we have a concurrent system...so there is a possibility\n+             * that another thread snuck in before us and created the logical resource. This\n+             * is easy to handle, just turn around and read it\n+             */\n+            if (v_duplicate) {\n+                try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+                    // bind parameters\n+                    stmt.setInt(1, v_resource_type_id);\n+                    stmt.setString(2, p_logical_id);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        v_logical_resource_id = res.getLong(1);\n+                    } else {\n+                        // Extremely unlikely as we should never delete logical resource records\n+                        throw new IllegalStateException(\"Logical resource was deleted: \" + tablePrefix + \"/\" + p_logical_id);\n+                    }\n+                }\n+            } else {\n+                v_new_resource = true;\n+\n+                // Insert the resource-specific logical resource record. Remember that logical_id is denormalized\n+                // so it gets stored again here for convenience\n+                final String sql3 = \"INSERT INTO \" + tablePrefix + \"_logical_resources (logical_resource_id, logical_id) VALUES (?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setString(2, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            }\n+        }\n+\n+        if (!v_new_resource) {\n+            // existing resource.  We need to know the current version from the\n+            // resource-specific logical resources table.\n+            final String sql3 = \"SELECT current_resource_id FROM \" + tablePrefix + \"_logical_resources WHERE logical_resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                stmt.setLong(1, v_logical_resource_id);\n+                ResultSet rs = stmt.executeQuery();\n+                if (rs.next()) {\n+                    v_current_resource_id = rs.getLong(1);\n+                }\n+                else {\n+                    // This database is broken, because we shouldn't have logical_resource records without\n+                    // corresponding resource-specific logical_resource records.\n+                    throw new SQLException(\"Logical_id record '\" + p_logical_id + \"' missing for resource \" + tablePrefix);\n+                }\n+            }\n+\n+            // so if we are storing a specific version, do a quick check to make\n+            // sure that this version doesn't currently exist. This is only done when processing\n+            // replication messages which might be duplicated. We want the operation to be idempotent,\n+            // so if the resource already exists, we don't need to do anything else.\n+\n+            if (p_version != null) {\n+                final String sqlStmt = \"SELECT resource_id FROM \" + tablePrefix + \"_resources dr WHERE dr.logical_resource_id = ? AND dr.version_id = ?\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sqlStmt)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setLong(2, p_version);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        // this version of this resource already exists, so we bail out right away\n+                        v_resource_id = res.getLong(1);\n+                        return v_resource_id;\n+                    }\n+                }\n+            }\n+\n+            // Grab the version value for the current version (identified by v_current_resource_id)\n+            final String sql4 = \"SELECT version_id FROM \" + tablePrefix + \"_resources WHERE resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql4)) {\n+                stmt.setLong(1, v_current_resource_id);\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_version = res.getInt(1);\n+                } else {\n+                    throw new IllegalStateException(\"current resource not found: \"\n+                            + tablePrefix + \"_resources.resource_id=\" + v_current_resource_id);\n+                }\n+            }\n+\n+            //If we have been passed a version number, this means that this is a replicated\n+            //resource, and so we only need to delete parameters if the given version is\n+            // later than the current version\n+            if (p_version == null || p_version > v_version) {\n+                // existing resource, so need to delete all its parameters\n+                // delete composites first, or else the foreign keys there restrict deletes on referenced tables\n+                deleteFromParameterTable(conn, tablePrefix + \"_composites\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_str_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_number_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_date_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_latlng_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_token_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_quantity_values\", v_logical_resource_id);\n+            }\n+        }\n+\n+        // Persist the data using the given version number if required\n+        if (p_version != null) {\n+            v_insert_version = p_version;\n+        } else {\n+            // remember we have a write (update) lock on the logical version, so we can safely calculate\n+            // the next version value here\n+            v_insert_version = v_version + 1;\n+\n+        }\n+\n+        /**\n+         * Create the new resource version.\n+         * Alpha version uses last_updated time from the app-server, so we keep that here\n+         */\n+        String sql2 = \"SELECT nextval('fhir_sequence')\";\n+        try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+            ResultSet res = stmt.executeQuery();\n+            if (res.next()) {\n+                v_resource_id = res.getLong(1); //Assign result of the above query\n+            } else {\n+                // unlikely\n+                throw new IllegalStateException(\"no row returned: \" + sql2);\n+            }\n+        }\n+\n+        // Finally we get to the big resource data insert\n+        String sql3 = \"INSERT INTO \" + tablePrefix + \"_resources (resource_id, logical_resource_id, version_id, data, last_updated, is_deleted) \"\n+                + \"VALUES (?,?,?,?,?,?)\";\n+        try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+            // bind parameters\n+            stmt.setLong(1, v_resource_id);\n+            stmt.setLong(2, v_logical_resource_id);\n+            stmt.setInt(3, v_insert_version);\n+            stmt.setBytes(4, p_payload);\n+            stmt.setTimestamp(5, p_last_updated, UTC);\n+            stmt.setString(6, p_is_deleted ? \"Y\" : \"N\");\n+            stmt.executeUpdate();\n+        }\n+\n+        if (p_version == null || p_version > v_version) {\n+            //only update the logical resource if the resource we are adding supercedes the\n+            //current resource\n+            String sql4 = \"UPDATE \" + tablePrefix + \"_logical_resources SET current_resource_id = ? WHERE logical_resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql4)) {\n+                // bind parameters\n+                stmt.setLong(1, v_resource_id);\n+                stmt.setLong(2, v_logical_resource_id);\n+                stmt.executeUpdate();\n+            }\n+\n+            // To keep things simple for the Derby use-case, we just use a visitor to\n+            // handle inserts of parameters directly in the resource parameter tables.\n+            // Note we don't get any parameters for the resource soft-delete operation\n+            if (parameters != null) {\n+                // Derby doesn't support partitioned multi-tenancy, so we disable it on the DAO:\n+                try (ParameterVisitorBatchDAO pvd = new ParameterVisitorBatchDAO(conn, null, tablePrefix, false, v_logical_resource_id, 100,\n+                    new ParameterNameCacheAdapter(parameterNameDAO), new CodeSystemCacheAdapter(codeSystemDAO))) {\n+                    for (ExtractedParameterValue p: parameters) {\n+                        p.accept(pvd);\n+                    }\n+                }\n+            }\n+        }\n+        logger.exiting(CLASSNAME, METHODNAME);\n+        return v_resource_id;\n+    }\n+\n+\n+    /**\n+     * Delete all parameters for the given resourceId from the parameters table\n+     *\n+     * @param conn\n+     * @param tableName\n+     * @param logicalResourceId\n+     * @throws SQLException\n+     */\n+    protected void deleteFromParameterTable(Connection conn, String tableName, long logicalResourceId) throws SQLException {\n+        final String delStrValues = \"DELETE FROM \" + tableName + \" WHERE logical_resource_id = ?\";\n+        try (PreparedStatement stmt = conn.prepareStatement(delStrValues)) {\n+            // bind parameters\n+            stmt.setLong(1, logicalResourceId);\n+            stmt.executeUpdate();\n+        }\n+\n+    }\n+\n+    /**\n+     * Read the id for the named type\n+     * @param resourceTypeName\n+     * @return the database id, or null if the named record is not found\n+     * @throws SQLException\n+     */\n+    protected Integer getResourceTypeId(String resourceTypeName, Connection conn) throws SQLException {\n+        Integer result;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "861db13b68349b21a0bfcaff0945ee48d74fde2c"}, "originalPosition": 473}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NjE2NzgwOnYy", "diffSide": "RIGHT", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNTowNjowNVrOGIZK7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNTowNjowNVrOGIZK7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ1NDE5MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            result = rs.getInt(1);\n          \n          \n            \n                        } else {\n          \n          \n            \n                            result = null;\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                            result = rs.getInt(1);\n          \n          \n            \n                        }\n          \n          \n            \n                    }", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411454191", "createdAt": "2020-04-20T15:06:05Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,524 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+\n+    }\n+\n+    /**\n+     * Store the resource in the database, creating a new logical_resource entry if this is\n+     * the first version of this resource, or creating a new resource entry if this a new\n+     * version of an existing logical resource. The logic tracks closely the DB2 stored\n+     * procedure implementation, including locking of the logical_resource and handling\n+     * concurrency issues using the standard insert-or-update pattern:\n+     * <pre>\n+     *   SELECT FOR UPDATE                 -- try and get a write lock\n+     *   IF NOT FOUND THEN                 -- doesn't exist, so we don't have a lock\n+     *     INSERT new logical resource     -- create the record - if OK, we own the lock\n+     *     IF DUPLICATE THEN               -- someone else beat us to the create\n+     *       SELECT FOR UPDATE             -- so we need to try again for a write lock\n+     *     ...\n+     *   ...\n+     * </pre>\n+     *\n+     * This works because we never delete a logical_resource record, and so don't have to deal\n+     * with concurrency issues caused when deletes are mingled with inserts/updates\n+     *\n+     * Note the execution flow aligns very closely with the DB2 stored procedure\n+     * implementation (fhir-persistence-schema/src/main/resources/add_any_resource.sql)\n+     *\n+     * @param tablePrefix\n+     * @param parameters\n+     * @param p_logical_id\n+     * @param p_payload\n+     * @param p_last_updated\n+     * @param p_is_deleted\n+     * @param p_source_key\n+     * @param p_version\n+     *\n+     * @return the resource_id for the entry we created\n+     * @throws Exception\n+     */\n+    public long storeResource(String tablePrefix, List<ExtractedParameterValue> parameters, String p_logical_id, byte[] p_payload, Timestamp p_last_updated, boolean p_is_deleted,\n+        String p_source_key, Integer p_version, Connection conn) throws Exception {\n+\n+        final String METHODNAME = \"storeResource() for \" + tablePrefix + \" resource\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Long v_logical_resource_id = null;\n+        Long v_current_resource_id = null;\n+        Long v_resource_id = null;\n+        Integer v_resource_type_id = null;\n+        boolean v_new_resource = false;\n+        boolean v_not_found = false;\n+        boolean v_duplicate = false;\n+        int v_version = 0;\n+        int v_insert_version = 0;\n+\n+        String v_resource_type = tablePrefix;\n+\n+        // Map the resource type name to the normalized id value in the database\n+        v_resource_type_id = getResourceTypeId(v_resource_type, conn);\n+        if (v_resource_type_id == null) {\n+            // programming error, as this should've been created earlier\n+            throw new IllegalStateException(\"resource type not found: \" + v_resource_type);\n+        }\n+\n+        // Get a lock at the system-wide logical resource level. Note the Derby-specific syntax\n+        final String SELECT_FOR_UPDATE = \"SELECT logical_resource_id FROM logical_resources WHERE resource_type_id = ? AND logical_id = ? FOR UPDATE\";\n+        try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+            stmt.setInt(1, v_resource_type_id);\n+            stmt.setString(2, p_logical_id);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                v_logical_resource_id = rs.getLong(1);\n+            } else {\n+                v_not_found = true;\n+                v_logical_resource_id = -1L; // just to be careful\n+            }\n+        }\n+\n+        // Create the logical resource if we don't have it already\n+        if (v_not_found) {\n+            // grab the id we want to use for the new logical resource instance\n+            final String sql2 = \"SELECT nextval('fhir_sequence')\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_logical_resource_id = res.getLong(1);\n+                } else {\n+                    // not going to happen, unless someone butchers the statement being executed\n+                    throw new IllegalStateException(\"VALUES failed to return a row: \" + sql2);\n+                }\n+            }\n+\n+            try {\n+                // insert the system-wide logical resource record.\n+                final String sql3 = \"INSERT INTO logical_resources (logical_resource_id, resource_type_id, logical_id) VALUES (?, ?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setInt(2, v_resource_type_id);\n+                    stmt.setString(3, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (translator.isDuplicate(e)) {\n+                    v_duplicate = true;\n+                }  else {\n+                    throw e;\n+                }\n+            }\n+\n+            /**\n+             * remember that we have a concurrent system...so there is a possibility\n+             * that another thread snuck in before us and created the logical resource. This\n+             * is easy to handle, just turn around and read it\n+             */\n+            if (v_duplicate) {\n+                try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+                    // bind parameters\n+                    stmt.setInt(1, v_resource_type_id);\n+                    stmt.setString(2, p_logical_id);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        v_logical_resource_id = res.getLong(1);\n+                    } else {\n+                        // Extremely unlikely as we should never delete logical resource records\n+                        throw new IllegalStateException(\"Logical resource was deleted: \" + tablePrefix + \"/\" + p_logical_id);\n+                    }\n+                }\n+            } else {\n+                v_new_resource = true;\n+\n+                // Insert the resource-specific logical resource record. Remember that logical_id is denormalized\n+                // so it gets stored again here for convenience\n+                final String sql3 = \"INSERT INTO \" + tablePrefix + \"_logical_resources (logical_resource_id, logical_id) VALUES (?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setString(2, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            }\n+        }\n+\n+        if (!v_new_resource) {\n+            // existing resource.  We need to know the current version from the\n+            // resource-specific logical resources table.\n+            final String sql3 = \"SELECT current_resource_id FROM \" + tablePrefix + \"_logical_resources WHERE logical_resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                stmt.setLong(1, v_logical_resource_id);\n+                ResultSet rs = stmt.executeQuery();\n+                if (rs.next()) {\n+                    v_current_resource_id = rs.getLong(1);\n+                }\n+                else {\n+                    // This database is broken, because we shouldn't have logical_resource records without\n+                    // corresponding resource-specific logical_resource records.\n+                    throw new SQLException(\"Logical_id record '\" + p_logical_id + \"' missing for resource \" + tablePrefix);\n+                }\n+            }\n+\n+            // so if we are storing a specific version, do a quick check to make\n+            // sure that this version doesn't currently exist. This is only done when processing\n+            // replication messages which might be duplicated. We want the operation to be idempotent,\n+            // so if the resource already exists, we don't need to do anything else.\n+\n+            if (p_version != null) {\n+                final String sqlStmt = \"SELECT resource_id FROM \" + tablePrefix + \"_resources dr WHERE dr.logical_resource_id = ? AND dr.version_id = ?\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sqlStmt)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setLong(2, p_version);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        // this version of this resource already exists, so we bail out right away\n+                        v_resource_id = res.getLong(1);\n+                        return v_resource_id;\n+                    }\n+                }\n+            }\n+\n+            // Grab the version value for the current version (identified by v_current_resource_id)\n+            final String sql4 = \"SELECT version_id FROM \" + tablePrefix + \"_resources WHERE resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql4)) {\n+                stmt.setLong(1, v_current_resource_id);\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_version = res.getInt(1);\n+                } else {\n+                    throw new IllegalStateException(\"current resource not found: \"\n+                            + tablePrefix + \"_resources.resource_id=\" + v_current_resource_id);\n+                }\n+            }\n+\n+            //If we have been passed a version number, this means that this is a replicated\n+            //resource, and so we only need to delete parameters if the given version is\n+            // later than the current version\n+            if (p_version == null || p_version > v_version) {\n+                // existing resource, so need to delete all its parameters\n+                // delete composites first, or else the foreign keys there restrict deletes on referenced tables\n+                deleteFromParameterTable(conn, tablePrefix + \"_composites\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_str_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_number_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_date_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_latlng_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_token_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_quantity_values\", v_logical_resource_id);\n+            }\n+        }\n+\n+        // Persist the data using the given version number if required\n+        if (p_version != null) {\n+            v_insert_version = p_version;\n+        } else {\n+            // remember we have a write (update) lock on the logical version, so we can safely calculate\n+            // the next version value here\n+            v_insert_version = v_version + 1;\n+\n+        }\n+\n+        /**\n+         * Create the new resource version.\n+         * Alpha version uses last_updated time from the app-server, so we keep that here\n+         */\n+        String sql2 = \"SELECT nextval('fhir_sequence')\";\n+        try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+            ResultSet res = stmt.executeQuery();\n+            if (res.next()) {\n+                v_resource_id = res.getLong(1); //Assign result of the above query\n+            } else {\n+                // unlikely\n+                throw new IllegalStateException(\"no row returned: \" + sql2);\n+            }\n+        }\n+\n+        // Finally we get to the big resource data insert\n+        String sql3 = \"INSERT INTO \" + tablePrefix + \"_resources (resource_id, logical_resource_id, version_id, data, last_updated, is_deleted) \"\n+                + \"VALUES (?,?,?,?,?,?)\";\n+        try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+            // bind parameters\n+            stmt.setLong(1, v_resource_id);\n+            stmt.setLong(2, v_logical_resource_id);\n+            stmt.setInt(3, v_insert_version);\n+            stmt.setBytes(4, p_payload);\n+            stmt.setTimestamp(5, p_last_updated, UTC);\n+            stmt.setString(6, p_is_deleted ? \"Y\" : \"N\");\n+            stmt.executeUpdate();\n+        }\n+\n+        if (p_version == null || p_version > v_version) {\n+            //only update the logical resource if the resource we are adding supercedes the\n+            //current resource\n+            String sql4 = \"UPDATE \" + tablePrefix + \"_logical_resources SET current_resource_id = ? WHERE logical_resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql4)) {\n+                // bind parameters\n+                stmt.setLong(1, v_resource_id);\n+                stmt.setLong(2, v_logical_resource_id);\n+                stmt.executeUpdate();\n+            }\n+\n+            // To keep things simple for the Derby use-case, we just use a visitor to\n+            // handle inserts of parameters directly in the resource parameter tables.\n+            // Note we don't get any parameters for the resource soft-delete operation\n+            if (parameters != null) {\n+                // Derby doesn't support partitioned multi-tenancy, so we disable it on the DAO:\n+                try (ParameterVisitorBatchDAO pvd = new ParameterVisitorBatchDAO(conn, null, tablePrefix, false, v_logical_resource_id, 100,\n+                    new ParameterNameCacheAdapter(parameterNameDAO), new CodeSystemCacheAdapter(codeSystemDAO))) {\n+                    for (ExtractedParameterValue p: parameters) {\n+                        p.accept(pvd);\n+                    }\n+                }\n+            }\n+        }\n+        logger.exiting(CLASSNAME, METHODNAME);\n+        return v_resource_id;\n+    }\n+\n+\n+    /**\n+     * Delete all parameters for the given resourceId from the parameters table\n+     *\n+     * @param conn\n+     * @param tableName\n+     * @param logicalResourceId\n+     * @throws SQLException\n+     */\n+    protected void deleteFromParameterTable(Connection conn, String tableName, long logicalResourceId) throws SQLException {\n+        final String delStrValues = \"DELETE FROM \" + tableName + \" WHERE logical_resource_id = ?\";\n+        try (PreparedStatement stmt = conn.prepareStatement(delStrValues)) {\n+            // bind parameters\n+            stmt.setLong(1, logicalResourceId);\n+            stmt.executeUpdate();\n+        }\n+\n+    }\n+\n+    /**\n+     * Read the id for the named type\n+     * @param resourceTypeName\n+     * @return the database id, or null if the named record is not found\n+     * @throws SQLException\n+     */\n+    protected Integer getResourceTypeId(String resourceTypeName, Connection conn) throws SQLException {\n+        Integer result;\n+\n+        final String sql1 = \"SELECT resource_type_id FROM resource_types WHERE resource_type = ?\";\n+\n+        try (PreparedStatement stmt = conn.prepareStatement(sql1)) {\n+            stmt.setString(1, resourceTypeName);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                result = rs.getInt(1);\n+            } else {\n+                result = null;\n+            }\n+        }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "861db13b68349b21a0bfcaff0945ee48d74fde2c"}, "originalPosition": 486}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 180, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}