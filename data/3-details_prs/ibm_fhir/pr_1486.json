{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgyMDkzNzk3", "number": 1486, "title": "Issue #1262 - enable wildcard search for _include, _revinclude", "bodyText": "Signed-off-by: Mike Schroeder mschroed@us.ibm.com", "createdAt": "2020-09-08T14:40:49Z", "url": "https://github.com/IBM/FHIR/pull/1486", "merged": true, "mergeCommit": {"oid": "79bab869343a5748ab2de76001fc2b96a7608fb3"}, "closed": true, "closedAt": "2020-09-09T14:06:50Z", "author": {"login": "michaelwschroeder"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdG4oi2gH2gAyNDgyMDkzNzk3OjhiMzJiZDU3MmYyOTQyOWQ4NmY5YjgwY2U4NzRjZjA0MTMzMmRiYzk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdHMwqTgFqTQ4NTA0NjQ0Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "8b32bd572f29429d86f9b80ce874cf041332dbc9", "author": {"user": {"login": "michaelwschroeder", "name": "Michael W Schroeder"}}, "url": "https://github.com/IBM/FHIR/commit/8b32bd572f29429d86f9b80ce874cf041332dbc9", "committedDate": "2020-09-08T14:39:45Z", "message": "Issue #1262 - enable wildcard search for _include, _revinclude\n\nSigned-off-by: Mike Schroeder <mschroed@us.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0MjMwNDg4", "url": "https://github.com/IBM/FHIR/pull/1486#pullrequestreview-484230488", "createdAt": "2020-09-08T14:59:33Z", "commit": {"oid": "8b32bd572f29429d86f9b80ce874cf041332dbc9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNDo1OTozNFrOHOhbmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNDo1OTozNFrOHOhbmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk4OTg1MA==", "bodyText": "Update Copyright please ,2020", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r484989850", "createdAt": "2020-09-08T14:59:34Z", "author": {"login": "prb112"}, "path": "fhir-search/src/test/java/com/ibm/fhir/search/test/InclusionParameterParseTest.java", "diffHunk": "@@ -20,9 +20,12 @@\n \n import org.testng.annotations.Test;\n \n+import com.ibm.fhir.model.resource.Condition;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b32bd572f29429d86f9b80ce874cf041332dbc9"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0MjM0NDM1", "url": "https://github.com/IBM/FHIR/pull/1486#pullrequestreview-484234435", "createdAt": "2020-09-08T15:03:35Z", "commit": {"oid": "8b32bd572f29429d86f9b80ce874cf041332dbc9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNTowMzozNVrOHOhm4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNTowMzozNVrOHOhm4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk5MjczNw==", "bodyText": "Having an integration test in SearchTest.java in fhir-server-test would be ideal.   And include a test with Provenance.target which is a reference to Any FHIR Resource", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r484992737", "createdAt": "2020-09-08T15:03:35Z", "author": {"login": "prb112"}, "path": "fhir-search/src/test/java/com/ibm/fhir/search/test/InclusionParameterParseTest.java", "diffHunk": "@@ -327,4 +340,151 @@ public void testMultiIncludeRevinclude() throws Exception {\n         assertTrue(selfUri.contains(include4));\n     }\n \n+    @Test\n+    public void testWildcardIncludeNoMatchingTargetType() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Patient> resourceType = Patient.class;\n+\n+        queryParameters.put(\"_include\", Collections.singletonList(\"Patient:*:Medication\"));\n+        FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+\n+        assertNotNull(searchContext);\n+        assertFalse(searchContext.hasIncludeParameters());\n+        assertFalse(searchContext.hasRevIncludeParameters());\n+\n+        String selfUri = SearchUtil.buildSearchSelfUri(\"http://example.com/Patient\", searchContext);\n+        assertTrue(selfUri.equals(\"http://example.com/Patient?_count=10&_page=1\"));\n+    }\n+\n+    @Test\n+    public void testWildcardIncludeSingleMatchingTargetType() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Patient> resourceType = Patient.class;\n+\n+        queryParameters.put(\"_include\", Collections.singletonList(\"Patient:*:RelatedPerson\"));\n+        FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+\n+        assertNotNull(searchContext);\n+        assertTrue(searchContext.hasIncludeParameters());\n+        assertEquals(1, searchContext.getIncludeParameters().size());\n+        InclusionParameter incParm = searchContext.getIncludeParameters().get(0);\n+        assertEquals(\"Patient\", incParm.getJoinResourceType());\n+        assertEquals(\"link\", incParm.getSearchParameter());\n+        assertEquals(\"RelatedPerson\", incParm.getSearchParameterTargetType());\n+        assertFalse(searchContext.hasRevIncludeParameters());\n+\n+        String selfUri = SearchUtil.buildSearchSelfUri(\"http://example.com/Patient\", searchContext);\n+        assertTrue(selfUri.equals(\"http://example.com/Patient?_count=10&_include=\" + incParm.getJoinResourceType() +\n+            \":\" + incParm.getSearchParameter() + \":\" + incParm.getSearchParameterTargetType() + \"&_page=1\"));\n+    }\n+\n+    @Test\n+    public void testWildcardIncludeNoTargetType() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Patient> resourceType = Patient.class;\n+        String include1 = \"&_include=Patient:general-practitioner:Organization\";\n+        String include2 = \"&_include=Patient:general-practitioner:Practitioner\";\n+        String include3 = \"&_include=Patient:general-practitioner:PractitionerRole\";\n+        String include4 = \"&_include=Patient:organization:Organization\";\n+        String include5 = \"&_include=Patient:link:Patient\";\n+        String include6 = \"&_include=Patient:link:RelatedPerson\";\n+\n+        List<InclusionParameter> expectedIncludeParms = new ArrayList<>();\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"general-practitioner\", \"Organization\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"general-practitioner\", \"Practitioner\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"general-practitioner\", \"PractitionerRole\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"organization\", \"Organization\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"link\", \"Patient\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"link\", \"RelatedPerson\"));\n+\n+        queryParameters.put(\"_include\", Collections.singletonList(\"Patient:*\"));\n+        FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+\n+        assertNotNull(searchContext);\n+        assertTrue(searchContext.hasIncludeParameters());\n+        assertEquals(expectedIncludeParms.size(), searchContext.getIncludeParameters().size());\n+        for (InclusionParameter includeParm : expectedIncludeParms) {\n+            assertTrue(expectedIncludeParms.contains(includeParm));\n+        }\n+\n+        assertFalse(searchContext.hasRevIncludeParameters());\n+\n+        String selfUri = SearchUtil.buildSearchSelfUri(\"http://example.com/Patient\", searchContext);\n+        assertTrue(selfUri.contains(include1));\n+        assertTrue(selfUri.contains(include2));\n+        assertTrue(selfUri.contains(include3));\n+        assertTrue(selfUri.contains(include4));\n+        assertTrue(selfUri.contains(include5));\n+        assertTrue(selfUri.contains(include6));\n+    }\n+\n+    @Test\n+    public void testWildcardRevIncludeNoMatchingTargetType() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Condition> resourceType = Condition.class;\n+\n+        queryParameters.put(\"_revinclude\", Collections.singletonList(\"Patient:*:Condition\"));\n+        FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+\n+        assertNotNull(searchContext);\n+        assertFalse(searchContext.hasIncludeParameters());\n+        assertFalse(searchContext.hasRevIncludeParameters());\n+\n+        String selfUri = SearchUtil.buildSearchSelfUri(\"http://example.com/Condition\", searchContext);\n+        assertTrue(selfUri.equals(\"http://example.com/Condition?_count=10&_page=1\"));\n+    }\n+\n+    @Test\n+    public void testWildcardRevIncludeSingleMatchingTargetType() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Encounter> resourceType = Encounter.class;\n+\n+        queryParameters.put(\"_revinclude\", Collections.singletonList(\"MedicationAdministration:*:Encounter\"));\n+        FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+\n+        assertNotNull(searchContext);\n+        assertTrue(searchContext.hasRevIncludeParameters());\n+        assertEquals(1, searchContext.getRevIncludeParameters().size());\n+        InclusionParameter incParm = searchContext.getRevIncludeParameters().get(0);\n+        assertEquals(\"MedicationAdministration\", incParm.getJoinResourceType());\n+        assertEquals(\"context\", incParm.getSearchParameter());\n+        assertEquals(\"Encounter\", incParm.getSearchParameterTargetType());\n+        assertFalse(searchContext.hasIncludeParameters());\n+\n+        String selfUri = SearchUtil.buildSearchSelfUri(\"http://example.com/Encounter\", searchContext);\n+        assertTrue(selfUri.equals(\"http://example.com/Encounter?_count=10&_revinclude=\" + incParm.getJoinResourceType() +\n+            \":\" + incParm.getSearchParameter() + \":\" + incParm.getSearchParameterTargetType() + \"&_page=1\"));\n+    }\n+\n+    @Test\n+    public void testWildcardRevIncludeNoTargetType() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Patient> resourceType = Patient.class;\n+        String include1 = \"&_revinclude=Procedure:patient:Patient\";\n+        String include2 = \"&_revinclude=Procedure:performer:Patient\";\n+        String include3 = \"&_revinclude=Procedure:subject:Patient\";\n+\n+        List<InclusionParameter> expectedIncludeParms = new ArrayList<>();\n+        expectedIncludeParms.add(new InclusionParameter(\"Procedure\", \"patient\", \"Patient\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Procedure\", \"performer\", \"Patient\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Procedure\", \"subject\", \"Patient\"));\n+\n+        queryParameters.put(\"_revinclude\", Collections.singletonList(\"Procedure:*\"));\n+        FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+\n+        assertNotNull(searchContext);\n+        assertTrue(searchContext.hasRevIncludeParameters());\n+        assertEquals(expectedIncludeParms.size(), searchContext.getRevIncludeParameters().size());\n+        for (InclusionParameter includeParm : expectedIncludeParms) {\n+            assertTrue(expectedIncludeParms.contains(includeParm));\n+        }\n+\n+        assertFalse(searchContext.hasIncludeParameters());\n+\n+        String selfUri = SearchUtil.buildSearchSelfUri(\"http://example.com/Patient\", searchContext);\n+        assertTrue(selfUri.contains(include1));\n+        assertTrue(selfUri.contains(include2));\n+        assertTrue(selfUri.contains(include3));\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b32bd572f29429d86f9b80ce874cf041332dbc9"}, "originalPosition": 182}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0MjM1ODcx", "url": "https://github.com/IBM/FHIR/pull/1486#pullrequestreview-484235871", "createdAt": "2020-09-08T15:05:07Z", "commit": {"oid": "8b32bd572f29429d86f9b80ce874cf041332dbc9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNTowNTowN1rOHOhrHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNTowNTowN1rOHOhrHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk5MzgyMw==", "bodyText": "Looks like SearchParamType.REFERENCE.equals(...) could be done instead against \"reference\".  Same comment on line 1485.", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r484993823", "createdAt": "2020-09-08T15:05:07Z", "author": {"login": "tbieste"}, "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -502,6 +502,47 @@ private static SearchParameter getSearchParameterByUrlIfPresent(Map<String, Para\n         return result;\n     }\n \n+    /**\n+     * Perform wildcard processing for inclusion search parameters by getting all valid search parameters for the\n+     * specified join resource type. Search parameters must have a type of 'reference'.\n+     * <p>\n+     * If inclusion keyword is ' _include' and a target resource type is specified, search parameter must contain\n+     * a matching type.\n+     * <p>\n+     * If inclusion keyword is '_revinclude', search parameter must have a target resource type matching the resource\n+     * type being searched.\n+     * \n+     * @param resourceType\n+     *            the resource type being searched for\n+     * @param joinResourceType\n+     *            the resource type for which inclusion search parameters will be returned\n+     * @param searchParameterTargetType\n+     *            the target resource type for included resources\n+     * @param inclusionKeyword\n+     *            the inclusion type, either _include or _revinclude\n+     * @return\n+     *         the inclusion SearchParameters for type {@code resourceType} or empty map if none exist\n+     * @throws Exception\n+     */\n+    private static Map<String, SearchParameter> getInclusionWildcardSearchParameters(String resourceType, String joinResourceType,\n+        String searchParameterTargetType, String inclusionKeyword) throws Exception {\n+        Map<String, SearchParameter> inclusionSearchParameters = new HashMap<>();\n+\n+        for (SearchParameter searchParameter : getApplicableSearchParameters(joinResourceType)) {\n+            if (searchParameter.getType().getValue().equals(\"reference\") &&", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b32bd572f29429d86f9b80ce874cf041332dbc9"}, "originalPosition": 31}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0MjM2MzU1", "url": "https://github.com/IBM/FHIR/pull/1486#pullrequestreview-484236355", "createdAt": "2020-09-08T15:05:36Z", "commit": {"oid": "8b32bd572f29429d86f9b80ce874cf041332dbc9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNTowNTozNlrOHOhsew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNTowNTozNlrOHOhsew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk5NDE3MQ==", "bodyText": "Typo in word \"already\".", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r484994171", "createdAt": "2020-09-08T15:05:36Z", "author": {"login": "tbieste"}, "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -502,6 +502,47 @@ private static SearchParameter getSearchParameterByUrlIfPresent(Map<String, Para\n         return result;\n     }\n \n+    /**\n+     * Perform wildcard processing for inclusion search parameters by getting all valid search parameters for the\n+     * specified join resource type. Search parameters must have a type of 'reference'.\n+     * <p>\n+     * If inclusion keyword is ' _include' and a target resource type is specified, search parameter must contain\n+     * a matching type.\n+     * <p>\n+     * If inclusion keyword is '_revinclude', search parameter must have a target resource type matching the resource\n+     * type being searched.\n+     * \n+     * @param resourceType\n+     *            the resource type being searched for\n+     * @param joinResourceType\n+     *            the resource type for which inclusion search parameters will be returned\n+     * @param searchParameterTargetType\n+     *            the target resource type for included resources\n+     * @param inclusionKeyword\n+     *            the inclusion type, either _include or _revinclude\n+     * @return\n+     *         the inclusion SearchParameters for type {@code resourceType} or empty map if none exist\n+     * @throws Exception\n+     */\n+    private static Map<String, SearchParameter> getInclusionWildcardSearchParameters(String resourceType, String joinResourceType,\n+        String searchParameterTargetType, String inclusionKeyword) throws Exception {\n+        Map<String, SearchParameter> inclusionSearchParameters = new HashMap<>();\n+\n+        for (SearchParameter searchParameter : getApplicableSearchParameters(joinResourceType)) {\n+            if (searchParameter.getType().getValue().equals(\"reference\") &&\n+                    ((SearchConstants.INCLUDE.equals(inclusionKeyword)\n+                            && (searchParameterTargetType == null || isValidTargetType(searchParameterTargetType, searchParameter))) ||\n+                    (SearchConstants.REVINCLUDE.equals(inclusionKeyword) && isValidTargetType(resourceType, searchParameter)))) {\n+                // Valid search parameter of type reference - add to map\n+                inclusionSearchParameters.put(searchParameter.getCode().getValue(), searchParameter);\n+            } else if (inclusionSearchParameters.containsKey(searchParameter.getCode().getValue())) {\n+                // Search parameter is not valid - remove if search parameter by same name is alread in map", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b32bd572f29429d86f9b80ce874cf041332dbc9"}, "originalPosition": 38}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0MjM5MTA1", "url": "https://github.com/IBM/FHIR/pull/1486#pullrequestreview-484239105", "createdAt": "2020-09-08T15:08:31Z", "commit": {"oid": "8b32bd572f29429d86f9b80ce874cf041332dbc9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNTowODozMVrOHOhz4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNTowODozMVrOHOhz4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk5NjA2NQ==", "bodyText": "Why would there be two search parameters of the same code already in the map?\nThe word already is misspelled", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r484996065", "createdAt": "2020-09-08T15:08:31Z", "author": {"login": "prb112"}, "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -502,6 +502,47 @@ private static SearchParameter getSearchParameterByUrlIfPresent(Map<String, Para\n         return result;\n     }\n \n+    /**\n+     * Perform wildcard processing for inclusion search parameters by getting all valid search parameters for the\n+     * specified join resource type. Search parameters must have a type of 'reference'.\n+     * <p>\n+     * If inclusion keyword is ' _include' and a target resource type is specified, search parameter must contain\n+     * a matching type.\n+     * <p>\n+     * If inclusion keyword is '_revinclude', search parameter must have a target resource type matching the resource\n+     * type being searched.\n+     * \n+     * @param resourceType\n+     *            the resource type being searched for\n+     * @param joinResourceType\n+     *            the resource type for which inclusion search parameters will be returned\n+     * @param searchParameterTargetType\n+     *            the target resource type for included resources\n+     * @param inclusionKeyword\n+     *            the inclusion type, either _include or _revinclude\n+     * @return\n+     *         the inclusion SearchParameters for type {@code resourceType} or empty map if none exist\n+     * @throws Exception\n+     */\n+    private static Map<String, SearchParameter> getInclusionWildcardSearchParameters(String resourceType, String joinResourceType,\n+        String searchParameterTargetType, String inclusionKeyword) throws Exception {\n+        Map<String, SearchParameter> inclusionSearchParameters = new HashMap<>();\n+\n+        for (SearchParameter searchParameter : getApplicableSearchParameters(joinResourceType)) {\n+            if (searchParameter.getType().getValue().equals(\"reference\") &&\n+                    ((SearchConstants.INCLUDE.equals(inclusionKeyword)\n+                            && (searchParameterTargetType == null || isValidTargetType(searchParameterTargetType, searchParameter))) ||\n+                    (SearchConstants.REVINCLUDE.equals(inclusionKeyword) && isValidTargetType(resourceType, searchParameter)))) {\n+                // Valid search parameter of type reference - add to map\n+                inclusionSearchParameters.put(searchParameter.getCode().getValue(), searchParameter);\n+            } else if (inclusionSearchParameters.containsKey(searchParameter.getCode().getValue())) {\n+                // Search parameter is not valid - remove if search parameter by same name is alread in map\n+                inclusionSearchParameters.remove(searchParameter.getCode().getValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b32bd572f29429d86f9b80ce874cf041332dbc9"}, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0MjQwNTAz", "url": "https://github.com/IBM/FHIR/pull/1486#pullrequestreview-484240503", "createdAt": "2020-09-08T15:10:08Z", "commit": {"oid": "8b32bd572f29429d86f9b80ce874cf041332dbc9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNToxMDowOFrOHOh4Ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNToxMDowOFrOHOh4Ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk5NzEyMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Parses _include and _revinclude search result parameters contained in the query string, and produces\n          \n          \n            \n                 * Parses _include and _revinclude search parameters contained in the query string, and produces", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r484997122", "createdAt": "2020-09-08T15:10:08Z", "author": {"login": "prb112"}, "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -1373,17 +1414,25 @@ public static String normalizeForSearch(String value) {\n     }\n \n     /**\n-     * Parses _include and _revinclude search result parameters contained in the\n-     * query string, and produces\n-     * InclusionParameter objects to represent those parameters. The\n-     * InclusionParameter objects are included in the\n-     * appropriate collections encapsulated in the passed FHIRSearchContext.\n+     * Parses _include and _revinclude search result parameters contained in the query string, and produces", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b32bd572f29429d86f9b80ce874cf041332dbc9"}, "originalPosition": 57}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0MjUxMzQ3", "url": "https://github.com/IBM/FHIR/pull/1486#pullrequestreview-484251347", "createdAt": "2020-09-08T15:22:01Z", "commit": {"oid": "8b32bd572f29429d86f9b80ce874cf041332dbc9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNToyMjowMlrOHOiYmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNToyMjowMlrOHOiYmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAwNTQ2Ng==", "bodyText": "What happens when it's set to lenient? e.g. do we fail it? look at the behavior on line 1477", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r485005466", "createdAt": "2020-09-08T15:22:02Z", "author": {"login": "prb112"}, "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -1399,66 +1448,73 @@ private static void parseInclusionParameter(Class<?> resourceType, FHIRSearchCon\n             // Parse value into 3 parts: joinResourceType, searchParameterName, searchParameterTargetType\n             inclusionValueParts = inclusionValue.split(\":\");\n             if (inclusionValueParts.length < 2) {\n-                throw SearchExceptionUtil.buildNewInvalidSearchException(\n-                        \"A value for _include or _revinclude must have at least 2 parts separated by a colon.\");\n+                throw SearchExceptionUtil.buildNewInvalidSearchException(\"A value for _include or _revinclude must have at least 2 parts separated by a colon.\");\n             }\n-            joinResourceType          = inclusionValueParts[0];\n-            searchParameterName       = inclusionValueParts[1];\n+            joinResourceType = inclusionValueParts[0];\n+            searchParameterName = inclusionValueParts[1];\n             searchParameterTargetType = inclusionValueParts.length == 3 ? inclusionValueParts[2] : null;\n \n-            // Ensure that the Inclusion Parameter being parsed is a valid search parameter of type 'reference'.\n-            searchParm                = getSearchParameter(joinResourceType, searchParameterName);\n-            if (searchParm == null) {\n-                String msg = \"Undefined Inclusion Parameter: \" + inclusionValue;\n-                if (lenient) {\n-                    // TODO add this to the list of supplemental warnings?\n-                    log.fine(msg);\n-                    continue;\n-                } else {\n-                    throw SearchExceptionUtil.buildNewInvalidSearchException(msg);\n-                }\n+            // For _include parameter, join resource type must match resource type being searched\n+            if (SearchConstants.INCLUDE.equals(inclusionKeyword) && !joinResourceType.equals(resourceType.getSimpleName())) {\n+                throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                        \"The join resource type must match the resource type being searched.\");\n             }\n-            if (!searchParm.getType().getValue().equals(\"reference\")) {\n-                throw SearchExceptionUtil\n-                        .buildNewInvalidSearchException(\"Inclusion Parameter must be of type 'reference'. \"\n-                                + \"The passed Inclusion Parameter is of type: \" + searchParm.getType().getValue());\n+\n+            // For _revinclude parameter, target resource type, if specified, must match resource type being searched\n+            if (SearchConstants.REVINCLUDE.equals(inclusionKeyword) && searchParameterTargetType != null\n+                    && !searchParameterTargetType.equals(resourceType.getSimpleName())) {\n+                throw SearchExceptionUtil.buildNewInvalidSearchException(\"The search parameter target type must match the resource type being searched.\");\n             }\n \n-            if (inclusionKeyword.equals(SearchConstants.INCLUDE)) {\n-                newInclusionParms =\n-                        buildIncludeParameter(resourceType, joinResourceType, searchParm, searchParameterName,\n-                                searchParameterTargetType);\n-                context.getIncludeParameters().addAll(newInclusionParms);\n+            // Ensure that the Inclusion Parameter being parsed is a valid search parameter of type 'reference'.\n+            Map<String, SearchParameter> searchParametersMap;\n+            if (SearchConstants.WILDCARD.equals(searchParameterName)) {\n+                searchParametersMap = getInclusionWildcardSearchParameters(resourceType.getSimpleName(), joinResourceType, searchParameterTargetType, inclusionKeyword);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b32bd572f29429d86f9b80ce874cf041332dbc9"}, "originalPosition": 131}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0MjUyNTY0", "url": "https://github.com/IBM/FHIR/pull/1486#pullrequestreview-484252564", "createdAt": "2020-09-08T15:23:20Z", "commit": {"oid": "8b32bd572f29429d86f9b80ce874cf041332dbc9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNToyMzoyMFrOHOicKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNToyMzoyMFrOHOicKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAwNjM3Nw==", "bodyText": "single quotes around the value.  it shows better in the logs", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r485006377", "createdAt": "2020-09-08T15:23:20Z", "author": {"login": "prb112"}, "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -1399,66 +1448,73 @@ private static void parseInclusionParameter(Class<?> resourceType, FHIRSearchCon\n             // Parse value into 3 parts: joinResourceType, searchParameterName, searchParameterTargetType\n             inclusionValueParts = inclusionValue.split(\":\");\n             if (inclusionValueParts.length < 2) {\n-                throw SearchExceptionUtil.buildNewInvalidSearchException(\n-                        \"A value for _include or _revinclude must have at least 2 parts separated by a colon.\");\n+                throw SearchExceptionUtil.buildNewInvalidSearchException(\"A value for _include or _revinclude must have at least 2 parts separated by a colon.\");\n             }\n-            joinResourceType          = inclusionValueParts[0];\n-            searchParameterName       = inclusionValueParts[1];\n+            joinResourceType = inclusionValueParts[0];\n+            searchParameterName = inclusionValueParts[1];\n             searchParameterTargetType = inclusionValueParts.length == 3 ? inclusionValueParts[2] : null;\n \n-            // Ensure that the Inclusion Parameter being parsed is a valid search parameter of type 'reference'.\n-            searchParm                = getSearchParameter(joinResourceType, searchParameterName);\n-            if (searchParm == null) {\n-                String msg = \"Undefined Inclusion Parameter: \" + inclusionValue;\n-                if (lenient) {\n-                    // TODO add this to the list of supplemental warnings?\n-                    log.fine(msg);\n-                    continue;\n-                } else {\n-                    throw SearchExceptionUtil.buildNewInvalidSearchException(msg);\n-                }\n+            // For _include parameter, join resource type must match resource type being searched\n+            if (SearchConstants.INCLUDE.equals(inclusionKeyword) && !joinResourceType.equals(resourceType.getSimpleName())) {\n+                throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                        \"The join resource type must match the resource type being searched.\");\n             }\n-            if (!searchParm.getType().getValue().equals(\"reference\")) {\n-                throw SearchExceptionUtil\n-                        .buildNewInvalidSearchException(\"Inclusion Parameter must be of type 'reference'. \"\n-                                + \"The passed Inclusion Parameter is of type: \" + searchParm.getType().getValue());\n+\n+            // For _revinclude parameter, target resource type, if specified, must match resource type being searched\n+            if (SearchConstants.REVINCLUDE.equals(inclusionKeyword) && searchParameterTargetType != null\n+                    && !searchParameterTargetType.equals(resourceType.getSimpleName())) {\n+                throw SearchExceptionUtil.buildNewInvalidSearchException(\"The search parameter target type must match the resource type being searched.\");\n             }\n \n-            if (inclusionKeyword.equals(SearchConstants.INCLUDE)) {\n-                newInclusionParms =\n-                        buildIncludeParameter(resourceType, joinResourceType, searchParm, searchParameterName,\n-                                searchParameterTargetType);\n-                context.getIncludeParameters().addAll(newInclusionParms);\n+            // Ensure that the Inclusion Parameter being parsed is a valid search parameter of type 'reference'.\n+            Map<String, SearchParameter> searchParametersMap;\n+            if (SearchConstants.WILDCARD.equals(searchParameterName)) {\n+                searchParametersMap = getInclusionWildcardSearchParameters(resourceType.getSimpleName(), joinResourceType, searchParameterTargetType, inclusionKeyword);\n             } else {\n-                newInclusionParm =\n-                        buildRevIncludeParameter(resourceType, joinResourceType, searchParm, searchParameterName,\n-                                searchParameterTargetType);\n-                context.getRevIncludeParameters().add(newInclusionParm);\n+                searchParm = getSearchParameter(joinResourceType, searchParameterName);\n+                if (searchParm == null) {\n+                    String msg = \"Undefined Inclusion Parameter: \" + inclusionValue;\n+                    if (lenient) {\n+                        // TODO add this to the list of supplemental warnings?\n+                        log.fine(msg);\n+                        continue;\n+                    } else {\n+                        throw SearchExceptionUtil.buildNewInvalidSearchException(msg);\n+                    }\n+                }\n+                if (!searchParm.getType().getValue().equals(\"reference\")) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(\"Inclusion Parameter must be of type 'reference'. \"\n+                            + \"The passed Inclusion Parameter is of type: \" + searchParm.getType().getValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b32bd572f29429d86f9b80ce874cf041332dbc9"}, "originalPosition": 150}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0MjU1NDA4", "url": "https://github.com/IBM/FHIR/pull/1486#pullrequestreview-484255408", "createdAt": "2020-09-08T15:26:23Z", "commit": {"oid": "8b32bd572f29429d86f9b80ce874cf041332dbc9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNToyNjoyM1rOHOik3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNToyNjoyM1rOHOik3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAwODYwNA==", "bodyText": "Let's add a set of extra tests. That has two _include search parameters on Patient and Provenance.  we want to double check that it works across multiple resources.", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r485008604", "createdAt": "2020-09-08T15:26:23Z", "author": {"login": "prb112"}, "path": "fhir-search/src/test/java/com/ibm/fhir/search/test/InclusionParameterParseTest.java", "diffHunk": "@@ -327,4 +340,151 @@ public void testMultiIncludeRevinclude() throws Exception {\n         assertTrue(selfUri.contains(include4));\n     }\n \n+    @Test\n+    public void testWildcardIncludeNoMatchingTargetType() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Patient> resourceType = Patient.class;\n+\n+        queryParameters.put(\"_include\", Collections.singletonList(\"Patient:*:Medication\"));\n+        FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+\n+        assertNotNull(searchContext);\n+        assertFalse(searchContext.hasIncludeParameters());\n+        assertFalse(searchContext.hasRevIncludeParameters());\n+\n+        String selfUri = SearchUtil.buildSearchSelfUri(\"http://example.com/Patient\", searchContext);\n+        assertTrue(selfUri.equals(\"http://example.com/Patient?_count=10&_page=1\"));\n+    }\n+\n+    @Test\n+    public void testWildcardIncludeSingleMatchingTargetType() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Patient> resourceType = Patient.class;\n+\n+        queryParameters.put(\"_include\", Collections.singletonList(\"Patient:*:RelatedPerson\"));\n+        FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+\n+        assertNotNull(searchContext);\n+        assertTrue(searchContext.hasIncludeParameters());\n+        assertEquals(1, searchContext.getIncludeParameters().size());\n+        InclusionParameter incParm = searchContext.getIncludeParameters().get(0);\n+        assertEquals(\"Patient\", incParm.getJoinResourceType());\n+        assertEquals(\"link\", incParm.getSearchParameter());\n+        assertEquals(\"RelatedPerson\", incParm.getSearchParameterTargetType());\n+        assertFalse(searchContext.hasRevIncludeParameters());\n+\n+        String selfUri = SearchUtil.buildSearchSelfUri(\"http://example.com/Patient\", searchContext);\n+        assertTrue(selfUri.equals(\"http://example.com/Patient?_count=10&_include=\" + incParm.getJoinResourceType() +\n+            \":\" + incParm.getSearchParameter() + \":\" + incParm.getSearchParameterTargetType() + \"&_page=1\"));\n+    }\n+\n+    @Test\n+    public void testWildcardIncludeNoTargetType() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Patient> resourceType = Patient.class;\n+        String include1 = \"&_include=Patient:general-practitioner:Organization\";\n+        String include2 = \"&_include=Patient:general-practitioner:Practitioner\";\n+        String include3 = \"&_include=Patient:general-practitioner:PractitionerRole\";\n+        String include4 = \"&_include=Patient:organization:Organization\";\n+        String include5 = \"&_include=Patient:link:Patient\";\n+        String include6 = \"&_include=Patient:link:RelatedPerson\";\n+\n+        List<InclusionParameter> expectedIncludeParms = new ArrayList<>();\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"general-practitioner\", \"Organization\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"general-practitioner\", \"Practitioner\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"general-practitioner\", \"PractitionerRole\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"organization\", \"Organization\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"link\", \"Patient\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"link\", \"RelatedPerson\"));\n+\n+        queryParameters.put(\"_include\", Collections.singletonList(\"Patient:*\"));\n+        FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+\n+        assertNotNull(searchContext);\n+        assertTrue(searchContext.hasIncludeParameters());\n+        assertEquals(expectedIncludeParms.size(), searchContext.getIncludeParameters().size());\n+        for (InclusionParameter includeParm : expectedIncludeParms) {\n+            assertTrue(expectedIncludeParms.contains(includeParm));\n+        }\n+\n+        assertFalse(searchContext.hasRevIncludeParameters());\n+\n+        String selfUri = SearchUtil.buildSearchSelfUri(\"http://example.com/Patient\", searchContext);\n+        assertTrue(selfUri.contains(include1));\n+        assertTrue(selfUri.contains(include2));\n+        assertTrue(selfUri.contains(include3));\n+        assertTrue(selfUri.contains(include4));\n+        assertTrue(selfUri.contains(include5));\n+        assertTrue(selfUri.contains(include6));\n+    }\n+\n+    @Test\n+    public void testWildcardRevIncludeNoMatchingTargetType() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Condition> resourceType = Condition.class;\n+\n+        queryParameters.put(\"_revinclude\", Collections.singletonList(\"Patient:*:Condition\"));\n+        FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+\n+        assertNotNull(searchContext);\n+        assertFalse(searchContext.hasIncludeParameters());\n+        assertFalse(searchContext.hasRevIncludeParameters());\n+\n+        String selfUri = SearchUtil.buildSearchSelfUri(\"http://example.com/Condition\", searchContext);\n+        assertTrue(selfUri.equals(\"http://example.com/Condition?_count=10&_page=1\"));\n+    }\n+\n+    @Test\n+    public void testWildcardRevIncludeSingleMatchingTargetType() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Encounter> resourceType = Encounter.class;\n+\n+        queryParameters.put(\"_revinclude\", Collections.singletonList(\"MedicationAdministration:*:Encounter\"));\n+        FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+\n+        assertNotNull(searchContext);\n+        assertTrue(searchContext.hasRevIncludeParameters());\n+        assertEquals(1, searchContext.getRevIncludeParameters().size());\n+        InclusionParameter incParm = searchContext.getRevIncludeParameters().get(0);\n+        assertEquals(\"MedicationAdministration\", incParm.getJoinResourceType());\n+        assertEquals(\"context\", incParm.getSearchParameter());\n+        assertEquals(\"Encounter\", incParm.getSearchParameterTargetType());\n+        assertFalse(searchContext.hasIncludeParameters());\n+\n+        String selfUri = SearchUtil.buildSearchSelfUri(\"http://example.com/Encounter\", searchContext);\n+        assertTrue(selfUri.equals(\"http://example.com/Encounter?_count=10&_revinclude=\" + incParm.getJoinResourceType() +\n+            \":\" + incParm.getSearchParameter() + \":\" + incParm.getSearchParameterTargetType() + \"&_page=1\"));\n+    }\n+\n+    @Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b32bd572f29429d86f9b80ce874cf041332dbc9"}, "originalPosition": 152}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44188619282c7e61b8ecb13e935132ba168401d4", "author": {"user": {"login": "michaelwschroeder", "name": "Michael W Schroeder"}}, "url": "https://github.com/IBM/FHIR/commit/44188619282c7e61b8ecb13e935132ba168401d4", "committedDate": "2020-09-08T21:10:28Z", "message": "Issue #1262 - address review comments, add tests\n\nSigned-off-by: Mike Schroeder <mschroed@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e85a6064ae12aacf54e2c0d14898928e00873d4", "author": {"user": {"login": "prb112", "name": "Paul Bastide"}}, "url": "https://github.com/IBM/FHIR/commit/3e85a6064ae12aacf54e2c0d14898928e00873d4", "committedDate": "2020-09-09T00:32:16Z", "message": "fix: double practitioner in SearchTest #1262\n\nSigned-off-by: Paul Bastide <pbastide@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f8164760f9300611ac93b3edf25107e652f39d02", "author": {"user": {"login": "prb112", "name": "Paul Bastide"}}, "url": "https://github.com/IBM/FHIR/commit/f8164760f9300611ac93b3edf25107e652f39d02", "committedDate": "2020-09-09T11:40:55Z", "message": "Merge pull request #1492 from IBM/issue-1262-pbastide\n\nfix: double practitioner in SearchTest #1262"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1MDMyNjc5", "url": "https://github.com/IBM/FHIR/pull/1486#pullrequestreview-485032679", "createdAt": "2020-09-09T13:53:30Z", "commit": {"oid": "f8164760f9300611ac93b3edf25107e652f39d02"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1MDQ2NDQ3", "url": "https://github.com/IBM/FHIR/pull/1486#pullrequestreview-485046447", "createdAt": "2020-09-09T14:06:43Z", "commit": {"oid": "f8164760f9300611ac93b3edf25107e652f39d02"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 821, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}