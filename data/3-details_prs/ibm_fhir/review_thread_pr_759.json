{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgzOTU3MDc4", "number": 759, "reviewThreads": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMToxODozM1rODlYmNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNzowMDozMVrODmYeGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNTI2OTAxOnYy", "diffSide": "RIGHT", "path": "fhir-audit/src/main/java/com/ibm/fhir/audit/logging/impl/WhcAuditCadfLogService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMToxODozM1rOFyPt4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMzoxODoyN1rOFyTH2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIzMDYyNA==", "bodyText": "the ordering made me smile :)", "url": "https://github.com/IBM/FHIR/pull/759#discussion_r388230624", "createdAt": "2020-03-05T11:18:33Z", "author": {"login": "prb112"}, "path": "fhir-audit/src/main/java/com/ibm/fhir/audit/logging/impl/WhcAuditCadfLogService.java", "diffHunk": "@@ -69,22 +69,22 @@\n     private boolean isEnabled = false;\n \n     private static final Map<String, Action> fhir2CadfMap = new HashMap<String, Action>() {\n-\n         private static final long serialVersionUID = 1L;\n         {\n             put(\"C\", Action.create);\n-            put(\"D\", Action.delete);\n-            put(\"U\", Action.update);\n             put(\"R\", Action.read);\n+            put(\"U\", Action.update);\n+            put(\"D\", Action.delete);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0ff4daa4297bea3aff6025eac16697c3fe6ecb1"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI4NjQyNA==", "bodyText": "I did a quick review of our auditing stuff and I think it needs some love, but for now I contained myself to this simple change :-)", "url": "https://github.com/IBM/FHIR/pull/759#discussion_r388286424", "createdAt": "2020-03-05T13:18:27Z", "author": {"login": "lmsurpre"}, "path": "fhir-audit/src/main/java/com/ibm/fhir/audit/logging/impl/WhcAuditCadfLogService.java", "diffHunk": "@@ -69,22 +69,22 @@\n     private boolean isEnabled = false;\n \n     private static final Map<String, Action> fhir2CadfMap = new HashMap<String, Action>() {\n-\n         private static final long serialVersionUID = 1L;\n         {\n             put(\"C\", Action.create);\n-            put(\"D\", Action.delete);\n-            put(\"U\", Action.update);\n             put(\"R\", Action.read);\n+            put(\"U\", Action.update);\n+            put(\"D\", Action.delete);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIzMDYyNA=="}, "originalCommit": {"oid": "d0ff4daa4297bea3aff6025eac16697c3fe6ecb1"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNTI3MjE0OnYy", "diffSide": "RIGHT", "path": "fhir-notification/src/main/java/com/ibm/fhir/notification/FHIRNotificationEvent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMToxOTozN1rOFyPvyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMToxOTozN1rOFyPvyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIzMTExNA==", "bodyText": "please update the copyright year", "url": "https://github.com/IBM/FHIR/pull/759#discussion_r388231114", "createdAt": "2020-03-05T11:19:37Z", "author": {"login": "prb112"}, "path": "fhir-notification/src/main/java/com/ibm/fhir/notification/FHIRNotificationEvent.java", "diffHunk": "@@ -6,8 +6,6 @@\n \n package com.ibm.fhir.notification;\n \n-import javax.ws.rs.core.HttpHeaders;\n-\n import com.ibm.fhir.model.resource.Resource;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0ff4daa4297bea3aff6025eac16697c3fe6ecb1"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNTI3MzkzOnYy", "diffSide": "RIGHT", "path": "fhir-audit/src/main/java/com/ibm/fhir/audit/logging/impl/WhcAuditCadfLogService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMToyMDoxOVrOFyPw9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMToyMDoxOVrOFyPw9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIzMTQxNQ==", "bodyText": "please update the copyright year", "url": "https://github.com/IBM/FHIR/pull/759#discussion_r388231415", "createdAt": "2020-03-05T11:20:19Z", "author": {"login": "prb112"}, "path": "fhir-audit/src/main/java/com/ibm/fhir/audit/logging/impl/WhcAuditCadfLogService.java", "diffHunk": "@@ -69,22 +69,22 @@\n     private boolean isEnabled = false;\n \n     private static final Map<String, Action> fhir2CadfMap = new HashMap<String, Action>() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0ff4daa4297bea3aff6025eac16697c3fe6ecb1"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNTI3NTQyOnYy", "diffSide": "RIGHT", "path": "fhir-operation-document/src/main/java/com/ibm/fhir/operation/document/DocumentOperation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMToyMDo0OFrOFyPx4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMToyMDo0OFrOFyPx4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIzMTY0OA==", "bodyText": "please update copyright year (I know this one is small)", "url": "https://github.com/IBM/FHIR/pull/759#discussion_r388231648", "createdAt": "2020-03-05T11:20:48Z", "author": {"login": "prb112"}, "path": "fhir-operation-document/src/main/java/com/ibm/fhir/operation/document/DocumentOperation.java", "diffHunk": "@@ -61,7 +61,7 @@ protected Parameters doInvoke(FHIROperationContext operationContext, Class<? ext\n             \n             composition = (Composition) resource;\n             \n-            Bundle bundle = buildDocument(operationContext, composition, resourceHelper);            \n+            Bundle bundle = buildDocument(operationContext, composition, resourceHelper);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0ff4daa4297bea3aff6025eac16697c3fe6ecb1"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNTI3NjYzOnYy", "diffSide": "RIGHT", "path": "fhir-operation-healthcheck/src/main/java/com/ibm/fhir/operation/healthcheck/HealthcheckOperation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMToyMTowN1rOFyPyig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMToyMTowN1rOFyPyig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIzMTgxOA==", "bodyText": "please update the above copyright header", "url": "https://github.com/IBM/FHIR/pull/759#discussion_r388231818", "createdAt": "2020-03-05T11:21:07Z", "author": {"login": "prb112"}, "path": "fhir-operation-healthcheck/src/main/java/com/ibm/fhir/operation/healthcheck/HealthcheckOperation.java", "diffHunk": "@@ -32,7 +32,7 @@ public HealthcheckOperation() {\n     @Override\n     protected OperationDefinition buildOperationDefinition() {\n         try (InputStream in = getClass().getClassLoader().getResourceAsStream(\"healthcheck.json\")) {\n-            return FHIRParser.parser(Format.JSON).parse(in);            \n+            return FHIRParser.parser(Format.JSON).parse(in);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0ff4daa4297bea3aff6025eac16697c3fe6ecb1"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNTI3NzY3OnYy", "diffSide": "RIGHT", "path": "fhir-operation/src/main/java/com/ibm/fhir/operation/context/FHIROperationContext.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMToyMToyOVrOFyPzNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMToyMToyOVrOFyPzNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIzMTk4OQ==", "bodyText": "copyright header", "url": "https://github.com/IBM/FHIR/pull/759#discussion_r388231989", "createdAt": "2020-03-05T11:21:29Z", "author": {"login": "prb112"}, "path": "fhir-operation/src/main/java/com/ibm/fhir/operation/context/FHIROperationContext.java", "diffHunk": "@@ -106,9 +99,8 @@ public Object getProperty(String name) {\n     }\n     \n     /**\n-     * Returns the HttpHeaders instance associated with the FHIR REST API request that triggered the\n-     * interceptor invocation.\n-     * Note that this HttpHeaders instance is only valid within the scope of the REST API request.\n+     * Returns the HttpHeaders instance associated with the request that triggered the operation.\n+     * Note that this HttpHeaders instance is only valid within the scope of a single request.\n      */\n     public HttpHeaders getHttpHeaders() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0ff4daa4297bea3aff6025eac16697c3fe6ecb1"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNTI3OTUxOnYy", "diffSide": "RIGHT", "path": "fhir-notification/src/main/java/com/ibm/fhir/notification/FHIRNotificationService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMToyMTo1OVrOFyP0Ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMToyMTo1OVrOFyP0Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIzMjI0Ng==", "bodyText": "copyright header", "url": "https://github.com/IBM/FHIR/pull/759#discussion_r388232246", "createdAt": "2020-03-05T11:21:59Z", "author": {"login": "prb112"}, "path": "fhir-notification/src/main/java/com/ibm/fhir/notification/FHIRNotificationService.java", "diffHunk": "@@ -226,7 +226,6 @@ private FHIRNotificationEvent buildNotificationEvent(String operation, FHIRPersi\n             event.setLocation((String) pEvent.getProperty(FHIRPersistenceEvent.PROPNAME_RESOURCE_LOCATION_URI));\n             event.setResourceId(resource.getId());\n             event.setResource(resource);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0ff4daa4297bea3aff6025eac16697c3fe6ecb1"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNTI4MTE1OnYy", "diffSide": "RIGHT", "path": "fhir-persistence/src/main/java/com/ibm/fhir/persistence/interceptor/FHIRPersistenceEvent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMToyMjozOVrOFyP1Rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMToyMjozOVrOFyP1Rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIzMjUxOA==", "bodyText": "copyright header", "url": "https://github.com/IBM/FHIR/pull/759#discussion_r388232518", "createdAt": "2020-03-05T11:22:39Z", "author": {"login": "prb112"}, "path": "fhir-persistence/src/main/java/com/ibm/fhir/persistence/interceptor/FHIRPersistenceEvent.java", "diffHunk": "@@ -9,10 +9,6 @@\n import java.util.HashMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0ff4daa4297bea3aff6025eac16697c3fe6ecb1"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNTI4NDYyOnYy", "diffSide": "RIGHT", "path": "fhir-persistence/src/main/java/com/ibm/fhir/persistence/interceptor/FHIRPersistenceEvent.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMToyMzo0NFrOFyP3Vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNjozOToxM1rOFzwXkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIzMzA0Nw==", "bodyText": "Leaving a general comment... so ... I do think we're locking down the flexibility of downstream applications to source custom headers and custom rest behaviors from the URL.  What is the approach in this case?\nFor instance, we have the DataSourceID...", "url": "https://github.com/IBM/FHIR/pull/759#discussion_r388233047", "createdAt": "2020-03-05T11:23:44Z", "author": {"login": "prb112"}, "path": "fhir-persistence/src/main/java/com/ibm/fhir/persistence/interceptor/FHIRPersistenceEvent.java", "diffHunk": "@@ -21,45 +17,19 @@\n  * This class represents an event fired by the FHIR persistence interceptor framework.\n  */\n public class FHIRPersistenceEvent {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0ff4daa4297bea3aff6025eac16697c3fe6ecb1"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI4NDIyNQ==", "bodyText": "We already have that dataStoreId (and others) in the FHIRRequestContext which is a threadlocal that we set up in the FHIRRestServletFilter.  My thought is that we can put context related to the HTTP request in there as needed, but its really just a thought...", "url": "https://github.com/IBM/FHIR/pull/759#discussion_r388284225", "createdAt": "2020-03-05T13:14:15Z", "author": {"login": "lmsurpre"}, "path": "fhir-persistence/src/main/java/com/ibm/fhir/persistence/interceptor/FHIRPersistenceEvent.java", "diffHunk": "@@ -21,45 +17,19 @@\n  * This class represents an event fired by the FHIR persistence interceptor framework.\n  */\n public class FHIRPersistenceEvent {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIzMzA0Nw=="}, "originalCommit": {"oid": "d0ff4daa4297bea3aff6025eac16697c3fe6ecb1"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODMzMTI3MQ==", "bodyText": "I would think maybe there there are more info in the header than what we plan to use now, maybe we can find values in the other headers in the future analytic, so I would think not a bad idea to keep the headers ...", "url": "https://github.com/IBM/FHIR/pull/759#discussion_r388331271", "createdAt": "2020-03-05T14:34:22Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-persistence/src/main/java/com/ibm/fhir/persistence/interceptor/FHIRPersistenceEvent.java", "diffHunk": "@@ -21,45 +17,19 @@\n  * This class represents an event fired by the FHIR persistence interceptor framework.\n  */\n public class FHIRPersistenceEvent {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIzMzA0Nw=="}, "originalCommit": {"oid": "d0ff4daa4297bea3aff6025eac16697c3fe6ecb1"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg4NTUwOA==", "bodyText": "I agree with Albert", "url": "https://github.com/IBM/FHIR/pull/759#discussion_r388885508", "createdAt": "2020-03-06T12:52:30Z", "author": {"login": "prb112"}, "path": "fhir-persistence/src/main/java/com/ibm/fhir/persistence/interceptor/FHIRPersistenceEvent.java", "diffHunk": "@@ -21,45 +17,19 @@\n  * This class represents an event fired by the FHIR persistence interceptor framework.\n  */\n public class FHIRPersistenceEvent {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIzMzA0Nw=="}, "originalCommit": {"oid": "d0ff4daa4297bea3aff6025eac16697c3fe6ecb1"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgxNDE2Mg==", "bodyText": "I've updated the PR to capture httpHeaders in the FHIRRequestContext", "url": "https://github.com/IBM/FHIR/pull/759#discussion_r389814162", "createdAt": "2020-03-09T16:39:13Z", "author": {"login": "lmsurpre"}, "path": "fhir-persistence/src/main/java/com/ibm/fhir/persistence/interceptor/FHIRPersistenceEvent.java", "diffHunk": "@@ -21,45 +17,19 @@\n  * This class represents an event fired by the FHIR persistence interceptor framework.\n  */\n public class FHIRPersistenceEvent {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIzMzA0Nw=="}, "originalCommit": {"oid": "d0ff4daa4297bea3aff6025eac16697c3fe6ecb1"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNTI4NzIwOnYy", "diffSide": "RIGHT", "path": "fhir-persistence/src/test/java/com/ibm/fhir/persistence/test/FHIRPersistenceEventTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMToyNDozM1rOFyP44A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMToyNDozM1rOFyP44A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIzMzQ0MA==", "bodyText": "copyright header", "url": "https://github.com/IBM/FHIR/pull/759#discussion_r388233440", "createdAt": "2020-03-05T11:24:33Z", "author": {"login": "prb112"}, "path": "fhir-persistence/src/test/java/com/ibm/fhir/persistence/test/FHIRPersistenceEventTest.java", "diffHunk": "@@ -32,10 +32,6 @@ public void testDefaultEvent() {\n         assertNull(pe.getFhirResourceId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0ff4daa4297bea3aff6025eac16697c3fe6ecb1"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNTI4NzgyOnYy", "diffSide": "LEFT", "path": "fhir-server-test/src/test/java/com/ibm/fhir/server/test/FHIRHealthcheckOperationTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMToyNDo0NVrOFyP5RQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMToyNDo0NVrOFyP5RQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIzMzU0MQ==", "bodyText": "copyright header", "url": "https://github.com/IBM/FHIR/pull/759#discussion_r388233541", "createdAt": "2020-03-05T11:24:45Z", "author": {"login": "prb112"}, "path": "fhir-server-test/src/test/java/com/ibm/fhir/server/test/FHIRHealthcheckOperationTest.java", "diffHunk": "@@ -18,7 +18,7 @@\n \n public class FHIRHealthcheckOperationTest extends FHIRServerTestBase {    \n     @Test\n-    public void testHealthcheck() {        ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0ff4daa4297bea3aff6025eac16697c3fe6ecb1"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNTI5MDQwOnYy", "diffSide": "LEFT", "path": "fhir-server/src/main/java/com/ibm/fhir/server/util/RestAuditLogger.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMToyNTozNlrOFyP6zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMToyNTozNlrOFyP6zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIzMzkzNQ==", "bodyText": "copyright header", "url": "https://github.com/IBM/FHIR/pull/759#discussion_r388233935", "createdAt": "2020-03-05T11:25:36Z", "author": {"login": "prb112"}, "path": "fhir-server/src/main/java/com/ibm/fhir/server/util/RestAuditLogger.java", "diffHunk": "@@ -76,7 +76,7 @@ public static void logCreate(HttpServletRequest request, Resource resource, Date\n         AuditLogService auditLogSvc = AuditLogServiceFactory.getService();\n         AuditLogEntry entry = initLogEntry(AuditLogEventType.FHIR_CREATE);\n         populateAuditLogEntry(entry, request, resource, startTime, endTime, responseStatus);\n-                ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0ff4daa4297bea3aff6025eac16697c3fe6ecb1"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNTMxODYxOnYy", "diffSide": "RIGHT", "path": "fhir-server/src/main/java/com/ibm/fhir/server/resources/FHIRRestHelper.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMTozNDo1OVrOFyQLpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNjo0MDoxNFrOFzwaDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIzODI0NA==", "bodyText": "This is going to sound strange... I think this one has validity to move up to FHIRUtil\nI think I wrote similar code for tests (not only for tests) in Search", "url": "https://github.com/IBM/FHIR/pull/759#discussion_r388238244", "createdAt": "2020-03-05T11:34:59Z", "author": {"login": "prb112"}, "path": "fhir-server/src/main/java/com/ibm/fhir/server/resources/FHIRRestHelper.java", "diffHunk": "@@ -0,0 +1,2448 @@\n+/*\n+ * (C) Copyright IBM Corp. 2016, 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.server.resources;\n+\n+import static com.ibm.fhir.model.type.String.string;\n+import static com.ibm.fhir.model.util.ModelSupport.getResourceType;\n+import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;\n+import static javax.servlet.http.HttpServletResponse.SC_GONE;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static javax.servlet.http.HttpServletResponse.SC_OK;\n+\n+import java.net.URI;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeFormatterBuilder;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.Status;\n+\n+import org.owasp.encoder.Encode;\n+\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.core.HTTPHandlingPreference;\n+import com.ibm.fhir.core.HTTPReturnPreference;\n+import com.ibm.fhir.core.context.FHIRPagingContext;\n+import com.ibm.fhir.exception.FHIROperationException;\n+import com.ibm.fhir.model.patch.FHIRPatch;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.OperationOutcome;\n+import com.ibm.fhir.model.resource.OperationOutcome.Issue;\n+import com.ibm.fhir.model.resource.Parameters;\n+import com.ibm.fhir.model.resource.Resource;\n+import com.ibm.fhir.model.type.CodeableConcept;\n+import com.ibm.fhir.model.type.Extension;\n+import com.ibm.fhir.model.type.UnsignedInt;\n+import com.ibm.fhir.model.type.Uri;\n+import com.ibm.fhir.model.type.Url;\n+import com.ibm.fhir.model.type.code.BundleType;\n+import com.ibm.fhir.model.type.code.HTTPVerb;\n+import com.ibm.fhir.model.type.code.IssueSeverity;\n+import com.ibm.fhir.model.type.code.IssueType;\n+import com.ibm.fhir.model.util.FHIRUtil;\n+import com.ibm.fhir.model.util.ModelSupport;\n+import com.ibm.fhir.model.util.ReferenceMappingVisitor;\n+import com.ibm.fhir.operation.FHIROperation;\n+import com.ibm.fhir.operation.context.FHIROperationContext;\n+import com.ibm.fhir.operation.registry.FHIROperationRegistry;\n+import com.ibm.fhir.operation.util.FHIROperationUtil;\n+import com.ibm.fhir.persistence.FHIRPersistence;\n+import com.ibm.fhir.persistence.FHIRPersistenceTransaction;\n+import com.ibm.fhir.persistence.context.FHIRHistoryContext;\n+import com.ibm.fhir.persistence.context.FHIRPersistenceContext;\n+import com.ibm.fhir.persistence.context.FHIRPersistenceContextFactory;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceResourceDeletedException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceResourceNotFoundException;\n+import com.ibm.fhir.persistence.helper.FHIRTransactionHelper;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceEvent;\n+import com.ibm.fhir.persistence.interceptor.impl.FHIRPersistenceInterceptorMgr;\n+import com.ibm.fhir.persistence.util.FHIRPersistenceUtil;\n+import com.ibm.fhir.rest.FHIRResourceHelpers;\n+import com.ibm.fhir.rest.FHIRRestOperationResponse;\n+import com.ibm.fhir.search.SearchConstants;\n+import com.ibm.fhir.search.SummaryValueSet;\n+import com.ibm.fhir.search.context.FHIRSearchContext;\n+import com.ibm.fhir.search.exception.FHIRSearchException;\n+import com.ibm.fhir.search.util.SearchUtil;\n+import com.ibm.fhir.server.exception.FHIRRestBundledRequestException;\n+import com.ibm.fhir.server.helper.FHIRUrlParser;\n+import com.ibm.fhir.server.util.IssueTypeToHttpStatusMapper;\n+import com.ibm.fhir.validation.FHIRValidator;\n+import com.ibm.fhir.validation.exception.FHIRValidationException;\n+\n+public class FHIRRestHelper implements FHIRResourceHelpers {\n+    private static final Logger log =\n+            java.util.logging.Logger.getLogger(FHIRRestHelper.class.getName());\n+\n+    private static final String EXTENSION_URL = \"http://ibm.com/fhir/extension\";\n+    private static final String LOCAL_REF_PREFIX = \"urn:\";\n+\n+    public static final DateTimeFormatter PARSER_FORMATTER = new DateTimeFormatterBuilder()\n+            .appendPattern(\"EEE\")\n+            .optionalStart()\n+            // ANSIC date time format for If-Modified-Since\n+            .appendPattern(\" MMM dd HH:mm:ss yyyy\")\n+            .optionalEnd()\n+            .optionalStart()\n+            // Touchstone date time format for If-Modified-Since\n+            .appendPattern(\", dd-MMM-yy HH:mm:ss\")\n+            .optionalEnd().toFormatter();\n+\n+    private FHIRPersistence persistence = null;\n+\n+    // These values are used for correlating requests within a bundle.\n+    private String bundleTransactionCorrelationId = null;\n+    private String bundleRequestCorrelationId = null;\n+\n+    public FHIRRestHelper(FHIRPersistence persistence) {\n+        this.persistence = persistence;\n+    }\n+\n+    /**\n+     * Performs the heavy lifting associated with a 'create' interaction.\n+     *\n+     * @param type\n+     *            the resource type specified as part of the request URL\n+     * @param resource\n+     *            the Resource to be stored.\n+     * @param ifNoneExist\n+     *            whether to create the resource if none exists\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return a FHIRRestOperationResponse object containing the results of the operation\n+     * @throws Exception\n+     */\n+    @Override\n+    public FHIRRestOperationResponse doCreate(String type, Resource resource, String ifNoneExist,\n+            Map<String, String> requestProperties) throws Exception {\n+        log.entering(this.getClass().getName(), \"doCreate\");\n+\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+        FHIRRestOperationResponse ior = new FHIRRestOperationResponse();\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+\n+            // Make sure the expected type (specified in the URL string) is congruent with the actual type\n+            // of the resource.\n+            String resourceType = ModelSupport.getTypeName(resource.getClass()); \n+            if (!resourceType.equals(type)) {\n+                String msg = \"Resource type '\" + resourceType\n+                        + \"' does not match type specified in request URI: \" + type;\n+                throw buildRestException(msg, IssueType.INVALID);\n+            }\n+\n+            // Check to see if we're supposed to perform a conditional 'create'.\n+            if (ifNoneExist != null && !ifNoneExist.isEmpty()) {\n+                log.fine(\"Performing conditional create with search criteria: \" + ifNoneExist);\n+                Bundle responseBundle = null;\n+\n+                // Perform the search using the \"If-None-Exist\" header value.\n+                try {\n+                    MultivaluedMap<String, String> searchParameters = getQueryParameterMap(ifNoneExist);\n+                    responseBundle =\n+                            doSearch(type, null, null, searchParameters, null, requestProperties, resource);\n+                } catch (FHIROperationException e) {\n+                    throw e;\n+                } catch (Throwable t) {\n+                    String msg =\n+                            \"An error occurred while performing the search for a conditional create operation.\";\n+                    log.log(Level.WARNING, msg, t);\n+                    throw new FHIROperationException(msg, t);\n+                }\n+\n+                // Check the search results to determine whether or not to perform the create operation.\n+                int resultCount = responseBundle.getEntry().size();\n+                log.fine(\"Conditional create search yielded \" + resultCount + \" results.\");\n+\n+                if (resultCount == 0) {\n+                    // Do nothing and fall through to process the 'create' request.\n+                } else if (resultCount == 1) {\n+                    // If we found a single match, bypass the 'create' request and return information\n+                    // for the matched resource.\n+                    Resource matchedResource = responseBundle.getEntry().get(0).getResource();\n+                    ior.setLocationURI(FHIRUtil.buildLocationURI(type, matchedResource));\n+                    ior.setStatus(Response.Status.OK);\n+                    ior.setResource(matchedResource);\n+                    log.fine(\"Returning location URI of matched resource: \" + ior.getLocationURI());\n+                    return ior;\n+                } else {\n+                    String msg =\n+                            \"The search criteria specified for a conditional create operation returned multiple matches.\";\n+                    throw buildRestException(msg, IssueType.MULTIPLE_MATCHES);\n+                }\n+            }\n+\n+            // For R4, resources may contain an id. For create, this should be ignored and\n+            // we no longer reject the request.\n+            if (resource.getId() != null && log.isLoggable(Level.FINE)) {\n+                log.fine(String.format(\"create request resource includes id: '%s'\", resource.getId()));\n+            }\n+\n+            // Validate the input resource and return any validation errors, but warnings are OK\n+            List<Issue> validationWarnings = validateInput(resource);\n+            ior.setOperationOutcome(FHIRUtil.buildOperationOutcome(validationWarnings));\n+\n+            // If there were no validation errors, then create the resource and return the location header.\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, invoke the 'beforeCreate' interceptor methods.\n+            FHIRPersistenceEvent event =\n+                    new FHIRPersistenceEvent(resource, buildPersistenceEventProperties(type, null, null, requestProperties));\n+            getInterceptorMgr().fireBeforeCreateEvent(event);\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event);\n+\n+            // R4: remember model objects are immutable, so we get back a new resource with the id/meta stuff\n+            resource = persistence.create(persistenceContext, resource).getResource();\n+            event.setFhirResource(resource); // update event with latest\n+            ior.setStatus(Response.Status.CREATED);\n+            ior.setResource(resource);\n+\n+            // Build our location URI and add it to the interceptor event structure since it is now known.\n+            ior.setLocationURI(FHIRUtil.buildLocationURI(ModelSupport.getTypeName(resource.getClass()), resource));\n+            event.getProperties().put(FHIRPersistenceEvent.PROPNAME_RESOURCE_LOCATION_URI, ior.getLocationURI().toString());\n+\n+            // Invoke the 'afterCreate' interceptor methods.\n+            getInterceptorMgr().fireAfterCreateEvent(event);\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+\n+            return ior;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we previously started a transaction and it's still active, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doCreate\");\n+        }\n+    }\n+\n+    @Override\n+    public FHIRRestOperationResponse doPatch(String type, String id, FHIRPatch patch, String ifMatchValue,\n+            String searchQueryString, Map<String, String> requestProperties) throws Exception {\n+\n+        return doPatchOrUpdate(type, id, patch, null, ifMatchValue, searchQueryString, requestProperties);\n+    }\n+\n+    @Override\n+    public FHIRRestOperationResponse doUpdate(String type, String id, Resource newResource, String ifMatchValue,\n+            String searchQueryString, Map<String, String> requestProperties) throws Exception {\n+\n+        return doPatchOrUpdate(type, id, null, newResource, ifMatchValue, searchQueryString, requestProperties);\n+    }\n+\n+    private FHIRRestOperationResponse doPatchOrUpdate(String type, String id, FHIRPatch patch,\n+            Resource newResource, String ifMatchValue, String searchQueryString,\n+            Map<String, String> requestProperties) throws Exception {\n+        log.entering(this.getClass().getName(), \"doPatchOrUpdate\");\n+\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        FHIRRestOperationResponse ior = new FHIRRestOperationResponse();\n+\n+        try {\n+            // Make sure the type specified in the URL string matches the resource type obtained from the new resource.\n+            if (patch == null) {\n+                String resourceType =  ModelSupport.getTypeName(newResource.getClass());\n+                if (!resourceType.equals(type)) {\n+                    String msg = \"Resource type '\" + resourceType\n+                            + \"' does not match type specified in request URI: \" + type;\n+                    throw buildRestException(msg, IssueType.INVALID);\n+                }\n+            }\n+\n+            // Next, if a conditional update was invoked then use the search criteria to find the\n+            // resource to be updated. Otherwise, we'll use the id value to retrieve the current\n+            // version of the resource.\n+            if (searchQueryString != null) {\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Performing conditional update/patch with search criteria: \"\n+                            + Encode.forHtml(searchQueryString));\n+                }\n+                Bundle responseBundle = null;\n+                try {\n+                    MultivaluedMap<String, String> searchParameters =\n+                            getQueryParameterMap(searchQueryString);\n+                    responseBundle =\n+                            doSearch(type, null, null, searchParameters, null, requestProperties, newResource);\n+                } catch (FHIROperationException e) {\n+                    throw e;\n+                } catch (Throwable t) {\n+                    String msg =\n+                            \"An error occurred while performing the search for a conditional update/patch operation.\";\n+                    throw new FHIROperationException(msg, t);\n+                }\n+\n+                // Check the search results to determine whether or not to perform the update operation.\n+                int resultCount = responseBundle.getEntry().size();\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Conditional update/patch search yielded \" + resultCount + \" results.\");\n+                }\n+\n+                if (resultCount == 0) {\n+                    if (patch != null) {\n+                        String msg =\n+                                \"The search criteria specified for a conditional patch operation did not return any results.\";\n+                        throw buildRestException(msg, IssueType.NOT_FOUND);\n+                    }\n+                    // Search yielded no matches, so we'll do an update/create operation below.\n+                    ior.setPrevResource(null);\n+\n+                    // if no id provided, then generate an id for the input resource\n+                    if (newResource.getId() == null || newResource.getId() == null) {\n+                        id = UUID.randomUUID().toString();\n+                        newResource = newResource.toBuilder().id(id).build();\n+                    } else {\n+                        id = newResource.getId();\n+                    }\n+                } else if (resultCount == 1) {\n+                    // If we found a single match, then we'll perform a normal update on the matched resource.\n+                    ior.setPrevResource(responseBundle.getEntry().get(0).getResource());\n+                    id = ior.getPrevResource().getId();\n+\n+                    // If the id of the input resource is different from the id of the search result,\n+                    // then throw exception.\n+                    if (newResource.getId() != null && newResource.getId() != null\n+                            && !newResource.getId().equalsIgnoreCase(id)) {\n+                        String msg = \"Input resource 'id' attribute must match the id of the search result resource.\";\n+                        throw buildRestException(msg, IssueType.VALUE);\n+                    }\n+                    // Make sure the id of the newResource is not null and is the same as the id of the found resource.\n+                    newResource = newResource.toBuilder().id(id).build();\n+                } else {\n+                    String msg =\n+                            \"The search criteria specified for a conditional update/patch operation returned multiple matches.\";\n+                    throw buildRestException(msg, IssueType.MULTIPLE_MATCHES);\n+                }\n+            } else {\n+                // Make sure an id value was passed in.\n+                if (id == null) {\n+                    String msg = \"The 'id' parameter is required for an update/pach operation.\";\n+                    throw buildRestException(msg, IssueType.REQUIRED);\n+                }\n+\n+                // If an id value was passed in (i.e. the id specified in the REST API URL string),\n+                // then make sure it's the same as the value in the resource.\n+                if (patch == null) {\n+                    // Make sure the resource has an 'id' attribute.\n+                    if (newResource.getId() == null) {\n+                        String msg = \"Input resource must contain an 'id' attribute.\";\n+                        throw buildRestException(msg, IssueType.INVALID);\n+                    }\n+\n+                    if (!newResource.getId().equals(id)) {\n+                        String msg = \"Input resource 'id' attribute must match 'id' parameter.\";\n+                        throw buildRestException(msg, IssueType.VALUE);\n+                    }\n+                }\n+\n+                // Retrieve the resource to be updated using the type and id values.\n+                ior.setPrevResource(doRead(type, id, (patch != null), true, requestProperties, newResource));\n+            }\n+\n+            if (patch != null) {\n+                newResource = patch.apply(ior.getPrevResource());\n+            }\n+\n+            // Validate the input resource and return any validation errors.\n+            List<Issue> validationWarnings = validateInput(newResource);\n+            ior.setOperationOutcome(FHIRUtil.buildOperationOutcome(validationWarnings));\n+\n+            // Perform the \"version-aware\" update check, and also find out if the resource was deleted.\n+            boolean isDeleted = false;\n+            if (ior.getPrevResource() != null) {\n+                performVersionAwareUpdateCheck(ior.getPrevResource(), ifMatchValue);\n+\n+                try {\n+                    doRead(type, id, (patch != null), false, requestProperties, newResource);\n+                } catch (FHIRPersistenceResourceDeletedException e) {\n+                    isDeleted = true;\n+                }\n+            }\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, create the persistence event.\n+            FHIRPersistenceEvent event = new FHIRPersistenceEvent(newResource, \n+                    buildPersistenceEventProperties(type, newResource.getId(), null, requestProperties));\n+\n+            // Next, set the \"previous resource\" in the persistence event.\n+            event.setPrevFhirResource(ior.getPrevResource());\n+\n+            // Next, invoke the 'beforeUpdate' or 'beforeCreate' interceptor methods as appropriate.\n+            boolean updateCreate = (ior.getPrevResource() == null);\n+            if (updateCreate) {\n+                getInterceptorMgr().fireBeforeCreateEvent(event);\n+            } else {\n+                if (patch != null) {\n+                    event.getProperties().put(FHIRPersistenceEvent.PROPNAME_PATCH, patch);\n+                    getInterceptorMgr().fireBeforePatchEvent(event);\n+                } else {\n+                    getInterceptorMgr().fireBeforeUpdateEvent(event);\n+                }\n+            }\n+\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event);\n+            newResource = persistence.update(persistenceContext, id, newResource).getResource();\n+            event.setFhirResource(newResource); // update event with latest\n+            ior.setResource(newResource);\n+\n+            // Build our location URI and add it to the interceptor event structure since it is now known.\n+            ior.setLocationURI(FHIRUtil.buildLocationURI(ModelSupport.getTypeName(newResource.getClass()), newResource));\n+            event.getProperties().put(FHIRPersistenceEvent.PROPNAME_RESOURCE_LOCATION_URI, ior.getLocationURI().toString());\n+\n+            // Invoke the 'afterUpdate' interceptor methods.\n+            if (updateCreate) {\n+                ior.setStatus(Response.Status.CREATED);\n+                getInterceptorMgr().fireAfterCreateEvent(event);\n+            } else {\n+                ior.setStatus(Response.Status.OK);\n+                if (patch != null) {\n+                    getInterceptorMgr().fireAfterPatchEvent(event);\n+                } else {\n+                    getInterceptorMgr().fireAfterUpdateEvent(event);\n+                }\n+            }\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+\n+            // If the deleted resource is updated, then simply return 201 instead of 200 to pass Touchstone test.\n+            // We don't set the previous resource to null in above codes if the resource was deleted, otherwise\n+            // it will break the code logic of the resource versioning.\n+            if (isDeleted && ior.getStatus() == Response.Status.OK) {\n+                ior.setStatus(Response.Status.CREATED);\n+            }\n+\n+            return ior;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we still have a transaction at this point, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doPatchOrUpdate\");\n+        }\n+    }\n+\n+    /**\n+     * Performs a 'delete' operation on the specified resource.\n+     *\n+     * @param type\n+     *            the resource type associated with the Resource to be deleted\n+     * @param id\n+     *            the id of the Resource to be deleted\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return a FHIRRestOperationResponse that contains the results of the operation\n+     * @throws Exception\n+     */\n+    @Override\n+    public FHIRRestOperationResponse doDelete(String type, String id, String searchQueryString,\n+            Map<String, String> requestProperties) throws Exception {\n+        log.entering(this.getClass().getName(), \"doDelete\");\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+        Response.Status status = null;\n+\n+        FHIRRestOperationResponse ior = new FHIRRestOperationResponse();\n+\n+        try {\n+            String resourceTypeName = type;\n+            if (!ModelSupport.isResourceType(type)) {\n+                throw buildUnsupportedResourceTypeException(type, IssueType.NOT_SUPPORTED);\n+            }\n+\n+            Class<? extends Resource> resourceType =\n+                    getResourceType(resourceTypeName);\n+\n+            // Next, if a conditional delete was invoked then use the search criteria to find the\n+            // resource to be deleted. Otherwise, we'll use the id value to identify the resource\n+            // to be deleted.\n+            Resource resourceToDelete = null;\n+            if (searchQueryString != null) {\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Performing conditional delete with search criteria: \"\n+                            + Encode.forHtml(searchQueryString));\n+                }\n+                Bundle responseBundle = null;\n+                try {\n+                    MultivaluedMap<String, String> searchParameters =\n+                            getQueryParameterMap(searchQueryString);\n+                    responseBundle =\n+                            doSearch(type, null, null, searchParameters, null, requestProperties, null);\n+                } catch (FHIROperationException e) {\n+                    throw e;\n+                } catch (Throwable t) {\n+                    String msg =\n+                            \"An error occurred while performing the search for a conditional delete operation.\";\n+                    throw new FHIROperationException(msg, t);\n+                }\n+\n+                // Check the search results to determine whether or not to perform the update operation.\n+                int resultCount = responseBundle.getEntry().size();\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Conditional delete search yielded \" + resultCount + \" results.\");\n+                }\n+\n+                if (resultCount == 0) {\n+                    // Search yielded no matches\n+                    String msg = \"Search criteria for a conditional delete operation yielded no matches.\";\n+                    if (log.isLoggable(Level.FINE)) {\n+                        log.fine(msg);\n+                    }\n+                    status = Response.Status.OK;\n+                    ior.setOperationOutcome(FHIRUtil.buildOperationOutcome(msg, IssueType.NOT_FOUND, IssueSeverity.WARNING));\n+                    ior.setStatus(status);\n+                    return ior;\n+                } else if (resultCount == 1) {\n+                    // If we found a single match, then we'll delete this one.\n+                    Resource resource = responseBundle.getEntry().get(0).getResource();\n+                    id = resource.getId();\n+                    resourceToDelete = resource;\n+                } else {\n+                    String msg =\n+                            \"The search criteria specified for a conditional delete operation returned multiple matches.\";\n+                    throw buildRestException(msg, IssueType.MULTIPLE_MATCHES);\n+                }\n+            } else {\n+                // Make sure an id value was passed in.\n+                if (id == null) {\n+                    String msg = \"The 'id' parameter is required for a delete operation.\";\n+                    throw buildRestException(msg, IssueType.REQUIRED);\n+                }\n+\n+                // Read the resource so it will be available to the beforeDelete interceptor methods.\n+                try {\n+                    resourceToDelete = doRead(type, id, false, false, requestProperties, null);\n+                } catch (FHIRPersistenceResourceDeletedException e) {\n+                    // Absorb this exception.\n+                    resourceToDelete = null;\n+                }\n+            }\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, invoke the 'beforeDelete' interceptor methods.\n+            FHIRPersistenceEvent event =\n+                    new FHIRPersistenceEvent(null, buildPersistenceEventProperties(type, id, null, requestProperties));\n+            event.setFhirResource(resourceToDelete);\n+            getInterceptorMgr().fireBeforeDeleteEvent(event);\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event);\n+\n+            Resource resource = persistence.delete(persistenceContext, resourceType, id).getResource();\n+            ior.setResource(resource);\n+            event.setFhirResource(resource);\n+            ior.setStatus(Response.Status.NO_CONTENT);\n+\n+            // Invoke the 'afterDelete' interceptor methods.\n+            getInterceptorMgr().fireAfterDeleteEvent(event);\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+            status = ior.getStatus();\n+\n+            return ior;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we previously started a transaction and it's still active, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doDelete\");\n+        }\n+    }\n+\n+    @Override\n+    public Resource doRead(String type, String id, boolean throwExcOnNull, boolean includeDeleted,\n+            Map<String, String> requestProperties, Resource contextResource) throws Exception {\n+        return doRead(type, id, throwExcOnNull, includeDeleted, requestProperties, contextResource, null);\n+    }\n+\n+    /**\n+     * Performs a 'read' operation to retrieve a Resource.\n+     *\n+     * @param type\n+     *            the resource type associated with the Resource to be retrieved\n+     * @param id\n+     *            the id of the Resource to be retrieved\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return the Resource\n+     * @throws Exception\n+     */\n+    @Override\n+    public Resource doRead(String type, String id, boolean throwExcOnNull, boolean includeDeleted,\n+            Map<String, String> requestProperties, Resource contextResource, MultivaluedMap<String, String> queryParameters)\n+            throws Exception {\n+        log.entering(this.getClass().getName(), \"doRead\");\n+\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+        Resource resource = null;\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+            String resourceTypeName = type;\n+            if (!ModelSupport.isResourceType(type)) {\n+                throw buildUnsupportedResourceTypeException(type, IssueType.NOT_SUPPORTED);\n+            }\n+\n+            Class<? extends Resource> resourceType = getResourceType(resourceTypeName);\n+\n+            FHIRSearchContext searchContext = null;\n+            if (queryParameters != null) {\n+                searchContext = SearchUtil.parseQueryParameters(null, null, resourceType, queryParameters, \n+                        HTTPHandlingPreference.LENIENT.equals(requestContext.getHandlingPreference()));\n+            }\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, invoke the 'beforeRead' interceptor methods.\n+            FHIRPersistenceEvent event =\n+                    new FHIRPersistenceEvent(contextResource, buildPersistenceEventProperties(type, id, null, requestProperties));\n+            getInterceptorMgr().fireBeforeReadEvent(event);\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event, includeDeleted, searchContext);\n+            resource = persistence.read(persistenceContext, resourceType, id).getResource();\n+            if (resource == null && throwExcOnNull) {\n+                throw new FHIRPersistenceResourceNotFoundException(\"Resource '\" + type + \"/\" + id + \"' not found.\");\n+            }\n+\n+            event.setFhirResource(resource);\n+\n+            // Invoke the 'afterRead' interceptor methods.\n+            getInterceptorMgr().fireAfterReadEvent(event);\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+\n+            return resource;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we previously started a transaction and it's still active, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doRead\");\n+        }\n+    }\n+\n+    /**\n+     * Performs a 'vread' operation by retrieving the specified version of a Resource.\n+     *\n+     * @param type\n+     *            the resource type associated with the Resource to be retrieved\n+     * @param id\n+     *            the id of the Resource to be retrieved\n+     * @param versionId\n+     *            the version id of the Resource to be retrieved\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return the Resource\n+     * @throws Exception\n+     */\n+    @Override\n+    public Resource doVRead(String type, String id, String versionId,\n+        Map<String, String> requestProperties) throws Exception {\n+        log.entering(this.getClass().getName(), \"doVRead\");\n+\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+        Resource resource = null;\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+            String resourceTypeName = type;\n+            if (!ModelSupport.isResourceType(type)) {\n+                throw buildUnsupportedResourceTypeException(type, IssueType.NOT_SUPPORTED);\n+            }\n+\n+            Class<? extends Resource> resourceType =\n+                    getResourceType(resourceTypeName);\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, invoke the 'beforeVread' interceptor methods.\n+            FHIRPersistenceEvent event =\n+                    new FHIRPersistenceEvent(null, buildPersistenceEventProperties(type, id, versionId, requestProperties));\n+            getInterceptorMgr().fireBeforeVreadEvent(event);\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event);\n+            resource = persistence.vread(persistenceContext, resourceType, id, versionId).getResource();\n+            if (resource == null) {\n+                throw new FHIRPersistenceResourceNotFoundException(\"Resource '\"\n+                        + resourceType.getSimpleName() + \"/\" + id + \"' version \" + versionId + \" not found.\");\n+            }\n+\n+            event.setFhirResource(resource);\n+\n+            // Invoke the 'afterVread' interceptor methods.\n+            getInterceptorMgr().fireAfterVreadEvent(event);\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+\n+            return resource;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we previously started a transaction and it's still active, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doVRead\");\n+        }\n+    }\n+\n+    /**\n+     * Performs the work of retrieving versions of a Resource.\n+     *\n+     * @param type\n+     *            the resource type associated with the Resource to be retrieved\n+     * @param id\n+     *            the id of the Resource to be retrieved\n+     * @param queryParameters\n+     *            a Map containing the query parameters from the request URL\n+     * @param requestUri the URI from the request\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return a Bundle containing the history of the specified Resource\n+     * @throws Exception\n+     */\n+    @Override\n+    public Bundle doHistory(String type, String id, MultivaluedMap<String, String> queryParameters,\n+        String requestUri, Map<String, String> requestProperties)\n+        throws Exception {\n+        log.entering(this.getClass().getName(), \"doHistory\");\n+\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+        Bundle bundle = null;\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+            String resourceTypeName = type;\n+            if (!ModelSupport.isResourceType(type)) {\n+                throw buildUnsupportedResourceTypeException(type, IssueType.NOT_SUPPORTED);\n+            }\n+\n+            Class<? extends Resource> resourceType =\n+                    getResourceType(resourceTypeName);\n+            FHIRHistoryContext historyContext =\n+                    FHIRPersistenceUtil.parseHistoryParameters(queryParameters, HTTPHandlingPreference.LENIENT.equals(requestContext.getHandlingPreference()));\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, invoke the 'beforeHistory' interceptor methods.\n+            FHIRPersistenceEvent event =\n+                    new FHIRPersistenceEvent(null, buildPersistenceEventProperties(type, id, null, requestProperties));\n+            getInterceptorMgr().fireBeforeHistoryEvent(event);\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event, historyContext);\n+            List<? extends Resource> resources =\n+                    persistence.history(persistenceContext, resourceType, id).getResource();\n+            bundle = createHistoryBundle(resources, historyContext, type);\n+            bundle = addLinks(historyContext, bundle, requestUri);\n+\n+            event.setFhirResource(bundle);\n+\n+            // Invoke the 'afterHistory' interceptor methods.\n+            getInterceptorMgr().fireAfterHistoryEvent(event);\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+\n+            return bundle;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we previously started a transaction and it's still active, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doHistory\");\n+        }\n+    }\n+\n+    /**\n+     * Performs heavy lifting associated with a 'search' operation.\n+     *\n+     * @param type\n+     *            the resource type associated with the search\n+     * @param queryParameters\n+     *            a Map containing the query parameters from the request URL\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return a Bundle containing the search result set\n+     * @throws Exception\n+     */\n+    @Override\n+    public Bundle doSearch(String type, String compartment, String compartmentId,\n+            MultivaluedMap<String, String> queryParameters, String requestUri,\n+            Map<String, String> requestProperties, Resource contextResource) throws Exception {\n+        log.entering(this.getClass().getName(), \"doSearch\");\n+\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+        Bundle bundle = null;\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+            String resourceTypeName = type;\n+\n+            // Check to see if it's supported, else, throw a bad request.\n+            // If this is removed, it'll result in nullpointer when processing the request\n+            if (!ModelSupport.isResourceType(type)) {\n+                throw buildUnsupportedResourceTypeException(type, IssueType.NOT_SUPPORTED);\n+            }\n+\n+            Class<? extends Resource> resourceType =\n+                    getResourceType(resourceTypeName);\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, invoke the 'beforeSearch' interceptor methods.\n+            FHIRPersistenceEvent event =\n+                    new FHIRPersistenceEvent(contextResource, buildPersistenceEventProperties(type, null, null, requestProperties));\n+            getInterceptorMgr().fireBeforeSearchEvent(event);\n+\n+            FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(compartment, compartmentId, resourceType, queryParameters,\n+                    HTTPHandlingPreference.LENIENT.equals(requestContext.getHandlingPreference()));\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event, searchContext);\n+            List<Resource> resources =\n+                    persistence.search(persistenceContext, resourceType).getResource();\n+\n+            bundle = createSearchBundle(resources, searchContext, type);\n+            if (requestUri != null) {\n+                bundle = addLinks(searchContext, bundle, requestUri);\n+            }\n+            event.setFhirResource(bundle);\n+\n+            // Invoke the 'afterSearch' interceptor methods.\n+            getInterceptorMgr().fireAfterSearchEvent(event);\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+\n+            return bundle;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we previously started a transaction and it's still active, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doSearch\");\n+        }\n+    }\n+\n+    /**\n+     * Helper method which invokes a custom operation.\n+     *\n+     * @param operationContext\n+     *            the FHIROperationContext associated with the request\n+     * @param resourceTypeName\n+     *            the resource type associated with the request\n+     * @param logicalId\n+     *            the resource logical id associated with the request\n+     * @param versionId\n+     *            the resource version id associated with the request\n+     * @param operationName\n+     *            the name of the custom operation to be invoked\n+     * @param resource\n+     *            the input resource associated with the custom operation to be invoked\n+     * @param queryParameters\n+     *            query parameters may be passed instead of a Parameters resource for certain custom operations invoked\n+     *            via GET\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return a Resource that represents the response to the custom operation\n+     * @throws Exception\n+     */\n+    @Override\n+    public Resource doInvoke(FHIROperationContext operationContext, String resourceTypeName,\n+            String logicalId, String versionId, String operationName,\n+            Resource resource, MultivaluedMap<String, String> queryParameters,\n+            Map<String, String> requestProperties) throws Exception {\n+        log.entering(this.getClass().getName(), \"doInvoke\");\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+            Class<? extends Resource> resourceType = null;\n+            if (resourceTypeName != null) {\n+                resourceType = getResourceType(resourceTypeName);\n+            }\n+            String operationKey = (resourceTypeName == null ? operationName : operationName + \":\" + resourceTypeName);\n+\n+            FHIROperation operation =\n+                    FHIROperationRegistry.getInstance().getOperation(operationKey);\n+            Parameters parameters = null;\n+            if (resource instanceof Parameters) {\n+                parameters = (Parameters) resource;\n+            } else {\n+                if (resource == null) {\n+                    // build parameters object from query parameters\n+                    parameters =\n+                            FHIROperationUtil.getInputParameters(operation.getDefinition(), queryParameters);\n+                } else {\n+                    // wrap resource in a parameters object\n+                    parameters =\n+                            FHIROperationUtil.getInputParameters(operation.getDefinition(), resource);\n+                }\n+            }\n+\n+            // Add properties to the FHIR operation context\n+            setOperationContextProperties(operationContext, resourceTypeName, requestProperties);\n+\n+            if (log.isLoggable(Level.FINE)) {\n+                log.fine(\"Invoking operation '\" + operationName + \"', context=\\n\"\n+                        + operationContext.toString());\n+            }\n+            Parameters result =\n+                    operation.invoke(operationContext, resourceType, logicalId, versionId, parameters, this);\n+            if (log.isLoggable(Level.FINE)) {\n+                log.fine(\"Returned from invocation of operation '\" + operationName + \"'...\");\n+            }\n+\n+            // if single resource output parameter, return the resource\n+            if (FHIROperationUtil.hasSingleResourceOutputParameter(result)) {\n+                return FHIROperationUtil.getSingleResourceOutputParameter(result);\n+            }\n+\n+            return result;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            log.exiting(this.getClass().getName(), \"doInvoke\");\n+        }\n+    }\n+\n+    /**\n+     * Processes a bundled request.\n+     *\n+     * @param bundleResource\n+     *            the request Bundle\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return the response Bundle\n+     */\n+    @Override\n+    public Bundle doBundle(Resource bundleResource, Map<String, String> requestProperties)\n+        throws Exception {\n+        log.entering(this.getClass().getName(), \"doBundle\");\n+        Bundle inputBundle = null;\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+            if (bundleResource instanceof Bundle) {\n+                inputBundle = (Bundle) bundleResource;\n+            } else {\n+                String msg = \"A 'Bundle' resource type is required but a '\"\n+                        + bundleResource.getClass().getSimpleName() + \"' resource type was sent.\";\n+                throw buildRestException(msg, IssueType.INVALID);\n+            }\n+            // First, validate the bundle and create the response bundle.\n+            Bundle responseBundle = validateBundle(inputBundle);\n+\n+            // Next, process each of the entries in the bundle.\n+            responseBundle = processBundleEntries(inputBundle, responseBundle, requestProperties);\n+\n+            return responseBundle;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            log.exiting(this.getClass().getName(), \"doBundle\");\n+        }\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * @see com.ibm.fhir.rest.FHIRResourceHelpers#getTransaction()\n+     */\n+    @Override\n+    public FHIRPersistenceTransaction getTransaction() throws Exception {\n+        return persistence.getTransaction();\n+    }\n+\n+    /**\n+     * Validate the input resource and throw if there are validation errors\n+     *\n+     * @param resource\n+     * @throws FHIRValidationException\n+     * @throws FHIROperationException\n+     */\n+    private List<OperationOutcome.Issue> validateInput(Resource resource)\n+            throws FHIRValidationException, FHIROperationException {\n+        List<OperationOutcome.Issue> issues = FHIRValidator.validator().validate(resource);\n+        if (!issues.isEmpty()) {\n+            boolean includesFailure = false;\n+            for (OperationOutcome.Issue issue : issues) {\n+                if (FHIRUtil.isFailure(issue.getSeverity())) {\n+                    includesFailure = true;\n+                }\n+            }\n+\n+            if (includesFailure) {\n+                throw new FHIROperationException(\"Input resource failed validation.\").withIssue(issues);\n+            } else {\n+                if (log.isLoggable(Level.FINE)) {\n+                    String info = issues.stream()\n+                                .flatMap(issue -> Stream.of(issue.getDetails()))\n+                                .flatMap(details -> Stream.of(details.getText()))\n+                                .flatMap(text -> Stream.of(text.getValue()))\n+                                .collect(Collectors.joining(\", \"));\n+                    log.fine(\"Validation warnings for input resource: \" + info);\n+                }\n+            }\n+        }\n+        return issues;\n+    }\n+\n+    /**\n+     * @param issues\n+     * @return\n+     */\n+    private boolean anyFailureInIssues(List<OperationOutcome.Issue> issues) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0ff4daa4297bea3aff6025eac16697c3fe6ecb1"}, "originalPosition": 1085}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI4NTEzNA==", "bodyText": "I actually agree.  Previously it was in FHIRResource so I just moved it over along with the doX methods since thats where it was used.", "url": "https://github.com/IBM/FHIR/pull/759#discussion_r388285134", "createdAt": "2020-03-05T13:15:58Z", "author": {"login": "lmsurpre"}, "path": "fhir-server/src/main/java/com/ibm/fhir/server/resources/FHIRRestHelper.java", "diffHunk": "@@ -0,0 +1,2448 @@\n+/*\n+ * (C) Copyright IBM Corp. 2016, 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.server.resources;\n+\n+import static com.ibm.fhir.model.type.String.string;\n+import static com.ibm.fhir.model.util.ModelSupport.getResourceType;\n+import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;\n+import static javax.servlet.http.HttpServletResponse.SC_GONE;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static javax.servlet.http.HttpServletResponse.SC_OK;\n+\n+import java.net.URI;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeFormatterBuilder;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.Status;\n+\n+import org.owasp.encoder.Encode;\n+\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.core.HTTPHandlingPreference;\n+import com.ibm.fhir.core.HTTPReturnPreference;\n+import com.ibm.fhir.core.context.FHIRPagingContext;\n+import com.ibm.fhir.exception.FHIROperationException;\n+import com.ibm.fhir.model.patch.FHIRPatch;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.OperationOutcome;\n+import com.ibm.fhir.model.resource.OperationOutcome.Issue;\n+import com.ibm.fhir.model.resource.Parameters;\n+import com.ibm.fhir.model.resource.Resource;\n+import com.ibm.fhir.model.type.CodeableConcept;\n+import com.ibm.fhir.model.type.Extension;\n+import com.ibm.fhir.model.type.UnsignedInt;\n+import com.ibm.fhir.model.type.Uri;\n+import com.ibm.fhir.model.type.Url;\n+import com.ibm.fhir.model.type.code.BundleType;\n+import com.ibm.fhir.model.type.code.HTTPVerb;\n+import com.ibm.fhir.model.type.code.IssueSeverity;\n+import com.ibm.fhir.model.type.code.IssueType;\n+import com.ibm.fhir.model.util.FHIRUtil;\n+import com.ibm.fhir.model.util.ModelSupport;\n+import com.ibm.fhir.model.util.ReferenceMappingVisitor;\n+import com.ibm.fhir.operation.FHIROperation;\n+import com.ibm.fhir.operation.context.FHIROperationContext;\n+import com.ibm.fhir.operation.registry.FHIROperationRegistry;\n+import com.ibm.fhir.operation.util.FHIROperationUtil;\n+import com.ibm.fhir.persistence.FHIRPersistence;\n+import com.ibm.fhir.persistence.FHIRPersistenceTransaction;\n+import com.ibm.fhir.persistence.context.FHIRHistoryContext;\n+import com.ibm.fhir.persistence.context.FHIRPersistenceContext;\n+import com.ibm.fhir.persistence.context.FHIRPersistenceContextFactory;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceResourceDeletedException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceResourceNotFoundException;\n+import com.ibm.fhir.persistence.helper.FHIRTransactionHelper;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceEvent;\n+import com.ibm.fhir.persistence.interceptor.impl.FHIRPersistenceInterceptorMgr;\n+import com.ibm.fhir.persistence.util.FHIRPersistenceUtil;\n+import com.ibm.fhir.rest.FHIRResourceHelpers;\n+import com.ibm.fhir.rest.FHIRRestOperationResponse;\n+import com.ibm.fhir.search.SearchConstants;\n+import com.ibm.fhir.search.SummaryValueSet;\n+import com.ibm.fhir.search.context.FHIRSearchContext;\n+import com.ibm.fhir.search.exception.FHIRSearchException;\n+import com.ibm.fhir.search.util.SearchUtil;\n+import com.ibm.fhir.server.exception.FHIRRestBundledRequestException;\n+import com.ibm.fhir.server.helper.FHIRUrlParser;\n+import com.ibm.fhir.server.util.IssueTypeToHttpStatusMapper;\n+import com.ibm.fhir.validation.FHIRValidator;\n+import com.ibm.fhir.validation.exception.FHIRValidationException;\n+\n+public class FHIRRestHelper implements FHIRResourceHelpers {\n+    private static final Logger log =\n+            java.util.logging.Logger.getLogger(FHIRRestHelper.class.getName());\n+\n+    private static final String EXTENSION_URL = \"http://ibm.com/fhir/extension\";\n+    private static final String LOCAL_REF_PREFIX = \"urn:\";\n+\n+    public static final DateTimeFormatter PARSER_FORMATTER = new DateTimeFormatterBuilder()\n+            .appendPattern(\"EEE\")\n+            .optionalStart()\n+            // ANSIC date time format for If-Modified-Since\n+            .appendPattern(\" MMM dd HH:mm:ss yyyy\")\n+            .optionalEnd()\n+            .optionalStart()\n+            // Touchstone date time format for If-Modified-Since\n+            .appendPattern(\", dd-MMM-yy HH:mm:ss\")\n+            .optionalEnd().toFormatter();\n+\n+    private FHIRPersistence persistence = null;\n+\n+    // These values are used for correlating requests within a bundle.\n+    private String bundleTransactionCorrelationId = null;\n+    private String bundleRequestCorrelationId = null;\n+\n+    public FHIRRestHelper(FHIRPersistence persistence) {\n+        this.persistence = persistence;\n+    }\n+\n+    /**\n+     * Performs the heavy lifting associated with a 'create' interaction.\n+     *\n+     * @param type\n+     *            the resource type specified as part of the request URL\n+     * @param resource\n+     *            the Resource to be stored.\n+     * @param ifNoneExist\n+     *            whether to create the resource if none exists\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return a FHIRRestOperationResponse object containing the results of the operation\n+     * @throws Exception\n+     */\n+    @Override\n+    public FHIRRestOperationResponse doCreate(String type, Resource resource, String ifNoneExist,\n+            Map<String, String> requestProperties) throws Exception {\n+        log.entering(this.getClass().getName(), \"doCreate\");\n+\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+        FHIRRestOperationResponse ior = new FHIRRestOperationResponse();\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+\n+            // Make sure the expected type (specified in the URL string) is congruent with the actual type\n+            // of the resource.\n+            String resourceType = ModelSupport.getTypeName(resource.getClass()); \n+            if (!resourceType.equals(type)) {\n+                String msg = \"Resource type '\" + resourceType\n+                        + \"' does not match type specified in request URI: \" + type;\n+                throw buildRestException(msg, IssueType.INVALID);\n+            }\n+\n+            // Check to see if we're supposed to perform a conditional 'create'.\n+            if (ifNoneExist != null && !ifNoneExist.isEmpty()) {\n+                log.fine(\"Performing conditional create with search criteria: \" + ifNoneExist);\n+                Bundle responseBundle = null;\n+\n+                // Perform the search using the \"If-None-Exist\" header value.\n+                try {\n+                    MultivaluedMap<String, String> searchParameters = getQueryParameterMap(ifNoneExist);\n+                    responseBundle =\n+                            doSearch(type, null, null, searchParameters, null, requestProperties, resource);\n+                } catch (FHIROperationException e) {\n+                    throw e;\n+                } catch (Throwable t) {\n+                    String msg =\n+                            \"An error occurred while performing the search for a conditional create operation.\";\n+                    log.log(Level.WARNING, msg, t);\n+                    throw new FHIROperationException(msg, t);\n+                }\n+\n+                // Check the search results to determine whether or not to perform the create operation.\n+                int resultCount = responseBundle.getEntry().size();\n+                log.fine(\"Conditional create search yielded \" + resultCount + \" results.\");\n+\n+                if (resultCount == 0) {\n+                    // Do nothing and fall through to process the 'create' request.\n+                } else if (resultCount == 1) {\n+                    // If we found a single match, bypass the 'create' request and return information\n+                    // for the matched resource.\n+                    Resource matchedResource = responseBundle.getEntry().get(0).getResource();\n+                    ior.setLocationURI(FHIRUtil.buildLocationURI(type, matchedResource));\n+                    ior.setStatus(Response.Status.OK);\n+                    ior.setResource(matchedResource);\n+                    log.fine(\"Returning location URI of matched resource: \" + ior.getLocationURI());\n+                    return ior;\n+                } else {\n+                    String msg =\n+                            \"The search criteria specified for a conditional create operation returned multiple matches.\";\n+                    throw buildRestException(msg, IssueType.MULTIPLE_MATCHES);\n+                }\n+            }\n+\n+            // For R4, resources may contain an id. For create, this should be ignored and\n+            // we no longer reject the request.\n+            if (resource.getId() != null && log.isLoggable(Level.FINE)) {\n+                log.fine(String.format(\"create request resource includes id: '%s'\", resource.getId()));\n+            }\n+\n+            // Validate the input resource and return any validation errors, but warnings are OK\n+            List<Issue> validationWarnings = validateInput(resource);\n+            ior.setOperationOutcome(FHIRUtil.buildOperationOutcome(validationWarnings));\n+\n+            // If there were no validation errors, then create the resource and return the location header.\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, invoke the 'beforeCreate' interceptor methods.\n+            FHIRPersistenceEvent event =\n+                    new FHIRPersistenceEvent(resource, buildPersistenceEventProperties(type, null, null, requestProperties));\n+            getInterceptorMgr().fireBeforeCreateEvent(event);\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event);\n+\n+            // R4: remember model objects are immutable, so we get back a new resource with the id/meta stuff\n+            resource = persistence.create(persistenceContext, resource).getResource();\n+            event.setFhirResource(resource); // update event with latest\n+            ior.setStatus(Response.Status.CREATED);\n+            ior.setResource(resource);\n+\n+            // Build our location URI and add it to the interceptor event structure since it is now known.\n+            ior.setLocationURI(FHIRUtil.buildLocationURI(ModelSupport.getTypeName(resource.getClass()), resource));\n+            event.getProperties().put(FHIRPersistenceEvent.PROPNAME_RESOURCE_LOCATION_URI, ior.getLocationURI().toString());\n+\n+            // Invoke the 'afterCreate' interceptor methods.\n+            getInterceptorMgr().fireAfterCreateEvent(event);\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+\n+            return ior;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we previously started a transaction and it's still active, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doCreate\");\n+        }\n+    }\n+\n+    @Override\n+    public FHIRRestOperationResponse doPatch(String type, String id, FHIRPatch patch, String ifMatchValue,\n+            String searchQueryString, Map<String, String> requestProperties) throws Exception {\n+\n+        return doPatchOrUpdate(type, id, patch, null, ifMatchValue, searchQueryString, requestProperties);\n+    }\n+\n+    @Override\n+    public FHIRRestOperationResponse doUpdate(String type, String id, Resource newResource, String ifMatchValue,\n+            String searchQueryString, Map<String, String> requestProperties) throws Exception {\n+\n+        return doPatchOrUpdate(type, id, null, newResource, ifMatchValue, searchQueryString, requestProperties);\n+    }\n+\n+    private FHIRRestOperationResponse doPatchOrUpdate(String type, String id, FHIRPatch patch,\n+            Resource newResource, String ifMatchValue, String searchQueryString,\n+            Map<String, String> requestProperties) throws Exception {\n+        log.entering(this.getClass().getName(), \"doPatchOrUpdate\");\n+\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        FHIRRestOperationResponse ior = new FHIRRestOperationResponse();\n+\n+        try {\n+            // Make sure the type specified in the URL string matches the resource type obtained from the new resource.\n+            if (patch == null) {\n+                String resourceType =  ModelSupport.getTypeName(newResource.getClass());\n+                if (!resourceType.equals(type)) {\n+                    String msg = \"Resource type '\" + resourceType\n+                            + \"' does not match type specified in request URI: \" + type;\n+                    throw buildRestException(msg, IssueType.INVALID);\n+                }\n+            }\n+\n+            // Next, if a conditional update was invoked then use the search criteria to find the\n+            // resource to be updated. Otherwise, we'll use the id value to retrieve the current\n+            // version of the resource.\n+            if (searchQueryString != null) {\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Performing conditional update/patch with search criteria: \"\n+                            + Encode.forHtml(searchQueryString));\n+                }\n+                Bundle responseBundle = null;\n+                try {\n+                    MultivaluedMap<String, String> searchParameters =\n+                            getQueryParameterMap(searchQueryString);\n+                    responseBundle =\n+                            doSearch(type, null, null, searchParameters, null, requestProperties, newResource);\n+                } catch (FHIROperationException e) {\n+                    throw e;\n+                } catch (Throwable t) {\n+                    String msg =\n+                            \"An error occurred while performing the search for a conditional update/patch operation.\";\n+                    throw new FHIROperationException(msg, t);\n+                }\n+\n+                // Check the search results to determine whether or not to perform the update operation.\n+                int resultCount = responseBundle.getEntry().size();\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Conditional update/patch search yielded \" + resultCount + \" results.\");\n+                }\n+\n+                if (resultCount == 0) {\n+                    if (patch != null) {\n+                        String msg =\n+                                \"The search criteria specified for a conditional patch operation did not return any results.\";\n+                        throw buildRestException(msg, IssueType.NOT_FOUND);\n+                    }\n+                    // Search yielded no matches, so we'll do an update/create operation below.\n+                    ior.setPrevResource(null);\n+\n+                    // if no id provided, then generate an id for the input resource\n+                    if (newResource.getId() == null || newResource.getId() == null) {\n+                        id = UUID.randomUUID().toString();\n+                        newResource = newResource.toBuilder().id(id).build();\n+                    } else {\n+                        id = newResource.getId();\n+                    }\n+                } else if (resultCount == 1) {\n+                    // If we found a single match, then we'll perform a normal update on the matched resource.\n+                    ior.setPrevResource(responseBundle.getEntry().get(0).getResource());\n+                    id = ior.getPrevResource().getId();\n+\n+                    // If the id of the input resource is different from the id of the search result,\n+                    // then throw exception.\n+                    if (newResource.getId() != null && newResource.getId() != null\n+                            && !newResource.getId().equalsIgnoreCase(id)) {\n+                        String msg = \"Input resource 'id' attribute must match the id of the search result resource.\";\n+                        throw buildRestException(msg, IssueType.VALUE);\n+                    }\n+                    // Make sure the id of the newResource is not null and is the same as the id of the found resource.\n+                    newResource = newResource.toBuilder().id(id).build();\n+                } else {\n+                    String msg =\n+                            \"The search criteria specified for a conditional update/patch operation returned multiple matches.\";\n+                    throw buildRestException(msg, IssueType.MULTIPLE_MATCHES);\n+                }\n+            } else {\n+                // Make sure an id value was passed in.\n+                if (id == null) {\n+                    String msg = \"The 'id' parameter is required for an update/pach operation.\";\n+                    throw buildRestException(msg, IssueType.REQUIRED);\n+                }\n+\n+                // If an id value was passed in (i.e. the id specified in the REST API URL string),\n+                // then make sure it's the same as the value in the resource.\n+                if (patch == null) {\n+                    // Make sure the resource has an 'id' attribute.\n+                    if (newResource.getId() == null) {\n+                        String msg = \"Input resource must contain an 'id' attribute.\";\n+                        throw buildRestException(msg, IssueType.INVALID);\n+                    }\n+\n+                    if (!newResource.getId().equals(id)) {\n+                        String msg = \"Input resource 'id' attribute must match 'id' parameter.\";\n+                        throw buildRestException(msg, IssueType.VALUE);\n+                    }\n+                }\n+\n+                // Retrieve the resource to be updated using the type and id values.\n+                ior.setPrevResource(doRead(type, id, (patch != null), true, requestProperties, newResource));\n+            }\n+\n+            if (patch != null) {\n+                newResource = patch.apply(ior.getPrevResource());\n+            }\n+\n+            // Validate the input resource and return any validation errors.\n+            List<Issue> validationWarnings = validateInput(newResource);\n+            ior.setOperationOutcome(FHIRUtil.buildOperationOutcome(validationWarnings));\n+\n+            // Perform the \"version-aware\" update check, and also find out if the resource was deleted.\n+            boolean isDeleted = false;\n+            if (ior.getPrevResource() != null) {\n+                performVersionAwareUpdateCheck(ior.getPrevResource(), ifMatchValue);\n+\n+                try {\n+                    doRead(type, id, (patch != null), false, requestProperties, newResource);\n+                } catch (FHIRPersistenceResourceDeletedException e) {\n+                    isDeleted = true;\n+                }\n+            }\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, create the persistence event.\n+            FHIRPersistenceEvent event = new FHIRPersistenceEvent(newResource, \n+                    buildPersistenceEventProperties(type, newResource.getId(), null, requestProperties));\n+\n+            // Next, set the \"previous resource\" in the persistence event.\n+            event.setPrevFhirResource(ior.getPrevResource());\n+\n+            // Next, invoke the 'beforeUpdate' or 'beforeCreate' interceptor methods as appropriate.\n+            boolean updateCreate = (ior.getPrevResource() == null);\n+            if (updateCreate) {\n+                getInterceptorMgr().fireBeforeCreateEvent(event);\n+            } else {\n+                if (patch != null) {\n+                    event.getProperties().put(FHIRPersistenceEvent.PROPNAME_PATCH, patch);\n+                    getInterceptorMgr().fireBeforePatchEvent(event);\n+                } else {\n+                    getInterceptorMgr().fireBeforeUpdateEvent(event);\n+                }\n+            }\n+\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event);\n+            newResource = persistence.update(persistenceContext, id, newResource).getResource();\n+            event.setFhirResource(newResource); // update event with latest\n+            ior.setResource(newResource);\n+\n+            // Build our location URI and add it to the interceptor event structure since it is now known.\n+            ior.setLocationURI(FHIRUtil.buildLocationURI(ModelSupport.getTypeName(newResource.getClass()), newResource));\n+            event.getProperties().put(FHIRPersistenceEvent.PROPNAME_RESOURCE_LOCATION_URI, ior.getLocationURI().toString());\n+\n+            // Invoke the 'afterUpdate' interceptor methods.\n+            if (updateCreate) {\n+                ior.setStatus(Response.Status.CREATED);\n+                getInterceptorMgr().fireAfterCreateEvent(event);\n+            } else {\n+                ior.setStatus(Response.Status.OK);\n+                if (patch != null) {\n+                    getInterceptorMgr().fireAfterPatchEvent(event);\n+                } else {\n+                    getInterceptorMgr().fireAfterUpdateEvent(event);\n+                }\n+            }\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+\n+            // If the deleted resource is updated, then simply return 201 instead of 200 to pass Touchstone test.\n+            // We don't set the previous resource to null in above codes if the resource was deleted, otherwise\n+            // it will break the code logic of the resource versioning.\n+            if (isDeleted && ior.getStatus() == Response.Status.OK) {\n+                ior.setStatus(Response.Status.CREATED);\n+            }\n+\n+            return ior;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we still have a transaction at this point, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doPatchOrUpdate\");\n+        }\n+    }\n+\n+    /**\n+     * Performs a 'delete' operation on the specified resource.\n+     *\n+     * @param type\n+     *            the resource type associated with the Resource to be deleted\n+     * @param id\n+     *            the id of the Resource to be deleted\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return a FHIRRestOperationResponse that contains the results of the operation\n+     * @throws Exception\n+     */\n+    @Override\n+    public FHIRRestOperationResponse doDelete(String type, String id, String searchQueryString,\n+            Map<String, String> requestProperties) throws Exception {\n+        log.entering(this.getClass().getName(), \"doDelete\");\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+        Response.Status status = null;\n+\n+        FHIRRestOperationResponse ior = new FHIRRestOperationResponse();\n+\n+        try {\n+            String resourceTypeName = type;\n+            if (!ModelSupport.isResourceType(type)) {\n+                throw buildUnsupportedResourceTypeException(type, IssueType.NOT_SUPPORTED);\n+            }\n+\n+            Class<? extends Resource> resourceType =\n+                    getResourceType(resourceTypeName);\n+\n+            // Next, if a conditional delete was invoked then use the search criteria to find the\n+            // resource to be deleted. Otherwise, we'll use the id value to identify the resource\n+            // to be deleted.\n+            Resource resourceToDelete = null;\n+            if (searchQueryString != null) {\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Performing conditional delete with search criteria: \"\n+                            + Encode.forHtml(searchQueryString));\n+                }\n+                Bundle responseBundle = null;\n+                try {\n+                    MultivaluedMap<String, String> searchParameters =\n+                            getQueryParameterMap(searchQueryString);\n+                    responseBundle =\n+                            doSearch(type, null, null, searchParameters, null, requestProperties, null);\n+                } catch (FHIROperationException e) {\n+                    throw e;\n+                } catch (Throwable t) {\n+                    String msg =\n+                            \"An error occurred while performing the search for a conditional delete operation.\";\n+                    throw new FHIROperationException(msg, t);\n+                }\n+\n+                // Check the search results to determine whether or not to perform the update operation.\n+                int resultCount = responseBundle.getEntry().size();\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Conditional delete search yielded \" + resultCount + \" results.\");\n+                }\n+\n+                if (resultCount == 0) {\n+                    // Search yielded no matches\n+                    String msg = \"Search criteria for a conditional delete operation yielded no matches.\";\n+                    if (log.isLoggable(Level.FINE)) {\n+                        log.fine(msg);\n+                    }\n+                    status = Response.Status.OK;\n+                    ior.setOperationOutcome(FHIRUtil.buildOperationOutcome(msg, IssueType.NOT_FOUND, IssueSeverity.WARNING));\n+                    ior.setStatus(status);\n+                    return ior;\n+                } else if (resultCount == 1) {\n+                    // If we found a single match, then we'll delete this one.\n+                    Resource resource = responseBundle.getEntry().get(0).getResource();\n+                    id = resource.getId();\n+                    resourceToDelete = resource;\n+                } else {\n+                    String msg =\n+                            \"The search criteria specified for a conditional delete operation returned multiple matches.\";\n+                    throw buildRestException(msg, IssueType.MULTIPLE_MATCHES);\n+                }\n+            } else {\n+                // Make sure an id value was passed in.\n+                if (id == null) {\n+                    String msg = \"The 'id' parameter is required for a delete operation.\";\n+                    throw buildRestException(msg, IssueType.REQUIRED);\n+                }\n+\n+                // Read the resource so it will be available to the beforeDelete interceptor methods.\n+                try {\n+                    resourceToDelete = doRead(type, id, false, false, requestProperties, null);\n+                } catch (FHIRPersistenceResourceDeletedException e) {\n+                    // Absorb this exception.\n+                    resourceToDelete = null;\n+                }\n+            }\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, invoke the 'beforeDelete' interceptor methods.\n+            FHIRPersistenceEvent event =\n+                    new FHIRPersistenceEvent(null, buildPersistenceEventProperties(type, id, null, requestProperties));\n+            event.setFhirResource(resourceToDelete);\n+            getInterceptorMgr().fireBeforeDeleteEvent(event);\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event);\n+\n+            Resource resource = persistence.delete(persistenceContext, resourceType, id).getResource();\n+            ior.setResource(resource);\n+            event.setFhirResource(resource);\n+            ior.setStatus(Response.Status.NO_CONTENT);\n+\n+            // Invoke the 'afterDelete' interceptor methods.\n+            getInterceptorMgr().fireAfterDeleteEvent(event);\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+            status = ior.getStatus();\n+\n+            return ior;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we previously started a transaction and it's still active, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doDelete\");\n+        }\n+    }\n+\n+    @Override\n+    public Resource doRead(String type, String id, boolean throwExcOnNull, boolean includeDeleted,\n+            Map<String, String> requestProperties, Resource contextResource) throws Exception {\n+        return doRead(type, id, throwExcOnNull, includeDeleted, requestProperties, contextResource, null);\n+    }\n+\n+    /**\n+     * Performs a 'read' operation to retrieve a Resource.\n+     *\n+     * @param type\n+     *            the resource type associated with the Resource to be retrieved\n+     * @param id\n+     *            the id of the Resource to be retrieved\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return the Resource\n+     * @throws Exception\n+     */\n+    @Override\n+    public Resource doRead(String type, String id, boolean throwExcOnNull, boolean includeDeleted,\n+            Map<String, String> requestProperties, Resource contextResource, MultivaluedMap<String, String> queryParameters)\n+            throws Exception {\n+        log.entering(this.getClass().getName(), \"doRead\");\n+\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+        Resource resource = null;\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+            String resourceTypeName = type;\n+            if (!ModelSupport.isResourceType(type)) {\n+                throw buildUnsupportedResourceTypeException(type, IssueType.NOT_SUPPORTED);\n+            }\n+\n+            Class<? extends Resource> resourceType = getResourceType(resourceTypeName);\n+\n+            FHIRSearchContext searchContext = null;\n+            if (queryParameters != null) {\n+                searchContext = SearchUtil.parseQueryParameters(null, null, resourceType, queryParameters, \n+                        HTTPHandlingPreference.LENIENT.equals(requestContext.getHandlingPreference()));\n+            }\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, invoke the 'beforeRead' interceptor methods.\n+            FHIRPersistenceEvent event =\n+                    new FHIRPersistenceEvent(contextResource, buildPersistenceEventProperties(type, id, null, requestProperties));\n+            getInterceptorMgr().fireBeforeReadEvent(event);\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event, includeDeleted, searchContext);\n+            resource = persistence.read(persistenceContext, resourceType, id).getResource();\n+            if (resource == null && throwExcOnNull) {\n+                throw new FHIRPersistenceResourceNotFoundException(\"Resource '\" + type + \"/\" + id + \"' not found.\");\n+            }\n+\n+            event.setFhirResource(resource);\n+\n+            // Invoke the 'afterRead' interceptor methods.\n+            getInterceptorMgr().fireAfterReadEvent(event);\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+\n+            return resource;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we previously started a transaction and it's still active, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doRead\");\n+        }\n+    }\n+\n+    /**\n+     * Performs a 'vread' operation by retrieving the specified version of a Resource.\n+     *\n+     * @param type\n+     *            the resource type associated with the Resource to be retrieved\n+     * @param id\n+     *            the id of the Resource to be retrieved\n+     * @param versionId\n+     *            the version id of the Resource to be retrieved\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return the Resource\n+     * @throws Exception\n+     */\n+    @Override\n+    public Resource doVRead(String type, String id, String versionId,\n+        Map<String, String> requestProperties) throws Exception {\n+        log.entering(this.getClass().getName(), \"doVRead\");\n+\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+        Resource resource = null;\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+            String resourceTypeName = type;\n+            if (!ModelSupport.isResourceType(type)) {\n+                throw buildUnsupportedResourceTypeException(type, IssueType.NOT_SUPPORTED);\n+            }\n+\n+            Class<? extends Resource> resourceType =\n+                    getResourceType(resourceTypeName);\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, invoke the 'beforeVread' interceptor methods.\n+            FHIRPersistenceEvent event =\n+                    new FHIRPersistenceEvent(null, buildPersistenceEventProperties(type, id, versionId, requestProperties));\n+            getInterceptorMgr().fireBeforeVreadEvent(event);\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event);\n+            resource = persistence.vread(persistenceContext, resourceType, id, versionId).getResource();\n+            if (resource == null) {\n+                throw new FHIRPersistenceResourceNotFoundException(\"Resource '\"\n+                        + resourceType.getSimpleName() + \"/\" + id + \"' version \" + versionId + \" not found.\");\n+            }\n+\n+            event.setFhirResource(resource);\n+\n+            // Invoke the 'afterVread' interceptor methods.\n+            getInterceptorMgr().fireAfterVreadEvent(event);\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+\n+            return resource;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we previously started a transaction and it's still active, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doVRead\");\n+        }\n+    }\n+\n+    /**\n+     * Performs the work of retrieving versions of a Resource.\n+     *\n+     * @param type\n+     *            the resource type associated with the Resource to be retrieved\n+     * @param id\n+     *            the id of the Resource to be retrieved\n+     * @param queryParameters\n+     *            a Map containing the query parameters from the request URL\n+     * @param requestUri the URI from the request\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return a Bundle containing the history of the specified Resource\n+     * @throws Exception\n+     */\n+    @Override\n+    public Bundle doHistory(String type, String id, MultivaluedMap<String, String> queryParameters,\n+        String requestUri, Map<String, String> requestProperties)\n+        throws Exception {\n+        log.entering(this.getClass().getName(), \"doHistory\");\n+\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+        Bundle bundle = null;\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+            String resourceTypeName = type;\n+            if (!ModelSupport.isResourceType(type)) {\n+                throw buildUnsupportedResourceTypeException(type, IssueType.NOT_SUPPORTED);\n+            }\n+\n+            Class<? extends Resource> resourceType =\n+                    getResourceType(resourceTypeName);\n+            FHIRHistoryContext historyContext =\n+                    FHIRPersistenceUtil.parseHistoryParameters(queryParameters, HTTPHandlingPreference.LENIENT.equals(requestContext.getHandlingPreference()));\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, invoke the 'beforeHistory' interceptor methods.\n+            FHIRPersistenceEvent event =\n+                    new FHIRPersistenceEvent(null, buildPersistenceEventProperties(type, id, null, requestProperties));\n+            getInterceptorMgr().fireBeforeHistoryEvent(event);\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event, historyContext);\n+            List<? extends Resource> resources =\n+                    persistence.history(persistenceContext, resourceType, id).getResource();\n+            bundle = createHistoryBundle(resources, historyContext, type);\n+            bundle = addLinks(historyContext, bundle, requestUri);\n+\n+            event.setFhirResource(bundle);\n+\n+            // Invoke the 'afterHistory' interceptor methods.\n+            getInterceptorMgr().fireAfterHistoryEvent(event);\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+\n+            return bundle;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we previously started a transaction and it's still active, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doHistory\");\n+        }\n+    }\n+\n+    /**\n+     * Performs heavy lifting associated with a 'search' operation.\n+     *\n+     * @param type\n+     *            the resource type associated with the search\n+     * @param queryParameters\n+     *            a Map containing the query parameters from the request URL\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return a Bundle containing the search result set\n+     * @throws Exception\n+     */\n+    @Override\n+    public Bundle doSearch(String type, String compartment, String compartmentId,\n+            MultivaluedMap<String, String> queryParameters, String requestUri,\n+            Map<String, String> requestProperties, Resource contextResource) throws Exception {\n+        log.entering(this.getClass().getName(), \"doSearch\");\n+\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+        Bundle bundle = null;\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+            String resourceTypeName = type;\n+\n+            // Check to see if it's supported, else, throw a bad request.\n+            // If this is removed, it'll result in nullpointer when processing the request\n+            if (!ModelSupport.isResourceType(type)) {\n+                throw buildUnsupportedResourceTypeException(type, IssueType.NOT_SUPPORTED);\n+            }\n+\n+            Class<? extends Resource> resourceType =\n+                    getResourceType(resourceTypeName);\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, invoke the 'beforeSearch' interceptor methods.\n+            FHIRPersistenceEvent event =\n+                    new FHIRPersistenceEvent(contextResource, buildPersistenceEventProperties(type, null, null, requestProperties));\n+            getInterceptorMgr().fireBeforeSearchEvent(event);\n+\n+            FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(compartment, compartmentId, resourceType, queryParameters,\n+                    HTTPHandlingPreference.LENIENT.equals(requestContext.getHandlingPreference()));\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event, searchContext);\n+            List<Resource> resources =\n+                    persistence.search(persistenceContext, resourceType).getResource();\n+\n+            bundle = createSearchBundle(resources, searchContext, type);\n+            if (requestUri != null) {\n+                bundle = addLinks(searchContext, bundle, requestUri);\n+            }\n+            event.setFhirResource(bundle);\n+\n+            // Invoke the 'afterSearch' interceptor methods.\n+            getInterceptorMgr().fireAfterSearchEvent(event);\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+\n+            return bundle;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we previously started a transaction and it's still active, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doSearch\");\n+        }\n+    }\n+\n+    /**\n+     * Helper method which invokes a custom operation.\n+     *\n+     * @param operationContext\n+     *            the FHIROperationContext associated with the request\n+     * @param resourceTypeName\n+     *            the resource type associated with the request\n+     * @param logicalId\n+     *            the resource logical id associated with the request\n+     * @param versionId\n+     *            the resource version id associated with the request\n+     * @param operationName\n+     *            the name of the custom operation to be invoked\n+     * @param resource\n+     *            the input resource associated with the custom operation to be invoked\n+     * @param queryParameters\n+     *            query parameters may be passed instead of a Parameters resource for certain custom operations invoked\n+     *            via GET\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return a Resource that represents the response to the custom operation\n+     * @throws Exception\n+     */\n+    @Override\n+    public Resource doInvoke(FHIROperationContext operationContext, String resourceTypeName,\n+            String logicalId, String versionId, String operationName,\n+            Resource resource, MultivaluedMap<String, String> queryParameters,\n+            Map<String, String> requestProperties) throws Exception {\n+        log.entering(this.getClass().getName(), \"doInvoke\");\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+            Class<? extends Resource> resourceType = null;\n+            if (resourceTypeName != null) {\n+                resourceType = getResourceType(resourceTypeName);\n+            }\n+            String operationKey = (resourceTypeName == null ? operationName : operationName + \":\" + resourceTypeName);\n+\n+            FHIROperation operation =\n+                    FHIROperationRegistry.getInstance().getOperation(operationKey);\n+            Parameters parameters = null;\n+            if (resource instanceof Parameters) {\n+                parameters = (Parameters) resource;\n+            } else {\n+                if (resource == null) {\n+                    // build parameters object from query parameters\n+                    parameters =\n+                            FHIROperationUtil.getInputParameters(operation.getDefinition(), queryParameters);\n+                } else {\n+                    // wrap resource in a parameters object\n+                    parameters =\n+                            FHIROperationUtil.getInputParameters(operation.getDefinition(), resource);\n+                }\n+            }\n+\n+            // Add properties to the FHIR operation context\n+            setOperationContextProperties(operationContext, resourceTypeName, requestProperties);\n+\n+            if (log.isLoggable(Level.FINE)) {\n+                log.fine(\"Invoking operation '\" + operationName + \"', context=\\n\"\n+                        + operationContext.toString());\n+            }\n+            Parameters result =\n+                    operation.invoke(operationContext, resourceType, logicalId, versionId, parameters, this);\n+            if (log.isLoggable(Level.FINE)) {\n+                log.fine(\"Returned from invocation of operation '\" + operationName + \"'...\");\n+            }\n+\n+            // if single resource output parameter, return the resource\n+            if (FHIROperationUtil.hasSingleResourceOutputParameter(result)) {\n+                return FHIROperationUtil.getSingleResourceOutputParameter(result);\n+            }\n+\n+            return result;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            log.exiting(this.getClass().getName(), \"doInvoke\");\n+        }\n+    }\n+\n+    /**\n+     * Processes a bundled request.\n+     *\n+     * @param bundleResource\n+     *            the request Bundle\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return the response Bundle\n+     */\n+    @Override\n+    public Bundle doBundle(Resource bundleResource, Map<String, String> requestProperties)\n+        throws Exception {\n+        log.entering(this.getClass().getName(), \"doBundle\");\n+        Bundle inputBundle = null;\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+            if (bundleResource instanceof Bundle) {\n+                inputBundle = (Bundle) bundleResource;\n+            } else {\n+                String msg = \"A 'Bundle' resource type is required but a '\"\n+                        + bundleResource.getClass().getSimpleName() + \"' resource type was sent.\";\n+                throw buildRestException(msg, IssueType.INVALID);\n+            }\n+            // First, validate the bundle and create the response bundle.\n+            Bundle responseBundle = validateBundle(inputBundle);\n+\n+            // Next, process each of the entries in the bundle.\n+            responseBundle = processBundleEntries(inputBundle, responseBundle, requestProperties);\n+\n+            return responseBundle;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            log.exiting(this.getClass().getName(), \"doBundle\");\n+        }\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * @see com.ibm.fhir.rest.FHIRResourceHelpers#getTransaction()\n+     */\n+    @Override\n+    public FHIRPersistenceTransaction getTransaction() throws Exception {\n+        return persistence.getTransaction();\n+    }\n+\n+    /**\n+     * Validate the input resource and throw if there are validation errors\n+     *\n+     * @param resource\n+     * @throws FHIRValidationException\n+     * @throws FHIROperationException\n+     */\n+    private List<OperationOutcome.Issue> validateInput(Resource resource)\n+            throws FHIRValidationException, FHIROperationException {\n+        List<OperationOutcome.Issue> issues = FHIRValidator.validator().validate(resource);\n+        if (!issues.isEmpty()) {\n+            boolean includesFailure = false;\n+            for (OperationOutcome.Issue issue : issues) {\n+                if (FHIRUtil.isFailure(issue.getSeverity())) {\n+                    includesFailure = true;\n+                }\n+            }\n+\n+            if (includesFailure) {\n+                throw new FHIROperationException(\"Input resource failed validation.\").withIssue(issues);\n+            } else {\n+                if (log.isLoggable(Level.FINE)) {\n+                    String info = issues.stream()\n+                                .flatMap(issue -> Stream.of(issue.getDetails()))\n+                                .flatMap(details -> Stream.of(details.getText()))\n+                                .flatMap(text -> Stream.of(text.getValue()))\n+                                .collect(Collectors.joining(\", \"));\n+                    log.fine(\"Validation warnings for input resource: \" + info);\n+                }\n+            }\n+        }\n+        return issues;\n+    }\n+\n+    /**\n+     * @param issues\n+     * @return\n+     */\n+    private boolean anyFailureInIssues(List<OperationOutcome.Issue> issues) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIzODI0NA=="}, "originalCommit": {"oid": "d0ff4daa4297bea3aff6025eac16697c3fe6ecb1"}, "originalPosition": 1085}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODM3ODI5Mw==", "bodyText": "Agree on moving to FHIRUtil", "url": "https://github.com/IBM/FHIR/pull/759#discussion_r388378293", "createdAt": "2020-03-05T15:43:42Z", "author": {"login": "JohnTimm"}, "path": "fhir-server/src/main/java/com/ibm/fhir/server/resources/FHIRRestHelper.java", "diffHunk": "@@ -0,0 +1,2448 @@\n+/*\n+ * (C) Copyright IBM Corp. 2016, 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.server.resources;\n+\n+import static com.ibm.fhir.model.type.String.string;\n+import static com.ibm.fhir.model.util.ModelSupport.getResourceType;\n+import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;\n+import static javax.servlet.http.HttpServletResponse.SC_GONE;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static javax.servlet.http.HttpServletResponse.SC_OK;\n+\n+import java.net.URI;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeFormatterBuilder;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.Status;\n+\n+import org.owasp.encoder.Encode;\n+\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.core.HTTPHandlingPreference;\n+import com.ibm.fhir.core.HTTPReturnPreference;\n+import com.ibm.fhir.core.context.FHIRPagingContext;\n+import com.ibm.fhir.exception.FHIROperationException;\n+import com.ibm.fhir.model.patch.FHIRPatch;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.OperationOutcome;\n+import com.ibm.fhir.model.resource.OperationOutcome.Issue;\n+import com.ibm.fhir.model.resource.Parameters;\n+import com.ibm.fhir.model.resource.Resource;\n+import com.ibm.fhir.model.type.CodeableConcept;\n+import com.ibm.fhir.model.type.Extension;\n+import com.ibm.fhir.model.type.UnsignedInt;\n+import com.ibm.fhir.model.type.Uri;\n+import com.ibm.fhir.model.type.Url;\n+import com.ibm.fhir.model.type.code.BundleType;\n+import com.ibm.fhir.model.type.code.HTTPVerb;\n+import com.ibm.fhir.model.type.code.IssueSeverity;\n+import com.ibm.fhir.model.type.code.IssueType;\n+import com.ibm.fhir.model.util.FHIRUtil;\n+import com.ibm.fhir.model.util.ModelSupport;\n+import com.ibm.fhir.model.util.ReferenceMappingVisitor;\n+import com.ibm.fhir.operation.FHIROperation;\n+import com.ibm.fhir.operation.context.FHIROperationContext;\n+import com.ibm.fhir.operation.registry.FHIROperationRegistry;\n+import com.ibm.fhir.operation.util.FHIROperationUtil;\n+import com.ibm.fhir.persistence.FHIRPersistence;\n+import com.ibm.fhir.persistence.FHIRPersistenceTransaction;\n+import com.ibm.fhir.persistence.context.FHIRHistoryContext;\n+import com.ibm.fhir.persistence.context.FHIRPersistenceContext;\n+import com.ibm.fhir.persistence.context.FHIRPersistenceContextFactory;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceResourceDeletedException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceResourceNotFoundException;\n+import com.ibm.fhir.persistence.helper.FHIRTransactionHelper;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceEvent;\n+import com.ibm.fhir.persistence.interceptor.impl.FHIRPersistenceInterceptorMgr;\n+import com.ibm.fhir.persistence.util.FHIRPersistenceUtil;\n+import com.ibm.fhir.rest.FHIRResourceHelpers;\n+import com.ibm.fhir.rest.FHIRRestOperationResponse;\n+import com.ibm.fhir.search.SearchConstants;\n+import com.ibm.fhir.search.SummaryValueSet;\n+import com.ibm.fhir.search.context.FHIRSearchContext;\n+import com.ibm.fhir.search.exception.FHIRSearchException;\n+import com.ibm.fhir.search.util.SearchUtil;\n+import com.ibm.fhir.server.exception.FHIRRestBundledRequestException;\n+import com.ibm.fhir.server.helper.FHIRUrlParser;\n+import com.ibm.fhir.server.util.IssueTypeToHttpStatusMapper;\n+import com.ibm.fhir.validation.FHIRValidator;\n+import com.ibm.fhir.validation.exception.FHIRValidationException;\n+\n+public class FHIRRestHelper implements FHIRResourceHelpers {\n+    private static final Logger log =\n+            java.util.logging.Logger.getLogger(FHIRRestHelper.class.getName());\n+\n+    private static final String EXTENSION_URL = \"http://ibm.com/fhir/extension\";\n+    private static final String LOCAL_REF_PREFIX = \"urn:\";\n+\n+    public static final DateTimeFormatter PARSER_FORMATTER = new DateTimeFormatterBuilder()\n+            .appendPattern(\"EEE\")\n+            .optionalStart()\n+            // ANSIC date time format for If-Modified-Since\n+            .appendPattern(\" MMM dd HH:mm:ss yyyy\")\n+            .optionalEnd()\n+            .optionalStart()\n+            // Touchstone date time format for If-Modified-Since\n+            .appendPattern(\", dd-MMM-yy HH:mm:ss\")\n+            .optionalEnd().toFormatter();\n+\n+    private FHIRPersistence persistence = null;\n+\n+    // These values are used for correlating requests within a bundle.\n+    private String bundleTransactionCorrelationId = null;\n+    private String bundleRequestCorrelationId = null;\n+\n+    public FHIRRestHelper(FHIRPersistence persistence) {\n+        this.persistence = persistence;\n+    }\n+\n+    /**\n+     * Performs the heavy lifting associated with a 'create' interaction.\n+     *\n+     * @param type\n+     *            the resource type specified as part of the request URL\n+     * @param resource\n+     *            the Resource to be stored.\n+     * @param ifNoneExist\n+     *            whether to create the resource if none exists\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return a FHIRRestOperationResponse object containing the results of the operation\n+     * @throws Exception\n+     */\n+    @Override\n+    public FHIRRestOperationResponse doCreate(String type, Resource resource, String ifNoneExist,\n+            Map<String, String> requestProperties) throws Exception {\n+        log.entering(this.getClass().getName(), \"doCreate\");\n+\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+        FHIRRestOperationResponse ior = new FHIRRestOperationResponse();\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+\n+            // Make sure the expected type (specified in the URL string) is congruent with the actual type\n+            // of the resource.\n+            String resourceType = ModelSupport.getTypeName(resource.getClass()); \n+            if (!resourceType.equals(type)) {\n+                String msg = \"Resource type '\" + resourceType\n+                        + \"' does not match type specified in request URI: \" + type;\n+                throw buildRestException(msg, IssueType.INVALID);\n+            }\n+\n+            // Check to see if we're supposed to perform a conditional 'create'.\n+            if (ifNoneExist != null && !ifNoneExist.isEmpty()) {\n+                log.fine(\"Performing conditional create with search criteria: \" + ifNoneExist);\n+                Bundle responseBundle = null;\n+\n+                // Perform the search using the \"If-None-Exist\" header value.\n+                try {\n+                    MultivaluedMap<String, String> searchParameters = getQueryParameterMap(ifNoneExist);\n+                    responseBundle =\n+                            doSearch(type, null, null, searchParameters, null, requestProperties, resource);\n+                } catch (FHIROperationException e) {\n+                    throw e;\n+                } catch (Throwable t) {\n+                    String msg =\n+                            \"An error occurred while performing the search for a conditional create operation.\";\n+                    log.log(Level.WARNING, msg, t);\n+                    throw new FHIROperationException(msg, t);\n+                }\n+\n+                // Check the search results to determine whether or not to perform the create operation.\n+                int resultCount = responseBundle.getEntry().size();\n+                log.fine(\"Conditional create search yielded \" + resultCount + \" results.\");\n+\n+                if (resultCount == 0) {\n+                    // Do nothing and fall through to process the 'create' request.\n+                } else if (resultCount == 1) {\n+                    // If we found a single match, bypass the 'create' request and return information\n+                    // for the matched resource.\n+                    Resource matchedResource = responseBundle.getEntry().get(0).getResource();\n+                    ior.setLocationURI(FHIRUtil.buildLocationURI(type, matchedResource));\n+                    ior.setStatus(Response.Status.OK);\n+                    ior.setResource(matchedResource);\n+                    log.fine(\"Returning location URI of matched resource: \" + ior.getLocationURI());\n+                    return ior;\n+                } else {\n+                    String msg =\n+                            \"The search criteria specified for a conditional create operation returned multiple matches.\";\n+                    throw buildRestException(msg, IssueType.MULTIPLE_MATCHES);\n+                }\n+            }\n+\n+            // For R4, resources may contain an id. For create, this should be ignored and\n+            // we no longer reject the request.\n+            if (resource.getId() != null && log.isLoggable(Level.FINE)) {\n+                log.fine(String.format(\"create request resource includes id: '%s'\", resource.getId()));\n+            }\n+\n+            // Validate the input resource and return any validation errors, but warnings are OK\n+            List<Issue> validationWarnings = validateInput(resource);\n+            ior.setOperationOutcome(FHIRUtil.buildOperationOutcome(validationWarnings));\n+\n+            // If there were no validation errors, then create the resource and return the location header.\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, invoke the 'beforeCreate' interceptor methods.\n+            FHIRPersistenceEvent event =\n+                    new FHIRPersistenceEvent(resource, buildPersistenceEventProperties(type, null, null, requestProperties));\n+            getInterceptorMgr().fireBeforeCreateEvent(event);\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event);\n+\n+            // R4: remember model objects are immutable, so we get back a new resource with the id/meta stuff\n+            resource = persistence.create(persistenceContext, resource).getResource();\n+            event.setFhirResource(resource); // update event with latest\n+            ior.setStatus(Response.Status.CREATED);\n+            ior.setResource(resource);\n+\n+            // Build our location URI and add it to the interceptor event structure since it is now known.\n+            ior.setLocationURI(FHIRUtil.buildLocationURI(ModelSupport.getTypeName(resource.getClass()), resource));\n+            event.getProperties().put(FHIRPersistenceEvent.PROPNAME_RESOURCE_LOCATION_URI, ior.getLocationURI().toString());\n+\n+            // Invoke the 'afterCreate' interceptor methods.\n+            getInterceptorMgr().fireAfterCreateEvent(event);\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+\n+            return ior;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we previously started a transaction and it's still active, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doCreate\");\n+        }\n+    }\n+\n+    @Override\n+    public FHIRRestOperationResponse doPatch(String type, String id, FHIRPatch patch, String ifMatchValue,\n+            String searchQueryString, Map<String, String> requestProperties) throws Exception {\n+\n+        return doPatchOrUpdate(type, id, patch, null, ifMatchValue, searchQueryString, requestProperties);\n+    }\n+\n+    @Override\n+    public FHIRRestOperationResponse doUpdate(String type, String id, Resource newResource, String ifMatchValue,\n+            String searchQueryString, Map<String, String> requestProperties) throws Exception {\n+\n+        return doPatchOrUpdate(type, id, null, newResource, ifMatchValue, searchQueryString, requestProperties);\n+    }\n+\n+    private FHIRRestOperationResponse doPatchOrUpdate(String type, String id, FHIRPatch patch,\n+            Resource newResource, String ifMatchValue, String searchQueryString,\n+            Map<String, String> requestProperties) throws Exception {\n+        log.entering(this.getClass().getName(), \"doPatchOrUpdate\");\n+\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        FHIRRestOperationResponse ior = new FHIRRestOperationResponse();\n+\n+        try {\n+            // Make sure the type specified in the URL string matches the resource type obtained from the new resource.\n+            if (patch == null) {\n+                String resourceType =  ModelSupport.getTypeName(newResource.getClass());\n+                if (!resourceType.equals(type)) {\n+                    String msg = \"Resource type '\" + resourceType\n+                            + \"' does not match type specified in request URI: \" + type;\n+                    throw buildRestException(msg, IssueType.INVALID);\n+                }\n+            }\n+\n+            // Next, if a conditional update was invoked then use the search criteria to find the\n+            // resource to be updated. Otherwise, we'll use the id value to retrieve the current\n+            // version of the resource.\n+            if (searchQueryString != null) {\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Performing conditional update/patch with search criteria: \"\n+                            + Encode.forHtml(searchQueryString));\n+                }\n+                Bundle responseBundle = null;\n+                try {\n+                    MultivaluedMap<String, String> searchParameters =\n+                            getQueryParameterMap(searchQueryString);\n+                    responseBundle =\n+                            doSearch(type, null, null, searchParameters, null, requestProperties, newResource);\n+                } catch (FHIROperationException e) {\n+                    throw e;\n+                } catch (Throwable t) {\n+                    String msg =\n+                            \"An error occurred while performing the search for a conditional update/patch operation.\";\n+                    throw new FHIROperationException(msg, t);\n+                }\n+\n+                // Check the search results to determine whether or not to perform the update operation.\n+                int resultCount = responseBundle.getEntry().size();\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Conditional update/patch search yielded \" + resultCount + \" results.\");\n+                }\n+\n+                if (resultCount == 0) {\n+                    if (patch != null) {\n+                        String msg =\n+                                \"The search criteria specified for a conditional patch operation did not return any results.\";\n+                        throw buildRestException(msg, IssueType.NOT_FOUND);\n+                    }\n+                    // Search yielded no matches, so we'll do an update/create operation below.\n+                    ior.setPrevResource(null);\n+\n+                    // if no id provided, then generate an id for the input resource\n+                    if (newResource.getId() == null || newResource.getId() == null) {\n+                        id = UUID.randomUUID().toString();\n+                        newResource = newResource.toBuilder().id(id).build();\n+                    } else {\n+                        id = newResource.getId();\n+                    }\n+                } else if (resultCount == 1) {\n+                    // If we found a single match, then we'll perform a normal update on the matched resource.\n+                    ior.setPrevResource(responseBundle.getEntry().get(0).getResource());\n+                    id = ior.getPrevResource().getId();\n+\n+                    // If the id of the input resource is different from the id of the search result,\n+                    // then throw exception.\n+                    if (newResource.getId() != null && newResource.getId() != null\n+                            && !newResource.getId().equalsIgnoreCase(id)) {\n+                        String msg = \"Input resource 'id' attribute must match the id of the search result resource.\";\n+                        throw buildRestException(msg, IssueType.VALUE);\n+                    }\n+                    // Make sure the id of the newResource is not null and is the same as the id of the found resource.\n+                    newResource = newResource.toBuilder().id(id).build();\n+                } else {\n+                    String msg =\n+                            \"The search criteria specified for a conditional update/patch operation returned multiple matches.\";\n+                    throw buildRestException(msg, IssueType.MULTIPLE_MATCHES);\n+                }\n+            } else {\n+                // Make sure an id value was passed in.\n+                if (id == null) {\n+                    String msg = \"The 'id' parameter is required for an update/pach operation.\";\n+                    throw buildRestException(msg, IssueType.REQUIRED);\n+                }\n+\n+                // If an id value was passed in (i.e. the id specified in the REST API URL string),\n+                // then make sure it's the same as the value in the resource.\n+                if (patch == null) {\n+                    // Make sure the resource has an 'id' attribute.\n+                    if (newResource.getId() == null) {\n+                        String msg = \"Input resource must contain an 'id' attribute.\";\n+                        throw buildRestException(msg, IssueType.INVALID);\n+                    }\n+\n+                    if (!newResource.getId().equals(id)) {\n+                        String msg = \"Input resource 'id' attribute must match 'id' parameter.\";\n+                        throw buildRestException(msg, IssueType.VALUE);\n+                    }\n+                }\n+\n+                // Retrieve the resource to be updated using the type and id values.\n+                ior.setPrevResource(doRead(type, id, (patch != null), true, requestProperties, newResource));\n+            }\n+\n+            if (patch != null) {\n+                newResource = patch.apply(ior.getPrevResource());\n+            }\n+\n+            // Validate the input resource and return any validation errors.\n+            List<Issue> validationWarnings = validateInput(newResource);\n+            ior.setOperationOutcome(FHIRUtil.buildOperationOutcome(validationWarnings));\n+\n+            // Perform the \"version-aware\" update check, and also find out if the resource was deleted.\n+            boolean isDeleted = false;\n+            if (ior.getPrevResource() != null) {\n+                performVersionAwareUpdateCheck(ior.getPrevResource(), ifMatchValue);\n+\n+                try {\n+                    doRead(type, id, (patch != null), false, requestProperties, newResource);\n+                } catch (FHIRPersistenceResourceDeletedException e) {\n+                    isDeleted = true;\n+                }\n+            }\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, create the persistence event.\n+            FHIRPersistenceEvent event = new FHIRPersistenceEvent(newResource, \n+                    buildPersistenceEventProperties(type, newResource.getId(), null, requestProperties));\n+\n+            // Next, set the \"previous resource\" in the persistence event.\n+            event.setPrevFhirResource(ior.getPrevResource());\n+\n+            // Next, invoke the 'beforeUpdate' or 'beforeCreate' interceptor methods as appropriate.\n+            boolean updateCreate = (ior.getPrevResource() == null);\n+            if (updateCreate) {\n+                getInterceptorMgr().fireBeforeCreateEvent(event);\n+            } else {\n+                if (patch != null) {\n+                    event.getProperties().put(FHIRPersistenceEvent.PROPNAME_PATCH, patch);\n+                    getInterceptorMgr().fireBeforePatchEvent(event);\n+                } else {\n+                    getInterceptorMgr().fireBeforeUpdateEvent(event);\n+                }\n+            }\n+\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event);\n+            newResource = persistence.update(persistenceContext, id, newResource).getResource();\n+            event.setFhirResource(newResource); // update event with latest\n+            ior.setResource(newResource);\n+\n+            // Build our location URI and add it to the interceptor event structure since it is now known.\n+            ior.setLocationURI(FHIRUtil.buildLocationURI(ModelSupport.getTypeName(newResource.getClass()), newResource));\n+            event.getProperties().put(FHIRPersistenceEvent.PROPNAME_RESOURCE_LOCATION_URI, ior.getLocationURI().toString());\n+\n+            // Invoke the 'afterUpdate' interceptor methods.\n+            if (updateCreate) {\n+                ior.setStatus(Response.Status.CREATED);\n+                getInterceptorMgr().fireAfterCreateEvent(event);\n+            } else {\n+                ior.setStatus(Response.Status.OK);\n+                if (patch != null) {\n+                    getInterceptorMgr().fireAfterPatchEvent(event);\n+                } else {\n+                    getInterceptorMgr().fireAfterUpdateEvent(event);\n+                }\n+            }\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+\n+            // If the deleted resource is updated, then simply return 201 instead of 200 to pass Touchstone test.\n+            // We don't set the previous resource to null in above codes if the resource was deleted, otherwise\n+            // it will break the code logic of the resource versioning.\n+            if (isDeleted && ior.getStatus() == Response.Status.OK) {\n+                ior.setStatus(Response.Status.CREATED);\n+            }\n+\n+            return ior;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we still have a transaction at this point, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doPatchOrUpdate\");\n+        }\n+    }\n+\n+    /**\n+     * Performs a 'delete' operation on the specified resource.\n+     *\n+     * @param type\n+     *            the resource type associated with the Resource to be deleted\n+     * @param id\n+     *            the id of the Resource to be deleted\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return a FHIRRestOperationResponse that contains the results of the operation\n+     * @throws Exception\n+     */\n+    @Override\n+    public FHIRRestOperationResponse doDelete(String type, String id, String searchQueryString,\n+            Map<String, String> requestProperties) throws Exception {\n+        log.entering(this.getClass().getName(), \"doDelete\");\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+        Response.Status status = null;\n+\n+        FHIRRestOperationResponse ior = new FHIRRestOperationResponse();\n+\n+        try {\n+            String resourceTypeName = type;\n+            if (!ModelSupport.isResourceType(type)) {\n+                throw buildUnsupportedResourceTypeException(type, IssueType.NOT_SUPPORTED);\n+            }\n+\n+            Class<? extends Resource> resourceType =\n+                    getResourceType(resourceTypeName);\n+\n+            // Next, if a conditional delete was invoked then use the search criteria to find the\n+            // resource to be deleted. Otherwise, we'll use the id value to identify the resource\n+            // to be deleted.\n+            Resource resourceToDelete = null;\n+            if (searchQueryString != null) {\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Performing conditional delete with search criteria: \"\n+                            + Encode.forHtml(searchQueryString));\n+                }\n+                Bundle responseBundle = null;\n+                try {\n+                    MultivaluedMap<String, String> searchParameters =\n+                            getQueryParameterMap(searchQueryString);\n+                    responseBundle =\n+                            doSearch(type, null, null, searchParameters, null, requestProperties, null);\n+                } catch (FHIROperationException e) {\n+                    throw e;\n+                } catch (Throwable t) {\n+                    String msg =\n+                            \"An error occurred while performing the search for a conditional delete operation.\";\n+                    throw new FHIROperationException(msg, t);\n+                }\n+\n+                // Check the search results to determine whether or not to perform the update operation.\n+                int resultCount = responseBundle.getEntry().size();\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Conditional delete search yielded \" + resultCount + \" results.\");\n+                }\n+\n+                if (resultCount == 0) {\n+                    // Search yielded no matches\n+                    String msg = \"Search criteria for a conditional delete operation yielded no matches.\";\n+                    if (log.isLoggable(Level.FINE)) {\n+                        log.fine(msg);\n+                    }\n+                    status = Response.Status.OK;\n+                    ior.setOperationOutcome(FHIRUtil.buildOperationOutcome(msg, IssueType.NOT_FOUND, IssueSeverity.WARNING));\n+                    ior.setStatus(status);\n+                    return ior;\n+                } else if (resultCount == 1) {\n+                    // If we found a single match, then we'll delete this one.\n+                    Resource resource = responseBundle.getEntry().get(0).getResource();\n+                    id = resource.getId();\n+                    resourceToDelete = resource;\n+                } else {\n+                    String msg =\n+                            \"The search criteria specified for a conditional delete operation returned multiple matches.\";\n+                    throw buildRestException(msg, IssueType.MULTIPLE_MATCHES);\n+                }\n+            } else {\n+                // Make sure an id value was passed in.\n+                if (id == null) {\n+                    String msg = \"The 'id' parameter is required for a delete operation.\";\n+                    throw buildRestException(msg, IssueType.REQUIRED);\n+                }\n+\n+                // Read the resource so it will be available to the beforeDelete interceptor methods.\n+                try {\n+                    resourceToDelete = doRead(type, id, false, false, requestProperties, null);\n+                } catch (FHIRPersistenceResourceDeletedException e) {\n+                    // Absorb this exception.\n+                    resourceToDelete = null;\n+                }\n+            }\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, invoke the 'beforeDelete' interceptor methods.\n+            FHIRPersistenceEvent event =\n+                    new FHIRPersistenceEvent(null, buildPersistenceEventProperties(type, id, null, requestProperties));\n+            event.setFhirResource(resourceToDelete);\n+            getInterceptorMgr().fireBeforeDeleteEvent(event);\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event);\n+\n+            Resource resource = persistence.delete(persistenceContext, resourceType, id).getResource();\n+            ior.setResource(resource);\n+            event.setFhirResource(resource);\n+            ior.setStatus(Response.Status.NO_CONTENT);\n+\n+            // Invoke the 'afterDelete' interceptor methods.\n+            getInterceptorMgr().fireAfterDeleteEvent(event);\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+            status = ior.getStatus();\n+\n+            return ior;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we previously started a transaction and it's still active, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doDelete\");\n+        }\n+    }\n+\n+    @Override\n+    public Resource doRead(String type, String id, boolean throwExcOnNull, boolean includeDeleted,\n+            Map<String, String> requestProperties, Resource contextResource) throws Exception {\n+        return doRead(type, id, throwExcOnNull, includeDeleted, requestProperties, contextResource, null);\n+    }\n+\n+    /**\n+     * Performs a 'read' operation to retrieve a Resource.\n+     *\n+     * @param type\n+     *            the resource type associated with the Resource to be retrieved\n+     * @param id\n+     *            the id of the Resource to be retrieved\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return the Resource\n+     * @throws Exception\n+     */\n+    @Override\n+    public Resource doRead(String type, String id, boolean throwExcOnNull, boolean includeDeleted,\n+            Map<String, String> requestProperties, Resource contextResource, MultivaluedMap<String, String> queryParameters)\n+            throws Exception {\n+        log.entering(this.getClass().getName(), \"doRead\");\n+\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+        Resource resource = null;\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+            String resourceTypeName = type;\n+            if (!ModelSupport.isResourceType(type)) {\n+                throw buildUnsupportedResourceTypeException(type, IssueType.NOT_SUPPORTED);\n+            }\n+\n+            Class<? extends Resource> resourceType = getResourceType(resourceTypeName);\n+\n+            FHIRSearchContext searchContext = null;\n+            if (queryParameters != null) {\n+                searchContext = SearchUtil.parseQueryParameters(null, null, resourceType, queryParameters, \n+                        HTTPHandlingPreference.LENIENT.equals(requestContext.getHandlingPreference()));\n+            }\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, invoke the 'beforeRead' interceptor methods.\n+            FHIRPersistenceEvent event =\n+                    new FHIRPersistenceEvent(contextResource, buildPersistenceEventProperties(type, id, null, requestProperties));\n+            getInterceptorMgr().fireBeforeReadEvent(event);\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event, includeDeleted, searchContext);\n+            resource = persistence.read(persistenceContext, resourceType, id).getResource();\n+            if (resource == null && throwExcOnNull) {\n+                throw new FHIRPersistenceResourceNotFoundException(\"Resource '\" + type + \"/\" + id + \"' not found.\");\n+            }\n+\n+            event.setFhirResource(resource);\n+\n+            // Invoke the 'afterRead' interceptor methods.\n+            getInterceptorMgr().fireAfterReadEvent(event);\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+\n+            return resource;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we previously started a transaction and it's still active, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doRead\");\n+        }\n+    }\n+\n+    /**\n+     * Performs a 'vread' operation by retrieving the specified version of a Resource.\n+     *\n+     * @param type\n+     *            the resource type associated with the Resource to be retrieved\n+     * @param id\n+     *            the id of the Resource to be retrieved\n+     * @param versionId\n+     *            the version id of the Resource to be retrieved\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return the Resource\n+     * @throws Exception\n+     */\n+    @Override\n+    public Resource doVRead(String type, String id, String versionId,\n+        Map<String, String> requestProperties) throws Exception {\n+        log.entering(this.getClass().getName(), \"doVRead\");\n+\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+        Resource resource = null;\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+            String resourceTypeName = type;\n+            if (!ModelSupport.isResourceType(type)) {\n+                throw buildUnsupportedResourceTypeException(type, IssueType.NOT_SUPPORTED);\n+            }\n+\n+            Class<? extends Resource> resourceType =\n+                    getResourceType(resourceTypeName);\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, invoke the 'beforeVread' interceptor methods.\n+            FHIRPersistenceEvent event =\n+                    new FHIRPersistenceEvent(null, buildPersistenceEventProperties(type, id, versionId, requestProperties));\n+            getInterceptorMgr().fireBeforeVreadEvent(event);\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event);\n+            resource = persistence.vread(persistenceContext, resourceType, id, versionId).getResource();\n+            if (resource == null) {\n+                throw new FHIRPersistenceResourceNotFoundException(\"Resource '\"\n+                        + resourceType.getSimpleName() + \"/\" + id + \"' version \" + versionId + \" not found.\");\n+            }\n+\n+            event.setFhirResource(resource);\n+\n+            // Invoke the 'afterVread' interceptor methods.\n+            getInterceptorMgr().fireAfterVreadEvent(event);\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+\n+            return resource;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we previously started a transaction and it's still active, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doVRead\");\n+        }\n+    }\n+\n+    /**\n+     * Performs the work of retrieving versions of a Resource.\n+     *\n+     * @param type\n+     *            the resource type associated with the Resource to be retrieved\n+     * @param id\n+     *            the id of the Resource to be retrieved\n+     * @param queryParameters\n+     *            a Map containing the query parameters from the request URL\n+     * @param requestUri the URI from the request\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return a Bundle containing the history of the specified Resource\n+     * @throws Exception\n+     */\n+    @Override\n+    public Bundle doHistory(String type, String id, MultivaluedMap<String, String> queryParameters,\n+        String requestUri, Map<String, String> requestProperties)\n+        throws Exception {\n+        log.entering(this.getClass().getName(), \"doHistory\");\n+\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+        Bundle bundle = null;\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+            String resourceTypeName = type;\n+            if (!ModelSupport.isResourceType(type)) {\n+                throw buildUnsupportedResourceTypeException(type, IssueType.NOT_SUPPORTED);\n+            }\n+\n+            Class<? extends Resource> resourceType =\n+                    getResourceType(resourceTypeName);\n+            FHIRHistoryContext historyContext =\n+                    FHIRPersistenceUtil.parseHistoryParameters(queryParameters, HTTPHandlingPreference.LENIENT.equals(requestContext.getHandlingPreference()));\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, invoke the 'beforeHistory' interceptor methods.\n+            FHIRPersistenceEvent event =\n+                    new FHIRPersistenceEvent(null, buildPersistenceEventProperties(type, id, null, requestProperties));\n+            getInterceptorMgr().fireBeforeHistoryEvent(event);\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event, historyContext);\n+            List<? extends Resource> resources =\n+                    persistence.history(persistenceContext, resourceType, id).getResource();\n+            bundle = createHistoryBundle(resources, historyContext, type);\n+            bundle = addLinks(historyContext, bundle, requestUri);\n+\n+            event.setFhirResource(bundle);\n+\n+            // Invoke the 'afterHistory' interceptor methods.\n+            getInterceptorMgr().fireAfterHistoryEvent(event);\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+\n+            return bundle;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we previously started a transaction and it's still active, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doHistory\");\n+        }\n+    }\n+\n+    /**\n+     * Performs heavy lifting associated with a 'search' operation.\n+     *\n+     * @param type\n+     *            the resource type associated with the search\n+     * @param queryParameters\n+     *            a Map containing the query parameters from the request URL\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return a Bundle containing the search result set\n+     * @throws Exception\n+     */\n+    @Override\n+    public Bundle doSearch(String type, String compartment, String compartmentId,\n+            MultivaluedMap<String, String> queryParameters, String requestUri,\n+            Map<String, String> requestProperties, Resource contextResource) throws Exception {\n+        log.entering(this.getClass().getName(), \"doSearch\");\n+\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+        Bundle bundle = null;\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+            String resourceTypeName = type;\n+\n+            // Check to see if it's supported, else, throw a bad request.\n+            // If this is removed, it'll result in nullpointer when processing the request\n+            if (!ModelSupport.isResourceType(type)) {\n+                throw buildUnsupportedResourceTypeException(type, IssueType.NOT_SUPPORTED);\n+            }\n+\n+            Class<? extends Resource> resourceType =\n+                    getResourceType(resourceTypeName);\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, invoke the 'beforeSearch' interceptor methods.\n+            FHIRPersistenceEvent event =\n+                    new FHIRPersistenceEvent(contextResource, buildPersistenceEventProperties(type, null, null, requestProperties));\n+            getInterceptorMgr().fireBeforeSearchEvent(event);\n+\n+            FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(compartment, compartmentId, resourceType, queryParameters,\n+                    HTTPHandlingPreference.LENIENT.equals(requestContext.getHandlingPreference()));\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event, searchContext);\n+            List<Resource> resources =\n+                    persistence.search(persistenceContext, resourceType).getResource();\n+\n+            bundle = createSearchBundle(resources, searchContext, type);\n+            if (requestUri != null) {\n+                bundle = addLinks(searchContext, bundle, requestUri);\n+            }\n+            event.setFhirResource(bundle);\n+\n+            // Invoke the 'afterSearch' interceptor methods.\n+            getInterceptorMgr().fireAfterSearchEvent(event);\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+\n+            return bundle;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we previously started a transaction and it's still active, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doSearch\");\n+        }\n+    }\n+\n+    /**\n+     * Helper method which invokes a custom operation.\n+     *\n+     * @param operationContext\n+     *            the FHIROperationContext associated with the request\n+     * @param resourceTypeName\n+     *            the resource type associated with the request\n+     * @param logicalId\n+     *            the resource logical id associated with the request\n+     * @param versionId\n+     *            the resource version id associated with the request\n+     * @param operationName\n+     *            the name of the custom operation to be invoked\n+     * @param resource\n+     *            the input resource associated with the custom operation to be invoked\n+     * @param queryParameters\n+     *            query parameters may be passed instead of a Parameters resource for certain custom operations invoked\n+     *            via GET\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return a Resource that represents the response to the custom operation\n+     * @throws Exception\n+     */\n+    @Override\n+    public Resource doInvoke(FHIROperationContext operationContext, String resourceTypeName,\n+            String logicalId, String versionId, String operationName,\n+            Resource resource, MultivaluedMap<String, String> queryParameters,\n+            Map<String, String> requestProperties) throws Exception {\n+        log.entering(this.getClass().getName(), \"doInvoke\");\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+            Class<? extends Resource> resourceType = null;\n+            if (resourceTypeName != null) {\n+                resourceType = getResourceType(resourceTypeName);\n+            }\n+            String operationKey = (resourceTypeName == null ? operationName : operationName + \":\" + resourceTypeName);\n+\n+            FHIROperation operation =\n+                    FHIROperationRegistry.getInstance().getOperation(operationKey);\n+            Parameters parameters = null;\n+            if (resource instanceof Parameters) {\n+                parameters = (Parameters) resource;\n+            } else {\n+                if (resource == null) {\n+                    // build parameters object from query parameters\n+                    parameters =\n+                            FHIROperationUtil.getInputParameters(operation.getDefinition(), queryParameters);\n+                } else {\n+                    // wrap resource in a parameters object\n+                    parameters =\n+                            FHIROperationUtil.getInputParameters(operation.getDefinition(), resource);\n+                }\n+            }\n+\n+            // Add properties to the FHIR operation context\n+            setOperationContextProperties(operationContext, resourceTypeName, requestProperties);\n+\n+            if (log.isLoggable(Level.FINE)) {\n+                log.fine(\"Invoking operation '\" + operationName + \"', context=\\n\"\n+                        + operationContext.toString());\n+            }\n+            Parameters result =\n+                    operation.invoke(operationContext, resourceType, logicalId, versionId, parameters, this);\n+            if (log.isLoggable(Level.FINE)) {\n+                log.fine(\"Returned from invocation of operation '\" + operationName + \"'...\");\n+            }\n+\n+            // if single resource output parameter, return the resource\n+            if (FHIROperationUtil.hasSingleResourceOutputParameter(result)) {\n+                return FHIROperationUtil.getSingleResourceOutputParameter(result);\n+            }\n+\n+            return result;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            log.exiting(this.getClass().getName(), \"doInvoke\");\n+        }\n+    }\n+\n+    /**\n+     * Processes a bundled request.\n+     *\n+     * @param bundleResource\n+     *            the request Bundle\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return the response Bundle\n+     */\n+    @Override\n+    public Bundle doBundle(Resource bundleResource, Map<String, String> requestProperties)\n+        throws Exception {\n+        log.entering(this.getClass().getName(), \"doBundle\");\n+        Bundle inputBundle = null;\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+            if (bundleResource instanceof Bundle) {\n+                inputBundle = (Bundle) bundleResource;\n+            } else {\n+                String msg = \"A 'Bundle' resource type is required but a '\"\n+                        + bundleResource.getClass().getSimpleName() + \"' resource type was sent.\";\n+                throw buildRestException(msg, IssueType.INVALID);\n+            }\n+            // First, validate the bundle and create the response bundle.\n+            Bundle responseBundle = validateBundle(inputBundle);\n+\n+            // Next, process each of the entries in the bundle.\n+            responseBundle = processBundleEntries(inputBundle, responseBundle, requestProperties);\n+\n+            return responseBundle;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            log.exiting(this.getClass().getName(), \"doBundle\");\n+        }\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * @see com.ibm.fhir.rest.FHIRResourceHelpers#getTransaction()\n+     */\n+    @Override\n+    public FHIRPersistenceTransaction getTransaction() throws Exception {\n+        return persistence.getTransaction();\n+    }\n+\n+    /**\n+     * Validate the input resource and throw if there are validation errors\n+     *\n+     * @param resource\n+     * @throws FHIRValidationException\n+     * @throws FHIROperationException\n+     */\n+    private List<OperationOutcome.Issue> validateInput(Resource resource)\n+            throws FHIRValidationException, FHIROperationException {\n+        List<OperationOutcome.Issue> issues = FHIRValidator.validator().validate(resource);\n+        if (!issues.isEmpty()) {\n+            boolean includesFailure = false;\n+            for (OperationOutcome.Issue issue : issues) {\n+                if (FHIRUtil.isFailure(issue.getSeverity())) {\n+                    includesFailure = true;\n+                }\n+            }\n+\n+            if (includesFailure) {\n+                throw new FHIROperationException(\"Input resource failed validation.\").withIssue(issues);\n+            } else {\n+                if (log.isLoggable(Level.FINE)) {\n+                    String info = issues.stream()\n+                                .flatMap(issue -> Stream.of(issue.getDetails()))\n+                                .flatMap(details -> Stream.of(details.getText()))\n+                                .flatMap(text -> Stream.of(text.getValue()))\n+                                .collect(Collectors.joining(\", \"));\n+                    log.fine(\"Validation warnings for input resource: \" + info);\n+                }\n+            }\n+        }\n+        return issues;\n+    }\n+\n+    /**\n+     * @param issues\n+     * @return\n+     */\n+    private boolean anyFailureInIssues(List<OperationOutcome.Issue> issues) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIzODI0NA=="}, "originalCommit": {"oid": "d0ff4daa4297bea3aff6025eac16697c3fe6ecb1"}, "originalPosition": 1085}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODM3ODYxMA==", "bodyText": "or the fhir-validator project", "url": "https://github.com/IBM/FHIR/pull/759#discussion_r388378610", "createdAt": "2020-03-05T15:44:09Z", "author": {"login": "JohnTimm"}, "path": "fhir-server/src/main/java/com/ibm/fhir/server/resources/FHIRRestHelper.java", "diffHunk": "@@ -0,0 +1,2448 @@\n+/*\n+ * (C) Copyright IBM Corp. 2016, 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.server.resources;\n+\n+import static com.ibm.fhir.model.type.String.string;\n+import static com.ibm.fhir.model.util.ModelSupport.getResourceType;\n+import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;\n+import static javax.servlet.http.HttpServletResponse.SC_GONE;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static javax.servlet.http.HttpServletResponse.SC_OK;\n+\n+import java.net.URI;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeFormatterBuilder;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.Status;\n+\n+import org.owasp.encoder.Encode;\n+\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.core.HTTPHandlingPreference;\n+import com.ibm.fhir.core.HTTPReturnPreference;\n+import com.ibm.fhir.core.context.FHIRPagingContext;\n+import com.ibm.fhir.exception.FHIROperationException;\n+import com.ibm.fhir.model.patch.FHIRPatch;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.OperationOutcome;\n+import com.ibm.fhir.model.resource.OperationOutcome.Issue;\n+import com.ibm.fhir.model.resource.Parameters;\n+import com.ibm.fhir.model.resource.Resource;\n+import com.ibm.fhir.model.type.CodeableConcept;\n+import com.ibm.fhir.model.type.Extension;\n+import com.ibm.fhir.model.type.UnsignedInt;\n+import com.ibm.fhir.model.type.Uri;\n+import com.ibm.fhir.model.type.Url;\n+import com.ibm.fhir.model.type.code.BundleType;\n+import com.ibm.fhir.model.type.code.HTTPVerb;\n+import com.ibm.fhir.model.type.code.IssueSeverity;\n+import com.ibm.fhir.model.type.code.IssueType;\n+import com.ibm.fhir.model.util.FHIRUtil;\n+import com.ibm.fhir.model.util.ModelSupport;\n+import com.ibm.fhir.model.util.ReferenceMappingVisitor;\n+import com.ibm.fhir.operation.FHIROperation;\n+import com.ibm.fhir.operation.context.FHIROperationContext;\n+import com.ibm.fhir.operation.registry.FHIROperationRegistry;\n+import com.ibm.fhir.operation.util.FHIROperationUtil;\n+import com.ibm.fhir.persistence.FHIRPersistence;\n+import com.ibm.fhir.persistence.FHIRPersistenceTransaction;\n+import com.ibm.fhir.persistence.context.FHIRHistoryContext;\n+import com.ibm.fhir.persistence.context.FHIRPersistenceContext;\n+import com.ibm.fhir.persistence.context.FHIRPersistenceContextFactory;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceResourceDeletedException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceResourceNotFoundException;\n+import com.ibm.fhir.persistence.helper.FHIRTransactionHelper;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceEvent;\n+import com.ibm.fhir.persistence.interceptor.impl.FHIRPersistenceInterceptorMgr;\n+import com.ibm.fhir.persistence.util.FHIRPersistenceUtil;\n+import com.ibm.fhir.rest.FHIRResourceHelpers;\n+import com.ibm.fhir.rest.FHIRRestOperationResponse;\n+import com.ibm.fhir.search.SearchConstants;\n+import com.ibm.fhir.search.SummaryValueSet;\n+import com.ibm.fhir.search.context.FHIRSearchContext;\n+import com.ibm.fhir.search.exception.FHIRSearchException;\n+import com.ibm.fhir.search.util.SearchUtil;\n+import com.ibm.fhir.server.exception.FHIRRestBundledRequestException;\n+import com.ibm.fhir.server.helper.FHIRUrlParser;\n+import com.ibm.fhir.server.util.IssueTypeToHttpStatusMapper;\n+import com.ibm.fhir.validation.FHIRValidator;\n+import com.ibm.fhir.validation.exception.FHIRValidationException;\n+\n+public class FHIRRestHelper implements FHIRResourceHelpers {\n+    private static final Logger log =\n+            java.util.logging.Logger.getLogger(FHIRRestHelper.class.getName());\n+\n+    private static final String EXTENSION_URL = \"http://ibm.com/fhir/extension\";\n+    private static final String LOCAL_REF_PREFIX = \"urn:\";\n+\n+    public static final DateTimeFormatter PARSER_FORMATTER = new DateTimeFormatterBuilder()\n+            .appendPattern(\"EEE\")\n+            .optionalStart()\n+            // ANSIC date time format for If-Modified-Since\n+            .appendPattern(\" MMM dd HH:mm:ss yyyy\")\n+            .optionalEnd()\n+            .optionalStart()\n+            // Touchstone date time format for If-Modified-Since\n+            .appendPattern(\", dd-MMM-yy HH:mm:ss\")\n+            .optionalEnd().toFormatter();\n+\n+    private FHIRPersistence persistence = null;\n+\n+    // These values are used for correlating requests within a bundle.\n+    private String bundleTransactionCorrelationId = null;\n+    private String bundleRequestCorrelationId = null;\n+\n+    public FHIRRestHelper(FHIRPersistence persistence) {\n+        this.persistence = persistence;\n+    }\n+\n+    /**\n+     * Performs the heavy lifting associated with a 'create' interaction.\n+     *\n+     * @param type\n+     *            the resource type specified as part of the request URL\n+     * @param resource\n+     *            the Resource to be stored.\n+     * @param ifNoneExist\n+     *            whether to create the resource if none exists\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return a FHIRRestOperationResponse object containing the results of the operation\n+     * @throws Exception\n+     */\n+    @Override\n+    public FHIRRestOperationResponse doCreate(String type, Resource resource, String ifNoneExist,\n+            Map<String, String> requestProperties) throws Exception {\n+        log.entering(this.getClass().getName(), \"doCreate\");\n+\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+        FHIRRestOperationResponse ior = new FHIRRestOperationResponse();\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+\n+            // Make sure the expected type (specified in the URL string) is congruent with the actual type\n+            // of the resource.\n+            String resourceType = ModelSupport.getTypeName(resource.getClass()); \n+            if (!resourceType.equals(type)) {\n+                String msg = \"Resource type '\" + resourceType\n+                        + \"' does not match type specified in request URI: \" + type;\n+                throw buildRestException(msg, IssueType.INVALID);\n+            }\n+\n+            // Check to see if we're supposed to perform a conditional 'create'.\n+            if (ifNoneExist != null && !ifNoneExist.isEmpty()) {\n+                log.fine(\"Performing conditional create with search criteria: \" + ifNoneExist);\n+                Bundle responseBundle = null;\n+\n+                // Perform the search using the \"If-None-Exist\" header value.\n+                try {\n+                    MultivaluedMap<String, String> searchParameters = getQueryParameterMap(ifNoneExist);\n+                    responseBundle =\n+                            doSearch(type, null, null, searchParameters, null, requestProperties, resource);\n+                } catch (FHIROperationException e) {\n+                    throw e;\n+                } catch (Throwable t) {\n+                    String msg =\n+                            \"An error occurred while performing the search for a conditional create operation.\";\n+                    log.log(Level.WARNING, msg, t);\n+                    throw new FHIROperationException(msg, t);\n+                }\n+\n+                // Check the search results to determine whether or not to perform the create operation.\n+                int resultCount = responseBundle.getEntry().size();\n+                log.fine(\"Conditional create search yielded \" + resultCount + \" results.\");\n+\n+                if (resultCount == 0) {\n+                    // Do nothing and fall through to process the 'create' request.\n+                } else if (resultCount == 1) {\n+                    // If we found a single match, bypass the 'create' request and return information\n+                    // for the matched resource.\n+                    Resource matchedResource = responseBundle.getEntry().get(0).getResource();\n+                    ior.setLocationURI(FHIRUtil.buildLocationURI(type, matchedResource));\n+                    ior.setStatus(Response.Status.OK);\n+                    ior.setResource(matchedResource);\n+                    log.fine(\"Returning location URI of matched resource: \" + ior.getLocationURI());\n+                    return ior;\n+                } else {\n+                    String msg =\n+                            \"The search criteria specified for a conditional create operation returned multiple matches.\";\n+                    throw buildRestException(msg, IssueType.MULTIPLE_MATCHES);\n+                }\n+            }\n+\n+            // For R4, resources may contain an id. For create, this should be ignored and\n+            // we no longer reject the request.\n+            if (resource.getId() != null && log.isLoggable(Level.FINE)) {\n+                log.fine(String.format(\"create request resource includes id: '%s'\", resource.getId()));\n+            }\n+\n+            // Validate the input resource and return any validation errors, but warnings are OK\n+            List<Issue> validationWarnings = validateInput(resource);\n+            ior.setOperationOutcome(FHIRUtil.buildOperationOutcome(validationWarnings));\n+\n+            // If there were no validation errors, then create the resource and return the location header.\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, invoke the 'beforeCreate' interceptor methods.\n+            FHIRPersistenceEvent event =\n+                    new FHIRPersistenceEvent(resource, buildPersistenceEventProperties(type, null, null, requestProperties));\n+            getInterceptorMgr().fireBeforeCreateEvent(event);\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event);\n+\n+            // R4: remember model objects are immutable, so we get back a new resource with the id/meta stuff\n+            resource = persistence.create(persistenceContext, resource).getResource();\n+            event.setFhirResource(resource); // update event with latest\n+            ior.setStatus(Response.Status.CREATED);\n+            ior.setResource(resource);\n+\n+            // Build our location URI and add it to the interceptor event structure since it is now known.\n+            ior.setLocationURI(FHIRUtil.buildLocationURI(ModelSupport.getTypeName(resource.getClass()), resource));\n+            event.getProperties().put(FHIRPersistenceEvent.PROPNAME_RESOURCE_LOCATION_URI, ior.getLocationURI().toString());\n+\n+            // Invoke the 'afterCreate' interceptor methods.\n+            getInterceptorMgr().fireAfterCreateEvent(event);\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+\n+            return ior;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we previously started a transaction and it's still active, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doCreate\");\n+        }\n+    }\n+\n+    @Override\n+    public FHIRRestOperationResponse doPatch(String type, String id, FHIRPatch patch, String ifMatchValue,\n+            String searchQueryString, Map<String, String> requestProperties) throws Exception {\n+\n+        return doPatchOrUpdate(type, id, patch, null, ifMatchValue, searchQueryString, requestProperties);\n+    }\n+\n+    @Override\n+    public FHIRRestOperationResponse doUpdate(String type, String id, Resource newResource, String ifMatchValue,\n+            String searchQueryString, Map<String, String> requestProperties) throws Exception {\n+\n+        return doPatchOrUpdate(type, id, null, newResource, ifMatchValue, searchQueryString, requestProperties);\n+    }\n+\n+    private FHIRRestOperationResponse doPatchOrUpdate(String type, String id, FHIRPatch patch,\n+            Resource newResource, String ifMatchValue, String searchQueryString,\n+            Map<String, String> requestProperties) throws Exception {\n+        log.entering(this.getClass().getName(), \"doPatchOrUpdate\");\n+\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        FHIRRestOperationResponse ior = new FHIRRestOperationResponse();\n+\n+        try {\n+            // Make sure the type specified in the URL string matches the resource type obtained from the new resource.\n+            if (patch == null) {\n+                String resourceType =  ModelSupport.getTypeName(newResource.getClass());\n+                if (!resourceType.equals(type)) {\n+                    String msg = \"Resource type '\" + resourceType\n+                            + \"' does not match type specified in request URI: \" + type;\n+                    throw buildRestException(msg, IssueType.INVALID);\n+                }\n+            }\n+\n+            // Next, if a conditional update was invoked then use the search criteria to find the\n+            // resource to be updated. Otherwise, we'll use the id value to retrieve the current\n+            // version of the resource.\n+            if (searchQueryString != null) {\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Performing conditional update/patch with search criteria: \"\n+                            + Encode.forHtml(searchQueryString));\n+                }\n+                Bundle responseBundle = null;\n+                try {\n+                    MultivaluedMap<String, String> searchParameters =\n+                            getQueryParameterMap(searchQueryString);\n+                    responseBundle =\n+                            doSearch(type, null, null, searchParameters, null, requestProperties, newResource);\n+                } catch (FHIROperationException e) {\n+                    throw e;\n+                } catch (Throwable t) {\n+                    String msg =\n+                            \"An error occurred while performing the search for a conditional update/patch operation.\";\n+                    throw new FHIROperationException(msg, t);\n+                }\n+\n+                // Check the search results to determine whether or not to perform the update operation.\n+                int resultCount = responseBundle.getEntry().size();\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Conditional update/patch search yielded \" + resultCount + \" results.\");\n+                }\n+\n+                if (resultCount == 0) {\n+                    if (patch != null) {\n+                        String msg =\n+                                \"The search criteria specified for a conditional patch operation did not return any results.\";\n+                        throw buildRestException(msg, IssueType.NOT_FOUND);\n+                    }\n+                    // Search yielded no matches, so we'll do an update/create operation below.\n+                    ior.setPrevResource(null);\n+\n+                    // if no id provided, then generate an id for the input resource\n+                    if (newResource.getId() == null || newResource.getId() == null) {\n+                        id = UUID.randomUUID().toString();\n+                        newResource = newResource.toBuilder().id(id).build();\n+                    } else {\n+                        id = newResource.getId();\n+                    }\n+                } else if (resultCount == 1) {\n+                    // If we found a single match, then we'll perform a normal update on the matched resource.\n+                    ior.setPrevResource(responseBundle.getEntry().get(0).getResource());\n+                    id = ior.getPrevResource().getId();\n+\n+                    // If the id of the input resource is different from the id of the search result,\n+                    // then throw exception.\n+                    if (newResource.getId() != null && newResource.getId() != null\n+                            && !newResource.getId().equalsIgnoreCase(id)) {\n+                        String msg = \"Input resource 'id' attribute must match the id of the search result resource.\";\n+                        throw buildRestException(msg, IssueType.VALUE);\n+                    }\n+                    // Make sure the id of the newResource is not null and is the same as the id of the found resource.\n+                    newResource = newResource.toBuilder().id(id).build();\n+                } else {\n+                    String msg =\n+                            \"The search criteria specified for a conditional update/patch operation returned multiple matches.\";\n+                    throw buildRestException(msg, IssueType.MULTIPLE_MATCHES);\n+                }\n+            } else {\n+                // Make sure an id value was passed in.\n+                if (id == null) {\n+                    String msg = \"The 'id' parameter is required for an update/pach operation.\";\n+                    throw buildRestException(msg, IssueType.REQUIRED);\n+                }\n+\n+                // If an id value was passed in (i.e. the id specified in the REST API URL string),\n+                // then make sure it's the same as the value in the resource.\n+                if (patch == null) {\n+                    // Make sure the resource has an 'id' attribute.\n+                    if (newResource.getId() == null) {\n+                        String msg = \"Input resource must contain an 'id' attribute.\";\n+                        throw buildRestException(msg, IssueType.INVALID);\n+                    }\n+\n+                    if (!newResource.getId().equals(id)) {\n+                        String msg = \"Input resource 'id' attribute must match 'id' parameter.\";\n+                        throw buildRestException(msg, IssueType.VALUE);\n+                    }\n+                }\n+\n+                // Retrieve the resource to be updated using the type and id values.\n+                ior.setPrevResource(doRead(type, id, (patch != null), true, requestProperties, newResource));\n+            }\n+\n+            if (patch != null) {\n+                newResource = patch.apply(ior.getPrevResource());\n+            }\n+\n+            // Validate the input resource and return any validation errors.\n+            List<Issue> validationWarnings = validateInput(newResource);\n+            ior.setOperationOutcome(FHIRUtil.buildOperationOutcome(validationWarnings));\n+\n+            // Perform the \"version-aware\" update check, and also find out if the resource was deleted.\n+            boolean isDeleted = false;\n+            if (ior.getPrevResource() != null) {\n+                performVersionAwareUpdateCheck(ior.getPrevResource(), ifMatchValue);\n+\n+                try {\n+                    doRead(type, id, (patch != null), false, requestProperties, newResource);\n+                } catch (FHIRPersistenceResourceDeletedException e) {\n+                    isDeleted = true;\n+                }\n+            }\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, create the persistence event.\n+            FHIRPersistenceEvent event = new FHIRPersistenceEvent(newResource, \n+                    buildPersistenceEventProperties(type, newResource.getId(), null, requestProperties));\n+\n+            // Next, set the \"previous resource\" in the persistence event.\n+            event.setPrevFhirResource(ior.getPrevResource());\n+\n+            // Next, invoke the 'beforeUpdate' or 'beforeCreate' interceptor methods as appropriate.\n+            boolean updateCreate = (ior.getPrevResource() == null);\n+            if (updateCreate) {\n+                getInterceptorMgr().fireBeforeCreateEvent(event);\n+            } else {\n+                if (patch != null) {\n+                    event.getProperties().put(FHIRPersistenceEvent.PROPNAME_PATCH, patch);\n+                    getInterceptorMgr().fireBeforePatchEvent(event);\n+                } else {\n+                    getInterceptorMgr().fireBeforeUpdateEvent(event);\n+                }\n+            }\n+\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event);\n+            newResource = persistence.update(persistenceContext, id, newResource).getResource();\n+            event.setFhirResource(newResource); // update event with latest\n+            ior.setResource(newResource);\n+\n+            // Build our location URI and add it to the interceptor event structure since it is now known.\n+            ior.setLocationURI(FHIRUtil.buildLocationURI(ModelSupport.getTypeName(newResource.getClass()), newResource));\n+            event.getProperties().put(FHIRPersistenceEvent.PROPNAME_RESOURCE_LOCATION_URI, ior.getLocationURI().toString());\n+\n+            // Invoke the 'afterUpdate' interceptor methods.\n+            if (updateCreate) {\n+                ior.setStatus(Response.Status.CREATED);\n+                getInterceptorMgr().fireAfterCreateEvent(event);\n+            } else {\n+                ior.setStatus(Response.Status.OK);\n+                if (patch != null) {\n+                    getInterceptorMgr().fireAfterPatchEvent(event);\n+                } else {\n+                    getInterceptorMgr().fireAfterUpdateEvent(event);\n+                }\n+            }\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+\n+            // If the deleted resource is updated, then simply return 201 instead of 200 to pass Touchstone test.\n+            // We don't set the previous resource to null in above codes if the resource was deleted, otherwise\n+            // it will break the code logic of the resource versioning.\n+            if (isDeleted && ior.getStatus() == Response.Status.OK) {\n+                ior.setStatus(Response.Status.CREATED);\n+            }\n+\n+            return ior;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we still have a transaction at this point, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doPatchOrUpdate\");\n+        }\n+    }\n+\n+    /**\n+     * Performs a 'delete' operation on the specified resource.\n+     *\n+     * @param type\n+     *            the resource type associated with the Resource to be deleted\n+     * @param id\n+     *            the id of the Resource to be deleted\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return a FHIRRestOperationResponse that contains the results of the operation\n+     * @throws Exception\n+     */\n+    @Override\n+    public FHIRRestOperationResponse doDelete(String type, String id, String searchQueryString,\n+            Map<String, String> requestProperties) throws Exception {\n+        log.entering(this.getClass().getName(), \"doDelete\");\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+        Response.Status status = null;\n+\n+        FHIRRestOperationResponse ior = new FHIRRestOperationResponse();\n+\n+        try {\n+            String resourceTypeName = type;\n+            if (!ModelSupport.isResourceType(type)) {\n+                throw buildUnsupportedResourceTypeException(type, IssueType.NOT_SUPPORTED);\n+            }\n+\n+            Class<? extends Resource> resourceType =\n+                    getResourceType(resourceTypeName);\n+\n+            // Next, if a conditional delete was invoked then use the search criteria to find the\n+            // resource to be deleted. Otherwise, we'll use the id value to identify the resource\n+            // to be deleted.\n+            Resource resourceToDelete = null;\n+            if (searchQueryString != null) {\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Performing conditional delete with search criteria: \"\n+                            + Encode.forHtml(searchQueryString));\n+                }\n+                Bundle responseBundle = null;\n+                try {\n+                    MultivaluedMap<String, String> searchParameters =\n+                            getQueryParameterMap(searchQueryString);\n+                    responseBundle =\n+                            doSearch(type, null, null, searchParameters, null, requestProperties, null);\n+                } catch (FHIROperationException e) {\n+                    throw e;\n+                } catch (Throwable t) {\n+                    String msg =\n+                            \"An error occurred while performing the search for a conditional delete operation.\";\n+                    throw new FHIROperationException(msg, t);\n+                }\n+\n+                // Check the search results to determine whether or not to perform the update operation.\n+                int resultCount = responseBundle.getEntry().size();\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Conditional delete search yielded \" + resultCount + \" results.\");\n+                }\n+\n+                if (resultCount == 0) {\n+                    // Search yielded no matches\n+                    String msg = \"Search criteria for a conditional delete operation yielded no matches.\";\n+                    if (log.isLoggable(Level.FINE)) {\n+                        log.fine(msg);\n+                    }\n+                    status = Response.Status.OK;\n+                    ior.setOperationOutcome(FHIRUtil.buildOperationOutcome(msg, IssueType.NOT_FOUND, IssueSeverity.WARNING));\n+                    ior.setStatus(status);\n+                    return ior;\n+                } else if (resultCount == 1) {\n+                    // If we found a single match, then we'll delete this one.\n+                    Resource resource = responseBundle.getEntry().get(0).getResource();\n+                    id = resource.getId();\n+                    resourceToDelete = resource;\n+                } else {\n+                    String msg =\n+                            \"The search criteria specified for a conditional delete operation returned multiple matches.\";\n+                    throw buildRestException(msg, IssueType.MULTIPLE_MATCHES);\n+                }\n+            } else {\n+                // Make sure an id value was passed in.\n+                if (id == null) {\n+                    String msg = \"The 'id' parameter is required for a delete operation.\";\n+                    throw buildRestException(msg, IssueType.REQUIRED);\n+                }\n+\n+                // Read the resource so it will be available to the beforeDelete interceptor methods.\n+                try {\n+                    resourceToDelete = doRead(type, id, false, false, requestProperties, null);\n+                } catch (FHIRPersistenceResourceDeletedException e) {\n+                    // Absorb this exception.\n+                    resourceToDelete = null;\n+                }\n+            }\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, invoke the 'beforeDelete' interceptor methods.\n+            FHIRPersistenceEvent event =\n+                    new FHIRPersistenceEvent(null, buildPersistenceEventProperties(type, id, null, requestProperties));\n+            event.setFhirResource(resourceToDelete);\n+            getInterceptorMgr().fireBeforeDeleteEvent(event);\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event);\n+\n+            Resource resource = persistence.delete(persistenceContext, resourceType, id).getResource();\n+            ior.setResource(resource);\n+            event.setFhirResource(resource);\n+            ior.setStatus(Response.Status.NO_CONTENT);\n+\n+            // Invoke the 'afterDelete' interceptor methods.\n+            getInterceptorMgr().fireAfterDeleteEvent(event);\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+            status = ior.getStatus();\n+\n+            return ior;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we previously started a transaction and it's still active, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doDelete\");\n+        }\n+    }\n+\n+    @Override\n+    public Resource doRead(String type, String id, boolean throwExcOnNull, boolean includeDeleted,\n+            Map<String, String> requestProperties, Resource contextResource) throws Exception {\n+        return doRead(type, id, throwExcOnNull, includeDeleted, requestProperties, contextResource, null);\n+    }\n+\n+    /**\n+     * Performs a 'read' operation to retrieve a Resource.\n+     *\n+     * @param type\n+     *            the resource type associated with the Resource to be retrieved\n+     * @param id\n+     *            the id of the Resource to be retrieved\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return the Resource\n+     * @throws Exception\n+     */\n+    @Override\n+    public Resource doRead(String type, String id, boolean throwExcOnNull, boolean includeDeleted,\n+            Map<String, String> requestProperties, Resource contextResource, MultivaluedMap<String, String> queryParameters)\n+            throws Exception {\n+        log.entering(this.getClass().getName(), \"doRead\");\n+\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+        Resource resource = null;\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+            String resourceTypeName = type;\n+            if (!ModelSupport.isResourceType(type)) {\n+                throw buildUnsupportedResourceTypeException(type, IssueType.NOT_SUPPORTED);\n+            }\n+\n+            Class<? extends Resource> resourceType = getResourceType(resourceTypeName);\n+\n+            FHIRSearchContext searchContext = null;\n+            if (queryParameters != null) {\n+                searchContext = SearchUtil.parseQueryParameters(null, null, resourceType, queryParameters, \n+                        HTTPHandlingPreference.LENIENT.equals(requestContext.getHandlingPreference()));\n+            }\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, invoke the 'beforeRead' interceptor methods.\n+            FHIRPersistenceEvent event =\n+                    new FHIRPersistenceEvent(contextResource, buildPersistenceEventProperties(type, id, null, requestProperties));\n+            getInterceptorMgr().fireBeforeReadEvent(event);\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event, includeDeleted, searchContext);\n+            resource = persistence.read(persistenceContext, resourceType, id).getResource();\n+            if (resource == null && throwExcOnNull) {\n+                throw new FHIRPersistenceResourceNotFoundException(\"Resource '\" + type + \"/\" + id + \"' not found.\");\n+            }\n+\n+            event.setFhirResource(resource);\n+\n+            // Invoke the 'afterRead' interceptor methods.\n+            getInterceptorMgr().fireAfterReadEvent(event);\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+\n+            return resource;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we previously started a transaction and it's still active, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doRead\");\n+        }\n+    }\n+\n+    /**\n+     * Performs a 'vread' operation by retrieving the specified version of a Resource.\n+     *\n+     * @param type\n+     *            the resource type associated with the Resource to be retrieved\n+     * @param id\n+     *            the id of the Resource to be retrieved\n+     * @param versionId\n+     *            the version id of the Resource to be retrieved\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return the Resource\n+     * @throws Exception\n+     */\n+    @Override\n+    public Resource doVRead(String type, String id, String versionId,\n+        Map<String, String> requestProperties) throws Exception {\n+        log.entering(this.getClass().getName(), \"doVRead\");\n+\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+        Resource resource = null;\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+            String resourceTypeName = type;\n+            if (!ModelSupport.isResourceType(type)) {\n+                throw buildUnsupportedResourceTypeException(type, IssueType.NOT_SUPPORTED);\n+            }\n+\n+            Class<? extends Resource> resourceType =\n+                    getResourceType(resourceTypeName);\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, invoke the 'beforeVread' interceptor methods.\n+            FHIRPersistenceEvent event =\n+                    new FHIRPersistenceEvent(null, buildPersistenceEventProperties(type, id, versionId, requestProperties));\n+            getInterceptorMgr().fireBeforeVreadEvent(event);\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event);\n+            resource = persistence.vread(persistenceContext, resourceType, id, versionId).getResource();\n+            if (resource == null) {\n+                throw new FHIRPersistenceResourceNotFoundException(\"Resource '\"\n+                        + resourceType.getSimpleName() + \"/\" + id + \"' version \" + versionId + \" not found.\");\n+            }\n+\n+            event.setFhirResource(resource);\n+\n+            // Invoke the 'afterVread' interceptor methods.\n+            getInterceptorMgr().fireAfterVreadEvent(event);\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+\n+            return resource;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we previously started a transaction and it's still active, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doVRead\");\n+        }\n+    }\n+\n+    /**\n+     * Performs the work of retrieving versions of a Resource.\n+     *\n+     * @param type\n+     *            the resource type associated with the Resource to be retrieved\n+     * @param id\n+     *            the id of the Resource to be retrieved\n+     * @param queryParameters\n+     *            a Map containing the query parameters from the request URL\n+     * @param requestUri the URI from the request\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return a Bundle containing the history of the specified Resource\n+     * @throws Exception\n+     */\n+    @Override\n+    public Bundle doHistory(String type, String id, MultivaluedMap<String, String> queryParameters,\n+        String requestUri, Map<String, String> requestProperties)\n+        throws Exception {\n+        log.entering(this.getClass().getName(), \"doHistory\");\n+\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+        Bundle bundle = null;\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+            String resourceTypeName = type;\n+            if (!ModelSupport.isResourceType(type)) {\n+                throw buildUnsupportedResourceTypeException(type, IssueType.NOT_SUPPORTED);\n+            }\n+\n+            Class<? extends Resource> resourceType =\n+                    getResourceType(resourceTypeName);\n+            FHIRHistoryContext historyContext =\n+                    FHIRPersistenceUtil.parseHistoryParameters(queryParameters, HTTPHandlingPreference.LENIENT.equals(requestContext.getHandlingPreference()));\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, invoke the 'beforeHistory' interceptor methods.\n+            FHIRPersistenceEvent event =\n+                    new FHIRPersistenceEvent(null, buildPersistenceEventProperties(type, id, null, requestProperties));\n+            getInterceptorMgr().fireBeforeHistoryEvent(event);\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event, historyContext);\n+            List<? extends Resource> resources =\n+                    persistence.history(persistenceContext, resourceType, id).getResource();\n+            bundle = createHistoryBundle(resources, historyContext, type);\n+            bundle = addLinks(historyContext, bundle, requestUri);\n+\n+            event.setFhirResource(bundle);\n+\n+            // Invoke the 'afterHistory' interceptor methods.\n+            getInterceptorMgr().fireAfterHistoryEvent(event);\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+\n+            return bundle;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we previously started a transaction and it's still active, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doHistory\");\n+        }\n+    }\n+\n+    /**\n+     * Performs heavy lifting associated with a 'search' operation.\n+     *\n+     * @param type\n+     *            the resource type associated with the search\n+     * @param queryParameters\n+     *            a Map containing the query parameters from the request URL\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return a Bundle containing the search result set\n+     * @throws Exception\n+     */\n+    @Override\n+    public Bundle doSearch(String type, String compartment, String compartmentId,\n+            MultivaluedMap<String, String> queryParameters, String requestUri,\n+            Map<String, String> requestProperties, Resource contextResource) throws Exception {\n+        log.entering(this.getClass().getName(), \"doSearch\");\n+\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+        Bundle bundle = null;\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+            String resourceTypeName = type;\n+\n+            // Check to see if it's supported, else, throw a bad request.\n+            // If this is removed, it'll result in nullpointer when processing the request\n+            if (!ModelSupport.isResourceType(type)) {\n+                throw buildUnsupportedResourceTypeException(type, IssueType.NOT_SUPPORTED);\n+            }\n+\n+            Class<? extends Resource> resourceType =\n+                    getResourceType(resourceTypeName);\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, invoke the 'beforeSearch' interceptor methods.\n+            FHIRPersistenceEvent event =\n+                    new FHIRPersistenceEvent(contextResource, buildPersistenceEventProperties(type, null, null, requestProperties));\n+            getInterceptorMgr().fireBeforeSearchEvent(event);\n+\n+            FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(compartment, compartmentId, resourceType, queryParameters,\n+                    HTTPHandlingPreference.LENIENT.equals(requestContext.getHandlingPreference()));\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event, searchContext);\n+            List<Resource> resources =\n+                    persistence.search(persistenceContext, resourceType).getResource();\n+\n+            bundle = createSearchBundle(resources, searchContext, type);\n+            if (requestUri != null) {\n+                bundle = addLinks(searchContext, bundle, requestUri);\n+            }\n+            event.setFhirResource(bundle);\n+\n+            // Invoke the 'afterSearch' interceptor methods.\n+            getInterceptorMgr().fireAfterSearchEvent(event);\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+\n+            return bundle;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we previously started a transaction and it's still active, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doSearch\");\n+        }\n+    }\n+\n+    /**\n+     * Helper method which invokes a custom operation.\n+     *\n+     * @param operationContext\n+     *            the FHIROperationContext associated with the request\n+     * @param resourceTypeName\n+     *            the resource type associated with the request\n+     * @param logicalId\n+     *            the resource logical id associated with the request\n+     * @param versionId\n+     *            the resource version id associated with the request\n+     * @param operationName\n+     *            the name of the custom operation to be invoked\n+     * @param resource\n+     *            the input resource associated with the custom operation to be invoked\n+     * @param queryParameters\n+     *            query parameters may be passed instead of a Parameters resource for certain custom operations invoked\n+     *            via GET\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return a Resource that represents the response to the custom operation\n+     * @throws Exception\n+     */\n+    @Override\n+    public Resource doInvoke(FHIROperationContext operationContext, String resourceTypeName,\n+            String logicalId, String versionId, String operationName,\n+            Resource resource, MultivaluedMap<String, String> queryParameters,\n+            Map<String, String> requestProperties) throws Exception {\n+        log.entering(this.getClass().getName(), \"doInvoke\");\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+            Class<? extends Resource> resourceType = null;\n+            if (resourceTypeName != null) {\n+                resourceType = getResourceType(resourceTypeName);\n+            }\n+            String operationKey = (resourceTypeName == null ? operationName : operationName + \":\" + resourceTypeName);\n+\n+            FHIROperation operation =\n+                    FHIROperationRegistry.getInstance().getOperation(operationKey);\n+            Parameters parameters = null;\n+            if (resource instanceof Parameters) {\n+                parameters = (Parameters) resource;\n+            } else {\n+                if (resource == null) {\n+                    // build parameters object from query parameters\n+                    parameters =\n+                            FHIROperationUtil.getInputParameters(operation.getDefinition(), queryParameters);\n+                } else {\n+                    // wrap resource in a parameters object\n+                    parameters =\n+                            FHIROperationUtil.getInputParameters(operation.getDefinition(), resource);\n+                }\n+            }\n+\n+            // Add properties to the FHIR operation context\n+            setOperationContextProperties(operationContext, resourceTypeName, requestProperties);\n+\n+            if (log.isLoggable(Level.FINE)) {\n+                log.fine(\"Invoking operation '\" + operationName + \"', context=\\n\"\n+                        + operationContext.toString());\n+            }\n+            Parameters result =\n+                    operation.invoke(operationContext, resourceType, logicalId, versionId, parameters, this);\n+            if (log.isLoggable(Level.FINE)) {\n+                log.fine(\"Returned from invocation of operation '\" + operationName + \"'...\");\n+            }\n+\n+            // if single resource output parameter, return the resource\n+            if (FHIROperationUtil.hasSingleResourceOutputParameter(result)) {\n+                return FHIROperationUtil.getSingleResourceOutputParameter(result);\n+            }\n+\n+            return result;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            log.exiting(this.getClass().getName(), \"doInvoke\");\n+        }\n+    }\n+\n+    /**\n+     * Processes a bundled request.\n+     *\n+     * @param bundleResource\n+     *            the request Bundle\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return the response Bundle\n+     */\n+    @Override\n+    public Bundle doBundle(Resource bundleResource, Map<String, String> requestProperties)\n+        throws Exception {\n+        log.entering(this.getClass().getName(), \"doBundle\");\n+        Bundle inputBundle = null;\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+            if (bundleResource instanceof Bundle) {\n+                inputBundle = (Bundle) bundleResource;\n+            } else {\n+                String msg = \"A 'Bundle' resource type is required but a '\"\n+                        + bundleResource.getClass().getSimpleName() + \"' resource type was sent.\";\n+                throw buildRestException(msg, IssueType.INVALID);\n+            }\n+            // First, validate the bundle and create the response bundle.\n+            Bundle responseBundle = validateBundle(inputBundle);\n+\n+            // Next, process each of the entries in the bundle.\n+            responseBundle = processBundleEntries(inputBundle, responseBundle, requestProperties);\n+\n+            return responseBundle;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            log.exiting(this.getClass().getName(), \"doBundle\");\n+        }\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * @see com.ibm.fhir.rest.FHIRResourceHelpers#getTransaction()\n+     */\n+    @Override\n+    public FHIRPersistenceTransaction getTransaction() throws Exception {\n+        return persistence.getTransaction();\n+    }\n+\n+    /**\n+     * Validate the input resource and throw if there are validation errors\n+     *\n+     * @param resource\n+     * @throws FHIRValidationException\n+     * @throws FHIROperationException\n+     */\n+    private List<OperationOutcome.Issue> validateInput(Resource resource)\n+            throws FHIRValidationException, FHIROperationException {\n+        List<OperationOutcome.Issue> issues = FHIRValidator.validator().validate(resource);\n+        if (!issues.isEmpty()) {\n+            boolean includesFailure = false;\n+            for (OperationOutcome.Issue issue : issues) {\n+                if (FHIRUtil.isFailure(issue.getSeverity())) {\n+                    includesFailure = true;\n+                }\n+            }\n+\n+            if (includesFailure) {\n+                throw new FHIROperationException(\"Input resource failed validation.\").withIssue(issues);\n+            } else {\n+                if (log.isLoggable(Level.FINE)) {\n+                    String info = issues.stream()\n+                                .flatMap(issue -> Stream.of(issue.getDetails()))\n+                                .flatMap(details -> Stream.of(details.getText()))\n+                                .flatMap(text -> Stream.of(text.getValue()))\n+                                .collect(Collectors.joining(\", \"));\n+                    log.fine(\"Validation warnings for input resource: \" + info);\n+                }\n+            }\n+        }\n+        return issues;\n+    }\n+\n+    /**\n+     * @param issues\n+     * @return\n+     */\n+    private boolean anyFailureInIssues(List<OperationOutcome.Issue> issues) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIzODI0NA=="}, "originalCommit": {"oid": "d0ff4daa4297bea3aff6025eac16697c3fe6ecb1"}, "originalPosition": 1085}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgxNDc5Nw==", "bodyText": "I didn't do this...but I can.  Should we do it now or accept this PR without it?", "url": "https://github.com/IBM/FHIR/pull/759#discussion_r389814797", "createdAt": "2020-03-09T16:40:14Z", "author": {"login": "lmsurpre"}, "path": "fhir-server/src/main/java/com/ibm/fhir/server/resources/FHIRRestHelper.java", "diffHunk": "@@ -0,0 +1,2448 @@\n+/*\n+ * (C) Copyright IBM Corp. 2016, 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.server.resources;\n+\n+import static com.ibm.fhir.model.type.String.string;\n+import static com.ibm.fhir.model.util.ModelSupport.getResourceType;\n+import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;\n+import static javax.servlet.http.HttpServletResponse.SC_GONE;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static javax.servlet.http.HttpServletResponse.SC_OK;\n+\n+import java.net.URI;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeFormatterBuilder;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.Status;\n+\n+import org.owasp.encoder.Encode;\n+\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.core.HTTPHandlingPreference;\n+import com.ibm.fhir.core.HTTPReturnPreference;\n+import com.ibm.fhir.core.context.FHIRPagingContext;\n+import com.ibm.fhir.exception.FHIROperationException;\n+import com.ibm.fhir.model.patch.FHIRPatch;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.OperationOutcome;\n+import com.ibm.fhir.model.resource.OperationOutcome.Issue;\n+import com.ibm.fhir.model.resource.Parameters;\n+import com.ibm.fhir.model.resource.Resource;\n+import com.ibm.fhir.model.type.CodeableConcept;\n+import com.ibm.fhir.model.type.Extension;\n+import com.ibm.fhir.model.type.UnsignedInt;\n+import com.ibm.fhir.model.type.Uri;\n+import com.ibm.fhir.model.type.Url;\n+import com.ibm.fhir.model.type.code.BundleType;\n+import com.ibm.fhir.model.type.code.HTTPVerb;\n+import com.ibm.fhir.model.type.code.IssueSeverity;\n+import com.ibm.fhir.model.type.code.IssueType;\n+import com.ibm.fhir.model.util.FHIRUtil;\n+import com.ibm.fhir.model.util.ModelSupport;\n+import com.ibm.fhir.model.util.ReferenceMappingVisitor;\n+import com.ibm.fhir.operation.FHIROperation;\n+import com.ibm.fhir.operation.context.FHIROperationContext;\n+import com.ibm.fhir.operation.registry.FHIROperationRegistry;\n+import com.ibm.fhir.operation.util.FHIROperationUtil;\n+import com.ibm.fhir.persistence.FHIRPersistence;\n+import com.ibm.fhir.persistence.FHIRPersistenceTransaction;\n+import com.ibm.fhir.persistence.context.FHIRHistoryContext;\n+import com.ibm.fhir.persistence.context.FHIRPersistenceContext;\n+import com.ibm.fhir.persistence.context.FHIRPersistenceContextFactory;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceResourceDeletedException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceResourceNotFoundException;\n+import com.ibm.fhir.persistence.helper.FHIRTransactionHelper;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceEvent;\n+import com.ibm.fhir.persistence.interceptor.impl.FHIRPersistenceInterceptorMgr;\n+import com.ibm.fhir.persistence.util.FHIRPersistenceUtil;\n+import com.ibm.fhir.rest.FHIRResourceHelpers;\n+import com.ibm.fhir.rest.FHIRRestOperationResponse;\n+import com.ibm.fhir.search.SearchConstants;\n+import com.ibm.fhir.search.SummaryValueSet;\n+import com.ibm.fhir.search.context.FHIRSearchContext;\n+import com.ibm.fhir.search.exception.FHIRSearchException;\n+import com.ibm.fhir.search.util.SearchUtil;\n+import com.ibm.fhir.server.exception.FHIRRestBundledRequestException;\n+import com.ibm.fhir.server.helper.FHIRUrlParser;\n+import com.ibm.fhir.server.util.IssueTypeToHttpStatusMapper;\n+import com.ibm.fhir.validation.FHIRValidator;\n+import com.ibm.fhir.validation.exception.FHIRValidationException;\n+\n+public class FHIRRestHelper implements FHIRResourceHelpers {\n+    private static final Logger log =\n+            java.util.logging.Logger.getLogger(FHIRRestHelper.class.getName());\n+\n+    private static final String EXTENSION_URL = \"http://ibm.com/fhir/extension\";\n+    private static final String LOCAL_REF_PREFIX = \"urn:\";\n+\n+    public static final DateTimeFormatter PARSER_FORMATTER = new DateTimeFormatterBuilder()\n+            .appendPattern(\"EEE\")\n+            .optionalStart()\n+            // ANSIC date time format for If-Modified-Since\n+            .appendPattern(\" MMM dd HH:mm:ss yyyy\")\n+            .optionalEnd()\n+            .optionalStart()\n+            // Touchstone date time format for If-Modified-Since\n+            .appendPattern(\", dd-MMM-yy HH:mm:ss\")\n+            .optionalEnd().toFormatter();\n+\n+    private FHIRPersistence persistence = null;\n+\n+    // These values are used for correlating requests within a bundle.\n+    private String bundleTransactionCorrelationId = null;\n+    private String bundleRequestCorrelationId = null;\n+\n+    public FHIRRestHelper(FHIRPersistence persistence) {\n+        this.persistence = persistence;\n+    }\n+\n+    /**\n+     * Performs the heavy lifting associated with a 'create' interaction.\n+     *\n+     * @param type\n+     *            the resource type specified as part of the request URL\n+     * @param resource\n+     *            the Resource to be stored.\n+     * @param ifNoneExist\n+     *            whether to create the resource if none exists\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return a FHIRRestOperationResponse object containing the results of the operation\n+     * @throws Exception\n+     */\n+    @Override\n+    public FHIRRestOperationResponse doCreate(String type, Resource resource, String ifNoneExist,\n+            Map<String, String> requestProperties) throws Exception {\n+        log.entering(this.getClass().getName(), \"doCreate\");\n+\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+        FHIRRestOperationResponse ior = new FHIRRestOperationResponse();\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+\n+            // Make sure the expected type (specified in the URL string) is congruent with the actual type\n+            // of the resource.\n+            String resourceType = ModelSupport.getTypeName(resource.getClass()); \n+            if (!resourceType.equals(type)) {\n+                String msg = \"Resource type '\" + resourceType\n+                        + \"' does not match type specified in request URI: \" + type;\n+                throw buildRestException(msg, IssueType.INVALID);\n+            }\n+\n+            // Check to see if we're supposed to perform a conditional 'create'.\n+            if (ifNoneExist != null && !ifNoneExist.isEmpty()) {\n+                log.fine(\"Performing conditional create with search criteria: \" + ifNoneExist);\n+                Bundle responseBundle = null;\n+\n+                // Perform the search using the \"If-None-Exist\" header value.\n+                try {\n+                    MultivaluedMap<String, String> searchParameters = getQueryParameterMap(ifNoneExist);\n+                    responseBundle =\n+                            doSearch(type, null, null, searchParameters, null, requestProperties, resource);\n+                } catch (FHIROperationException e) {\n+                    throw e;\n+                } catch (Throwable t) {\n+                    String msg =\n+                            \"An error occurred while performing the search for a conditional create operation.\";\n+                    log.log(Level.WARNING, msg, t);\n+                    throw new FHIROperationException(msg, t);\n+                }\n+\n+                // Check the search results to determine whether or not to perform the create operation.\n+                int resultCount = responseBundle.getEntry().size();\n+                log.fine(\"Conditional create search yielded \" + resultCount + \" results.\");\n+\n+                if (resultCount == 0) {\n+                    // Do nothing and fall through to process the 'create' request.\n+                } else if (resultCount == 1) {\n+                    // If we found a single match, bypass the 'create' request and return information\n+                    // for the matched resource.\n+                    Resource matchedResource = responseBundle.getEntry().get(0).getResource();\n+                    ior.setLocationURI(FHIRUtil.buildLocationURI(type, matchedResource));\n+                    ior.setStatus(Response.Status.OK);\n+                    ior.setResource(matchedResource);\n+                    log.fine(\"Returning location URI of matched resource: \" + ior.getLocationURI());\n+                    return ior;\n+                } else {\n+                    String msg =\n+                            \"The search criteria specified for a conditional create operation returned multiple matches.\";\n+                    throw buildRestException(msg, IssueType.MULTIPLE_MATCHES);\n+                }\n+            }\n+\n+            // For R4, resources may contain an id. For create, this should be ignored and\n+            // we no longer reject the request.\n+            if (resource.getId() != null && log.isLoggable(Level.FINE)) {\n+                log.fine(String.format(\"create request resource includes id: '%s'\", resource.getId()));\n+            }\n+\n+            // Validate the input resource and return any validation errors, but warnings are OK\n+            List<Issue> validationWarnings = validateInput(resource);\n+            ior.setOperationOutcome(FHIRUtil.buildOperationOutcome(validationWarnings));\n+\n+            // If there were no validation errors, then create the resource and return the location header.\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, invoke the 'beforeCreate' interceptor methods.\n+            FHIRPersistenceEvent event =\n+                    new FHIRPersistenceEvent(resource, buildPersistenceEventProperties(type, null, null, requestProperties));\n+            getInterceptorMgr().fireBeforeCreateEvent(event);\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event);\n+\n+            // R4: remember model objects are immutable, so we get back a new resource with the id/meta stuff\n+            resource = persistence.create(persistenceContext, resource).getResource();\n+            event.setFhirResource(resource); // update event with latest\n+            ior.setStatus(Response.Status.CREATED);\n+            ior.setResource(resource);\n+\n+            // Build our location URI and add it to the interceptor event structure since it is now known.\n+            ior.setLocationURI(FHIRUtil.buildLocationURI(ModelSupport.getTypeName(resource.getClass()), resource));\n+            event.getProperties().put(FHIRPersistenceEvent.PROPNAME_RESOURCE_LOCATION_URI, ior.getLocationURI().toString());\n+\n+            // Invoke the 'afterCreate' interceptor methods.\n+            getInterceptorMgr().fireAfterCreateEvent(event);\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+\n+            return ior;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we previously started a transaction and it's still active, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doCreate\");\n+        }\n+    }\n+\n+    @Override\n+    public FHIRRestOperationResponse doPatch(String type, String id, FHIRPatch patch, String ifMatchValue,\n+            String searchQueryString, Map<String, String> requestProperties) throws Exception {\n+\n+        return doPatchOrUpdate(type, id, patch, null, ifMatchValue, searchQueryString, requestProperties);\n+    }\n+\n+    @Override\n+    public FHIRRestOperationResponse doUpdate(String type, String id, Resource newResource, String ifMatchValue,\n+            String searchQueryString, Map<String, String> requestProperties) throws Exception {\n+\n+        return doPatchOrUpdate(type, id, null, newResource, ifMatchValue, searchQueryString, requestProperties);\n+    }\n+\n+    private FHIRRestOperationResponse doPatchOrUpdate(String type, String id, FHIRPatch patch,\n+            Resource newResource, String ifMatchValue, String searchQueryString,\n+            Map<String, String> requestProperties) throws Exception {\n+        log.entering(this.getClass().getName(), \"doPatchOrUpdate\");\n+\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        FHIRRestOperationResponse ior = new FHIRRestOperationResponse();\n+\n+        try {\n+            // Make sure the type specified in the URL string matches the resource type obtained from the new resource.\n+            if (patch == null) {\n+                String resourceType =  ModelSupport.getTypeName(newResource.getClass());\n+                if (!resourceType.equals(type)) {\n+                    String msg = \"Resource type '\" + resourceType\n+                            + \"' does not match type specified in request URI: \" + type;\n+                    throw buildRestException(msg, IssueType.INVALID);\n+                }\n+            }\n+\n+            // Next, if a conditional update was invoked then use the search criteria to find the\n+            // resource to be updated. Otherwise, we'll use the id value to retrieve the current\n+            // version of the resource.\n+            if (searchQueryString != null) {\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Performing conditional update/patch with search criteria: \"\n+                            + Encode.forHtml(searchQueryString));\n+                }\n+                Bundle responseBundle = null;\n+                try {\n+                    MultivaluedMap<String, String> searchParameters =\n+                            getQueryParameterMap(searchQueryString);\n+                    responseBundle =\n+                            doSearch(type, null, null, searchParameters, null, requestProperties, newResource);\n+                } catch (FHIROperationException e) {\n+                    throw e;\n+                } catch (Throwable t) {\n+                    String msg =\n+                            \"An error occurred while performing the search for a conditional update/patch operation.\";\n+                    throw new FHIROperationException(msg, t);\n+                }\n+\n+                // Check the search results to determine whether or not to perform the update operation.\n+                int resultCount = responseBundle.getEntry().size();\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Conditional update/patch search yielded \" + resultCount + \" results.\");\n+                }\n+\n+                if (resultCount == 0) {\n+                    if (patch != null) {\n+                        String msg =\n+                                \"The search criteria specified for a conditional patch operation did not return any results.\";\n+                        throw buildRestException(msg, IssueType.NOT_FOUND);\n+                    }\n+                    // Search yielded no matches, so we'll do an update/create operation below.\n+                    ior.setPrevResource(null);\n+\n+                    // if no id provided, then generate an id for the input resource\n+                    if (newResource.getId() == null || newResource.getId() == null) {\n+                        id = UUID.randomUUID().toString();\n+                        newResource = newResource.toBuilder().id(id).build();\n+                    } else {\n+                        id = newResource.getId();\n+                    }\n+                } else if (resultCount == 1) {\n+                    // If we found a single match, then we'll perform a normal update on the matched resource.\n+                    ior.setPrevResource(responseBundle.getEntry().get(0).getResource());\n+                    id = ior.getPrevResource().getId();\n+\n+                    // If the id of the input resource is different from the id of the search result,\n+                    // then throw exception.\n+                    if (newResource.getId() != null && newResource.getId() != null\n+                            && !newResource.getId().equalsIgnoreCase(id)) {\n+                        String msg = \"Input resource 'id' attribute must match the id of the search result resource.\";\n+                        throw buildRestException(msg, IssueType.VALUE);\n+                    }\n+                    // Make sure the id of the newResource is not null and is the same as the id of the found resource.\n+                    newResource = newResource.toBuilder().id(id).build();\n+                } else {\n+                    String msg =\n+                            \"The search criteria specified for a conditional update/patch operation returned multiple matches.\";\n+                    throw buildRestException(msg, IssueType.MULTIPLE_MATCHES);\n+                }\n+            } else {\n+                // Make sure an id value was passed in.\n+                if (id == null) {\n+                    String msg = \"The 'id' parameter is required for an update/pach operation.\";\n+                    throw buildRestException(msg, IssueType.REQUIRED);\n+                }\n+\n+                // If an id value was passed in (i.e. the id specified in the REST API URL string),\n+                // then make sure it's the same as the value in the resource.\n+                if (patch == null) {\n+                    // Make sure the resource has an 'id' attribute.\n+                    if (newResource.getId() == null) {\n+                        String msg = \"Input resource must contain an 'id' attribute.\";\n+                        throw buildRestException(msg, IssueType.INVALID);\n+                    }\n+\n+                    if (!newResource.getId().equals(id)) {\n+                        String msg = \"Input resource 'id' attribute must match 'id' parameter.\";\n+                        throw buildRestException(msg, IssueType.VALUE);\n+                    }\n+                }\n+\n+                // Retrieve the resource to be updated using the type and id values.\n+                ior.setPrevResource(doRead(type, id, (patch != null), true, requestProperties, newResource));\n+            }\n+\n+            if (patch != null) {\n+                newResource = patch.apply(ior.getPrevResource());\n+            }\n+\n+            // Validate the input resource and return any validation errors.\n+            List<Issue> validationWarnings = validateInput(newResource);\n+            ior.setOperationOutcome(FHIRUtil.buildOperationOutcome(validationWarnings));\n+\n+            // Perform the \"version-aware\" update check, and also find out if the resource was deleted.\n+            boolean isDeleted = false;\n+            if (ior.getPrevResource() != null) {\n+                performVersionAwareUpdateCheck(ior.getPrevResource(), ifMatchValue);\n+\n+                try {\n+                    doRead(type, id, (patch != null), false, requestProperties, newResource);\n+                } catch (FHIRPersistenceResourceDeletedException e) {\n+                    isDeleted = true;\n+                }\n+            }\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, create the persistence event.\n+            FHIRPersistenceEvent event = new FHIRPersistenceEvent(newResource, \n+                    buildPersistenceEventProperties(type, newResource.getId(), null, requestProperties));\n+\n+            // Next, set the \"previous resource\" in the persistence event.\n+            event.setPrevFhirResource(ior.getPrevResource());\n+\n+            // Next, invoke the 'beforeUpdate' or 'beforeCreate' interceptor methods as appropriate.\n+            boolean updateCreate = (ior.getPrevResource() == null);\n+            if (updateCreate) {\n+                getInterceptorMgr().fireBeforeCreateEvent(event);\n+            } else {\n+                if (patch != null) {\n+                    event.getProperties().put(FHIRPersistenceEvent.PROPNAME_PATCH, patch);\n+                    getInterceptorMgr().fireBeforePatchEvent(event);\n+                } else {\n+                    getInterceptorMgr().fireBeforeUpdateEvent(event);\n+                }\n+            }\n+\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event);\n+            newResource = persistence.update(persistenceContext, id, newResource).getResource();\n+            event.setFhirResource(newResource); // update event with latest\n+            ior.setResource(newResource);\n+\n+            // Build our location URI and add it to the interceptor event structure since it is now known.\n+            ior.setLocationURI(FHIRUtil.buildLocationURI(ModelSupport.getTypeName(newResource.getClass()), newResource));\n+            event.getProperties().put(FHIRPersistenceEvent.PROPNAME_RESOURCE_LOCATION_URI, ior.getLocationURI().toString());\n+\n+            // Invoke the 'afterUpdate' interceptor methods.\n+            if (updateCreate) {\n+                ior.setStatus(Response.Status.CREATED);\n+                getInterceptorMgr().fireAfterCreateEvent(event);\n+            } else {\n+                ior.setStatus(Response.Status.OK);\n+                if (patch != null) {\n+                    getInterceptorMgr().fireAfterPatchEvent(event);\n+                } else {\n+                    getInterceptorMgr().fireAfterUpdateEvent(event);\n+                }\n+            }\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+\n+            // If the deleted resource is updated, then simply return 201 instead of 200 to pass Touchstone test.\n+            // We don't set the previous resource to null in above codes if the resource was deleted, otherwise\n+            // it will break the code logic of the resource versioning.\n+            if (isDeleted && ior.getStatus() == Response.Status.OK) {\n+                ior.setStatus(Response.Status.CREATED);\n+            }\n+\n+            return ior;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we still have a transaction at this point, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doPatchOrUpdate\");\n+        }\n+    }\n+\n+    /**\n+     * Performs a 'delete' operation on the specified resource.\n+     *\n+     * @param type\n+     *            the resource type associated with the Resource to be deleted\n+     * @param id\n+     *            the id of the Resource to be deleted\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return a FHIRRestOperationResponse that contains the results of the operation\n+     * @throws Exception\n+     */\n+    @Override\n+    public FHIRRestOperationResponse doDelete(String type, String id, String searchQueryString,\n+            Map<String, String> requestProperties) throws Exception {\n+        log.entering(this.getClass().getName(), \"doDelete\");\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+        Response.Status status = null;\n+\n+        FHIRRestOperationResponse ior = new FHIRRestOperationResponse();\n+\n+        try {\n+            String resourceTypeName = type;\n+            if (!ModelSupport.isResourceType(type)) {\n+                throw buildUnsupportedResourceTypeException(type, IssueType.NOT_SUPPORTED);\n+            }\n+\n+            Class<? extends Resource> resourceType =\n+                    getResourceType(resourceTypeName);\n+\n+            // Next, if a conditional delete was invoked then use the search criteria to find the\n+            // resource to be deleted. Otherwise, we'll use the id value to identify the resource\n+            // to be deleted.\n+            Resource resourceToDelete = null;\n+            if (searchQueryString != null) {\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Performing conditional delete with search criteria: \"\n+                            + Encode.forHtml(searchQueryString));\n+                }\n+                Bundle responseBundle = null;\n+                try {\n+                    MultivaluedMap<String, String> searchParameters =\n+                            getQueryParameterMap(searchQueryString);\n+                    responseBundle =\n+                            doSearch(type, null, null, searchParameters, null, requestProperties, null);\n+                } catch (FHIROperationException e) {\n+                    throw e;\n+                } catch (Throwable t) {\n+                    String msg =\n+                            \"An error occurred while performing the search for a conditional delete operation.\";\n+                    throw new FHIROperationException(msg, t);\n+                }\n+\n+                // Check the search results to determine whether or not to perform the update operation.\n+                int resultCount = responseBundle.getEntry().size();\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Conditional delete search yielded \" + resultCount + \" results.\");\n+                }\n+\n+                if (resultCount == 0) {\n+                    // Search yielded no matches\n+                    String msg = \"Search criteria for a conditional delete operation yielded no matches.\";\n+                    if (log.isLoggable(Level.FINE)) {\n+                        log.fine(msg);\n+                    }\n+                    status = Response.Status.OK;\n+                    ior.setOperationOutcome(FHIRUtil.buildOperationOutcome(msg, IssueType.NOT_FOUND, IssueSeverity.WARNING));\n+                    ior.setStatus(status);\n+                    return ior;\n+                } else if (resultCount == 1) {\n+                    // If we found a single match, then we'll delete this one.\n+                    Resource resource = responseBundle.getEntry().get(0).getResource();\n+                    id = resource.getId();\n+                    resourceToDelete = resource;\n+                } else {\n+                    String msg =\n+                            \"The search criteria specified for a conditional delete operation returned multiple matches.\";\n+                    throw buildRestException(msg, IssueType.MULTIPLE_MATCHES);\n+                }\n+            } else {\n+                // Make sure an id value was passed in.\n+                if (id == null) {\n+                    String msg = \"The 'id' parameter is required for a delete operation.\";\n+                    throw buildRestException(msg, IssueType.REQUIRED);\n+                }\n+\n+                // Read the resource so it will be available to the beforeDelete interceptor methods.\n+                try {\n+                    resourceToDelete = doRead(type, id, false, false, requestProperties, null);\n+                } catch (FHIRPersistenceResourceDeletedException e) {\n+                    // Absorb this exception.\n+                    resourceToDelete = null;\n+                }\n+            }\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, invoke the 'beforeDelete' interceptor methods.\n+            FHIRPersistenceEvent event =\n+                    new FHIRPersistenceEvent(null, buildPersistenceEventProperties(type, id, null, requestProperties));\n+            event.setFhirResource(resourceToDelete);\n+            getInterceptorMgr().fireBeforeDeleteEvent(event);\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event);\n+\n+            Resource resource = persistence.delete(persistenceContext, resourceType, id).getResource();\n+            ior.setResource(resource);\n+            event.setFhirResource(resource);\n+            ior.setStatus(Response.Status.NO_CONTENT);\n+\n+            // Invoke the 'afterDelete' interceptor methods.\n+            getInterceptorMgr().fireAfterDeleteEvent(event);\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+            status = ior.getStatus();\n+\n+            return ior;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we previously started a transaction and it's still active, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doDelete\");\n+        }\n+    }\n+\n+    @Override\n+    public Resource doRead(String type, String id, boolean throwExcOnNull, boolean includeDeleted,\n+            Map<String, String> requestProperties, Resource contextResource) throws Exception {\n+        return doRead(type, id, throwExcOnNull, includeDeleted, requestProperties, contextResource, null);\n+    }\n+\n+    /**\n+     * Performs a 'read' operation to retrieve a Resource.\n+     *\n+     * @param type\n+     *            the resource type associated with the Resource to be retrieved\n+     * @param id\n+     *            the id of the Resource to be retrieved\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return the Resource\n+     * @throws Exception\n+     */\n+    @Override\n+    public Resource doRead(String type, String id, boolean throwExcOnNull, boolean includeDeleted,\n+            Map<String, String> requestProperties, Resource contextResource, MultivaluedMap<String, String> queryParameters)\n+            throws Exception {\n+        log.entering(this.getClass().getName(), \"doRead\");\n+\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+        Resource resource = null;\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+            String resourceTypeName = type;\n+            if (!ModelSupport.isResourceType(type)) {\n+                throw buildUnsupportedResourceTypeException(type, IssueType.NOT_SUPPORTED);\n+            }\n+\n+            Class<? extends Resource> resourceType = getResourceType(resourceTypeName);\n+\n+            FHIRSearchContext searchContext = null;\n+            if (queryParameters != null) {\n+                searchContext = SearchUtil.parseQueryParameters(null, null, resourceType, queryParameters, \n+                        HTTPHandlingPreference.LENIENT.equals(requestContext.getHandlingPreference()));\n+            }\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, invoke the 'beforeRead' interceptor methods.\n+            FHIRPersistenceEvent event =\n+                    new FHIRPersistenceEvent(contextResource, buildPersistenceEventProperties(type, id, null, requestProperties));\n+            getInterceptorMgr().fireBeforeReadEvent(event);\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event, includeDeleted, searchContext);\n+            resource = persistence.read(persistenceContext, resourceType, id).getResource();\n+            if (resource == null && throwExcOnNull) {\n+                throw new FHIRPersistenceResourceNotFoundException(\"Resource '\" + type + \"/\" + id + \"' not found.\");\n+            }\n+\n+            event.setFhirResource(resource);\n+\n+            // Invoke the 'afterRead' interceptor methods.\n+            getInterceptorMgr().fireAfterReadEvent(event);\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+\n+            return resource;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we previously started a transaction and it's still active, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doRead\");\n+        }\n+    }\n+\n+    /**\n+     * Performs a 'vread' operation by retrieving the specified version of a Resource.\n+     *\n+     * @param type\n+     *            the resource type associated with the Resource to be retrieved\n+     * @param id\n+     *            the id of the Resource to be retrieved\n+     * @param versionId\n+     *            the version id of the Resource to be retrieved\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return the Resource\n+     * @throws Exception\n+     */\n+    @Override\n+    public Resource doVRead(String type, String id, String versionId,\n+        Map<String, String> requestProperties) throws Exception {\n+        log.entering(this.getClass().getName(), \"doVRead\");\n+\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+        Resource resource = null;\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+            String resourceTypeName = type;\n+            if (!ModelSupport.isResourceType(type)) {\n+                throw buildUnsupportedResourceTypeException(type, IssueType.NOT_SUPPORTED);\n+            }\n+\n+            Class<? extends Resource> resourceType =\n+                    getResourceType(resourceTypeName);\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, invoke the 'beforeVread' interceptor methods.\n+            FHIRPersistenceEvent event =\n+                    new FHIRPersistenceEvent(null, buildPersistenceEventProperties(type, id, versionId, requestProperties));\n+            getInterceptorMgr().fireBeforeVreadEvent(event);\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event);\n+            resource = persistence.vread(persistenceContext, resourceType, id, versionId).getResource();\n+            if (resource == null) {\n+                throw new FHIRPersistenceResourceNotFoundException(\"Resource '\"\n+                        + resourceType.getSimpleName() + \"/\" + id + \"' version \" + versionId + \" not found.\");\n+            }\n+\n+            event.setFhirResource(resource);\n+\n+            // Invoke the 'afterVread' interceptor methods.\n+            getInterceptorMgr().fireAfterVreadEvent(event);\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+\n+            return resource;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we previously started a transaction and it's still active, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doVRead\");\n+        }\n+    }\n+\n+    /**\n+     * Performs the work of retrieving versions of a Resource.\n+     *\n+     * @param type\n+     *            the resource type associated with the Resource to be retrieved\n+     * @param id\n+     *            the id of the Resource to be retrieved\n+     * @param queryParameters\n+     *            a Map containing the query parameters from the request URL\n+     * @param requestUri the URI from the request\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return a Bundle containing the history of the specified Resource\n+     * @throws Exception\n+     */\n+    @Override\n+    public Bundle doHistory(String type, String id, MultivaluedMap<String, String> queryParameters,\n+        String requestUri, Map<String, String> requestProperties)\n+        throws Exception {\n+        log.entering(this.getClass().getName(), \"doHistory\");\n+\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+        Bundle bundle = null;\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+            String resourceTypeName = type;\n+            if (!ModelSupport.isResourceType(type)) {\n+                throw buildUnsupportedResourceTypeException(type, IssueType.NOT_SUPPORTED);\n+            }\n+\n+            Class<? extends Resource> resourceType =\n+                    getResourceType(resourceTypeName);\n+            FHIRHistoryContext historyContext =\n+                    FHIRPersistenceUtil.parseHistoryParameters(queryParameters, HTTPHandlingPreference.LENIENT.equals(requestContext.getHandlingPreference()));\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, invoke the 'beforeHistory' interceptor methods.\n+            FHIRPersistenceEvent event =\n+                    new FHIRPersistenceEvent(null, buildPersistenceEventProperties(type, id, null, requestProperties));\n+            getInterceptorMgr().fireBeforeHistoryEvent(event);\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event, historyContext);\n+            List<? extends Resource> resources =\n+                    persistence.history(persistenceContext, resourceType, id).getResource();\n+            bundle = createHistoryBundle(resources, historyContext, type);\n+            bundle = addLinks(historyContext, bundle, requestUri);\n+\n+            event.setFhirResource(bundle);\n+\n+            // Invoke the 'afterHistory' interceptor methods.\n+            getInterceptorMgr().fireAfterHistoryEvent(event);\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+\n+            return bundle;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we previously started a transaction and it's still active, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doHistory\");\n+        }\n+    }\n+\n+    /**\n+     * Performs heavy lifting associated with a 'search' operation.\n+     *\n+     * @param type\n+     *            the resource type associated with the search\n+     * @param queryParameters\n+     *            a Map containing the query parameters from the request URL\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return a Bundle containing the search result set\n+     * @throws Exception\n+     */\n+    @Override\n+    public Bundle doSearch(String type, String compartment, String compartmentId,\n+            MultivaluedMap<String, String> queryParameters, String requestUri,\n+            Map<String, String> requestProperties, Resource contextResource) throws Exception {\n+        log.entering(this.getClass().getName(), \"doSearch\");\n+\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+        Bundle bundle = null;\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+            String resourceTypeName = type;\n+\n+            // Check to see if it's supported, else, throw a bad request.\n+            // If this is removed, it'll result in nullpointer when processing the request\n+            if (!ModelSupport.isResourceType(type)) {\n+                throw buildUnsupportedResourceTypeException(type, IssueType.NOT_SUPPORTED);\n+            }\n+\n+            Class<? extends Resource> resourceType =\n+                    getResourceType(resourceTypeName);\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, invoke the 'beforeSearch' interceptor methods.\n+            FHIRPersistenceEvent event =\n+                    new FHIRPersistenceEvent(contextResource, buildPersistenceEventProperties(type, null, null, requestProperties));\n+            getInterceptorMgr().fireBeforeSearchEvent(event);\n+\n+            FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(compartment, compartmentId, resourceType, queryParameters,\n+                    HTTPHandlingPreference.LENIENT.equals(requestContext.getHandlingPreference()));\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event, searchContext);\n+            List<Resource> resources =\n+                    persistence.search(persistenceContext, resourceType).getResource();\n+\n+            bundle = createSearchBundle(resources, searchContext, type);\n+            if (requestUri != null) {\n+                bundle = addLinks(searchContext, bundle, requestUri);\n+            }\n+            event.setFhirResource(bundle);\n+\n+            // Invoke the 'afterSearch' interceptor methods.\n+            getInterceptorMgr().fireAfterSearchEvent(event);\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+\n+            return bundle;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we previously started a transaction and it's still active, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doSearch\");\n+        }\n+    }\n+\n+    /**\n+     * Helper method which invokes a custom operation.\n+     *\n+     * @param operationContext\n+     *            the FHIROperationContext associated with the request\n+     * @param resourceTypeName\n+     *            the resource type associated with the request\n+     * @param logicalId\n+     *            the resource logical id associated with the request\n+     * @param versionId\n+     *            the resource version id associated with the request\n+     * @param operationName\n+     *            the name of the custom operation to be invoked\n+     * @param resource\n+     *            the input resource associated with the custom operation to be invoked\n+     * @param queryParameters\n+     *            query parameters may be passed instead of a Parameters resource for certain custom operations invoked\n+     *            via GET\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return a Resource that represents the response to the custom operation\n+     * @throws Exception\n+     */\n+    @Override\n+    public Resource doInvoke(FHIROperationContext operationContext, String resourceTypeName,\n+            String logicalId, String versionId, String operationName,\n+            Resource resource, MultivaluedMap<String, String> queryParameters,\n+            Map<String, String> requestProperties) throws Exception {\n+        log.entering(this.getClass().getName(), \"doInvoke\");\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+            Class<? extends Resource> resourceType = null;\n+            if (resourceTypeName != null) {\n+                resourceType = getResourceType(resourceTypeName);\n+            }\n+            String operationKey = (resourceTypeName == null ? operationName : operationName + \":\" + resourceTypeName);\n+\n+            FHIROperation operation =\n+                    FHIROperationRegistry.getInstance().getOperation(operationKey);\n+            Parameters parameters = null;\n+            if (resource instanceof Parameters) {\n+                parameters = (Parameters) resource;\n+            } else {\n+                if (resource == null) {\n+                    // build parameters object from query parameters\n+                    parameters =\n+                            FHIROperationUtil.getInputParameters(operation.getDefinition(), queryParameters);\n+                } else {\n+                    // wrap resource in a parameters object\n+                    parameters =\n+                            FHIROperationUtil.getInputParameters(operation.getDefinition(), resource);\n+                }\n+            }\n+\n+            // Add properties to the FHIR operation context\n+            setOperationContextProperties(operationContext, resourceTypeName, requestProperties);\n+\n+            if (log.isLoggable(Level.FINE)) {\n+                log.fine(\"Invoking operation '\" + operationName + \"', context=\\n\"\n+                        + operationContext.toString());\n+            }\n+            Parameters result =\n+                    operation.invoke(operationContext, resourceType, logicalId, versionId, parameters, this);\n+            if (log.isLoggable(Level.FINE)) {\n+                log.fine(\"Returned from invocation of operation '\" + operationName + \"'...\");\n+            }\n+\n+            // if single resource output parameter, return the resource\n+            if (FHIROperationUtil.hasSingleResourceOutputParameter(result)) {\n+                return FHIROperationUtil.getSingleResourceOutputParameter(result);\n+            }\n+\n+            return result;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            log.exiting(this.getClass().getName(), \"doInvoke\");\n+        }\n+    }\n+\n+    /**\n+     * Processes a bundled request.\n+     *\n+     * @param bundleResource\n+     *            the request Bundle\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return the response Bundle\n+     */\n+    @Override\n+    public Bundle doBundle(Resource bundleResource, Map<String, String> requestProperties)\n+        throws Exception {\n+        log.entering(this.getClass().getName(), \"doBundle\");\n+        Bundle inputBundle = null;\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+            if (bundleResource instanceof Bundle) {\n+                inputBundle = (Bundle) bundleResource;\n+            } else {\n+                String msg = \"A 'Bundle' resource type is required but a '\"\n+                        + bundleResource.getClass().getSimpleName() + \"' resource type was sent.\";\n+                throw buildRestException(msg, IssueType.INVALID);\n+            }\n+            // First, validate the bundle and create the response bundle.\n+            Bundle responseBundle = validateBundle(inputBundle);\n+\n+            // Next, process each of the entries in the bundle.\n+            responseBundle = processBundleEntries(inputBundle, responseBundle, requestProperties);\n+\n+            return responseBundle;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            log.exiting(this.getClass().getName(), \"doBundle\");\n+        }\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * @see com.ibm.fhir.rest.FHIRResourceHelpers#getTransaction()\n+     */\n+    @Override\n+    public FHIRPersistenceTransaction getTransaction() throws Exception {\n+        return persistence.getTransaction();\n+    }\n+\n+    /**\n+     * Validate the input resource and throw if there are validation errors\n+     *\n+     * @param resource\n+     * @throws FHIRValidationException\n+     * @throws FHIROperationException\n+     */\n+    private List<OperationOutcome.Issue> validateInput(Resource resource)\n+            throws FHIRValidationException, FHIROperationException {\n+        List<OperationOutcome.Issue> issues = FHIRValidator.validator().validate(resource);\n+        if (!issues.isEmpty()) {\n+            boolean includesFailure = false;\n+            for (OperationOutcome.Issue issue : issues) {\n+                if (FHIRUtil.isFailure(issue.getSeverity())) {\n+                    includesFailure = true;\n+                }\n+            }\n+\n+            if (includesFailure) {\n+                throw new FHIROperationException(\"Input resource failed validation.\").withIssue(issues);\n+            } else {\n+                if (log.isLoggable(Level.FINE)) {\n+                    String info = issues.stream()\n+                                .flatMap(issue -> Stream.of(issue.getDetails()))\n+                                .flatMap(details -> Stream.of(details.getText()))\n+                                .flatMap(text -> Stream.of(text.getValue()))\n+                                .collect(Collectors.joining(\", \"));\n+                    log.fine(\"Validation warnings for input resource: \" + info);\n+                }\n+            }\n+        }\n+        return issues;\n+    }\n+\n+    /**\n+     * @param issues\n+     * @return\n+     */\n+    private boolean anyFailureInIssues(List<OperationOutcome.Issue> issues) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIzODI0NA=="}, "originalCommit": {"oid": "d0ff4daa4297bea3aff6025eac16697c3fe6ecb1"}, "originalPosition": 1085}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNTMyOTkxOnYy", "diffSide": "RIGHT", "path": "fhir-server/src/main/java/com/ibm/fhir/server/resources/FHIRRestHelper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMTozODo1NVrOFyQSig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMzoxMTo0NlrOFyS6XA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI0MDAxMA==", "bodyText": "mind dropping this comment?", "url": "https://github.com/IBM/FHIR/pull/759#discussion_r388240010", "createdAt": "2020-03-05T11:38:55Z", "author": {"login": "prb112"}, "path": "fhir-server/src/main/java/com/ibm/fhir/server/resources/FHIRRestHelper.java", "diffHunk": "@@ -0,0 +1,2448 @@\n+/*\n+ * (C) Copyright IBM Corp. 2016, 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.server.resources;\n+\n+import static com.ibm.fhir.model.type.String.string;\n+import static com.ibm.fhir.model.util.ModelSupport.getResourceType;\n+import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;\n+import static javax.servlet.http.HttpServletResponse.SC_GONE;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static javax.servlet.http.HttpServletResponse.SC_OK;\n+\n+import java.net.URI;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeFormatterBuilder;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.Status;\n+\n+import org.owasp.encoder.Encode;\n+\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.core.HTTPHandlingPreference;\n+import com.ibm.fhir.core.HTTPReturnPreference;\n+import com.ibm.fhir.core.context.FHIRPagingContext;\n+import com.ibm.fhir.exception.FHIROperationException;\n+import com.ibm.fhir.model.patch.FHIRPatch;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.OperationOutcome;\n+import com.ibm.fhir.model.resource.OperationOutcome.Issue;\n+import com.ibm.fhir.model.resource.Parameters;\n+import com.ibm.fhir.model.resource.Resource;\n+import com.ibm.fhir.model.type.CodeableConcept;\n+import com.ibm.fhir.model.type.Extension;\n+import com.ibm.fhir.model.type.UnsignedInt;\n+import com.ibm.fhir.model.type.Uri;\n+import com.ibm.fhir.model.type.Url;\n+import com.ibm.fhir.model.type.code.BundleType;\n+import com.ibm.fhir.model.type.code.HTTPVerb;\n+import com.ibm.fhir.model.type.code.IssueSeverity;\n+import com.ibm.fhir.model.type.code.IssueType;\n+import com.ibm.fhir.model.util.FHIRUtil;\n+import com.ibm.fhir.model.util.ModelSupport;\n+import com.ibm.fhir.model.util.ReferenceMappingVisitor;\n+import com.ibm.fhir.operation.FHIROperation;\n+import com.ibm.fhir.operation.context.FHIROperationContext;\n+import com.ibm.fhir.operation.registry.FHIROperationRegistry;\n+import com.ibm.fhir.operation.util.FHIROperationUtil;\n+import com.ibm.fhir.persistence.FHIRPersistence;\n+import com.ibm.fhir.persistence.FHIRPersistenceTransaction;\n+import com.ibm.fhir.persistence.context.FHIRHistoryContext;\n+import com.ibm.fhir.persistence.context.FHIRPersistenceContext;\n+import com.ibm.fhir.persistence.context.FHIRPersistenceContextFactory;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceResourceDeletedException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceResourceNotFoundException;\n+import com.ibm.fhir.persistence.helper.FHIRTransactionHelper;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceEvent;\n+import com.ibm.fhir.persistence.interceptor.impl.FHIRPersistenceInterceptorMgr;\n+import com.ibm.fhir.persistence.util.FHIRPersistenceUtil;\n+import com.ibm.fhir.rest.FHIRResourceHelpers;\n+import com.ibm.fhir.rest.FHIRRestOperationResponse;\n+import com.ibm.fhir.search.SearchConstants;\n+import com.ibm.fhir.search.SummaryValueSet;\n+import com.ibm.fhir.search.context.FHIRSearchContext;\n+import com.ibm.fhir.search.exception.FHIRSearchException;\n+import com.ibm.fhir.search.util.SearchUtil;\n+import com.ibm.fhir.server.exception.FHIRRestBundledRequestException;\n+import com.ibm.fhir.server.helper.FHIRUrlParser;\n+import com.ibm.fhir.server.util.IssueTypeToHttpStatusMapper;\n+import com.ibm.fhir.validation.FHIRValidator;\n+import com.ibm.fhir.validation.exception.FHIRValidationException;\n+\n+public class FHIRRestHelper implements FHIRResourceHelpers {\n+    private static final Logger log =\n+            java.util.logging.Logger.getLogger(FHIRRestHelper.class.getName());\n+\n+    private static final String EXTENSION_URL = \"http://ibm.com/fhir/extension\";\n+    private static final String LOCAL_REF_PREFIX = \"urn:\";\n+\n+    public static final DateTimeFormatter PARSER_FORMATTER = new DateTimeFormatterBuilder()\n+            .appendPattern(\"EEE\")\n+            .optionalStart()\n+            // ANSIC date time format for If-Modified-Since\n+            .appendPattern(\" MMM dd HH:mm:ss yyyy\")\n+            .optionalEnd()\n+            .optionalStart()\n+            // Touchstone date time format for If-Modified-Since\n+            .appendPattern(\", dd-MMM-yy HH:mm:ss\")\n+            .optionalEnd().toFormatter();\n+\n+    private FHIRPersistence persistence = null;\n+\n+    // These values are used for correlating requests within a bundle.\n+    private String bundleTransactionCorrelationId = null;\n+    private String bundleRequestCorrelationId = null;\n+\n+    public FHIRRestHelper(FHIRPersistence persistence) {\n+        this.persistence = persistence;\n+    }\n+\n+    /**\n+     * Performs the heavy lifting associated with a 'create' interaction.\n+     *\n+     * @param type\n+     *            the resource type specified as part of the request URL\n+     * @param resource\n+     *            the Resource to be stored.\n+     * @param ifNoneExist\n+     *            whether to create the resource if none exists\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return a FHIRRestOperationResponse object containing the results of the operation\n+     * @throws Exception\n+     */\n+    @Override\n+    public FHIRRestOperationResponse doCreate(String type, Resource resource, String ifNoneExist,\n+            Map<String, String> requestProperties) throws Exception {\n+        log.entering(this.getClass().getName(), \"doCreate\");\n+\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+        FHIRRestOperationResponse ior = new FHIRRestOperationResponse();\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+\n+            // Make sure the expected type (specified in the URL string) is congruent with the actual type\n+            // of the resource.\n+            String resourceType = ModelSupport.getTypeName(resource.getClass()); \n+            if (!resourceType.equals(type)) {\n+                String msg = \"Resource type '\" + resourceType\n+                        + \"' does not match type specified in request URI: \" + type;\n+                throw buildRestException(msg, IssueType.INVALID);\n+            }\n+\n+            // Check to see if we're supposed to perform a conditional 'create'.\n+            if (ifNoneExist != null && !ifNoneExist.isEmpty()) {\n+                log.fine(\"Performing conditional create with search criteria: \" + ifNoneExist);\n+                Bundle responseBundle = null;\n+\n+                // Perform the search using the \"If-None-Exist\" header value.\n+                try {\n+                    MultivaluedMap<String, String> searchParameters = getQueryParameterMap(ifNoneExist);\n+                    responseBundle =\n+                            doSearch(type, null, null, searchParameters, null, requestProperties, resource);\n+                } catch (FHIROperationException e) {\n+                    throw e;\n+                } catch (Throwable t) {\n+                    String msg =\n+                            \"An error occurred while performing the search for a conditional create operation.\";\n+                    log.log(Level.WARNING, msg, t);\n+                    throw new FHIROperationException(msg, t);\n+                }\n+\n+                // Check the search results to determine whether or not to perform the create operation.\n+                int resultCount = responseBundle.getEntry().size();\n+                log.fine(\"Conditional create search yielded \" + resultCount + \" results.\");\n+\n+                if (resultCount == 0) {\n+                    // Do nothing and fall through to process the 'create' request.\n+                } else if (resultCount == 1) {\n+                    // If we found a single match, bypass the 'create' request and return information\n+                    // for the matched resource.\n+                    Resource matchedResource = responseBundle.getEntry().get(0).getResource();\n+                    ior.setLocationURI(FHIRUtil.buildLocationURI(type, matchedResource));\n+                    ior.setStatus(Response.Status.OK);\n+                    ior.setResource(matchedResource);\n+                    log.fine(\"Returning location URI of matched resource: \" + ior.getLocationURI());\n+                    return ior;\n+                } else {\n+                    String msg =\n+                            \"The search criteria specified for a conditional create operation returned multiple matches.\";\n+                    throw buildRestException(msg, IssueType.MULTIPLE_MATCHES);\n+                }\n+            }\n+\n+            // For R4, resources may contain an id. For create, this should be ignored and\n+            // we no longer reject the request.\n+            if (resource.getId() != null && log.isLoggable(Level.FINE)) {\n+                log.fine(String.format(\"create request resource includes id: '%s'\", resource.getId()));\n+            }\n+\n+            // Validate the input resource and return any validation errors, but warnings are OK\n+            List<Issue> validationWarnings = validateInput(resource);\n+            ior.setOperationOutcome(FHIRUtil.buildOperationOutcome(validationWarnings));\n+\n+            // If there were no validation errors, then create the resource and return the location header.\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, invoke the 'beforeCreate' interceptor methods.\n+            FHIRPersistenceEvent event =\n+                    new FHIRPersistenceEvent(resource, buildPersistenceEventProperties(type, null, null, requestProperties));\n+            getInterceptorMgr().fireBeforeCreateEvent(event);\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event);\n+\n+            // R4: remember model objects are immutable, so we get back a new resource with the id/meta stuff\n+            resource = persistence.create(persistenceContext, resource).getResource();\n+            event.setFhirResource(resource); // update event with latest\n+            ior.setStatus(Response.Status.CREATED);\n+            ior.setResource(resource);\n+\n+            // Build our location URI and add it to the interceptor event structure since it is now known.\n+            ior.setLocationURI(FHIRUtil.buildLocationURI(ModelSupport.getTypeName(resource.getClass()), resource));\n+            event.getProperties().put(FHIRPersistenceEvent.PROPNAME_RESOURCE_LOCATION_URI, ior.getLocationURI().toString());\n+\n+            // Invoke the 'afterCreate' interceptor methods.\n+            getInterceptorMgr().fireAfterCreateEvent(event);\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+\n+            return ior;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we previously started a transaction and it's still active, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doCreate\");\n+        }\n+    }\n+\n+    @Override\n+    public FHIRRestOperationResponse doPatch(String type, String id, FHIRPatch patch, String ifMatchValue,\n+            String searchQueryString, Map<String, String> requestProperties) throws Exception {\n+\n+        return doPatchOrUpdate(type, id, patch, null, ifMatchValue, searchQueryString, requestProperties);\n+    }\n+\n+    @Override\n+    public FHIRRestOperationResponse doUpdate(String type, String id, Resource newResource, String ifMatchValue,\n+            String searchQueryString, Map<String, String> requestProperties) throws Exception {\n+\n+        return doPatchOrUpdate(type, id, null, newResource, ifMatchValue, searchQueryString, requestProperties);\n+    }\n+\n+    private FHIRRestOperationResponse doPatchOrUpdate(String type, String id, FHIRPatch patch,\n+            Resource newResource, String ifMatchValue, String searchQueryString,\n+            Map<String, String> requestProperties) throws Exception {\n+        log.entering(this.getClass().getName(), \"doPatchOrUpdate\");\n+\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        FHIRRestOperationResponse ior = new FHIRRestOperationResponse();\n+\n+        try {\n+            // Make sure the type specified in the URL string matches the resource type obtained from the new resource.\n+            if (patch == null) {\n+                String resourceType =  ModelSupport.getTypeName(newResource.getClass());\n+                if (!resourceType.equals(type)) {\n+                    String msg = \"Resource type '\" + resourceType\n+                            + \"' does not match type specified in request URI: \" + type;\n+                    throw buildRestException(msg, IssueType.INVALID);\n+                }\n+            }\n+\n+            // Next, if a conditional update was invoked then use the search criteria to find the\n+            // resource to be updated. Otherwise, we'll use the id value to retrieve the current\n+            // version of the resource.\n+            if (searchQueryString != null) {\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Performing conditional update/patch with search criteria: \"\n+                            + Encode.forHtml(searchQueryString));\n+                }\n+                Bundle responseBundle = null;\n+                try {\n+                    MultivaluedMap<String, String> searchParameters =\n+                            getQueryParameterMap(searchQueryString);\n+                    responseBundle =\n+                            doSearch(type, null, null, searchParameters, null, requestProperties, newResource);\n+                } catch (FHIROperationException e) {\n+                    throw e;\n+                } catch (Throwable t) {\n+                    String msg =\n+                            \"An error occurred while performing the search for a conditional update/patch operation.\";\n+                    throw new FHIROperationException(msg, t);\n+                }\n+\n+                // Check the search results to determine whether or not to perform the update operation.\n+                int resultCount = responseBundle.getEntry().size();\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Conditional update/patch search yielded \" + resultCount + \" results.\");\n+                }\n+\n+                if (resultCount == 0) {\n+                    if (patch != null) {\n+                        String msg =\n+                                \"The search criteria specified for a conditional patch operation did not return any results.\";\n+                        throw buildRestException(msg, IssueType.NOT_FOUND);\n+                    }\n+                    // Search yielded no matches, so we'll do an update/create operation below.\n+                    ior.setPrevResource(null);\n+\n+                    // if no id provided, then generate an id for the input resource\n+                    if (newResource.getId() == null || newResource.getId() == null) {\n+                        id = UUID.randomUUID().toString();\n+                        newResource = newResource.toBuilder().id(id).build();\n+                    } else {\n+                        id = newResource.getId();\n+                    }\n+                } else if (resultCount == 1) {\n+                    // If we found a single match, then we'll perform a normal update on the matched resource.\n+                    ior.setPrevResource(responseBundle.getEntry().get(0).getResource());\n+                    id = ior.getPrevResource().getId();\n+\n+                    // If the id of the input resource is different from the id of the search result,\n+                    // then throw exception.\n+                    if (newResource.getId() != null && newResource.getId() != null\n+                            && !newResource.getId().equalsIgnoreCase(id)) {\n+                        String msg = \"Input resource 'id' attribute must match the id of the search result resource.\";\n+                        throw buildRestException(msg, IssueType.VALUE);\n+                    }\n+                    // Make sure the id of the newResource is not null and is the same as the id of the found resource.\n+                    newResource = newResource.toBuilder().id(id).build();\n+                } else {\n+                    String msg =\n+                            \"The search criteria specified for a conditional update/patch operation returned multiple matches.\";\n+                    throw buildRestException(msg, IssueType.MULTIPLE_MATCHES);\n+                }\n+            } else {\n+                // Make sure an id value was passed in.\n+                if (id == null) {\n+                    String msg = \"The 'id' parameter is required for an update/pach operation.\";\n+                    throw buildRestException(msg, IssueType.REQUIRED);\n+                }\n+\n+                // If an id value was passed in (i.e. the id specified in the REST API URL string),\n+                // then make sure it's the same as the value in the resource.\n+                if (patch == null) {\n+                    // Make sure the resource has an 'id' attribute.\n+                    if (newResource.getId() == null) {\n+                        String msg = \"Input resource must contain an 'id' attribute.\";\n+                        throw buildRestException(msg, IssueType.INVALID);\n+                    }\n+\n+                    if (!newResource.getId().equals(id)) {\n+                        String msg = \"Input resource 'id' attribute must match 'id' parameter.\";\n+                        throw buildRestException(msg, IssueType.VALUE);\n+                    }\n+                }\n+\n+                // Retrieve the resource to be updated using the type and id values.\n+                ior.setPrevResource(doRead(type, id, (patch != null), true, requestProperties, newResource));\n+            }\n+\n+            if (patch != null) {\n+                newResource = patch.apply(ior.getPrevResource());\n+            }\n+\n+            // Validate the input resource and return any validation errors.\n+            List<Issue> validationWarnings = validateInput(newResource);\n+            ior.setOperationOutcome(FHIRUtil.buildOperationOutcome(validationWarnings));\n+\n+            // Perform the \"version-aware\" update check, and also find out if the resource was deleted.\n+            boolean isDeleted = false;\n+            if (ior.getPrevResource() != null) {\n+                performVersionAwareUpdateCheck(ior.getPrevResource(), ifMatchValue);\n+\n+                try {\n+                    doRead(type, id, (patch != null), false, requestProperties, newResource);\n+                } catch (FHIRPersistenceResourceDeletedException e) {\n+                    isDeleted = true;\n+                }\n+            }\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, create the persistence event.\n+            FHIRPersistenceEvent event = new FHIRPersistenceEvent(newResource, \n+                    buildPersistenceEventProperties(type, newResource.getId(), null, requestProperties));\n+\n+            // Next, set the \"previous resource\" in the persistence event.\n+            event.setPrevFhirResource(ior.getPrevResource());\n+\n+            // Next, invoke the 'beforeUpdate' or 'beforeCreate' interceptor methods as appropriate.\n+            boolean updateCreate = (ior.getPrevResource() == null);\n+            if (updateCreate) {\n+                getInterceptorMgr().fireBeforeCreateEvent(event);\n+            } else {\n+                if (patch != null) {\n+                    event.getProperties().put(FHIRPersistenceEvent.PROPNAME_PATCH, patch);\n+                    getInterceptorMgr().fireBeforePatchEvent(event);\n+                } else {\n+                    getInterceptorMgr().fireBeforeUpdateEvent(event);\n+                }\n+            }\n+\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event);\n+            newResource = persistence.update(persistenceContext, id, newResource).getResource();\n+            event.setFhirResource(newResource); // update event with latest\n+            ior.setResource(newResource);\n+\n+            // Build our location URI and add it to the interceptor event structure since it is now known.\n+            ior.setLocationURI(FHIRUtil.buildLocationURI(ModelSupport.getTypeName(newResource.getClass()), newResource));\n+            event.getProperties().put(FHIRPersistenceEvent.PROPNAME_RESOURCE_LOCATION_URI, ior.getLocationURI().toString());\n+\n+            // Invoke the 'afterUpdate' interceptor methods.\n+            if (updateCreate) {\n+                ior.setStatus(Response.Status.CREATED);\n+                getInterceptorMgr().fireAfterCreateEvent(event);\n+            } else {\n+                ior.setStatus(Response.Status.OK);\n+                if (patch != null) {\n+                    getInterceptorMgr().fireAfterPatchEvent(event);\n+                } else {\n+                    getInterceptorMgr().fireAfterUpdateEvent(event);\n+                }\n+            }\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+\n+            // If the deleted resource is updated, then simply return 201 instead of 200 to pass Touchstone test.\n+            // We don't set the previous resource to null in above codes if the resource was deleted, otherwise\n+            // it will break the code logic of the resource versioning.\n+            if (isDeleted && ior.getStatus() == Response.Status.OK) {\n+                ior.setStatus(Response.Status.CREATED);\n+            }\n+\n+            return ior;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we still have a transaction at this point, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doPatchOrUpdate\");\n+        }\n+    }\n+\n+    /**\n+     * Performs a 'delete' operation on the specified resource.\n+     *\n+     * @param type\n+     *            the resource type associated with the Resource to be deleted\n+     * @param id\n+     *            the id of the Resource to be deleted\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return a FHIRRestOperationResponse that contains the results of the operation\n+     * @throws Exception\n+     */\n+    @Override\n+    public FHIRRestOperationResponse doDelete(String type, String id, String searchQueryString,\n+            Map<String, String> requestProperties) throws Exception {\n+        log.entering(this.getClass().getName(), \"doDelete\");\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+        Response.Status status = null;\n+\n+        FHIRRestOperationResponse ior = new FHIRRestOperationResponse();\n+\n+        try {\n+            String resourceTypeName = type;\n+            if (!ModelSupport.isResourceType(type)) {\n+                throw buildUnsupportedResourceTypeException(type, IssueType.NOT_SUPPORTED);\n+            }\n+\n+            Class<? extends Resource> resourceType =\n+                    getResourceType(resourceTypeName);\n+\n+            // Next, if a conditional delete was invoked then use the search criteria to find the\n+            // resource to be deleted. Otherwise, we'll use the id value to identify the resource\n+            // to be deleted.\n+            Resource resourceToDelete = null;\n+            if (searchQueryString != null) {\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Performing conditional delete with search criteria: \"\n+                            + Encode.forHtml(searchQueryString));\n+                }\n+                Bundle responseBundle = null;\n+                try {\n+                    MultivaluedMap<String, String> searchParameters =\n+                            getQueryParameterMap(searchQueryString);\n+                    responseBundle =\n+                            doSearch(type, null, null, searchParameters, null, requestProperties, null);\n+                } catch (FHIROperationException e) {\n+                    throw e;\n+                } catch (Throwable t) {\n+                    String msg =\n+                            \"An error occurred while performing the search for a conditional delete operation.\";\n+                    throw new FHIROperationException(msg, t);\n+                }\n+\n+                // Check the search results to determine whether or not to perform the update operation.\n+                int resultCount = responseBundle.getEntry().size();\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Conditional delete search yielded \" + resultCount + \" results.\");\n+                }\n+\n+                if (resultCount == 0) {\n+                    // Search yielded no matches\n+                    String msg = \"Search criteria for a conditional delete operation yielded no matches.\";\n+                    if (log.isLoggable(Level.FINE)) {\n+                        log.fine(msg);\n+                    }\n+                    status = Response.Status.OK;\n+                    ior.setOperationOutcome(FHIRUtil.buildOperationOutcome(msg, IssueType.NOT_FOUND, IssueSeverity.WARNING));\n+                    ior.setStatus(status);\n+                    return ior;\n+                } else if (resultCount == 1) {\n+                    // If we found a single match, then we'll delete this one.\n+                    Resource resource = responseBundle.getEntry().get(0).getResource();\n+                    id = resource.getId();\n+                    resourceToDelete = resource;\n+                } else {\n+                    String msg =\n+                            \"The search criteria specified for a conditional delete operation returned multiple matches.\";\n+                    throw buildRestException(msg, IssueType.MULTIPLE_MATCHES);\n+                }\n+            } else {\n+                // Make sure an id value was passed in.\n+                if (id == null) {\n+                    String msg = \"The 'id' parameter is required for a delete operation.\";\n+                    throw buildRestException(msg, IssueType.REQUIRED);\n+                }\n+\n+                // Read the resource so it will be available to the beforeDelete interceptor methods.\n+                try {\n+                    resourceToDelete = doRead(type, id, false, false, requestProperties, null);\n+                } catch (FHIRPersistenceResourceDeletedException e) {\n+                    // Absorb this exception.\n+                    resourceToDelete = null;\n+                }\n+            }\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, invoke the 'beforeDelete' interceptor methods.\n+            FHIRPersistenceEvent event =\n+                    new FHIRPersistenceEvent(null, buildPersistenceEventProperties(type, id, null, requestProperties));\n+            event.setFhirResource(resourceToDelete);\n+            getInterceptorMgr().fireBeforeDeleteEvent(event);\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event);\n+\n+            Resource resource = persistence.delete(persistenceContext, resourceType, id).getResource();\n+            ior.setResource(resource);\n+            event.setFhirResource(resource);\n+            ior.setStatus(Response.Status.NO_CONTENT);\n+\n+            // Invoke the 'afterDelete' interceptor methods.\n+            getInterceptorMgr().fireAfterDeleteEvent(event);\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+            status = ior.getStatus();\n+\n+            return ior;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we previously started a transaction and it's still active, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doDelete\");\n+        }\n+    }\n+\n+    @Override\n+    public Resource doRead(String type, String id, boolean throwExcOnNull, boolean includeDeleted,\n+            Map<String, String> requestProperties, Resource contextResource) throws Exception {\n+        return doRead(type, id, throwExcOnNull, includeDeleted, requestProperties, contextResource, null);\n+    }\n+\n+    /**\n+     * Performs a 'read' operation to retrieve a Resource.\n+     *\n+     * @param type\n+     *            the resource type associated with the Resource to be retrieved\n+     * @param id\n+     *            the id of the Resource to be retrieved\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return the Resource\n+     * @throws Exception\n+     */\n+    @Override\n+    public Resource doRead(String type, String id, boolean throwExcOnNull, boolean includeDeleted,\n+            Map<String, String> requestProperties, Resource contextResource, MultivaluedMap<String, String> queryParameters)\n+            throws Exception {\n+        log.entering(this.getClass().getName(), \"doRead\");\n+\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+        Resource resource = null;\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+            String resourceTypeName = type;\n+            if (!ModelSupport.isResourceType(type)) {\n+                throw buildUnsupportedResourceTypeException(type, IssueType.NOT_SUPPORTED);\n+            }\n+\n+            Class<? extends Resource> resourceType = getResourceType(resourceTypeName);\n+\n+            FHIRSearchContext searchContext = null;\n+            if (queryParameters != null) {\n+                searchContext = SearchUtil.parseQueryParameters(null, null, resourceType, queryParameters, \n+                        HTTPHandlingPreference.LENIENT.equals(requestContext.getHandlingPreference()));\n+            }\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, invoke the 'beforeRead' interceptor methods.\n+            FHIRPersistenceEvent event =\n+                    new FHIRPersistenceEvent(contextResource, buildPersistenceEventProperties(type, id, null, requestProperties));\n+            getInterceptorMgr().fireBeforeReadEvent(event);\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event, includeDeleted, searchContext);\n+            resource = persistence.read(persistenceContext, resourceType, id).getResource();\n+            if (resource == null && throwExcOnNull) {\n+                throw new FHIRPersistenceResourceNotFoundException(\"Resource '\" + type + \"/\" + id + \"' not found.\");\n+            }\n+\n+            event.setFhirResource(resource);\n+\n+            // Invoke the 'afterRead' interceptor methods.\n+            getInterceptorMgr().fireAfterReadEvent(event);\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+\n+            return resource;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we previously started a transaction and it's still active, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doRead\");\n+        }\n+    }\n+\n+    /**\n+     * Performs a 'vread' operation by retrieving the specified version of a Resource.\n+     *\n+     * @param type\n+     *            the resource type associated with the Resource to be retrieved\n+     * @param id\n+     *            the id of the Resource to be retrieved\n+     * @param versionId\n+     *            the version id of the Resource to be retrieved\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return the Resource\n+     * @throws Exception\n+     */\n+    @Override\n+    public Resource doVRead(String type, String id, String versionId,\n+        Map<String, String> requestProperties) throws Exception {\n+        log.entering(this.getClass().getName(), \"doVRead\");\n+\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+        Resource resource = null;\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+            String resourceTypeName = type;\n+            if (!ModelSupport.isResourceType(type)) {\n+                throw buildUnsupportedResourceTypeException(type, IssueType.NOT_SUPPORTED);\n+            }\n+\n+            Class<? extends Resource> resourceType =\n+                    getResourceType(resourceTypeName);\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, invoke the 'beforeVread' interceptor methods.\n+            FHIRPersistenceEvent event =\n+                    new FHIRPersistenceEvent(null, buildPersistenceEventProperties(type, id, versionId, requestProperties));\n+            getInterceptorMgr().fireBeforeVreadEvent(event);\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event);\n+            resource = persistence.vread(persistenceContext, resourceType, id, versionId).getResource();\n+            if (resource == null) {\n+                throw new FHIRPersistenceResourceNotFoundException(\"Resource '\"\n+                        + resourceType.getSimpleName() + \"/\" + id + \"' version \" + versionId + \" not found.\");\n+            }\n+\n+            event.setFhirResource(resource);\n+\n+            // Invoke the 'afterVread' interceptor methods.\n+            getInterceptorMgr().fireAfterVreadEvent(event);\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+\n+            return resource;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we previously started a transaction and it's still active, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doVRead\");\n+        }\n+    }\n+\n+    /**\n+     * Performs the work of retrieving versions of a Resource.\n+     *\n+     * @param type\n+     *            the resource type associated with the Resource to be retrieved\n+     * @param id\n+     *            the id of the Resource to be retrieved\n+     * @param queryParameters\n+     *            a Map containing the query parameters from the request URL\n+     * @param requestUri the URI from the request\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return a Bundle containing the history of the specified Resource\n+     * @throws Exception\n+     */\n+    @Override\n+    public Bundle doHistory(String type, String id, MultivaluedMap<String, String> queryParameters,\n+        String requestUri, Map<String, String> requestProperties)\n+        throws Exception {\n+        log.entering(this.getClass().getName(), \"doHistory\");\n+\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+        Bundle bundle = null;\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+            String resourceTypeName = type;\n+            if (!ModelSupport.isResourceType(type)) {\n+                throw buildUnsupportedResourceTypeException(type, IssueType.NOT_SUPPORTED);\n+            }\n+\n+            Class<? extends Resource> resourceType =\n+                    getResourceType(resourceTypeName);\n+            FHIRHistoryContext historyContext =\n+                    FHIRPersistenceUtil.parseHistoryParameters(queryParameters, HTTPHandlingPreference.LENIENT.equals(requestContext.getHandlingPreference()));\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, invoke the 'beforeHistory' interceptor methods.\n+            FHIRPersistenceEvent event =\n+                    new FHIRPersistenceEvent(null, buildPersistenceEventProperties(type, id, null, requestProperties));\n+            getInterceptorMgr().fireBeforeHistoryEvent(event);\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event, historyContext);\n+            List<? extends Resource> resources =\n+                    persistence.history(persistenceContext, resourceType, id).getResource();\n+            bundle = createHistoryBundle(resources, historyContext, type);\n+            bundle = addLinks(historyContext, bundle, requestUri);\n+\n+            event.setFhirResource(bundle);\n+\n+            // Invoke the 'afterHistory' interceptor methods.\n+            getInterceptorMgr().fireAfterHistoryEvent(event);\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+\n+            return bundle;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we previously started a transaction and it's still active, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doHistory\");\n+        }\n+    }\n+\n+    /**\n+     * Performs heavy lifting associated with a 'search' operation.\n+     *\n+     * @param type\n+     *            the resource type associated with the search\n+     * @param queryParameters\n+     *            a Map containing the query parameters from the request URL\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return a Bundle containing the search result set\n+     * @throws Exception\n+     */\n+    @Override\n+    public Bundle doSearch(String type, String compartment, String compartmentId,\n+            MultivaluedMap<String, String> queryParameters, String requestUri,\n+            Map<String, String> requestProperties, Resource contextResource) throws Exception {\n+        log.entering(this.getClass().getName(), \"doSearch\");\n+\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+        Bundle bundle = null;\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+            String resourceTypeName = type;\n+\n+            // Check to see if it's supported, else, throw a bad request.\n+            // If this is removed, it'll result in nullpointer when processing the request\n+            if (!ModelSupport.isResourceType(type)) {\n+                throw buildUnsupportedResourceTypeException(type, IssueType.NOT_SUPPORTED);\n+            }\n+\n+            Class<? extends Resource> resourceType =\n+                    getResourceType(resourceTypeName);\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, invoke the 'beforeSearch' interceptor methods.\n+            FHIRPersistenceEvent event =\n+                    new FHIRPersistenceEvent(contextResource, buildPersistenceEventProperties(type, null, null, requestProperties));\n+            getInterceptorMgr().fireBeforeSearchEvent(event);\n+\n+            FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(compartment, compartmentId, resourceType, queryParameters,\n+                    HTTPHandlingPreference.LENIENT.equals(requestContext.getHandlingPreference()));\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event, searchContext);\n+            List<Resource> resources =\n+                    persistence.search(persistenceContext, resourceType).getResource();\n+\n+            bundle = createSearchBundle(resources, searchContext, type);\n+            if (requestUri != null) {\n+                bundle = addLinks(searchContext, bundle, requestUri);\n+            }\n+            event.setFhirResource(bundle);\n+\n+            // Invoke the 'afterSearch' interceptor methods.\n+            getInterceptorMgr().fireAfterSearchEvent(event);\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+\n+            return bundle;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we previously started a transaction and it's still active, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doSearch\");\n+        }\n+    }\n+\n+    /**\n+     * Helper method which invokes a custom operation.\n+     *\n+     * @param operationContext\n+     *            the FHIROperationContext associated with the request\n+     * @param resourceTypeName\n+     *            the resource type associated with the request\n+     * @param logicalId\n+     *            the resource logical id associated with the request\n+     * @param versionId\n+     *            the resource version id associated with the request\n+     * @param operationName\n+     *            the name of the custom operation to be invoked\n+     * @param resource\n+     *            the input resource associated with the custom operation to be invoked\n+     * @param queryParameters\n+     *            query parameters may be passed instead of a Parameters resource for certain custom operations invoked\n+     *            via GET\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return a Resource that represents the response to the custom operation\n+     * @throws Exception\n+     */\n+    @Override\n+    public Resource doInvoke(FHIROperationContext operationContext, String resourceTypeName,\n+            String logicalId, String versionId, String operationName,\n+            Resource resource, MultivaluedMap<String, String> queryParameters,\n+            Map<String, String> requestProperties) throws Exception {\n+        log.entering(this.getClass().getName(), \"doInvoke\");\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+            Class<? extends Resource> resourceType = null;\n+            if (resourceTypeName != null) {\n+                resourceType = getResourceType(resourceTypeName);\n+            }\n+            String operationKey = (resourceTypeName == null ? operationName : operationName + \":\" + resourceTypeName);\n+\n+            FHIROperation operation =\n+                    FHIROperationRegistry.getInstance().getOperation(operationKey);\n+            Parameters parameters = null;\n+            if (resource instanceof Parameters) {\n+                parameters = (Parameters) resource;\n+            } else {\n+                if (resource == null) {\n+                    // build parameters object from query parameters\n+                    parameters =\n+                            FHIROperationUtil.getInputParameters(operation.getDefinition(), queryParameters);\n+                } else {\n+                    // wrap resource in a parameters object\n+                    parameters =\n+                            FHIROperationUtil.getInputParameters(operation.getDefinition(), resource);\n+                }\n+            }\n+\n+            // Add properties to the FHIR operation context\n+            setOperationContextProperties(operationContext, resourceTypeName, requestProperties);\n+\n+            if (log.isLoggable(Level.FINE)) {\n+                log.fine(\"Invoking operation '\" + operationName + \"', context=\\n\"\n+                        + operationContext.toString());\n+            }\n+            Parameters result =\n+                    operation.invoke(operationContext, resourceType, logicalId, versionId, parameters, this);\n+            if (log.isLoggable(Level.FINE)) {\n+                log.fine(\"Returned from invocation of operation '\" + operationName + \"'...\");\n+            }\n+\n+            // if single resource output parameter, return the resource\n+            if (FHIROperationUtil.hasSingleResourceOutputParameter(result)) {\n+                return FHIROperationUtil.getSingleResourceOutputParameter(result);\n+            }\n+\n+            return result;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            log.exiting(this.getClass().getName(), \"doInvoke\");\n+        }\n+    }\n+\n+    /**\n+     * Processes a bundled request.\n+     *\n+     * @param bundleResource\n+     *            the request Bundle\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return the response Bundle\n+     */\n+    @Override\n+    public Bundle doBundle(Resource bundleResource, Map<String, String> requestProperties)\n+        throws Exception {\n+        log.entering(this.getClass().getName(), \"doBundle\");\n+        Bundle inputBundle = null;\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+            if (bundleResource instanceof Bundle) {\n+                inputBundle = (Bundle) bundleResource;\n+            } else {\n+                String msg = \"A 'Bundle' resource type is required but a '\"\n+                        + bundleResource.getClass().getSimpleName() + \"' resource type was sent.\";\n+                throw buildRestException(msg, IssueType.INVALID);\n+            }\n+            // First, validate the bundle and create the response bundle.\n+            Bundle responseBundle = validateBundle(inputBundle);\n+\n+            // Next, process each of the entries in the bundle.\n+            responseBundle = processBundleEntries(inputBundle, responseBundle, requestProperties);\n+\n+            return responseBundle;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            log.exiting(this.getClass().getName(), \"doBundle\");\n+        }\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * @see com.ibm.fhir.rest.FHIRResourceHelpers#getTransaction()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0ff4daa4297bea3aff6025eac16697c3fe6ecb1"}, "originalPosition": 1040}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI4Mjk3Mg==", "bodyText": "done", "url": "https://github.com/IBM/FHIR/pull/759#discussion_r388282972", "createdAt": "2020-03-05T13:11:46Z", "author": {"login": "lmsurpre"}, "path": "fhir-server/src/main/java/com/ibm/fhir/server/resources/FHIRRestHelper.java", "diffHunk": "@@ -0,0 +1,2448 @@\n+/*\n+ * (C) Copyright IBM Corp. 2016, 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.server.resources;\n+\n+import static com.ibm.fhir.model.type.String.string;\n+import static com.ibm.fhir.model.util.ModelSupport.getResourceType;\n+import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;\n+import static javax.servlet.http.HttpServletResponse.SC_GONE;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static javax.servlet.http.HttpServletResponse.SC_OK;\n+\n+import java.net.URI;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeFormatterBuilder;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.Status;\n+\n+import org.owasp.encoder.Encode;\n+\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.core.HTTPHandlingPreference;\n+import com.ibm.fhir.core.HTTPReturnPreference;\n+import com.ibm.fhir.core.context.FHIRPagingContext;\n+import com.ibm.fhir.exception.FHIROperationException;\n+import com.ibm.fhir.model.patch.FHIRPatch;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.OperationOutcome;\n+import com.ibm.fhir.model.resource.OperationOutcome.Issue;\n+import com.ibm.fhir.model.resource.Parameters;\n+import com.ibm.fhir.model.resource.Resource;\n+import com.ibm.fhir.model.type.CodeableConcept;\n+import com.ibm.fhir.model.type.Extension;\n+import com.ibm.fhir.model.type.UnsignedInt;\n+import com.ibm.fhir.model.type.Uri;\n+import com.ibm.fhir.model.type.Url;\n+import com.ibm.fhir.model.type.code.BundleType;\n+import com.ibm.fhir.model.type.code.HTTPVerb;\n+import com.ibm.fhir.model.type.code.IssueSeverity;\n+import com.ibm.fhir.model.type.code.IssueType;\n+import com.ibm.fhir.model.util.FHIRUtil;\n+import com.ibm.fhir.model.util.ModelSupport;\n+import com.ibm.fhir.model.util.ReferenceMappingVisitor;\n+import com.ibm.fhir.operation.FHIROperation;\n+import com.ibm.fhir.operation.context.FHIROperationContext;\n+import com.ibm.fhir.operation.registry.FHIROperationRegistry;\n+import com.ibm.fhir.operation.util.FHIROperationUtil;\n+import com.ibm.fhir.persistence.FHIRPersistence;\n+import com.ibm.fhir.persistence.FHIRPersistenceTransaction;\n+import com.ibm.fhir.persistence.context.FHIRHistoryContext;\n+import com.ibm.fhir.persistence.context.FHIRPersistenceContext;\n+import com.ibm.fhir.persistence.context.FHIRPersistenceContextFactory;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceResourceDeletedException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceResourceNotFoundException;\n+import com.ibm.fhir.persistence.helper.FHIRTransactionHelper;\n+import com.ibm.fhir.persistence.interceptor.FHIRPersistenceEvent;\n+import com.ibm.fhir.persistence.interceptor.impl.FHIRPersistenceInterceptorMgr;\n+import com.ibm.fhir.persistence.util.FHIRPersistenceUtil;\n+import com.ibm.fhir.rest.FHIRResourceHelpers;\n+import com.ibm.fhir.rest.FHIRRestOperationResponse;\n+import com.ibm.fhir.search.SearchConstants;\n+import com.ibm.fhir.search.SummaryValueSet;\n+import com.ibm.fhir.search.context.FHIRSearchContext;\n+import com.ibm.fhir.search.exception.FHIRSearchException;\n+import com.ibm.fhir.search.util.SearchUtil;\n+import com.ibm.fhir.server.exception.FHIRRestBundledRequestException;\n+import com.ibm.fhir.server.helper.FHIRUrlParser;\n+import com.ibm.fhir.server.util.IssueTypeToHttpStatusMapper;\n+import com.ibm.fhir.validation.FHIRValidator;\n+import com.ibm.fhir.validation.exception.FHIRValidationException;\n+\n+public class FHIRRestHelper implements FHIRResourceHelpers {\n+    private static final Logger log =\n+            java.util.logging.Logger.getLogger(FHIRRestHelper.class.getName());\n+\n+    private static final String EXTENSION_URL = \"http://ibm.com/fhir/extension\";\n+    private static final String LOCAL_REF_PREFIX = \"urn:\";\n+\n+    public static final DateTimeFormatter PARSER_FORMATTER = new DateTimeFormatterBuilder()\n+            .appendPattern(\"EEE\")\n+            .optionalStart()\n+            // ANSIC date time format for If-Modified-Since\n+            .appendPattern(\" MMM dd HH:mm:ss yyyy\")\n+            .optionalEnd()\n+            .optionalStart()\n+            // Touchstone date time format for If-Modified-Since\n+            .appendPattern(\", dd-MMM-yy HH:mm:ss\")\n+            .optionalEnd().toFormatter();\n+\n+    private FHIRPersistence persistence = null;\n+\n+    // These values are used for correlating requests within a bundle.\n+    private String bundleTransactionCorrelationId = null;\n+    private String bundleRequestCorrelationId = null;\n+\n+    public FHIRRestHelper(FHIRPersistence persistence) {\n+        this.persistence = persistence;\n+    }\n+\n+    /**\n+     * Performs the heavy lifting associated with a 'create' interaction.\n+     *\n+     * @param type\n+     *            the resource type specified as part of the request URL\n+     * @param resource\n+     *            the Resource to be stored.\n+     * @param ifNoneExist\n+     *            whether to create the resource if none exists\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return a FHIRRestOperationResponse object containing the results of the operation\n+     * @throws Exception\n+     */\n+    @Override\n+    public FHIRRestOperationResponse doCreate(String type, Resource resource, String ifNoneExist,\n+            Map<String, String> requestProperties) throws Exception {\n+        log.entering(this.getClass().getName(), \"doCreate\");\n+\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+        FHIRRestOperationResponse ior = new FHIRRestOperationResponse();\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+\n+            // Make sure the expected type (specified in the URL string) is congruent with the actual type\n+            // of the resource.\n+            String resourceType = ModelSupport.getTypeName(resource.getClass()); \n+            if (!resourceType.equals(type)) {\n+                String msg = \"Resource type '\" + resourceType\n+                        + \"' does not match type specified in request URI: \" + type;\n+                throw buildRestException(msg, IssueType.INVALID);\n+            }\n+\n+            // Check to see if we're supposed to perform a conditional 'create'.\n+            if (ifNoneExist != null && !ifNoneExist.isEmpty()) {\n+                log.fine(\"Performing conditional create with search criteria: \" + ifNoneExist);\n+                Bundle responseBundle = null;\n+\n+                // Perform the search using the \"If-None-Exist\" header value.\n+                try {\n+                    MultivaluedMap<String, String> searchParameters = getQueryParameterMap(ifNoneExist);\n+                    responseBundle =\n+                            doSearch(type, null, null, searchParameters, null, requestProperties, resource);\n+                } catch (FHIROperationException e) {\n+                    throw e;\n+                } catch (Throwable t) {\n+                    String msg =\n+                            \"An error occurred while performing the search for a conditional create operation.\";\n+                    log.log(Level.WARNING, msg, t);\n+                    throw new FHIROperationException(msg, t);\n+                }\n+\n+                // Check the search results to determine whether or not to perform the create operation.\n+                int resultCount = responseBundle.getEntry().size();\n+                log.fine(\"Conditional create search yielded \" + resultCount + \" results.\");\n+\n+                if (resultCount == 0) {\n+                    // Do nothing and fall through to process the 'create' request.\n+                } else if (resultCount == 1) {\n+                    // If we found a single match, bypass the 'create' request and return information\n+                    // for the matched resource.\n+                    Resource matchedResource = responseBundle.getEntry().get(0).getResource();\n+                    ior.setLocationURI(FHIRUtil.buildLocationURI(type, matchedResource));\n+                    ior.setStatus(Response.Status.OK);\n+                    ior.setResource(matchedResource);\n+                    log.fine(\"Returning location URI of matched resource: \" + ior.getLocationURI());\n+                    return ior;\n+                } else {\n+                    String msg =\n+                            \"The search criteria specified for a conditional create operation returned multiple matches.\";\n+                    throw buildRestException(msg, IssueType.MULTIPLE_MATCHES);\n+                }\n+            }\n+\n+            // For R4, resources may contain an id. For create, this should be ignored and\n+            // we no longer reject the request.\n+            if (resource.getId() != null && log.isLoggable(Level.FINE)) {\n+                log.fine(String.format(\"create request resource includes id: '%s'\", resource.getId()));\n+            }\n+\n+            // Validate the input resource and return any validation errors, but warnings are OK\n+            List<Issue> validationWarnings = validateInput(resource);\n+            ior.setOperationOutcome(FHIRUtil.buildOperationOutcome(validationWarnings));\n+\n+            // If there were no validation errors, then create the resource and return the location header.\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, invoke the 'beforeCreate' interceptor methods.\n+            FHIRPersistenceEvent event =\n+                    new FHIRPersistenceEvent(resource, buildPersistenceEventProperties(type, null, null, requestProperties));\n+            getInterceptorMgr().fireBeforeCreateEvent(event);\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event);\n+\n+            // R4: remember model objects are immutable, so we get back a new resource with the id/meta stuff\n+            resource = persistence.create(persistenceContext, resource).getResource();\n+            event.setFhirResource(resource); // update event with latest\n+            ior.setStatus(Response.Status.CREATED);\n+            ior.setResource(resource);\n+\n+            // Build our location URI and add it to the interceptor event structure since it is now known.\n+            ior.setLocationURI(FHIRUtil.buildLocationURI(ModelSupport.getTypeName(resource.getClass()), resource));\n+            event.getProperties().put(FHIRPersistenceEvent.PROPNAME_RESOURCE_LOCATION_URI, ior.getLocationURI().toString());\n+\n+            // Invoke the 'afterCreate' interceptor methods.\n+            getInterceptorMgr().fireAfterCreateEvent(event);\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+\n+            return ior;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we previously started a transaction and it's still active, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doCreate\");\n+        }\n+    }\n+\n+    @Override\n+    public FHIRRestOperationResponse doPatch(String type, String id, FHIRPatch patch, String ifMatchValue,\n+            String searchQueryString, Map<String, String> requestProperties) throws Exception {\n+\n+        return doPatchOrUpdate(type, id, patch, null, ifMatchValue, searchQueryString, requestProperties);\n+    }\n+\n+    @Override\n+    public FHIRRestOperationResponse doUpdate(String type, String id, Resource newResource, String ifMatchValue,\n+            String searchQueryString, Map<String, String> requestProperties) throws Exception {\n+\n+        return doPatchOrUpdate(type, id, null, newResource, ifMatchValue, searchQueryString, requestProperties);\n+    }\n+\n+    private FHIRRestOperationResponse doPatchOrUpdate(String type, String id, FHIRPatch patch,\n+            Resource newResource, String ifMatchValue, String searchQueryString,\n+            Map<String, String> requestProperties) throws Exception {\n+        log.entering(this.getClass().getName(), \"doPatchOrUpdate\");\n+\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        FHIRRestOperationResponse ior = new FHIRRestOperationResponse();\n+\n+        try {\n+            // Make sure the type specified in the URL string matches the resource type obtained from the new resource.\n+            if (patch == null) {\n+                String resourceType =  ModelSupport.getTypeName(newResource.getClass());\n+                if (!resourceType.equals(type)) {\n+                    String msg = \"Resource type '\" + resourceType\n+                            + \"' does not match type specified in request URI: \" + type;\n+                    throw buildRestException(msg, IssueType.INVALID);\n+                }\n+            }\n+\n+            // Next, if a conditional update was invoked then use the search criteria to find the\n+            // resource to be updated. Otherwise, we'll use the id value to retrieve the current\n+            // version of the resource.\n+            if (searchQueryString != null) {\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Performing conditional update/patch with search criteria: \"\n+                            + Encode.forHtml(searchQueryString));\n+                }\n+                Bundle responseBundle = null;\n+                try {\n+                    MultivaluedMap<String, String> searchParameters =\n+                            getQueryParameterMap(searchQueryString);\n+                    responseBundle =\n+                            doSearch(type, null, null, searchParameters, null, requestProperties, newResource);\n+                } catch (FHIROperationException e) {\n+                    throw e;\n+                } catch (Throwable t) {\n+                    String msg =\n+                            \"An error occurred while performing the search for a conditional update/patch operation.\";\n+                    throw new FHIROperationException(msg, t);\n+                }\n+\n+                // Check the search results to determine whether or not to perform the update operation.\n+                int resultCount = responseBundle.getEntry().size();\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Conditional update/patch search yielded \" + resultCount + \" results.\");\n+                }\n+\n+                if (resultCount == 0) {\n+                    if (patch != null) {\n+                        String msg =\n+                                \"The search criteria specified for a conditional patch operation did not return any results.\";\n+                        throw buildRestException(msg, IssueType.NOT_FOUND);\n+                    }\n+                    // Search yielded no matches, so we'll do an update/create operation below.\n+                    ior.setPrevResource(null);\n+\n+                    // if no id provided, then generate an id for the input resource\n+                    if (newResource.getId() == null || newResource.getId() == null) {\n+                        id = UUID.randomUUID().toString();\n+                        newResource = newResource.toBuilder().id(id).build();\n+                    } else {\n+                        id = newResource.getId();\n+                    }\n+                } else if (resultCount == 1) {\n+                    // If we found a single match, then we'll perform a normal update on the matched resource.\n+                    ior.setPrevResource(responseBundle.getEntry().get(0).getResource());\n+                    id = ior.getPrevResource().getId();\n+\n+                    // If the id of the input resource is different from the id of the search result,\n+                    // then throw exception.\n+                    if (newResource.getId() != null && newResource.getId() != null\n+                            && !newResource.getId().equalsIgnoreCase(id)) {\n+                        String msg = \"Input resource 'id' attribute must match the id of the search result resource.\";\n+                        throw buildRestException(msg, IssueType.VALUE);\n+                    }\n+                    // Make sure the id of the newResource is not null and is the same as the id of the found resource.\n+                    newResource = newResource.toBuilder().id(id).build();\n+                } else {\n+                    String msg =\n+                            \"The search criteria specified for a conditional update/patch operation returned multiple matches.\";\n+                    throw buildRestException(msg, IssueType.MULTIPLE_MATCHES);\n+                }\n+            } else {\n+                // Make sure an id value was passed in.\n+                if (id == null) {\n+                    String msg = \"The 'id' parameter is required for an update/pach operation.\";\n+                    throw buildRestException(msg, IssueType.REQUIRED);\n+                }\n+\n+                // If an id value was passed in (i.e. the id specified in the REST API URL string),\n+                // then make sure it's the same as the value in the resource.\n+                if (patch == null) {\n+                    // Make sure the resource has an 'id' attribute.\n+                    if (newResource.getId() == null) {\n+                        String msg = \"Input resource must contain an 'id' attribute.\";\n+                        throw buildRestException(msg, IssueType.INVALID);\n+                    }\n+\n+                    if (!newResource.getId().equals(id)) {\n+                        String msg = \"Input resource 'id' attribute must match 'id' parameter.\";\n+                        throw buildRestException(msg, IssueType.VALUE);\n+                    }\n+                }\n+\n+                // Retrieve the resource to be updated using the type and id values.\n+                ior.setPrevResource(doRead(type, id, (patch != null), true, requestProperties, newResource));\n+            }\n+\n+            if (patch != null) {\n+                newResource = patch.apply(ior.getPrevResource());\n+            }\n+\n+            // Validate the input resource and return any validation errors.\n+            List<Issue> validationWarnings = validateInput(newResource);\n+            ior.setOperationOutcome(FHIRUtil.buildOperationOutcome(validationWarnings));\n+\n+            // Perform the \"version-aware\" update check, and also find out if the resource was deleted.\n+            boolean isDeleted = false;\n+            if (ior.getPrevResource() != null) {\n+                performVersionAwareUpdateCheck(ior.getPrevResource(), ifMatchValue);\n+\n+                try {\n+                    doRead(type, id, (patch != null), false, requestProperties, newResource);\n+                } catch (FHIRPersistenceResourceDeletedException e) {\n+                    isDeleted = true;\n+                }\n+            }\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, create the persistence event.\n+            FHIRPersistenceEvent event = new FHIRPersistenceEvent(newResource, \n+                    buildPersistenceEventProperties(type, newResource.getId(), null, requestProperties));\n+\n+            // Next, set the \"previous resource\" in the persistence event.\n+            event.setPrevFhirResource(ior.getPrevResource());\n+\n+            // Next, invoke the 'beforeUpdate' or 'beforeCreate' interceptor methods as appropriate.\n+            boolean updateCreate = (ior.getPrevResource() == null);\n+            if (updateCreate) {\n+                getInterceptorMgr().fireBeforeCreateEvent(event);\n+            } else {\n+                if (patch != null) {\n+                    event.getProperties().put(FHIRPersistenceEvent.PROPNAME_PATCH, patch);\n+                    getInterceptorMgr().fireBeforePatchEvent(event);\n+                } else {\n+                    getInterceptorMgr().fireBeforeUpdateEvent(event);\n+                }\n+            }\n+\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event);\n+            newResource = persistence.update(persistenceContext, id, newResource).getResource();\n+            event.setFhirResource(newResource); // update event with latest\n+            ior.setResource(newResource);\n+\n+            // Build our location URI and add it to the interceptor event structure since it is now known.\n+            ior.setLocationURI(FHIRUtil.buildLocationURI(ModelSupport.getTypeName(newResource.getClass()), newResource));\n+            event.getProperties().put(FHIRPersistenceEvent.PROPNAME_RESOURCE_LOCATION_URI, ior.getLocationURI().toString());\n+\n+            // Invoke the 'afterUpdate' interceptor methods.\n+            if (updateCreate) {\n+                ior.setStatus(Response.Status.CREATED);\n+                getInterceptorMgr().fireAfterCreateEvent(event);\n+            } else {\n+                ior.setStatus(Response.Status.OK);\n+                if (patch != null) {\n+                    getInterceptorMgr().fireAfterPatchEvent(event);\n+                } else {\n+                    getInterceptorMgr().fireAfterUpdateEvent(event);\n+                }\n+            }\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+\n+            // If the deleted resource is updated, then simply return 201 instead of 200 to pass Touchstone test.\n+            // We don't set the previous resource to null in above codes if the resource was deleted, otherwise\n+            // it will break the code logic of the resource versioning.\n+            if (isDeleted && ior.getStatus() == Response.Status.OK) {\n+                ior.setStatus(Response.Status.CREATED);\n+            }\n+\n+            return ior;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we still have a transaction at this point, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doPatchOrUpdate\");\n+        }\n+    }\n+\n+    /**\n+     * Performs a 'delete' operation on the specified resource.\n+     *\n+     * @param type\n+     *            the resource type associated with the Resource to be deleted\n+     * @param id\n+     *            the id of the Resource to be deleted\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return a FHIRRestOperationResponse that contains the results of the operation\n+     * @throws Exception\n+     */\n+    @Override\n+    public FHIRRestOperationResponse doDelete(String type, String id, String searchQueryString,\n+            Map<String, String> requestProperties) throws Exception {\n+        log.entering(this.getClass().getName(), \"doDelete\");\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+        Response.Status status = null;\n+\n+        FHIRRestOperationResponse ior = new FHIRRestOperationResponse();\n+\n+        try {\n+            String resourceTypeName = type;\n+            if (!ModelSupport.isResourceType(type)) {\n+                throw buildUnsupportedResourceTypeException(type, IssueType.NOT_SUPPORTED);\n+            }\n+\n+            Class<? extends Resource> resourceType =\n+                    getResourceType(resourceTypeName);\n+\n+            // Next, if a conditional delete was invoked then use the search criteria to find the\n+            // resource to be deleted. Otherwise, we'll use the id value to identify the resource\n+            // to be deleted.\n+            Resource resourceToDelete = null;\n+            if (searchQueryString != null) {\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Performing conditional delete with search criteria: \"\n+                            + Encode.forHtml(searchQueryString));\n+                }\n+                Bundle responseBundle = null;\n+                try {\n+                    MultivaluedMap<String, String> searchParameters =\n+                            getQueryParameterMap(searchQueryString);\n+                    responseBundle =\n+                            doSearch(type, null, null, searchParameters, null, requestProperties, null);\n+                } catch (FHIROperationException e) {\n+                    throw e;\n+                } catch (Throwable t) {\n+                    String msg =\n+                            \"An error occurred while performing the search for a conditional delete operation.\";\n+                    throw new FHIROperationException(msg, t);\n+                }\n+\n+                // Check the search results to determine whether or not to perform the update operation.\n+                int resultCount = responseBundle.getEntry().size();\n+                if (log.isLoggable(Level.FINE)) {\n+                    log.fine(\"Conditional delete search yielded \" + resultCount + \" results.\");\n+                }\n+\n+                if (resultCount == 0) {\n+                    // Search yielded no matches\n+                    String msg = \"Search criteria for a conditional delete operation yielded no matches.\";\n+                    if (log.isLoggable(Level.FINE)) {\n+                        log.fine(msg);\n+                    }\n+                    status = Response.Status.OK;\n+                    ior.setOperationOutcome(FHIRUtil.buildOperationOutcome(msg, IssueType.NOT_FOUND, IssueSeverity.WARNING));\n+                    ior.setStatus(status);\n+                    return ior;\n+                } else if (resultCount == 1) {\n+                    // If we found a single match, then we'll delete this one.\n+                    Resource resource = responseBundle.getEntry().get(0).getResource();\n+                    id = resource.getId();\n+                    resourceToDelete = resource;\n+                } else {\n+                    String msg =\n+                            \"The search criteria specified for a conditional delete operation returned multiple matches.\";\n+                    throw buildRestException(msg, IssueType.MULTIPLE_MATCHES);\n+                }\n+            } else {\n+                // Make sure an id value was passed in.\n+                if (id == null) {\n+                    String msg = \"The 'id' parameter is required for a delete operation.\";\n+                    throw buildRestException(msg, IssueType.REQUIRED);\n+                }\n+\n+                // Read the resource so it will be available to the beforeDelete interceptor methods.\n+                try {\n+                    resourceToDelete = doRead(type, id, false, false, requestProperties, null);\n+                } catch (FHIRPersistenceResourceDeletedException e) {\n+                    // Absorb this exception.\n+                    resourceToDelete = null;\n+                }\n+            }\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, invoke the 'beforeDelete' interceptor methods.\n+            FHIRPersistenceEvent event =\n+                    new FHIRPersistenceEvent(null, buildPersistenceEventProperties(type, id, null, requestProperties));\n+            event.setFhirResource(resourceToDelete);\n+            getInterceptorMgr().fireBeforeDeleteEvent(event);\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event);\n+\n+            Resource resource = persistence.delete(persistenceContext, resourceType, id).getResource();\n+            ior.setResource(resource);\n+            event.setFhirResource(resource);\n+            ior.setStatus(Response.Status.NO_CONTENT);\n+\n+            // Invoke the 'afterDelete' interceptor methods.\n+            getInterceptorMgr().fireAfterDeleteEvent(event);\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+            status = ior.getStatus();\n+\n+            return ior;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we previously started a transaction and it's still active, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doDelete\");\n+        }\n+    }\n+\n+    @Override\n+    public Resource doRead(String type, String id, boolean throwExcOnNull, boolean includeDeleted,\n+            Map<String, String> requestProperties, Resource contextResource) throws Exception {\n+        return doRead(type, id, throwExcOnNull, includeDeleted, requestProperties, contextResource, null);\n+    }\n+\n+    /**\n+     * Performs a 'read' operation to retrieve a Resource.\n+     *\n+     * @param type\n+     *            the resource type associated with the Resource to be retrieved\n+     * @param id\n+     *            the id of the Resource to be retrieved\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return the Resource\n+     * @throws Exception\n+     */\n+    @Override\n+    public Resource doRead(String type, String id, boolean throwExcOnNull, boolean includeDeleted,\n+            Map<String, String> requestProperties, Resource contextResource, MultivaluedMap<String, String> queryParameters)\n+            throws Exception {\n+        log.entering(this.getClass().getName(), \"doRead\");\n+\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+        Resource resource = null;\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+            String resourceTypeName = type;\n+            if (!ModelSupport.isResourceType(type)) {\n+                throw buildUnsupportedResourceTypeException(type, IssueType.NOT_SUPPORTED);\n+            }\n+\n+            Class<? extends Resource> resourceType = getResourceType(resourceTypeName);\n+\n+            FHIRSearchContext searchContext = null;\n+            if (queryParameters != null) {\n+                searchContext = SearchUtil.parseQueryParameters(null, null, resourceType, queryParameters, \n+                        HTTPHandlingPreference.LENIENT.equals(requestContext.getHandlingPreference()));\n+            }\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, invoke the 'beforeRead' interceptor methods.\n+            FHIRPersistenceEvent event =\n+                    new FHIRPersistenceEvent(contextResource, buildPersistenceEventProperties(type, id, null, requestProperties));\n+            getInterceptorMgr().fireBeforeReadEvent(event);\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event, includeDeleted, searchContext);\n+            resource = persistence.read(persistenceContext, resourceType, id).getResource();\n+            if (resource == null && throwExcOnNull) {\n+                throw new FHIRPersistenceResourceNotFoundException(\"Resource '\" + type + \"/\" + id + \"' not found.\");\n+            }\n+\n+            event.setFhirResource(resource);\n+\n+            // Invoke the 'afterRead' interceptor methods.\n+            getInterceptorMgr().fireAfterReadEvent(event);\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+\n+            return resource;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we previously started a transaction and it's still active, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doRead\");\n+        }\n+    }\n+\n+    /**\n+     * Performs a 'vread' operation by retrieving the specified version of a Resource.\n+     *\n+     * @param type\n+     *            the resource type associated with the Resource to be retrieved\n+     * @param id\n+     *            the id of the Resource to be retrieved\n+     * @param versionId\n+     *            the version id of the Resource to be retrieved\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return the Resource\n+     * @throws Exception\n+     */\n+    @Override\n+    public Resource doVRead(String type, String id, String versionId,\n+        Map<String, String> requestProperties) throws Exception {\n+        log.entering(this.getClass().getName(), \"doVRead\");\n+\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+        Resource resource = null;\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+            String resourceTypeName = type;\n+            if (!ModelSupport.isResourceType(type)) {\n+                throw buildUnsupportedResourceTypeException(type, IssueType.NOT_SUPPORTED);\n+            }\n+\n+            Class<? extends Resource> resourceType =\n+                    getResourceType(resourceTypeName);\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, invoke the 'beforeVread' interceptor methods.\n+            FHIRPersistenceEvent event =\n+                    new FHIRPersistenceEvent(null, buildPersistenceEventProperties(type, id, versionId, requestProperties));\n+            getInterceptorMgr().fireBeforeVreadEvent(event);\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event);\n+            resource = persistence.vread(persistenceContext, resourceType, id, versionId).getResource();\n+            if (resource == null) {\n+                throw new FHIRPersistenceResourceNotFoundException(\"Resource '\"\n+                        + resourceType.getSimpleName() + \"/\" + id + \"' version \" + versionId + \" not found.\");\n+            }\n+\n+            event.setFhirResource(resource);\n+\n+            // Invoke the 'afterVread' interceptor methods.\n+            getInterceptorMgr().fireAfterVreadEvent(event);\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+\n+            return resource;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we previously started a transaction and it's still active, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doVRead\");\n+        }\n+    }\n+\n+    /**\n+     * Performs the work of retrieving versions of a Resource.\n+     *\n+     * @param type\n+     *            the resource type associated with the Resource to be retrieved\n+     * @param id\n+     *            the id of the Resource to be retrieved\n+     * @param queryParameters\n+     *            a Map containing the query parameters from the request URL\n+     * @param requestUri the URI from the request\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return a Bundle containing the history of the specified Resource\n+     * @throws Exception\n+     */\n+    @Override\n+    public Bundle doHistory(String type, String id, MultivaluedMap<String, String> queryParameters,\n+        String requestUri, Map<String, String> requestProperties)\n+        throws Exception {\n+        log.entering(this.getClass().getName(), \"doHistory\");\n+\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+        Bundle bundle = null;\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+            String resourceTypeName = type;\n+            if (!ModelSupport.isResourceType(type)) {\n+                throw buildUnsupportedResourceTypeException(type, IssueType.NOT_SUPPORTED);\n+            }\n+\n+            Class<? extends Resource> resourceType =\n+                    getResourceType(resourceTypeName);\n+            FHIRHistoryContext historyContext =\n+                    FHIRPersistenceUtil.parseHistoryParameters(queryParameters, HTTPHandlingPreference.LENIENT.equals(requestContext.getHandlingPreference()));\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, invoke the 'beforeHistory' interceptor methods.\n+            FHIRPersistenceEvent event =\n+                    new FHIRPersistenceEvent(null, buildPersistenceEventProperties(type, id, null, requestProperties));\n+            getInterceptorMgr().fireBeforeHistoryEvent(event);\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event, historyContext);\n+            List<? extends Resource> resources =\n+                    persistence.history(persistenceContext, resourceType, id).getResource();\n+            bundle = createHistoryBundle(resources, historyContext, type);\n+            bundle = addLinks(historyContext, bundle, requestUri);\n+\n+            event.setFhirResource(bundle);\n+\n+            // Invoke the 'afterHistory' interceptor methods.\n+            getInterceptorMgr().fireAfterHistoryEvent(event);\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+\n+            return bundle;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we previously started a transaction and it's still active, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doHistory\");\n+        }\n+    }\n+\n+    /**\n+     * Performs heavy lifting associated with a 'search' operation.\n+     *\n+     * @param type\n+     *            the resource type associated with the search\n+     * @param queryParameters\n+     *            a Map containing the query parameters from the request URL\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return a Bundle containing the search result set\n+     * @throws Exception\n+     */\n+    @Override\n+    public Bundle doSearch(String type, String compartment, String compartmentId,\n+            MultivaluedMap<String, String> queryParameters, String requestUri,\n+            Map<String, String> requestProperties, Resource contextResource) throws Exception {\n+        log.entering(this.getClass().getName(), \"doSearch\");\n+\n+        FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction());\n+        Bundle bundle = null;\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+            String resourceTypeName = type;\n+\n+            // Check to see if it's supported, else, throw a bad request.\n+            // If this is removed, it'll result in nullpointer when processing the request\n+            if (!ModelSupport.isResourceType(type)) {\n+                throw buildUnsupportedResourceTypeException(type, IssueType.NOT_SUPPORTED);\n+            }\n+\n+            Class<? extends Resource> resourceType =\n+                    getResourceType(resourceTypeName);\n+\n+            // Start a new txn in the persistence layer if one is not already active.\n+            txn.begin();\n+\n+            // First, invoke the 'beforeSearch' interceptor methods.\n+            FHIRPersistenceEvent event =\n+                    new FHIRPersistenceEvent(contextResource, buildPersistenceEventProperties(type, null, null, requestProperties));\n+            getInterceptorMgr().fireBeforeSearchEvent(event);\n+\n+            FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(compartment, compartmentId, resourceType, queryParameters,\n+                    HTTPHandlingPreference.LENIENT.equals(requestContext.getHandlingPreference()));\n+\n+            FHIRPersistenceContext persistenceContext =\n+                    FHIRPersistenceContextFactory.createPersistenceContext(event, searchContext);\n+            List<Resource> resources =\n+                    persistence.search(persistenceContext, resourceType).getResource();\n+\n+            bundle = createSearchBundle(resources, searchContext, type);\n+            if (requestUri != null) {\n+                bundle = addLinks(searchContext, bundle, requestUri);\n+            }\n+            event.setFhirResource(bundle);\n+\n+            // Invoke the 'afterSearch' interceptor methods.\n+            getInterceptorMgr().fireAfterSearchEvent(event);\n+\n+            // Commit our transaction if we started one before.\n+            txn.commit();\n+            txn = null;\n+\n+            return bundle;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            // If we previously started a transaction and it's still active, we need to rollback due to an error.\n+            if (txn != null) {\n+                txn.rollback();\n+            }\n+\n+            log.exiting(this.getClass().getName(), \"doSearch\");\n+        }\n+    }\n+\n+    /**\n+     * Helper method which invokes a custom operation.\n+     *\n+     * @param operationContext\n+     *            the FHIROperationContext associated with the request\n+     * @param resourceTypeName\n+     *            the resource type associated with the request\n+     * @param logicalId\n+     *            the resource logical id associated with the request\n+     * @param versionId\n+     *            the resource version id associated with the request\n+     * @param operationName\n+     *            the name of the custom operation to be invoked\n+     * @param resource\n+     *            the input resource associated with the custom operation to be invoked\n+     * @param queryParameters\n+     *            query parameters may be passed instead of a Parameters resource for certain custom operations invoked\n+     *            via GET\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return a Resource that represents the response to the custom operation\n+     * @throws Exception\n+     */\n+    @Override\n+    public Resource doInvoke(FHIROperationContext operationContext, String resourceTypeName,\n+            String logicalId, String versionId, String operationName,\n+            Resource resource, MultivaluedMap<String, String> queryParameters,\n+            Map<String, String> requestProperties) throws Exception {\n+        log.entering(this.getClass().getName(), \"doInvoke\");\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+            Class<? extends Resource> resourceType = null;\n+            if (resourceTypeName != null) {\n+                resourceType = getResourceType(resourceTypeName);\n+            }\n+            String operationKey = (resourceTypeName == null ? operationName : operationName + \":\" + resourceTypeName);\n+\n+            FHIROperation operation =\n+                    FHIROperationRegistry.getInstance().getOperation(operationKey);\n+            Parameters parameters = null;\n+            if (resource instanceof Parameters) {\n+                parameters = (Parameters) resource;\n+            } else {\n+                if (resource == null) {\n+                    // build parameters object from query parameters\n+                    parameters =\n+                            FHIROperationUtil.getInputParameters(operation.getDefinition(), queryParameters);\n+                } else {\n+                    // wrap resource in a parameters object\n+                    parameters =\n+                            FHIROperationUtil.getInputParameters(operation.getDefinition(), resource);\n+                }\n+            }\n+\n+            // Add properties to the FHIR operation context\n+            setOperationContextProperties(operationContext, resourceTypeName, requestProperties);\n+\n+            if (log.isLoggable(Level.FINE)) {\n+                log.fine(\"Invoking operation '\" + operationName + \"', context=\\n\"\n+                        + operationContext.toString());\n+            }\n+            Parameters result =\n+                    operation.invoke(operationContext, resourceType, logicalId, versionId, parameters, this);\n+            if (log.isLoggable(Level.FINE)) {\n+                log.fine(\"Returned from invocation of operation '\" + operationName + \"'...\");\n+            }\n+\n+            // if single resource output parameter, return the resource\n+            if (FHIROperationUtil.hasSingleResourceOutputParameter(result)) {\n+                return FHIROperationUtil.getSingleResourceOutputParameter(result);\n+            }\n+\n+            return result;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            log.exiting(this.getClass().getName(), \"doInvoke\");\n+        }\n+    }\n+\n+    /**\n+     * Processes a bundled request.\n+     *\n+     * @param bundleResource\n+     *            the request Bundle\n+     * @param requestProperties\n+     *            additional request properties which supplement the HTTP headers associated with this request\n+     * @return the response Bundle\n+     */\n+    @Override\n+    public Bundle doBundle(Resource bundleResource, Map<String, String> requestProperties)\n+        throws Exception {\n+        log.entering(this.getClass().getName(), \"doBundle\");\n+        Bundle inputBundle = null;\n+\n+        // Save the current request context.\n+        FHIRRequestContext requestContext = FHIRRequestContext.get();\n+\n+        try {\n+            if (bundleResource instanceof Bundle) {\n+                inputBundle = (Bundle) bundleResource;\n+            } else {\n+                String msg = \"A 'Bundle' resource type is required but a '\"\n+                        + bundleResource.getClass().getSimpleName() + \"' resource type was sent.\";\n+                throw buildRestException(msg, IssueType.INVALID);\n+            }\n+            // First, validate the bundle and create the response bundle.\n+            Bundle responseBundle = validateBundle(inputBundle);\n+\n+            // Next, process each of the entries in the bundle.\n+            responseBundle = processBundleEntries(inputBundle, responseBundle, requestProperties);\n+\n+            return responseBundle;\n+        } finally {\n+            // Restore the original request context.\n+            FHIRRequestContext.set(requestContext);\n+\n+            log.exiting(this.getClass().getName(), \"doBundle\");\n+        }\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * @see com.ibm.fhir.rest.FHIRResourceHelpers#getTransaction()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI0MDAxMA=="}, "originalCommit": {"oid": "d0ff4daa4297bea3aff6025eac16697c3fe6ecb1"}, "originalPosition": 1040}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNTg1OTg3OnYy", "diffSide": "RIGHT", "path": "fhir-audit/src/main/java/com/ibm/fhir/audit/logging/impl/WhcAuditCadfLogService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxNDoyMTo0NFrOFyVWtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxNToyOToyMFrOFyYJBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODMyMjk5OA==", "bodyText": "do we need a more valid versionUID?", "url": "https://github.com/IBM/FHIR/pull/759#discussion_r388322998", "createdAt": "2020-03-05T14:21:44Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-audit/src/main/java/com/ibm/fhir/audit/logging/impl/WhcAuditCadfLogService.java", "diffHunk": "@@ -69,22 +69,22 @@\n     private boolean isEnabled = false;\n \n     private static final Map<String, Action> fhir2CadfMap = new HashMap<String, Action>() {\n-\n         private static final long serialVersionUID = 1L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98d226d48bb0c522285aff3aa2b3c33b9c3b5c07"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODM2ODY0Ng==", "bodyText": "this is not something i changed.  paul had a similar comment on a different class, but i'm \"meh\"", "url": "https://github.com/IBM/FHIR/pull/759#discussion_r388368646", "createdAt": "2020-03-05T15:29:20Z", "author": {"login": "lmsurpre"}, "path": "fhir-audit/src/main/java/com/ibm/fhir/audit/logging/impl/WhcAuditCadfLogService.java", "diffHunk": "@@ -69,22 +69,22 @@\n     private boolean isEnabled = false;\n \n     private static final Map<String, Action> fhir2CadfMap = new HashMap<String, Action>() {\n-\n         private static final long serialVersionUID = 1L;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODMyMjk5OA=="}, "originalCommit": {"oid": "98d226d48bb0c522285aff3aa2b3c33b9c3b5c07"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNTg4NzQ1OnYy", "diffSide": "LEFT", "path": "fhir-notification/src/main/java/com/ibm/fhir/notification/FHIRNotificationEvent.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxNDoyODoyOVrOFyVn9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNjo1NDo1MFrOFzw9qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODMyNzQxMg==", "bodyText": "need to understand why the http headers were put into the notification event, maybe the design was to keep all info in the request header including browser agent info, cookies and with all the fhir headers for better analytics later ...", "url": "https://github.com/IBM/FHIR/pull/759#discussion_r388327412", "createdAt": "2020-03-05T14:28:29Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-notification/src/main/java/com/ibm/fhir/notification/FHIRNotificationEvent.java", "diffHunk": "@@ -73,12 +69,4 @@ public Resource getResource() {\n     public void setResource(Resource resource) {\n         this.resource = resource;\n     }\n-\n-    public HttpHeaders getHttpHeaders() {\n-        return this.httpHeaders;\n-    }\n-\n-    public void setHttpHeaders(HttpHeaders httpHeaders) {\n-        this.httpHeaders = httpHeaders;\n-    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98d226d48bb0c522285aff3aa2b3c33b9c3b5c07"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODM2OTMwMQ==", "bodyText": "IMHO the notification stuff needs some significant reworking.  With some effort I could add the HttpHeaders back in, but IMHO they don't really belong.", "url": "https://github.com/IBM/FHIR/pull/759#discussion_r388369301", "createdAt": "2020-03-05T15:30:21Z", "author": {"login": "lmsurpre"}, "path": "fhir-notification/src/main/java/com/ibm/fhir/notification/FHIRNotificationEvent.java", "diffHunk": "@@ -73,12 +69,4 @@ public Resource getResource() {\n     public void setResource(Resource resource) {\n         this.resource = resource;\n     }\n-\n-    public HttpHeaders getHttpHeaders() {\n-        return this.httpHeaders;\n-    }\n-\n-    public void setHttpHeaders(HttpHeaders httpHeaders) {\n-        this.httpHeaders = httpHeaders;\n-    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODMyNzQxMg=="}, "originalCommit": {"oid": "98d226d48bb0c522285aff3aa2b3c33b9c3b5c07"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODM3OTQ3MA==", "bodyText": "If we have a flow that takes and HTTP request and ultimately lands it on a Kafka queue (for example), then some of the contextual HTTP request information may be valuable downstream.", "url": "https://github.com/IBM/FHIR/pull/759#discussion_r388379470", "createdAt": "2020-03-05T15:45:25Z", "author": {"login": "JohnTimm"}, "path": "fhir-notification/src/main/java/com/ibm/fhir/notification/FHIRNotificationEvent.java", "diffHunk": "@@ -73,12 +69,4 @@ public Resource getResource() {\n     public void setResource(Resource resource) {\n         this.resource = resource;\n     }\n-\n-    public HttpHeaders getHttpHeaders() {\n-        return this.httpHeaders;\n-    }\n-\n-    public void setHttpHeaders(HttpHeaders httpHeaders) {\n-        this.httpHeaders = httpHeaders;\n-    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODMyNzQxMg=="}, "originalCommit": {"oid": "98d226d48bb0c522285aff3aa2b3c33b9c3b5c07"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgyMzkxNQ==", "bodyText": "I prefer to leave it off for now.  Per our discussion on Friday, I think we agreed that is OK.  If not, please re-open.", "url": "https://github.com/IBM/FHIR/pull/759#discussion_r389823915", "createdAt": "2020-03-09T16:54:50Z", "author": {"login": "lmsurpre"}, "path": "fhir-notification/src/main/java/com/ibm/fhir/notification/FHIRNotificationEvent.java", "diffHunk": "@@ -73,12 +69,4 @@ public Resource getResource() {\n     public void setResource(Resource resource) {\n         this.resource = resource;\n     }\n-\n-    public HttpHeaders getHttpHeaders() {\n-        return this.httpHeaders;\n-    }\n-\n-    public void setHttpHeaders(HttpHeaders httpHeaders) {\n-        this.httpHeaders = httpHeaders;\n-    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODMyNzQxMg=="}, "originalCommit": {"oid": "98d226d48bb0c522285aff3aa2b3c33b9c3b5c07"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNTkwMDU0OnYy", "diffSide": "RIGHT", "path": "fhir-operation-document/src/main/java/com/ibm/fhir/operation/document/DocumentOperation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxNDozMTozNlrOFyVwEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxNTozMToxOFrOFyYOGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODMyOTQ5MQ==", "bodyText": "it's weird to find that spaces are added from time to time to the files, my eclipse has save action to remove the spaces at the line end, but sometime when I edit the same file again, I can still see spaces at the same file... really strange ...", "url": "https://github.com/IBM/FHIR/pull/759#discussion_r388329491", "createdAt": "2020-03-05T14:31:36Z", "author": {"login": "albertwang-ibm"}, "path": "fhir-operation-document/src/main/java/com/ibm/fhir/operation/document/DocumentOperation.java", "diffHunk": "@@ -61,7 +61,7 @@ protected Parameters doInvoke(FHIROperationContext operationContext, Class<? ext\n             \n             composition = (Composition) resource;\n             \n-            Bundle bundle = buildDocument(operationContext, composition, resourceHelper);            \n+            Bundle bundle = buildDocument(operationContext, composition, resourceHelper);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98d226d48bb0c522285aff3aa2b3c33b9c3b5c07"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODM2OTk0Ng==", "bodyText": "Yeah, I just clean it up when I see it.  Probably should have left out of a big PR like this, but too much energy to dance around it once I've made the local change.", "url": "https://github.com/IBM/FHIR/pull/759#discussion_r388369946", "createdAt": "2020-03-05T15:31:18Z", "author": {"login": "lmsurpre"}, "path": "fhir-operation-document/src/main/java/com/ibm/fhir/operation/document/DocumentOperation.java", "diffHunk": "@@ -61,7 +61,7 @@ protected Parameters doInvoke(FHIROperationContext operationContext, Class<? ext\n             \n             composition = (Composition) resource;\n             \n-            Bundle bundle = buildDocument(operationContext, composition, resourceHelper);            \n+            Bundle bundle = buildDocument(operationContext, composition, resourceHelper);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODMyOTQ5MQ=="}, "originalCommit": {"oid": "98d226d48bb0c522285aff3aa2b3c33b9c3b5c07"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwOTQ4OTkzOnYy", "diffSide": "RIGHT", "path": "fhir-server/src/main/java/com/ibm/fhir/server/resources/FHIRResource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxMjo1NjowM1rOFy3xrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNjo0MTo1MFrOFzwd4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg4Njk1Ng==", "bodyText": "repeated pattern... seems like an enum and a single method may be best.", "url": "https://github.com/IBM/FHIR/pull/759#discussion_r388886956", "createdAt": "2020-03-06T12:56:03Z", "author": {"login": "prb112"}, "path": "fhir-server/src/main/java/com/ibm/fhir/server/resources/FHIRResource.java", "diffHunk": "@@ -468,13 +472,25 @@ public Response patch(@PathParam(\"type\") String type, @PathParam(\"id\") String id\n             response = addHeaders(response, resource);\n             return response.build();\n         } catch (FHIRPersistenceResourceNotFoundException e) {\n-            return exceptionResponse(e, Response.Status.METHOD_NOT_ALLOWED);\n+            status = Status.METHOD_NOT_ALLOWED;\n+            return exceptionResponse(e, status);\n         } catch (FHIROperationException e) {\n-            return exceptionResponse(e);\n+            status = issueListToStatus(e.getIssues());\n+            return exceptionResponse(e, status);\n         } catch (Exception e) {\n-            return exceptionResponse(e, Response.Status.INTERNAL_SERVER_ERROR);\n+            status = Status.INTERNAL_SERVER_ERROR;\n+            return exceptionResponse(e, status);\n         } finally {\n-            log.exiting(this.getClass().getName(), \"patch(String,String,JsonArray)\");\n+            try {\n+                RestAuditLogger.logPatch(httpServletRequest,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58c739c2bebb0729a2e56761b506d255dd0d618f"}, "originalPosition": 429}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgxNTc3Nw==", "bodyText": "will not refactor this for this PR...it can get revisited later", "url": "https://github.com/IBM/FHIR/pull/759#discussion_r389815777", "createdAt": "2020-03-09T16:41:50Z", "author": {"login": "lmsurpre"}, "path": "fhir-server/src/main/java/com/ibm/fhir/server/resources/FHIRResource.java", "diffHunk": "@@ -468,13 +472,25 @@ public Response patch(@PathParam(\"type\") String type, @PathParam(\"id\") String id\n             response = addHeaders(response, resource);\n             return response.build();\n         } catch (FHIRPersistenceResourceNotFoundException e) {\n-            return exceptionResponse(e, Response.Status.METHOD_NOT_ALLOWED);\n+            status = Status.METHOD_NOT_ALLOWED;\n+            return exceptionResponse(e, status);\n         } catch (FHIROperationException e) {\n-            return exceptionResponse(e);\n+            status = issueListToStatus(e.getIssues());\n+            return exceptionResponse(e, status);\n         } catch (Exception e) {\n-            return exceptionResponse(e, Response.Status.INTERNAL_SERVER_ERROR);\n+            status = Status.INTERNAL_SERVER_ERROR;\n+            return exceptionResponse(e, status);\n         } finally {\n-            log.exiting(this.getClass().getName(), \"patch(String,String,JsonArray)\");\n+            try {\n+                RestAuditLogger.logPatch(httpServletRequest,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg4Njk1Ng=="}, "originalCommit": {"oid": "58c739c2bebb0729a2e56761b506d255dd0d618f"}, "originalPosition": 429}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNTcyOTExOnYy", "diffSide": "RIGHT", "path": "fhir-search/src/main/java/com/ibm/fhir/search/parameters/ParametersUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNjo1OToxMFrOFzxI1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNjo1OToxMFrOFzxI1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgyNjc3NQ==", "bodyText": "copyright", "url": "https://github.com/IBM/FHIR/pull/759#discussion_r389826775", "createdAt": "2020-03-09T16:59:10Z", "author": {"login": "prb112"}, "path": "fhir-search/src/main/java/com/ibm/fhir/search/parameters/ParametersUtil.java", "diffHunk": "@@ -166,7 +166,7 @@ static void checkAndWarnForIssueWithCodeAndName(String code, String name) {\n         // Code is the code used in the URL or the parameter name in a parameters resource for this search parameter.\n         // @see https://www.hl7.org/fhir/searchparameter-definitions.html#SearchParameter.code", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deda4c8057805a349217adde10f02f53c77ba6de"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNTczMTY0OnYy", "diffSide": "RIGHT", "path": "fhir-server/src/main/java/com/ibm/fhir/server/FHIRApplication.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNjo1OTo0OVrOFzxKdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNjo1OTo0OVrOFzxKdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgyNzE5MA==", "bodyText": "copyright", "url": "https://github.com/IBM/FHIR/pull/759#discussion_r389827190", "createdAt": "2020-03-09T16:59:49Z", "author": {"login": "prb112"}, "path": "fhir-server/src/main/java/com/ibm/fhir/server/FHIRApplication.java", "diffHunk": "@@ -16,7 +16,17 @@\n import com.ibm.fhir.provider.FHIRJsonPatchProvider;\n import com.ibm.fhir.provider.FHIRJsonProvider;\n import com.ibm.fhir.provider.FHIRProvider;\n-import com.ibm.fhir.server.resources.FHIRResource;\n+import com.ibm.fhir.server.resources.Batch;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deda4c8057805a349217adde10f02f53c77ba6de"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNTczNDAyOnYy", "diffSide": "RIGHT", "path": "fhir-server/src/main/java/com/ibm/fhir/server/filter/rest/FHIRRestServletFilter.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNzowMDozMVrOFzxL-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxODozMToyNlrOFz0gng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgyNzU3Ng==", "bodyText": "double semicolon", "url": "https://github.com/IBM/FHIR/pull/759#discussion_r389827576", "createdAt": "2020-03-09T17:00:31Z", "author": {"login": "prb112"}, "path": "fhir-server/src/main/java/com/ibm/fhir/server/filter/rest/FHIRRestServletFilter.java", "diffHunk": "@@ -185,6 +193,20 @@ public void doFilter(HttpServletRequest request, HttpServletResponse response, F\n         }\n     }\n \n+    /**\n+     * @return a map of HTTP request headers, keyed by header name\n+     */\n+    private Map<String, List<String>> extractRequestHeaders(HttpServletRequest request) {\n+        Map<String, List<String>> requestHeaders = new HashMap<String, List<String>>();\n+\n+        List<String> headerNames = Collections.list(request.getHeaderNames());\n+        for (String headerName : headerNames) {\n+            requestHeaders.put(headerName, Collections.list(request.getHeaders(headerName)));;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deda4c8057805a349217adde10f02f53c77ba6de"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgyODY3NA==", "bodyText": "This feels redundant", "url": "https://github.com/IBM/FHIR/pull/759#discussion_r389828674", "createdAt": "2020-03-09T17:02:12Z", "author": {"login": "prb112"}, "path": "fhir-server/src/main/java/com/ibm/fhir/server/filter/rest/FHIRRestServletFilter.java", "diffHunk": "@@ -185,6 +193,20 @@ public void doFilter(HttpServletRequest request, HttpServletResponse response, F\n         }\n     }\n \n+    /**\n+     * @return a map of HTTP request headers, keyed by header name\n+     */\n+    private Map<String, List<String>> extractRequestHeaders(HttpServletRequest request) {\n+        Map<String, List<String>> requestHeaders = new HashMap<String, List<String>>();\n+\n+        List<String> headerNames = Collections.list(request.getHeaderNames());\n+        for (String headerName : headerNames) {\n+            requestHeaders.put(headerName, Collections.list(request.getHeaders(headerName)));;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgyNzU3Ng=="}, "originalCommit": {"oid": "deda4c8057805a349217adde10f02f53c77ba6de"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg4MDUyMA==", "bodyText": "thx, good catch", "url": "https://github.com/IBM/FHIR/pull/759#discussion_r389880520", "createdAt": "2020-03-09T18:28:37Z", "author": {"login": "lmsurpre"}, "path": "fhir-server/src/main/java/com/ibm/fhir/server/filter/rest/FHIRRestServletFilter.java", "diffHunk": "@@ -185,6 +193,20 @@ public void doFilter(HttpServletRequest request, HttpServletResponse response, F\n         }\n     }\n \n+    /**\n+     * @return a map of HTTP request headers, keyed by header name\n+     */\n+    private Map<String, List<String>> extractRequestHeaders(HttpServletRequest request) {\n+        Map<String, List<String>> requestHeaders = new HashMap<String, List<String>>();\n+\n+        List<String> headerNames = Collections.list(request.getHeaderNames());\n+        for (String headerName : headerNames) {\n+            requestHeaders.put(headerName, Collections.list(request.getHeaders(headerName)));;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgyNzU3Ng=="}, "originalCommit": {"oid": "deda4c8057805a349217adde10f02f53c77ba6de"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg4MjAxNA==", "bodyText": "fixed", "url": "https://github.com/IBM/FHIR/pull/759#discussion_r389882014", "createdAt": "2020-03-09T18:31:26Z", "author": {"login": "lmsurpre"}, "path": "fhir-server/src/main/java/com/ibm/fhir/server/filter/rest/FHIRRestServletFilter.java", "diffHunk": "@@ -185,6 +193,20 @@ public void doFilter(HttpServletRequest request, HttpServletResponse response, F\n         }\n     }\n \n+    /**\n+     * @return a map of HTTP request headers, keyed by header name\n+     */\n+    private Map<String, List<String>> extractRequestHeaders(HttpServletRequest request) {\n+        Map<String, List<String>> requestHeaders = new HashMap<String, List<String>>();\n+\n+        List<String> headerNames = Collections.list(request.getHeaderNames());\n+        for (String headerName : headerNames) {\n+            requestHeaders.put(headerName, Collections.list(request.getHeaders(headerName)));;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgyNzU3Ng=="}, "originalCommit": {"oid": "deda4c8057805a349217adde10f02f53c77ba6de"}, "originalPosition": 34}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 85, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}