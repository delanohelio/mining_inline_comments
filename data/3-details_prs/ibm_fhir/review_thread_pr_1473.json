{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc3OTIzODE0", "number": 1473, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNzoxMzoyM1rOEfjYgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNzoyNDo1NFrOEfjprA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNTIxMDI3OnYy", "diffSide": "RIGHT", "path": "fhir-tools/src/main/java/com/ibm/fhir/tools/CodeGenerator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNzoxMzoyM1rOHL5RHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNzo1MTo1NlrOHL6qJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIzNDY1Mw==", "bodyText": "typo on 'contraint'", "url": "https://github.com/IBM/FHIR/pull/1473#discussion_r482234653", "createdAt": "2020-09-02T17:13:23Z", "author": {"login": "michaelwschroeder"}, "path": "fhir-tools/src/main/java/com/ibm/fhir/tools/CodeGenerator.java", "diffHunk": "@@ -1475,6 +1477,154 @@ public int compare(JsonObject first, JsonObject second) {\n             }\n             cb.annotation(\"Constraint\", valueMap);\n         }\n+                \n+        // Generate constraint annotations from extensible and preferred bindings\n+        generateVocabularyConstraints(structureDefinition, cb, className, lastId);\n+    }\n+    \n+    /**\n+     * Generates constraint annotations from extensible and preferred bindings.\n+     * \n+     * @param structureDefinition\n+     *            the structure definition\n+     * @param cb\n+     *            the code builder\n+     * @param className\n+     *            the class name\n+     * @param lastId\n+     *            the ID of the last contraint", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b4fc8a6babefca74f548b595a923cdf12900ddf"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI1NzQ0Nw==", "bodyText": "Fixed.", "url": "https://github.com/IBM/FHIR/pull/1473#discussion_r482257447", "createdAt": "2020-09-02T17:51:56Z", "author": {"login": "tbieste"}, "path": "fhir-tools/src/main/java/com/ibm/fhir/tools/CodeGenerator.java", "diffHunk": "@@ -1475,6 +1477,154 @@ public int compare(JsonObject first, JsonObject second) {\n             }\n             cb.annotation(\"Constraint\", valueMap);\n         }\n+                \n+        // Generate constraint annotations from extensible and preferred bindings\n+        generateVocabularyConstraints(structureDefinition, cb, className, lastId);\n+    }\n+    \n+    /**\n+     * Generates constraint annotations from extensible and preferred bindings.\n+     * \n+     * @param structureDefinition\n+     *            the structure definition\n+     * @param cb\n+     *            the code builder\n+     * @param className\n+     *            the class name\n+     * @param lastId\n+     *            the ID of the last contraint", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIzNDY1Mw=="}, "originalCommit": {"oid": "1b4fc8a6babefca74f548b595a923cdf12900ddf"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNTIzNDE1OnYy", "diffSide": "RIGHT", "path": "fhir-tools/src/main/java/com/ibm/fhir/tools/CodeGenerator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNzoxOToxOVrOHL5gpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNzo1NDowNFrOHL6utA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIzODYzMA==", "bodyText": "wondering if you need the 'at least' part in the description - I think 'SHALL, if possible, contain a code from value set' and 'SHOULD contain a code from value set' works", "url": "https://github.com/IBM/FHIR/pull/1473#discussion_r482238630", "createdAt": "2020-09-02T17:19:19Z", "author": {"login": "michaelwschroeder"}, "path": "fhir-tools/src/main/java/com/ibm/fhir/tools/CodeGenerator.java", "diffHunk": "@@ -1475,6 +1477,154 @@ public int compare(JsonObject first, JsonObject second) {\n             }\n             cb.annotation(\"Constraint\", valueMap);\n         }\n+                \n+        // Generate constraint annotations from extensible and preferred bindings\n+        generateVocabularyConstraints(structureDefinition, cb, className, lastId);\n+    }\n+    \n+    /**\n+     * Generates constraint annotations from extensible and preferred bindings.\n+     * \n+     * @param structureDefinition\n+     *            the structure definition\n+     * @param cb\n+     *            the code builder\n+     * @param className\n+     *            the class name\n+     * @param lastId\n+     *            the ID of the last contraint\n+     */\n+    private void generateVocabularyConstraints(JsonObject structureDefinition, CodeBuilder cb, String className, String lastId) {\n+\n+        // Collect elements that have an extensible or preferred binding\n+        for (JsonObject elementDefinition : getElementDefinitions(structureDefinition).stream().filter(e -> !isProhibited(e)).filter(e -> hasExtensibleBinding(e)\n+                || hasPreferredBinding(e)).collect(Collectors.toList())) {\n+\n+            String path = elementDefinition.getString(\"path\");\n+            String elementName = getElementNameWithoutPrefix(elementDefinition, path, className);\n+            JsonObject binding = getBinding(elementDefinition);\n+            String location = elementName.contains(\".\") ? elementName.replace(\".div\", \".`div`\").replace(\"[x]\", \"\") : \"(base)\";\n+            String expressionElementName = \"(base)\".equals(location) ? elementName : \"$this\";\n+\n+            // Generate constraint for value set binding\n+            String valueSet = binding.getString(\"valueSet\", null);\n+            if (valueSet != null) {\n+                lastId = generateNextConstraintId(lastId, className);\n+\n+                String level = \"Warning\";\n+                String description = (hasExtensibleBinding(elementDefinition) ? \"SHALL, if possible, at least contain a code from value set \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b4fc8a6babefca74f548b595a923cdf12900ddf"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI1ODYxMg==", "bodyText": "I can remove the words \"at least\".", "url": "https://github.com/IBM/FHIR/pull/1473#discussion_r482258612", "createdAt": "2020-09-02T17:54:04Z", "author": {"login": "tbieste"}, "path": "fhir-tools/src/main/java/com/ibm/fhir/tools/CodeGenerator.java", "diffHunk": "@@ -1475,6 +1477,154 @@ public int compare(JsonObject first, JsonObject second) {\n             }\n             cb.annotation(\"Constraint\", valueMap);\n         }\n+                \n+        // Generate constraint annotations from extensible and preferred bindings\n+        generateVocabularyConstraints(structureDefinition, cb, className, lastId);\n+    }\n+    \n+    /**\n+     * Generates constraint annotations from extensible and preferred bindings.\n+     * \n+     * @param structureDefinition\n+     *            the structure definition\n+     * @param cb\n+     *            the code builder\n+     * @param className\n+     *            the class name\n+     * @param lastId\n+     *            the ID of the last contraint\n+     */\n+    private void generateVocabularyConstraints(JsonObject structureDefinition, CodeBuilder cb, String className, String lastId) {\n+\n+        // Collect elements that have an extensible or preferred binding\n+        for (JsonObject elementDefinition : getElementDefinitions(structureDefinition).stream().filter(e -> !isProhibited(e)).filter(e -> hasExtensibleBinding(e)\n+                || hasPreferredBinding(e)).collect(Collectors.toList())) {\n+\n+            String path = elementDefinition.getString(\"path\");\n+            String elementName = getElementNameWithoutPrefix(elementDefinition, path, className);\n+            JsonObject binding = getBinding(elementDefinition);\n+            String location = elementName.contains(\".\") ? elementName.replace(\".div\", \".`div`\").replace(\"[x]\", \"\") : \"(base)\";\n+            String expressionElementName = \"(base)\".equals(location) ? elementName : \"$this\";\n+\n+            // Generate constraint for value set binding\n+            String valueSet = binding.getString(\"valueSet\", null);\n+            if (valueSet != null) {\n+                lastId = generateNextConstraintId(lastId, className);\n+\n+                String level = \"Warning\";\n+                String description = (hasExtensibleBinding(elementDefinition) ? \"SHALL, if possible, at least contain a code from value set \"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIzODYzMA=="}, "originalCommit": {"oid": "1b4fc8a6babefca74f548b595a923cdf12900ddf"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNTI1NDIwOnYy", "diffSide": "RIGHT", "path": "fhir-tools/src/main/java/com/ibm/fhir/tools/CodeGenerator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNzoyNDo1NFrOHL5tNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNzo1MjozOFrOHL6rvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI0MTg0Ng==", "bodyText": "remove 'any of' before 'the structure definition'", "url": "https://github.com/IBM/FHIR/pull/1473#discussion_r482241846", "createdAt": "2020-09-02T17:24:54Z", "author": {"login": "michaelwschroeder"}, "path": "fhir-tools/src/main/java/com/ibm/fhir/tools/CodeGenerator.java", "diffHunk": "@@ -1475,6 +1477,154 @@ public int compare(JsonObject first, JsonObject second) {\n             }\n             cb.annotation(\"Constraint\", valueMap);\n         }\n+                \n+        // Generate constraint annotations from extensible and preferred bindings\n+        generateVocabularyConstraints(structureDefinition, cb, className, lastId);\n+    }\n+    \n+    /**\n+     * Generates constraint annotations from extensible and preferred bindings.\n+     * \n+     * @param structureDefinition\n+     *            the structure definition\n+     * @param cb\n+     *            the code builder\n+     * @param className\n+     *            the class name\n+     * @param lastId\n+     *            the ID of the last contraint\n+     */\n+    private void generateVocabularyConstraints(JsonObject structureDefinition, CodeBuilder cb, String className, String lastId) {\n+\n+        // Collect elements that have an extensible or preferred binding\n+        for (JsonObject elementDefinition : getElementDefinitions(structureDefinition).stream().filter(e -> !isProhibited(e)).filter(e -> hasExtensibleBinding(e)\n+                || hasPreferredBinding(e)).collect(Collectors.toList())) {\n+\n+            String path = elementDefinition.getString(\"path\");\n+            String elementName = getElementNameWithoutPrefix(elementDefinition, path, className);\n+            JsonObject binding = getBinding(elementDefinition);\n+            String location = elementName.contains(\".\") ? elementName.replace(\".div\", \".`div`\").replace(\"[x]\", \"\") : \"(base)\";\n+            String expressionElementName = \"(base)\".equals(location) ? elementName : \"$this\";\n+\n+            // Generate constraint for value set binding\n+            String valueSet = binding.getString(\"valueSet\", null);\n+            if (valueSet != null) {\n+                lastId = generateNextConstraintId(lastId, className);\n+\n+                String level = \"Warning\";\n+                String description = (hasExtensibleBinding(elementDefinition) ? \"SHALL, if possible, at least contain a code from value set \"\n+                        : \"SHOULD at least contain a code from value set \") + valueSet;\n+                String strength = binding.getString(\"strength\");\n+                String expression = generateVocabularyConstraintExpression(elementDefinition, expressionElementName, valueSet, strength);\n+\n+                Map<String, String> valueMap = new LinkedHashMap<>();\n+                valueMap.put(\"id\", quote(lastId));\n+                valueMap.put(\"level\", quote(level));\n+                valueMap.put(\"location\", quote(location));\n+                valueMap.put(\"description\", quote(description));\n+                valueMap.put(\"expression\", quote(expression));\n+                cb.annotation(\"Constraint\", valueMap);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Generates the FHIRPath expression for the constraint.\n+     * \n+     * @param elementDefinition\n+     *            the element definition\n+     * @param elementName\n+     *            the element name, or $this\n+     * @param valueSet\n+     *            the value set\n+     * @param strength\n+     *            the binding strength\n+     * @return the FHIRPath expression\n+     */\n+    private String generateVocabularyConstraintExpression(JsonObject elementDefinition, String elementName, String valueSet, String strength) {\n+        StringBuilder sb = new StringBuilder();\n+\n+        String choiceText = \"\";\n+        if (isChoiceElement(elementDefinition)) {\n+            List<String> choiceTypeNames = getChoiceTypeNames(elementDefinition);\n+            if (!choiceTypeNames.isEmpty()) {\n+                String typeName = choiceTypeNames.get(0);\n+                choiceText = \".as(\" + typeName + \")\";\n+            }\n+        }\n+\n+        // Generate constraint to element that has focus\n+        if (\"$this\".equals(elementName)) {\n+            sb.append(elementName).append(choiceText).append(\".memberOf('\").append(valueSet).append(\"', '\").append(strength).append(\"')\");\n+        }\n+        // Generate constraint to context element\n+        else {\n+            sb.append(elementName).append(choiceText);\n+\n+            if (isOptional(elementDefinition)) {\n+                sb.append(\".exists() implies (\");\n+            } else {\n+                sb.append(\".exists() and \");\n+            }\n+\n+            sb.append(elementName).append(choiceText);\n+\n+            if (isRepeating(elementDefinition)) {\n+                sb.append(\".all(\");\n+            } else {\n+                sb.append(\".\");\n+            }\n+\n+            sb.append(\"memberOf('\").append(valueSet).append(\"', '\").append(strength).append(\"')\");\n+\n+            if (isRepeating(elementDefinition)) {\n+                sb.append(\")\");\n+            }\n+\n+            if (isOptional(elementDefinition)) {\n+                sb.append(\")\");\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Gets the next generated constraint ID.\n+     * \n+     * @param lastId\n+     *            the last ID\n+     * @param className\n+     *            the model class name\n+     * @return the next generated constraint ID\n+     */\n+    private String generateNextConstraintId(String lastId, String className) {\n+        String nextSuffix = \"0\";\n+        if (lastId != null) {\n+            lastId = lastId.substring(lastId.indexOf(\"-\") + 1);\n+            if (Character.isLetter(lastId.charAt(lastId.length() - 1))) {\n+                lastId = lastId.substring(0, lastId.length() - 1);\n+            }\n+            int nextKeyInt = Integer.parseInt(lastId) + 1;\n+            nextSuffix = String.valueOf(nextKeyInt);\n+        }\n+        return camelCase(className) + \"-\" + nextSuffix;\n+    }\n+\n+    /**\n+     * Determines if any of the structure definition contains any elements with an extensible or preferred binding.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b4fc8a6babefca74f548b595a923cdf12900ddf"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI1Nzg1Mw==", "bodyText": "Fixed.", "url": "https://github.com/IBM/FHIR/pull/1473#discussion_r482257853", "createdAt": "2020-09-02T17:52:38Z", "author": {"login": "tbieste"}, "path": "fhir-tools/src/main/java/com/ibm/fhir/tools/CodeGenerator.java", "diffHunk": "@@ -1475,6 +1477,154 @@ public int compare(JsonObject first, JsonObject second) {\n             }\n             cb.annotation(\"Constraint\", valueMap);\n         }\n+                \n+        // Generate constraint annotations from extensible and preferred bindings\n+        generateVocabularyConstraints(structureDefinition, cb, className, lastId);\n+    }\n+    \n+    /**\n+     * Generates constraint annotations from extensible and preferred bindings.\n+     * \n+     * @param structureDefinition\n+     *            the structure definition\n+     * @param cb\n+     *            the code builder\n+     * @param className\n+     *            the class name\n+     * @param lastId\n+     *            the ID of the last contraint\n+     */\n+    private void generateVocabularyConstraints(JsonObject structureDefinition, CodeBuilder cb, String className, String lastId) {\n+\n+        // Collect elements that have an extensible or preferred binding\n+        for (JsonObject elementDefinition : getElementDefinitions(structureDefinition).stream().filter(e -> !isProhibited(e)).filter(e -> hasExtensibleBinding(e)\n+                || hasPreferredBinding(e)).collect(Collectors.toList())) {\n+\n+            String path = elementDefinition.getString(\"path\");\n+            String elementName = getElementNameWithoutPrefix(elementDefinition, path, className);\n+            JsonObject binding = getBinding(elementDefinition);\n+            String location = elementName.contains(\".\") ? elementName.replace(\".div\", \".`div`\").replace(\"[x]\", \"\") : \"(base)\";\n+            String expressionElementName = \"(base)\".equals(location) ? elementName : \"$this\";\n+\n+            // Generate constraint for value set binding\n+            String valueSet = binding.getString(\"valueSet\", null);\n+            if (valueSet != null) {\n+                lastId = generateNextConstraintId(lastId, className);\n+\n+                String level = \"Warning\";\n+                String description = (hasExtensibleBinding(elementDefinition) ? \"SHALL, if possible, at least contain a code from value set \"\n+                        : \"SHOULD at least contain a code from value set \") + valueSet;\n+                String strength = binding.getString(\"strength\");\n+                String expression = generateVocabularyConstraintExpression(elementDefinition, expressionElementName, valueSet, strength);\n+\n+                Map<String, String> valueMap = new LinkedHashMap<>();\n+                valueMap.put(\"id\", quote(lastId));\n+                valueMap.put(\"level\", quote(level));\n+                valueMap.put(\"location\", quote(location));\n+                valueMap.put(\"description\", quote(description));\n+                valueMap.put(\"expression\", quote(expression));\n+                cb.annotation(\"Constraint\", valueMap);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Generates the FHIRPath expression for the constraint.\n+     * \n+     * @param elementDefinition\n+     *            the element definition\n+     * @param elementName\n+     *            the element name, or $this\n+     * @param valueSet\n+     *            the value set\n+     * @param strength\n+     *            the binding strength\n+     * @return the FHIRPath expression\n+     */\n+    private String generateVocabularyConstraintExpression(JsonObject elementDefinition, String elementName, String valueSet, String strength) {\n+        StringBuilder sb = new StringBuilder();\n+\n+        String choiceText = \"\";\n+        if (isChoiceElement(elementDefinition)) {\n+            List<String> choiceTypeNames = getChoiceTypeNames(elementDefinition);\n+            if (!choiceTypeNames.isEmpty()) {\n+                String typeName = choiceTypeNames.get(0);\n+                choiceText = \".as(\" + typeName + \")\";\n+            }\n+        }\n+\n+        // Generate constraint to element that has focus\n+        if (\"$this\".equals(elementName)) {\n+            sb.append(elementName).append(choiceText).append(\".memberOf('\").append(valueSet).append(\"', '\").append(strength).append(\"')\");\n+        }\n+        // Generate constraint to context element\n+        else {\n+            sb.append(elementName).append(choiceText);\n+\n+            if (isOptional(elementDefinition)) {\n+                sb.append(\".exists() implies (\");\n+            } else {\n+                sb.append(\".exists() and \");\n+            }\n+\n+            sb.append(elementName).append(choiceText);\n+\n+            if (isRepeating(elementDefinition)) {\n+                sb.append(\".all(\");\n+            } else {\n+                sb.append(\".\");\n+            }\n+\n+            sb.append(\"memberOf('\").append(valueSet).append(\"', '\").append(strength).append(\"')\");\n+\n+            if (isRepeating(elementDefinition)) {\n+                sb.append(\")\");\n+            }\n+\n+            if (isOptional(elementDefinition)) {\n+                sb.append(\")\");\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Gets the next generated constraint ID.\n+     * \n+     * @param lastId\n+     *            the last ID\n+     * @param className\n+     *            the model class name\n+     * @return the next generated constraint ID\n+     */\n+    private String generateNextConstraintId(String lastId, String className) {\n+        String nextSuffix = \"0\";\n+        if (lastId != null) {\n+            lastId = lastId.substring(lastId.indexOf(\"-\") + 1);\n+            if (Character.isLetter(lastId.charAt(lastId.length() - 1))) {\n+                lastId = lastId.substring(0, lastId.length() - 1);\n+            }\n+            int nextKeyInt = Integer.parseInt(lastId) + 1;\n+            nextSuffix = String.valueOf(nextKeyInt);\n+        }\n+        return camelCase(className) + \"-\" + nextSuffix;\n+    }\n+\n+    /**\n+     * Determines if any of the structure definition contains any elements with an extensible or preferred binding.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI0MTg0Ng=="}, "originalCommit": {"oid": "1b4fc8a6babefca74f548b595a923cdf12900ddf"}, "originalPosition": 170}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4821, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}