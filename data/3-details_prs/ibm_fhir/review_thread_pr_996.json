{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEwMjA2MjQz", "number": 996, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNjoyNjowMVrOD3tGiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNjo1MDoxM1rOD3tskQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NzM3MjI0OnYy", "diffSide": "RIGHT", "path": "fhir-persistence-schema/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNjoyNjowMVrOGOG8zA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNjoyNjowMVrOGOG8zA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ0NzExNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Use `--tenant-key-file tenant.key.file` to direct the action to read the tenant-key from file.  If the file exists the tenant key (up to 44 characters is read from the file.  If the file does not exist, the generated tenantKey is written out to the file.\n          \n          \n            \n            Use `--tenant-key-file tenant.key.file` to direct the action to read the tenant-key from file.  If the file exists the tenant key (up to 44 characters) is read from the file.  If the file does not exist, the generated tenantKey is written out to the file.", "url": "https://github.com/IBM/FHIR/pull/996#discussion_r417447116", "createdAt": "2020-04-29T16:26:01Z", "author": {"login": "lmsurpre"}, "path": "fhir-persistence-schema/README.md", "diffHunk": "@@ -129,6 +129,8 @@ Don't forget to copy the tenant-key secret generated by --allocate-tenant. This\n --allocate-tenant default\n ```\n \n+Use `--tenant-key-file tenant.key.file` to direct the action to read the tenant-key from file.  If the file exists the tenant key (up to 44 characters is read from the file.  If the file does not exist, the generated tenantKey is written out to the file.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8ae1039888ff9578cd64c7297ac3740f27040d0"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NzM4OTg5OnYy", "diffSide": "RIGHT", "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/app/Main.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNjozMDoxNlrOGOHHpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNjo0Njo0MlrOGOHxSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ0OTg5Mw==", "bodyText": "if we ever add to the MULTITENANT_FEATURE_ENABLED list, we'll need to update this line...but I think its fine for now", "url": "https://github.com/IBM/FHIR/pull/996#discussion_r417449893", "createdAt": "2020-04-29T16:30:16Z", "author": {"login": "lmsurpre"}, "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/app/Main.java", "diffHunk": "@@ -858,42 +886,103 @@ protected void addTenantKey() {\n             }\n         }\n \n-        logger.info(\"New tenant key: \" + addKeyForTenant + \" [key=\" + tenantKey + \"]\");\n+        if (tenantKeyFileName == null) {\n+            // Generated\n+            logger.info(\"New tenant key: \" + addKeyForTenant + \" [key=\" + tenantKey + \"]\");\n+        } else {\n+            // Loaded from File\n+            logger.info(\n+                    \"New tenant key from file: \" + addKeyForTenant + \" [tenantKeyFileName=\" + tenantKeyFileName + \"]\");\n+            if (!tenantKeyFileUtil.keyFileExists(tenantKeyFileName)) {\n+                tenantKeyFileUtil.writeTenantFile(tenantKeyFileName, tenantKey);\n+            }\n+        }\n \n     }\n \n+    /**\n+     * checks if tenant name and tenant key exists.\n+     * \n+     * @param adapter    the db2 adapter as this is a db2 feature only now\n+     * @param tenantName the tenant's name\n+     * @param tenantKey  tenant key\n+     */\n+    protected void checkIfTenantNameAndTenantKeyExists(Db2Adapter adapter, String tenantName, String tenantKey) {\n+        try (ITransaction tx = TransactionFactory.openTransaction(connectionPool)) {\n+            try {\n+                final String sql =\n+                        \"SELECT t.tenant_status FROM fhir_admin.tenants t WHERE t.tenant_name = ? \"\n+                                + \"AND EXISTS (SELECT 1 FROM fhir_admin.tenant_keys tk WHERE tk.mt_id = t.mt_id \"\n+                                + \"AND tk.tenant_hash = sysibm.hash(tk.tenant_salt || ?, 2));\";\n+                try (PreparedStatement stmt = connectionPool.getConnection().prepareStatement(sql)) {\n+                    stmt.setString(1, tenantName);\n+                    stmt.setString(2, tenantKey);\n+                    if (stmt.execute()) {\n+                        try (ResultSet resultSet = stmt.getResultSet();) {\n+                            if (resultSet.next()) {\n+                                throw new IllegalArgumentException(\"tenantName and tenantKey already exists\");\n+                            }\n+                        }\n+                    } else {\n+                        throw new IllegalArgumentException(\"Problem checking the results\");\n+                    }\n+                } catch (SQLException e) {\n+                    throw new IllegalArgumentException(\n+                            \"Exception when querying backend to verify tenant key and tenant name\", e);\n+                }\n+            } catch (DataAccessException x) {\n+                // Something went wrong, so mark the transaction as failed\n+                tx.setRollbackOnly();\n+                throw x;\n+            }\n+        }\n+    }\n+\n     /**\n      * Allocate this tenant, creating new partitions if required.\n      */\n     protected void allocateTenant() {\n-        if (dbType == DbType.DERBY || dbType == DbType.POSTGRESQL) {\n+        if (!MULTITENANT_FEATURE_ENABLED.contains(dbType)) {\n             return;\n         }\n+\n         // The key we'll use for this tenant. This key should be used in subsequent\n         // activities related to this tenant, such as setting the tenant context.\n-        final String tenantKey = getRandomKey();\n+        if (tenantKeyFileUtil.keyFileExists(tenantKeyFileName)) {\n+            // Only if the Tenant Key file is provided as a parameter is it not null. \n+            // in  this case we want special behavior.\n+            tenantKey = this.tenantKeyFileUtil.readTenantFile(tenantKeyFileName);\n+        } else {\n+            tenantKey = getRandomKey();\n+        }\n \n         // The salt is used when we hash the tenantKey. We're just using SHA-256 for\n         // the hash here, not multiple rounds of a password hashing algorithm. It's\n         // sufficient in our case because we are using a 32-byte random value as the\n         // key, giving 256 bits of entropy.\n         final String tenantSalt = getRandomKey();\n \n+        Db2Adapter adapter = new Db2Adapter(connectionPool);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8ae1039888ff9578cd64c7297ac3740f27040d0"}, "originalPosition": 267}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2MDU1NA==", "bodyText": "Yes, that's right, we have a smattering of those throughout.", "url": "https://github.com/IBM/FHIR/pull/996#discussion_r417460554", "createdAt": "2020-04-29T16:46:42Z", "author": {"login": "prb112"}, "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/app/Main.java", "diffHunk": "@@ -858,42 +886,103 @@ protected void addTenantKey() {\n             }\n         }\n \n-        logger.info(\"New tenant key: \" + addKeyForTenant + \" [key=\" + tenantKey + \"]\");\n+        if (tenantKeyFileName == null) {\n+            // Generated\n+            logger.info(\"New tenant key: \" + addKeyForTenant + \" [key=\" + tenantKey + \"]\");\n+        } else {\n+            // Loaded from File\n+            logger.info(\n+                    \"New tenant key from file: \" + addKeyForTenant + \" [tenantKeyFileName=\" + tenantKeyFileName + \"]\");\n+            if (!tenantKeyFileUtil.keyFileExists(tenantKeyFileName)) {\n+                tenantKeyFileUtil.writeTenantFile(tenantKeyFileName, tenantKey);\n+            }\n+        }\n \n     }\n \n+    /**\n+     * checks if tenant name and tenant key exists.\n+     * \n+     * @param adapter    the db2 adapter as this is a db2 feature only now\n+     * @param tenantName the tenant's name\n+     * @param tenantKey  tenant key\n+     */\n+    protected void checkIfTenantNameAndTenantKeyExists(Db2Adapter adapter, String tenantName, String tenantKey) {\n+        try (ITransaction tx = TransactionFactory.openTransaction(connectionPool)) {\n+            try {\n+                final String sql =\n+                        \"SELECT t.tenant_status FROM fhir_admin.tenants t WHERE t.tenant_name = ? \"\n+                                + \"AND EXISTS (SELECT 1 FROM fhir_admin.tenant_keys tk WHERE tk.mt_id = t.mt_id \"\n+                                + \"AND tk.tenant_hash = sysibm.hash(tk.tenant_salt || ?, 2));\";\n+                try (PreparedStatement stmt = connectionPool.getConnection().prepareStatement(sql)) {\n+                    stmt.setString(1, tenantName);\n+                    stmt.setString(2, tenantKey);\n+                    if (stmt.execute()) {\n+                        try (ResultSet resultSet = stmt.getResultSet();) {\n+                            if (resultSet.next()) {\n+                                throw new IllegalArgumentException(\"tenantName and tenantKey already exists\");\n+                            }\n+                        }\n+                    } else {\n+                        throw new IllegalArgumentException(\"Problem checking the results\");\n+                    }\n+                } catch (SQLException e) {\n+                    throw new IllegalArgumentException(\n+                            \"Exception when querying backend to verify tenant key and tenant name\", e);\n+                }\n+            } catch (DataAccessException x) {\n+                // Something went wrong, so mark the transaction as failed\n+                tx.setRollbackOnly();\n+                throw x;\n+            }\n+        }\n+    }\n+\n     /**\n      * Allocate this tenant, creating new partitions if required.\n      */\n     protected void allocateTenant() {\n-        if (dbType == DbType.DERBY || dbType == DbType.POSTGRESQL) {\n+        if (!MULTITENANT_FEATURE_ENABLED.contains(dbType)) {\n             return;\n         }\n+\n         // The key we'll use for this tenant. This key should be used in subsequent\n         // activities related to this tenant, such as setting the tenant context.\n-        final String tenantKey = getRandomKey();\n+        if (tenantKeyFileUtil.keyFileExists(tenantKeyFileName)) {\n+            // Only if the Tenant Key file is provided as a parameter is it not null. \n+            // in  this case we want special behavior.\n+            tenantKey = this.tenantKeyFileUtil.readTenantFile(tenantKeyFileName);\n+        } else {\n+            tenantKey = getRandomKey();\n+        }\n \n         // The salt is used when we hash the tenantKey. We're just using SHA-256 for\n         // the hash here, not multiple rounds of a password hashing algorithm. It's\n         // sufficient in our case because we are using a 32-byte random value as the\n         // key, giving 256 bits of entropy.\n         final String tenantSalt = getRandomKey();\n \n+        Db2Adapter adapter = new Db2Adapter(connectionPool);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ0OTg5Mw=="}, "originalCommit": {"oid": "e8ae1039888ff9578cd64c7297ac3740f27040d0"}, "originalPosition": 267}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NzM5NTg5OnYy", "diffSide": "RIGHT", "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/app/Main.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNjozMTozOVrOGOHLbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNjo0OToxM1rOGOH3mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ1MDg2MQ==", "bodyText": "maybe move these below the if-else block so its closer to the try-with-resource?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // Open a new transaction and associate it with our connection pool. Remember\n          \n          \n            \n                    // that we don't support distributed transactions, so all connections within\n          \n          \n            \n                    // this transaction must come from the same pool", "url": "https://github.com/IBM/FHIR/pull/996#discussion_r417450861", "createdAt": "2020-04-29T16:31:39Z", "author": {"login": "lmsurpre"}, "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/app/Main.java", "diffHunk": "@@ -858,42 +886,103 @@ protected void addTenantKey() {\n             }\n         }\n \n-        logger.info(\"New tenant key: \" + addKeyForTenant + \" [key=\" + tenantKey + \"]\");\n+        if (tenantKeyFileName == null) {\n+            // Generated\n+            logger.info(\"New tenant key: \" + addKeyForTenant + \" [key=\" + tenantKey + \"]\");\n+        } else {\n+            // Loaded from File\n+            logger.info(\n+                    \"New tenant key from file: \" + addKeyForTenant + \" [tenantKeyFileName=\" + tenantKeyFileName + \"]\");\n+            if (!tenantKeyFileUtil.keyFileExists(tenantKeyFileName)) {\n+                tenantKeyFileUtil.writeTenantFile(tenantKeyFileName, tenantKey);\n+            }\n+        }\n \n     }\n \n+    /**\n+     * checks if tenant name and tenant key exists.\n+     * \n+     * @param adapter    the db2 adapter as this is a db2 feature only now\n+     * @param tenantName the tenant's name\n+     * @param tenantKey  tenant key\n+     */\n+    protected void checkIfTenantNameAndTenantKeyExists(Db2Adapter adapter, String tenantName, String tenantKey) {\n+        try (ITransaction tx = TransactionFactory.openTransaction(connectionPool)) {\n+            try {\n+                final String sql =\n+                        \"SELECT t.tenant_status FROM fhir_admin.tenants t WHERE t.tenant_name = ? \"\n+                                + \"AND EXISTS (SELECT 1 FROM fhir_admin.tenant_keys tk WHERE tk.mt_id = t.mt_id \"\n+                                + \"AND tk.tenant_hash = sysibm.hash(tk.tenant_salt || ?, 2));\";\n+                try (PreparedStatement stmt = connectionPool.getConnection().prepareStatement(sql)) {\n+                    stmt.setString(1, tenantName);\n+                    stmt.setString(2, tenantKey);\n+                    if (stmt.execute()) {\n+                        try (ResultSet resultSet = stmt.getResultSet();) {\n+                            if (resultSet.next()) {\n+                                throw new IllegalArgumentException(\"tenantName and tenantKey already exists\");\n+                            }\n+                        }\n+                    } else {\n+                        throw new IllegalArgumentException(\"Problem checking the results\");\n+                    }\n+                } catch (SQLException e) {\n+                    throw new IllegalArgumentException(\n+                            \"Exception when querying backend to verify tenant key and tenant name\", e);\n+                }\n+            } catch (DataAccessException x) {\n+                // Something went wrong, so mark the transaction as failed\n+                tx.setRollbackOnly();\n+                throw x;\n+            }\n+        }\n+    }\n+\n     /**\n      * Allocate this tenant, creating new partitions if required.\n      */\n     protected void allocateTenant() {\n-        if (dbType == DbType.DERBY || dbType == DbType.POSTGRESQL) {\n+        if (!MULTITENANT_FEATURE_ENABLED.contains(dbType)) {\n             return;\n         }\n+\n         // The key we'll use for this tenant. This key should be used in subsequent\n         // activities related to this tenant, such as setting the tenant context.\n-        final String tenantKey = getRandomKey();\n+        if (tenantKeyFileUtil.keyFileExists(tenantKeyFileName)) {\n+            // Only if the Tenant Key file is provided as a parameter is it not null. \n+            // in  this case we want special behavior.\n+            tenantKey = this.tenantKeyFileUtil.readTenantFile(tenantKeyFileName);\n+        } else {\n+            tenantKey = getRandomKey();\n+        }\n \n         // The salt is used when we hash the tenantKey. We're just using SHA-256 for\n         // the hash here, not multiple rounds of a password hashing algorithm. It's\n         // sufficient in our case because we are using a 32-byte random value as the\n         // key, giving 256 bits of entropy.\n         final String tenantSalt = getRandomKey();\n \n+        Db2Adapter adapter = new Db2Adapter(connectionPool);\n+        checkIfTenantNameAndTenantKeyExists(adapter, tenantName, tenantKey);\n+\n         // Open a new transaction and associate it with our connection pool. Remember\n         // that we don't support distributed transactions, so all connections within\n         // this transaction must come from the same pool", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8ae1039888ff9578cd64c7297ac3740f27040d0"}, "originalPosition": 272}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2MjE3MA==", "bodyText": "resolving conversation so I can edit in another suggestion", "url": "https://github.com/IBM/FHIR/pull/996#discussion_r417462170", "createdAt": "2020-04-29T16:49:13Z", "author": {"login": "prb112"}, "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/app/Main.java", "diffHunk": "@@ -858,42 +886,103 @@ protected void addTenantKey() {\n             }\n         }\n \n-        logger.info(\"New tenant key: \" + addKeyForTenant + \" [key=\" + tenantKey + \"]\");\n+        if (tenantKeyFileName == null) {\n+            // Generated\n+            logger.info(\"New tenant key: \" + addKeyForTenant + \" [key=\" + tenantKey + \"]\");\n+        } else {\n+            // Loaded from File\n+            logger.info(\n+                    \"New tenant key from file: \" + addKeyForTenant + \" [tenantKeyFileName=\" + tenantKeyFileName + \"]\");\n+            if (!tenantKeyFileUtil.keyFileExists(tenantKeyFileName)) {\n+                tenantKeyFileUtil.writeTenantFile(tenantKeyFileName, tenantKey);\n+            }\n+        }\n \n     }\n \n+    /**\n+     * checks if tenant name and tenant key exists.\n+     * \n+     * @param adapter    the db2 adapter as this is a db2 feature only now\n+     * @param tenantName the tenant's name\n+     * @param tenantKey  tenant key\n+     */\n+    protected void checkIfTenantNameAndTenantKeyExists(Db2Adapter adapter, String tenantName, String tenantKey) {\n+        try (ITransaction tx = TransactionFactory.openTransaction(connectionPool)) {\n+            try {\n+                final String sql =\n+                        \"SELECT t.tenant_status FROM fhir_admin.tenants t WHERE t.tenant_name = ? \"\n+                                + \"AND EXISTS (SELECT 1 FROM fhir_admin.tenant_keys tk WHERE tk.mt_id = t.mt_id \"\n+                                + \"AND tk.tenant_hash = sysibm.hash(tk.tenant_salt || ?, 2));\";\n+                try (PreparedStatement stmt = connectionPool.getConnection().prepareStatement(sql)) {\n+                    stmt.setString(1, tenantName);\n+                    stmt.setString(2, tenantKey);\n+                    if (stmt.execute()) {\n+                        try (ResultSet resultSet = stmt.getResultSet();) {\n+                            if (resultSet.next()) {\n+                                throw new IllegalArgumentException(\"tenantName and tenantKey already exists\");\n+                            }\n+                        }\n+                    } else {\n+                        throw new IllegalArgumentException(\"Problem checking the results\");\n+                    }\n+                } catch (SQLException e) {\n+                    throw new IllegalArgumentException(\n+                            \"Exception when querying backend to verify tenant key and tenant name\", e);\n+                }\n+            } catch (DataAccessException x) {\n+                // Something went wrong, so mark the transaction as failed\n+                tx.setRollbackOnly();\n+                throw x;\n+            }\n+        }\n+    }\n+\n     /**\n      * Allocate this tenant, creating new partitions if required.\n      */\n     protected void allocateTenant() {\n-        if (dbType == DbType.DERBY || dbType == DbType.POSTGRESQL) {\n+        if (!MULTITENANT_FEATURE_ENABLED.contains(dbType)) {\n             return;\n         }\n+\n         // The key we'll use for this tenant. This key should be used in subsequent\n         // activities related to this tenant, such as setting the tenant context.\n-        final String tenantKey = getRandomKey();\n+        if (tenantKeyFileUtil.keyFileExists(tenantKeyFileName)) {\n+            // Only if the Tenant Key file is provided as a parameter is it not null. \n+            // in  this case we want special behavior.\n+            tenantKey = this.tenantKeyFileUtil.readTenantFile(tenantKeyFileName);\n+        } else {\n+            tenantKey = getRandomKey();\n+        }\n \n         // The salt is used when we hash the tenantKey. We're just using SHA-256 for\n         // the hash here, not multiple rounds of a password hashing algorithm. It's\n         // sufficient in our case because we are using a 32-byte random value as the\n         // key, giving 256 bits of entropy.\n         final String tenantSalt = getRandomKey();\n \n+        Db2Adapter adapter = new Db2Adapter(connectionPool);\n+        checkIfTenantNameAndTenantKeyExists(adapter, tenantName, tenantKey);\n+\n         // Open a new transaction and associate it with our connection pool. Remember\n         // that we don't support distributed transactions, so all connections within\n         // this transaction must come from the same pool", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ1MDg2MQ=="}, "originalCommit": {"oid": "e8ae1039888ff9578cd64c7297ac3740f27040d0"}, "originalPosition": 272}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NzQxMzEwOnYy", "diffSide": "RIGHT", "path": "fhir-persistence-schema/src/test/resources/test/.gitignore", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNjozNjowN1rOGOHWLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQyMToyNjozN1rOGORozA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ1MzYxNQ==", "bodyText": "why does it end in .nowrite?\nI think the pattern should match the name given in the examples in the README; currently that is  --tenant-key-file tenant.key.file", "url": "https://github.com/IBM/FHIR/pull/996#discussion_r417453615", "createdAt": "2020-04-29T16:36:07Z", "author": {"login": "lmsurpre"}, "path": "fhir-persistence-schema/src/test/resources/test/.gitignore", "diffHunk": "@@ -0,0 +1,2 @@\n+# Blocks the Addition of the test files into git\n+**/*.key.nowrite", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8ae1039888ff9578cd64c7297ac3740f27040d0"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2MTE5Nw==", "bodyText": "right... I chose to ignore the files (.nowrite), as in one of the tests, I actually write the file. I wanted to not block the rest of the test files.  in src/test/resources/test/", "url": "https://github.com/IBM/FHIR/pull/996#discussion_r417461197", "createdAt": "2020-04-29T16:47:44Z", "author": {"login": "prb112"}, "path": "fhir-persistence-schema/src/test/resources/test/.gitignore", "diffHunk": "@@ -0,0 +1,2 @@\n+# Blocks the Addition of the test files into git\n+**/*.key.nowrite", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ1MzYxNQ=="}, "originalCommit": {"oid": "e8ae1039888ff9578cd64c7297ac3740f27040d0"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzYyMjIyMA==", "bodyText": "ah, ok.  i guess i was thinking this was a higher-level directory and we were trying to help prevent people from accidentally checking in their keys.  now i understand its just for the test.", "url": "https://github.com/IBM/FHIR/pull/996#discussion_r417622220", "createdAt": "2020-04-29T21:26:37Z", "author": {"login": "lmsurpre"}, "path": "fhir-persistence-schema/src/test/resources/test/.gitignore", "diffHunk": "@@ -0,0 +1,2 @@\n+# Blocks the Addition of the test files into git\n+**/*.key.nowrite", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ1MzYxNQ=="}, "originalCommit": {"oid": "e8ae1039888ff9578cd64c7297ac3740f27040d0"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NzQ2OTYxOnYy", "diffSide": "RIGHT", "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/app/Main.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNjo1MDoxM1rOGOH6ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNjo1MDoxM1rOGOH6ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2MjkyMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n            \n          \n          \n            \n                    // Open a new transaction and associate it with our connection pool. Remember\n          \n          \n            \n                    // that we don't support distributed transactions, so all connections within\n          \n          \n            \n                    // this transaction must come from the same pool", "url": "https://github.com/IBM/FHIR/pull/996#discussion_r417462922", "createdAt": "2020-04-29T16:50:13Z", "author": {"login": "prb112"}, "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/app/Main.java", "diffHunk": "@@ -858,42 +886,103 @@ protected void addTenantKey() {\n             }\n         }\n \n-        logger.info(\"New tenant key: \" + addKeyForTenant + \" [key=\" + tenantKey + \"]\");\n+        if (tenantKeyFileName == null) {\n+            // Generated\n+            logger.info(\"New tenant key: \" + addKeyForTenant + \" [key=\" + tenantKey + \"]\");\n+        } else {\n+            // Loaded from File\n+            logger.info(\n+                    \"New tenant key from file: \" + addKeyForTenant + \" [tenantKeyFileName=\" + tenantKeyFileName + \"]\");\n+            if (!tenantKeyFileUtil.keyFileExists(tenantKeyFileName)) {\n+                tenantKeyFileUtil.writeTenantFile(tenantKeyFileName, tenantKey);\n+            }\n+        }\n \n     }\n \n+    /**\n+     * checks if tenant name and tenant key exists.\n+     * \n+     * @param adapter    the db2 adapter as this is a db2 feature only now\n+     * @param tenantName the tenant's name\n+     * @param tenantKey  tenant key\n+     */\n+    protected void checkIfTenantNameAndTenantKeyExists(Db2Adapter adapter, String tenantName, String tenantKey) {\n+        try (ITransaction tx = TransactionFactory.openTransaction(connectionPool)) {\n+            try {\n+                final String sql =\n+                        \"SELECT t.tenant_status FROM fhir_admin.tenants t WHERE t.tenant_name = ? \"\n+                                + \"AND EXISTS (SELECT 1 FROM fhir_admin.tenant_keys tk WHERE tk.mt_id = t.mt_id \"\n+                                + \"AND tk.tenant_hash = sysibm.hash(tk.tenant_salt || ?, 2));\";\n+                try (PreparedStatement stmt = connectionPool.getConnection().prepareStatement(sql)) {\n+                    stmt.setString(1, tenantName);\n+                    stmt.setString(2, tenantKey);\n+                    if (stmt.execute()) {\n+                        try (ResultSet resultSet = stmt.getResultSet();) {\n+                            if (resultSet.next()) {\n+                                throw new IllegalArgumentException(\"tenantName and tenantKey already exists\");\n+                            }\n+                        }\n+                    } else {\n+                        throw new IllegalArgumentException(\"Problem checking the results\");\n+                    }\n+                } catch (SQLException e) {\n+                    throw new IllegalArgumentException(\n+                            \"Exception when querying backend to verify tenant key and tenant name\", e);\n+                }\n+            } catch (DataAccessException x) {\n+                // Something went wrong, so mark the transaction as failed\n+                tx.setRollbackOnly();\n+                throw x;\n+            }\n+        }\n+    }\n+\n     /**\n      * Allocate this tenant, creating new partitions if required.\n      */\n     protected void allocateTenant() {\n-        if (dbType == DbType.DERBY || dbType == DbType.POSTGRESQL) {\n+        if (!MULTITENANT_FEATURE_ENABLED.contains(dbType)) {\n             return;\n         }\n+\n         // The key we'll use for this tenant. This key should be used in subsequent\n         // activities related to this tenant, such as setting the tenant context.\n-        final String tenantKey = getRandomKey();\n+        if (tenantKeyFileUtil.keyFileExists(tenantKeyFileName)) {\n+            // Only if the Tenant Key file is provided as a parameter is it not null. \n+            // in  this case we want special behavior.\n+            tenantKey = this.tenantKeyFileUtil.readTenantFile(tenantKeyFileName);\n+        } else {\n+            tenantKey = getRandomKey();\n+        }\n \n         // The salt is used when we hash the tenantKey. We're just using SHA-256 for\n         // the hash here, not multiple rounds of a password hashing algorithm. It's\n         // sufficient in our case because we are using a 32-byte random value as the\n         // key, giving 256 bits of entropy.\n         final String tenantSalt = getRandomKey();\n \n+        Db2Adapter adapter = new Db2Adapter(connectionPool);\n+        checkIfTenantNameAndTenantKeyExists(adapter, tenantName, tenantKey);\n+\n         // Open a new transaction and associate it with our connection pool. Remember\n         // that we don't support distributed transactions, so all connections within\n         // this transaction must come from the same pool\n-        Db2Adapter adapter = new Db2Adapter(connectionPool);\n-        logger.info(\"Allocating new tenant: \" + tenantName + \" [key=\" + tenantKey + \"]\");\n+        if (tenantKeyFileName == null) {\n+            logger.info(\"Allocating new tenant: \" + tenantName + \" [key=\" + tenantKey + \"]\");\n+        } else {\n+            logger.info(\"Allocating new tenant: \" + tenantName + \" [tenantKeyFileName=\" + tenantKeyFileName + \"]\");\n+        }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8ae1039888ff9578cd64c7297ac3740f27040d0"}, "originalPosition": 280}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4997, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}