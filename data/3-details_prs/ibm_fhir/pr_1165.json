{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI1MTQ5Mjky", "number": 1165, "title": "issue-1132 - refactor multi tenancy and schema migration docs", "bodyText": "Signed-off-by: Robin Arnold robin.arnold23@ibm.com\nFirst cut at trying to shuffle stuff around plus add more content and clarifications. Not perfect yet, but want to publish what I have so far.", "createdAt": "2020-05-29T14:46:36Z", "url": "https://github.com/IBM/FHIR/pull/1165", "merged": true, "mergeCommit": {"oid": "a45df8371a302ca634a13d7a7de85068265a262b"}, "closed": true, "closedAt": "2020-08-29T02:16:03Z", "author": {"login": "punktilious"}, "timelineItems": {"totalCount": 29, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcmDQvIAH2gAyNDI1MTQ5MjkyOjZkNjRhMDIwNDYxZjI1NmNlZWNkYmNmMjMxZmQ0YTA2ZTllOWFhMmU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdDf9rXAH2gAyNDI1MTQ5MjkyOmQzYjJkNmQ4NDgxNWE3OWVjMjAwMzZkODZmOWMzZDdjY2QzNmRlYzE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e", "author": {"user": {"login": "punktilious", "name": "Robin Arnold"}}, "url": "https://github.com/IBM/FHIR/commit/6d64a020461f256ceecdbcf231fd4a06e9e9aa2e", "committedDate": "2020-05-29T14:23:12Z", "message": "issue-1132 - refactor multi tenancy and schema migration docs\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMDI3Njkz", "url": "https://github.com/IBM/FHIR/pull/1165#pullrequestreview-421027693", "createdAt": "2020-05-29T14:51:02Z", "commit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNDo1MTowMlrOGcgIPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNDo1MTowMlrOGcgIPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjUzOTcxMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            CREATE TABLE ptng.patients (\n          \n          \n            \n            CREATE TABLE fhirdata.patients (", "url": "https://github.com/IBM/FHIR/pull/1165#discussion_r432539711", "createdAt": "2020-05-29T14:51:02Z", "author": {"login": "prb112"}, "path": "fhir-persistence-schema/docs/DB2MultiTenancy.md", "diffHunk": "@@ -1,16 +1,225 @@\n-# The IBM FHIR Server - Db2 Multi-Tenancy\n+# The IBM FHIR Server - Multi-Tenancy on Db2\n \n-This document outlines the schema design and implementation for the IBM FHIR Server's Db2 Multi-tenancy feature. \n+This document outlines the schema design and implementation for the IBM FHIR Server's Multi-tenancy feature on Db2.\n \n The Multi-tenancy feature has two main areas of focus: \n - Tenant Provisioning  \n - Security\n \n-## Multi-Tenancy Schema Design\n+This document assumes familiarity with the general [IBM FHIR Server schema design](SchemaMigration.md).\n+\n+# Multi-Tenancy Concepts and Design\n+\n+The IBM FHIR Server design supports three levels of multi-tenancy:\n+\n+1. Separate database per tenant\n+2. Separate data schema per tenant\n+3. (Db2-only) multiple tenants per schema, partitioned with row-based access control and per-tenant tablespaces.\n+\n+Of course, an entire deployment (application servers and database) also could be dedicated to a single tenant, which is really just a variant of option 1 above, although clearly such a configuration would not be considered multi-tenant.\n+\n+## Tenant Data Administration\n+\n+The IBM FHIR Server separates schema administration data from user data. All administration data is held in tables within the FHIRADMIN schema, and these tables are not directly accessible by the IBM FHIR Server database user.\n+\n+The FHIRADMIN schema is used to manage schema version migrations as well as tenant configuration for any tenants resident in the given database. The FHIRADMIN schema does not manage tenants in other databases.\n+\n+See the general [IBM FHIR Server schema design](SchemaMigration.md) documentation for a more detailed description of how FHIRADMIN tables are used to manage schema versions.\n+\n+\n+## Multi-tenancy using Db2 Table Partitions and Per Tenant Tablespaces\n+\n+The IBM FHIR Server provides a multi-tenancy feature based on Db2 row-based access control and table partitioning features.\n+\n+Each new tenant is allocated a unique tenant id value which is of database type `INT`. All tables in the IBM FHIR Server data schema (typically `FHIRDATA`) are created as range partitioned and configured with row-based access control. \n+\n+As an example, consider a table of patients created using the following DDL (illustrative only, this is not the actual IBM FHIR Server schema):\n+\n+```\n+CREATE TABLE ptng.patients (", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "originalPosition": 42}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMDI3OTM4", "url": "https://github.com/IBM/FHIR/pull/1165#pullrequestreview-421027938", "createdAt": "2020-05-29T14:51:22Z", "commit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNDo1MToyMlrOGcgJAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNDo1MToyMlrOGcgJAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjUzOTkwNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            CREATE UNIQUE INDEX ptng.unq_ssn ON ptng.patients(mt_id, ssn);\n          \n          \n            \n            CREATE UNIQUE INDEX fhirdata.unq_ssn ON fhirdata.patients(mt_id, ssn);", "url": "https://github.com/IBM/FHIR/pull/1165#discussion_r432539905", "createdAt": "2020-05-29T14:51:22Z", "author": {"login": "prb112"}, "path": "fhir-persistence-schema/docs/DB2MultiTenancy.md", "diffHunk": "@@ -1,16 +1,225 @@\n-# The IBM FHIR Server - Db2 Multi-Tenancy\n+# The IBM FHIR Server - Multi-Tenancy on Db2\n \n-This document outlines the schema design and implementation for the IBM FHIR Server's Db2 Multi-tenancy feature. \n+This document outlines the schema design and implementation for the IBM FHIR Server's Multi-tenancy feature on Db2.\n \n The Multi-tenancy feature has two main areas of focus: \n - Tenant Provisioning  \n - Security\n \n-## Multi-Tenancy Schema Design\n+This document assumes familiarity with the general [IBM FHIR Server schema design](SchemaMigration.md).\n+\n+# Multi-Tenancy Concepts and Design\n+\n+The IBM FHIR Server design supports three levels of multi-tenancy:\n+\n+1. Separate database per tenant\n+2. Separate data schema per tenant\n+3. (Db2-only) multiple tenants per schema, partitioned with row-based access control and per-tenant tablespaces.\n+\n+Of course, an entire deployment (application servers and database) also could be dedicated to a single tenant, which is really just a variant of option 1 above, although clearly such a configuration would not be considered multi-tenant.\n+\n+## Tenant Data Administration\n+\n+The IBM FHIR Server separates schema administration data from user data. All administration data is held in tables within the FHIRADMIN schema, and these tables are not directly accessible by the IBM FHIR Server database user.\n+\n+The FHIRADMIN schema is used to manage schema version migrations as well as tenant configuration for any tenants resident in the given database. The FHIRADMIN schema does not manage tenants in other databases.\n+\n+See the general [IBM FHIR Server schema design](SchemaMigration.md) documentation for a more detailed description of how FHIRADMIN tables are used to manage schema versions.\n+\n+\n+## Multi-tenancy using Db2 Table Partitions and Per Tenant Tablespaces\n+\n+The IBM FHIR Server provides a multi-tenancy feature based on Db2 row-based access control and table partitioning features.\n+\n+Each new tenant is allocated a unique tenant id value which is of database type `INT`. All tables in the IBM FHIR Server data schema (typically `FHIRDATA`) are created as range partitioned and configured with row-based access control. \n+\n+As an example, consider a table of patients created using the following DDL (illustrative only, this is not the actual IBM FHIR Server schema):\n+\n+```\n+CREATE TABLE ptng.patients (\n+\u00a0 \u00a0 mt_id \u00a0 \u00a0 \u00a0 \u00a0 \u00a0     INT \u00a0 \u00a0 NOT NULL,\n+\u00a0 \u00a0 patient_name\u00a0 \u00a0 VARCHAR(18) NOT NULL,\n+\u00a0 \u00a0 age \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 INT \u00a0 \u00a0 NOT NULL,\n+\u00a0 \u00a0 doctor_name \u00a0 \u00a0 VARCHAR(18),\n+\u00a0 \u00a0 ssn\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 CHAR(11),\n+\u00a0 \u00a0 CONSTRAINT pk_patient PRIMARY KEY (mt_id, patient_name)\n+)\n+PARTITION BY RANGE (mt_id) (STARTING 0 INCLUSIVE ENDING 0 INCLUSIVE);\n+```\n+\n+Each tenant is allocated a unique integer value for mt_id (multi-tenant id), with a range partition used to define which table partition is to be used for a particular tenant's mt_id. The mapping of tenant name to mt_id value is maintained in the FHIR_ADMIN.TENANTS table.\n+\n+The above example assumes that patient_name will be unique within the context of a single tenant, which obviously does not apply to the actual IBM FHIR Server schema. The primary key must include the partition range key `mt_id`. In addition, any secondary indexes MUST also include mt_id to ensure they are always local to the partition. For example:\n+\n+```\n+CREATE UNIQUE INDEX ptng.unq_ssn ON ptng.patients(mt_id, ssn);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "originalPosition": 58}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMDI4MjU2", "url": "https://github.com/IBM/FHIR/pull/1165#pullrequestreview-421028256", "createdAt": "2020-05-29T14:51:40Z", "commit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNDo1MTo0MFrOGcgJ7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNDo1MTo0MFrOGcgJ7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU0MDE0MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            CREATE PERMISSION ROW_ACCESS ON ptng.patients\n          \n          \n            \n            \u00a0\u00a0 \u00a0 \u00a0 \u00a0 FOR ROWS WHERE patients.mt_id = ptng.session_tenant\n          \n          \n            \n            \u00a0\u00a0 \u00a0 \u00a0 \u00a0 ENFORCED FOR ALL ACCESS\n          \n          \n            \n            \u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ENABLE;\n          \n          \n            \n            \n          \n          \n            \n            ALTER TABLE ptng.patients ACTIVATE ROW ACCESS CONTROL;\n          \n          \n            \n            CREATE PERMISSION ROW_ACCESS ON fhirdata.patients\n          \n          \n            \n            \u00a0\u00a0 \u00a0 \u00a0 \u00a0 FOR ROWS WHERE patients.mt_id = fhirdata.session_tenant\n          \n          \n            \n            \u00a0\u00a0 \u00a0 \u00a0 \u00a0 ENFORCED FOR ALL ACCESS\n          \n          \n            \n            \u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ENABLE;\n          \n          \n            \n            \n          \n          \n            \n            ALTER TABLE fhirdata.patients ACTIVATE ROW ACCESS CONTROL;", "url": "https://github.com/IBM/FHIR/pull/1165#discussion_r432540140", "createdAt": "2020-05-29T14:51:40Z", "author": {"login": "prb112"}, "path": "fhir-persistence-schema/docs/DB2MultiTenancy.md", "diffHunk": "@@ -1,16 +1,225 @@\n-# The IBM FHIR Server - Db2 Multi-Tenancy\n+# The IBM FHIR Server - Multi-Tenancy on Db2\n \n-This document outlines the schema design and implementation for the IBM FHIR Server's Db2 Multi-tenancy feature. \n+This document outlines the schema design and implementation for the IBM FHIR Server's Multi-tenancy feature on Db2.\n \n The Multi-tenancy feature has two main areas of focus: \n - Tenant Provisioning  \n - Security\n \n-## Multi-Tenancy Schema Design\n+This document assumes familiarity with the general [IBM FHIR Server schema design](SchemaMigration.md).\n+\n+# Multi-Tenancy Concepts and Design\n+\n+The IBM FHIR Server design supports three levels of multi-tenancy:\n+\n+1. Separate database per tenant\n+2. Separate data schema per tenant\n+3. (Db2-only) multiple tenants per schema, partitioned with row-based access control and per-tenant tablespaces.\n+\n+Of course, an entire deployment (application servers and database) also could be dedicated to a single tenant, which is really just a variant of option 1 above, although clearly such a configuration would not be considered multi-tenant.\n+\n+## Tenant Data Administration\n+\n+The IBM FHIR Server separates schema administration data from user data. All administration data is held in tables within the FHIRADMIN schema, and these tables are not directly accessible by the IBM FHIR Server database user.\n+\n+The FHIRADMIN schema is used to manage schema version migrations as well as tenant configuration for any tenants resident in the given database. The FHIRADMIN schema does not manage tenants in other databases.\n+\n+See the general [IBM FHIR Server schema design](SchemaMigration.md) documentation for a more detailed description of how FHIRADMIN tables are used to manage schema versions.\n+\n+\n+## Multi-tenancy using Db2 Table Partitions and Per Tenant Tablespaces\n+\n+The IBM FHIR Server provides a multi-tenancy feature based on Db2 row-based access control and table partitioning features.\n+\n+Each new tenant is allocated a unique tenant id value which is of database type `INT`. All tables in the IBM FHIR Server data schema (typically `FHIRDATA`) are created as range partitioned and configured with row-based access control. \n+\n+As an example, consider a table of patients created using the following DDL (illustrative only, this is not the actual IBM FHIR Server schema):\n+\n+```\n+CREATE TABLE ptng.patients (\n+\u00a0 \u00a0 mt_id \u00a0 \u00a0 \u00a0 \u00a0 \u00a0     INT \u00a0 \u00a0 NOT NULL,\n+\u00a0 \u00a0 patient_name\u00a0 \u00a0 VARCHAR(18) NOT NULL,\n+\u00a0 \u00a0 age \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 INT \u00a0 \u00a0 NOT NULL,\n+\u00a0 \u00a0 doctor_name \u00a0 \u00a0 VARCHAR(18),\n+\u00a0 \u00a0 ssn\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 CHAR(11),\n+\u00a0 \u00a0 CONSTRAINT pk_patient PRIMARY KEY (mt_id, patient_name)\n+)\n+PARTITION BY RANGE (mt_id) (STARTING 0 INCLUSIVE ENDING 0 INCLUSIVE);\n+```\n+\n+Each tenant is allocated a unique integer value for mt_id (multi-tenant id), with a range partition used to define which table partition is to be used for a particular tenant's mt_id. The mapping of tenant name to mt_id value is maintained in the FHIR_ADMIN.TENANTS table.\n+\n+The above example assumes that patient_name will be unique within the context of a single tenant, which obviously does not apply to the actual IBM FHIR Server schema. The primary key must include the partition range key `mt_id`. In addition, any secondary indexes MUST also include mt_id to ensure they are always local to the partition. For example:\n+\n+```\n+CREATE UNIQUE INDEX ptng.unq_ssn ON ptng.patients(mt_id, ssn);\n+```\n+\n+Local indexes are important to ensure proper tenant data isolation, with the added benefit of simplifying the task of removing the tenant when the time comes.\n+\n+## Per-Tenant Tablespaces\n+\n+Each tenant is allocated its own tablespace, and the table and index partitions for that tenant are all assigned to that tablespace, as depicted below:\n+\n+>![](partitioned_tables.png)\n+\n+Note: historically, DBAs would often cook up complex database layouts, using different tablespaces for tables and indexes to try and balance the IO workload for optimal throughput and/or latency. In cloud environments with heavily virtualized storage, this becomes less relevant and so leveraging tablespaces to provide an application function (isolating tenant data) is reasonable.\n+\n+Each tablespace is mapped to one or containers which are typically files at the OS filesystem level. When the tablespace is dropped, these files are deleted. The schema also defines a common tablespace `FHIR_TS` which is used for the base table definition. Db2 requires that a table and its partitions must use tablespaces with the same extent size.\n+\n+The tablespaces are created with automatic storage using an EXTENTSIZE of 4 (x32KB) pages to reduce overhead and improve deployment times. This is due to the large number of objects (tables and indexes) created in the schema, each requiring an initial number of extents. \n+\n+To add a new tenant, a utility program connects to Db2 as the FHIRADMIN user and adds records to the FHIR_ADMIN.TENANTS and FHIR_ADMIN.TENANT_KEYS tables. The utility probram then uses the newly assigned mt_id value when adding new partitions to each of the tables in the FHIRDATA schema.\n+\n+The tablespace is managed automatically with an ([EXTENTSIZE](https://www.ibm.com/support/knowledgecenter/SSEPGG_11.5.0/com.ibm.db2.luw.admin.dbobj.doc/doc/c0004964.html)) of 128KB. Note, the extentsize is multiplied by the pagesize to arrive at a storage size.\n+\n+Each tenant is allocated a partition based on the MT_ID and assigned to a tablespace. The tenant `tablespace` is created one time and no changes to the tablespace are expected.\n+\n+In general, smaller extent sizes can harm the performance of table and index scans because they limit the amount of data which can be read in a single IO operation. However, such scans are not common in most FHIR query use-cases, so this tends to not be an issue.\n+\n+\n+## Multi-tenant Queries\n+\n+We could use the multi-tenant enabled table definition as-is and modify every SQL statement to include `AND mt_id = ?` but this is error-prone and risky. If a query was missed or poorly written and ran without that predicate, it could expose data from another tenant.\n+\n+Instead, we leverage DB2 permission objects which allow us to specify a filter condition. Each query submitted by the application is rewritten by the database to include the `FOR ROWS WHERE` predicate, which is defined as: \n+\n+```\n+CREATE PERMISSION ROW_ACCESS ON ptng.patients\n+\u00a0\u00a0 \u00a0 \u00a0 \u00a0 FOR ROWS WHERE patients.mt_id = ptng.session_tenant\n+\u00a0\u00a0 \u00a0 \u00a0 \u00a0 ENFORCED FOR ALL ACCESS\n+\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ENABLE;\n+\n+ALTER TABLE ptng.patients ACTIVATE ROW ACCESS CONTROL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "originalPosition": 96}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMDI4NjIw", "url": "https://github.com/IBM/FHIR/pull/1165#pullrequestreview-421028620", "createdAt": "2020-05-29T14:52:04Z", "commit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNDo1MjowNFrOGcgK6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNDo1MjowNFrOGcgK6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU0MDM5NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            SET ptng.session_tenant = 1;\n          \n          \n            \n            SELECT * FROM ptng.patients;\n          \n          \n            \n            commit;\n          \n          \n            \n            ```\n          \n          \n            \n            \n          \n          \n            \n            Internally, DB2 rewrites the query to look like this:\n          \n          \n            \n            \n          \n          \n            \n            ```\n          \n          \n            \n            SELECT * FROM ptng.patients WHERE mt_id = 1;\n          \n          \n            \n            ```\n          \n          \n            \n            \n          \n          \n            \n            Because the table `ptng.patients` is partitioned using mt_id, the query optimizer is able to perform a partition-prune, by limiting the query access to the partition associated with the tenant. This results in a query execution plan very similar in terms of performance to a single-tenant scenario without any partitioning.\n          \n          \n            \n            SET fhirdata.session_tenant = 1;\n          \n          \n            \n            SELECT * FROM fhirdata.patients;\n          \n          \n            \n            commit;\n          \n      \n    \n    \n  \n\nInternally, DB2 rewrites the query to look like this:\nSELECT * FROM fhirdata.patients WHERE mt_id = 1;\n\nBecause the table fhirdata.patients is partitioned using mt_id, the query optimizer is able to perform a partition-prune, by limiting the query access to the partition associated with the tenant. This results in a query execution plan very similar in terms of performance to a single-tenant scenario without any partitioning.", "url": "https://github.com/IBM/FHIR/pull/1165#discussion_r432540394", "createdAt": "2020-05-29T14:52:04Z", "author": {"login": "prb112"}, "path": "fhir-persistence-schema/docs/DB2MultiTenancy.md", "diffHunk": "@@ -1,16 +1,225 @@\n-# The IBM FHIR Server - Db2 Multi-Tenancy\n+# The IBM FHIR Server - Multi-Tenancy on Db2\n \n-This document outlines the schema design and implementation for the IBM FHIR Server's Db2 Multi-tenancy feature. \n+This document outlines the schema design and implementation for the IBM FHIR Server's Multi-tenancy feature on Db2.\n \n The Multi-tenancy feature has two main areas of focus: \n - Tenant Provisioning  \n - Security\n \n-## Multi-Tenancy Schema Design\n+This document assumes familiarity with the general [IBM FHIR Server schema design](SchemaMigration.md).\n+\n+# Multi-Tenancy Concepts and Design\n+\n+The IBM FHIR Server design supports three levels of multi-tenancy:\n+\n+1. Separate database per tenant\n+2. Separate data schema per tenant\n+3. (Db2-only) multiple tenants per schema, partitioned with row-based access control and per-tenant tablespaces.\n+\n+Of course, an entire deployment (application servers and database) also could be dedicated to a single tenant, which is really just a variant of option 1 above, although clearly such a configuration would not be considered multi-tenant.\n+\n+## Tenant Data Administration\n+\n+The IBM FHIR Server separates schema administration data from user data. All administration data is held in tables within the FHIRADMIN schema, and these tables are not directly accessible by the IBM FHIR Server database user.\n+\n+The FHIRADMIN schema is used to manage schema version migrations as well as tenant configuration for any tenants resident in the given database. The FHIRADMIN schema does not manage tenants in other databases.\n+\n+See the general [IBM FHIR Server schema design](SchemaMigration.md) documentation for a more detailed description of how FHIRADMIN tables are used to manage schema versions.\n+\n+\n+## Multi-tenancy using Db2 Table Partitions and Per Tenant Tablespaces\n+\n+The IBM FHIR Server provides a multi-tenancy feature based on Db2 row-based access control and table partitioning features.\n+\n+Each new tenant is allocated a unique tenant id value which is of database type `INT`. All tables in the IBM FHIR Server data schema (typically `FHIRDATA`) are created as range partitioned and configured with row-based access control. \n+\n+As an example, consider a table of patients created using the following DDL (illustrative only, this is not the actual IBM FHIR Server schema):\n+\n+```\n+CREATE TABLE ptng.patients (\n+\u00a0 \u00a0 mt_id \u00a0 \u00a0 \u00a0 \u00a0 \u00a0     INT \u00a0 \u00a0 NOT NULL,\n+\u00a0 \u00a0 patient_name\u00a0 \u00a0 VARCHAR(18) NOT NULL,\n+\u00a0 \u00a0 age \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 INT \u00a0 \u00a0 NOT NULL,\n+\u00a0 \u00a0 doctor_name \u00a0 \u00a0 VARCHAR(18),\n+\u00a0 \u00a0 ssn\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 CHAR(11),\n+\u00a0 \u00a0 CONSTRAINT pk_patient PRIMARY KEY (mt_id, patient_name)\n+)\n+PARTITION BY RANGE (mt_id) (STARTING 0 INCLUSIVE ENDING 0 INCLUSIVE);\n+```\n+\n+Each tenant is allocated a unique integer value for mt_id (multi-tenant id), with a range partition used to define which table partition is to be used for a particular tenant's mt_id. The mapping of tenant name to mt_id value is maintained in the FHIR_ADMIN.TENANTS table.\n+\n+The above example assumes that patient_name will be unique within the context of a single tenant, which obviously does not apply to the actual IBM FHIR Server schema. The primary key must include the partition range key `mt_id`. In addition, any secondary indexes MUST also include mt_id to ensure they are always local to the partition. For example:\n+\n+```\n+CREATE UNIQUE INDEX ptng.unq_ssn ON ptng.patients(mt_id, ssn);\n+```\n+\n+Local indexes are important to ensure proper tenant data isolation, with the added benefit of simplifying the task of removing the tenant when the time comes.\n+\n+## Per-Tenant Tablespaces\n+\n+Each tenant is allocated its own tablespace, and the table and index partitions for that tenant are all assigned to that tablespace, as depicted below:\n+\n+>![](partitioned_tables.png)\n+\n+Note: historically, DBAs would often cook up complex database layouts, using different tablespaces for tables and indexes to try and balance the IO workload for optimal throughput and/or latency. In cloud environments with heavily virtualized storage, this becomes less relevant and so leveraging tablespaces to provide an application function (isolating tenant data) is reasonable.\n+\n+Each tablespace is mapped to one or containers which are typically files at the OS filesystem level. When the tablespace is dropped, these files are deleted. The schema also defines a common tablespace `FHIR_TS` which is used for the base table definition. Db2 requires that a table and its partitions must use tablespaces with the same extent size.\n+\n+The tablespaces are created with automatic storage using an EXTENTSIZE of 4 (x32KB) pages to reduce overhead and improve deployment times. This is due to the large number of objects (tables and indexes) created in the schema, each requiring an initial number of extents. \n+\n+To add a new tenant, a utility program connects to Db2 as the FHIRADMIN user and adds records to the FHIR_ADMIN.TENANTS and FHIR_ADMIN.TENANT_KEYS tables. The utility probram then uses the newly assigned mt_id value when adding new partitions to each of the tables in the FHIRDATA schema.\n+\n+The tablespace is managed automatically with an ([EXTENTSIZE](https://www.ibm.com/support/knowledgecenter/SSEPGG_11.5.0/com.ibm.db2.luw.admin.dbobj.doc/doc/c0004964.html)) of 128KB. Note, the extentsize is multiplied by the pagesize to arrive at a storage size.\n+\n+Each tenant is allocated a partition based on the MT_ID and assigned to a tablespace. The tenant `tablespace` is created one time and no changes to the tablespace are expected.\n+\n+In general, smaller extent sizes can harm the performance of table and index scans because they limit the amount of data which can be read in a single IO operation. However, such scans are not common in most FHIR query use-cases, so this tends to not be an issue.\n+\n+\n+## Multi-tenant Queries\n+\n+We could use the multi-tenant enabled table definition as-is and modify every SQL statement to include `AND mt_id = ?` but this is error-prone and risky. If a query was missed or poorly written and ran without that predicate, it could expose data from another tenant.\n+\n+Instead, we leverage DB2 permission objects which allow us to specify a filter condition. Each query submitted by the application is rewritten by the database to include the `FOR ROWS WHERE` predicate, which is defined as: \n+\n+```\n+CREATE PERMISSION ROW_ACCESS ON ptng.patients\n+\u00a0\u00a0 \u00a0 \u00a0 \u00a0 FOR ROWS WHERE patients.mt_id = ptng.session_tenant\n+\u00a0\u00a0 \u00a0 \u00a0 \u00a0 ENFORCED FOR ALL ACCESS\n+\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ENABLE;\n+\n+ALTER TABLE ptng.patients ACTIVATE ROW ACCESS CONTROL;\n+```\n+\n+The `session_tenant` above is defined as a session variable. The application must set the value to match the mt_id value configured for the tenant.\n+\n+Logically:\n+\n+```\n+SET ptng.session_tenant = 1;\n+SELECT * FROM ptng.patients;\n+commit;\n+```\n+\n+Internally, DB2 rewrites the query to look like this:\n+\n+```\n+SELECT * FROM ptng.patients WHERE mt_id = 1;\n+```\n+\n+Because the table `ptng.patients` is partitioned using mt_id, the query optimizer is able to perform a partition-prune, by limiting the query access to the partition associated with the tenant. This results in a query execution plan very similar in terms of performance to a single-tenant scenario without any partitioning.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "originalPosition": 115}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMDI4ODA2", "url": "https://github.com/IBM/FHIR/pull/1165#pullrequestreview-421028806", "createdAt": "2020-05-29T14:52:18Z", "commit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNDo1MjoxOFrOGcgLdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNDo1MjoxOFrOGcgLdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU0MDUzMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ALTER TABLE ptng.patients ADD PARTITION TENANT1 STARTING 1 INCLUSIVE ENDING 1 INCLUSIVE IN TS_TENANT1;\n          \n          \n            \n            \n          \n          \n            \n            -- for tenant #2\n          \n          \n            \n            ALTER TABLE ptng.patients ADD PARTITION TENANT2 STARTING 2 INCLUSIVE ENDING 2 INCLUSIVE IN TS_TENANT2;\n          \n          \n            \n            ALTER TABLE fhirdata.patients ADD PARTITION TENANT1 STARTING 1 INCLUSIVE ENDING 1 INCLUSIVE IN TS_TENANT1;\n          \n          \n            \n            \n          \n          \n            \n            -- for tenant #2\n          \n          \n            \n            ALTER TABLE fhirdata.patients ADD PARTITION TENANT2 STARTING 2 INCLUSIVE ENDING 2 INCLUSIVE IN TS_TENANT2;", "url": "https://github.com/IBM/FHIR/pull/1165#discussion_r432540532", "createdAt": "2020-05-29T14:52:18Z", "author": {"login": "prb112"}, "path": "fhir-persistence-schema/docs/DB2MultiTenancy.md", "diffHunk": "@@ -1,16 +1,225 @@\n-# The IBM FHIR Server - Db2 Multi-Tenancy\n+# The IBM FHIR Server - Multi-Tenancy on Db2\n \n-This document outlines the schema design and implementation for the IBM FHIR Server's Db2 Multi-tenancy feature. \n+This document outlines the schema design and implementation for the IBM FHIR Server's Multi-tenancy feature on Db2.\n \n The Multi-tenancy feature has two main areas of focus: \n - Tenant Provisioning  \n - Security\n \n-## Multi-Tenancy Schema Design\n+This document assumes familiarity with the general [IBM FHIR Server schema design](SchemaMigration.md).\n+\n+# Multi-Tenancy Concepts and Design\n+\n+The IBM FHIR Server design supports three levels of multi-tenancy:\n+\n+1. Separate database per tenant\n+2. Separate data schema per tenant\n+3. (Db2-only) multiple tenants per schema, partitioned with row-based access control and per-tenant tablespaces.\n+\n+Of course, an entire deployment (application servers and database) also could be dedicated to a single tenant, which is really just a variant of option 1 above, although clearly such a configuration would not be considered multi-tenant.\n+\n+## Tenant Data Administration\n+\n+The IBM FHIR Server separates schema administration data from user data. All administration data is held in tables within the FHIRADMIN schema, and these tables are not directly accessible by the IBM FHIR Server database user.\n+\n+The FHIRADMIN schema is used to manage schema version migrations as well as tenant configuration for any tenants resident in the given database. The FHIRADMIN schema does not manage tenants in other databases.\n+\n+See the general [IBM FHIR Server schema design](SchemaMigration.md) documentation for a more detailed description of how FHIRADMIN tables are used to manage schema versions.\n+\n+\n+## Multi-tenancy using Db2 Table Partitions and Per Tenant Tablespaces\n+\n+The IBM FHIR Server provides a multi-tenancy feature based on Db2 row-based access control and table partitioning features.\n+\n+Each new tenant is allocated a unique tenant id value which is of database type `INT`. All tables in the IBM FHIR Server data schema (typically `FHIRDATA`) are created as range partitioned and configured with row-based access control. \n+\n+As an example, consider a table of patients created using the following DDL (illustrative only, this is not the actual IBM FHIR Server schema):\n+\n+```\n+CREATE TABLE ptng.patients (\n+\u00a0 \u00a0 mt_id \u00a0 \u00a0 \u00a0 \u00a0 \u00a0     INT \u00a0 \u00a0 NOT NULL,\n+\u00a0 \u00a0 patient_name\u00a0 \u00a0 VARCHAR(18) NOT NULL,\n+\u00a0 \u00a0 age \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 INT \u00a0 \u00a0 NOT NULL,\n+\u00a0 \u00a0 doctor_name \u00a0 \u00a0 VARCHAR(18),\n+\u00a0 \u00a0 ssn\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 CHAR(11),\n+\u00a0 \u00a0 CONSTRAINT pk_patient PRIMARY KEY (mt_id, patient_name)\n+)\n+PARTITION BY RANGE (mt_id) (STARTING 0 INCLUSIVE ENDING 0 INCLUSIVE);\n+```\n+\n+Each tenant is allocated a unique integer value for mt_id (multi-tenant id), with a range partition used to define which table partition is to be used for a particular tenant's mt_id. The mapping of tenant name to mt_id value is maintained in the FHIR_ADMIN.TENANTS table.\n+\n+The above example assumes that patient_name will be unique within the context of a single tenant, which obviously does not apply to the actual IBM FHIR Server schema. The primary key must include the partition range key `mt_id`. In addition, any secondary indexes MUST also include mt_id to ensure they are always local to the partition. For example:\n+\n+```\n+CREATE UNIQUE INDEX ptng.unq_ssn ON ptng.patients(mt_id, ssn);\n+```\n+\n+Local indexes are important to ensure proper tenant data isolation, with the added benefit of simplifying the task of removing the tenant when the time comes.\n+\n+## Per-Tenant Tablespaces\n+\n+Each tenant is allocated its own tablespace, and the table and index partitions for that tenant are all assigned to that tablespace, as depicted below:\n+\n+>![](partitioned_tables.png)\n+\n+Note: historically, DBAs would often cook up complex database layouts, using different tablespaces for tables and indexes to try and balance the IO workload for optimal throughput and/or latency. In cloud environments with heavily virtualized storage, this becomes less relevant and so leveraging tablespaces to provide an application function (isolating tenant data) is reasonable.\n+\n+Each tablespace is mapped to one or containers which are typically files at the OS filesystem level. When the tablespace is dropped, these files are deleted. The schema also defines a common tablespace `FHIR_TS` which is used for the base table definition. Db2 requires that a table and its partitions must use tablespaces with the same extent size.\n+\n+The tablespaces are created with automatic storage using an EXTENTSIZE of 4 (x32KB) pages to reduce overhead and improve deployment times. This is due to the large number of objects (tables and indexes) created in the schema, each requiring an initial number of extents. \n+\n+To add a new tenant, a utility program connects to Db2 as the FHIRADMIN user and adds records to the FHIR_ADMIN.TENANTS and FHIR_ADMIN.TENANT_KEYS tables. The utility probram then uses the newly assigned mt_id value when adding new partitions to each of the tables in the FHIRDATA schema.\n+\n+The tablespace is managed automatically with an ([EXTENTSIZE](https://www.ibm.com/support/knowledgecenter/SSEPGG_11.5.0/com.ibm.db2.luw.admin.dbobj.doc/doc/c0004964.html)) of 128KB. Note, the extentsize is multiplied by the pagesize to arrive at a storage size.\n+\n+Each tenant is allocated a partition based on the MT_ID and assigned to a tablespace. The tenant `tablespace` is created one time and no changes to the tablespace are expected.\n+\n+In general, smaller extent sizes can harm the performance of table and index scans because they limit the amount of data which can be read in a single IO operation. However, such scans are not common in most FHIR query use-cases, so this tends to not be an issue.\n+\n+\n+## Multi-tenant Queries\n+\n+We could use the multi-tenant enabled table definition as-is and modify every SQL statement to include `AND mt_id = ?` but this is error-prone and risky. If a query was missed or poorly written and ran without that predicate, it could expose data from another tenant.\n+\n+Instead, we leverage DB2 permission objects which allow us to specify a filter condition. Each query submitted by the application is rewritten by the database to include the `FOR ROWS WHERE` predicate, which is defined as: \n+\n+```\n+CREATE PERMISSION ROW_ACCESS ON ptng.patients\n+\u00a0\u00a0 \u00a0 \u00a0 \u00a0 FOR ROWS WHERE patients.mt_id = ptng.session_tenant\n+\u00a0\u00a0 \u00a0 \u00a0 \u00a0 ENFORCED FOR ALL ACCESS\n+\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ENABLE;\n+\n+ALTER TABLE ptng.patients ACTIVATE ROW ACCESS CONTROL;\n+```\n+\n+The `session_tenant` above is defined as a session variable. The application must set the value to match the mt_id value configured for the tenant.\n+\n+Logically:\n+\n+```\n+SET ptng.session_tenant = 1;\n+SELECT * FROM ptng.patients;\n+commit;\n+```\n+\n+Internally, DB2 rewrites the query to look like this:\n+\n+```\n+SELECT * FROM ptng.patients WHERE mt_id = 1;\n+```\n+\n+Because the table `ptng.patients` is partitioned using mt_id, the query optimizer is able to perform a partition-prune, by limiting the query access to the partition associated with the tenant. This results in a query execution plan very similar in terms of performance to a single-tenant scenario without any partitioning.\n+\n+To isolate a tenant's data at the file-system level, a tablespace is created per tenant and the partition objects are are allocated to that tablespace, including any local indexes:\n+\n+```\n+CREATE TABLESPACE TS_TENANT1 MANAGED BY AUTOMATIC STORAGE;\n+CREATE TABLESPACE TS_TENANT2 MANAGED BY AUTOMATIC STORAGE;\n+```\n+\n+\n+Adding new tenants requires adding partitions to each table in the data schema. Note how the partition is configured with the tenant's specific tablespace:\n+\n+```\n+-- for tenant #1\n+ALTER TABLE ptng.patients ADD PARTITION TENANT1 STARTING 1 INCLUSIVE ENDING 1 INCLUSIVE IN TS_TENANT1;\n+\n+-- for tenant #2\n+ALTER TABLE ptng.patients ADD PARTITION TENANT2 STARTING 2 INCLUSIVE ENDING 2 INCLUSIVE IN TS_TENANT2;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "originalPosition": 132}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMDMwMjA2", "url": "https://github.com/IBM/FHIR/pull/1165#pullrequestreview-421030206", "createdAt": "2020-05-29T14:53:52Z", "commit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNDo1Mzo1MlrOGcgPfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNDo1Mzo1MlrOGcgPfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU0MTU2NQ==", "bodyText": "Right now, 3 is only the one supported, we should be clear that this is the schema design. and not the fhir server", "url": "https://github.com/IBM/FHIR/pull/1165#discussion_r432541565", "createdAt": "2020-05-29T14:53:52Z", "author": {"login": "prb112"}, "path": "fhir-persistence-schema/docs/DB2MultiTenancy.md", "diffHunk": "@@ -1,16 +1,225 @@\n-# The IBM FHIR Server - Db2 Multi-Tenancy\n+# The IBM FHIR Server - Multi-Tenancy on Db2\n \n-This document outlines the schema design and implementation for the IBM FHIR Server's Db2 Multi-tenancy feature. \n+This document outlines the schema design and implementation for the IBM FHIR Server's Multi-tenancy feature on Db2.\n \n The Multi-tenancy feature has two main areas of focus: \n - Tenant Provisioning  \n - Security\n \n-## Multi-Tenancy Schema Design\n+This document assumes familiarity with the general [IBM FHIR Server schema design](SchemaMigration.md).\n+\n+# Multi-Tenancy Concepts and Design\n+\n+The IBM FHIR Server design supports three levels of multi-tenancy:\n+\n+1. Separate database per tenant\n+2. Separate data schema per tenant\n+3. (Db2-only) multiple tenants per schema, partitioned with row-based access control and per-tenant tablespaces.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "originalPosition": 20}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMDMwNDkz", "url": "https://github.com/IBM/FHIR/pull/1165#pullrequestreview-421030493", "createdAt": "2020-05-29T14:54:09Z", "commit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNDo1NDowOVrOGcgQUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNDo1NDowOVrOGcgQUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU0MTc3Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The IBM FHIR Server separates schema administration data from user data. All administration data is held in tables within the FHIRADMIN schema, and these tables are not directly accessible by the IBM FHIR Server database user.\n          \n          \n            \n            The IBM FHIR Server separates schema administration data from user data. All administration data is held in tables within the FHIR_ADMIN schema, and these tables are not directly accessible by the IBM FHIR Server database user.", "url": "https://github.com/IBM/FHIR/pull/1165#discussion_r432541777", "createdAt": "2020-05-29T14:54:09Z", "author": {"login": "prb112"}, "path": "fhir-persistence-schema/docs/DB2MultiTenancy.md", "diffHunk": "@@ -1,16 +1,225 @@\n-# The IBM FHIR Server - Db2 Multi-Tenancy\n+# The IBM FHIR Server - Multi-Tenancy on Db2\n \n-This document outlines the schema design and implementation for the IBM FHIR Server's Db2 Multi-tenancy feature. \n+This document outlines the schema design and implementation for the IBM FHIR Server's Multi-tenancy feature on Db2.\n \n The Multi-tenancy feature has two main areas of focus: \n - Tenant Provisioning  \n - Security\n \n-## Multi-Tenancy Schema Design\n+This document assumes familiarity with the general [IBM FHIR Server schema design](SchemaMigration.md).\n+\n+# Multi-Tenancy Concepts and Design\n+\n+The IBM FHIR Server design supports three levels of multi-tenancy:\n+\n+1. Separate database per tenant\n+2. Separate data schema per tenant\n+3. (Db2-only) multiple tenants per schema, partitioned with row-based access control and per-tenant tablespaces.\n+\n+Of course, an entire deployment (application servers and database) also could be dedicated to a single tenant, which is really just a variant of option 1 above, although clearly such a configuration would not be considered multi-tenant.\n+\n+## Tenant Data Administration\n+\n+The IBM FHIR Server separates schema administration data from user data. All administration data is held in tables within the FHIRADMIN schema, and these tables are not directly accessible by the IBM FHIR Server database user.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMDMwNzI4", "url": "https://github.com/IBM/FHIR/pull/1165#pullrequestreview-421030728", "createdAt": "2020-05-29T14:54:24Z", "commit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNDo1NDoyNFrOGcgQ_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNDo1NDoyNFrOGcgQ_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU0MTk1MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The FHIRADMIN schema is used to manage schema version migrations as well as tenant configuration for any tenants resident in the given database. The FHIRADMIN schema does not manage tenants in other databases.\n          \n          \n            \n            The FHIR_ADMIN schema is used to manage schema version migrations as well as tenant configuration for any tenants resident in the given database. The FHIR_ADMIN schema does not manage tenants in other databases.", "url": "https://github.com/IBM/FHIR/pull/1165#discussion_r432541951", "createdAt": "2020-05-29T14:54:24Z", "author": {"login": "prb112"}, "path": "fhir-persistence-schema/docs/DB2MultiTenancy.md", "diffHunk": "@@ -1,16 +1,225 @@\n-# The IBM FHIR Server - Db2 Multi-Tenancy\n+# The IBM FHIR Server - Multi-Tenancy on Db2\n \n-This document outlines the schema design and implementation for the IBM FHIR Server's Db2 Multi-tenancy feature. \n+This document outlines the schema design and implementation for the IBM FHIR Server's Multi-tenancy feature on Db2.\n \n The Multi-tenancy feature has two main areas of focus: \n - Tenant Provisioning  \n - Security\n \n-## Multi-Tenancy Schema Design\n+This document assumes familiarity with the general [IBM FHIR Server schema design](SchemaMigration.md).\n+\n+# Multi-Tenancy Concepts and Design\n+\n+The IBM FHIR Server design supports three levels of multi-tenancy:\n+\n+1. Separate database per tenant\n+2. Separate data schema per tenant\n+3. (Db2-only) multiple tenants per schema, partitioned with row-based access control and per-tenant tablespaces.\n+\n+Of course, an entire deployment (application servers and database) also could be dedicated to a single tenant, which is really just a variant of option 1 above, although clearly such a configuration would not be considered multi-tenant.\n+\n+## Tenant Data Administration\n+\n+The IBM FHIR Server separates schema administration data from user data. All administration data is held in tables within the FHIRADMIN schema, and these tables are not directly accessible by the IBM FHIR Server database user.\n+\n+The FHIRADMIN schema is used to manage schema version migrations as well as tenant configuration for any tenants resident in the given database. The FHIRADMIN schema does not manage tenants in other databases.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "originalPosition": 28}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMDMxMTQ3", "url": "https://github.com/IBM/FHIR/pull/1165#pullrequestreview-421031147", "createdAt": "2020-05-29T14:54:53Z", "commit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNDo1NDo1M1rOGcgSQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNDo1NDo1M1rOGcgSQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU0MjI3Mg==", "bodyText": "Suggested change", "url": "https://github.com/IBM/FHIR/pull/1165#discussion_r432542272", "createdAt": "2020-05-29T14:54:53Z", "author": {"login": "prb112"}, "path": "fhir-persistence-schema/docs/DB2MultiTenancy.md", "diffHunk": "@@ -1,16 +1,225 @@\n-# The IBM FHIR Server - Db2 Multi-Tenancy\n+# The IBM FHIR Server - Multi-Tenancy on Db2\n \n-This document outlines the schema design and implementation for the IBM FHIR Server's Db2 Multi-tenancy feature. \n+This document outlines the schema design and implementation for the IBM FHIR Server's Multi-tenancy feature on Db2.\n \n The Multi-tenancy feature has two main areas of focus: \n - Tenant Provisioning  \n - Security\n \n-## Multi-Tenancy Schema Design\n+This document assumes familiarity with the general [IBM FHIR Server schema design](SchemaMigration.md).\n+\n+# Multi-Tenancy Concepts and Design\n+\n+The IBM FHIR Server design supports three levels of multi-tenancy:\n+\n+1. Separate database per tenant\n+2. Separate data schema per tenant\n+3. (Db2-only) multiple tenants per schema, partitioned with row-based access control and per-tenant tablespaces.\n+\n+Of course, an entire deployment (application servers and database) also could be dedicated to a single tenant, which is really just a variant of option 1 above, although clearly such a configuration would not be considered multi-tenant.\n+\n+## Tenant Data Administration\n+\n+The IBM FHIR Server separates schema administration data from user data. All administration data is held in tables within the FHIRADMIN schema, and these tables are not directly accessible by the IBM FHIR Server database user.\n+\n+The FHIRADMIN schema is used to manage schema version migrations as well as tenant configuration for any tenants resident in the given database. The FHIRADMIN schema does not manage tenants in other databases.\n+\n+See the general [IBM FHIR Server schema design](SchemaMigration.md) documentation for a more detailed description of how FHIRADMIN tables are used to manage schema versions.\n+\n+\n+## Multi-tenancy using Db2 Table Partitions and Per Tenant Tablespaces\n+\n+The IBM FHIR Server provides a multi-tenancy feature based on Db2 row-based access control and table partitioning features.\n+\n+Each new tenant is allocated a unique tenant id value which is of database type `INT`. All tables in the IBM FHIR Server data schema (typically `FHIRDATA`) are created as range partitioned and configured with row-based access control. \n+\n+As an example, consider a table of patients created using the following DDL (illustrative only, this is not the actual IBM FHIR Server schema):\n+\n+```\n+CREATE TABLE ptng.patients (\n+\u00a0 \u00a0 mt_id \u00a0 \u00a0 \u00a0 \u00a0 \u00a0     INT \u00a0 \u00a0 NOT NULL,\n+\u00a0 \u00a0 patient_name\u00a0 \u00a0 VARCHAR(18) NOT NULL,\n+\u00a0 \u00a0 age \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 INT \u00a0 \u00a0 NOT NULL,\n+\u00a0 \u00a0 doctor_name \u00a0 \u00a0 VARCHAR(18),\n+\u00a0 \u00a0 ssn\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 CHAR(11),\n+\u00a0 \u00a0 CONSTRAINT pk_patient PRIMARY KEY (mt_id, patient_name)\n+)\n+PARTITION BY RANGE (mt_id) (STARTING 0 INCLUSIVE ENDING 0 INCLUSIVE);\n+```\n+\n+Each tenant is allocated a unique integer value for mt_id (multi-tenant id), with a range partition used to define which table partition is to be used for a particular tenant's mt_id. The mapping of tenant name to mt_id value is maintained in the FHIR_ADMIN.TENANTS table.\n+\n+The above example assumes that patient_name will be unique within the context of a single tenant, which obviously does not apply to the actual IBM FHIR Server schema. The primary key must include the partition range key `mt_id`. In addition, any secondary indexes MUST also include mt_id to ensure they are always local to the partition. For example:\n+\n+```\n+CREATE UNIQUE INDEX ptng.unq_ssn ON ptng.patients(mt_id, ssn);\n+```\n+\n+Local indexes are important to ensure proper tenant data isolation, with the added benefit of simplifying the task of removing the tenant when the time comes.\n+\n+## Per-Tenant Tablespaces\n+\n+Each tenant is allocated its own tablespace, and the table and index partitions for that tenant are all assigned to that tablespace, as depicted below:\n+\n+>![](partitioned_tables.png)\n+\n+Note: historically, DBAs would often cook up complex database layouts, using different tablespaces for tables and indexes to try and balance the IO workload for optimal throughput and/or latency. In cloud environments with heavily virtualized storage, this becomes less relevant and so leveraging tablespaces to provide an application function (isolating tenant data) is reasonable.\n+\n+Each tablespace is mapped to one or containers which are typically files at the OS filesystem level. When the tablespace is dropped, these files are deleted. The schema also defines a common tablespace `FHIR_TS` which is used for the base table definition. Db2 requires that a table and its partitions must use tablespaces with the same extent size.\n+\n+The tablespaces are created with automatic storage using an EXTENTSIZE of 4 (x32KB) pages to reduce overhead and improve deployment times. This is due to the large number of objects (tables and indexes) created in the schema, each requiring an initial number of extents. \n+\n+To add a new tenant, a utility program connects to Db2 as the FHIRADMIN user and adds records to the FHIR_ADMIN.TENANTS and FHIR_ADMIN.TENANT_KEYS tables. The utility probram then uses the newly assigned mt_id value when adding new partitions to each of the tables in the FHIRDATA schema.\n+\n+The tablespace is managed automatically with an ([EXTENTSIZE](https://www.ibm.com/support/knowledgecenter/SSEPGG_11.5.0/com.ibm.db2.luw.admin.dbobj.doc/doc/c0004964.html)) of 128KB. Note, the extentsize is multiplied by the pagesize to arrive at a storage size.\n+\n+Each tenant is allocated a partition based on the MT_ID and assigned to a tablespace. The tenant `tablespace` is created one time and no changes to the tablespace are expected.\n+\n+In general, smaller extent sizes can harm the performance of table and index scans because they limit the amount of data which can be read in a single IO operation. However, such scans are not common in most FHIR query use-cases, so this tends to not be an issue.\n+\n+\n+## Multi-tenant Queries\n+\n+We could use the multi-tenant enabled table definition as-is and modify every SQL statement to include `AND mt_id = ?` but this is error-prone and risky. If a query was missed or poorly written and ran without that predicate, it could expose data from another tenant.\n+\n+Instead, we leverage DB2 permission objects which allow us to specify a filter condition. Each query submitted by the application is rewritten by the database to include the `FOR ROWS WHERE` predicate, which is defined as: \n+\n+```\n+CREATE PERMISSION ROW_ACCESS ON ptng.patients\n+\u00a0\u00a0 \u00a0 \u00a0 \u00a0 FOR ROWS WHERE patients.mt_id = ptng.session_tenant\n+\u00a0\u00a0 \u00a0 \u00a0 \u00a0 ENFORCED FOR ALL ACCESS\n+\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ENABLE;\n+\n+ALTER TABLE ptng.patients ACTIVATE ROW ACCESS CONTROL;\n+```\n+\n+The `session_tenant` above is defined as a session variable. The application must set the value to match the mt_id value configured for the tenant.\n+\n+Logically:\n+\n+```\n+SET ptng.session_tenant = 1;\n+SELECT * FROM ptng.patients;\n+commit;\n+```\n+\n+Internally, DB2 rewrites the query to look like this:\n+\n+```\n+SELECT * FROM ptng.patients WHERE mt_id = 1;\n+```\n+\n+Because the table `ptng.patients` is partitioned using mt_id, the query optimizer is able to perform a partition-prune, by limiting the query access to the partition associated with the tenant. This results in a query execution plan very similar in terms of performance to a single-tenant scenario without any partitioning.\n+\n+To isolate a tenant's data at the file-system level, a tablespace is created per tenant and the partition objects are are allocated to that tablespace, including any local indexes:\n+\n+```\n+CREATE TABLESPACE TS_TENANT1 MANAGED BY AUTOMATIC STORAGE;\n+CREATE TABLESPACE TS_TENANT2 MANAGED BY AUTOMATIC STORAGE;\n+```\n+\n+\n+Adding new tenants requires adding partitions to each table in the data schema. Note how the partition is configured with the tenant's specific tablespace:\n+\n+```\n+-- for tenant #1\n+ALTER TABLE ptng.patients ADD PARTITION TENANT1 STARTING 1 INCLUSIVE ENDING 1 INCLUSIVE IN TS_TENANT1;\n+\n+-- for tenant #2\n+ALTER TABLE ptng.patients ADD PARTITION TENANT2 STARTING 2 INCLUSIVE ENDING 2 INCLUSIVE IN TS_TENANT2;\n+```\n+\n+When the tenant is deleted, the partition associated with the tenant is detached and subsequently dropped from the database. This renders the tenant data inaccessible from the perspective of a database user. However, database space management does not necessarily overwrite the freed blocks. Although the data is encrypted, someone with the database key and sufficient time, tooling and knowledge could theoretically retrieve parts of the data. By using a tablespace which is dropped, the database will delete the files at the OS layer.\n+\n+The process to delete a tenant is (logically):\n+\n+```\n+ALTER TABLE <tbl> DETACH PARTITION INTO <tbl_drp1>;\n+...\n+COMMIT;\n+DROP TABLE <tbl_drp1>;\n+...\n+COMMIT;\n+DROP TABLESPACE TS_TENANT1;\n+```\n+\n+In this case, TS_TENANT1 is the name of the tablespace previously assigned to the tenant being dropped.\n+\n+Note that DB2 requires a commit after the partition is detached and before the table `<tbl_drp1>` can be dropped. The tooling must implement this process to be idempotent to handle cases where a detach or drop might fail.\n+\n+Dropping partitions in this way works by swizzling metadata in the catalog which requires very little (redo) logging and is therefore far more efficient than deleting actual rows of data.\n+\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "originalPosition": 156}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMDMyNjE1", "url": "https://github.com/IBM/FHIR/pull/1165#pullrequestreview-421032615", "createdAt": "2020-05-29T14:56:29Z", "commit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNDo1NjoyOVrOGcgWhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNDo1NjoyOVrOGcgWhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU0MzM2Nw==", "bodyText": "Suggested change", "url": "https://github.com/IBM/FHIR/pull/1165#discussion_r432543367", "createdAt": "2020-05-29T14:56:29Z", "author": {"login": "prb112"}, "path": "fhir-persistence-schema/docs/DB2MultiTenancy.md", "diffHunk": "@@ -1,16 +1,225 @@\n-# The IBM FHIR Server - Db2 Multi-Tenancy\n+# The IBM FHIR Server - Multi-Tenancy on Db2\n \n-This document outlines the schema design and implementation for the IBM FHIR Server's Db2 Multi-tenancy feature. \n+This document outlines the schema design and implementation for the IBM FHIR Server's Multi-tenancy feature on Db2.\n \n The Multi-tenancy feature has two main areas of focus: \n - Tenant Provisioning  \n - Security\n \n-## Multi-Tenancy Schema Design\n+This document assumes familiarity with the general [IBM FHIR Server schema design](SchemaMigration.md).\n+\n+# Multi-Tenancy Concepts and Design\n+\n+The IBM FHIR Server design supports three levels of multi-tenancy:\n+\n+1. Separate database per tenant\n+2. Separate data schema per tenant\n+3. (Db2-only) multiple tenants per schema, partitioned with row-based access control and per-tenant tablespaces.\n+\n+Of course, an entire deployment (application servers and database) also could be dedicated to a single tenant, which is really just a variant of option 1 above, although clearly such a configuration would not be considered multi-tenant.\n+\n+## Tenant Data Administration\n+\n+The IBM FHIR Server separates schema administration data from user data. All administration data is held in tables within the FHIRADMIN schema, and these tables are not directly accessible by the IBM FHIR Server database user.\n+\n+The FHIRADMIN schema is used to manage schema version migrations as well as tenant configuration for any tenants resident in the given database. The FHIRADMIN schema does not manage tenants in other databases.\n+\n+See the general [IBM FHIR Server schema design](SchemaMigration.md) documentation for a more detailed description of how FHIRADMIN tables are used to manage schema versions.\n+\n+\n+## Multi-tenancy using Db2 Table Partitions and Per Tenant Tablespaces\n+\n+The IBM FHIR Server provides a multi-tenancy feature based on Db2 row-based access control and table partitioning features.\n+\n+Each new tenant is allocated a unique tenant id value which is of database type `INT`. All tables in the IBM FHIR Server data schema (typically `FHIRDATA`) are created as range partitioned and configured with row-based access control. \n+\n+As an example, consider a table of patients created using the following DDL (illustrative only, this is not the actual IBM FHIR Server schema):\n+\n+```\n+CREATE TABLE ptng.patients (\n+\u00a0 \u00a0 mt_id \u00a0 \u00a0 \u00a0 \u00a0 \u00a0     INT \u00a0 \u00a0 NOT NULL,\n+\u00a0 \u00a0 patient_name\u00a0 \u00a0 VARCHAR(18) NOT NULL,\n+\u00a0 \u00a0 age \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 INT \u00a0 \u00a0 NOT NULL,\n+\u00a0 \u00a0 doctor_name \u00a0 \u00a0 VARCHAR(18),\n+\u00a0 \u00a0 ssn\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 CHAR(11),\n+\u00a0 \u00a0 CONSTRAINT pk_patient PRIMARY KEY (mt_id, patient_name)\n+)\n+PARTITION BY RANGE (mt_id) (STARTING 0 INCLUSIVE ENDING 0 INCLUSIVE);\n+```\n+\n+Each tenant is allocated a unique integer value for mt_id (multi-tenant id), with a range partition used to define which table partition is to be used for a particular tenant's mt_id. The mapping of tenant name to mt_id value is maintained in the FHIR_ADMIN.TENANTS table.\n+\n+The above example assumes that patient_name will be unique within the context of a single tenant, which obviously does not apply to the actual IBM FHIR Server schema. The primary key must include the partition range key `mt_id`. In addition, any secondary indexes MUST also include mt_id to ensure they are always local to the partition. For example:\n+\n+```\n+CREATE UNIQUE INDEX ptng.unq_ssn ON ptng.patients(mt_id, ssn);\n+```\n+\n+Local indexes are important to ensure proper tenant data isolation, with the added benefit of simplifying the task of removing the tenant when the time comes.\n+\n+## Per-Tenant Tablespaces\n+\n+Each tenant is allocated its own tablespace, and the table and index partitions for that tenant are all assigned to that tablespace, as depicted below:\n+\n+>![](partitioned_tables.png)\n+\n+Note: historically, DBAs would often cook up complex database layouts, using different tablespaces for tables and indexes to try and balance the IO workload for optimal throughput and/or latency. In cloud environments with heavily virtualized storage, this becomes less relevant and so leveraging tablespaces to provide an application function (isolating tenant data) is reasonable.\n+\n+Each tablespace is mapped to one or containers which are typically files at the OS filesystem level. When the tablespace is dropped, these files are deleted. The schema also defines a common tablespace `FHIR_TS` which is used for the base table definition. Db2 requires that a table and its partitions must use tablespaces with the same extent size.\n+\n+The tablespaces are created with automatic storage using an EXTENTSIZE of 4 (x32KB) pages to reduce overhead and improve deployment times. This is due to the large number of objects (tables and indexes) created in the schema, each requiring an initial number of extents. \n+\n+To add a new tenant, a utility program connects to Db2 as the FHIRADMIN user and adds records to the FHIR_ADMIN.TENANTS and FHIR_ADMIN.TENANT_KEYS tables. The utility probram then uses the newly assigned mt_id value when adding new partitions to each of the tables in the FHIRDATA schema.\n+\n+The tablespace is managed automatically with an ([EXTENTSIZE](https://www.ibm.com/support/knowledgecenter/SSEPGG_11.5.0/com.ibm.db2.luw.admin.dbobj.doc/doc/c0004964.html)) of 128KB. Note, the extentsize is multiplied by the pagesize to arrive at a storage size.\n+\n+Each tenant is allocated a partition based on the MT_ID and assigned to a tablespace. The tenant `tablespace` is created one time and no changes to the tablespace are expected.\n+\n+In general, smaller extent sizes can harm the performance of table and index scans because they limit the amount of data which can be read in a single IO operation. However, such scans are not common in most FHIR query use-cases, so this tends to not be an issue.\n+\n+\n+## Multi-tenant Queries\n+\n+We could use the multi-tenant enabled table definition as-is and modify every SQL statement to include `AND mt_id = ?` but this is error-prone and risky. If a query was missed or poorly written and ran without that predicate, it could expose data from another tenant.\n+\n+Instead, we leverage DB2 permission objects which allow us to specify a filter condition. Each query submitted by the application is rewritten by the database to include the `FOR ROWS WHERE` predicate, which is defined as: \n+\n+```\n+CREATE PERMISSION ROW_ACCESS ON ptng.patients\n+\u00a0\u00a0 \u00a0 \u00a0 \u00a0 FOR ROWS WHERE patients.mt_id = ptng.session_tenant\n+\u00a0\u00a0 \u00a0 \u00a0 \u00a0 ENFORCED FOR ALL ACCESS\n+\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ENABLE;\n+\n+ALTER TABLE ptng.patients ACTIVATE ROW ACCESS CONTROL;\n+```\n+\n+The `session_tenant` above is defined as a session variable. The application must set the value to match the mt_id value configured for the tenant.\n+\n+Logically:\n+\n+```\n+SET ptng.session_tenant = 1;\n+SELECT * FROM ptng.patients;\n+commit;\n+```\n+\n+Internally, DB2 rewrites the query to look like this:\n+\n+```\n+SELECT * FROM ptng.patients WHERE mt_id = 1;\n+```\n+\n+Because the table `ptng.patients` is partitioned using mt_id, the query optimizer is able to perform a partition-prune, by limiting the query access to the partition associated with the tenant. This results in a query execution plan very similar in terms of performance to a single-tenant scenario without any partitioning.\n+\n+To isolate a tenant's data at the file-system level, a tablespace is created per tenant and the partition objects are are allocated to that tablespace, including any local indexes:\n+\n+```\n+CREATE TABLESPACE TS_TENANT1 MANAGED BY AUTOMATIC STORAGE;\n+CREATE TABLESPACE TS_TENANT2 MANAGED BY AUTOMATIC STORAGE;\n+```\n+\n+\n+Adding new tenants requires adding partitions to each table in the data schema. Note how the partition is configured with the tenant's specific tablespace:\n+\n+```\n+-- for tenant #1\n+ALTER TABLE ptng.patients ADD PARTITION TENANT1 STARTING 1 INCLUSIVE ENDING 1 INCLUSIVE IN TS_TENANT1;\n+\n+-- for tenant #2\n+ALTER TABLE ptng.patients ADD PARTITION TENANT2 STARTING 2 INCLUSIVE ENDING 2 INCLUSIVE IN TS_TENANT2;\n+```\n+\n+When the tenant is deleted, the partition associated with the tenant is detached and subsequently dropped from the database. This renders the tenant data inaccessible from the perspective of a database user. However, database space management does not necessarily overwrite the freed blocks. Although the data is encrypted, someone with the database key and sufficient time, tooling and knowledge could theoretically retrieve parts of the data. By using a tablespace which is dropped, the database will delete the files at the OS layer.\n+\n+The process to delete a tenant is (logically):\n+\n+```\n+ALTER TABLE <tbl> DETACH PARTITION INTO <tbl_drp1>;\n+...\n+COMMIT;\n+DROP TABLE <tbl_drp1>;\n+...\n+COMMIT;\n+DROP TABLESPACE TS_TENANT1;\n+```\n+\n+In this case, TS_TENANT1 is the name of the tablespace previously assigned to the tenant being dropped.\n+\n+Note that DB2 requires a commit after the partition is detached and before the table `<tbl_drp1>` can be dropped. The tooling must implement this process to be idempotent to handle cases where a detach or drop might fail.\n+\n+Dropping partitions in this way works by swizzling metadata in the catalog which requires very little (redo) logging and is therefore far more efficient than deleting actual rows of data.\n+\n+\n+\n+\n+## Tenant Authentication\n+\n+The server connect to Db2 with a user configured for the least privileges it requires to provide the FHIR resource persistence and search functions. This user does not have any database administration privileges, unlike the FHIRADMIN user which is used to deploy the schema, allocate tenants etc.\n+\n+![Privilege Design](privilege_design.png)\n+\n+To prevent an application (or other user with access to the applications database connection information) from arbitrarily setting the session_tenant value, the user used by the IBM FHIR server to connect is granted only read access to the variable. This is why we create the session_tenant variable in the FHIR_ADMIN schema, owned by the FHIRADMIN user, not the FHIRDATA schema, which is the default schema for the user used by the server to access the database. In order to set (write) its value, the data user is granted execute privileges on a DB2 stored procedure called FHIR_ADMIN.SET_TENANT. This is the only way a non-administrative user can set the session_tenant value and access the data.\n+\n+The following table summarizes the properties/values involved in authenticating tenant access:\n+\n+| Property | Description |\n+|----------|-------------|\n+|TENANT_NAME | Used by applications to uniquely identify tenants |\n+| MT_ID | The integer primary key of the TENANTS table, used to map the TENANT_NAME to an integer value which is used as the partitioning key and row-based access permission predicate. |\n+| TENANT_KEY | A 32 byte random value created when the tenant is provisioned. This is a secret, and must be passed by the client to the database in order to obtain access to a tenant. A tenant may have multiple tenant keys to support key rotation. (deploy new key before removing old key) |\n+| TENANT_SALT | A 32 byte random value used as a salt when computing the SHA-256 tenant hash |\n+| TENANT_HASH | A SHA-256 hash of the TENANT_KEY and TENANT_SALT. The TENANT_KEY is never stored directly by the database. |\n+\n+\n+The FHIR_ADMIN.SET_TENANT stored procedure takes two parameters: the tenant name and the tenant key. This acts as a user/password pair tuple. The SET_TENANT code looks up a previously stored salt value associated with the tenant name and computes a hash of the salt + tenant key. If the result matches the stored hash value, the call is considered authentic, and the session_tenant variable is set.\n+\n+To summarize, for a client application to access tenant data in the multi-tenant Db2 schema, the following must apply:\n+\n+1. The client (e.g. the server) must have access to the database as the FHIRUSER user;\n+2. The user FHIRUSER must be granted execute privilges on the FHIR_ADMIN.SET_TENANT procedure;\n+3. The user FHIRUSER must be granted READ on FHIR_ADMIN.SV_TENANT_ID;\n+4. The user FHIRUSER must be granted SELECT,INSERT,UPDATE,DELETE on all tables in the FHIRDATA schema. \n+\n+## Summary of Granted Privileges:\n+\n+| Grants |\n+| --- |\n+| All objects in schema FHIR_ADMIN are owned by user FHIRADMIN |\n+| All objects in schema FHIRDATA are owned by user FHIRADMIN |\n+| GRANT EXECUTE ON FHIR_ADMIN.SET_TENANT TO FHIRUSER; |\n+| GRANT READ ON FHIR_ADMIN.SV_TENANT_ID TO FHIRUSER; |\n+| GRANT EXECUTE ON FHIRDATA.ADD_RESOURCE_TYPE TO FHIRUSER; |\n+| GRANT EXECUTE ON FHIRDATA.ADD_RESOURCE TO FHIRUSER; |\n+| GRANT SELECT,INSERT,UPDATE,DELETE ON FHIRDATA.PATIENT_RESOURCES TO FHIRUSER; |\n+\n+\n+## Tenant Data Security\n+\n+HIPAA controls require protected data at rest is encrypted, and this is implemented by using Db2 native encryption. When the tenant is deleted, its data must be rendered inaccessible. This is achieved by the following:\n+\n+1. Detaching the tenant's partition and dropping the table created by the detach operation.\n+2. Dropping the tenant's tablespace, which will delete the database container files on the underlying OS filesystem.\n+\n+The above actions mean that the tenant's data would no longer be accessible at the database or file-system levels.\n+\n+In the past, there may have been an argument for a third step involving scrubbing the files by overwriting their data with zeroes or random values. However, in today's data centers with heavily virtualized storage sub-systems, there would be no guarantee that such a write would overwrite the actual on-disk data blocks anyway (storage sub-systems may use copy-on-write techniques or similar approaches to provide snapshots, for example). In addition, when consuming Db2 as a cloud service, OS-level access is unlikely to be available, making a file scrub impossible, unless it was exposed by the cloud provider as a feature of the service.\n+\n+Because dropping a tablespace causes Db2 to delete the underlying container files, any attempt to recover the data would require:\n+\n+1. privileged access to the OS or storage sub-system;\n+2. the database encryption key;\n+3. detailed knowledge of OS file systems and data recovery tools;\n+4. detailed knowledge of Db2 internals and data recovery tools;\n+5. opportunity to retrieve the data before the OS reused the free blocks in the filesystem.\n+\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "originalPosition": 219}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMDMzNTI0", "url": "https://github.com/IBM/FHIR/pull/1165#pullrequestreview-421033524", "createdAt": "2020-05-29T14:57:31Z", "commit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNDo1NzozMVrOGcgZOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNDo1NzozMVrOGcgZOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU0NDA1OA==", "bodyText": "I don't think we should mention HIPAA.", "url": "https://github.com/IBM/FHIR/pull/1165#discussion_r432544058", "createdAt": "2020-05-29T14:57:31Z", "author": {"login": "prb112"}, "path": "fhir-persistence-schema/docs/DB2MultiTenancy.md", "diffHunk": "@@ -1,16 +1,225 @@\n-# The IBM FHIR Server - Db2 Multi-Tenancy\n+# The IBM FHIR Server - Multi-Tenancy on Db2\n \n-This document outlines the schema design and implementation for the IBM FHIR Server's Db2 Multi-tenancy feature. \n+This document outlines the schema design and implementation for the IBM FHIR Server's Multi-tenancy feature on Db2.\n \n The Multi-tenancy feature has two main areas of focus: \n - Tenant Provisioning  \n - Security\n \n-## Multi-Tenancy Schema Design\n+This document assumes familiarity with the general [IBM FHIR Server schema design](SchemaMigration.md).\n+\n+# Multi-Tenancy Concepts and Design\n+\n+The IBM FHIR Server design supports three levels of multi-tenancy:\n+\n+1. Separate database per tenant\n+2. Separate data schema per tenant\n+3. (Db2-only) multiple tenants per schema, partitioned with row-based access control and per-tenant tablespaces.\n+\n+Of course, an entire deployment (application servers and database) also could be dedicated to a single tenant, which is really just a variant of option 1 above, although clearly such a configuration would not be considered multi-tenant.\n+\n+## Tenant Data Administration\n+\n+The IBM FHIR Server separates schema administration data from user data. All administration data is held in tables within the FHIRADMIN schema, and these tables are not directly accessible by the IBM FHIR Server database user.\n+\n+The FHIRADMIN schema is used to manage schema version migrations as well as tenant configuration for any tenants resident in the given database. The FHIRADMIN schema does not manage tenants in other databases.\n+\n+See the general [IBM FHIR Server schema design](SchemaMigration.md) documentation for a more detailed description of how FHIRADMIN tables are used to manage schema versions.\n+\n+\n+## Multi-tenancy using Db2 Table Partitions and Per Tenant Tablespaces\n+\n+The IBM FHIR Server provides a multi-tenancy feature based on Db2 row-based access control and table partitioning features.\n+\n+Each new tenant is allocated a unique tenant id value which is of database type `INT`. All tables in the IBM FHIR Server data schema (typically `FHIRDATA`) are created as range partitioned and configured with row-based access control. \n+\n+As an example, consider a table of patients created using the following DDL (illustrative only, this is not the actual IBM FHIR Server schema):\n+\n+```\n+CREATE TABLE ptng.patients (\n+\u00a0 \u00a0 mt_id \u00a0 \u00a0 \u00a0 \u00a0 \u00a0     INT \u00a0 \u00a0 NOT NULL,\n+\u00a0 \u00a0 patient_name\u00a0 \u00a0 VARCHAR(18) NOT NULL,\n+\u00a0 \u00a0 age \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 INT \u00a0 \u00a0 NOT NULL,\n+\u00a0 \u00a0 doctor_name \u00a0 \u00a0 VARCHAR(18),\n+\u00a0 \u00a0 ssn\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 CHAR(11),\n+\u00a0 \u00a0 CONSTRAINT pk_patient PRIMARY KEY (mt_id, patient_name)\n+)\n+PARTITION BY RANGE (mt_id) (STARTING 0 INCLUSIVE ENDING 0 INCLUSIVE);\n+```\n+\n+Each tenant is allocated a unique integer value for mt_id (multi-tenant id), with a range partition used to define which table partition is to be used for a particular tenant's mt_id. The mapping of tenant name to mt_id value is maintained in the FHIR_ADMIN.TENANTS table.\n+\n+The above example assumes that patient_name will be unique within the context of a single tenant, which obviously does not apply to the actual IBM FHIR Server schema. The primary key must include the partition range key `mt_id`. In addition, any secondary indexes MUST also include mt_id to ensure they are always local to the partition. For example:\n+\n+```\n+CREATE UNIQUE INDEX ptng.unq_ssn ON ptng.patients(mt_id, ssn);\n+```\n+\n+Local indexes are important to ensure proper tenant data isolation, with the added benefit of simplifying the task of removing the tenant when the time comes.\n+\n+## Per-Tenant Tablespaces\n+\n+Each tenant is allocated its own tablespace, and the table and index partitions for that tenant are all assigned to that tablespace, as depicted below:\n+\n+>![](partitioned_tables.png)\n+\n+Note: historically, DBAs would often cook up complex database layouts, using different tablespaces for tables and indexes to try and balance the IO workload for optimal throughput and/or latency. In cloud environments with heavily virtualized storage, this becomes less relevant and so leveraging tablespaces to provide an application function (isolating tenant data) is reasonable.\n+\n+Each tablespace is mapped to one or containers which are typically files at the OS filesystem level. When the tablespace is dropped, these files are deleted. The schema also defines a common tablespace `FHIR_TS` which is used for the base table definition. Db2 requires that a table and its partitions must use tablespaces with the same extent size.\n+\n+The tablespaces are created with automatic storage using an EXTENTSIZE of 4 (x32KB) pages to reduce overhead and improve deployment times. This is due to the large number of objects (tables and indexes) created in the schema, each requiring an initial number of extents. \n+\n+To add a new tenant, a utility program connects to Db2 as the FHIRADMIN user and adds records to the FHIR_ADMIN.TENANTS and FHIR_ADMIN.TENANT_KEYS tables. The utility probram then uses the newly assigned mt_id value when adding new partitions to each of the tables in the FHIRDATA schema.\n+\n+The tablespace is managed automatically with an ([EXTENTSIZE](https://www.ibm.com/support/knowledgecenter/SSEPGG_11.5.0/com.ibm.db2.luw.admin.dbobj.doc/doc/c0004964.html)) of 128KB. Note, the extentsize is multiplied by the pagesize to arrive at a storage size.\n+\n+Each tenant is allocated a partition based on the MT_ID and assigned to a tablespace. The tenant `tablespace` is created one time and no changes to the tablespace are expected.\n+\n+In general, smaller extent sizes can harm the performance of table and index scans because they limit the amount of data which can be read in a single IO operation. However, such scans are not common in most FHIR query use-cases, so this tends to not be an issue.\n+\n+\n+## Multi-tenant Queries\n+\n+We could use the multi-tenant enabled table definition as-is and modify every SQL statement to include `AND mt_id = ?` but this is error-prone and risky. If a query was missed or poorly written and ran without that predicate, it could expose data from another tenant.\n+\n+Instead, we leverage DB2 permission objects which allow us to specify a filter condition. Each query submitted by the application is rewritten by the database to include the `FOR ROWS WHERE` predicate, which is defined as: \n+\n+```\n+CREATE PERMISSION ROW_ACCESS ON ptng.patients\n+\u00a0\u00a0 \u00a0 \u00a0 \u00a0 FOR ROWS WHERE patients.mt_id = ptng.session_tenant\n+\u00a0\u00a0 \u00a0 \u00a0 \u00a0 ENFORCED FOR ALL ACCESS\n+\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ENABLE;\n+\n+ALTER TABLE ptng.patients ACTIVATE ROW ACCESS CONTROL;\n+```\n+\n+The `session_tenant` above is defined as a session variable. The application must set the value to match the mt_id value configured for the tenant.\n+\n+Logically:\n+\n+```\n+SET ptng.session_tenant = 1;\n+SELECT * FROM ptng.patients;\n+commit;\n+```\n+\n+Internally, DB2 rewrites the query to look like this:\n+\n+```\n+SELECT * FROM ptng.patients WHERE mt_id = 1;\n+```\n+\n+Because the table `ptng.patients` is partitioned using mt_id, the query optimizer is able to perform a partition-prune, by limiting the query access to the partition associated with the tenant. This results in a query execution plan very similar in terms of performance to a single-tenant scenario without any partitioning.\n+\n+To isolate a tenant's data at the file-system level, a tablespace is created per tenant and the partition objects are are allocated to that tablespace, including any local indexes:\n+\n+```\n+CREATE TABLESPACE TS_TENANT1 MANAGED BY AUTOMATIC STORAGE;\n+CREATE TABLESPACE TS_TENANT2 MANAGED BY AUTOMATIC STORAGE;\n+```\n+\n+\n+Adding new tenants requires adding partitions to each table in the data schema. Note how the partition is configured with the tenant's specific tablespace:\n+\n+```\n+-- for tenant #1\n+ALTER TABLE ptng.patients ADD PARTITION TENANT1 STARTING 1 INCLUSIVE ENDING 1 INCLUSIVE IN TS_TENANT1;\n+\n+-- for tenant #2\n+ALTER TABLE ptng.patients ADD PARTITION TENANT2 STARTING 2 INCLUSIVE ENDING 2 INCLUSIVE IN TS_TENANT2;\n+```\n+\n+When the tenant is deleted, the partition associated with the tenant is detached and subsequently dropped from the database. This renders the tenant data inaccessible from the perspective of a database user. However, database space management does not necessarily overwrite the freed blocks. Although the data is encrypted, someone with the database key and sufficient time, tooling and knowledge could theoretically retrieve parts of the data. By using a tablespace which is dropped, the database will delete the files at the OS layer.\n+\n+The process to delete a tenant is (logically):\n+\n+```\n+ALTER TABLE <tbl> DETACH PARTITION INTO <tbl_drp1>;\n+...\n+COMMIT;\n+DROP TABLE <tbl_drp1>;\n+...\n+COMMIT;\n+DROP TABLESPACE TS_TENANT1;\n+```\n+\n+In this case, TS_TENANT1 is the name of the tablespace previously assigned to the tenant being dropped.\n+\n+Note that DB2 requires a commit after the partition is detached and before the table `<tbl_drp1>` can be dropped. The tooling must implement this process to be idempotent to handle cases where a detach or drop might fail.\n+\n+Dropping partitions in this way works by swizzling metadata in the catalog which requires very little (redo) logging and is therefore far more efficient than deleting actual rows of data.\n+\n+\n+\n+\n+## Tenant Authentication\n+\n+The server connect to Db2 with a user configured for the least privileges it requires to provide the FHIR resource persistence and search functions. This user does not have any database administration privileges, unlike the FHIRADMIN user which is used to deploy the schema, allocate tenants etc.\n+\n+![Privilege Design](privilege_design.png)\n+\n+To prevent an application (or other user with access to the applications database connection information) from arbitrarily setting the session_tenant value, the user used by the IBM FHIR server to connect is granted only read access to the variable. This is why we create the session_tenant variable in the FHIR_ADMIN schema, owned by the FHIRADMIN user, not the FHIRDATA schema, which is the default schema for the user used by the server to access the database. In order to set (write) its value, the data user is granted execute privileges on a DB2 stored procedure called FHIR_ADMIN.SET_TENANT. This is the only way a non-administrative user can set the session_tenant value and access the data.\n+\n+The following table summarizes the properties/values involved in authenticating tenant access:\n+\n+| Property | Description |\n+|----------|-------------|\n+|TENANT_NAME | Used by applications to uniquely identify tenants |\n+| MT_ID | The integer primary key of the TENANTS table, used to map the TENANT_NAME to an integer value which is used as the partitioning key and row-based access permission predicate. |\n+| TENANT_KEY | A 32 byte random value created when the tenant is provisioned. This is a secret, and must be passed by the client to the database in order to obtain access to a tenant. A tenant may have multiple tenant keys to support key rotation. (deploy new key before removing old key) |\n+| TENANT_SALT | A 32 byte random value used as a salt when computing the SHA-256 tenant hash |\n+| TENANT_HASH | A SHA-256 hash of the TENANT_KEY and TENANT_SALT. The TENANT_KEY is never stored directly by the database. |\n+\n+\n+The FHIR_ADMIN.SET_TENANT stored procedure takes two parameters: the tenant name and the tenant key. This acts as a user/password pair tuple. The SET_TENANT code looks up a previously stored salt value associated with the tenant name and computes a hash of the salt + tenant key. If the result matches the stored hash value, the call is considered authentic, and the session_tenant variable is set.\n+\n+To summarize, for a client application to access tenant data in the multi-tenant Db2 schema, the following must apply:\n+\n+1. The client (e.g. the server) must have access to the database as the FHIRUSER user;\n+2. The user FHIRUSER must be granted execute privilges on the FHIR_ADMIN.SET_TENANT procedure;\n+3. The user FHIRUSER must be granted READ on FHIR_ADMIN.SV_TENANT_ID;\n+4. The user FHIRUSER must be granted SELECT,INSERT,UPDATE,DELETE on all tables in the FHIRDATA schema. \n+\n+## Summary of Granted Privileges:\n+\n+| Grants |\n+| --- |\n+| All objects in schema FHIR_ADMIN are owned by user FHIRADMIN |\n+| All objects in schema FHIRDATA are owned by user FHIRADMIN |\n+| GRANT EXECUTE ON FHIR_ADMIN.SET_TENANT TO FHIRUSER; |\n+| GRANT READ ON FHIR_ADMIN.SV_TENANT_ID TO FHIRUSER; |\n+| GRANT EXECUTE ON FHIRDATA.ADD_RESOURCE_TYPE TO FHIRUSER; |\n+| GRANT EXECUTE ON FHIRDATA.ADD_RESOURCE TO FHIRUSER; |\n+| GRANT SELECT,INSERT,UPDATE,DELETE ON FHIRDATA.PATIENT_RESOURCES TO FHIRUSER; |\n+\n+\n+## Tenant Data Security\n+\n+HIPAA controls require protected data at rest is encrypted, and this is implemented by using Db2 native encryption. When the tenant is deleted, its data must be rendered inaccessible. This is achieved by the following:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "originalPosition": 201}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMDMzNzg1", "url": "https://github.com/IBM/FHIR/pull/1165#pullrequestreview-421033785", "createdAt": "2020-05-29T14:57:48Z", "commit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNDo1Nzo0OFrOGcgaAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNDo1Nzo0OFrOGcgaAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU0NDI1Ng==", "bodyText": "Suggested change", "url": "https://github.com/IBM/FHIR/pull/1165#discussion_r432544256", "createdAt": "2020-05-29T14:57:48Z", "author": {"login": "prb112"}, "path": "fhir-persistence-schema/docs/DB2MultiTenancy.md", "diffHunk": "@@ -19,6 +228,20 @@ The administrative schema's name is FHIR_ADMIN.  FHIR_ADMIN has\n \n The tables have supporting indicies and privileges. \n \n+\n+**Table: VERSION_HISTORY**\n+\n+Before any table or schema object is created, the `VERSION_HISTORY` table is created using `CreateVersionHistory.createTableIfNeeded(adminSchemaName, adapter);`  This table includes VERSION_HISTORY for resources created in the schema. If an object in the schema is updated, then the VERSION_HISTORY table must be updated to track the changes. \n+\n+The `VERSION_HISTORY` table enables Tenant version isolation, so upgrades and patches are separately applied to the schema to which the tenant belongs. Specifically, if the tenant shares the table definitions with another client, the patching is applied to both tenants at the same time.  If the tenant has a specific schema, the table definitions may be updated independent of each other.\n+\n+The `CreateVersionHistory` class controls the creation the `VERSION_HISTORY` table. Importantly, the VERISON_HISTORY table does not support migrations and changes. The Primary Key has a corresponding index `PK_VERSION_HISTORY`, and the code does not support updating the index. \n+\n+This table is an administrative table and should not require updating and migration. \n+\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "originalPosition": 246}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMDM3MDkz", "url": "https://github.com/IBM/FHIR/pull/1165#pullrequestreview-421037093", "createdAt": "2020-05-29T15:01:42Z", "commit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNTowMTo0MlrOGcgjjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNTowMTo0MlrOGcgjjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU0NjcwMw==", "bodyText": "This image needs some work.\nSchema is FHIR_ADMIN\nI think the red lines should be removed\nthe CREATE PERMISSIONS should be removed at the bottom", "url": "https://github.com/IBM/FHIR/pull/1165#discussion_r432546703", "createdAt": "2020-05-29T15:01:42Z", "author": {"login": "prb112"}, "path": "fhir-persistence-schema/docs/DB2MultiTenancy.md", "diffHunk": "@@ -1,16 +1,225 @@\n-# The IBM FHIR Server - Db2 Multi-Tenancy\n+# The IBM FHIR Server - Multi-Tenancy on Db2\n \n-This document outlines the schema design and implementation for the IBM FHIR Server's Db2 Multi-tenancy feature. \n+This document outlines the schema design and implementation for the IBM FHIR Server's Multi-tenancy feature on Db2.\n \n The Multi-tenancy feature has two main areas of focus: \n - Tenant Provisioning  \n - Security\n \n-## Multi-Tenancy Schema Design\n+This document assumes familiarity with the general [IBM FHIR Server schema design](SchemaMigration.md).\n+\n+# Multi-Tenancy Concepts and Design\n+\n+The IBM FHIR Server design supports three levels of multi-tenancy:\n+\n+1. Separate database per tenant\n+2. Separate data schema per tenant\n+3. (Db2-only) multiple tenants per schema, partitioned with row-based access control and per-tenant tablespaces.\n+\n+Of course, an entire deployment (application servers and database) also could be dedicated to a single tenant, which is really just a variant of option 1 above, although clearly such a configuration would not be considered multi-tenant.\n+\n+## Tenant Data Administration\n+\n+The IBM FHIR Server separates schema administration data from user data. All administration data is held in tables within the FHIRADMIN schema, and these tables are not directly accessible by the IBM FHIR Server database user.\n+\n+The FHIRADMIN schema is used to manage schema version migrations as well as tenant configuration for any tenants resident in the given database. The FHIRADMIN schema does not manage tenants in other databases.\n+\n+See the general [IBM FHIR Server schema design](SchemaMigration.md) documentation for a more detailed description of how FHIRADMIN tables are used to manage schema versions.\n+\n+\n+## Multi-tenancy using Db2 Table Partitions and Per Tenant Tablespaces\n+\n+The IBM FHIR Server provides a multi-tenancy feature based on Db2 row-based access control and table partitioning features.\n+\n+Each new tenant is allocated a unique tenant id value which is of database type `INT`. All tables in the IBM FHIR Server data schema (typically `FHIRDATA`) are created as range partitioned and configured with row-based access control. \n+\n+As an example, consider a table of patients created using the following DDL (illustrative only, this is not the actual IBM FHIR Server schema):\n+\n+```\n+CREATE TABLE ptng.patients (\n+\u00a0 \u00a0 mt_id \u00a0 \u00a0 \u00a0 \u00a0 \u00a0     INT \u00a0 \u00a0 NOT NULL,\n+\u00a0 \u00a0 patient_name\u00a0 \u00a0 VARCHAR(18) NOT NULL,\n+\u00a0 \u00a0 age \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 INT \u00a0 \u00a0 NOT NULL,\n+\u00a0 \u00a0 doctor_name \u00a0 \u00a0 VARCHAR(18),\n+\u00a0 \u00a0 ssn\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 CHAR(11),\n+\u00a0 \u00a0 CONSTRAINT pk_patient PRIMARY KEY (mt_id, patient_name)\n+)\n+PARTITION BY RANGE (mt_id) (STARTING 0 INCLUSIVE ENDING 0 INCLUSIVE);\n+```\n+\n+Each tenant is allocated a unique integer value for mt_id (multi-tenant id), with a range partition used to define which table partition is to be used for a particular tenant's mt_id. The mapping of tenant name to mt_id value is maintained in the FHIR_ADMIN.TENANTS table.\n+\n+The above example assumes that patient_name will be unique within the context of a single tenant, which obviously does not apply to the actual IBM FHIR Server schema. The primary key must include the partition range key `mt_id`. In addition, any secondary indexes MUST also include mt_id to ensure they are always local to the partition. For example:\n+\n+```\n+CREATE UNIQUE INDEX ptng.unq_ssn ON ptng.patients(mt_id, ssn);\n+```\n+\n+Local indexes are important to ensure proper tenant data isolation, with the added benefit of simplifying the task of removing the tenant when the time comes.\n+\n+## Per-Tenant Tablespaces\n+\n+Each tenant is allocated its own tablespace, and the table and index partitions for that tenant are all assigned to that tablespace, as depicted below:\n+\n+>![](partitioned_tables.png)\n+\n+Note: historically, DBAs would often cook up complex database layouts, using different tablespaces for tables and indexes to try and balance the IO workload for optimal throughput and/or latency. In cloud environments with heavily virtualized storage, this becomes less relevant and so leveraging tablespaces to provide an application function (isolating tenant data) is reasonable.\n+\n+Each tablespace is mapped to one or containers which are typically files at the OS filesystem level. When the tablespace is dropped, these files are deleted. The schema also defines a common tablespace `FHIR_TS` which is used for the base table definition. Db2 requires that a table and its partitions must use tablespaces with the same extent size.\n+\n+The tablespaces are created with automatic storage using an EXTENTSIZE of 4 (x32KB) pages to reduce overhead and improve deployment times. This is due to the large number of objects (tables and indexes) created in the schema, each requiring an initial number of extents. \n+\n+To add a new tenant, a utility program connects to Db2 as the FHIRADMIN user and adds records to the FHIR_ADMIN.TENANTS and FHIR_ADMIN.TENANT_KEYS tables. The utility probram then uses the newly assigned mt_id value when adding new partitions to each of the tables in the FHIRDATA schema.\n+\n+The tablespace is managed automatically with an ([EXTENTSIZE](https://www.ibm.com/support/knowledgecenter/SSEPGG_11.5.0/com.ibm.db2.luw.admin.dbobj.doc/doc/c0004964.html)) of 128KB. Note, the extentsize is multiplied by the pagesize to arrive at a storage size.\n+\n+Each tenant is allocated a partition based on the MT_ID and assigned to a tablespace. The tenant `tablespace` is created one time and no changes to the tablespace are expected.\n+\n+In general, smaller extent sizes can harm the performance of table and index scans because they limit the amount of data which can be read in a single IO operation. However, such scans are not common in most FHIR query use-cases, so this tends to not be an issue.\n+\n+\n+## Multi-tenant Queries\n+\n+We could use the multi-tenant enabled table definition as-is and modify every SQL statement to include `AND mt_id = ?` but this is error-prone and risky. If a query was missed or poorly written and ran without that predicate, it could expose data from another tenant.\n+\n+Instead, we leverage DB2 permission objects which allow us to specify a filter condition. Each query submitted by the application is rewritten by the database to include the `FOR ROWS WHERE` predicate, which is defined as: \n+\n+```\n+CREATE PERMISSION ROW_ACCESS ON ptng.patients\n+\u00a0\u00a0 \u00a0 \u00a0 \u00a0 FOR ROWS WHERE patients.mt_id = ptng.session_tenant\n+\u00a0\u00a0 \u00a0 \u00a0 \u00a0 ENFORCED FOR ALL ACCESS\n+\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ENABLE;\n+\n+ALTER TABLE ptng.patients ACTIVATE ROW ACCESS CONTROL;\n+```\n+\n+The `session_tenant` above is defined as a session variable. The application must set the value to match the mt_id value configured for the tenant.\n+\n+Logically:\n+\n+```\n+SET ptng.session_tenant = 1;\n+SELECT * FROM ptng.patients;\n+commit;\n+```\n+\n+Internally, DB2 rewrites the query to look like this:\n+\n+```\n+SELECT * FROM ptng.patients WHERE mt_id = 1;\n+```\n+\n+Because the table `ptng.patients` is partitioned using mt_id, the query optimizer is able to perform a partition-prune, by limiting the query access to the partition associated with the tenant. This results in a query execution plan very similar in terms of performance to a single-tenant scenario without any partitioning.\n+\n+To isolate a tenant's data at the file-system level, a tablespace is created per tenant and the partition objects are are allocated to that tablespace, including any local indexes:\n+\n+```\n+CREATE TABLESPACE TS_TENANT1 MANAGED BY AUTOMATIC STORAGE;\n+CREATE TABLESPACE TS_TENANT2 MANAGED BY AUTOMATIC STORAGE;\n+```\n+\n+\n+Adding new tenants requires adding partitions to each table in the data schema. Note how the partition is configured with the tenant's specific tablespace:\n+\n+```\n+-- for tenant #1\n+ALTER TABLE ptng.patients ADD PARTITION TENANT1 STARTING 1 INCLUSIVE ENDING 1 INCLUSIVE IN TS_TENANT1;\n+\n+-- for tenant #2\n+ALTER TABLE ptng.patients ADD PARTITION TENANT2 STARTING 2 INCLUSIVE ENDING 2 INCLUSIVE IN TS_TENANT2;\n+```\n+\n+When the tenant is deleted, the partition associated with the tenant is detached and subsequently dropped from the database. This renders the tenant data inaccessible from the perspective of a database user. However, database space management does not necessarily overwrite the freed blocks. Although the data is encrypted, someone with the database key and sufficient time, tooling and knowledge could theoretically retrieve parts of the data. By using a tablespace which is dropped, the database will delete the files at the OS layer.\n+\n+The process to delete a tenant is (logically):\n+\n+```\n+ALTER TABLE <tbl> DETACH PARTITION INTO <tbl_drp1>;\n+...\n+COMMIT;\n+DROP TABLE <tbl_drp1>;\n+...\n+COMMIT;\n+DROP TABLESPACE TS_TENANT1;\n+```\n+\n+In this case, TS_TENANT1 is the name of the tablespace previously assigned to the tenant being dropped.\n+\n+Note that DB2 requires a commit after the partition is detached and before the table `<tbl_drp1>` can be dropped. The tooling must implement this process to be idempotent to handle cases where a detach or drop might fail.\n+\n+Dropping partitions in this way works by swizzling metadata in the catalog which requires very little (redo) logging and is therefore far more efficient than deleting actual rows of data.\n+\n+\n+\n+\n+## Tenant Authentication\n+\n+The server connect to Db2 with a user configured for the least privileges it requires to provide the FHIR resource persistence and search functions. This user does not have any database administration privileges, unlike the FHIRADMIN user which is used to deploy the schema, allocate tenants etc.\n+\n+![Privilege Design](privilege_design.png)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "originalPosition": 162}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMDM3NTU1", "url": "https://github.com/IBM/FHIR/pull/1165#pullrequestreview-421037555", "createdAt": "2020-05-29T15:02:17Z", "commit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNTowMjoxN1rOGcgk8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNTowMjoxN1rOGcgk8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU0NzA1OA==", "bodyText": "I suggest removing the red squiggly lines", "url": "https://github.com/IBM/FHIR/pull/1165#discussion_r432547058", "createdAt": "2020-05-29T15:02:17Z", "author": {"login": "prb112"}, "path": "fhir-persistence-schema/docs/SchemaMigration.md", "diffHunk": "@@ -0,0 +1,407 @@\n+# The IBM FHIR Server - Schema Design and Management\n+\n+This document details the IBM FHIR Server schema design and how schema changes are managed. There are differences among the databases currently supported, most notably with Db2 which uses additional database capabilities to support multi-tenancy. Details of the multi-tenant design can be found [here](DB2MultiTenancy.md). Other variations across databases are discussed in this document.\n+\n+Currently it is not possible to deploy the simplified single-tenant variant of the schema to Db2. GitHub [issue-840](https://github.com/IBM/FHIR/issues/840) has been opened to address this. \n+\n+\n+There are three core projects which are referenced: \n+\n+| Project | Description |\n+|----------|---------------------------------------------|\n+| `fhir-model` | The HL7 FHIR model - generated Java code |\n+| `fhir-database-utils` | The SQL/database constructs used to create SQL compliant statements |\n+| `fhir-persistence-schema` | Uses database-utils to define a physical data model for storing FHIR resources and supporting the FHIR API |\n+\n+The schema generates the following object types that require management: \n+\n+- DB2 PACKAGE\n+- TABLESPACES\n+- SCHEMA \n+- GLOBAL VARIABLE \n+- INDEX \n+- PERMISSION \n+- PROCEDURE \n+- SEQUENCE \n+- TABLE\n+- TABLE CONSTRAINT \n+\n+----------------------------------------------------------------\n+# Database Support\n+\n+\n+| Database   | Version   | Support |\n+|------------|-----------|-----------------------------------|\n+| DB2        |      11.5 | Suitable for production. Supports multi-tenancy. |\n+| PostgreSQL |        12 | Experimental. Single tenant per database. |\n+| Derby      | 10.14.2.0 | Development only. Single tenant per database |\n+\n+\n+----------------------------------------------------------------\n+# Overview and Concepts\n+\n+The IBM FHIR schema is managed in code and is applied to a target database using a JDBC connection. This simplifies development of Derby-based unit-tests, allows a common schema definition to be used across multiple database flavors, simplifies deployment in cloud scenarios, and because the data model dependencies are understood by the code, the schema creation process can be parallelized to reduce deployment times. In practice, however, we've found that the number of threads must be limited due to driving contention in the internal catalog tables (in DB2, for example). We have also found that some parallel object create operations cause internal database deadlocks (notably creating foreign key relationships). The implementation contains a retry loop, but may fail if the retry limit is exceeded. Note that these deadlocks are internal to Db2, not the more common kind typically caused by poor application code.\n+\n+The `FHIR_ADMIN` schema is used to manage meta-data related to the actual data schemas. A single database instance can be used to support multiple FHIR data schemas, as long as the FHIR_ADMIN schema structure doesn't change. At the time of writing, the IBM FHIR Server does not support more than one FHIR_ADMIN schema in a single database. If a use-case arises where this is required, it is simply a matter of identifying in code where FHIR_ADMIN is used as a constant and replacing instances with a configurable property, although an implementation may also want to consider protecting individual schemas from accidentally being managed by more than one FHIR_ADMIN schema. One possible use-case for this sharing is using a database instance for schema development work, although use of the Db2 docker container makes this moot.\n+\n+The `FHIR_ADMIN` schema also plays an important role in managing tenants in the Db2 multi-tenant implementation. See the [Db2 Multi-Tenant Schema Design](DB2MultiTenancy.md) for more details.\n+\n+\n+## Differences Among Database Implementations\n+\n+The following table highlights the main differences among the database implementations currently supported:\n+\n+| Database   | Variation |\n+| --------   | ----------|\n+| DB2        | Multi-tenant. Supports multiple but isolated tenants within one database/schema |\n+| DB2        | An SPL stored procedure is used to implement the resource storage logic, reducing the number of application server to database round-trips, improving performance |\n+| DB2        | Uses `FHIR_TS` tablespace for admin tables, and a tablespace per tenant |\n+| DB2        | `FHIR_TS` is created using a small extent size for efficiency |\n+| PostgreSQL | Based on the Derby implementation, but uses a stored procedure for the resource persistence logic, like DB2 |\n+| PostgreSQL | TEXT type used instead of CLOB for large data values |\n+| Derby      | Resource persistence is implemented at the DAO layer as a sequence of individual statements instead of one procedure call. At a functional level, the process is identical. Simplifies debugging and supports easier unit-test construction. |\n+\n+\n+----------------------------------------------------------------\n+# Schema Management\n+\n+Use of the schema management tool is described [here](https://github.com/IBM/FHIR/tree/master/fhir-persistence-schema/README.md).\n+\n+The schema is managed using the class `com.ibm.fhir.schema.app.Main`. The `Main` class uses `FhirSchemaGenerator` to build a `PhysicalDataModel` which represents the schema as a Java data structure. This schema model is then applied to a database using an implementation of `IDatabaseAdapter` specific to the target database type (Derby, PostgreSQL or DB2). The adapter implements calls such as `createTable` and constructs the DDL statement appropriate for the target database. In some cases where the object type is not supported or not required for the given target database, the adapter can simply perform no operation (NOP).\n+\n+The code models dependencies among the various objects such as foreign key relationships between tables. Others relationships are marked explicitly, such as stored procedure dependency on tables. To keep things simple, there are some `NopObject` markers used as a barrier during parallel deployment. This barrier is used to collect together a lot of dependencies into one place, allowing subsequent operations to just depend on the barrier object instead of each having to individually express a dependency to lots of objects.\n+\n+The following example shows how we define a table in the schema. In this case, we are creating the global logical resources table (which is not resource-type specific):\n+\n+```java\n+ 1    public void addLogicalResources(PhysicalDataModel pdm) {\n+ 2       final String tableName = LOGICAL_RESOURCES;\n+ 3\n+ 4       Table tbl = Table.builder(schemaName, tableName)\n+ 5               .setTenantColumnName(MT_ID)\n+ 6               .addBigIntColumn(LOGICAL_RESOURCE_ID, false)\n+ 7               .addIntColumn(RESOURCE_TYPE_ID, false)\n+ 8               .addVarcharColumn(LOGICAL_ID, LOGICAL_ID_BYTES, false)\n+ 9               .addPrimaryKey(tableName + \"_PK\", LOGICAL_RESOURCE_ID)\n+10                .addUniqueIndex(\"UNQ_\" + LOGICAL_RESOURCES, RESOURCE_TYPE_ID, LOGICAL_ID)\n+11                .setTablespace(fhirTablespace)\n+12                .addPrivileges(resourceTablePrivileges)\n+13                .addForeignKeyConstraint(FK + tableName + \"_RTID\", schemaName, RESOURCE_TYPES, RESOURCE_TYPE_ID)\n+14                .enableAccessControl(this.sessionVariable)\n+15                .build(pdm);\n+\n+16        tbl.addTag(SCHEMA_GROUP_TAG, FHIRDATA_GROUP);\n+17        this.procedureDependencies.add(tbl);\n+18        pdm.addTable(tbl);\n+19        pdm.addObject(tbl);\n+20    }\n+```\n+\n+Notes:\n+\n+**Line 4.** Database objects are created using the fluent builder pattern to create an immutable definition.\n+\n+**Line 5.** MT_ID is used as the tenant column. The tenant column is handled as an explicit property (rather than just addIntColumn) because it allows us to ignore it later depending on the database target the model is being applied to. Currenly only Db2 supports our multi-tenant design.\n+\n+**Line 6.** Adds a column to table definition.\n+\n+**Line 9.** Specifies the primary key. The columns in the PK definition must be added before addPrimaryKey is called.\n+\n+**Line 10.** Adds a unique index to the table.\n+\n+**Line 11.** Identifies the tablespace to be used for this table. All tables are created in a specific tablespace `FHIR_TS` created with a smaller than typical extent size. The model contains a large number of tables and indexes, and in the multi-tenant schema, the initial table/partition never holds any data. Using a smaller extent size significantly improves schema deployment time because the database has to allocate fewer pages for each object, and this also reduces waste from allocating space that would never be used.\n+\n+**Line 12.** Adds the list of privileges that need to be applied to this table.\n+\n+**Line 13.** Adds a foreign key relationship to a target table, which is RESOURCE_TYPES in this case.\n+\n+**Line 14.** Adds access control to this table. Used only when the target database is Db2. \n+\n+**Line 15.** Fluent pattern - builds the immutable `Table` object. The model is passed as a parameter to permit some integrity checking, helping to ensure that the resulting object is valid before it is applied to any database.\n+\n+**Line 17.** Adds this table as a dependency for the stored procedures. To keep things simple, we say that all tables must be complete before any stored procedures are processed.\n+\n+**Line 18.** Adds this object as a table to the `PhysicalDataModel`. The set of tables are used to perform lookups when foreign key relationships are added.\n+\n+**Line 19.** Adds this object to the full list of objects in the `PhysicalDataModel`.\n+\n+There is room for improvement in the design around how objects are added to the model. The need to make two calls (addTable and addObject) is cumbersome and potentially error-prone.\n+\n+Note that the object being built is a subclass of VersionedSchemaObject which assigned a version id of 1 for the initial creation of an object. Note that version numbers are tracked at the object level, not globally. This makes it far easier to manage changes to a given object.\n+\n+\n+### Schema Migration and Versioning\n+\n+The VERSION_HISTORY table is used to record the logical schema version number of every object in the FHIR data schema. This history information is used to determine which deltas to apply to migrate the schema to the latest version. When schema changes are applied, the VERSION_HISTORY table is updated to reflect the latest version number of a particular object. The next time the schema update is run, this table is read, and only changes with a greater version number than the value recorded in the VERSION_HISTORY table are applied for a given object.\n+\n+NOTE: Schema changes must always be carefully considered and in an ideal world are backward compatible - this is important when needing to roll back a change. Rolling back application code changes is as simple as deploying an older version, but rolling back a database change is often impossible. Designing in backward compatibility is tricky to do in practice, but should be considered for each change, especially if continuous availability is a goal.\n+\n+The DDL for most objects (like tables) is specified once. Changes to the table structure are applied as alter statements and assigned an increasing version id. We use a simple version number tracking to identify which changes (deltas) need to be applied to a particular object.\n+\n+The schema update utility first reads the VERSION_HISTORY table, loading all records for the target schema (e.g. FHIRDATA). The utility only applies changes which have a version number greater than the currently recorded version. Once the DDL has been applied successfully, the version number is updated in VERSION_HISTORY. This makes the processed idempotent. Subsequent runs of the schema update utility only apply changes which have a greater version id value than the most recently stored value for each object.\n+\n+Enhancements to schema migration handling are tracked in [issue-1163](https://github.com/IBM/FHIR/issues/1163).\n+\n+\n+## TABLESPACES\n+\n+The Db2 multi-tenant schema variant uses a tablespace per tenant. All other database implementations use the default tablespace.\n+\n+\n+----------------------------------------------------------------\n+## Schema: FHIR_ADMIN\n+\n+The Schema FHIR_ADMIN is deployed once per database and contains tables used to manage schema version history and tenant access (in the case of a multi-tenant supported configuration). The schema contains 3 tables:\n+\n+| Object | Notes | Purpose |\n+| ----- | ----- | ------- |\n+| VERSION_HISTORY | | Table used to track the schema version number for each of the managed objects in the data schema (usually FHIRDATA) |\n+| TENANTS | Db2 only | Table for mapping between tenant name and the tenant id used to isolate the tenant's data in the data schema |\n+| TENANT_KEYS | Db2 only | Authorization keys allocated to a given given. A tenant can have multiple valid keys at any point in time to support rolling key changes (add new before remove old).\n+| TENANT_SEQUENCE | Db2 only | Sequence used to provide unique mt_id values for allocated tenants |\n+| SET_TENANT | Db2 only | Stored procedure. The only way for FHIRUSER to set the value of the SV_TENANT_ID session variable.\n+\n+\n+These table definitions are more completely described in [DB2MultiTenancy.md](DB2MultiTenancy.md). \n+\n+\n+----------------------------------------------------------------\n+\n+# Schema: FHIR Resource Data \n+\n+The IBM FHIR Server persists resources using tables defined in a data schema (usually FHIRDATA, but this can be anything). Multiple data schemas can exist in the same database, all managed from a single FHIR_ADMIN schema.\n+\n+> ![resource_schema.png](resource_schema.png)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "originalPosition": 174}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMDM4MTg3", "url": "https://github.com/IBM/FHIR/pull/1165#pullrequestreview-421038187", "createdAt": "2020-05-29T15:03:01Z", "commit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNTowMzowMVrOGcgm0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNTowMzowMVrOGcgm0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU0NzUzOA==", "bodyText": "Where is tenant_query_rewrite.png used?", "url": "https://github.com/IBM/FHIR/pull/1165#discussion_r432547538", "createdAt": "2020-05-29T15:03:01Z", "author": {"login": "prb112"}, "path": "fhir-persistence-schema/docs/DB2MultiTenancy.md", "diffHunk": "@@ -1,16 +1,225 @@\n-# The IBM FHIR Server - Db2 Multi-Tenancy\n+# The IBM FHIR Server - Multi-Tenancy on Db2\n \n-This document outlines the schema design and implementation for the IBM FHIR Server's Db2 Multi-tenancy feature. \n+This document outlines the schema design and implementation for the IBM FHIR Server's Multi-tenancy feature on Db2.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMDQ1MDc2", "url": "https://github.com/IBM/FHIR/pull/1165#pullrequestreview-421045076", "createdAt": "2020-05-29T15:11:29Z", "commit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNToxMToyOVrOGcg6cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNToxMToyOVrOGcg6cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU1MjU2Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ## SV_TENANT_ID SESSION VARIABLE \n          \n          \n            \n            **SESSION VARIABLE: SV_TENANT_ID**", "url": "https://github.com/IBM/FHIR/pull/1165#discussion_r432552563", "createdAt": "2020-05-29T15:11:29Z", "author": {"login": "prb112"}, "path": "fhir-persistence-schema/docs/DB2MultiTenancy.md", "diffHunk": "@@ -67,9 +342,36 @@ The VERSION_HISTORY table enables Tenant version isolation, so upgrades and patc\n | VERSION | INTEGER | 4 | No | The version starting at one and incrementing with every version change |\n | APPLIED | TIMESTAMP | 10 | No | The time of the latest object update |\n \n-### Schema: Tenant-Specific\n \n-The Tenant specific data is partitioned and isolated in a customer specific tablespace.  The tenant data is not mixed with other tenant data physically using the tablespace isolation. \n+## SV_TENANT_ID SESSION VARIABLE ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "originalPosition": 317}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMDQ1NjQ4", "url": "https://github.com/IBM/FHIR/pull/1165#pullrequestreview-421045648", "createdAt": "2020-05-29T15:12:09Z", "commit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNToxMjowOVrOGcg7_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNToxMjowOVrOGcg7_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU1Mjk1OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The variable privileges (grants) are updated one time, and applied to `FHIRUSER` user. The `FHIRUSER` gets only read access to this variable. To set the value of the variable, `FHIRUSER` must call `FHIR_ADMIN.SET_TENANT` as described in the next section.\n          \n          \n            \n            The variable privileges (grants) are updated one time, and applied to `FHIRSERVER` user. The `FHIRSERVER` gets only read access to this variable. To set the value of the variable, `FHIRSERVER` must call `FHIR_ADMIN.SET_TENANT` as described in the next section.", "url": "https://github.com/IBM/FHIR/pull/1165#discussion_r432552959", "createdAt": "2020-05-29T15:12:09Z", "author": {"login": "prb112"}, "path": "fhir-persistence-schema/docs/DB2MultiTenancy.md", "diffHunk": "@@ -67,9 +342,36 @@ The VERSION_HISTORY table enables Tenant version isolation, so upgrades and patc\n | VERSION | INTEGER | 4 | No | The version starting at one and incrementing with every version change |\n | APPLIED | TIMESTAMP | 10 | No | The time of the latest object update |\n \n-### Schema: Tenant-Specific\n \n-The Tenant specific data is partitioned and isolated in a customer specific tablespace.  The tenant data is not mixed with other tenant data physically using the tablespace isolation. \n+## SV_TENANT_ID SESSION VARIABLE \n+\n+The `FHIR_ADMIN.SV_TENANT_ID` session variable is used in a row permission object to isolate data among tenants. The variable is created in `FHIRSchemaGenerator.addVariable`, and its definition should not be modified. \n+\n+The variable privileges (grants) are updated one time, and applied to `FHIRUSER` user. The `FHIRUSER` gets only read access to this variable. To set the value of the variable, `FHIRUSER` must call `FHIR_ADMIN.SET_TENANT` as described in the next section.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "originalPosition": 321}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMDQ1OTIy", "url": "https://github.com/IBM/FHIR/pull/1165#pullrequestreview-421045922", "createdAt": "2020-05-29T15:12:29Z", "commit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNToxMjoyOVrOGcg80w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNToxMjoyOVrOGcg80w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU1MzE3MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            1. The client (e.g. the server) must have access to the database as the FHIRUSER user;\n          \n          \n            \n            1. The client (e.g. the server) must have access to the database as the FHIRSERVER user;", "url": "https://github.com/IBM/FHIR/pull/1165#discussion_r432553171", "createdAt": "2020-05-29T15:12:29Z", "author": {"login": "prb112"}, "path": "fhir-persistence-schema/docs/DB2MultiTenancy.md", "diffHunk": "@@ -1,16 +1,225 @@\n-# The IBM FHIR Server - Db2 Multi-Tenancy\n+# The IBM FHIR Server - Multi-Tenancy on Db2\n \n-This document outlines the schema design and implementation for the IBM FHIR Server's Db2 Multi-tenancy feature. \n+This document outlines the schema design and implementation for the IBM FHIR Server's Multi-tenancy feature on Db2.\n \n The Multi-tenancy feature has two main areas of focus: \n - Tenant Provisioning  \n - Security\n \n-## Multi-Tenancy Schema Design\n+This document assumes familiarity with the general [IBM FHIR Server schema design](SchemaMigration.md).\n+\n+# Multi-Tenancy Concepts and Design\n+\n+The IBM FHIR Server design supports three levels of multi-tenancy:\n+\n+1. Separate database per tenant\n+2. Separate data schema per tenant\n+3. (Db2-only) multiple tenants per schema, partitioned with row-based access control and per-tenant tablespaces.\n+\n+Of course, an entire deployment (application servers and database) also could be dedicated to a single tenant, which is really just a variant of option 1 above, although clearly such a configuration would not be considered multi-tenant.\n+\n+## Tenant Data Administration\n+\n+The IBM FHIR Server separates schema administration data from user data. All administration data is held in tables within the FHIRADMIN schema, and these tables are not directly accessible by the IBM FHIR Server database user.\n+\n+The FHIRADMIN schema is used to manage schema version migrations as well as tenant configuration for any tenants resident in the given database. The FHIRADMIN schema does not manage tenants in other databases.\n+\n+See the general [IBM FHIR Server schema design](SchemaMigration.md) documentation for a more detailed description of how FHIRADMIN tables are used to manage schema versions.\n+\n+\n+## Multi-tenancy using Db2 Table Partitions and Per Tenant Tablespaces\n+\n+The IBM FHIR Server provides a multi-tenancy feature based on Db2 row-based access control and table partitioning features.\n+\n+Each new tenant is allocated a unique tenant id value which is of database type `INT`. All tables in the IBM FHIR Server data schema (typically `FHIRDATA`) are created as range partitioned and configured with row-based access control. \n+\n+As an example, consider a table of patients created using the following DDL (illustrative only, this is not the actual IBM FHIR Server schema):\n+\n+```\n+CREATE TABLE ptng.patients (\n+\u00a0 \u00a0 mt_id \u00a0 \u00a0 \u00a0 \u00a0 \u00a0     INT \u00a0 \u00a0 NOT NULL,\n+\u00a0 \u00a0 patient_name\u00a0 \u00a0 VARCHAR(18) NOT NULL,\n+\u00a0 \u00a0 age \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 INT \u00a0 \u00a0 NOT NULL,\n+\u00a0 \u00a0 doctor_name \u00a0 \u00a0 VARCHAR(18),\n+\u00a0 \u00a0 ssn\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 CHAR(11),\n+\u00a0 \u00a0 CONSTRAINT pk_patient PRIMARY KEY (mt_id, patient_name)\n+)\n+PARTITION BY RANGE (mt_id) (STARTING 0 INCLUSIVE ENDING 0 INCLUSIVE);\n+```\n+\n+Each tenant is allocated a unique integer value for mt_id (multi-tenant id), with a range partition used to define which table partition is to be used for a particular tenant's mt_id. The mapping of tenant name to mt_id value is maintained in the FHIR_ADMIN.TENANTS table.\n+\n+The above example assumes that patient_name will be unique within the context of a single tenant, which obviously does not apply to the actual IBM FHIR Server schema. The primary key must include the partition range key `mt_id`. In addition, any secondary indexes MUST also include mt_id to ensure they are always local to the partition. For example:\n+\n+```\n+CREATE UNIQUE INDEX ptng.unq_ssn ON ptng.patients(mt_id, ssn);\n+```\n+\n+Local indexes are important to ensure proper tenant data isolation, with the added benefit of simplifying the task of removing the tenant when the time comes.\n+\n+## Per-Tenant Tablespaces\n+\n+Each tenant is allocated its own tablespace, and the table and index partitions for that tenant are all assigned to that tablespace, as depicted below:\n+\n+>![](partitioned_tables.png)\n+\n+Note: historically, DBAs would often cook up complex database layouts, using different tablespaces for tables and indexes to try and balance the IO workload for optimal throughput and/or latency. In cloud environments with heavily virtualized storage, this becomes less relevant and so leveraging tablespaces to provide an application function (isolating tenant data) is reasonable.\n+\n+Each tablespace is mapped to one or containers which are typically files at the OS filesystem level. When the tablespace is dropped, these files are deleted. The schema also defines a common tablespace `FHIR_TS` which is used for the base table definition. Db2 requires that a table and its partitions must use tablespaces with the same extent size.\n+\n+The tablespaces are created with automatic storage using an EXTENTSIZE of 4 (x32KB) pages to reduce overhead and improve deployment times. This is due to the large number of objects (tables and indexes) created in the schema, each requiring an initial number of extents. \n+\n+To add a new tenant, a utility program connects to Db2 as the FHIRADMIN user and adds records to the FHIR_ADMIN.TENANTS and FHIR_ADMIN.TENANT_KEYS tables. The utility probram then uses the newly assigned mt_id value when adding new partitions to each of the tables in the FHIRDATA schema.\n+\n+The tablespace is managed automatically with an ([EXTENTSIZE](https://www.ibm.com/support/knowledgecenter/SSEPGG_11.5.0/com.ibm.db2.luw.admin.dbobj.doc/doc/c0004964.html)) of 128KB. Note, the extentsize is multiplied by the pagesize to arrive at a storage size.\n+\n+Each tenant is allocated a partition based on the MT_ID and assigned to a tablespace. The tenant `tablespace` is created one time and no changes to the tablespace are expected.\n+\n+In general, smaller extent sizes can harm the performance of table and index scans because they limit the amount of data which can be read in a single IO operation. However, such scans are not common in most FHIR query use-cases, so this tends to not be an issue.\n+\n+\n+## Multi-tenant Queries\n+\n+We could use the multi-tenant enabled table definition as-is and modify every SQL statement to include `AND mt_id = ?` but this is error-prone and risky. If a query was missed or poorly written and ran without that predicate, it could expose data from another tenant.\n+\n+Instead, we leverage DB2 permission objects which allow us to specify a filter condition. Each query submitted by the application is rewritten by the database to include the `FOR ROWS WHERE` predicate, which is defined as: \n+\n+```\n+CREATE PERMISSION ROW_ACCESS ON ptng.patients\n+\u00a0\u00a0 \u00a0 \u00a0 \u00a0 FOR ROWS WHERE patients.mt_id = ptng.session_tenant\n+\u00a0\u00a0 \u00a0 \u00a0 \u00a0 ENFORCED FOR ALL ACCESS\n+\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ENABLE;\n+\n+ALTER TABLE ptng.patients ACTIVATE ROW ACCESS CONTROL;\n+```\n+\n+The `session_tenant` above is defined as a session variable. The application must set the value to match the mt_id value configured for the tenant.\n+\n+Logically:\n+\n+```\n+SET ptng.session_tenant = 1;\n+SELECT * FROM ptng.patients;\n+commit;\n+```\n+\n+Internally, DB2 rewrites the query to look like this:\n+\n+```\n+SELECT * FROM ptng.patients WHERE mt_id = 1;\n+```\n+\n+Because the table `ptng.patients` is partitioned using mt_id, the query optimizer is able to perform a partition-prune, by limiting the query access to the partition associated with the tenant. This results in a query execution plan very similar in terms of performance to a single-tenant scenario without any partitioning.\n+\n+To isolate a tenant's data at the file-system level, a tablespace is created per tenant and the partition objects are are allocated to that tablespace, including any local indexes:\n+\n+```\n+CREATE TABLESPACE TS_TENANT1 MANAGED BY AUTOMATIC STORAGE;\n+CREATE TABLESPACE TS_TENANT2 MANAGED BY AUTOMATIC STORAGE;\n+```\n+\n+\n+Adding new tenants requires adding partitions to each table in the data schema. Note how the partition is configured with the tenant's specific tablespace:\n+\n+```\n+-- for tenant #1\n+ALTER TABLE ptng.patients ADD PARTITION TENANT1 STARTING 1 INCLUSIVE ENDING 1 INCLUSIVE IN TS_TENANT1;\n+\n+-- for tenant #2\n+ALTER TABLE ptng.patients ADD PARTITION TENANT2 STARTING 2 INCLUSIVE ENDING 2 INCLUSIVE IN TS_TENANT2;\n+```\n+\n+When the tenant is deleted, the partition associated with the tenant is detached and subsequently dropped from the database. This renders the tenant data inaccessible from the perspective of a database user. However, database space management does not necessarily overwrite the freed blocks. Although the data is encrypted, someone with the database key and sufficient time, tooling and knowledge could theoretically retrieve parts of the data. By using a tablespace which is dropped, the database will delete the files at the OS layer.\n+\n+The process to delete a tenant is (logically):\n+\n+```\n+ALTER TABLE <tbl> DETACH PARTITION INTO <tbl_drp1>;\n+...\n+COMMIT;\n+DROP TABLE <tbl_drp1>;\n+...\n+COMMIT;\n+DROP TABLESPACE TS_TENANT1;\n+```\n+\n+In this case, TS_TENANT1 is the name of the tablespace previously assigned to the tenant being dropped.\n+\n+Note that DB2 requires a commit after the partition is detached and before the table `<tbl_drp1>` can be dropped. The tooling must implement this process to be idempotent to handle cases where a detach or drop might fail.\n+\n+Dropping partitions in this way works by swizzling metadata in the catalog which requires very little (redo) logging and is therefore far more efficient than deleting actual rows of data.\n+\n+\n+\n+\n+## Tenant Authentication\n+\n+The server connect to Db2 with a user configured for the least privileges it requires to provide the FHIR resource persistence and search functions. This user does not have any database administration privileges, unlike the FHIRADMIN user which is used to deploy the schema, allocate tenants etc.\n+\n+![Privilege Design](privilege_design.png)\n+\n+To prevent an application (or other user with access to the applications database connection information) from arbitrarily setting the session_tenant value, the user used by the IBM FHIR server to connect is granted only read access to the variable. This is why we create the session_tenant variable in the FHIR_ADMIN schema, owned by the FHIRADMIN user, not the FHIRDATA schema, which is the default schema for the user used by the server to access the database. In order to set (write) its value, the data user is granted execute privileges on a DB2 stored procedure called FHIR_ADMIN.SET_TENANT. This is the only way a non-administrative user can set the session_tenant value and access the data.\n+\n+The following table summarizes the properties/values involved in authenticating tenant access:\n+\n+| Property | Description |\n+|----------|-------------|\n+|TENANT_NAME | Used by applications to uniquely identify tenants |\n+| MT_ID | The integer primary key of the TENANTS table, used to map the TENANT_NAME to an integer value which is used as the partitioning key and row-based access permission predicate. |\n+| TENANT_KEY | A 32 byte random value created when the tenant is provisioned. This is a secret, and must be passed by the client to the database in order to obtain access to a tenant. A tenant may have multiple tenant keys to support key rotation. (deploy new key before removing old key) |\n+| TENANT_SALT | A 32 byte random value used as a salt when computing the SHA-256 tenant hash |\n+| TENANT_HASH | A SHA-256 hash of the TENANT_KEY and TENANT_SALT. The TENANT_KEY is never stored directly by the database. |\n+\n+\n+The FHIR_ADMIN.SET_TENANT stored procedure takes two parameters: the tenant name and the tenant key. This acts as a user/password pair tuple. The SET_TENANT code looks up a previously stored salt value associated with the tenant name and computes a hash of the salt + tenant key. If the result matches the stored hash value, the call is considered authentic, and the session_tenant variable is set.\n+\n+To summarize, for a client application to access tenant data in the multi-tenant Db2 schema, the following must apply:\n+\n+1. The client (e.g. the server) must have access to the database as the FHIRUSER user;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "originalPosition": 181}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMDQ3NDMy", "url": "https://github.com/IBM/FHIR/pull/1165#pullrequestreview-421047432", "createdAt": "2020-05-29T15:14:14Z", "commit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNToxNDoxNFrOGchBdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNToxNDoxNFrOGchBdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU1NDM1Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The FHIR_ADMIN.SET_TENANT stored procedure takes two parameters: the tenant name and the tenant key. This acts as a user/password pair tuple. The SET_TENANT code looks up a previously stored salt value associated with the tenant name and computes a hash of the salt + tenant key. If the result matches the stored hash value, the call is considered authentic, and the session_tenant variable is set.\n          \n          \n            \n            The FHIR_ADMIN.SET_TENANT stored procedure takes two parameters: the tenant name and the tenant key - acts as an authorization key. The SET_TENANT code looks up a previously stored salt value associated with the tenant name and computes a hash of the salt + tenant key. If the result matches the stored hash value, the call is considered authentic, and the session_tenant variable is set.\n          \n      \n    \n    \n  \n\nI suggest minimizing the user/password reference, a user reading this may conflate it with their user-password.", "url": "https://github.com/IBM/FHIR/pull/1165#discussion_r432554356", "createdAt": "2020-05-29T15:14:14Z", "author": {"login": "prb112"}, "path": "fhir-persistence-schema/docs/DB2MultiTenancy.md", "diffHunk": "@@ -1,16 +1,225 @@\n-# The IBM FHIR Server - Db2 Multi-Tenancy\n+# The IBM FHIR Server - Multi-Tenancy on Db2\n \n-This document outlines the schema design and implementation for the IBM FHIR Server's Db2 Multi-tenancy feature. \n+This document outlines the schema design and implementation for the IBM FHIR Server's Multi-tenancy feature on Db2.\n \n The Multi-tenancy feature has two main areas of focus: \n - Tenant Provisioning  \n - Security\n \n-## Multi-Tenancy Schema Design\n+This document assumes familiarity with the general [IBM FHIR Server schema design](SchemaMigration.md).\n+\n+# Multi-Tenancy Concepts and Design\n+\n+The IBM FHIR Server design supports three levels of multi-tenancy:\n+\n+1. Separate database per tenant\n+2. Separate data schema per tenant\n+3. (Db2-only) multiple tenants per schema, partitioned with row-based access control and per-tenant tablespaces.\n+\n+Of course, an entire deployment (application servers and database) also could be dedicated to a single tenant, which is really just a variant of option 1 above, although clearly such a configuration would not be considered multi-tenant.\n+\n+## Tenant Data Administration\n+\n+The IBM FHIR Server separates schema administration data from user data. All administration data is held in tables within the FHIRADMIN schema, and these tables are not directly accessible by the IBM FHIR Server database user.\n+\n+The FHIRADMIN schema is used to manage schema version migrations as well as tenant configuration for any tenants resident in the given database. The FHIRADMIN schema does not manage tenants in other databases.\n+\n+See the general [IBM FHIR Server schema design](SchemaMigration.md) documentation for a more detailed description of how FHIRADMIN tables are used to manage schema versions.\n+\n+\n+## Multi-tenancy using Db2 Table Partitions and Per Tenant Tablespaces\n+\n+The IBM FHIR Server provides a multi-tenancy feature based on Db2 row-based access control and table partitioning features.\n+\n+Each new tenant is allocated a unique tenant id value which is of database type `INT`. All tables in the IBM FHIR Server data schema (typically `FHIRDATA`) are created as range partitioned and configured with row-based access control. \n+\n+As an example, consider a table of patients created using the following DDL (illustrative only, this is not the actual IBM FHIR Server schema):\n+\n+```\n+CREATE TABLE ptng.patients (\n+\u00a0 \u00a0 mt_id \u00a0 \u00a0 \u00a0 \u00a0 \u00a0     INT \u00a0 \u00a0 NOT NULL,\n+\u00a0 \u00a0 patient_name\u00a0 \u00a0 VARCHAR(18) NOT NULL,\n+\u00a0 \u00a0 age \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 INT \u00a0 \u00a0 NOT NULL,\n+\u00a0 \u00a0 doctor_name \u00a0 \u00a0 VARCHAR(18),\n+\u00a0 \u00a0 ssn\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 CHAR(11),\n+\u00a0 \u00a0 CONSTRAINT pk_patient PRIMARY KEY (mt_id, patient_name)\n+)\n+PARTITION BY RANGE (mt_id) (STARTING 0 INCLUSIVE ENDING 0 INCLUSIVE);\n+```\n+\n+Each tenant is allocated a unique integer value for mt_id (multi-tenant id), with a range partition used to define which table partition is to be used for a particular tenant's mt_id. The mapping of tenant name to mt_id value is maintained in the FHIR_ADMIN.TENANTS table.\n+\n+The above example assumes that patient_name will be unique within the context of a single tenant, which obviously does not apply to the actual IBM FHIR Server schema. The primary key must include the partition range key `mt_id`. In addition, any secondary indexes MUST also include mt_id to ensure they are always local to the partition. For example:\n+\n+```\n+CREATE UNIQUE INDEX ptng.unq_ssn ON ptng.patients(mt_id, ssn);\n+```\n+\n+Local indexes are important to ensure proper tenant data isolation, with the added benefit of simplifying the task of removing the tenant when the time comes.\n+\n+## Per-Tenant Tablespaces\n+\n+Each tenant is allocated its own tablespace, and the table and index partitions for that tenant are all assigned to that tablespace, as depicted below:\n+\n+>![](partitioned_tables.png)\n+\n+Note: historically, DBAs would often cook up complex database layouts, using different tablespaces for tables and indexes to try and balance the IO workload for optimal throughput and/or latency. In cloud environments with heavily virtualized storage, this becomes less relevant and so leveraging tablespaces to provide an application function (isolating tenant data) is reasonable.\n+\n+Each tablespace is mapped to one or containers which are typically files at the OS filesystem level. When the tablespace is dropped, these files are deleted. The schema also defines a common tablespace `FHIR_TS` which is used for the base table definition. Db2 requires that a table and its partitions must use tablespaces with the same extent size.\n+\n+The tablespaces are created with automatic storage using an EXTENTSIZE of 4 (x32KB) pages to reduce overhead and improve deployment times. This is due to the large number of objects (tables and indexes) created in the schema, each requiring an initial number of extents. \n+\n+To add a new tenant, a utility program connects to Db2 as the FHIRADMIN user and adds records to the FHIR_ADMIN.TENANTS and FHIR_ADMIN.TENANT_KEYS tables. The utility probram then uses the newly assigned mt_id value when adding new partitions to each of the tables in the FHIRDATA schema.\n+\n+The tablespace is managed automatically with an ([EXTENTSIZE](https://www.ibm.com/support/knowledgecenter/SSEPGG_11.5.0/com.ibm.db2.luw.admin.dbobj.doc/doc/c0004964.html)) of 128KB. Note, the extentsize is multiplied by the pagesize to arrive at a storage size.\n+\n+Each tenant is allocated a partition based on the MT_ID and assigned to a tablespace. The tenant `tablespace` is created one time and no changes to the tablespace are expected.\n+\n+In general, smaller extent sizes can harm the performance of table and index scans because they limit the amount of data which can be read in a single IO operation. However, such scans are not common in most FHIR query use-cases, so this tends to not be an issue.\n+\n+\n+## Multi-tenant Queries\n+\n+We could use the multi-tenant enabled table definition as-is and modify every SQL statement to include `AND mt_id = ?` but this is error-prone and risky. If a query was missed or poorly written and ran without that predicate, it could expose data from another tenant.\n+\n+Instead, we leverage DB2 permission objects which allow us to specify a filter condition. Each query submitted by the application is rewritten by the database to include the `FOR ROWS WHERE` predicate, which is defined as: \n+\n+```\n+CREATE PERMISSION ROW_ACCESS ON ptng.patients\n+\u00a0\u00a0 \u00a0 \u00a0 \u00a0 FOR ROWS WHERE patients.mt_id = ptng.session_tenant\n+\u00a0\u00a0 \u00a0 \u00a0 \u00a0 ENFORCED FOR ALL ACCESS\n+\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ENABLE;\n+\n+ALTER TABLE ptng.patients ACTIVATE ROW ACCESS CONTROL;\n+```\n+\n+The `session_tenant` above is defined as a session variable. The application must set the value to match the mt_id value configured for the tenant.\n+\n+Logically:\n+\n+```\n+SET ptng.session_tenant = 1;\n+SELECT * FROM ptng.patients;\n+commit;\n+```\n+\n+Internally, DB2 rewrites the query to look like this:\n+\n+```\n+SELECT * FROM ptng.patients WHERE mt_id = 1;\n+```\n+\n+Because the table `ptng.patients` is partitioned using mt_id, the query optimizer is able to perform a partition-prune, by limiting the query access to the partition associated with the tenant. This results in a query execution plan very similar in terms of performance to a single-tenant scenario without any partitioning.\n+\n+To isolate a tenant's data at the file-system level, a tablespace is created per tenant and the partition objects are are allocated to that tablespace, including any local indexes:\n+\n+```\n+CREATE TABLESPACE TS_TENANT1 MANAGED BY AUTOMATIC STORAGE;\n+CREATE TABLESPACE TS_TENANT2 MANAGED BY AUTOMATIC STORAGE;\n+```\n+\n+\n+Adding new tenants requires adding partitions to each table in the data schema. Note how the partition is configured with the tenant's specific tablespace:\n+\n+```\n+-- for tenant #1\n+ALTER TABLE ptng.patients ADD PARTITION TENANT1 STARTING 1 INCLUSIVE ENDING 1 INCLUSIVE IN TS_TENANT1;\n+\n+-- for tenant #2\n+ALTER TABLE ptng.patients ADD PARTITION TENANT2 STARTING 2 INCLUSIVE ENDING 2 INCLUSIVE IN TS_TENANT2;\n+```\n+\n+When the tenant is deleted, the partition associated with the tenant is detached and subsequently dropped from the database. This renders the tenant data inaccessible from the perspective of a database user. However, database space management does not necessarily overwrite the freed blocks. Although the data is encrypted, someone with the database key and sufficient time, tooling and knowledge could theoretically retrieve parts of the data. By using a tablespace which is dropped, the database will delete the files at the OS layer.\n+\n+The process to delete a tenant is (logically):\n+\n+```\n+ALTER TABLE <tbl> DETACH PARTITION INTO <tbl_drp1>;\n+...\n+COMMIT;\n+DROP TABLE <tbl_drp1>;\n+...\n+COMMIT;\n+DROP TABLESPACE TS_TENANT1;\n+```\n+\n+In this case, TS_TENANT1 is the name of the tablespace previously assigned to the tenant being dropped.\n+\n+Note that DB2 requires a commit after the partition is detached and before the table `<tbl_drp1>` can be dropped. The tooling must implement this process to be idempotent to handle cases where a detach or drop might fail.\n+\n+Dropping partitions in this way works by swizzling metadata in the catalog which requires very little (redo) logging and is therefore far more efficient than deleting actual rows of data.\n+\n+\n+\n+\n+## Tenant Authentication\n+\n+The server connect to Db2 with a user configured for the least privileges it requires to provide the FHIR resource persistence and search functions. This user does not have any database administration privileges, unlike the FHIRADMIN user which is used to deploy the schema, allocate tenants etc.\n+\n+![Privilege Design](privilege_design.png)\n+\n+To prevent an application (or other user with access to the applications database connection information) from arbitrarily setting the session_tenant value, the user used by the IBM FHIR server to connect is granted only read access to the variable. This is why we create the session_tenant variable in the FHIR_ADMIN schema, owned by the FHIRADMIN user, not the FHIRDATA schema, which is the default schema for the user used by the server to access the database. In order to set (write) its value, the data user is granted execute privileges on a DB2 stored procedure called FHIR_ADMIN.SET_TENANT. This is the only way a non-administrative user can set the session_tenant value and access the data.\n+\n+The following table summarizes the properties/values involved in authenticating tenant access:\n+\n+| Property | Description |\n+|----------|-------------|\n+|TENANT_NAME | Used by applications to uniquely identify tenants |\n+| MT_ID | The integer primary key of the TENANTS table, used to map the TENANT_NAME to an integer value which is used as the partitioning key and row-based access permission predicate. |\n+| TENANT_KEY | A 32 byte random value created when the tenant is provisioned. This is a secret, and must be passed by the client to the database in order to obtain access to a tenant. A tenant may have multiple tenant keys to support key rotation. (deploy new key before removing old key) |\n+| TENANT_SALT | A 32 byte random value used as a salt when computing the SHA-256 tenant hash |\n+| TENANT_HASH | A SHA-256 hash of the TENANT_KEY and TENANT_SALT. The TENANT_KEY is never stored directly by the database. |\n+\n+\n+The FHIR_ADMIN.SET_TENANT stored procedure takes two parameters: the tenant name and the tenant key. This acts as a user/password pair tuple. The SET_TENANT code looks up a previously stored salt value associated with the tenant name and computes a hash of the salt + tenant key. If the result matches the stored hash value, the call is considered authentic, and the session_tenant variable is set.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "originalPosition": 177}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMDQ4MTc4", "url": "https://github.com/IBM/FHIR/pull/1165#pullrequestreview-421048178", "createdAt": "2020-05-29T15:15:05Z", "commit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNToxNTowNVrOGchDuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNToxNTowNVrOGchDuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU1NDkzOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            2. Dropping the tenant's tablespace, which will delete the database container files on the underlying OS filesystem.\n          \n          \n            \n            2. Dropping the tenant's tablespace, which deletes the database container files on the underlying OS filesystem.", "url": "https://github.com/IBM/FHIR/pull/1165#discussion_r432554939", "createdAt": "2020-05-29T15:15:05Z", "author": {"login": "prb112"}, "path": "fhir-persistence-schema/docs/DB2MultiTenancy.md", "diffHunk": "@@ -1,16 +1,225 @@\n-# The IBM FHIR Server - Db2 Multi-Tenancy\n+# The IBM FHIR Server - Multi-Tenancy on Db2\n \n-This document outlines the schema design and implementation for the IBM FHIR Server's Db2 Multi-tenancy feature. \n+This document outlines the schema design and implementation for the IBM FHIR Server's Multi-tenancy feature on Db2.\n \n The Multi-tenancy feature has two main areas of focus: \n - Tenant Provisioning  \n - Security\n \n-## Multi-Tenancy Schema Design\n+This document assumes familiarity with the general [IBM FHIR Server schema design](SchemaMigration.md).\n+\n+# Multi-Tenancy Concepts and Design\n+\n+The IBM FHIR Server design supports three levels of multi-tenancy:\n+\n+1. Separate database per tenant\n+2. Separate data schema per tenant\n+3. (Db2-only) multiple tenants per schema, partitioned with row-based access control and per-tenant tablespaces.\n+\n+Of course, an entire deployment (application servers and database) also could be dedicated to a single tenant, which is really just a variant of option 1 above, although clearly such a configuration would not be considered multi-tenant.\n+\n+## Tenant Data Administration\n+\n+The IBM FHIR Server separates schema administration data from user data. All administration data is held in tables within the FHIRADMIN schema, and these tables are not directly accessible by the IBM FHIR Server database user.\n+\n+The FHIRADMIN schema is used to manage schema version migrations as well as tenant configuration for any tenants resident in the given database. The FHIRADMIN schema does not manage tenants in other databases.\n+\n+See the general [IBM FHIR Server schema design](SchemaMigration.md) documentation for a more detailed description of how FHIRADMIN tables are used to manage schema versions.\n+\n+\n+## Multi-tenancy using Db2 Table Partitions and Per Tenant Tablespaces\n+\n+The IBM FHIR Server provides a multi-tenancy feature based on Db2 row-based access control and table partitioning features.\n+\n+Each new tenant is allocated a unique tenant id value which is of database type `INT`. All tables in the IBM FHIR Server data schema (typically `FHIRDATA`) are created as range partitioned and configured with row-based access control. \n+\n+As an example, consider a table of patients created using the following DDL (illustrative only, this is not the actual IBM FHIR Server schema):\n+\n+```\n+CREATE TABLE ptng.patients (\n+\u00a0 \u00a0 mt_id \u00a0 \u00a0 \u00a0 \u00a0 \u00a0     INT \u00a0 \u00a0 NOT NULL,\n+\u00a0 \u00a0 patient_name\u00a0 \u00a0 VARCHAR(18) NOT NULL,\n+\u00a0 \u00a0 age \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 INT \u00a0 \u00a0 NOT NULL,\n+\u00a0 \u00a0 doctor_name \u00a0 \u00a0 VARCHAR(18),\n+\u00a0 \u00a0 ssn\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 CHAR(11),\n+\u00a0 \u00a0 CONSTRAINT pk_patient PRIMARY KEY (mt_id, patient_name)\n+)\n+PARTITION BY RANGE (mt_id) (STARTING 0 INCLUSIVE ENDING 0 INCLUSIVE);\n+```\n+\n+Each tenant is allocated a unique integer value for mt_id (multi-tenant id), with a range partition used to define which table partition is to be used for a particular tenant's mt_id. The mapping of tenant name to mt_id value is maintained in the FHIR_ADMIN.TENANTS table.\n+\n+The above example assumes that patient_name will be unique within the context of a single tenant, which obviously does not apply to the actual IBM FHIR Server schema. The primary key must include the partition range key `mt_id`. In addition, any secondary indexes MUST also include mt_id to ensure they are always local to the partition. For example:\n+\n+```\n+CREATE UNIQUE INDEX ptng.unq_ssn ON ptng.patients(mt_id, ssn);\n+```\n+\n+Local indexes are important to ensure proper tenant data isolation, with the added benefit of simplifying the task of removing the tenant when the time comes.\n+\n+## Per-Tenant Tablespaces\n+\n+Each tenant is allocated its own tablespace, and the table and index partitions for that tenant are all assigned to that tablespace, as depicted below:\n+\n+>![](partitioned_tables.png)\n+\n+Note: historically, DBAs would often cook up complex database layouts, using different tablespaces for tables and indexes to try and balance the IO workload for optimal throughput and/or latency. In cloud environments with heavily virtualized storage, this becomes less relevant and so leveraging tablespaces to provide an application function (isolating tenant data) is reasonable.\n+\n+Each tablespace is mapped to one or containers which are typically files at the OS filesystem level. When the tablespace is dropped, these files are deleted. The schema also defines a common tablespace `FHIR_TS` which is used for the base table definition. Db2 requires that a table and its partitions must use tablespaces with the same extent size.\n+\n+The tablespaces are created with automatic storage using an EXTENTSIZE of 4 (x32KB) pages to reduce overhead and improve deployment times. This is due to the large number of objects (tables and indexes) created in the schema, each requiring an initial number of extents. \n+\n+To add a new tenant, a utility program connects to Db2 as the FHIRADMIN user and adds records to the FHIR_ADMIN.TENANTS and FHIR_ADMIN.TENANT_KEYS tables. The utility probram then uses the newly assigned mt_id value when adding new partitions to each of the tables in the FHIRDATA schema.\n+\n+The tablespace is managed automatically with an ([EXTENTSIZE](https://www.ibm.com/support/knowledgecenter/SSEPGG_11.5.0/com.ibm.db2.luw.admin.dbobj.doc/doc/c0004964.html)) of 128KB. Note, the extentsize is multiplied by the pagesize to arrive at a storage size.\n+\n+Each tenant is allocated a partition based on the MT_ID and assigned to a tablespace. The tenant `tablespace` is created one time and no changes to the tablespace are expected.\n+\n+In general, smaller extent sizes can harm the performance of table and index scans because they limit the amount of data which can be read in a single IO operation. However, such scans are not common in most FHIR query use-cases, so this tends to not be an issue.\n+\n+\n+## Multi-tenant Queries\n+\n+We could use the multi-tenant enabled table definition as-is and modify every SQL statement to include `AND mt_id = ?` but this is error-prone and risky. If a query was missed or poorly written and ran without that predicate, it could expose data from another tenant.\n+\n+Instead, we leverage DB2 permission objects which allow us to specify a filter condition. Each query submitted by the application is rewritten by the database to include the `FOR ROWS WHERE` predicate, which is defined as: \n+\n+```\n+CREATE PERMISSION ROW_ACCESS ON ptng.patients\n+\u00a0\u00a0 \u00a0 \u00a0 \u00a0 FOR ROWS WHERE patients.mt_id = ptng.session_tenant\n+\u00a0\u00a0 \u00a0 \u00a0 \u00a0 ENFORCED FOR ALL ACCESS\n+\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ENABLE;\n+\n+ALTER TABLE ptng.patients ACTIVATE ROW ACCESS CONTROL;\n+```\n+\n+The `session_tenant` above is defined as a session variable. The application must set the value to match the mt_id value configured for the tenant.\n+\n+Logically:\n+\n+```\n+SET ptng.session_tenant = 1;\n+SELECT * FROM ptng.patients;\n+commit;\n+```\n+\n+Internally, DB2 rewrites the query to look like this:\n+\n+```\n+SELECT * FROM ptng.patients WHERE mt_id = 1;\n+```\n+\n+Because the table `ptng.patients` is partitioned using mt_id, the query optimizer is able to perform a partition-prune, by limiting the query access to the partition associated with the tenant. This results in a query execution plan very similar in terms of performance to a single-tenant scenario without any partitioning.\n+\n+To isolate a tenant's data at the file-system level, a tablespace is created per tenant and the partition objects are are allocated to that tablespace, including any local indexes:\n+\n+```\n+CREATE TABLESPACE TS_TENANT1 MANAGED BY AUTOMATIC STORAGE;\n+CREATE TABLESPACE TS_TENANT2 MANAGED BY AUTOMATIC STORAGE;\n+```\n+\n+\n+Adding new tenants requires adding partitions to each table in the data schema. Note how the partition is configured with the tenant's specific tablespace:\n+\n+```\n+-- for tenant #1\n+ALTER TABLE ptng.patients ADD PARTITION TENANT1 STARTING 1 INCLUSIVE ENDING 1 INCLUSIVE IN TS_TENANT1;\n+\n+-- for tenant #2\n+ALTER TABLE ptng.patients ADD PARTITION TENANT2 STARTING 2 INCLUSIVE ENDING 2 INCLUSIVE IN TS_TENANT2;\n+```\n+\n+When the tenant is deleted, the partition associated with the tenant is detached and subsequently dropped from the database. This renders the tenant data inaccessible from the perspective of a database user. However, database space management does not necessarily overwrite the freed blocks. Although the data is encrypted, someone with the database key and sufficient time, tooling and knowledge could theoretically retrieve parts of the data. By using a tablespace which is dropped, the database will delete the files at the OS layer.\n+\n+The process to delete a tenant is (logically):\n+\n+```\n+ALTER TABLE <tbl> DETACH PARTITION INTO <tbl_drp1>;\n+...\n+COMMIT;\n+DROP TABLE <tbl_drp1>;\n+...\n+COMMIT;\n+DROP TABLESPACE TS_TENANT1;\n+```\n+\n+In this case, TS_TENANT1 is the name of the tablespace previously assigned to the tenant being dropped.\n+\n+Note that DB2 requires a commit after the partition is detached and before the table `<tbl_drp1>` can be dropped. The tooling must implement this process to be idempotent to handle cases where a detach or drop might fail.\n+\n+Dropping partitions in this way works by swizzling metadata in the catalog which requires very little (redo) logging and is therefore far more efficient than deleting actual rows of data.\n+\n+\n+\n+\n+## Tenant Authentication\n+\n+The server connect to Db2 with a user configured for the least privileges it requires to provide the FHIR resource persistence and search functions. This user does not have any database administration privileges, unlike the FHIRADMIN user which is used to deploy the schema, allocate tenants etc.\n+\n+![Privilege Design](privilege_design.png)\n+\n+To prevent an application (or other user with access to the applications database connection information) from arbitrarily setting the session_tenant value, the user used by the IBM FHIR server to connect is granted only read access to the variable. This is why we create the session_tenant variable in the FHIR_ADMIN schema, owned by the FHIRADMIN user, not the FHIRDATA schema, which is the default schema for the user used by the server to access the database. In order to set (write) its value, the data user is granted execute privileges on a DB2 stored procedure called FHIR_ADMIN.SET_TENANT. This is the only way a non-administrative user can set the session_tenant value and access the data.\n+\n+The following table summarizes the properties/values involved in authenticating tenant access:\n+\n+| Property | Description |\n+|----------|-------------|\n+|TENANT_NAME | Used by applications to uniquely identify tenants |\n+| MT_ID | The integer primary key of the TENANTS table, used to map the TENANT_NAME to an integer value which is used as the partitioning key and row-based access permission predicate. |\n+| TENANT_KEY | A 32 byte random value created when the tenant is provisioned. This is a secret, and must be passed by the client to the database in order to obtain access to a tenant. A tenant may have multiple tenant keys to support key rotation. (deploy new key before removing old key) |\n+| TENANT_SALT | A 32 byte random value used as a salt when computing the SHA-256 tenant hash |\n+| TENANT_HASH | A SHA-256 hash of the TENANT_KEY and TENANT_SALT. The TENANT_KEY is never stored directly by the database. |\n+\n+\n+The FHIR_ADMIN.SET_TENANT stored procedure takes two parameters: the tenant name and the tenant key. This acts as a user/password pair tuple. The SET_TENANT code looks up a previously stored salt value associated with the tenant name and computes a hash of the salt + tenant key. If the result matches the stored hash value, the call is considered authentic, and the session_tenant variable is set.\n+\n+To summarize, for a client application to access tenant data in the multi-tenant Db2 schema, the following must apply:\n+\n+1. The client (e.g. the server) must have access to the database as the FHIRUSER user;\n+2. The user FHIRUSER must be granted execute privilges on the FHIR_ADMIN.SET_TENANT procedure;\n+3. The user FHIRUSER must be granted READ on FHIR_ADMIN.SV_TENANT_ID;\n+4. The user FHIRUSER must be granted SELECT,INSERT,UPDATE,DELETE on all tables in the FHIRDATA schema. \n+\n+## Summary of Granted Privileges:\n+\n+| Grants |\n+| --- |\n+| All objects in schema FHIR_ADMIN are owned by user FHIRADMIN |\n+| All objects in schema FHIRDATA are owned by user FHIRADMIN |\n+| GRANT EXECUTE ON FHIR_ADMIN.SET_TENANT TO FHIRUSER; |\n+| GRANT READ ON FHIR_ADMIN.SV_TENANT_ID TO FHIRUSER; |\n+| GRANT EXECUTE ON FHIRDATA.ADD_RESOURCE_TYPE TO FHIRUSER; |\n+| GRANT EXECUTE ON FHIRDATA.ADD_RESOURCE TO FHIRUSER; |\n+| GRANT SELECT,INSERT,UPDATE,DELETE ON FHIRDATA.PATIENT_RESOURCES TO FHIRUSER; |\n+\n+\n+## Tenant Data Security\n+\n+HIPAA controls require protected data at rest is encrypted, and this is implemented by using Db2 native encryption. When the tenant is deleted, its data must be rendered inaccessible. This is achieved by the following:\n+\n+1. Detaching the tenant's partition and dropping the table created by the detach operation.\n+2. Dropping the tenant's tablespace, which will delete the database container files on the underlying OS filesystem.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "originalPosition": 204}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMDUwNzUz", "url": "https://github.com/IBM/FHIR/pull/1165#pullrequestreview-421050753", "createdAt": "2020-05-29T15:18:10Z", "commit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNToxODoxMFrOGchLZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNToxODoxMFrOGchLZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU1NjkwMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | PostgreSQL | Based on the Derby implementation, but uses a stored procedure for the resource persistence logic, like DB2 |\n          \n          \n            \n            | PostgreSQL | Uses a function for the resource persistence logic |", "url": "https://github.com/IBM/FHIR/pull/1165#discussion_r432556900", "createdAt": "2020-05-29T15:18:10Z", "author": {"login": "prb112"}, "path": "fhir-persistence-schema/docs/SchemaMigration.md", "diffHunk": "@@ -0,0 +1,407 @@\n+# The IBM FHIR Server - Schema Design and Management\n+\n+This document details the IBM FHIR Server schema design and how schema changes are managed. There are differences among the databases currently supported, most notably with Db2 which uses additional database capabilities to support multi-tenancy. Details of the multi-tenant design can be found [here](DB2MultiTenancy.md). Other variations across databases are discussed in this document.\n+\n+Currently it is not possible to deploy the simplified single-tenant variant of the schema to Db2. GitHub [issue-840](https://github.com/IBM/FHIR/issues/840) has been opened to address this. \n+\n+\n+There are three core projects which are referenced: \n+\n+| Project | Description |\n+|----------|---------------------------------------------|\n+| `fhir-model` | The HL7 FHIR model - generated Java code |\n+| `fhir-database-utils` | The SQL/database constructs used to create SQL compliant statements |\n+| `fhir-persistence-schema` | Uses database-utils to define a physical data model for storing FHIR resources and supporting the FHIR API |\n+\n+The schema generates the following object types that require management: \n+\n+- DB2 PACKAGE\n+- TABLESPACES\n+- SCHEMA \n+- GLOBAL VARIABLE \n+- INDEX \n+- PERMISSION \n+- PROCEDURE \n+- SEQUENCE \n+- TABLE\n+- TABLE CONSTRAINT \n+\n+----------------------------------------------------------------\n+# Database Support\n+\n+\n+| Database   | Version   | Support |\n+|------------|-----------|-----------------------------------|\n+| DB2        |      11.5 | Suitable for production. Supports multi-tenancy. |\n+| PostgreSQL |        12 | Experimental. Single tenant per database. |\n+| Derby      | 10.14.2.0 | Development only. Single tenant per database |\n+\n+\n+----------------------------------------------------------------\n+# Overview and Concepts\n+\n+The IBM FHIR schema is managed in code and is applied to a target database using a JDBC connection. This simplifies development of Derby-based unit-tests, allows a common schema definition to be used across multiple database flavors, simplifies deployment in cloud scenarios, and because the data model dependencies are understood by the code, the schema creation process can be parallelized to reduce deployment times. In practice, however, we've found that the number of threads must be limited due to driving contention in the internal catalog tables (in DB2, for example). We have also found that some parallel object create operations cause internal database deadlocks (notably creating foreign key relationships). The implementation contains a retry loop, but may fail if the retry limit is exceeded. Note that these deadlocks are internal to Db2, not the more common kind typically caused by poor application code.\n+\n+The `FHIR_ADMIN` schema is used to manage meta-data related to the actual data schemas. A single database instance can be used to support multiple FHIR data schemas, as long as the FHIR_ADMIN schema structure doesn't change. At the time of writing, the IBM FHIR Server does not support more than one FHIR_ADMIN schema in a single database. If a use-case arises where this is required, it is simply a matter of identifying in code where FHIR_ADMIN is used as a constant and replacing instances with a configurable property, although an implementation may also want to consider protecting individual schemas from accidentally being managed by more than one FHIR_ADMIN schema. One possible use-case for this sharing is using a database instance for schema development work, although use of the Db2 docker container makes this moot.\n+\n+The `FHIR_ADMIN` schema also plays an important role in managing tenants in the Db2 multi-tenant implementation. See the [Db2 Multi-Tenant Schema Design](DB2MultiTenancy.md) for more details.\n+\n+\n+## Differences Among Database Implementations\n+\n+The following table highlights the main differences among the database implementations currently supported:\n+\n+| Database   | Variation |\n+| --------   | ----------|\n+| DB2        | Multi-tenant. Supports multiple but isolated tenants within one database/schema |\n+| DB2        | An SPL stored procedure is used to implement the resource storage logic, reducing the number of application server to database round-trips, improving performance |\n+| DB2        | Uses `FHIR_TS` tablespace for admin tables, and a tablespace per tenant |\n+| DB2        | `FHIR_TS` is created using a small extent size for efficiency |\n+| PostgreSQL | Based on the Derby implementation, but uses a stored procedure for the resource persistence logic, like DB2 |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "originalPosition": 60}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMDUyMDk5", "url": "https://github.com/IBM/FHIR/pull/1165#pullrequestreview-421052099", "createdAt": "2020-05-29T15:19:50Z", "commit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNToxOTo1MFrOGchPfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNToxOTo1MFrOGchPfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU1Nzk0OQ==", "bodyText": "let's not cite these, it's hard to back track", "url": "https://github.com/IBM/FHIR/pull/1165#discussion_r432557949", "createdAt": "2020-05-29T15:19:50Z", "author": {"login": "prb112"}, "path": "fhir-persistence-schema/docs/SchemaMigration.md", "diffHunk": "@@ -0,0 +1,407 @@\n+# The IBM FHIR Server - Schema Design and Management\n+\n+This document details the IBM FHIR Server schema design and how schema changes are managed. There are differences among the databases currently supported, most notably with Db2 which uses additional database capabilities to support multi-tenancy. Details of the multi-tenant design can be found [here](DB2MultiTenancy.md). Other variations across databases are discussed in this document.\n+\n+Currently it is not possible to deploy the simplified single-tenant variant of the schema to Db2. GitHub [issue-840](https://github.com/IBM/FHIR/issues/840) has been opened to address this. \n+\n+\n+There are three core projects which are referenced: \n+\n+| Project | Description |\n+|----------|---------------------------------------------|\n+| `fhir-model` | The HL7 FHIR model - generated Java code |\n+| `fhir-database-utils` | The SQL/database constructs used to create SQL compliant statements |\n+| `fhir-persistence-schema` | Uses database-utils to define a physical data model for storing FHIR resources and supporting the FHIR API |\n+\n+The schema generates the following object types that require management: \n+\n+- DB2 PACKAGE\n+- TABLESPACES\n+- SCHEMA \n+- GLOBAL VARIABLE \n+- INDEX \n+- PERMISSION \n+- PROCEDURE \n+- SEQUENCE \n+- TABLE\n+- TABLE CONSTRAINT \n+\n+----------------------------------------------------------------\n+# Database Support\n+\n+\n+| Database   | Version   | Support |\n+|------------|-----------|-----------------------------------|\n+| DB2        |      11.5 | Suitable for production. Supports multi-tenancy. |\n+| PostgreSQL |        12 | Experimental. Single tenant per database. |\n+| Derby      | 10.14.2.0 | Development only. Single tenant per database |\n+\n+\n+----------------------------------------------------------------\n+# Overview and Concepts\n+\n+The IBM FHIR schema is managed in code and is applied to a target database using a JDBC connection. This simplifies development of Derby-based unit-tests, allows a common schema definition to be used across multiple database flavors, simplifies deployment in cloud scenarios, and because the data model dependencies are understood by the code, the schema creation process can be parallelized to reduce deployment times. In practice, however, we've found that the number of threads must be limited due to driving contention in the internal catalog tables (in DB2, for example). We have also found that some parallel object create operations cause internal database deadlocks (notably creating foreign key relationships). The implementation contains a retry loop, but may fail if the retry limit is exceeded. Note that these deadlocks are internal to Db2, not the more common kind typically caused by poor application code.\n+\n+The `FHIR_ADMIN` schema is used to manage meta-data related to the actual data schemas. A single database instance can be used to support multiple FHIR data schemas, as long as the FHIR_ADMIN schema structure doesn't change. At the time of writing, the IBM FHIR Server does not support more than one FHIR_ADMIN schema in a single database. If a use-case arises where this is required, it is simply a matter of identifying in code where FHIR_ADMIN is used as a constant and replacing instances with a configurable property, although an implementation may also want to consider protecting individual schemas from accidentally being managed by more than one FHIR_ADMIN schema. One possible use-case for this sharing is using a database instance for schema development work, although use of the Db2 docker container makes this moot.\n+\n+The `FHIR_ADMIN` schema also plays an important role in managing tenants in the Db2 multi-tenant implementation. See the [Db2 Multi-Tenant Schema Design](DB2MultiTenancy.md) for more details.\n+\n+\n+## Differences Among Database Implementations\n+\n+The following table highlights the main differences among the database implementations currently supported:\n+\n+| Database   | Variation |\n+| --------   | ----------|\n+| DB2        | Multi-tenant. Supports multiple but isolated tenants within one database/schema |\n+| DB2        | An SPL stored procedure is used to implement the resource storage logic, reducing the number of application server to database round-trips, improving performance |\n+| DB2        | Uses `FHIR_TS` tablespace for admin tables, and a tablespace per tenant |\n+| DB2        | `FHIR_TS` is created using a small extent size for efficiency |\n+| PostgreSQL | Based on the Derby implementation, but uses a stored procedure for the resource persistence logic, like DB2 |\n+| PostgreSQL | TEXT type used instead of CLOB for large data values |\n+| Derby      | Resource persistence is implemented at the DAO layer as a sequence of individual statements instead of one procedure call. At a functional level, the process is identical. Simplifies debugging and supports easier unit-test construction. |\n+\n+\n+----------------------------------------------------------------\n+# Schema Management\n+\n+Use of the schema management tool is described [here](https://github.com/IBM/FHIR/tree/master/fhir-persistence-schema/README.md).\n+\n+The schema is managed using the class `com.ibm.fhir.schema.app.Main`. The `Main` class uses `FhirSchemaGenerator` to build a `PhysicalDataModel` which represents the schema as a Java data structure. This schema model is then applied to a database using an implementation of `IDatabaseAdapter` specific to the target database type (Derby, PostgreSQL or DB2). The adapter implements calls such as `createTable` and constructs the DDL statement appropriate for the target database. In some cases where the object type is not supported or not required for the given target database, the adapter can simply perform no operation (NOP).\n+\n+The code models dependencies among the various objects such as foreign key relationships between tables. Others relationships are marked explicitly, such as stored procedure dependency on tables. To keep things simple, there are some `NopObject` markers used as a barrier during parallel deployment. This barrier is used to collect together a lot of dependencies into one place, allowing subsequent operations to just depend on the barrier object instead of each having to individually express a dependency to lots of objects.\n+\n+The following example shows how we define a table in the schema. In this case, we are creating the global logical resources table (which is not resource-type specific):\n+\n+```java\n+ 1    public void addLogicalResources(PhysicalDataModel pdm) {\n+ 2       final String tableName = LOGICAL_RESOURCES;\n+ 3\n+ 4       Table tbl = Table.builder(schemaName, tableName)\n+ 5               .setTenantColumnName(MT_ID)\n+ 6               .addBigIntColumn(LOGICAL_RESOURCE_ID, false)\n+ 7               .addIntColumn(RESOURCE_TYPE_ID, false)\n+ 8               .addVarcharColumn(LOGICAL_ID, LOGICAL_ID_BYTES, false)\n+ 9               .addPrimaryKey(tableName + \"_PK\", LOGICAL_RESOURCE_ID)\n+10                .addUniqueIndex(\"UNQ_\" + LOGICAL_RESOURCES, RESOURCE_TYPE_ID, LOGICAL_ID)\n+11                .setTablespace(fhirTablespace)\n+12                .addPrivileges(resourceTablePrivileges)\n+13                .addForeignKeyConstraint(FK + tableName + \"_RTID\", schemaName, RESOURCE_TYPES, RESOURCE_TYPE_ID)\n+14                .enableAccessControl(this.sessionVariable)\n+15                .build(pdm);\n+\n+16        tbl.addTag(SCHEMA_GROUP_TAG, FHIRDATA_GROUP);\n+17        this.procedureDependencies.add(tbl);\n+18        pdm.addTable(tbl);\n+19        pdm.addObject(tbl);\n+20    }\n+```\n+\n+Notes:\n+\n+**Line 4.** Database objects are created using the fluent builder pattern to create an immutable definition.\n+\n+**Line 5.** MT_ID is used as the tenant column. The tenant column is handled as an explicit property (rather than just addIntColumn) because it allows us to ignore it later depending on the database target the model is being applied to. Currenly only Db2 supports our multi-tenant design.\n+\n+**Line 6.** Adds a column to table definition.\n+\n+**Line 9.** Specifies the primary key. The columns in the PK definition must be added before addPrimaryKey is called.\n+\n+**Line 10.** Adds a unique index to the table.\n+\n+**Line 11.** Identifies the tablespace to be used for this table. All tables are created in a specific tablespace `FHIR_TS` created with a smaller than typical extent size. The model contains a large number of tables and indexes, and in the multi-tenant schema, the initial table/partition never holds any data. Using a smaller extent size significantly improves schema deployment time because the database has to allocate fewer pages for each object, and this also reduces waste from allocating space that would never be used.\n+\n+**Line 12.** Adds the list of privileges that need to be applied to this table.\n+\n+**Line 13.** Adds a foreign key relationship to a target table, which is RESOURCE_TYPES in this case.\n+\n+**Line 14.** Adds access control to this table. Used only when the target database is Db2. \n+\n+**Line 15.** Fluent pattern - builds the immutable `Table` object. The model is passed as a parameter to permit some integrity checking, helping to ensure that the resulting object is valid before it is applied to any database.\n+\n+**Line 17.** Adds this table as a dependency for the stored procedures. To keep things simple, we say that all tables must be complete before any stored procedures are processed.\n+\n+**Line 18.** Adds this object as a table to the `PhysicalDataModel`. The set of tables are used to perform lookups when foreign key relationships are added.\n+\n+**Line 19.** Adds this object to the full list of objects in the `PhysicalDataModel`.\n+\n+There is room for improvement in the design around how objects are added to the model. The need to make two calls (addTable and addObject) is cumbersome and potentially error-prone.\n+\n+Note that the object being built is a subclass of VersionedSchemaObject which assigned a version id of 1 for the initial creation of an object. Note that version numbers are tracked at the object level, not globally. This makes it far easier to manage changes to a given object.\n+\n+\n+### Schema Migration and Versioning\n+\n+The VERSION_HISTORY table is used to record the logical schema version number of every object in the FHIR data schema. This history information is used to determine which deltas to apply to migrate the schema to the latest version. When schema changes are applied, the VERSION_HISTORY table is updated to reflect the latest version number of a particular object. The next time the schema update is run, this table is read, and only changes with a greater version number than the value recorded in the VERSION_HISTORY table are applied for a given object.\n+\n+NOTE: Schema changes must always be carefully considered and in an ideal world are backward compatible - this is important when needing to roll back a change. Rolling back application code changes is as simple as deploying an older version, but rolling back a database change is often impossible. Designing in backward compatibility is tricky to do in practice, but should be considered for each change, especially if continuous availability is a goal.\n+\n+The DDL for most objects (like tables) is specified once. Changes to the table structure are applied as alter statements and assigned an increasing version id. We use a simple version number tracking to identify which changes (deltas) need to be applied to a particular object.\n+\n+The schema update utility first reads the VERSION_HISTORY table, loading all records for the target schema (e.g. FHIRDATA). The utility only applies changes which have a version number greater than the currently recorded version. Once the DDL has been applied successfully, the version number is updated in VERSION_HISTORY. This makes the processed idempotent. Subsequent runs of the schema update utility only apply changes which have a greater version id value than the most recently stored value for each object.\n+\n+Enhancements to schema migration handling are tracked in [issue-1163](https://github.com/IBM/FHIR/issues/1163).\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "originalPosition": 144}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMDUzMDg5", "url": "https://github.com/IBM/FHIR/pull/1165#pullrequestreview-421053089", "createdAt": "2020-05-29T15:21:03Z", "commit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNToyMTowM1rOGchSdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNToyMTowM1rOGchSdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU1ODcwOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The IBM FHIR Server persists resources using tables defined in a data schema (usually FHIRDATA, but this can be anything). Multiple data schemas can exist in the same database, all managed from a single FHIR_ADMIN schema.\n          \n          \n            \n            The IBM FHIR Server persists resources using tables defined in a data schema (usually FHIRDATA). Multiple data schemas can exist in the same database, all managed from a single FHIR_ADMIN schema.", "url": "https://github.com/IBM/FHIR/pull/1165#discussion_r432558708", "createdAt": "2020-05-29T15:21:03Z", "author": {"login": "prb112"}, "path": "fhir-persistence-schema/docs/SchemaMigration.md", "diffHunk": "@@ -0,0 +1,407 @@\n+# The IBM FHIR Server - Schema Design and Management\n+\n+This document details the IBM FHIR Server schema design and how schema changes are managed. There are differences among the databases currently supported, most notably with Db2 which uses additional database capabilities to support multi-tenancy. Details of the multi-tenant design can be found [here](DB2MultiTenancy.md). Other variations across databases are discussed in this document.\n+\n+Currently it is not possible to deploy the simplified single-tenant variant of the schema to Db2. GitHub [issue-840](https://github.com/IBM/FHIR/issues/840) has been opened to address this. \n+\n+\n+There are three core projects which are referenced: \n+\n+| Project | Description |\n+|----------|---------------------------------------------|\n+| `fhir-model` | The HL7 FHIR model - generated Java code |\n+| `fhir-database-utils` | The SQL/database constructs used to create SQL compliant statements |\n+| `fhir-persistence-schema` | Uses database-utils to define a physical data model for storing FHIR resources and supporting the FHIR API |\n+\n+The schema generates the following object types that require management: \n+\n+- DB2 PACKAGE\n+- TABLESPACES\n+- SCHEMA \n+- GLOBAL VARIABLE \n+- INDEX \n+- PERMISSION \n+- PROCEDURE \n+- SEQUENCE \n+- TABLE\n+- TABLE CONSTRAINT \n+\n+----------------------------------------------------------------\n+# Database Support\n+\n+\n+| Database   | Version   | Support |\n+|------------|-----------|-----------------------------------|\n+| DB2        |      11.5 | Suitable for production. Supports multi-tenancy. |\n+| PostgreSQL |        12 | Experimental. Single tenant per database. |\n+| Derby      | 10.14.2.0 | Development only. Single tenant per database |\n+\n+\n+----------------------------------------------------------------\n+# Overview and Concepts\n+\n+The IBM FHIR schema is managed in code and is applied to a target database using a JDBC connection. This simplifies development of Derby-based unit-tests, allows a common schema definition to be used across multiple database flavors, simplifies deployment in cloud scenarios, and because the data model dependencies are understood by the code, the schema creation process can be parallelized to reduce deployment times. In practice, however, we've found that the number of threads must be limited due to driving contention in the internal catalog tables (in DB2, for example). We have also found that some parallel object create operations cause internal database deadlocks (notably creating foreign key relationships). The implementation contains a retry loop, but may fail if the retry limit is exceeded. Note that these deadlocks are internal to Db2, not the more common kind typically caused by poor application code.\n+\n+The `FHIR_ADMIN` schema is used to manage meta-data related to the actual data schemas. A single database instance can be used to support multiple FHIR data schemas, as long as the FHIR_ADMIN schema structure doesn't change. At the time of writing, the IBM FHIR Server does not support more than one FHIR_ADMIN schema in a single database. If a use-case arises where this is required, it is simply a matter of identifying in code where FHIR_ADMIN is used as a constant and replacing instances with a configurable property, although an implementation may also want to consider protecting individual schemas from accidentally being managed by more than one FHIR_ADMIN schema. One possible use-case for this sharing is using a database instance for schema development work, although use of the Db2 docker container makes this moot.\n+\n+The `FHIR_ADMIN` schema also plays an important role in managing tenants in the Db2 multi-tenant implementation. See the [Db2 Multi-Tenant Schema Design](DB2MultiTenancy.md) for more details.\n+\n+\n+## Differences Among Database Implementations\n+\n+The following table highlights the main differences among the database implementations currently supported:\n+\n+| Database   | Variation |\n+| --------   | ----------|\n+| DB2        | Multi-tenant. Supports multiple but isolated tenants within one database/schema |\n+| DB2        | An SPL stored procedure is used to implement the resource storage logic, reducing the number of application server to database round-trips, improving performance |\n+| DB2        | Uses `FHIR_TS` tablespace for admin tables, and a tablespace per tenant |\n+| DB2        | `FHIR_TS` is created using a small extent size for efficiency |\n+| PostgreSQL | Based on the Derby implementation, but uses a stored procedure for the resource persistence logic, like DB2 |\n+| PostgreSQL | TEXT type used instead of CLOB for large data values |\n+| Derby      | Resource persistence is implemented at the DAO layer as a sequence of individual statements instead of one procedure call. At a functional level, the process is identical. Simplifies debugging and supports easier unit-test construction. |\n+\n+\n+----------------------------------------------------------------\n+# Schema Management\n+\n+Use of the schema management tool is described [here](https://github.com/IBM/FHIR/tree/master/fhir-persistence-schema/README.md).\n+\n+The schema is managed using the class `com.ibm.fhir.schema.app.Main`. The `Main` class uses `FhirSchemaGenerator` to build a `PhysicalDataModel` which represents the schema as a Java data structure. This schema model is then applied to a database using an implementation of `IDatabaseAdapter` specific to the target database type (Derby, PostgreSQL or DB2). The adapter implements calls such as `createTable` and constructs the DDL statement appropriate for the target database. In some cases where the object type is not supported or not required for the given target database, the adapter can simply perform no operation (NOP).\n+\n+The code models dependencies among the various objects such as foreign key relationships between tables. Others relationships are marked explicitly, such as stored procedure dependency on tables. To keep things simple, there are some `NopObject` markers used as a barrier during parallel deployment. This barrier is used to collect together a lot of dependencies into one place, allowing subsequent operations to just depend on the barrier object instead of each having to individually express a dependency to lots of objects.\n+\n+The following example shows how we define a table in the schema. In this case, we are creating the global logical resources table (which is not resource-type specific):\n+\n+```java\n+ 1    public void addLogicalResources(PhysicalDataModel pdm) {\n+ 2       final String tableName = LOGICAL_RESOURCES;\n+ 3\n+ 4       Table tbl = Table.builder(schemaName, tableName)\n+ 5               .setTenantColumnName(MT_ID)\n+ 6               .addBigIntColumn(LOGICAL_RESOURCE_ID, false)\n+ 7               .addIntColumn(RESOURCE_TYPE_ID, false)\n+ 8               .addVarcharColumn(LOGICAL_ID, LOGICAL_ID_BYTES, false)\n+ 9               .addPrimaryKey(tableName + \"_PK\", LOGICAL_RESOURCE_ID)\n+10                .addUniqueIndex(\"UNQ_\" + LOGICAL_RESOURCES, RESOURCE_TYPE_ID, LOGICAL_ID)\n+11                .setTablespace(fhirTablespace)\n+12                .addPrivileges(resourceTablePrivileges)\n+13                .addForeignKeyConstraint(FK + tableName + \"_RTID\", schemaName, RESOURCE_TYPES, RESOURCE_TYPE_ID)\n+14                .enableAccessControl(this.sessionVariable)\n+15                .build(pdm);\n+\n+16        tbl.addTag(SCHEMA_GROUP_TAG, FHIRDATA_GROUP);\n+17        this.procedureDependencies.add(tbl);\n+18        pdm.addTable(tbl);\n+19        pdm.addObject(tbl);\n+20    }\n+```\n+\n+Notes:\n+\n+**Line 4.** Database objects are created using the fluent builder pattern to create an immutable definition.\n+\n+**Line 5.** MT_ID is used as the tenant column. The tenant column is handled as an explicit property (rather than just addIntColumn) because it allows us to ignore it later depending on the database target the model is being applied to. Currenly only Db2 supports our multi-tenant design.\n+\n+**Line 6.** Adds a column to table definition.\n+\n+**Line 9.** Specifies the primary key. The columns in the PK definition must be added before addPrimaryKey is called.\n+\n+**Line 10.** Adds a unique index to the table.\n+\n+**Line 11.** Identifies the tablespace to be used for this table. All tables are created in a specific tablespace `FHIR_TS` created with a smaller than typical extent size. The model contains a large number of tables and indexes, and in the multi-tenant schema, the initial table/partition never holds any data. Using a smaller extent size significantly improves schema deployment time because the database has to allocate fewer pages for each object, and this also reduces waste from allocating space that would never be used.\n+\n+**Line 12.** Adds the list of privileges that need to be applied to this table.\n+\n+**Line 13.** Adds a foreign key relationship to a target table, which is RESOURCE_TYPES in this case.\n+\n+**Line 14.** Adds access control to this table. Used only when the target database is Db2. \n+\n+**Line 15.** Fluent pattern - builds the immutable `Table` object. The model is passed as a parameter to permit some integrity checking, helping to ensure that the resulting object is valid before it is applied to any database.\n+\n+**Line 17.** Adds this table as a dependency for the stored procedures. To keep things simple, we say that all tables must be complete before any stored procedures are processed.\n+\n+**Line 18.** Adds this object as a table to the `PhysicalDataModel`. The set of tables are used to perform lookups when foreign key relationships are added.\n+\n+**Line 19.** Adds this object to the full list of objects in the `PhysicalDataModel`.\n+\n+There is room for improvement in the design around how objects are added to the model. The need to make two calls (addTable and addObject) is cumbersome and potentially error-prone.\n+\n+Note that the object being built is a subclass of VersionedSchemaObject which assigned a version id of 1 for the initial creation of an object. Note that version numbers are tracked at the object level, not globally. This makes it far easier to manage changes to a given object.\n+\n+\n+### Schema Migration and Versioning\n+\n+The VERSION_HISTORY table is used to record the logical schema version number of every object in the FHIR data schema. This history information is used to determine which deltas to apply to migrate the schema to the latest version. When schema changes are applied, the VERSION_HISTORY table is updated to reflect the latest version number of a particular object. The next time the schema update is run, this table is read, and only changes with a greater version number than the value recorded in the VERSION_HISTORY table are applied for a given object.\n+\n+NOTE: Schema changes must always be carefully considered and in an ideal world are backward compatible - this is important when needing to roll back a change. Rolling back application code changes is as simple as deploying an older version, but rolling back a database change is often impossible. Designing in backward compatibility is tricky to do in practice, but should be considered for each change, especially if continuous availability is a goal.\n+\n+The DDL for most objects (like tables) is specified once. Changes to the table structure are applied as alter statements and assigned an increasing version id. We use a simple version number tracking to identify which changes (deltas) need to be applied to a particular object.\n+\n+The schema update utility first reads the VERSION_HISTORY table, loading all records for the target schema (e.g. FHIRDATA). The utility only applies changes which have a version number greater than the currently recorded version. Once the DDL has been applied successfully, the version number is updated in VERSION_HISTORY. This makes the processed idempotent. Subsequent runs of the schema update utility only apply changes which have a greater version id value than the most recently stored value for each object.\n+\n+Enhancements to schema migration handling are tracked in [issue-1163](https://github.com/IBM/FHIR/issues/1163).\n+\n+\n+## TABLESPACES\n+\n+The Db2 multi-tenant schema variant uses a tablespace per tenant. All other database implementations use the default tablespace.\n+\n+\n+----------------------------------------------------------------\n+## Schema: FHIR_ADMIN\n+\n+The Schema FHIR_ADMIN is deployed once per database and contains tables used to manage schema version history and tenant access (in the case of a multi-tenant supported configuration). The schema contains 3 tables:\n+\n+| Object | Notes | Purpose |\n+| ----- | ----- | ------- |\n+| VERSION_HISTORY | | Table used to track the schema version number for each of the managed objects in the data schema (usually FHIRDATA) |\n+| TENANTS | Db2 only | Table for mapping between tenant name and the tenant id used to isolate the tenant's data in the data schema |\n+| TENANT_KEYS | Db2 only | Authorization keys allocated to a given given. A tenant can have multiple valid keys at any point in time to support rolling key changes (add new before remove old).\n+| TENANT_SEQUENCE | Db2 only | Sequence used to provide unique mt_id values for allocated tenants |\n+| SET_TENANT | Db2 only | Stored procedure. The only way for FHIRUSER to set the value of the SV_TENANT_ID session variable.\n+\n+\n+These table definitions are more completely described in [DB2MultiTenancy.md](DB2MultiTenancy.md). \n+\n+\n+----------------------------------------------------------------\n+\n+# Schema: FHIR Resource Data \n+\n+The IBM FHIR Server persists resources using tables defined in a data schema (usually FHIRDATA, but this can be anything). Multiple data schemas can exist in the same database, all managed from a single FHIR_ADMIN schema.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "originalPosition": 172}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMDU0MTM1", "url": "https://github.com/IBM/FHIR/pull/1165#pullrequestreview-421054135", "createdAt": "2020-05-29T15:22:19Z", "commit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNToyMjoxOVrOGchViw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNToyMjoxOVrOGchViw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU1OTQ5OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The `FHIR_ADMIN` schema is used to manage meta-data related to the actual data schemas. A single database instance can be used to support multiple FHIR data schemas, as long as the FHIR_ADMIN schema structure doesn't change. At the time of writing, the IBM FHIR Server does not support more than one FHIR_ADMIN schema in a single database. If a use-case arises where this is required, it is simply a matter of identifying in code where FHIR_ADMIN is used as a constant and replacing instances with a configurable property, although an implementation may also want to consider protecting individual schemas from accidentally being managed by more than one FHIR_ADMIN schema. One possible use-case for this sharing is using a database instance for schema development work, although use of the Db2 docker container makes this moot.\n          \n          \n            \n            The `FHIR_ADMIN` schema is used to manage meta-data related to the actual data schemas. A single database instance can be used to support multiple FHIR data schemas, as long as the FHIR_ADMIN schema structure doesn't change. At the time of writing, the IBM FHIR Server does not support more than one FHIR_ADMIN schema in a single database. If a use-case arises where this is required, it is simply a matter of identifying in code where FHIR_ADMIN is used as a constant and replacing instances with a configurable property, although an implementation may also want to consider protecting individual schemas from accidentally being managed by more than one FHIR_ADMIN schema. One possible use-case for this sharing is using a database instance for schema development work.", "url": "https://github.com/IBM/FHIR/pull/1165#discussion_r432559499", "createdAt": "2020-05-29T15:22:19Z", "author": {"login": "prb112"}, "path": "fhir-persistence-schema/docs/SchemaMigration.md", "diffHunk": "@@ -0,0 +1,407 @@\n+# The IBM FHIR Server - Schema Design and Management\n+\n+This document details the IBM FHIR Server schema design and how schema changes are managed. There are differences among the databases currently supported, most notably with Db2 which uses additional database capabilities to support multi-tenancy. Details of the multi-tenant design can be found [here](DB2MultiTenancy.md). Other variations across databases are discussed in this document.\n+\n+Currently it is not possible to deploy the simplified single-tenant variant of the schema to Db2. GitHub [issue-840](https://github.com/IBM/FHIR/issues/840) has been opened to address this. \n+\n+\n+There are three core projects which are referenced: \n+\n+| Project | Description |\n+|----------|---------------------------------------------|\n+| `fhir-model` | The HL7 FHIR model - generated Java code |\n+| `fhir-database-utils` | The SQL/database constructs used to create SQL compliant statements |\n+| `fhir-persistence-schema` | Uses database-utils to define a physical data model for storing FHIR resources and supporting the FHIR API |\n+\n+The schema generates the following object types that require management: \n+\n+- DB2 PACKAGE\n+- TABLESPACES\n+- SCHEMA \n+- GLOBAL VARIABLE \n+- INDEX \n+- PERMISSION \n+- PROCEDURE \n+- SEQUENCE \n+- TABLE\n+- TABLE CONSTRAINT \n+\n+----------------------------------------------------------------\n+# Database Support\n+\n+\n+| Database   | Version   | Support |\n+|------------|-----------|-----------------------------------|\n+| DB2        |      11.5 | Suitable for production. Supports multi-tenancy. |\n+| PostgreSQL |        12 | Experimental. Single tenant per database. |\n+| Derby      | 10.14.2.0 | Development only. Single tenant per database |\n+\n+\n+----------------------------------------------------------------\n+# Overview and Concepts\n+\n+The IBM FHIR schema is managed in code and is applied to a target database using a JDBC connection. This simplifies development of Derby-based unit-tests, allows a common schema definition to be used across multiple database flavors, simplifies deployment in cloud scenarios, and because the data model dependencies are understood by the code, the schema creation process can be parallelized to reduce deployment times. In practice, however, we've found that the number of threads must be limited due to driving contention in the internal catalog tables (in DB2, for example). We have also found that some parallel object create operations cause internal database deadlocks (notably creating foreign key relationships). The implementation contains a retry loop, but may fail if the retry limit is exceeded. Note that these deadlocks are internal to Db2, not the more common kind typically caused by poor application code.\n+\n+The `FHIR_ADMIN` schema is used to manage meta-data related to the actual data schemas. A single database instance can be used to support multiple FHIR data schemas, as long as the FHIR_ADMIN schema structure doesn't change. At the time of writing, the IBM FHIR Server does not support more than one FHIR_ADMIN schema in a single database. If a use-case arises where this is required, it is simply a matter of identifying in code where FHIR_ADMIN is used as a constant and replacing instances with a configurable property, although an implementation may also want to consider protecting individual schemas from accidentally being managed by more than one FHIR_ADMIN schema. One possible use-case for this sharing is using a database instance for schema development work, although use of the Db2 docker container makes this moot.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d64a020461f256ceecdbcf231fd4a06e9e9aa2e"}, "originalPosition": 45}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d94ed1107c4dc3dea36d202d0ecd0469841e922", "author": {"user": {"login": "punktilious", "name": "Robin Arnold"}}, "url": "https://github.com/IBM/FHIR/commit/0d94ed1107c4dc3dea36d202d0ecd0469841e922", "committedDate": "2020-05-29T20:21:29Z", "message": "Update fhir-persistence-schema/docs/DB2MultiTenancy.md\n\nCo-authored-by: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Paul Bastide <pbastide@us.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9355ee6cbec878b8b4907a32b81e37248b44be91", "author": {"user": {"login": "punktilious", "name": "Robin Arnold"}}, "url": "https://github.com/IBM/FHIR/commit/9355ee6cbec878b8b4907a32b81e37248b44be91", "committedDate": "2020-05-29T20:17:24Z", "message": "Update fhir-persistence-schema/docs/DB2MultiTenancy.md\n\nCo-authored-by: Paul Bastide <pbastide@us.ibm.com>"}, "afterCommit": {"oid": "0d94ed1107c4dc3dea36d202d0ecd0469841e922", "author": {"user": {"login": "punktilious", "name": "Robin Arnold"}}, "url": "https://github.com/IBM/FHIR/commit/0d94ed1107c4dc3dea36d202d0ecd0469841e922", "committedDate": "2020-05-29T20:21:29Z", "message": "Update fhir-persistence-schema/docs/DB2MultiTenancy.md\n\nCo-authored-by: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Paul Bastide <pbastide@us.ibm.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4MDAyMTg4", "url": "https://github.com/IBM/FHIR/pull/1165#pullrequestreview-478002188", "createdAt": "2020-08-28T20:18:06Z", "commit": {"oid": "0d94ed1107c4dc3dea36d202d0ecd0469841e922"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d3b2d6d84815a79ec20036d86f9c3d7ccd36dec1", "author": {"user": {"login": "punktilious", "name": "Robin Arnold"}}, "url": "https://github.com/IBM/FHIR/commit/d3b2d6d84815a79ec20036d86f9c3d7ccd36dec1", "committedDate": "2020-08-29T02:13:26Z", "message": "issue-1132 addressed review comments from Paul\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 253, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}