{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgyMDkzNzk3", "number": 1486, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNDo1OTozNFrOEhShIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNToyNjoyM1rOEhTPRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMzQxODU4OnYy", "diffSide": "RIGHT", "path": "fhir-search/src/test/java/com/ibm/fhir/search/test/InclusionParameterParseTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNDo1OTozNFrOHOhbmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMToxMTowNlrOHOuJ2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk4OTg1MA==", "bodyText": "Update Copyright please ,2020", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r484989850", "createdAt": "2020-09-08T14:59:34Z", "author": {"login": "prb112"}, "path": "fhir-search/src/test/java/com/ibm/fhir/search/test/InclusionParameterParseTest.java", "diffHunk": "@@ -20,9 +20,12 @@\n \n import org.testng.annotations.Test;\n \n+import com.ibm.fhir.model.resource.Condition;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b32bd572f29429d86f9b80ce874cf041332dbc9"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE5ODI5OQ==", "bodyText": "Fixed.", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r485198299", "createdAt": "2020-09-08T21:11:06Z", "author": {"login": "michaelwschroeder"}, "path": "fhir-search/src/test/java/com/ibm/fhir/search/test/InclusionParameterParseTest.java", "diffHunk": "@@ -20,9 +20,12 @@\n \n import org.testng.annotations.Test;\n \n+import com.ibm.fhir.model.resource.Condition;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk4OTg1MA=="}, "originalCommit": {"oid": "8b32bd572f29429d86f9b80ce874cf041332dbc9"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMzQzNjkwOnYy", "diffSide": "RIGHT", "path": "fhir-search/src/test/java/com/ibm/fhir/search/test/InclusionParameterParseTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNTowMzozNVrOHOhm4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMToxMToyNlrOHOuKhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk5MjczNw==", "bodyText": "Having an integration test in SearchTest.java in fhir-server-test would be ideal.   And include a test with Provenance.target which is a reference to Any FHIR Resource", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r484992737", "createdAt": "2020-09-08T15:03:35Z", "author": {"login": "prb112"}, "path": "fhir-search/src/test/java/com/ibm/fhir/search/test/InclusionParameterParseTest.java", "diffHunk": "@@ -327,4 +340,151 @@ public void testMultiIncludeRevinclude() throws Exception {\n         assertTrue(selfUri.contains(include4));\n     }\n \n+    @Test\n+    public void testWildcardIncludeNoMatchingTargetType() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Patient> resourceType = Patient.class;\n+\n+        queryParameters.put(\"_include\", Collections.singletonList(\"Patient:*:Medication\"));\n+        FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+\n+        assertNotNull(searchContext);\n+        assertFalse(searchContext.hasIncludeParameters());\n+        assertFalse(searchContext.hasRevIncludeParameters());\n+\n+        String selfUri = SearchUtil.buildSearchSelfUri(\"http://example.com/Patient\", searchContext);\n+        assertTrue(selfUri.equals(\"http://example.com/Patient?_count=10&_page=1\"));\n+    }\n+\n+    @Test\n+    public void testWildcardIncludeSingleMatchingTargetType() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Patient> resourceType = Patient.class;\n+\n+        queryParameters.put(\"_include\", Collections.singletonList(\"Patient:*:RelatedPerson\"));\n+        FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+\n+        assertNotNull(searchContext);\n+        assertTrue(searchContext.hasIncludeParameters());\n+        assertEquals(1, searchContext.getIncludeParameters().size());\n+        InclusionParameter incParm = searchContext.getIncludeParameters().get(0);\n+        assertEquals(\"Patient\", incParm.getJoinResourceType());\n+        assertEquals(\"link\", incParm.getSearchParameter());\n+        assertEquals(\"RelatedPerson\", incParm.getSearchParameterTargetType());\n+        assertFalse(searchContext.hasRevIncludeParameters());\n+\n+        String selfUri = SearchUtil.buildSearchSelfUri(\"http://example.com/Patient\", searchContext);\n+        assertTrue(selfUri.equals(\"http://example.com/Patient?_count=10&_include=\" + incParm.getJoinResourceType() +\n+            \":\" + incParm.getSearchParameter() + \":\" + incParm.getSearchParameterTargetType() + \"&_page=1\"));\n+    }\n+\n+    @Test\n+    public void testWildcardIncludeNoTargetType() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Patient> resourceType = Patient.class;\n+        String include1 = \"&_include=Patient:general-practitioner:Organization\";\n+        String include2 = \"&_include=Patient:general-practitioner:Practitioner\";\n+        String include3 = \"&_include=Patient:general-practitioner:PractitionerRole\";\n+        String include4 = \"&_include=Patient:organization:Organization\";\n+        String include5 = \"&_include=Patient:link:Patient\";\n+        String include6 = \"&_include=Patient:link:RelatedPerson\";\n+\n+        List<InclusionParameter> expectedIncludeParms = new ArrayList<>();\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"general-practitioner\", \"Organization\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"general-practitioner\", \"Practitioner\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"general-practitioner\", \"PractitionerRole\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"organization\", \"Organization\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"link\", \"Patient\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"link\", \"RelatedPerson\"));\n+\n+        queryParameters.put(\"_include\", Collections.singletonList(\"Patient:*\"));\n+        FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+\n+        assertNotNull(searchContext);\n+        assertTrue(searchContext.hasIncludeParameters());\n+        assertEquals(expectedIncludeParms.size(), searchContext.getIncludeParameters().size());\n+        for (InclusionParameter includeParm : expectedIncludeParms) {\n+            assertTrue(expectedIncludeParms.contains(includeParm));\n+        }\n+\n+        assertFalse(searchContext.hasRevIncludeParameters());\n+\n+        String selfUri = SearchUtil.buildSearchSelfUri(\"http://example.com/Patient\", searchContext);\n+        assertTrue(selfUri.contains(include1));\n+        assertTrue(selfUri.contains(include2));\n+        assertTrue(selfUri.contains(include3));\n+        assertTrue(selfUri.contains(include4));\n+        assertTrue(selfUri.contains(include5));\n+        assertTrue(selfUri.contains(include6));\n+    }\n+\n+    @Test\n+    public void testWildcardRevIncludeNoMatchingTargetType() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Condition> resourceType = Condition.class;\n+\n+        queryParameters.put(\"_revinclude\", Collections.singletonList(\"Patient:*:Condition\"));\n+        FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+\n+        assertNotNull(searchContext);\n+        assertFalse(searchContext.hasIncludeParameters());\n+        assertFalse(searchContext.hasRevIncludeParameters());\n+\n+        String selfUri = SearchUtil.buildSearchSelfUri(\"http://example.com/Condition\", searchContext);\n+        assertTrue(selfUri.equals(\"http://example.com/Condition?_count=10&_page=1\"));\n+    }\n+\n+    @Test\n+    public void testWildcardRevIncludeSingleMatchingTargetType() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Encounter> resourceType = Encounter.class;\n+\n+        queryParameters.put(\"_revinclude\", Collections.singletonList(\"MedicationAdministration:*:Encounter\"));\n+        FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+\n+        assertNotNull(searchContext);\n+        assertTrue(searchContext.hasRevIncludeParameters());\n+        assertEquals(1, searchContext.getRevIncludeParameters().size());\n+        InclusionParameter incParm = searchContext.getRevIncludeParameters().get(0);\n+        assertEquals(\"MedicationAdministration\", incParm.getJoinResourceType());\n+        assertEquals(\"context\", incParm.getSearchParameter());\n+        assertEquals(\"Encounter\", incParm.getSearchParameterTargetType());\n+        assertFalse(searchContext.hasIncludeParameters());\n+\n+        String selfUri = SearchUtil.buildSearchSelfUri(\"http://example.com/Encounter\", searchContext);\n+        assertTrue(selfUri.equals(\"http://example.com/Encounter?_count=10&_revinclude=\" + incParm.getJoinResourceType() +\n+            \":\" + incParm.getSearchParameter() + \":\" + incParm.getSearchParameterTargetType() + \"&_page=1\"));\n+    }\n+\n+    @Test\n+    public void testWildcardRevIncludeNoTargetType() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Patient> resourceType = Patient.class;\n+        String include1 = \"&_revinclude=Procedure:patient:Patient\";\n+        String include2 = \"&_revinclude=Procedure:performer:Patient\";\n+        String include3 = \"&_revinclude=Procedure:subject:Patient\";\n+\n+        List<InclusionParameter> expectedIncludeParms = new ArrayList<>();\n+        expectedIncludeParms.add(new InclusionParameter(\"Procedure\", \"patient\", \"Patient\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Procedure\", \"performer\", \"Patient\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Procedure\", \"subject\", \"Patient\"));\n+\n+        queryParameters.put(\"_revinclude\", Collections.singletonList(\"Procedure:*\"));\n+        FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+\n+        assertNotNull(searchContext);\n+        assertTrue(searchContext.hasRevIncludeParameters());\n+        assertEquals(expectedIncludeParms.size(), searchContext.getRevIncludeParameters().size());\n+        for (InclusionParameter includeParm : expectedIncludeParms) {\n+            assertTrue(expectedIncludeParms.contains(includeParm));\n+        }\n+\n+        assertFalse(searchContext.hasIncludeParameters());\n+\n+        String selfUri = SearchUtil.buildSearchSelfUri(\"http://example.com/Patient\", searchContext);\n+        assertTrue(selfUri.contains(include1));\n+        assertTrue(selfUri.contains(include2));\n+        assertTrue(selfUri.contains(include3));\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b32bd572f29429d86f9b80ce874cf041332dbc9"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE5ODQ2OQ==", "bodyText": "Test added.", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r485198469", "createdAt": "2020-09-08T21:11:26Z", "author": {"login": "michaelwschroeder"}, "path": "fhir-search/src/test/java/com/ibm/fhir/search/test/InclusionParameterParseTest.java", "diffHunk": "@@ -327,4 +340,151 @@ public void testMultiIncludeRevinclude() throws Exception {\n         assertTrue(selfUri.contains(include4));\n     }\n \n+    @Test\n+    public void testWildcardIncludeNoMatchingTargetType() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Patient> resourceType = Patient.class;\n+\n+        queryParameters.put(\"_include\", Collections.singletonList(\"Patient:*:Medication\"));\n+        FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+\n+        assertNotNull(searchContext);\n+        assertFalse(searchContext.hasIncludeParameters());\n+        assertFalse(searchContext.hasRevIncludeParameters());\n+\n+        String selfUri = SearchUtil.buildSearchSelfUri(\"http://example.com/Patient\", searchContext);\n+        assertTrue(selfUri.equals(\"http://example.com/Patient?_count=10&_page=1\"));\n+    }\n+\n+    @Test\n+    public void testWildcardIncludeSingleMatchingTargetType() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Patient> resourceType = Patient.class;\n+\n+        queryParameters.put(\"_include\", Collections.singletonList(\"Patient:*:RelatedPerson\"));\n+        FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+\n+        assertNotNull(searchContext);\n+        assertTrue(searchContext.hasIncludeParameters());\n+        assertEquals(1, searchContext.getIncludeParameters().size());\n+        InclusionParameter incParm = searchContext.getIncludeParameters().get(0);\n+        assertEquals(\"Patient\", incParm.getJoinResourceType());\n+        assertEquals(\"link\", incParm.getSearchParameter());\n+        assertEquals(\"RelatedPerson\", incParm.getSearchParameterTargetType());\n+        assertFalse(searchContext.hasRevIncludeParameters());\n+\n+        String selfUri = SearchUtil.buildSearchSelfUri(\"http://example.com/Patient\", searchContext);\n+        assertTrue(selfUri.equals(\"http://example.com/Patient?_count=10&_include=\" + incParm.getJoinResourceType() +\n+            \":\" + incParm.getSearchParameter() + \":\" + incParm.getSearchParameterTargetType() + \"&_page=1\"));\n+    }\n+\n+    @Test\n+    public void testWildcardIncludeNoTargetType() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Patient> resourceType = Patient.class;\n+        String include1 = \"&_include=Patient:general-practitioner:Organization\";\n+        String include2 = \"&_include=Patient:general-practitioner:Practitioner\";\n+        String include3 = \"&_include=Patient:general-practitioner:PractitionerRole\";\n+        String include4 = \"&_include=Patient:organization:Organization\";\n+        String include5 = \"&_include=Patient:link:Patient\";\n+        String include6 = \"&_include=Patient:link:RelatedPerson\";\n+\n+        List<InclusionParameter> expectedIncludeParms = new ArrayList<>();\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"general-practitioner\", \"Organization\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"general-practitioner\", \"Practitioner\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"general-practitioner\", \"PractitionerRole\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"organization\", \"Organization\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"link\", \"Patient\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"link\", \"RelatedPerson\"));\n+\n+        queryParameters.put(\"_include\", Collections.singletonList(\"Patient:*\"));\n+        FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+\n+        assertNotNull(searchContext);\n+        assertTrue(searchContext.hasIncludeParameters());\n+        assertEquals(expectedIncludeParms.size(), searchContext.getIncludeParameters().size());\n+        for (InclusionParameter includeParm : expectedIncludeParms) {\n+            assertTrue(expectedIncludeParms.contains(includeParm));\n+        }\n+\n+        assertFalse(searchContext.hasRevIncludeParameters());\n+\n+        String selfUri = SearchUtil.buildSearchSelfUri(\"http://example.com/Patient\", searchContext);\n+        assertTrue(selfUri.contains(include1));\n+        assertTrue(selfUri.contains(include2));\n+        assertTrue(selfUri.contains(include3));\n+        assertTrue(selfUri.contains(include4));\n+        assertTrue(selfUri.contains(include5));\n+        assertTrue(selfUri.contains(include6));\n+    }\n+\n+    @Test\n+    public void testWildcardRevIncludeNoMatchingTargetType() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Condition> resourceType = Condition.class;\n+\n+        queryParameters.put(\"_revinclude\", Collections.singletonList(\"Patient:*:Condition\"));\n+        FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+\n+        assertNotNull(searchContext);\n+        assertFalse(searchContext.hasIncludeParameters());\n+        assertFalse(searchContext.hasRevIncludeParameters());\n+\n+        String selfUri = SearchUtil.buildSearchSelfUri(\"http://example.com/Condition\", searchContext);\n+        assertTrue(selfUri.equals(\"http://example.com/Condition?_count=10&_page=1\"));\n+    }\n+\n+    @Test\n+    public void testWildcardRevIncludeSingleMatchingTargetType() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Encounter> resourceType = Encounter.class;\n+\n+        queryParameters.put(\"_revinclude\", Collections.singletonList(\"MedicationAdministration:*:Encounter\"));\n+        FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+\n+        assertNotNull(searchContext);\n+        assertTrue(searchContext.hasRevIncludeParameters());\n+        assertEquals(1, searchContext.getRevIncludeParameters().size());\n+        InclusionParameter incParm = searchContext.getRevIncludeParameters().get(0);\n+        assertEquals(\"MedicationAdministration\", incParm.getJoinResourceType());\n+        assertEquals(\"context\", incParm.getSearchParameter());\n+        assertEquals(\"Encounter\", incParm.getSearchParameterTargetType());\n+        assertFalse(searchContext.hasIncludeParameters());\n+\n+        String selfUri = SearchUtil.buildSearchSelfUri(\"http://example.com/Encounter\", searchContext);\n+        assertTrue(selfUri.equals(\"http://example.com/Encounter?_count=10&_revinclude=\" + incParm.getJoinResourceType() +\n+            \":\" + incParm.getSearchParameter() + \":\" + incParm.getSearchParameterTargetType() + \"&_page=1\"));\n+    }\n+\n+    @Test\n+    public void testWildcardRevIncludeNoTargetType() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Patient> resourceType = Patient.class;\n+        String include1 = \"&_revinclude=Procedure:patient:Patient\";\n+        String include2 = \"&_revinclude=Procedure:performer:Patient\";\n+        String include3 = \"&_revinclude=Procedure:subject:Patient\";\n+\n+        List<InclusionParameter> expectedIncludeParms = new ArrayList<>();\n+        expectedIncludeParms.add(new InclusionParameter(\"Procedure\", \"patient\", \"Patient\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Procedure\", \"performer\", \"Patient\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Procedure\", \"subject\", \"Patient\"));\n+\n+        queryParameters.put(\"_revinclude\", Collections.singletonList(\"Procedure:*\"));\n+        FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+\n+        assertNotNull(searchContext);\n+        assertTrue(searchContext.hasRevIncludeParameters());\n+        assertEquals(expectedIncludeParms.size(), searchContext.getRevIncludeParameters().size());\n+        for (InclusionParameter includeParm : expectedIncludeParms) {\n+            assertTrue(expectedIncludeParms.contains(includeParm));\n+        }\n+\n+        assertFalse(searchContext.hasIncludeParameters());\n+\n+        String selfUri = SearchUtil.buildSearchSelfUri(\"http://example.com/Patient\", searchContext);\n+        assertTrue(selfUri.contains(include1));\n+        assertTrue(selfUri.contains(include2));\n+        assertTrue(selfUri.contains(include3));\n+    }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk5MjczNw=="}, "originalCommit": {"oid": "8b32bd572f29429d86f9b80ce874cf041332dbc9"}, "originalPosition": 182}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMzQ0MzY1OnYy", "diffSide": "RIGHT", "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNTowNTowN1rOHOhrHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMToxMTozOFrOHOuK4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk5MzgyMw==", "bodyText": "Looks like SearchParamType.REFERENCE.equals(...) could be done instead against \"reference\".  Same comment on line 1485.", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r484993823", "createdAt": "2020-09-08T15:05:07Z", "author": {"login": "tbieste"}, "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -502,6 +502,47 @@ private static SearchParameter getSearchParameterByUrlIfPresent(Map<String, Para\n         return result;\n     }\n \n+    /**\n+     * Perform wildcard processing for inclusion search parameters by getting all valid search parameters for the\n+     * specified join resource type. Search parameters must have a type of 'reference'.\n+     * <p>\n+     * If inclusion keyword is ' _include' and a target resource type is specified, search parameter must contain\n+     * a matching type.\n+     * <p>\n+     * If inclusion keyword is '_revinclude', search parameter must have a target resource type matching the resource\n+     * type being searched.\n+     * \n+     * @param resourceType\n+     *            the resource type being searched for\n+     * @param joinResourceType\n+     *            the resource type for which inclusion search parameters will be returned\n+     * @param searchParameterTargetType\n+     *            the target resource type for included resources\n+     * @param inclusionKeyword\n+     *            the inclusion type, either _include or _revinclude\n+     * @return\n+     *         the inclusion SearchParameters for type {@code resourceType} or empty map if none exist\n+     * @throws Exception\n+     */\n+    private static Map<String, SearchParameter> getInclusionWildcardSearchParameters(String resourceType, String joinResourceType,\n+        String searchParameterTargetType, String inclusionKeyword) throws Exception {\n+        Map<String, SearchParameter> inclusionSearchParameters = new HashMap<>();\n+\n+        for (SearchParameter searchParameter : getApplicableSearchParameters(joinResourceType)) {\n+            if (searchParameter.getType().getValue().equals(\"reference\") &&", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b32bd572f29429d86f9b80ce874cf041332dbc9"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE5ODU2Mw==", "bodyText": "Fixed.", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r485198563", "createdAt": "2020-09-08T21:11:38Z", "author": {"login": "michaelwschroeder"}, "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -502,6 +502,47 @@ private static SearchParameter getSearchParameterByUrlIfPresent(Map<String, Para\n         return result;\n     }\n \n+    /**\n+     * Perform wildcard processing for inclusion search parameters by getting all valid search parameters for the\n+     * specified join resource type. Search parameters must have a type of 'reference'.\n+     * <p>\n+     * If inclusion keyword is ' _include' and a target resource type is specified, search parameter must contain\n+     * a matching type.\n+     * <p>\n+     * If inclusion keyword is '_revinclude', search parameter must have a target resource type matching the resource\n+     * type being searched.\n+     * \n+     * @param resourceType\n+     *            the resource type being searched for\n+     * @param joinResourceType\n+     *            the resource type for which inclusion search parameters will be returned\n+     * @param searchParameterTargetType\n+     *            the target resource type for included resources\n+     * @param inclusionKeyword\n+     *            the inclusion type, either _include or _revinclude\n+     * @return\n+     *         the inclusion SearchParameters for type {@code resourceType} or empty map if none exist\n+     * @throws Exception\n+     */\n+    private static Map<String, SearchParameter> getInclusionWildcardSearchParameters(String resourceType, String joinResourceType,\n+        String searchParameterTargetType, String inclusionKeyword) throws Exception {\n+        Map<String, SearchParameter> inclusionSearchParameters = new HashMap<>();\n+\n+        for (SearchParameter searchParameter : getApplicableSearchParameters(joinResourceType)) {\n+            if (searchParameter.getType().getValue().equals(\"reference\") &&", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk5MzgyMw=="}, "originalCommit": {"oid": "8b32bd572f29429d86f9b80ce874cf041332dbc9"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMzQ0NTcyOnYy", "diffSide": "RIGHT", "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNTowNTozNlrOHOhsew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMToxMTo0OVrOHOuLPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk5NDE3MQ==", "bodyText": "Typo in word \"already\".", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r484994171", "createdAt": "2020-09-08T15:05:36Z", "author": {"login": "tbieste"}, "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -502,6 +502,47 @@ private static SearchParameter getSearchParameterByUrlIfPresent(Map<String, Para\n         return result;\n     }\n \n+    /**\n+     * Perform wildcard processing for inclusion search parameters by getting all valid search parameters for the\n+     * specified join resource type. Search parameters must have a type of 'reference'.\n+     * <p>\n+     * If inclusion keyword is ' _include' and a target resource type is specified, search parameter must contain\n+     * a matching type.\n+     * <p>\n+     * If inclusion keyword is '_revinclude', search parameter must have a target resource type matching the resource\n+     * type being searched.\n+     * \n+     * @param resourceType\n+     *            the resource type being searched for\n+     * @param joinResourceType\n+     *            the resource type for which inclusion search parameters will be returned\n+     * @param searchParameterTargetType\n+     *            the target resource type for included resources\n+     * @param inclusionKeyword\n+     *            the inclusion type, either _include or _revinclude\n+     * @return\n+     *         the inclusion SearchParameters for type {@code resourceType} or empty map if none exist\n+     * @throws Exception\n+     */\n+    private static Map<String, SearchParameter> getInclusionWildcardSearchParameters(String resourceType, String joinResourceType,\n+        String searchParameterTargetType, String inclusionKeyword) throws Exception {\n+        Map<String, SearchParameter> inclusionSearchParameters = new HashMap<>();\n+\n+        for (SearchParameter searchParameter : getApplicableSearchParameters(joinResourceType)) {\n+            if (searchParameter.getType().getValue().equals(\"reference\") &&\n+                    ((SearchConstants.INCLUDE.equals(inclusionKeyword)\n+                            && (searchParameterTargetType == null || isValidTargetType(searchParameterTargetType, searchParameter))) ||\n+                    (SearchConstants.REVINCLUDE.equals(inclusionKeyword) && isValidTargetType(resourceType, searchParameter)))) {\n+                // Valid search parameter of type reference - add to map\n+                inclusionSearchParameters.put(searchParameter.getCode().getValue(), searchParameter);\n+            } else if (inclusionSearchParameters.containsKey(searchParameter.getCode().getValue())) {\n+                // Search parameter is not valid - remove if search parameter by same name is alread in map", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b32bd572f29429d86f9b80ce874cf041332dbc9"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE5ODY1Mw==", "bodyText": "Fixed.", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r485198653", "createdAt": "2020-09-08T21:11:49Z", "author": {"login": "michaelwschroeder"}, "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -502,6 +502,47 @@ private static SearchParameter getSearchParameterByUrlIfPresent(Map<String, Para\n         return result;\n     }\n \n+    /**\n+     * Perform wildcard processing for inclusion search parameters by getting all valid search parameters for the\n+     * specified join resource type. Search parameters must have a type of 'reference'.\n+     * <p>\n+     * If inclusion keyword is ' _include' and a target resource type is specified, search parameter must contain\n+     * a matching type.\n+     * <p>\n+     * If inclusion keyword is '_revinclude', search parameter must have a target resource type matching the resource\n+     * type being searched.\n+     * \n+     * @param resourceType\n+     *            the resource type being searched for\n+     * @param joinResourceType\n+     *            the resource type for which inclusion search parameters will be returned\n+     * @param searchParameterTargetType\n+     *            the target resource type for included resources\n+     * @param inclusionKeyword\n+     *            the inclusion type, either _include or _revinclude\n+     * @return\n+     *         the inclusion SearchParameters for type {@code resourceType} or empty map if none exist\n+     * @throws Exception\n+     */\n+    private static Map<String, SearchParameter> getInclusionWildcardSearchParameters(String resourceType, String joinResourceType,\n+        String searchParameterTargetType, String inclusionKeyword) throws Exception {\n+        Map<String, SearchParameter> inclusionSearchParameters = new HashMap<>();\n+\n+        for (SearchParameter searchParameter : getApplicableSearchParameters(joinResourceType)) {\n+            if (searchParameter.getType().getValue().equals(\"reference\") &&\n+                    ((SearchConstants.INCLUDE.equals(inclusionKeyword)\n+                            && (searchParameterTargetType == null || isValidTargetType(searchParameterTargetType, searchParameter))) ||\n+                    (SearchConstants.REVINCLUDE.equals(inclusionKeyword) && isValidTargetType(resourceType, searchParameter)))) {\n+                // Valid search parameter of type reference - add to map\n+                inclusionSearchParameters.put(searchParameter.getCode().getValue(), searchParameter);\n+            } else if (inclusionSearchParameters.containsKey(searchParameter.getCode().getValue())) {\n+                // Search parameter is not valid - remove if search parameter by same name is alread in map", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk5NDE3MQ=="}, "originalCommit": {"oid": "8b32bd572f29429d86f9b80ce874cf041332dbc9"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMzQ1NzE2OnYy", "diffSide": "RIGHT", "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNTowODozMVrOHOhz4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMToxMjozMFrOHOuMTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk5NjA2NQ==", "bodyText": "Why would there be two search parameters of the same code already in the map?\nThe word already is misspelled", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r484996065", "createdAt": "2020-09-08T15:08:31Z", "author": {"login": "prb112"}, "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -502,6 +502,47 @@ private static SearchParameter getSearchParameterByUrlIfPresent(Map<String, Para\n         return result;\n     }\n \n+    /**\n+     * Perform wildcard processing for inclusion search parameters by getting all valid search parameters for the\n+     * specified join resource type. Search parameters must have a type of 'reference'.\n+     * <p>\n+     * If inclusion keyword is ' _include' and a target resource type is specified, search parameter must contain\n+     * a matching type.\n+     * <p>\n+     * If inclusion keyword is '_revinclude', search parameter must have a target resource type matching the resource\n+     * type being searched.\n+     * \n+     * @param resourceType\n+     *            the resource type being searched for\n+     * @param joinResourceType\n+     *            the resource type for which inclusion search parameters will be returned\n+     * @param searchParameterTargetType\n+     *            the target resource type for included resources\n+     * @param inclusionKeyword\n+     *            the inclusion type, either _include or _revinclude\n+     * @return\n+     *         the inclusion SearchParameters for type {@code resourceType} or empty map if none exist\n+     * @throws Exception\n+     */\n+    private static Map<String, SearchParameter> getInclusionWildcardSearchParameters(String resourceType, String joinResourceType,\n+        String searchParameterTargetType, String inclusionKeyword) throws Exception {\n+        Map<String, SearchParameter> inclusionSearchParameters = new HashMap<>();\n+\n+        for (SearchParameter searchParameter : getApplicableSearchParameters(joinResourceType)) {\n+            if (searchParameter.getType().getValue().equals(\"reference\") &&\n+                    ((SearchConstants.INCLUDE.equals(inclusionKeyword)\n+                            && (searchParameterTargetType == null || isValidTargetType(searchParameterTargetType, searchParameter))) ||\n+                    (SearchConstants.REVINCLUDE.equals(inclusionKeyword) && isValidTargetType(resourceType, searchParameter)))) {\n+                // Valid search parameter of type reference - add to map\n+                inclusionSearchParameters.put(searchParameter.getCode().getValue(), searchParameter);\n+            } else if (inclusionSearchParameters.containsKey(searchParameter.getCode().getValue())) {\n+                // Search parameter is not valid - remove if search parameter by same name is alread in map\n+                inclusionSearchParameters.remove(searchParameter.getCode().getValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b32bd572f29429d86f9b80ce874cf041332dbc9"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA0MTU4NQ==", "bodyText": "This is covering a case where there's a built-in search parm of type 'reference', but there's a tenant-specific search parm of the same name and the type is not 'reference'. I thought the tenant-specific parm should win.", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r485041585", "createdAt": "2020-09-08T16:15:48Z", "author": {"login": "michaelwschroeder"}, "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -502,6 +502,47 @@ private static SearchParameter getSearchParameterByUrlIfPresent(Map<String, Para\n         return result;\n     }\n \n+    /**\n+     * Perform wildcard processing for inclusion search parameters by getting all valid search parameters for the\n+     * specified join resource type. Search parameters must have a type of 'reference'.\n+     * <p>\n+     * If inclusion keyword is ' _include' and a target resource type is specified, search parameter must contain\n+     * a matching type.\n+     * <p>\n+     * If inclusion keyword is '_revinclude', search parameter must have a target resource type matching the resource\n+     * type being searched.\n+     * \n+     * @param resourceType\n+     *            the resource type being searched for\n+     * @param joinResourceType\n+     *            the resource type for which inclusion search parameters will be returned\n+     * @param searchParameterTargetType\n+     *            the target resource type for included resources\n+     * @param inclusionKeyword\n+     *            the inclusion type, either _include or _revinclude\n+     * @return\n+     *         the inclusion SearchParameters for type {@code resourceType} or empty map if none exist\n+     * @throws Exception\n+     */\n+    private static Map<String, SearchParameter> getInclusionWildcardSearchParameters(String resourceType, String joinResourceType,\n+        String searchParameterTargetType, String inclusionKeyword) throws Exception {\n+        Map<String, SearchParameter> inclusionSearchParameters = new HashMap<>();\n+\n+        for (SearchParameter searchParameter : getApplicableSearchParameters(joinResourceType)) {\n+            if (searchParameter.getType().getValue().equals(\"reference\") &&\n+                    ((SearchConstants.INCLUDE.equals(inclusionKeyword)\n+                            && (searchParameterTargetType == null || isValidTargetType(searchParameterTargetType, searchParameter))) ||\n+                    (SearchConstants.REVINCLUDE.equals(inclusionKeyword) && isValidTargetType(resourceType, searchParameter)))) {\n+                // Valid search parameter of type reference - add to map\n+                inclusionSearchParameters.put(searchParameter.getCode().getValue(), searchParameter);\n+            } else if (inclusionSearchParameters.containsKey(searchParameter.getCode().getValue())) {\n+                // Search parameter is not valid - remove if search parameter by same name is alread in map\n+                inclusionSearchParameters.remove(searchParameter.getCode().getValue());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk5NjA2NQ=="}, "originalCommit": {"oid": "8b32bd572f29429d86f9b80ce874cf041332dbc9"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA1MDM1MQ==", "bodyText": "so this is an error condition.  I think we should log, and not remove.  Generally it's not accepted to mutate, as it changes the values table for the search value.", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r485050351", "createdAt": "2020-09-08T16:30:09Z", "author": {"login": "prb112"}, "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -502,6 +502,47 @@ private static SearchParameter getSearchParameterByUrlIfPresent(Map<String, Para\n         return result;\n     }\n \n+    /**\n+     * Perform wildcard processing for inclusion search parameters by getting all valid search parameters for the\n+     * specified join resource type. Search parameters must have a type of 'reference'.\n+     * <p>\n+     * If inclusion keyword is ' _include' and a target resource type is specified, search parameter must contain\n+     * a matching type.\n+     * <p>\n+     * If inclusion keyword is '_revinclude', search parameter must have a target resource type matching the resource\n+     * type being searched.\n+     * \n+     * @param resourceType\n+     *            the resource type being searched for\n+     * @param joinResourceType\n+     *            the resource type for which inclusion search parameters will be returned\n+     * @param searchParameterTargetType\n+     *            the target resource type for included resources\n+     * @param inclusionKeyword\n+     *            the inclusion type, either _include or _revinclude\n+     * @return\n+     *         the inclusion SearchParameters for type {@code resourceType} or empty map if none exist\n+     * @throws Exception\n+     */\n+    private static Map<String, SearchParameter> getInclusionWildcardSearchParameters(String resourceType, String joinResourceType,\n+        String searchParameterTargetType, String inclusionKeyword) throws Exception {\n+        Map<String, SearchParameter> inclusionSearchParameters = new HashMap<>();\n+\n+        for (SearchParameter searchParameter : getApplicableSearchParameters(joinResourceType)) {\n+            if (searchParameter.getType().getValue().equals(\"reference\") &&\n+                    ((SearchConstants.INCLUDE.equals(inclusionKeyword)\n+                            && (searchParameterTargetType == null || isValidTargetType(searchParameterTargetType, searchParameter))) ||\n+                    (SearchConstants.REVINCLUDE.equals(inclusionKeyword) && isValidTargetType(resourceType, searchParameter)))) {\n+                // Valid search parameter of type reference - add to map\n+                inclusionSearchParameters.put(searchParameter.getCode().getValue(), searchParameter);\n+            } else if (inclusionSearchParameters.containsKey(searchParameter.getCode().getValue())) {\n+                // Search parameter is not valid - remove if search parameter by same name is alread in map\n+                inclusionSearchParameters.remove(searchParameter.getCode().getValue());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk5NjA2NQ=="}, "originalCommit": {"oid": "8b32bd572f29429d86f9b80ce874cf041332dbc9"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE5ODkyNw==", "bodyText": "Added log message and did not remove existing map entry.", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r485198927", "createdAt": "2020-09-08T21:12:30Z", "author": {"login": "michaelwschroeder"}, "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -502,6 +502,47 @@ private static SearchParameter getSearchParameterByUrlIfPresent(Map<String, Para\n         return result;\n     }\n \n+    /**\n+     * Perform wildcard processing for inclusion search parameters by getting all valid search parameters for the\n+     * specified join resource type. Search parameters must have a type of 'reference'.\n+     * <p>\n+     * If inclusion keyword is ' _include' and a target resource type is specified, search parameter must contain\n+     * a matching type.\n+     * <p>\n+     * If inclusion keyword is '_revinclude', search parameter must have a target resource type matching the resource\n+     * type being searched.\n+     * \n+     * @param resourceType\n+     *            the resource type being searched for\n+     * @param joinResourceType\n+     *            the resource type for which inclusion search parameters will be returned\n+     * @param searchParameterTargetType\n+     *            the target resource type for included resources\n+     * @param inclusionKeyword\n+     *            the inclusion type, either _include or _revinclude\n+     * @return\n+     *         the inclusion SearchParameters for type {@code resourceType} or empty map if none exist\n+     * @throws Exception\n+     */\n+    private static Map<String, SearchParameter> getInclusionWildcardSearchParameters(String resourceType, String joinResourceType,\n+        String searchParameterTargetType, String inclusionKeyword) throws Exception {\n+        Map<String, SearchParameter> inclusionSearchParameters = new HashMap<>();\n+\n+        for (SearchParameter searchParameter : getApplicableSearchParameters(joinResourceType)) {\n+            if (searchParameter.getType().getValue().equals(\"reference\") &&\n+                    ((SearchConstants.INCLUDE.equals(inclusionKeyword)\n+                            && (searchParameterTargetType == null || isValidTargetType(searchParameterTargetType, searchParameter))) ||\n+                    (SearchConstants.REVINCLUDE.equals(inclusionKeyword) && isValidTargetType(resourceType, searchParameter)))) {\n+                // Valid search parameter of type reference - add to map\n+                inclusionSearchParameters.put(searchParameter.getCode().getValue(), searchParameter);\n+            } else if (inclusionSearchParameters.containsKey(searchParameter.getCode().getValue())) {\n+                // Search parameter is not valid - remove if search parameter by same name is alread in map\n+                inclusionSearchParameters.remove(searchParameter.getCode().getValue());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk5NjA2NQ=="}, "originalCommit": {"oid": "8b32bd572f29429d86f9b80ce874cf041332dbc9"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMzQ2Mzk2OnYy", "diffSide": "RIGHT", "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNToxMDowOFrOHOh4Ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMToxMjo0MFrOHOuMmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk5NzEyMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Parses _include and _revinclude search result parameters contained in the query string, and produces\n          \n          \n            \n                 * Parses _include and _revinclude search parameters contained in the query string, and produces", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r484997122", "createdAt": "2020-09-08T15:10:08Z", "author": {"login": "prb112"}, "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -1373,17 +1414,25 @@ public static String normalizeForSearch(String value) {\n     }\n \n     /**\n-     * Parses _include and _revinclude search result parameters contained in the\n-     * query string, and produces\n-     * InclusionParameter objects to represent those parameters. The\n-     * InclusionParameter objects are included in the\n-     * appropriate collections encapsulated in the passed FHIRSearchContext.\n+     * Parses _include and _revinclude search result parameters contained in the query string, and produces", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b32bd572f29429d86f9b80ce874cf041332dbc9"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE5OTAwMA==", "bodyText": "Fixed.", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r485199000", "createdAt": "2020-09-08T21:12:40Z", "author": {"login": "michaelwschroeder"}, "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -1373,17 +1414,25 @@ public static String normalizeForSearch(String value) {\n     }\n \n     /**\n-     * Parses _include and _revinclude search result parameters contained in the\n-     * query string, and produces\n-     * InclusionParameter objects to represent those parameters. The\n-     * InclusionParameter objects are included in the\n-     * appropriate collections encapsulated in the passed FHIRSearchContext.\n+     * Parses _include and _revinclude search result parameters contained in the query string, and produces", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk5NzEyMg=="}, "originalCommit": {"oid": "8b32bd572f29429d86f9b80ce874cf041332dbc9"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMzUxNjE2OnYy", "diffSide": "RIGHT", "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNToyMjowMlrOHOiYmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNjoyNDo0N1rOHOk68g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAwNTQ2Ng==", "bodyText": "What happens when it's set to lenient? e.g. do we fail it? look at the behavior on line 1477", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r485005466", "createdAt": "2020-09-08T15:22:02Z", "author": {"login": "prb112"}, "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -1399,66 +1448,73 @@ private static void parseInclusionParameter(Class<?> resourceType, FHIRSearchCon\n             // Parse value into 3 parts: joinResourceType, searchParameterName, searchParameterTargetType\n             inclusionValueParts = inclusionValue.split(\":\");\n             if (inclusionValueParts.length < 2) {\n-                throw SearchExceptionUtil.buildNewInvalidSearchException(\n-                        \"A value for _include or _revinclude must have at least 2 parts separated by a colon.\");\n+                throw SearchExceptionUtil.buildNewInvalidSearchException(\"A value for _include or _revinclude must have at least 2 parts separated by a colon.\");\n             }\n-            joinResourceType          = inclusionValueParts[0];\n-            searchParameterName       = inclusionValueParts[1];\n+            joinResourceType = inclusionValueParts[0];\n+            searchParameterName = inclusionValueParts[1];\n             searchParameterTargetType = inclusionValueParts.length == 3 ? inclusionValueParts[2] : null;\n \n-            // Ensure that the Inclusion Parameter being parsed is a valid search parameter of type 'reference'.\n-            searchParm                = getSearchParameter(joinResourceType, searchParameterName);\n-            if (searchParm == null) {\n-                String msg = \"Undefined Inclusion Parameter: \" + inclusionValue;\n-                if (lenient) {\n-                    // TODO add this to the list of supplemental warnings?\n-                    log.fine(msg);\n-                    continue;\n-                } else {\n-                    throw SearchExceptionUtil.buildNewInvalidSearchException(msg);\n-                }\n+            // For _include parameter, join resource type must match resource type being searched\n+            if (SearchConstants.INCLUDE.equals(inclusionKeyword) && !joinResourceType.equals(resourceType.getSimpleName())) {\n+                throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                        \"The join resource type must match the resource type being searched.\");\n             }\n-            if (!searchParm.getType().getValue().equals(\"reference\")) {\n-                throw SearchExceptionUtil\n-                        .buildNewInvalidSearchException(\"Inclusion Parameter must be of type 'reference'. \"\n-                                + \"The passed Inclusion Parameter is of type: \" + searchParm.getType().getValue());\n+\n+            // For _revinclude parameter, target resource type, if specified, must match resource type being searched\n+            if (SearchConstants.REVINCLUDE.equals(inclusionKeyword) && searchParameterTargetType != null\n+                    && !searchParameterTargetType.equals(resourceType.getSimpleName())) {\n+                throw SearchExceptionUtil.buildNewInvalidSearchException(\"The search parameter target type must match the resource type being searched.\");\n             }\n \n-            if (inclusionKeyword.equals(SearchConstants.INCLUDE)) {\n-                newInclusionParms =\n-                        buildIncludeParameter(resourceType, joinResourceType, searchParm, searchParameterName,\n-                                searchParameterTargetType);\n-                context.getIncludeParameters().addAll(newInclusionParms);\n+            // Ensure that the Inclusion Parameter being parsed is a valid search parameter of type 'reference'.\n+            Map<String, SearchParameter> searchParametersMap;\n+            if (SearchConstants.WILDCARD.equals(searchParameterName)) {\n+                searchParametersMap = getInclusionWildcardSearchParameters(resourceType.getSimpleName(), joinResourceType, searchParameterTargetType, inclusionKeyword);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b32bd572f29429d86f9b80ce874cf041332dbc9"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAzOTIyMA==", "bodyText": "In the case of a wildcard search, if no valid matching search parameters are found, then we simply don't generate an _include or _revinclude clause - no exception is thrown. Should an exception be thrown in that case (if non-lenient)? I can certainly add a log entry indicating no valid search parms were found.", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r485039220", "createdAt": "2020-09-08T16:12:08Z", "author": {"login": "michaelwschroeder"}, "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -1399,66 +1448,73 @@ private static void parseInclusionParameter(Class<?> resourceType, FHIRSearchCon\n             // Parse value into 3 parts: joinResourceType, searchParameterName, searchParameterTargetType\n             inclusionValueParts = inclusionValue.split(\":\");\n             if (inclusionValueParts.length < 2) {\n-                throw SearchExceptionUtil.buildNewInvalidSearchException(\n-                        \"A value for _include or _revinclude must have at least 2 parts separated by a colon.\");\n+                throw SearchExceptionUtil.buildNewInvalidSearchException(\"A value for _include or _revinclude must have at least 2 parts separated by a colon.\");\n             }\n-            joinResourceType          = inclusionValueParts[0];\n-            searchParameterName       = inclusionValueParts[1];\n+            joinResourceType = inclusionValueParts[0];\n+            searchParameterName = inclusionValueParts[1];\n             searchParameterTargetType = inclusionValueParts.length == 3 ? inclusionValueParts[2] : null;\n \n-            // Ensure that the Inclusion Parameter being parsed is a valid search parameter of type 'reference'.\n-            searchParm                = getSearchParameter(joinResourceType, searchParameterName);\n-            if (searchParm == null) {\n-                String msg = \"Undefined Inclusion Parameter: \" + inclusionValue;\n-                if (lenient) {\n-                    // TODO add this to the list of supplemental warnings?\n-                    log.fine(msg);\n-                    continue;\n-                } else {\n-                    throw SearchExceptionUtil.buildNewInvalidSearchException(msg);\n-                }\n+            // For _include parameter, join resource type must match resource type being searched\n+            if (SearchConstants.INCLUDE.equals(inclusionKeyword) && !joinResourceType.equals(resourceType.getSimpleName())) {\n+                throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                        \"The join resource type must match the resource type being searched.\");\n             }\n-            if (!searchParm.getType().getValue().equals(\"reference\")) {\n-                throw SearchExceptionUtil\n-                        .buildNewInvalidSearchException(\"Inclusion Parameter must be of type 'reference'. \"\n-                                + \"The passed Inclusion Parameter is of type: \" + searchParm.getType().getValue());\n+\n+            // For _revinclude parameter, target resource type, if specified, must match resource type being searched\n+            if (SearchConstants.REVINCLUDE.equals(inclusionKeyword) && searchParameterTargetType != null\n+                    && !searchParameterTargetType.equals(resourceType.getSimpleName())) {\n+                throw SearchExceptionUtil.buildNewInvalidSearchException(\"The search parameter target type must match the resource type being searched.\");\n             }\n \n-            if (inclusionKeyword.equals(SearchConstants.INCLUDE)) {\n-                newInclusionParms =\n-                        buildIncludeParameter(resourceType, joinResourceType, searchParm, searchParameterName,\n-                                searchParameterTargetType);\n-                context.getIncludeParameters().addAll(newInclusionParms);\n+            // Ensure that the Inclusion Parameter being parsed is a valid search parameter of type 'reference'.\n+            Map<String, SearchParameter> searchParametersMap;\n+            if (SearchConstants.WILDCARD.equals(searchParameterName)) {\n+                searchParametersMap = getInclusionWildcardSearchParameters(resourceType.getSimpleName(), joinResourceType, searchParameterTargetType, inclusionKeyword);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAwNTQ2Ng=="}, "originalCommit": {"oid": "8b32bd572f29429d86f9b80ce874cf041332dbc9"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA0Mjc0NQ==", "bodyText": "Maybe we just log out, if it is set to not lenient?", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r485042745", "createdAt": "2020-09-08T16:17:39Z", "author": {"login": "prb112"}, "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -1399,66 +1448,73 @@ private static void parseInclusionParameter(Class<?> resourceType, FHIRSearchCon\n             // Parse value into 3 parts: joinResourceType, searchParameterName, searchParameterTargetType\n             inclusionValueParts = inclusionValue.split(\":\");\n             if (inclusionValueParts.length < 2) {\n-                throw SearchExceptionUtil.buildNewInvalidSearchException(\n-                        \"A value for _include or _revinclude must have at least 2 parts separated by a colon.\");\n+                throw SearchExceptionUtil.buildNewInvalidSearchException(\"A value for _include or _revinclude must have at least 2 parts separated by a colon.\");\n             }\n-            joinResourceType          = inclusionValueParts[0];\n-            searchParameterName       = inclusionValueParts[1];\n+            joinResourceType = inclusionValueParts[0];\n+            searchParameterName = inclusionValueParts[1];\n             searchParameterTargetType = inclusionValueParts.length == 3 ? inclusionValueParts[2] : null;\n \n-            // Ensure that the Inclusion Parameter being parsed is a valid search parameter of type 'reference'.\n-            searchParm                = getSearchParameter(joinResourceType, searchParameterName);\n-            if (searchParm == null) {\n-                String msg = \"Undefined Inclusion Parameter: \" + inclusionValue;\n-                if (lenient) {\n-                    // TODO add this to the list of supplemental warnings?\n-                    log.fine(msg);\n-                    continue;\n-                } else {\n-                    throw SearchExceptionUtil.buildNewInvalidSearchException(msg);\n-                }\n+            // For _include parameter, join resource type must match resource type being searched\n+            if (SearchConstants.INCLUDE.equals(inclusionKeyword) && !joinResourceType.equals(resourceType.getSimpleName())) {\n+                throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                        \"The join resource type must match the resource type being searched.\");\n             }\n-            if (!searchParm.getType().getValue().equals(\"reference\")) {\n-                throw SearchExceptionUtil\n-                        .buildNewInvalidSearchException(\"Inclusion Parameter must be of type 'reference'. \"\n-                                + \"The passed Inclusion Parameter is of type: \" + searchParm.getType().getValue());\n+\n+            // For _revinclude parameter, target resource type, if specified, must match resource type being searched\n+            if (SearchConstants.REVINCLUDE.equals(inclusionKeyword) && searchParameterTargetType != null\n+                    && !searchParameterTargetType.equals(resourceType.getSimpleName())) {\n+                throw SearchExceptionUtil.buildNewInvalidSearchException(\"The search parameter target type must match the resource type being searched.\");\n             }\n \n-            if (inclusionKeyword.equals(SearchConstants.INCLUDE)) {\n-                newInclusionParms =\n-                        buildIncludeParameter(resourceType, joinResourceType, searchParm, searchParameterName,\n-                                searchParameterTargetType);\n-                context.getIncludeParameters().addAll(newInclusionParms);\n+            // Ensure that the Inclusion Parameter being parsed is a valid search parameter of type 'reference'.\n+            Map<String, SearchParameter> searchParametersMap;\n+            if (SearchConstants.WILDCARD.equals(searchParameterName)) {\n+                searchParametersMap = getInclusionWildcardSearchParameters(resourceType.getSimpleName(), joinResourceType, searchParameterTargetType, inclusionKeyword);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAwNTQ2Ng=="}, "originalCommit": {"oid": "8b32bd572f29429d86f9b80ce874cf041332dbc9"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA0NzAyNg==", "bodyText": "Yeah, will just log it.", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r485047026", "createdAt": "2020-09-08T16:24:47Z", "author": {"login": "michaelwschroeder"}, "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -1399,66 +1448,73 @@ private static void parseInclusionParameter(Class<?> resourceType, FHIRSearchCon\n             // Parse value into 3 parts: joinResourceType, searchParameterName, searchParameterTargetType\n             inclusionValueParts = inclusionValue.split(\":\");\n             if (inclusionValueParts.length < 2) {\n-                throw SearchExceptionUtil.buildNewInvalidSearchException(\n-                        \"A value for _include or _revinclude must have at least 2 parts separated by a colon.\");\n+                throw SearchExceptionUtil.buildNewInvalidSearchException(\"A value for _include or _revinclude must have at least 2 parts separated by a colon.\");\n             }\n-            joinResourceType          = inclusionValueParts[0];\n-            searchParameterName       = inclusionValueParts[1];\n+            joinResourceType = inclusionValueParts[0];\n+            searchParameterName = inclusionValueParts[1];\n             searchParameterTargetType = inclusionValueParts.length == 3 ? inclusionValueParts[2] : null;\n \n-            // Ensure that the Inclusion Parameter being parsed is a valid search parameter of type 'reference'.\n-            searchParm                = getSearchParameter(joinResourceType, searchParameterName);\n-            if (searchParm == null) {\n-                String msg = \"Undefined Inclusion Parameter: \" + inclusionValue;\n-                if (lenient) {\n-                    // TODO add this to the list of supplemental warnings?\n-                    log.fine(msg);\n-                    continue;\n-                } else {\n-                    throw SearchExceptionUtil.buildNewInvalidSearchException(msg);\n-                }\n+            // For _include parameter, join resource type must match resource type being searched\n+            if (SearchConstants.INCLUDE.equals(inclusionKeyword) && !joinResourceType.equals(resourceType.getSimpleName())) {\n+                throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                        \"The join resource type must match the resource type being searched.\");\n             }\n-            if (!searchParm.getType().getValue().equals(\"reference\")) {\n-                throw SearchExceptionUtil\n-                        .buildNewInvalidSearchException(\"Inclusion Parameter must be of type 'reference'. \"\n-                                + \"The passed Inclusion Parameter is of type: \" + searchParm.getType().getValue());\n+\n+            // For _revinclude parameter, target resource type, if specified, must match resource type being searched\n+            if (SearchConstants.REVINCLUDE.equals(inclusionKeyword) && searchParameterTargetType != null\n+                    && !searchParameterTargetType.equals(resourceType.getSimpleName())) {\n+                throw SearchExceptionUtil.buildNewInvalidSearchException(\"The search parameter target type must match the resource type being searched.\");\n             }\n \n-            if (inclusionKeyword.equals(SearchConstants.INCLUDE)) {\n-                newInclusionParms =\n-                        buildIncludeParameter(resourceType, joinResourceType, searchParm, searchParameterName,\n-                                searchParameterTargetType);\n-                context.getIncludeParameters().addAll(newInclusionParms);\n+            // Ensure that the Inclusion Parameter being parsed is a valid search parameter of type 'reference'.\n+            Map<String, SearchParameter> searchParametersMap;\n+            if (SearchConstants.WILDCARD.equals(searchParameterName)) {\n+                searchParametersMap = getInclusionWildcardSearchParameters(resourceType.getSimpleName(), joinResourceType, searchParameterTargetType, inclusionKeyword);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAwNTQ2Ng=="}, "originalCommit": {"oid": "8b32bd572f29429d86f9b80ce874cf041332dbc9"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMzUyMjMxOnYy", "diffSide": "RIGHT", "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNToyMzoyMFrOHOicKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMToxMjo1MlrOHOuM7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAwNjM3Nw==", "bodyText": "single quotes around the value.  it shows better in the logs", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r485006377", "createdAt": "2020-09-08T15:23:20Z", "author": {"login": "prb112"}, "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -1399,66 +1448,73 @@ private static void parseInclusionParameter(Class<?> resourceType, FHIRSearchCon\n             // Parse value into 3 parts: joinResourceType, searchParameterName, searchParameterTargetType\n             inclusionValueParts = inclusionValue.split(\":\");\n             if (inclusionValueParts.length < 2) {\n-                throw SearchExceptionUtil.buildNewInvalidSearchException(\n-                        \"A value for _include or _revinclude must have at least 2 parts separated by a colon.\");\n+                throw SearchExceptionUtil.buildNewInvalidSearchException(\"A value for _include or _revinclude must have at least 2 parts separated by a colon.\");\n             }\n-            joinResourceType          = inclusionValueParts[0];\n-            searchParameterName       = inclusionValueParts[1];\n+            joinResourceType = inclusionValueParts[0];\n+            searchParameterName = inclusionValueParts[1];\n             searchParameterTargetType = inclusionValueParts.length == 3 ? inclusionValueParts[2] : null;\n \n-            // Ensure that the Inclusion Parameter being parsed is a valid search parameter of type 'reference'.\n-            searchParm                = getSearchParameter(joinResourceType, searchParameterName);\n-            if (searchParm == null) {\n-                String msg = \"Undefined Inclusion Parameter: \" + inclusionValue;\n-                if (lenient) {\n-                    // TODO add this to the list of supplemental warnings?\n-                    log.fine(msg);\n-                    continue;\n-                } else {\n-                    throw SearchExceptionUtil.buildNewInvalidSearchException(msg);\n-                }\n+            // For _include parameter, join resource type must match resource type being searched\n+            if (SearchConstants.INCLUDE.equals(inclusionKeyword) && !joinResourceType.equals(resourceType.getSimpleName())) {\n+                throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                        \"The join resource type must match the resource type being searched.\");\n             }\n-            if (!searchParm.getType().getValue().equals(\"reference\")) {\n-                throw SearchExceptionUtil\n-                        .buildNewInvalidSearchException(\"Inclusion Parameter must be of type 'reference'. \"\n-                                + \"The passed Inclusion Parameter is of type: \" + searchParm.getType().getValue());\n+\n+            // For _revinclude parameter, target resource type, if specified, must match resource type being searched\n+            if (SearchConstants.REVINCLUDE.equals(inclusionKeyword) && searchParameterTargetType != null\n+                    && !searchParameterTargetType.equals(resourceType.getSimpleName())) {\n+                throw SearchExceptionUtil.buildNewInvalidSearchException(\"The search parameter target type must match the resource type being searched.\");\n             }\n \n-            if (inclusionKeyword.equals(SearchConstants.INCLUDE)) {\n-                newInclusionParms =\n-                        buildIncludeParameter(resourceType, joinResourceType, searchParm, searchParameterName,\n-                                searchParameterTargetType);\n-                context.getIncludeParameters().addAll(newInclusionParms);\n+            // Ensure that the Inclusion Parameter being parsed is a valid search parameter of type 'reference'.\n+            Map<String, SearchParameter> searchParametersMap;\n+            if (SearchConstants.WILDCARD.equals(searchParameterName)) {\n+                searchParametersMap = getInclusionWildcardSearchParameters(resourceType.getSimpleName(), joinResourceType, searchParameterTargetType, inclusionKeyword);\n             } else {\n-                newInclusionParm =\n-                        buildRevIncludeParameter(resourceType, joinResourceType, searchParm, searchParameterName,\n-                                searchParameterTargetType);\n-                context.getRevIncludeParameters().add(newInclusionParm);\n+                searchParm = getSearchParameter(joinResourceType, searchParameterName);\n+                if (searchParm == null) {\n+                    String msg = \"Undefined Inclusion Parameter: \" + inclusionValue;\n+                    if (lenient) {\n+                        // TODO add this to the list of supplemental warnings?\n+                        log.fine(msg);\n+                        continue;\n+                    } else {\n+                        throw SearchExceptionUtil.buildNewInvalidSearchException(msg);\n+                    }\n+                }\n+                if (!searchParm.getType().getValue().equals(\"reference\")) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(\"Inclusion Parameter must be of type 'reference'. \"\n+                            + \"The passed Inclusion Parameter is of type: \" + searchParm.getType().getValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b32bd572f29429d86f9b80ce874cf041332dbc9"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE5OTA4Ng==", "bodyText": "Fixed.", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r485199086", "createdAt": "2020-09-08T21:12:52Z", "author": {"login": "michaelwschroeder"}, "path": "fhir-search/src/main/java/com/ibm/fhir/search/util/SearchUtil.java", "diffHunk": "@@ -1399,66 +1448,73 @@ private static void parseInclusionParameter(Class<?> resourceType, FHIRSearchCon\n             // Parse value into 3 parts: joinResourceType, searchParameterName, searchParameterTargetType\n             inclusionValueParts = inclusionValue.split(\":\");\n             if (inclusionValueParts.length < 2) {\n-                throw SearchExceptionUtil.buildNewInvalidSearchException(\n-                        \"A value for _include or _revinclude must have at least 2 parts separated by a colon.\");\n+                throw SearchExceptionUtil.buildNewInvalidSearchException(\"A value for _include or _revinclude must have at least 2 parts separated by a colon.\");\n             }\n-            joinResourceType          = inclusionValueParts[0];\n-            searchParameterName       = inclusionValueParts[1];\n+            joinResourceType = inclusionValueParts[0];\n+            searchParameterName = inclusionValueParts[1];\n             searchParameterTargetType = inclusionValueParts.length == 3 ? inclusionValueParts[2] : null;\n \n-            // Ensure that the Inclusion Parameter being parsed is a valid search parameter of type 'reference'.\n-            searchParm                = getSearchParameter(joinResourceType, searchParameterName);\n-            if (searchParm == null) {\n-                String msg = \"Undefined Inclusion Parameter: \" + inclusionValue;\n-                if (lenient) {\n-                    // TODO add this to the list of supplemental warnings?\n-                    log.fine(msg);\n-                    continue;\n-                } else {\n-                    throw SearchExceptionUtil.buildNewInvalidSearchException(msg);\n-                }\n+            // For _include parameter, join resource type must match resource type being searched\n+            if (SearchConstants.INCLUDE.equals(inclusionKeyword) && !joinResourceType.equals(resourceType.getSimpleName())) {\n+                throw SearchExceptionUtil.buildNewInvalidSearchException(\n+                        \"The join resource type must match the resource type being searched.\");\n             }\n-            if (!searchParm.getType().getValue().equals(\"reference\")) {\n-                throw SearchExceptionUtil\n-                        .buildNewInvalidSearchException(\"Inclusion Parameter must be of type 'reference'. \"\n-                                + \"The passed Inclusion Parameter is of type: \" + searchParm.getType().getValue());\n+\n+            // For _revinclude parameter, target resource type, if specified, must match resource type being searched\n+            if (SearchConstants.REVINCLUDE.equals(inclusionKeyword) && searchParameterTargetType != null\n+                    && !searchParameterTargetType.equals(resourceType.getSimpleName())) {\n+                throw SearchExceptionUtil.buildNewInvalidSearchException(\"The search parameter target type must match the resource type being searched.\");\n             }\n \n-            if (inclusionKeyword.equals(SearchConstants.INCLUDE)) {\n-                newInclusionParms =\n-                        buildIncludeParameter(resourceType, joinResourceType, searchParm, searchParameterName,\n-                                searchParameterTargetType);\n-                context.getIncludeParameters().addAll(newInclusionParms);\n+            // Ensure that the Inclusion Parameter being parsed is a valid search parameter of type 'reference'.\n+            Map<String, SearchParameter> searchParametersMap;\n+            if (SearchConstants.WILDCARD.equals(searchParameterName)) {\n+                searchParametersMap = getInclusionWildcardSearchParameters(resourceType.getSimpleName(), joinResourceType, searchParameterTargetType, inclusionKeyword);\n             } else {\n-                newInclusionParm =\n-                        buildRevIncludeParameter(resourceType, joinResourceType, searchParm, searchParameterName,\n-                                searchParameterTargetType);\n-                context.getRevIncludeParameters().add(newInclusionParm);\n+                searchParm = getSearchParameter(joinResourceType, searchParameterName);\n+                if (searchParm == null) {\n+                    String msg = \"Undefined Inclusion Parameter: \" + inclusionValue;\n+                    if (lenient) {\n+                        // TODO add this to the list of supplemental warnings?\n+                        log.fine(msg);\n+                        continue;\n+                    } else {\n+                        throw SearchExceptionUtil.buildNewInvalidSearchException(msg);\n+                    }\n+                }\n+                if (!searchParm.getType().getValue().equals(\"reference\")) {\n+                    throw SearchExceptionUtil.buildNewInvalidSearchException(\"Inclusion Parameter must be of type 'reference'. \"\n+                            + \"The passed Inclusion Parameter is of type: \" + searchParm.getType().getValue());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAwNjM3Nw=="}, "originalCommit": {"oid": "8b32bd572f29429d86f9b80ce874cf041332dbc9"}, "originalPosition": 150}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMzUzNjcxOnYy", "diffSide": "RIGHT", "path": "fhir-search/src/test/java/com/ibm/fhir/search/test/InclusionParameterParseTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNToyNjoyM1rOHOik3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMToxMzoxM1rOHOuNew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAwODYwNA==", "bodyText": "Let's add a set of extra tests. That has two _include search parameters on Patient and Provenance.  we want to double check that it works across multiple resources.", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r485008604", "createdAt": "2020-09-08T15:26:23Z", "author": {"login": "prb112"}, "path": "fhir-search/src/test/java/com/ibm/fhir/search/test/InclusionParameterParseTest.java", "diffHunk": "@@ -327,4 +340,151 @@ public void testMultiIncludeRevinclude() throws Exception {\n         assertTrue(selfUri.contains(include4));\n     }\n \n+    @Test\n+    public void testWildcardIncludeNoMatchingTargetType() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Patient> resourceType = Patient.class;\n+\n+        queryParameters.put(\"_include\", Collections.singletonList(\"Patient:*:Medication\"));\n+        FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+\n+        assertNotNull(searchContext);\n+        assertFalse(searchContext.hasIncludeParameters());\n+        assertFalse(searchContext.hasRevIncludeParameters());\n+\n+        String selfUri = SearchUtil.buildSearchSelfUri(\"http://example.com/Patient\", searchContext);\n+        assertTrue(selfUri.equals(\"http://example.com/Patient?_count=10&_page=1\"));\n+    }\n+\n+    @Test\n+    public void testWildcardIncludeSingleMatchingTargetType() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Patient> resourceType = Patient.class;\n+\n+        queryParameters.put(\"_include\", Collections.singletonList(\"Patient:*:RelatedPerson\"));\n+        FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+\n+        assertNotNull(searchContext);\n+        assertTrue(searchContext.hasIncludeParameters());\n+        assertEquals(1, searchContext.getIncludeParameters().size());\n+        InclusionParameter incParm = searchContext.getIncludeParameters().get(0);\n+        assertEquals(\"Patient\", incParm.getJoinResourceType());\n+        assertEquals(\"link\", incParm.getSearchParameter());\n+        assertEquals(\"RelatedPerson\", incParm.getSearchParameterTargetType());\n+        assertFalse(searchContext.hasRevIncludeParameters());\n+\n+        String selfUri = SearchUtil.buildSearchSelfUri(\"http://example.com/Patient\", searchContext);\n+        assertTrue(selfUri.equals(\"http://example.com/Patient?_count=10&_include=\" + incParm.getJoinResourceType() +\n+            \":\" + incParm.getSearchParameter() + \":\" + incParm.getSearchParameterTargetType() + \"&_page=1\"));\n+    }\n+\n+    @Test\n+    public void testWildcardIncludeNoTargetType() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Patient> resourceType = Patient.class;\n+        String include1 = \"&_include=Patient:general-practitioner:Organization\";\n+        String include2 = \"&_include=Patient:general-practitioner:Practitioner\";\n+        String include3 = \"&_include=Patient:general-practitioner:PractitionerRole\";\n+        String include4 = \"&_include=Patient:organization:Organization\";\n+        String include5 = \"&_include=Patient:link:Patient\";\n+        String include6 = \"&_include=Patient:link:RelatedPerson\";\n+\n+        List<InclusionParameter> expectedIncludeParms = new ArrayList<>();\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"general-practitioner\", \"Organization\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"general-practitioner\", \"Practitioner\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"general-practitioner\", \"PractitionerRole\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"organization\", \"Organization\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"link\", \"Patient\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"link\", \"RelatedPerson\"));\n+\n+        queryParameters.put(\"_include\", Collections.singletonList(\"Patient:*\"));\n+        FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+\n+        assertNotNull(searchContext);\n+        assertTrue(searchContext.hasIncludeParameters());\n+        assertEquals(expectedIncludeParms.size(), searchContext.getIncludeParameters().size());\n+        for (InclusionParameter includeParm : expectedIncludeParms) {\n+            assertTrue(expectedIncludeParms.contains(includeParm));\n+        }\n+\n+        assertFalse(searchContext.hasRevIncludeParameters());\n+\n+        String selfUri = SearchUtil.buildSearchSelfUri(\"http://example.com/Patient\", searchContext);\n+        assertTrue(selfUri.contains(include1));\n+        assertTrue(selfUri.contains(include2));\n+        assertTrue(selfUri.contains(include3));\n+        assertTrue(selfUri.contains(include4));\n+        assertTrue(selfUri.contains(include5));\n+        assertTrue(selfUri.contains(include6));\n+    }\n+\n+    @Test\n+    public void testWildcardRevIncludeNoMatchingTargetType() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Condition> resourceType = Condition.class;\n+\n+        queryParameters.put(\"_revinclude\", Collections.singletonList(\"Patient:*:Condition\"));\n+        FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+\n+        assertNotNull(searchContext);\n+        assertFalse(searchContext.hasIncludeParameters());\n+        assertFalse(searchContext.hasRevIncludeParameters());\n+\n+        String selfUri = SearchUtil.buildSearchSelfUri(\"http://example.com/Condition\", searchContext);\n+        assertTrue(selfUri.equals(\"http://example.com/Condition?_count=10&_page=1\"));\n+    }\n+\n+    @Test\n+    public void testWildcardRevIncludeSingleMatchingTargetType() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Encounter> resourceType = Encounter.class;\n+\n+        queryParameters.put(\"_revinclude\", Collections.singletonList(\"MedicationAdministration:*:Encounter\"));\n+        FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+\n+        assertNotNull(searchContext);\n+        assertTrue(searchContext.hasRevIncludeParameters());\n+        assertEquals(1, searchContext.getRevIncludeParameters().size());\n+        InclusionParameter incParm = searchContext.getRevIncludeParameters().get(0);\n+        assertEquals(\"MedicationAdministration\", incParm.getJoinResourceType());\n+        assertEquals(\"context\", incParm.getSearchParameter());\n+        assertEquals(\"Encounter\", incParm.getSearchParameterTargetType());\n+        assertFalse(searchContext.hasIncludeParameters());\n+\n+        String selfUri = SearchUtil.buildSearchSelfUri(\"http://example.com/Encounter\", searchContext);\n+        assertTrue(selfUri.equals(\"http://example.com/Encounter?_count=10&_revinclude=\" + incParm.getJoinResourceType() +\n+            \":\" + incParm.getSearchParameter() + \":\" + incParm.getSearchParameterTargetType() + \"&_page=1\"));\n+    }\n+\n+    @Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b32bd572f29429d86f9b80ce874cf041332dbc9"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE5OTIyNw==", "bodyText": "Added new unit tests.", "url": "https://github.com/IBM/FHIR/pull/1486#discussion_r485199227", "createdAt": "2020-09-08T21:13:13Z", "author": {"login": "michaelwschroeder"}, "path": "fhir-search/src/test/java/com/ibm/fhir/search/test/InclusionParameterParseTest.java", "diffHunk": "@@ -327,4 +340,151 @@ public void testMultiIncludeRevinclude() throws Exception {\n         assertTrue(selfUri.contains(include4));\n     }\n \n+    @Test\n+    public void testWildcardIncludeNoMatchingTargetType() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Patient> resourceType = Patient.class;\n+\n+        queryParameters.put(\"_include\", Collections.singletonList(\"Patient:*:Medication\"));\n+        FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+\n+        assertNotNull(searchContext);\n+        assertFalse(searchContext.hasIncludeParameters());\n+        assertFalse(searchContext.hasRevIncludeParameters());\n+\n+        String selfUri = SearchUtil.buildSearchSelfUri(\"http://example.com/Patient\", searchContext);\n+        assertTrue(selfUri.equals(\"http://example.com/Patient?_count=10&_page=1\"));\n+    }\n+\n+    @Test\n+    public void testWildcardIncludeSingleMatchingTargetType() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Patient> resourceType = Patient.class;\n+\n+        queryParameters.put(\"_include\", Collections.singletonList(\"Patient:*:RelatedPerson\"));\n+        FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+\n+        assertNotNull(searchContext);\n+        assertTrue(searchContext.hasIncludeParameters());\n+        assertEquals(1, searchContext.getIncludeParameters().size());\n+        InclusionParameter incParm = searchContext.getIncludeParameters().get(0);\n+        assertEquals(\"Patient\", incParm.getJoinResourceType());\n+        assertEquals(\"link\", incParm.getSearchParameter());\n+        assertEquals(\"RelatedPerson\", incParm.getSearchParameterTargetType());\n+        assertFalse(searchContext.hasRevIncludeParameters());\n+\n+        String selfUri = SearchUtil.buildSearchSelfUri(\"http://example.com/Patient\", searchContext);\n+        assertTrue(selfUri.equals(\"http://example.com/Patient?_count=10&_include=\" + incParm.getJoinResourceType() +\n+            \":\" + incParm.getSearchParameter() + \":\" + incParm.getSearchParameterTargetType() + \"&_page=1\"));\n+    }\n+\n+    @Test\n+    public void testWildcardIncludeNoTargetType() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Patient> resourceType = Patient.class;\n+        String include1 = \"&_include=Patient:general-practitioner:Organization\";\n+        String include2 = \"&_include=Patient:general-practitioner:Practitioner\";\n+        String include3 = \"&_include=Patient:general-practitioner:PractitionerRole\";\n+        String include4 = \"&_include=Patient:organization:Organization\";\n+        String include5 = \"&_include=Patient:link:Patient\";\n+        String include6 = \"&_include=Patient:link:RelatedPerson\";\n+\n+        List<InclusionParameter> expectedIncludeParms = new ArrayList<>();\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"general-practitioner\", \"Organization\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"general-practitioner\", \"Practitioner\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"general-practitioner\", \"PractitionerRole\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"organization\", \"Organization\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"link\", \"Patient\"));\n+        expectedIncludeParms.add(new InclusionParameter(\"Patient\", \"link\", \"RelatedPerson\"));\n+\n+        queryParameters.put(\"_include\", Collections.singletonList(\"Patient:*\"));\n+        FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+\n+        assertNotNull(searchContext);\n+        assertTrue(searchContext.hasIncludeParameters());\n+        assertEquals(expectedIncludeParms.size(), searchContext.getIncludeParameters().size());\n+        for (InclusionParameter includeParm : expectedIncludeParms) {\n+            assertTrue(expectedIncludeParms.contains(includeParm));\n+        }\n+\n+        assertFalse(searchContext.hasRevIncludeParameters());\n+\n+        String selfUri = SearchUtil.buildSearchSelfUri(\"http://example.com/Patient\", searchContext);\n+        assertTrue(selfUri.contains(include1));\n+        assertTrue(selfUri.contains(include2));\n+        assertTrue(selfUri.contains(include3));\n+        assertTrue(selfUri.contains(include4));\n+        assertTrue(selfUri.contains(include5));\n+        assertTrue(selfUri.contains(include6));\n+    }\n+\n+    @Test\n+    public void testWildcardRevIncludeNoMatchingTargetType() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Condition> resourceType = Condition.class;\n+\n+        queryParameters.put(\"_revinclude\", Collections.singletonList(\"Patient:*:Condition\"));\n+        FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+\n+        assertNotNull(searchContext);\n+        assertFalse(searchContext.hasIncludeParameters());\n+        assertFalse(searchContext.hasRevIncludeParameters());\n+\n+        String selfUri = SearchUtil.buildSearchSelfUri(\"http://example.com/Condition\", searchContext);\n+        assertTrue(selfUri.equals(\"http://example.com/Condition?_count=10&_page=1\"));\n+    }\n+\n+    @Test\n+    public void testWildcardRevIncludeSingleMatchingTargetType() throws Exception {\n+        Map<String, List<String>> queryParameters = new HashMap<>();\n+        Class<Encounter> resourceType = Encounter.class;\n+\n+        queryParameters.put(\"_revinclude\", Collections.singletonList(\"MedicationAdministration:*:Encounter\"));\n+        FHIRSearchContext searchContext = SearchUtil.parseQueryParameters(resourceType, queryParameters);\n+\n+        assertNotNull(searchContext);\n+        assertTrue(searchContext.hasRevIncludeParameters());\n+        assertEquals(1, searchContext.getRevIncludeParameters().size());\n+        InclusionParameter incParm = searchContext.getRevIncludeParameters().get(0);\n+        assertEquals(\"MedicationAdministration\", incParm.getJoinResourceType());\n+        assertEquals(\"context\", incParm.getSearchParameter());\n+        assertEquals(\"Encounter\", incParm.getSearchParameterTargetType());\n+        assertFalse(searchContext.hasIncludeParameters());\n+\n+        String selfUri = SearchUtil.buildSearchSelfUri(\"http://example.com/Encounter\", searchContext);\n+        assertTrue(selfUri.equals(\"http://example.com/Encounter?_count=10&_revinclude=\" + incParm.getJoinResourceType() +\n+            \":\" + incParm.getSearchParameter() + \":\" + incParm.getSearchParameterTargetType() + \"&_page=1\"));\n+    }\n+\n+    @Test", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAwODYwNA=="}, "originalCommit": {"oid": "8b32bd572f29429d86f9b80ce874cf041332dbc9"}, "originalPosition": 152}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4667, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}