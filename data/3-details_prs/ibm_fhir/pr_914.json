{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAxMTM0MDU4", "number": 914, "title": "issue #877 postgresql support ", "bodyText": "Added: postgresql support (without storage procedure and partition support).\n(1) added postgresql support to datautil, schema, jdbc and proxy projects to allow postgresql db to be used as fhir data store.\n(2) added sample postgresql config to fhir-server-config.json.\n(3) added postgresql support to schema and jdbc test apps.\n(4) added sample postgresql config to properties files for tools/tests in the schema and jdbc projects.\n(5) added instruction and sample ddl to allow user to use postgresql as javabatch job repository.\n(6) refactored ResourceDAO codes.\npassed jdbc and server integration tests with manually set up postgresql instance.", "createdAt": "2020-04-08T23:45:23Z", "url": "https://github.com/IBM/FHIR/pull/914", "merged": true, "mergeCommit": {"oid": "efdfadd8d044627d0590b9d3e9c5c40396cc8b34"}, "closed": true, "closedAt": "2020-04-20T20:24:27Z", "author": {"login": "albertwang-ibm"}, "timelineItems": {"totalCount": 121, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcZkaQZgH2gAyNDAxMTM0MDU4OjJlMjViOGJhNzM3OGNlZGNlMjA5ODY0YmIyZDcxNGFiNWJiMWYzOWY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcZkapygBqjMyNTMyODcxNDg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "2e25b8ba7378cedce209864bb2d714ab5bb1f39f", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/2e25b8ba7378cedce209864bb2d714ab5bb1f39f", "committedDate": "2020-04-20T19:39:27Z", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "62a4402385b0d704c273738bbb03b4531211292e", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/62a4402385b0d704c273738bbb03b4531211292e", "committedDate": "2020-04-20T19:39:27Z", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f5c6637bdbd1a33a2a266e969e5c335de765c6b9", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/f5c6637bdbd1a33a2a266e969e5c335de765c6b9", "committedDate": "2020-04-20T19:39:27Z", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b650b7ded3d70427488aefb0bb060b03c5c77716", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/b650b7ded3d70427488aefb0bb060b03c5c77716", "committedDate": "2020-04-20T19:39:27Z", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "61446b4c970f123bb5500bb891ead756bd07cb6e", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/61446b4c970f123bb5500bb891ead756bd07cb6e", "committedDate": "2020-04-20T19:39:27Z", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "592103135de8d5a5cdd1685ba20ba06211ec3295", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/592103135de8d5a5cdd1685ba20ba06211ec3295", "committedDate": "2020-04-20T19:39:27Z", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a5cc2af5fc4f1046a8331becb351c8062c88725f", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/a5cc2af5fc4f1046a8331becb351c8062c88725f", "committedDate": "2020-04-20T19:39:27Z", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "97c4e2fee2028d09575a51ed5898dab5f8eae1cb", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/97c4e2fee2028d09575a51ed5898dab5f8eae1cb", "committedDate": "2020-04-20T19:39:27Z", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c280bd8ed0950dd464dc14ef0e3beb78c22c77bb", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/c280bd8ed0950dd464dc14ef0e3beb78c22c77bb", "committedDate": "2020-04-20T19:39:27Z", "message": "Update fhir-persistence-jdbc/src/test/resources/test.jdbc-perform.properties\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "75d04d67a2e098ae1cb811ffde26af6b4cf3d589", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/75d04d67a2e098ae1cb811ffde26af6b4cf3d589", "committedDate": "2020-04-20T19:39:27Z", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/FHIRResourceDAOFactory.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3cf72cbfe657b9aff8b9dd3dbbffcfdea32c4c8e", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/3cf72cbfe657b9aff8b9dd3dbbffcfdea32c4c8e", "committedDate": "2020-04-20T19:39:27Z", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/FhirSequenceDAOImpl.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f021e7b72a9c6c5bc2cf0474af8ea56692adf606", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/f021e7b72a9c6c5bc2cf0474af8ea56692adf606", "committedDate": "2020-04-20T19:39:27Z", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/FHIRResourceDAOFactory.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f2f785b68901d83d48871dc637d82a66f784dd9", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/3f2f785b68901d83d48871dc637d82a66f784dd9", "committedDate": "2020-04-20T19:39:27Z", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee91af8d86efc412ce04953b13a53fcf9ae812b7", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/ee91af8d86efc412ce04953b13a53fcf9ae812b7", "committedDate": "2020-04-20T19:39:27Z", "message": "Update fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlDoesTableExist.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "96988ad195592e7383ca3448776b7af618dbd508", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/96988ad195592e7383ca3448776b7af618dbd508", "committedDate": "2020-04-20T19:39:27Z", "message": "Update fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlDoesTableExist.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7847fb0d46a21c6b74875df02b4e37630f58e3b7", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/7847fb0d46a21c6b74875df02b4e37630f58e3b7", "committedDate": "2020-04-20T19:39:27Z", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dabff61587dff093180804802ba09d7a3fafc683", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/dabff61587dff093180804802ba09d7a3fafc683", "committedDate": "2020-04-20T19:39:27Z", "message": "Update fhir-persistence-schema/README.md\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f8c98e914b9f456b973be3e5ccc383048299754", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/7f8c98e914b9f456b973be3e5ccc383048299754", "committedDate": "2020-04-20T19:39:27Z", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "949e44de878c7cc7e20afcafc1297bdb640a6317", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/949e44de878c7cc7e20afcafc1297bdb640a6317", "committedDate": "2020-04-20T19:39:27Z", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "12126fb06f285521180681126d77efbd05aecbfa", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/12126fb06f285521180681126d77efbd05aecbfa", "committedDate": "2020-04-20T19:39:27Z", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "79f706c179f934c4382d611a16e9d5fe40ed3549", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/79f706c179f934c4382d611a16e9d5fe40ed3549", "committedDate": "2020-04-20T19:39:27Z", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ec4828123b18300d77a17cfc397de50758bd9d9", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/8ec4828123b18300d77a17cfc397de50758bd9d9", "committedDate": "2020-04-20T19:39:27Z", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cfd4e260a392bc7ec138c2ae2d2fcca95995de9b", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/cfd4e260a392bc7ec138c2ae2d2fcca95995de9b", "committedDate": "2020-04-20T19:39:27Z", "message": "issue #877 keep index name unchanged for db2 and derby\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ccd160ddb04985c7132e495cf2893a3bd4751c33", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/ccd160ddb04985c7132e495cf2893a3bd4751c33", "committedDate": "2020-04-20T19:39:27Z", "message": "issue #877 minor update to readme of schema tool\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f042490a5d5e3badca775b891ccb10ffdb28ebc1", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/f042490a5d5e3badca775b891ccb10ffdb28ebc1", "committedDate": "2020-04-20T19:32:20Z", "message": "issue #877 minor update to readme of schema tool\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}, "afterCommit": {"oid": "ccd160ddb04985c7132e495cf2893a3bd4751c33", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/ccd160ddb04985c7132e495cf2893a3bd4751c33", "committedDate": "2020-04-20T19:39:27Z", "message": "issue #877 minor update to readme of schema tool\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2b4f5788096d92f88828cc8010cc76f42b33f6c1", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/2b4f5788096d92f88828cc8010cc76f42b33f6c1", "committedDate": "2020-04-08T22:34:47Z", "message": "Merge pull request #912 from IBM/issue-877\n\nIssue 877"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwNzQ4NzE3", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-390748717", "createdAt": "2020-04-09T12:31:42Z", "commit": {"oid": "aae34e26f731a5ff727a5a875f3f9828f1069987"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMjozMTo0MlrOGDWqjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMjozMTo0MlrOGDWqjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3MDI1Mw==", "bodyText": "I think this row is wrong too", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r406170253", "createdAt": "2020-04-09T12:31:42Z", "author": {"login": "lmsurpre"}, "path": "docs/src/pages/guides/FHIRServerUsersGuide.md", "diffHunk": "@@ -1442,7 +1442,7 @@ must restart the server for that change to take effect.\n |`fhirServer/bulkdata/jobParameters/cos.api.key`|Y|Y|\n |`fhirServer/bulkdata/jobParameters/cos.srvinst.id`|Y|Y|\n |`fhirServer/bulkdata/bulkDataBatchJobIdEncryptionKey`|Y|Y|", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aae34e26f731a5ff727a5a875f3f9828f1069987"}, "originalPosition": 3}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyMTE1NjE0", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-392115614", "createdAt": "2020-04-13T12:29:57Z", "commit": {"oid": "30dc31f428897b014c86cf452b52905e6156ce0c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxMjoyOTo1N1rOGElGkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxMjoyOTo1N1rOGElGkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQ1NTM3OQ==", "bodyText": "for consistency, move this entry one line up (before fhir)\npersistence libraries then fhir", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r407455379", "createdAt": "2020-04-13T12:29:57Z", "author": {"login": "prb112"}, "path": "fhir-server/liberty-config/server.xml", "diffHunk": "@@ -151,6 +151,7 @@\n         <fileset dir=\"${shared.resource.dir}/lib/derby\" includes=\"*.jar\"/>\n         <fileset dir=\"${shared.resource.dir}/lib/db2\" includes=\"*.jar\"/>\n         <fileset dir=\"${shared.resource.dir}/lib/fhir\" includes=\"*.jar\"/>\n+        <fileset dir=\"${shared.resource.dir}/lib/postgresql\" includes=\"*.jar\"/>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "30dc31f428897b014c86cf452b52905e6156ce0c"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0Njg2Njgx", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-394686681", "createdAt": "2020-04-16T14:25:06Z", "commit": {"oid": "cdd27c9867e0bff4426c2d54d6ff569fbf9056b3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxNDoyNTowNlrOGGn8Cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxNDoyNTowNlrOGGn8Cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTU5ODk4Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ```", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r409598986", "createdAt": "2020-04-16T14:25:06Z", "author": {"login": "prb112"}, "path": "docs/src/pages/guides/FHIRServerUsersGuide.md", "diffHunk": "@@ -1220,9 +1220,81 @@ The JavaBatch user is configured in server.xml and the bulkdata.json:\n \t</security-role>\n </authorization-roles>\n ```\n-Note: The user referenced in the bulkdata.json must have a role of at least batchSubmitter.\n-\n-By default, in-memory Derby database is used for persistence of the JavaBatch Jobs. Instruction is also provided in \"Configuring a Liberty Datasource with API Key\" section of the DB2OnCloudSetup guide to configure DB2 service in IBM Clouds as JavaBatch persistence store. Liberty JavaBatch framework creates DB schema and tables automatically by default for both approaches, and the configured database is created automatically, if the in-memory Apache Derby approach is used.   \n+Note: The user referenced in the fhir-server-config.json must have a role of at least batchSubmitter.\n+\n+By default, in-memory Derby database is used for persistence of the JavaBatch Jobs as configured in batchDs.xml. Instruction is also provided in \"Configuring a Liberty Datasource with API Key\" section of the DB2OnCloudSetup guide to configure DB2 service in IBM Clouds as JavaBatch persistence store. Liberty JavaBatch framework creates DB schema and tables automatically by default for both approaches, and the configured database is created automatically, if the in-memory Apache Derby approach is used.\n+\n+You can also choose to use postgresql or other RDBMS as your Job repository, if taking this approach, you will need to generate the DDL for the job tables first following [IBM Websphere Liberty Batch - Job Repository Configuration](https://www-03.ibm.com/support/techdocs/atsmastr.nsf/WebIndex/WP102716) , then make necessary changes to the generated DDL to make it valid for your RDBMS, and then create the job database, create javabatch user, create jbatch schema and then run the DDL to generate the job tables and enable it in batchDs.xml let's use postgresql as an example:\n+\n+(1) Generate DDL and modify it according to your RDBMS.\n+\n+``` shell\n+ ./ddlGen generate fhir-server\n+```", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdd27c9867e0bff4426c2d54d6ff569fbf9056b3"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0Njg3Mzk5", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-394687399", "createdAt": "2020-04-16T14:25:48Z", "commit": {"oid": "cdd27c9867e0bff4426c2d54d6ff569fbf9056b3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxNDoyNTo0OFrOGGn-IQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxNDoyNTo0OFrOGGn-IQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTU5OTUyMQ==", "bodyText": "I think this should be a file in fhir-persistence-schema", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r409599521", "createdAt": "2020-04-16T14:25:48Z", "author": {"login": "prb112"}, "path": "docs/src/pages/guides/FHIRServerUsersGuide.md", "diffHunk": "@@ -1220,9 +1220,81 @@ The JavaBatch user is configured in server.xml and the bulkdata.json:\n \t</security-role>\n </authorization-roles>\n ```\n-Note: The user referenced in the bulkdata.json must have a role of at least batchSubmitter.\n-\n-By default, in-memory Derby database is used for persistence of the JavaBatch Jobs. Instruction is also provided in \"Configuring a Liberty Datasource with API Key\" section of the DB2OnCloudSetup guide to configure DB2 service in IBM Clouds as JavaBatch persistence store. Liberty JavaBatch framework creates DB schema and tables automatically by default for both approaches, and the configured database is created automatically, if the in-memory Apache Derby approach is used.   \n+Note: The user referenced in the fhir-server-config.json must have a role of at least batchSubmitter.\n+\n+By default, in-memory Derby database is used for persistence of the JavaBatch Jobs as configured in batchDs.xml. Instruction is also provided in \"Configuring a Liberty Datasource with API Key\" section of the DB2OnCloudSetup guide to configure DB2 service in IBM Clouds as JavaBatch persistence store. Liberty JavaBatch framework creates DB schema and tables automatically by default for both approaches, and the configured database is created automatically, if the in-memory Apache Derby approach is used.\n+\n+You can also choose to use postgresql or other RDBMS as your Job repository, if taking this approach, you will need to generate the DDL for the job tables first following [IBM Websphere Liberty Batch - Job Repository Configuration](https://www-03.ibm.com/support/techdocs/atsmastr.nsf/WebIndex/WP102716) , then make necessary changes to the generated DDL to make it valid for your RDBMS, and then create the job database, create javabatch user, create jbatch schema and then run the DDL to generate the job tables and enable it in batchDs.xml let's use postgresql as an example:\n+\n+(1) Generate DDL and modify it according to your RDBMS.\n+\n+``` shell\n+ ./ddlGen generate fhir-server\n+```\n+Following is a modified version for postgresql:\n+\n+``` shell", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdd27c9867e0bff4426c2d54d6ff569fbf9056b3"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0Njg4NTQ3", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-394688547", "createdAt": "2020-04-16T14:26:55Z", "commit": {"oid": "cdd27c9867e0bff4426c2d54d6ff569fbf9056b3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxNDoyNjo1NVrOGGoBhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxNDoyNjo1NVrOGGoBhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYwMDM4OQ==", "bodyText": "How is this not tenant specific?  I thought each tenant is able to override", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r409600389", "createdAt": "2020-04-16T14:26:55Z", "author": {"login": "prb112"}, "path": "docs/src/pages/guides/FHIRServerUsersGuide.md", "diffHunk": "@@ -1442,7 +1514,7 @@ must restart the server for that change to take effect.\n |`fhirServer/bulkdata/jobParameters/cos.api.key`|Y|Y|\n |`fhirServer/bulkdata/jobParameters/cos.srvinst.id`|Y|Y|\n |`fhirServer/bulkdata/bulkDataBatchJobIdEncryptionKey`|Y|Y|\n-|`fhirServer/bulkdata/isExportPublic`|Y|Y|\n+|`fhirServer/bulkdata/isExportPublic`|N|Y|", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdd27c9867e0bff4426c2d54d6ff569fbf9056b3"}, "originalPosition": 99}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0Njk1OTQ4", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-394695948", "createdAt": "2020-04-16T14:34:01Z", "commit": {"oid": "cdd27c9867e0bff4426c2d54d6ff569fbf9056b3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxNDozNDowMVrOGGoX3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxNDozNDowMVrOGGoX3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYwNjExMQ==", "bodyText": "Default is recommended to come second...\nhttps://stackoverflow.com/a/16732059/1873438", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r409606111", "createdAt": "2020-04-16T14:34:01Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/api/IDatabaseTypeAdapter.java", "diffHunk": "@@ -27,6 +27,14 @@\n      */\n     public String blobClause(long size, int inlineSize);\n \n+    /**\n+     * Generate a clause for double data type\n+     * @return\n+     */\n+    default public String doubleClause() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdd27c9867e0bff4426c2d54d6ff569fbf9056b3"}, "originalPosition": 15}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0Njk2OTc5", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-394696979", "createdAt": "2020-04-16T14:35:04Z", "commit": {"oid": "cdd27c9867e0bff4426c2d54d6ff569fbf9056b3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxNDozNTowNFrOGGobCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxNDozNTowNFrOGGobCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYwNjkyMw==", "bodyText": "why is a null being cast?", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r409606923", "createdAt": "2020-04-16T14:35:04Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/AddColumn.java", "diffHunk": "@@ -38,7 +43,19 @@ public AddColumn(String schemaName, String tableName, ColumnBase column) {\n     @Override\n     public void run(IDatabaseTranslator translator, Connection c) {\n         String qname = DataDefinitionUtil.getQualifiedName(schemaName, tableName);\n-        String ddl = \"ALTER TABLE \" + qname + \" ADD COLUMN \" + columnDef(column);\n+\n+        // DatabaseTypeAdapter is needed to find the correct data type for the column.\n+        IDatabaseTypeAdapter dbAdapter = null;\n+        String driveClassName = translator.getDriverClassName();\n+        if (driveClassName.contains(\"db2\")) {\n+            dbAdapter = new Db2Adapter((IConnectionProvider)null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdd27c9867e0bff4426c2d54d6ff569fbf9056b3"}, "originalPosition": 25}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0Nzk4Mjg0", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-394798284", "createdAt": "2020-04-16T16:23:13Z", "commit": {"oid": "c3ea7ce045570353246610b88513f4f19c17f134"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxNjoyMzoxM1rOGGtSDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxNjoyMzoxM1rOGGtSDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY4NjU0Mw==", "bodyText": "throw UnsupportedOperation", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r409686543", "createdAt": "2020-04-16T16:23:13Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlTranslator.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.sql.SQLException;\n+import java.util.Properties;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.ConnectionDetails;\n+import com.ibm.fhir.database.utils.api.ConnectionException;\n+import com.ibm.fhir.database.utils.api.DataAccessException;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.database.utils.api.LockException;\n+import com.ibm.fhir.database.utils.api.UndefinedNameException;\n+import com.ibm.fhir.database.utils.api.UniqueConstraintViolationException;\n+\n+/**\n+ * translates database access to PostgreSql supported access.\n+ */\n+public class PostgreSqlTranslator implements IDatabaseTranslator {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlTranslator.class.getName());\n+\n+    @Override\n+    public String addForUpdate(String sql) {\n+        return sql + \" FOR UPDATE\";\n+    }\n+\n+    @Override\n+    public boolean isDerby() {\n+        return false;\n+    }\n+\n+    @Override\n+    public String globalTempTableName(String tableName) {\n+        return \"SYSTEM.\" + tableName;\n+    }\n+\n+    @Override\n+    public String createGlobalTempTable(String ddl) {\n+        return \"DECLARE \" + ddl;\n+    }\n+\n+    @Override\n+    public boolean isDuplicate(SQLException x) {\n+        // Class Code 23: Constraint Violation\n+        return \"23505\".equals(x.getSQLState());\n+    }\n+\n+    @Override\n+    public boolean isAlreadyExists(SQLException x) {\n+        return \"42710\".equals(x.getSQLState());\n+    }\n+\n+    @Override\n+    public boolean isLockTimeout(SQLException x) {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isDeadlock(SQLException x) {\n+        final String sqlState = x.getSQLState();\n+        return \"40XL1\".equals(sqlState) || \"40XL2\".equals(sqlState);\n+    }\n+\n+    @Override\n+    public boolean isConnectionError(SQLException x) {\n+        String sqlState = x.getSQLState();\n+        return sqlState != null && sqlState.startsWith(\"08\");\n+    }\n+\n+    @Override\n+    public DataAccessException translate(SQLException x) {\n+        if (isDeadlock(x)) {\n+            return new LockException(x, true);\n+        }\n+        else if (isLockTimeout(x)) {\n+            return new LockException(x, false);\n+        }\n+        else if (isConnectionError(x)) {\n+            return new ConnectionException(x);\n+        }\n+        else if (isDuplicate(x)) {\n+            return new UniqueConstraintViolationException(x);\n+        }\n+        else if (isUndefinedName(x)) {\n+            return new UndefinedNameException(x);\n+        }\n+        else {\n+            return new DataAccessException(x);\n+        }\n+    }\n+\n+    @Override\n+    public boolean isUndefinedName(SQLException x) {\n+        return \"42X05\".equals(x.getSQLState());\n+    }\n+\n+    @Override\n+    public void fillProperties(Properties p, ConnectionDetails cd) {\n+        p.put(\"user\", cd.getUser());\n+        p.put(\"password\", cd.getPassword());\n+\n+        if (cd.isSsl()) {\n+            p.put(\"sslConnection\", \"true\");\n+        }\n+\n+        if (cd.isHA()) {\n+            logger.warning(\"No HA support for PostgreSql\");\n+        }\n+    }\n+\n+    @Override\n+    public String timestampDiff(String left, String right, String alias) {\n+        if (alias == null || alias.isEmpty()) {\n+            return String.format(\"{fn timestampdiff(SQL_TSI_SECOND, %s, %s)}\", left, right);\n+        }\n+        else {\n+            return String.format(\"{fn timestampdiff(SQL_TSI_SECOND, %s, %s)} AS %s\", left, right, alias);\n+        }\n+    }\n+\n+    @Override\n+    public String createSequence(String name, int cache) {\n+        // cache isn't supported by PostgreSql\n+        return \"CREATE SEQUENCE \" + name;\n+    }\n+\n+    @Override\n+    public String reorgTableCommand(String tableName) {\n+        // REORG TABLE not supported by PostgreSql, so return null\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3ea7ce045570353246610b88513f4f19c17f134"}, "originalPosition": 135}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NDI1Mjgw", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396425280", "createdAt": "2020-04-20T12:55:06Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMjo1NTowNlrOGITBzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMjo1NTowNlrOGITBzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM1MzU1MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            or you can simply use this sample DDL file: fhir-bulkimportexport-webapp/src/test/resources/batchPersistence-postgresql.ddl\n          \n          \n            \n            or you can simply use this sample DDL file: [fhir-bulkimportexport-webapp/src/test/resources/batchPersistence-postgresql.ddl](https://github.com/IBM/FHIR/tree/master/fhir-bulkimportexport-webapp/src/test/resources/batchPersistence-postgresql.ddl)", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411353551", "createdAt": "2020-04-20T12:55:06Z", "author": {"login": "prb112"}, "path": "docs/src/pages/guides/FHIRServerUsersGuide.md", "diffHunk": "@@ -1220,9 +1220,56 @@ The JavaBatch user is configured in server.xml and the bulkdata.json:\n \t</security-role>\n </authorization-roles>\n ```\n-Note: The user referenced in the bulkdata.json must have a role of at least batchSubmitter.\n+Note: The user referenced in the fhir-server-config.json must have a role of at least batchSubmitter.\n \n-By default, in-memory Derby database is used for persistence of the JavaBatch Jobs. Instruction is also provided in \"Configuring a Liberty Datasource with API Key\" section of the DB2OnCloudSetup guide to configure DB2 service in IBM Clouds as JavaBatch persistence store. Liberty JavaBatch framework creates DB schema and tables automatically by default for both approaches, and the configured database is created automatically, if the in-memory Apache Derby approach is used.   \n+By default, in-memory Derby database is used for persistence of the JavaBatch Jobs as configured in batchDs.xml. Instruction is also provided in \"Configuring a Liberty Datasource with API Key\" section of the DB2OnCloudSetup guide to configure DB2 service in IBM Clouds as JavaBatch persistence store. Liberty JavaBatch framework creates DB schema and tables automatically by default for both approaches, and the configured database is created automatically, if the in-memory Apache Derby approach is used.\n+\n+You can also choose to use postgresql or other RDBMS as your Job repository, if taking this approach, you will need to generate the DDL for the job tables first following [IBM Websphere Liberty Batch - Job Repository Configuration](https://www-03.ibm.com/support/techdocs/atsmastr.nsf/WebIndex/WP102716) , then make necessary changes to the generated DDL to make it valid for your RDBMS, and then create the job database, create javabatch user, create jbatch schema and then run the DDL to generate the job tables and enable it in batchDs.xml. let's use postgresql as an example:\n+\n+(1) Generate DDL and modify it according to your RDBMS.\n+\n+``` shell\n+ ./ddlGen generate fhir-server\n+```\n+then modify the generated DLL file to make it valid for postgresql. \n+or you can simply use this sample DDL file: fhir-bulkimportexport-webapp/src/test/resources/batchPersistence-postgresql.ddl", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 27}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NDI1NTg5", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396425589", "createdAt": "2020-04-20T12:55:30Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMjo1NTozMFrOGITC-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMjo1NTozMFrOGITC-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM1Mzg0OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ```\n          \n          \n            \n            ``` xml", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411353848", "createdAt": "2020-04-20T12:55:30Z", "author": {"login": "prb112"}, "path": "docs/src/pages/guides/FHIRServerUsersGuide.md", "diffHunk": "@@ -1220,9 +1220,56 @@ The JavaBatch user is configured in server.xml and the bulkdata.json:\n \t</security-role>\n </authorization-roles>\n ```\n-Note: The user referenced in the bulkdata.json must have a role of at least batchSubmitter.\n+Note: The user referenced in the fhir-server-config.json must have a role of at least batchSubmitter.\n \n-By default, in-memory Derby database is used for persistence of the JavaBatch Jobs. Instruction is also provided in \"Configuring a Liberty Datasource with API Key\" section of the DB2OnCloudSetup guide to configure DB2 service in IBM Clouds as JavaBatch persistence store. Liberty JavaBatch framework creates DB schema and tables automatically by default for both approaches, and the configured database is created automatically, if the in-memory Apache Derby approach is used.   \n+By default, in-memory Derby database is used for persistence of the JavaBatch Jobs as configured in batchDs.xml. Instruction is also provided in \"Configuring a Liberty Datasource with API Key\" section of the DB2OnCloudSetup guide to configure DB2 service in IBM Clouds as JavaBatch persistence store. Liberty JavaBatch framework creates DB schema and tables automatically by default for both approaches, and the configured database is created automatically, if the in-memory Apache Derby approach is used.\n+\n+You can also choose to use postgresql or other RDBMS as your Job repository, if taking this approach, you will need to generate the DDL for the job tables first following [IBM Websphere Liberty Batch - Job Repository Configuration](https://www-03.ibm.com/support/techdocs/atsmastr.nsf/WebIndex/WP102716) , then make necessary changes to the generated DDL to make it valid for your RDBMS, and then create the job database, create javabatch user, create jbatch schema and then run the DDL to generate the job tables and enable it in batchDs.xml. let's use postgresql as an example:\n+\n+(1) Generate DDL and modify it according to your RDBMS.\n+\n+``` shell\n+ ./ddlGen generate fhir-server\n+```\n+then modify the generated DLL file to make it valid for postgresql. \n+or you can simply use this sample DDL file: fhir-bulkimportexport-webapp/src/test/resources/batchPersistence-postgresql.ddl\n+\n+(2) Create the Job database and user.  \n+\n+``` shell\n+psql postgres\n+>postgres=# create database jobdb;\n+>postgres=# create user javabatch with password 'change-password';\n+>postgres=# grant all privileges on database jobdb to javabatch;\n+```\n+(3) Create jbatch schema.\n+\n+``` shell\n+psql -d jobdb -U javabatch\n+jobdb=> CREATE SCHEMA jbatch;\n+```\n+(4) Run the modified DDL with javabatch user against the job database.\n+\n+``` shell\n+psql -v ON_ERROR_STOP=1 -1 -U javabatch -f batchPersistence-postgresql.ddl -d jobdb\n+```\n+(5) Enable postgresql job repository in batchDs.xml as following.\n+\n+```", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NDI4ODMw", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396428830", "createdAt": "2020-04-20T12:59:41Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMjo1OTo0MVrOGITOEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMjo1OTo0MVrOGITOEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM1NjY5MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            -- to 4.10.1 of IBM FHIR Server User's Guide about how this DDL is used.\n          \n          \n            \n            -- to 4.10.1 of IBM FHIR Server User's Guide about how this DDL is used.\n          \n          \n            \n            -- \n          \n          \n            \n            -- This DDL is modified with a larger JOB_PARAMETER.VALUE VARCHAR size of 4096.", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411356691", "createdAt": "2020-04-20T12:59:41Z", "author": {"login": "prb112"}, "path": "fhir-bulkimportexport-webapp/src/test/resources/batchPersistence-postgresql.ddl", "diffHunk": "@@ -0,0 +1,35 @@\n+-------------------------------------------------------------------------------\n+-- (C) Copyright IBM Corp. 2020\n+--\n+-- SPDX-License-Identifier: Apache-2.0\n+-------------------------------------------------------------------------------\n+\n+-- ----------------------------------------------------------------------------\n+-- Sample DDL for generating javabatch job tables for postgresql, please refer\n+-- to 4.10.1 of IBM FHIR Server User's Guide about how this DDL is used.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 9}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NDkxODU4", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396491858", "createdAt": "2020-04-20T14:12:17Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoxMjoxN1rOGIWihQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoxMjoxN1rOGIWihQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxMTA3Nw==", "bodyText": "I suggest putting this in CommonDatabaseAdapter as a common method", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411411077", "createdAt": "2020-04-20T14:12:17Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/AddColumn.java", "diffHunk": "@@ -38,7 +42,19 @@ public AddColumn(String schemaName, String tableName, ColumnBase column) {\n     @Override\n     public void run(IDatabaseTranslator translator, Connection c) {\n         String qname = DataDefinitionUtil.getQualifiedName(schemaName, tableName);\n-        String ddl = \"ALTER TABLE \" + qname + \" ADD COLUMN \" + columnDef(column);\n+\n+        // DatabaseTypeAdapter is needed to find the correct data type for the column.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 18}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NDkzNTAz", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396493503", "createdAt": "2020-04-20T14:13:59Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoxMzo1OVrOGIWoAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoxMzo1OVrOGIWoAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxMjQ4Mw==", "bodyText": "This is good defensive programming.  it's actually checking against a whitelist, and prevents any injection, since this is bundled/shipped, it's worth keeping, and adding a postgres branching logic.", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411412483", "createdAt": "2020-04-20T14:13:59Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/DataDefinitionUtil.java", "diffHunk": "@@ -34,59 +34,61 @@\n      */\n     public static String createUniqueIndex(String schemaName, String tableName, String indexName, List<String> indexColumns,\n             List<String> includeColumns) {\n-        \n+\n         StringBuilder result = new StringBuilder();\n         result.append(createUniqueIndex(schemaName, tableName, indexName, indexColumns));\n         result.append(\" INCLUDE (\");\n         result.append(join(includeColumns));\n         result.append(\")\");\n-        \n+\n         return result.toString();\n     }\n \n     /**\n-     * \n+     *\n      * @param schemaName\n      * @param tableName\n      * @param indexName\n      * @param indexColumns\n      * @return\n      */\n     public static String createUniqueIndex(String schemaName, String tableName, String indexName, List<String> indexColumns) {\n-        \n+\n         StringBuilder result = new StringBuilder();\n         result.append(\"CREATE UNIQUE INDEX \");\n-        result.append(getQualifiedName(schemaName, indexName));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 46}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NDk0Mzgy", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396494382", "createdAt": "2020-04-20T14:14:51Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoxNDo1MlrOGIWqzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoxNDo1MlrOGIWqzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxMzE5Nw==", "bodyText": "This is good defensive programming. it's actually checking against a whitelist, and prevents any injection, since this is bundled/shipped, it's worth keeping, and adding a postgres branching logic.", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411413197", "createdAt": "2020-04-20T14:14:52Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/common/DataDefinitionUtil.java", "diffHunk": "@@ -34,59 +34,61 @@\n      */\n     public static String createUniqueIndex(String schemaName, String tableName, String indexName, List<String> indexColumns,\n             List<String> includeColumns) {\n-        \n+\n         StringBuilder result = new StringBuilder();\n         result.append(createUniqueIndex(schemaName, tableName, indexName, indexColumns));\n         result.append(\" INCLUDE (\");\n         result.append(join(includeColumns));\n         result.append(\")\");\n-        \n+\n         return result.toString();\n     }\n \n     /**\n-     * \n+     *\n      * @param schemaName\n      * @param tableName\n      * @param indexName\n      * @param indexColumns\n      * @return\n      */\n     public static String createUniqueIndex(String schemaName, String tableName, String indexName, List<String> indexColumns) {\n-        \n+\n         StringBuilder result = new StringBuilder();\n         result.append(\"CREATE UNIQUE INDEX \");\n-        result.append(getQualifiedName(schemaName, indexName));\n+        // Postgresql doesn't support index name prefixed with the schema name.\n+        result.append(indexName);\n         result.append(\" ON \");\n         result.append(getQualifiedName(schemaName, tableName));\n         result.append(\"(\");\n         result.append(join(indexColumns));\n         result.append(\")\");\n-                \n+\n         return result.toString();\n     }\n \n \n     /**\n      * Create the DDL for a plain old index\n-     * \n+     *\n      * @param schemaName\n      * @param tableName\n      * @param indexName\n      * @param indexColumns\n      * @return\n      */\n     public static String createIndex(String schemaName, String tableName, String indexName, List<String> indexColumns) {\n-                \n+\n         StringBuilder result = new StringBuilder();\n         result.append(\"CREATE INDEX \");\n-        result.append(getQualifiedName(schemaName, indexName));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 75}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NDk1NDAy", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396495402", "createdAt": "2020-04-20T14:15:55Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoxNTo1NVrOGIWt8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoxNTo1NVrOGIWt8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxNDAwMQ==", "bodyText": "extra line.", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411414001", "createdAt": "2020-04-20T14:15:55Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlAdapter.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Supplier;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseTarget;\n+import com.ibm.fhir.database.utils.common.AddForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.common.CommonDatabaseAdapter;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+import com.ibm.fhir.database.utils.model.ColumnBase;\n+import com.ibm.fhir.database.utils.model.ForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.model.IdentityDef;\n+import com.ibm.fhir.database.utils.model.PrimaryKeyDef;\n+import com.ibm.fhir.database.utils.model.Table;\n+\n+/**\n+ * A PostgreSql database target\n+ */\n+public class PostgreSqlAdapter extends CommonDatabaseAdapter {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlAdapter.class.getName());\n+\n+    // Different warning messages we track so that we only have to report them once\n+    private enum MessageKey {\n+        MULTITENANCY, CREATE_VAR, CREATE_PERM, ENABLE_ROW_ACCESS, DISABLE_ROW_ACCESS, PARTITIONING,\n+        ROW_TYPE, ROW_ARR_TYPE, DROP_TYPE, CREATE_PROC, DROP_PROC, TABLESPACE\n+    }\n+\n+    // Just warn once for each unique message key. This cleans up build logs a lot\n+    private static final Set<MessageKey> warned = ConcurrentHashMap.newKeySet();\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 44}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NDk1NjM2", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396495636", "createdAt": "2020-04-20T14:16:09Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoxNjowOVrOGIWu2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoxNjowOVrOGIWu2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxNDIzNA==", "bodyText": "best to have each entry on a single line", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411414234", "createdAt": "2020-04-20T14:16:09Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlAdapter.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Supplier;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseTarget;\n+import com.ibm.fhir.database.utils.common.AddForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.common.CommonDatabaseAdapter;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+import com.ibm.fhir.database.utils.model.ColumnBase;\n+import com.ibm.fhir.database.utils.model.ForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.model.IdentityDef;\n+import com.ibm.fhir.database.utils.model.PrimaryKeyDef;\n+import com.ibm.fhir.database.utils.model.Table;\n+\n+/**\n+ * A PostgreSql database target\n+ */\n+public class PostgreSqlAdapter extends CommonDatabaseAdapter {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlAdapter.class.getName());\n+\n+    // Different warning messages we track so that we only have to report them once\n+    private enum MessageKey {\n+        MULTITENANCY, CREATE_VAR, CREATE_PERM, ENABLE_ROW_ACCESS, DISABLE_ROW_ACCESS, PARTITIONING,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 37}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NDk2MjQ2", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396496246", "createdAt": "2020-04-20T14:16:47Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoxNjo0N1rOGIWw6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoxNjo0N1rOGIWw6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxNDc2Mw==", "bodyText": "Extra line", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411414763", "createdAt": "2020-04-20T14:16:47Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlAdapter.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Supplier;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseTarget;\n+import com.ibm.fhir.database.utils.common.AddForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.common.CommonDatabaseAdapter;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+import com.ibm.fhir.database.utils.model.ColumnBase;\n+import com.ibm.fhir.database.utils.model.ForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.model.IdentityDef;\n+import com.ibm.fhir.database.utils.model.PrimaryKeyDef;\n+import com.ibm.fhir.database.utils.model.Table;\n+\n+/**\n+ * A PostgreSql database target\n+ */\n+public class PostgreSqlAdapter extends CommonDatabaseAdapter {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlAdapter.class.getName());\n+\n+    // Different warning messages we track so that we only have to report them once\n+    private enum MessageKey {\n+        MULTITENANCY, CREATE_VAR, CREATE_PERM, ENABLE_ROW_ACCESS, DISABLE_ROW_ACCESS, PARTITIONING,\n+        ROW_TYPE, ROW_ARR_TYPE, DROP_TYPE, CREATE_PROC, DROP_PROC, TABLESPACE\n+    }\n+\n+    // Just warn once for each unique message key. This cleans up build logs a lot\n+    private static final Set<MessageKey> warned = ConcurrentHashMap.newKeySet();\n+\n+\n+    /**\n+     * Public constructor\n+     * @param tgt the target database we want to manage\n+     */\n+    public PostgreSqlAdapter(IDatabaseTarget tgt) {\n+        super(tgt, new PostgreSqlTranslator());\n+    }\n+\n+    public PostgreSqlAdapter(IConnectionProvider cp) {\n+        super(cp, new PostgreSqlTranslator());\n+    }\n+\n+    public PostgreSqlAdapter() {\n+        super();\n+    }\n+\n+    /**\n+     * Once write each warning message once\n+     * @param msg\n+     */\n+    public void warnOnce(MessageKey messageKey, String msg) {\n+        if (logger.isLoggable(Level.WARNING) && !warned.contains(messageKey)) {\n+            warned.add(messageKey);\n+            logger.warning(\"[ONCE] \" + msg);\n+        }\n+    }\n+\n+    @Override\n+    public void createTable(String schemaName, String name, String tenantColumnName, List<ColumnBase> columns, PrimaryKeyDef primaryKey,\n+            IdentityDef identity, String tablespaceName) {\n+\n+        // PostgreSql doesn't support partitioning, so we ignore tenantColumnName\n+        if (tenantColumnName != null) {\n+            warnOnce(MessageKey.MULTITENANCY, \"PostgreSql does support not multi-tenancy: \" + name);\n+        }\n+\n+        // We also ignore tablespace for PostgreSql\n+        String ddl = buildCreateTableStatement(schemaName, name, columns, primaryKey, identity, null);\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 84}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NDk2NzQ2", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396496746", "createdAt": "2020-04-20T14:17:17Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoxNzoxN1rOGIWygA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoxNzoxN1rOGIWygA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxNTE2OA==", "bodyText": "line space is not needed", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411415168", "createdAt": "2020-04-20T14:17:17Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlAdapter.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Supplier;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseTarget;\n+import com.ibm.fhir.database.utils.common.AddForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.common.CommonDatabaseAdapter;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+import com.ibm.fhir.database.utils.model.ColumnBase;\n+import com.ibm.fhir.database.utils.model.ForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.model.IdentityDef;\n+import com.ibm.fhir.database.utils.model.PrimaryKeyDef;\n+import com.ibm.fhir.database.utils.model.Table;\n+\n+/**\n+ * A PostgreSql database target\n+ */\n+public class PostgreSqlAdapter extends CommonDatabaseAdapter {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlAdapter.class.getName());\n+\n+    // Different warning messages we track so that we only have to report them once\n+    private enum MessageKey {\n+        MULTITENANCY, CREATE_VAR, CREATE_PERM, ENABLE_ROW_ACCESS, DISABLE_ROW_ACCESS, PARTITIONING,\n+        ROW_TYPE, ROW_ARR_TYPE, DROP_TYPE, CREATE_PROC, DROP_PROC, TABLESPACE\n+    }\n+\n+    // Just warn once for each unique message key. This cleans up build logs a lot\n+    private static final Set<MessageKey> warned = ConcurrentHashMap.newKeySet();\n+\n+\n+    /**\n+     * Public constructor\n+     * @param tgt the target database we want to manage\n+     */\n+    public PostgreSqlAdapter(IDatabaseTarget tgt) {\n+        super(tgt, new PostgreSqlTranslator());\n+    }\n+\n+    public PostgreSqlAdapter(IConnectionProvider cp) {\n+        super(cp, new PostgreSqlTranslator());\n+    }\n+\n+    public PostgreSqlAdapter() {\n+        super();\n+    }\n+\n+    /**\n+     * Once write each warning message once\n+     * @param msg\n+     */\n+    public void warnOnce(MessageKey messageKey, String msg) {\n+        if (logger.isLoggable(Level.WARNING) && !warned.contains(messageKey)) {\n+            warned.add(messageKey);\n+            logger.warning(\"[ONCE] \" + msg);\n+        }\n+    }\n+\n+    @Override\n+    public void createTable(String schemaName, String name, String tenantColumnName, List<ColumnBase> columns, PrimaryKeyDef primaryKey,\n+            IdentityDef identity, String tablespaceName) {\n+\n+        // PostgreSql doesn't support partitioning, so we ignore tenantColumnName\n+        if (tenantColumnName != null) {\n+            warnOnce(MessageKey.MULTITENANCY, \"PostgreSql does support not multi-tenancy: \" + name);\n+        }\n+\n+        // We also ignore tablespace for PostgreSql\n+        String ddl = buildCreateTableStatement(schemaName, name, columns, primaryKey, identity, null);\n+\n+\n+        runStatement(ddl);\n+    }\n+\n+    @Override\n+    public void createUniqueIndex(String schemaName, String tableName, String indexName, String tenantColumnName, List<String> indexColumns,\n+            List<String> includeColumns) {\n+\n+        // PostgreSql doesn't support include columns, so we just have to create a normal index\n+        createUniqueIndex(schemaName, tableName, indexName, tenantColumnName, indexColumns);\n+    }\n+\n+    @Override\n+    public void createIntVariable(String schemaName, String variableName) {\n+        warnOnce(MessageKey.CREATE_VAR, \"PostgreSql does not support CREATE VARIABLE for: \" + variableName);\n+    }\n+\n+    @Override\n+    public void createOrReplacePermission(String schemaName, String permissionName, String tableName, String predicate) {\n+        warnOnce(MessageKey.CREATE_PERM, \"PostgreSql does not support CREATE PERMISSION for: \" + permissionName);\n+    }\n+\n+    @Override\n+    public void activateRowAccessControl(String schemaName, String tableName) {\n+        warnOnce(MessageKey.ENABLE_ROW_ACCESS, \"PostgreSql does not support ROW ACCESS CONTROL for table: \" + tableName);\n+    }\n+\n+    @Override\n+    public void setIntVariable(String schemaName, String variableName, int value) {\n+        // As this is a runtime issue, we throw as an exception instead of\n+        // simply logging a warning. This shouldn't be called in the case\n+        // of a PostgreSql database\n+        throw new IllegalStateException(\"setIntVariable not supported on PostgreSql for: \" + variableName);\n+    }\n+\n+    @Override\n+    public void deactivateRowAccessControl(String schemaName, String tableName) {\n+        warnOnce(MessageKey.DISABLE_ROW_ACCESS, \"PostgreSql does not support ROW ACCESS CONTROL for table: \" + tableName);\n+    }\n+\n+    @Override\n+    public void createTenantPartitions(Collection<Table> tables, String schemaName, int newTenantId, int extentSizeKB) {\n+        warnOnce(MessageKey.PARTITIONING, \"PostgreSql does not support tenant partitioning\");\n+    }\n+\n+    @Override\n+    public void createRowType(String schemaName, String typeName, List<ColumnBase> columns) {\n+        warnOnce(MessageKey.ROW_TYPE, \"Create row type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createArrType(String schemaName, String typeName, String valueType, int arraySize) {\n+        warnOnce(MessageKey.ROW_ARR_TYPE, \"Create array row type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropType(String schemaName, String typeName) {\n+        warnOnce(MessageKey.DROP_TYPE, \"Drop type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createOrReplaceProcedure(String schemaName, String procedureName, Supplier<String> supplier) {\n+        warnOnce(MessageKey.CREATE_PROC, \"Create procedure not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropProcedure(String schemaName, String procedureName) {\n+        warnOnce(MessageKey.DROP_PROC, \"Drop procedure not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createTablespace(String tablespaceName) {\n+        warnOnce(MessageKey.TABLESPACE, \"Create tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropTablespace(String tablespaceName) {\n+        warnOnce(MessageKey.TABLESPACE, \"Drop tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void detachPartition(String schemaName, String tableName, String partitionName, String newTableName) {\n+        warnOnce(MessageKey.PARTITIONING, \"Detach partition not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void removeTenantPartitions(Collection<Table> tables, String schemaName, int tenantId,\n+            String tenantStagingTable) {\n+        warnOnce(MessageKey.PARTITIONING, \"Remove tenant partitions not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createTablespace(String tablespaceName, int extentSizeKB) {\n+        warnOnce(MessageKey.TABLESPACE, \"Create tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public boolean doesTableExist(String schemaName, String tableName) {\n+        PostgreSqlDoesTableExist dao = new PostgreSqlDoesTableExist(schemaName, tableName);\n+        return runStatement(dao);\n+    }\n+\n+    @Override\n+    public void createSequence(String schemaName, String sequenceName, int cache) {\n+        /* CREATE SEQUENCE fhir_sequence\n+         *     AS BIGINT\n+         *     START WITH 1\n+         *     CACHE 1000\n+         *     NO CYCLE;\n+        */\n+        // PostgreSql doesn't support CACHE\n+        final String sname = DataDefinitionUtil.getQualifiedName(schemaName, sequenceName);\n+        final String ddl = \"CREATE SEQUENCE \" + sname + \" AS BIGINT START WITH 1 NO CYCLE\";\n+        runStatement(ddl);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 198}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NDk3NTU5", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396497559", "createdAt": "2020-04-20T14:18:09Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoxODoxMFrOGIW1OA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoxODoxMFrOGIW1OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxNTg2NA==", "bodyText": "start at 1000 always.  it give space to use the ID with specific mappings. for instance RESOURCE_TYPE are hard coded, and we don't want it to client.", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411415864", "createdAt": "2020-04-20T14:18:10Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlAdapter.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Supplier;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseTarget;\n+import com.ibm.fhir.database.utils.common.AddForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.common.CommonDatabaseAdapter;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+import com.ibm.fhir.database.utils.model.ColumnBase;\n+import com.ibm.fhir.database.utils.model.ForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.model.IdentityDef;\n+import com.ibm.fhir.database.utils.model.PrimaryKeyDef;\n+import com.ibm.fhir.database.utils.model.Table;\n+\n+/**\n+ * A PostgreSql database target\n+ */\n+public class PostgreSqlAdapter extends CommonDatabaseAdapter {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlAdapter.class.getName());\n+\n+    // Different warning messages we track so that we only have to report them once\n+    private enum MessageKey {\n+        MULTITENANCY, CREATE_VAR, CREATE_PERM, ENABLE_ROW_ACCESS, DISABLE_ROW_ACCESS, PARTITIONING,\n+        ROW_TYPE, ROW_ARR_TYPE, DROP_TYPE, CREATE_PROC, DROP_PROC, TABLESPACE\n+    }\n+\n+    // Just warn once for each unique message key. This cleans up build logs a lot\n+    private static final Set<MessageKey> warned = ConcurrentHashMap.newKeySet();\n+\n+\n+    /**\n+     * Public constructor\n+     * @param tgt the target database we want to manage\n+     */\n+    public PostgreSqlAdapter(IDatabaseTarget tgt) {\n+        super(tgt, new PostgreSqlTranslator());\n+    }\n+\n+    public PostgreSqlAdapter(IConnectionProvider cp) {\n+        super(cp, new PostgreSqlTranslator());\n+    }\n+\n+    public PostgreSqlAdapter() {\n+        super();\n+    }\n+\n+    /**\n+     * Once write each warning message once\n+     * @param msg\n+     */\n+    public void warnOnce(MessageKey messageKey, String msg) {\n+        if (logger.isLoggable(Level.WARNING) && !warned.contains(messageKey)) {\n+            warned.add(messageKey);\n+            logger.warning(\"[ONCE] \" + msg);\n+        }\n+    }\n+\n+    @Override\n+    public void createTable(String schemaName, String name, String tenantColumnName, List<ColumnBase> columns, PrimaryKeyDef primaryKey,\n+            IdentityDef identity, String tablespaceName) {\n+\n+        // PostgreSql doesn't support partitioning, so we ignore tenantColumnName\n+        if (tenantColumnName != null) {\n+            warnOnce(MessageKey.MULTITENANCY, \"PostgreSql does support not multi-tenancy: \" + name);\n+        }\n+\n+        // We also ignore tablespace for PostgreSql\n+        String ddl = buildCreateTableStatement(schemaName, name, columns, primaryKey, identity, null);\n+\n+\n+        runStatement(ddl);\n+    }\n+\n+    @Override\n+    public void createUniqueIndex(String schemaName, String tableName, String indexName, String tenantColumnName, List<String> indexColumns,\n+            List<String> includeColumns) {\n+\n+        // PostgreSql doesn't support include columns, so we just have to create a normal index\n+        createUniqueIndex(schemaName, tableName, indexName, tenantColumnName, indexColumns);\n+    }\n+\n+    @Override\n+    public void createIntVariable(String schemaName, String variableName) {\n+        warnOnce(MessageKey.CREATE_VAR, \"PostgreSql does not support CREATE VARIABLE for: \" + variableName);\n+    }\n+\n+    @Override\n+    public void createOrReplacePermission(String schemaName, String permissionName, String tableName, String predicate) {\n+        warnOnce(MessageKey.CREATE_PERM, \"PostgreSql does not support CREATE PERMISSION for: \" + permissionName);\n+    }\n+\n+    @Override\n+    public void activateRowAccessControl(String schemaName, String tableName) {\n+        warnOnce(MessageKey.ENABLE_ROW_ACCESS, \"PostgreSql does not support ROW ACCESS CONTROL for table: \" + tableName);\n+    }\n+\n+    @Override\n+    public void setIntVariable(String schemaName, String variableName, int value) {\n+        // As this is a runtime issue, we throw as an exception instead of\n+        // simply logging a warning. This shouldn't be called in the case\n+        // of a PostgreSql database\n+        throw new IllegalStateException(\"setIntVariable not supported on PostgreSql for: \" + variableName);\n+    }\n+\n+    @Override\n+    public void deactivateRowAccessControl(String schemaName, String tableName) {\n+        warnOnce(MessageKey.DISABLE_ROW_ACCESS, \"PostgreSql does not support ROW ACCESS CONTROL for table: \" + tableName);\n+    }\n+\n+    @Override\n+    public void createTenantPartitions(Collection<Table> tables, String schemaName, int newTenantId, int extentSizeKB) {\n+        warnOnce(MessageKey.PARTITIONING, \"PostgreSql does not support tenant partitioning\");\n+    }\n+\n+    @Override\n+    public void createRowType(String schemaName, String typeName, List<ColumnBase> columns) {\n+        warnOnce(MessageKey.ROW_TYPE, \"Create row type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createArrType(String schemaName, String typeName, String valueType, int arraySize) {\n+        warnOnce(MessageKey.ROW_ARR_TYPE, \"Create array row type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropType(String schemaName, String typeName) {\n+        warnOnce(MessageKey.DROP_TYPE, \"Drop type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createOrReplaceProcedure(String schemaName, String procedureName, Supplier<String> supplier) {\n+        warnOnce(MessageKey.CREATE_PROC, \"Create procedure not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropProcedure(String schemaName, String procedureName) {\n+        warnOnce(MessageKey.DROP_PROC, \"Drop procedure not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createTablespace(String tablespaceName) {\n+        warnOnce(MessageKey.TABLESPACE, \"Create tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropTablespace(String tablespaceName) {\n+        warnOnce(MessageKey.TABLESPACE, \"Drop tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void detachPartition(String schemaName, String tableName, String partitionName, String newTableName) {\n+        warnOnce(MessageKey.PARTITIONING, \"Detach partition not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void removeTenantPartitions(Collection<Table> tables, String schemaName, int tenantId,\n+            String tenantStagingTable) {\n+        warnOnce(MessageKey.PARTITIONING, \"Remove tenant partitions not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createTablespace(String tablespaceName, int extentSizeKB) {\n+        warnOnce(MessageKey.TABLESPACE, \"Create tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public boolean doesTableExist(String schemaName, String tableName) {\n+        PostgreSqlDoesTableExist dao = new PostgreSqlDoesTableExist(schemaName, tableName);\n+        return runStatement(dao);\n+    }\n+\n+    @Override\n+    public void createSequence(String schemaName, String sequenceName, int cache) {\n+        /* CREATE SEQUENCE fhir_sequence\n+         *     AS BIGINT\n+         *     START WITH 1\n+         *     CACHE 1000\n+         *     NO CYCLE;\n+        */\n+        // PostgreSql doesn't support CACHE\n+        final String sname = DataDefinitionUtil.getQualifiedName(schemaName, sequenceName);\n+        final String ddl = \"CREATE SEQUENCE \" + sname + \" AS BIGINT START WITH 1 NO CYCLE\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 196}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NDk3Njgy", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396497682", "createdAt": "2020-04-20T14:18:18Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoxODoxOFrOGIW1ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoxODoxOFrOGIW1ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxNTk3MQ==", "bodyText": "Remove cache line", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411415971", "createdAt": "2020-04-20T14:18:18Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlAdapter.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Supplier;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseTarget;\n+import com.ibm.fhir.database.utils.common.AddForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.common.CommonDatabaseAdapter;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+import com.ibm.fhir.database.utils.model.ColumnBase;\n+import com.ibm.fhir.database.utils.model.ForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.model.IdentityDef;\n+import com.ibm.fhir.database.utils.model.PrimaryKeyDef;\n+import com.ibm.fhir.database.utils.model.Table;\n+\n+/**\n+ * A PostgreSql database target\n+ */\n+public class PostgreSqlAdapter extends CommonDatabaseAdapter {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlAdapter.class.getName());\n+\n+    // Different warning messages we track so that we only have to report them once\n+    private enum MessageKey {\n+        MULTITENANCY, CREATE_VAR, CREATE_PERM, ENABLE_ROW_ACCESS, DISABLE_ROW_ACCESS, PARTITIONING,\n+        ROW_TYPE, ROW_ARR_TYPE, DROP_TYPE, CREATE_PROC, DROP_PROC, TABLESPACE\n+    }\n+\n+    // Just warn once for each unique message key. This cleans up build logs a lot\n+    private static final Set<MessageKey> warned = ConcurrentHashMap.newKeySet();\n+\n+\n+    /**\n+     * Public constructor\n+     * @param tgt the target database we want to manage\n+     */\n+    public PostgreSqlAdapter(IDatabaseTarget tgt) {\n+        super(tgt, new PostgreSqlTranslator());\n+    }\n+\n+    public PostgreSqlAdapter(IConnectionProvider cp) {\n+        super(cp, new PostgreSqlTranslator());\n+    }\n+\n+    public PostgreSqlAdapter() {\n+        super();\n+    }\n+\n+    /**\n+     * Once write each warning message once\n+     * @param msg\n+     */\n+    public void warnOnce(MessageKey messageKey, String msg) {\n+        if (logger.isLoggable(Level.WARNING) && !warned.contains(messageKey)) {\n+            warned.add(messageKey);\n+            logger.warning(\"[ONCE] \" + msg);\n+        }\n+    }\n+\n+    @Override\n+    public void createTable(String schemaName, String name, String tenantColumnName, List<ColumnBase> columns, PrimaryKeyDef primaryKey,\n+            IdentityDef identity, String tablespaceName) {\n+\n+        // PostgreSql doesn't support partitioning, so we ignore tenantColumnName\n+        if (tenantColumnName != null) {\n+            warnOnce(MessageKey.MULTITENANCY, \"PostgreSql does support not multi-tenancy: \" + name);\n+        }\n+\n+        // We also ignore tablespace for PostgreSql\n+        String ddl = buildCreateTableStatement(schemaName, name, columns, primaryKey, identity, null);\n+\n+\n+        runStatement(ddl);\n+    }\n+\n+    @Override\n+    public void createUniqueIndex(String schemaName, String tableName, String indexName, String tenantColumnName, List<String> indexColumns,\n+            List<String> includeColumns) {\n+\n+        // PostgreSql doesn't support include columns, so we just have to create a normal index\n+        createUniqueIndex(schemaName, tableName, indexName, tenantColumnName, indexColumns);\n+    }\n+\n+    @Override\n+    public void createIntVariable(String schemaName, String variableName) {\n+        warnOnce(MessageKey.CREATE_VAR, \"PostgreSql does not support CREATE VARIABLE for: \" + variableName);\n+    }\n+\n+    @Override\n+    public void createOrReplacePermission(String schemaName, String permissionName, String tableName, String predicate) {\n+        warnOnce(MessageKey.CREATE_PERM, \"PostgreSql does not support CREATE PERMISSION for: \" + permissionName);\n+    }\n+\n+    @Override\n+    public void activateRowAccessControl(String schemaName, String tableName) {\n+        warnOnce(MessageKey.ENABLE_ROW_ACCESS, \"PostgreSql does not support ROW ACCESS CONTROL for table: \" + tableName);\n+    }\n+\n+    @Override\n+    public void setIntVariable(String schemaName, String variableName, int value) {\n+        // As this is a runtime issue, we throw as an exception instead of\n+        // simply logging a warning. This shouldn't be called in the case\n+        // of a PostgreSql database\n+        throw new IllegalStateException(\"setIntVariable not supported on PostgreSql for: \" + variableName);\n+    }\n+\n+    @Override\n+    public void deactivateRowAccessControl(String schemaName, String tableName) {\n+        warnOnce(MessageKey.DISABLE_ROW_ACCESS, \"PostgreSql does not support ROW ACCESS CONTROL for table: \" + tableName);\n+    }\n+\n+    @Override\n+    public void createTenantPartitions(Collection<Table> tables, String schemaName, int newTenantId, int extentSizeKB) {\n+        warnOnce(MessageKey.PARTITIONING, \"PostgreSql does not support tenant partitioning\");\n+    }\n+\n+    @Override\n+    public void createRowType(String schemaName, String typeName, List<ColumnBase> columns) {\n+        warnOnce(MessageKey.ROW_TYPE, \"Create row type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createArrType(String schemaName, String typeName, String valueType, int arraySize) {\n+        warnOnce(MessageKey.ROW_ARR_TYPE, \"Create array row type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropType(String schemaName, String typeName) {\n+        warnOnce(MessageKey.DROP_TYPE, \"Drop type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createOrReplaceProcedure(String schemaName, String procedureName, Supplier<String> supplier) {\n+        warnOnce(MessageKey.CREATE_PROC, \"Create procedure not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropProcedure(String schemaName, String procedureName) {\n+        warnOnce(MessageKey.DROP_PROC, \"Drop procedure not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createTablespace(String tablespaceName) {\n+        warnOnce(MessageKey.TABLESPACE, \"Create tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropTablespace(String tablespaceName) {\n+        warnOnce(MessageKey.TABLESPACE, \"Drop tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void detachPartition(String schemaName, String tableName, String partitionName, String newTableName) {\n+        warnOnce(MessageKey.PARTITIONING, \"Detach partition not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void removeTenantPartitions(Collection<Table> tables, String schemaName, int tenantId,\n+            String tenantStagingTable) {\n+        warnOnce(MessageKey.PARTITIONING, \"Remove tenant partitions not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createTablespace(String tablespaceName, int extentSizeKB) {\n+        warnOnce(MessageKey.TABLESPACE, \"Create tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public boolean doesTableExist(String schemaName, String tableName) {\n+        PostgreSqlDoesTableExist dao = new PostgreSqlDoesTableExist(schemaName, tableName);\n+        return runStatement(dao);\n+    }\n+\n+    @Override\n+    public void createSequence(String schemaName, String sequenceName, int cache) {\n+        /* CREATE SEQUENCE fhir_sequence\n+         *     AS BIGINT\n+         *     START WITH 1\n+         *     CACHE 1000", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 191}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NDk3ODc4", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396497878", "createdAt": "2020-04-20T14:18:29Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoxODozMFrOGIW2WQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoxODozMFrOGIW2WQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxNjE1Mw==", "bodyText": "move to 1000  per following comments", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411416153", "createdAt": "2020-04-20T14:18:30Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlAdapter.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Supplier;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.IConnectionProvider;\n+import com.ibm.fhir.database.utils.api.IDatabaseStatement;\n+import com.ibm.fhir.database.utils.api.IDatabaseTarget;\n+import com.ibm.fhir.database.utils.common.AddForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.common.CommonDatabaseAdapter;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+import com.ibm.fhir.database.utils.model.ColumnBase;\n+import com.ibm.fhir.database.utils.model.ForeignKeyConstraint;\n+import com.ibm.fhir.database.utils.model.IdentityDef;\n+import com.ibm.fhir.database.utils.model.PrimaryKeyDef;\n+import com.ibm.fhir.database.utils.model.Table;\n+\n+/**\n+ * A PostgreSql database target\n+ */\n+public class PostgreSqlAdapter extends CommonDatabaseAdapter {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlAdapter.class.getName());\n+\n+    // Different warning messages we track so that we only have to report them once\n+    private enum MessageKey {\n+        MULTITENANCY, CREATE_VAR, CREATE_PERM, ENABLE_ROW_ACCESS, DISABLE_ROW_ACCESS, PARTITIONING,\n+        ROW_TYPE, ROW_ARR_TYPE, DROP_TYPE, CREATE_PROC, DROP_PROC, TABLESPACE\n+    }\n+\n+    // Just warn once for each unique message key. This cleans up build logs a lot\n+    private static final Set<MessageKey> warned = ConcurrentHashMap.newKeySet();\n+\n+\n+    /**\n+     * Public constructor\n+     * @param tgt the target database we want to manage\n+     */\n+    public PostgreSqlAdapter(IDatabaseTarget tgt) {\n+        super(tgt, new PostgreSqlTranslator());\n+    }\n+\n+    public PostgreSqlAdapter(IConnectionProvider cp) {\n+        super(cp, new PostgreSqlTranslator());\n+    }\n+\n+    public PostgreSqlAdapter() {\n+        super();\n+    }\n+\n+    /**\n+     * Once write each warning message once\n+     * @param msg\n+     */\n+    public void warnOnce(MessageKey messageKey, String msg) {\n+        if (logger.isLoggable(Level.WARNING) && !warned.contains(messageKey)) {\n+            warned.add(messageKey);\n+            logger.warning(\"[ONCE] \" + msg);\n+        }\n+    }\n+\n+    @Override\n+    public void createTable(String schemaName, String name, String tenantColumnName, List<ColumnBase> columns, PrimaryKeyDef primaryKey,\n+            IdentityDef identity, String tablespaceName) {\n+\n+        // PostgreSql doesn't support partitioning, so we ignore tenantColumnName\n+        if (tenantColumnName != null) {\n+            warnOnce(MessageKey.MULTITENANCY, \"PostgreSql does support not multi-tenancy: \" + name);\n+        }\n+\n+        // We also ignore tablespace for PostgreSql\n+        String ddl = buildCreateTableStatement(schemaName, name, columns, primaryKey, identity, null);\n+\n+\n+        runStatement(ddl);\n+    }\n+\n+    @Override\n+    public void createUniqueIndex(String schemaName, String tableName, String indexName, String tenantColumnName, List<String> indexColumns,\n+            List<String> includeColumns) {\n+\n+        // PostgreSql doesn't support include columns, so we just have to create a normal index\n+        createUniqueIndex(schemaName, tableName, indexName, tenantColumnName, indexColumns);\n+    }\n+\n+    @Override\n+    public void createIntVariable(String schemaName, String variableName) {\n+        warnOnce(MessageKey.CREATE_VAR, \"PostgreSql does not support CREATE VARIABLE for: \" + variableName);\n+    }\n+\n+    @Override\n+    public void createOrReplacePermission(String schemaName, String permissionName, String tableName, String predicate) {\n+        warnOnce(MessageKey.CREATE_PERM, \"PostgreSql does not support CREATE PERMISSION for: \" + permissionName);\n+    }\n+\n+    @Override\n+    public void activateRowAccessControl(String schemaName, String tableName) {\n+        warnOnce(MessageKey.ENABLE_ROW_ACCESS, \"PostgreSql does not support ROW ACCESS CONTROL for table: \" + tableName);\n+    }\n+\n+    @Override\n+    public void setIntVariable(String schemaName, String variableName, int value) {\n+        // As this is a runtime issue, we throw as an exception instead of\n+        // simply logging a warning. This shouldn't be called in the case\n+        // of a PostgreSql database\n+        throw new IllegalStateException(\"setIntVariable not supported on PostgreSql for: \" + variableName);\n+    }\n+\n+    @Override\n+    public void deactivateRowAccessControl(String schemaName, String tableName) {\n+        warnOnce(MessageKey.DISABLE_ROW_ACCESS, \"PostgreSql does not support ROW ACCESS CONTROL for table: \" + tableName);\n+    }\n+\n+    @Override\n+    public void createTenantPartitions(Collection<Table> tables, String schemaName, int newTenantId, int extentSizeKB) {\n+        warnOnce(MessageKey.PARTITIONING, \"PostgreSql does not support tenant partitioning\");\n+    }\n+\n+    @Override\n+    public void createRowType(String schemaName, String typeName, List<ColumnBase> columns) {\n+        warnOnce(MessageKey.ROW_TYPE, \"Create row type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createArrType(String schemaName, String typeName, String valueType, int arraySize) {\n+        warnOnce(MessageKey.ROW_ARR_TYPE, \"Create array row type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropType(String schemaName, String typeName) {\n+        warnOnce(MessageKey.DROP_TYPE, \"Drop type not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createOrReplaceProcedure(String schemaName, String procedureName, Supplier<String> supplier) {\n+        warnOnce(MessageKey.CREATE_PROC, \"Create procedure not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropProcedure(String schemaName, String procedureName) {\n+        warnOnce(MessageKey.DROP_PROC, \"Drop procedure not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createTablespace(String tablespaceName) {\n+        warnOnce(MessageKey.TABLESPACE, \"Create tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void dropTablespace(String tablespaceName) {\n+        warnOnce(MessageKey.TABLESPACE, \"Drop tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void detachPartition(String schemaName, String tableName, String partitionName, String newTableName) {\n+        warnOnce(MessageKey.PARTITIONING, \"Detach partition not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void removeTenantPartitions(Collection<Table> tables, String schemaName, int tenantId,\n+            String tenantStagingTable) {\n+        warnOnce(MessageKey.PARTITIONING, \"Remove tenant partitions not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public void createTablespace(String tablespaceName, int extentSizeKB) {\n+        warnOnce(MessageKey.TABLESPACE, \"Create tablespace not supported in PostgreSql\");\n+    }\n+\n+    @Override\n+    public boolean doesTableExist(String schemaName, String tableName) {\n+        PostgreSqlDoesTableExist dao = new PostgreSqlDoesTableExist(schemaName, tableName);\n+        return runStatement(dao);\n+    }\n+\n+    @Override\n+    public void createSequence(String schemaName, String sequenceName, int cache) {\n+        /* CREATE SEQUENCE fhir_sequence\n+         *     AS BIGINT\n+         *     START WITH 1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 190}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NDk5MzU3", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396499357", "createdAt": "2020-04-20T14:20:03Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoyMDowM1rOGIW7JA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoyMDowM1rOGIW7JA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxNzM4MA==", "bodyText": "remove line\n\n  \n    \n      \n        Suggested change", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411417380", "createdAt": "2020-04-20T14:20:03Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlDoesTableExist.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.database.utils.api.IDatabaseSupplier;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+\n+/**\n+ * For this implementation we simply run a select against the table\n+ * and see if it kicks back with an error (which isn't related to\n+ * connection failure).\n+ */\n+public class PostgreSqlDoesTableExist implements IDatabaseSupplier<Boolean> {\n+\n+    // The schema of the table\n+    private final String schemaName;\n+\n+    // The name of the table\n+    private final String tableName;\n+\n+    /**\n+     * Public constructor\n+     * @param schemaName\n+     * @param tableName\n+     */\n+    public PostgreSqlDoesTableExist(String schemaName, String tableName) {\n+        this.schemaName = DataDefinitionUtil.assertValidName(schemaName);\n+        this.tableName = DataDefinitionUtil.assertValidName(tableName);\n+    }\n+\n+    @Override\n+    public Boolean run(IDatabaseTranslator translator, Connection c) {\n+        Boolean result;\n+        // For PostgreSQL, identifier names are always in lowercase unless they are surround with double quotes.\n+        final String sql = \"SELECT EXISTS (\" +\n+                \"SELECT FROM information_schema.tables \" +\n+                \"WHERE  LOWER(table_schema) = LOWER('\" + schemaName +\n+                \"') AND LOWER(table_name) = LOWER('\" + tableName + \"'))\";\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTAwMjgy", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396500282", "createdAt": "2020-04-20T14:21:03Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoyMTowNFrOGIW-Jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoyMTowNFrOGIW-Jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxODE1MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        }\n          \n          \n            \n                        else {\n          \n          \n            \n                        } else {", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411418150", "createdAt": "2020-04-20T14:21:04Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlDoesTableExist.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.database.utils.api.IDatabaseSupplier;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+\n+/**\n+ * For this implementation we simply run a select against the table\n+ * and see if it kicks back with an error (which isn't related to\n+ * connection failure).\n+ */\n+public class PostgreSqlDoesTableExist implements IDatabaseSupplier<Boolean> {\n+\n+    // The schema of the table\n+    private final String schemaName;\n+\n+    // The name of the table\n+    private final String tableName;\n+\n+    /**\n+     * Public constructor\n+     * @param schemaName\n+     * @param tableName\n+     */\n+    public PostgreSqlDoesTableExist(String schemaName, String tableName) {\n+        this.schemaName = DataDefinitionUtil.assertValidName(schemaName);\n+        this.tableName = DataDefinitionUtil.assertValidName(tableName);\n+    }\n+\n+    @Override\n+    public Boolean run(IDatabaseTranslator translator, Connection c) {\n+        Boolean result;\n+        // For PostgreSQL, identifier names are always in lowercase unless they are surround with double quotes.\n+        final String sql = \"SELECT EXISTS (\" +\n+                \"SELECT FROM information_schema.tables \" +\n+                \"WHERE  LOWER(table_schema) = LOWER('\" + schemaName +\n+                \"') AND LOWER(table_name) = LOWER('\" + tableName + \"'))\";\n+\n+\n+        try (PreparedStatement ps = c.prepareStatement(sql)) {\n+            ResultSet rs = ps.executeQuery();\n+            if (rs.next()) {\n+                result = rs.getBoolean(1);\n+            }\n+            else {\n+                result = false;\n+            }\n+        }\n+        catch (SQLException x) {\n+            if (translator.isConnectionError(x)) {\n+                throw translator.translate(x);\n+            }\n+            else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 64}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTAwNDg4", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396500488", "createdAt": "2020-04-20T14:21:16Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoyMToxNlrOGIW-4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoyMToxNlrOGIW-4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxODMzNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        }\n          \n          \n            \n                        else {\n          \n          \n            \n                            result = false;\n          \n          \n            \n                        } else {\n          \n          \n            \n                            result = false;", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411418337", "createdAt": "2020-04-20T14:21:16Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlDoesTableExist.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.database.utils.api.IDatabaseSupplier;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+\n+/**\n+ * For this implementation we simply run a select against the table\n+ * and see if it kicks back with an error (which isn't related to\n+ * connection failure).\n+ */\n+public class PostgreSqlDoesTableExist implements IDatabaseSupplier<Boolean> {\n+\n+    // The schema of the table\n+    private final String schemaName;\n+\n+    // The name of the table\n+    private final String tableName;\n+\n+    /**\n+     * Public constructor\n+     * @param schemaName\n+     * @param tableName\n+     */\n+    public PostgreSqlDoesTableExist(String schemaName, String tableName) {\n+        this.schemaName = DataDefinitionUtil.assertValidName(schemaName);\n+        this.tableName = DataDefinitionUtil.assertValidName(tableName);\n+    }\n+\n+    @Override\n+    public Boolean run(IDatabaseTranslator translator, Connection c) {\n+        Boolean result;\n+        // For PostgreSQL, identifier names are always in lowercase unless they are surround with double quotes.\n+        final String sql = \"SELECT EXISTS (\" +\n+                \"SELECT FROM information_schema.tables \" +\n+                \"WHERE  LOWER(table_schema) = LOWER('\" + schemaName +\n+                \"') AND LOWER(table_name) = LOWER('\" + tableName + \"'))\";\n+\n+\n+        try (PreparedStatement ps = c.prepareStatement(sql)) {\n+            ResultSet rs = ps.executeQuery();\n+            if (rs.next()) {\n+                result = rs.getBoolean(1);\n+            }\n+            else {\n+                result = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 57}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTAxMTc2", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396501176", "createdAt": "2020-04-20T14:21:57Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoyMTo1N1rOGIXBZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoyMTo1N1rOGIXBZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxODk4Mw==", "bodyText": "you can set to Boolean.False here, and avoid an extra branch down below.", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411418983", "createdAt": "2020-04-20T14:21:57Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlDoesTableExist.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.database.utils.api.IDatabaseSupplier;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.database.utils.common.DataDefinitionUtil;\n+\n+/**\n+ * For this implementation we simply run a select against the table\n+ * and see if it kicks back with an error (which isn't related to\n+ * connection failure).\n+ */\n+public class PostgreSqlDoesTableExist implements IDatabaseSupplier<Boolean> {\n+\n+    // The schema of the table\n+    private final String schemaName;\n+\n+    // The name of the table\n+    private final String tableName;\n+\n+    /**\n+     * Public constructor\n+     * @param schemaName\n+     * @param tableName\n+     */\n+    public PostgreSqlDoesTableExist(String schemaName, String tableName) {\n+        this.schemaName = DataDefinitionUtil.assertValidName(schemaName);\n+        this.tableName = DataDefinitionUtil.assertValidName(tableName);\n+    }\n+\n+    @Override\n+    public Boolean run(IDatabaseTranslator translator, Connection c) {\n+        Boolean result;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 43}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTAzMzMy", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396503332", "createdAt": "2020-04-20T14:24:18Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoyNDoxOFrOGIXIeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoyNDoxOFrOGIXIeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyMDc5NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // Class Code 23: Constraint Violation\n          \n          \n            \n                    // Class Code 23: Constraint Violation\n          \n          \n            \n                    // Refer to https://www.postgresql.org/docs/12/errcodes-appendix.html for more detail\n          \n      \n    \n    \n  \n\nI always want to know more, the link will help me (since I'm new )", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411420794", "createdAt": "2020-04-20T14:24:18Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlTranslator.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.sql.SQLException;\n+import java.util.Properties;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.ConnectionDetails;\n+import com.ibm.fhir.database.utils.api.ConnectionException;\n+import com.ibm.fhir.database.utils.api.DataAccessException;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.database.utils.api.LockException;\n+import com.ibm.fhir.database.utils.api.UndefinedNameException;\n+import com.ibm.fhir.database.utils.api.UniqueConstraintViolationException;\n+\n+/**\n+ * translates database access to PostgreSql supported access.\n+ */\n+public class PostgreSqlTranslator implements IDatabaseTranslator {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlTranslator.class.getName());\n+\n+    @Override\n+    public String addForUpdate(String sql) {\n+        return sql + \" FOR UPDATE\";\n+    }\n+\n+    @Override\n+    public boolean isDerby() {\n+        return false;\n+    }\n+\n+    @Override\n+    public String globalTempTableName(String tableName) {\n+        return \"SYSTEM.\" + tableName;\n+    }\n+\n+    @Override\n+    public String createGlobalTempTable(String ddl) {\n+        return \"DECLARE \" + ddl;\n+    }\n+\n+    @Override\n+    public boolean isDuplicate(SQLException x) {\n+        // Class Code 23: Constraint Violation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 49}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTA0NTEx", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396504511", "createdAt": "2020-04-20T14:25:33Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoyNTozM1rOGIXMgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoyNTozM1rOGIXMgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyMTgyNg==", "bodyText": "do we ever need to pass other properties in? How do we handle in Derby and Db2?", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411421826", "createdAt": "2020-04-20T14:25:33Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlTranslator.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.database.utils.postgresql;\n+\n+import java.sql.SQLException;\n+import java.util.Properties;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.database.utils.api.ConnectionDetails;\n+import com.ibm.fhir.database.utils.api.ConnectionException;\n+import com.ibm.fhir.database.utils.api.DataAccessException;\n+import com.ibm.fhir.database.utils.api.IDatabaseTranslator;\n+import com.ibm.fhir.database.utils.api.LockException;\n+import com.ibm.fhir.database.utils.api.UndefinedNameException;\n+import com.ibm.fhir.database.utils.api.UniqueConstraintViolationException;\n+\n+/**\n+ * translates database access to PostgreSql supported access.\n+ */\n+public class PostgreSqlTranslator implements IDatabaseTranslator {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlTranslator.class.getName());\n+\n+    @Override\n+    public String addForUpdate(String sql) {\n+        return sql + \" FOR UPDATE\";\n+    }\n+\n+    @Override\n+    public boolean isDerby() {\n+        return false;\n+    }\n+\n+    @Override\n+    public String globalTempTableName(String tableName) {\n+        return \"SYSTEM.\" + tableName;\n+    }\n+\n+    @Override\n+    public String createGlobalTempTable(String ddl) {\n+        return \"DECLARE \" + ddl;\n+    }\n+\n+    @Override\n+    public boolean isDuplicate(SQLException x) {\n+        // Class Code 23: Constraint Violation\n+        return \"23505\".equals(x.getSQLState());\n+    }\n+\n+    @Override\n+    public boolean isAlreadyExists(SQLException x) {\n+        return \"42710\".equals(x.getSQLState());\n+    }\n+\n+    @Override\n+    public boolean isLockTimeout(SQLException x) {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isDeadlock(SQLException x) {\n+        final String sqlState = x.getSQLState();\n+        return \"40XL1\".equals(sqlState) || \"40XL2\".equals(sqlState);\n+    }\n+\n+    @Override\n+    public boolean isConnectionError(SQLException x) {\n+        String sqlState = x.getSQLState();\n+        return sqlState != null && sqlState.startsWith(\"08\");\n+    }\n+\n+    @Override\n+    public DataAccessException translate(SQLException x) {\n+        if (isDeadlock(x)) {\n+            return new LockException(x, true);\n+        }\n+        else if (isLockTimeout(x)) {\n+            return new LockException(x, false);\n+        }\n+        else if (isConnectionError(x)) {\n+            return new ConnectionException(x);\n+        }\n+        else if (isDuplicate(x)) {\n+            return new UniqueConstraintViolationException(x);\n+        }\n+        else if (isUndefinedName(x)) {\n+            return new UndefinedNameException(x);\n+        }\n+        else {\n+            return new DataAccessException(x);\n+        }\n+    }\n+\n+    @Override\n+    public boolean isUndefinedName(SQLException x) {\n+        return \"42X05\".equals(x.getSQLState());\n+    }\n+\n+    @Override\n+    public void fillProperties(Properties p, ConnectionDetails cd) {\n+        p.put(\"user\", cd.getUser());\n+        p.put(\"password\", cd.getPassword());\n+\n+        if (cd.isSsl()) {\n+            p.put(\"sslConnection\", \"true\");\n+        }\n+\n+        if (cd.isHA()) {\n+            logger.warning(\"No HA support for PostgreSql\");\n+        }\n+    }\n+\n+    @Override\n+    public String timestampDiff(String left, String right, String alias) {\n+        if (alias == null || alias.isEmpty()) {\n+            return String.format(\"{fn timestampdiff(SQL_TSI_SECOND, %s, %s)}\", left, right);\n+        }\n+        else {\n+            return String.format(\"{fn timestampdiff(SQL_TSI_SECOND, %s, %s)} AS %s\", left, right, alias);\n+        }\n+    }\n+\n+    @Override\n+    public String createSequence(String name, int cache) {\n+        // cache isn't supported by PostgreSql\n+        return \"CREATE SEQUENCE \" + name;\n+    }\n+\n+    @Override\n+    public String reorgTableCommand(String tableName) {\n+        // REORG TABLE not supported by PostgreSql\n+        throw new UnsupportedOperationException(\"reorg table is not supported!\");\n+    }\n+\n+    @Override\n+    public String getDriverClassName() {\n+        return \"org.postgresql.Driver\";\n+    }\n+\n+    @Override\n+    public String getUrl(Properties connectionProperties) {\n+        PostgreSqlPropertyAdapter adapter = new PostgreSqlPropertyAdapter(connectionProperties);\n+\n+        return \"jdbc:postgresql://\" + adapter.getHost() + \":\" + adapter.getPort() + \"/\" + adapter.getDatabase();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 147}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTA2MTc4", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396506178", "createdAt": "2020-04-20T14:27:21Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoyNzoyMVrOGIXR_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoyNzoyMVrOGIXR_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyMzIzMA==", "bodyText": "If I could suggest a flip of the code here.  if-then-else can come before, and be assigned to a value.\nthen the builder can be automatically assigned to the InsertStatement", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411423230", "createdAt": "2020-04-20T14:27:21Z", "author": {"login": "prb112"}, "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/version/AddVersionDAO.java", "diffHunk": "@@ -38,14 +38,18 @@ public AddVersionDAO(String adminSchemaName, String schemaName, String type, Str\n \n     @Override\n     public void run(IDatabaseTranslator translator, Connection c) {\n-\n-        final InsertStatement ins = InsertStatement.builder(adminSchemaName, SchemaConstants.VERSION_HISTORY)\n+        InsertStatement.Builder insBuilder = InsertStatement.builder(adminSchemaName, SchemaConstants.VERSION_HISTORY)\n                 .addColumn(SchemaConstants.SCHEMA_NAME)\n                 .addColumn(SchemaConstants.OBJECT_TYPE)\n                 .addColumn(SchemaConstants.OBJECT_NAME)\n-                .addColumn(SchemaConstants.VERSION)\n-                .addColumn(SchemaConstants.APPLIED, \"CURRENT TIMESTAMP\")\n-                .build();\n+                .addColumn(SchemaConstants.VERSION);\n+        if (translator.getDriverClassName().contains(\"postgresql\")) {\n+            insBuilder = insBuilder.addColumn(SchemaConstants.APPLIED, \"CURRENT_TIMESTAMP\");\n+        } else {\n+            insBuilder = insBuilder.addColumn(SchemaConstants.APPLIED, \"CURRENT TIMESTAMP\");\n+        }\n+\n+        final InsertStatement ins = insBuilder.build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 20}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTA3MjQy", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396507242", "createdAt": "2020-04-20T14:28:27Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoyODoyOFrOGIXVLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoyODoyOFrOGIXVLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyNDA0Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public enum FHIRResourceDAOType {\n          \n          \n            \n                // The various DAO Types that are used in the JDBC Persistence layer. \n          \n          \n            \n                public enum DAOType {", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411424047", "createdAt": "2020-04-20T14:28:28Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/FHIRResourceDAOFactory.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.persistence.jdbc.dao.api.ResourceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyResourceDAO;\n+import com.ibm.fhir.persistence.jdbc.postgresql.PostgreSqlResourceDAO;\n+\n+public class FHIRResourceDAOFactory {\n+\n+    public enum FHIRResourceDAOType {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTA3ODA2", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396507806", "createdAt": "2020-04-20T14:29:05Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoyOTowNVrOGIXXRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoyOTowNVrOGIXXRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyNDU4MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n      \n    \n    \n  \n\nextra line", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411424581", "createdAt": "2020-04-20T14:29:05Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/FHIRResourceDAOFactory.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.persistence.jdbc.dao.api.ResourceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyResourceDAO;\n+import com.ibm.fhir.persistence.jdbc.postgresql.PostgreSqlResourceDAO;\n+\n+public class FHIRResourceDAOFactory {\n+\n+    public enum FHIRResourceDAOType {\n+        DB2(\"db2\"),\n+        DERBY(\"derby\"),\n+        POSTGRESQL(\"postgresql\");\n+\n+        private final String value;\n+\n+        FHIRResourceDAOType(String value) {\n+            this.value = value;\n+        }\n+\n+        public String value() {\n+            return value;\n+        }\n+\n+        public static FHIRResourceDAOType of(Connection con) throws SQLException, IllegalArgumentException {\n+            String dbUrl = con.getMetaData().getURL();\n+            dbUrl = dbUrl.toLowerCase();\n+            if (dbUrl.contains(DB2.value)) {\n+                return DB2;\n+            } else if (dbUrl.contains(DERBY.value)) {\n+                return DERBY;\n+            } else if (dbUrl.contains(POSTGRESQL.value)) {\n+                return POSTGRESQL;\n+            } else {\n+                throw new IllegalArgumentException(dbUrl);\n+            }\n+\n+        }\n+    }\n+\n+   public static ResourceDAO getResourceDAO (Connection con, TransactionSynchronizationRegistry trxSynchRegistry) throws IllegalArgumentException, SQLException {\n+        ResourceDAO resourceDAO = null;\n+        switch (FHIRResourceDAOType.of(con)) {\n+            case DB2:\n+                resourceDAO = new ResourceDAOImpl(trxSynchRegistry);\n+                break;\n+            case DERBY:\n+                resourceDAO = new DerbyResourceDAO(trxSynchRegistry);\n+                break;\n+            case POSTGRESQL:\n+                resourceDAO = new PostgreSqlResourceDAO(trxSynchRegistry);\n+                break;\n+        }\n+        return resourceDAO;\n+    }\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 68}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTA4OTE4", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396508918", "createdAt": "2020-04-20T14:30:11Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozMDoxMVrOGIXawQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozMDoxMVrOGIXawQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyNTQ3Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               public static ResourceDAO getResourceDAO (Connection con, TransactionSynchronizationRegistry trxSynchRegistry) throws IllegalArgumentException, SQLException {\n          \n          \n            \n               public static ResourceDAO getResourceDAO (Connection conn, TransactionSynchronizationRegistry trxSynchRegistry) throws IllegalArgumentException, SQLException {\n          \n      \n    \n    \n  \n\nI was advised this a long time ago. don't use con.  Con is actually a reserved word on windows.  And a swear in another language.  Search con french. use conn", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411425473", "createdAt": "2020-04-20T14:30:11Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/FHIRResourceDAOFactory.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.persistence.jdbc.dao.api.ResourceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyResourceDAO;\n+import com.ibm.fhir.persistence.jdbc.postgresql.PostgreSqlResourceDAO;\n+\n+public class FHIRResourceDAOFactory {\n+\n+    public enum FHIRResourceDAOType {\n+        DB2(\"db2\"),\n+        DERBY(\"derby\"),\n+        POSTGRESQL(\"postgresql\");\n+\n+        private final String value;\n+\n+        FHIRResourceDAOType(String value) {\n+            this.value = value;\n+        }\n+\n+        public String value() {\n+            return value;\n+        }\n+\n+        public static FHIRResourceDAOType of(Connection con) throws SQLException, IllegalArgumentException {\n+            String dbUrl = con.getMetaData().getURL();\n+            dbUrl = dbUrl.toLowerCase();\n+            if (dbUrl.contains(DB2.value)) {\n+                return DB2;\n+            } else if (dbUrl.contains(DERBY.value)) {\n+                return DERBY;\n+            } else if (dbUrl.contains(POSTGRESQL.value)) {\n+                return POSTGRESQL;\n+            } else {\n+                throw new IllegalArgumentException(dbUrl);\n+            }\n+\n+        }\n+    }\n+\n+   public static ResourceDAO getResourceDAO (Connection con, TransactionSynchronizationRegistry trxSynchRegistry) throws IllegalArgumentException, SQLException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 52}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTA5MTQy", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396509142", "createdAt": "2020-04-20T14:30:26Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozMDoyN1rOGIXbkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozMDoyN1rOGIXbkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyNTY4Mg==", "bodyText": "same comment as above", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411425682", "createdAt": "2020-04-20T14:30:27Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/FHIRResourceDAOFactory.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.persistence.jdbc.dao.api.ResourceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyResourceDAO;\n+import com.ibm.fhir.persistence.jdbc.postgresql.PostgreSqlResourceDAO;\n+\n+public class FHIRResourceDAOFactory {\n+\n+    public enum FHIRResourceDAOType {\n+        DB2(\"db2\"),\n+        DERBY(\"derby\"),\n+        POSTGRESQL(\"postgresql\");\n+\n+        private final String value;\n+\n+        FHIRResourceDAOType(String value) {\n+            this.value = value;\n+        }\n+\n+        public String value() {\n+            return value;\n+        }\n+\n+        public static FHIRResourceDAOType of(Connection con) throws SQLException, IllegalArgumentException {\n+            String dbUrl = con.getMetaData().getURL();\n+            dbUrl = dbUrl.toLowerCase();\n+            if (dbUrl.contains(DB2.value)) {\n+                return DB2;\n+            } else if (dbUrl.contains(DERBY.value)) {\n+                return DERBY;\n+            } else if (dbUrl.contains(POSTGRESQL.value)) {\n+                return POSTGRESQL;\n+            } else {\n+                throw new IllegalArgumentException(dbUrl);\n+            }\n+\n+        }\n+    }\n+\n+   public static ResourceDAO getResourceDAO (Connection con, TransactionSynchronizationRegistry trxSynchRegistry) throws IllegalArgumentException, SQLException {\n+        ResourceDAO resourceDAO = null;\n+        switch (FHIRResourceDAOType.of(con)) {\n+            case DB2:\n+                resourceDAO = new ResourceDAOImpl(trxSynchRegistry);\n+                break;\n+            case DERBY:\n+                resourceDAO = new DerbyResourceDAO(trxSynchRegistry);\n+                break;\n+            case POSTGRESQL:\n+                resourceDAO = new PostgreSqlResourceDAO(trxSynchRegistry);\n+                break;\n+        }\n+        return resourceDAO;\n+    }\n+\n+\n+    public static ResourceDAO getResourceDAO (Connection con) throws IllegalArgumentException, SQLException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 69}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTEwNzAw", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396510700", "createdAt": "2020-04-20T14:32:03Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozMjowM1rOGIXgmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozMjowM1rOGIXgmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyNjk2OA==", "bodyText": "This feels like it should go into the another class", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411426968", "createdAt": "2020-04-20T14:32:03Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/dao/impl/ResourceDAOImpl.java", "diffHunk": "@@ -459,40 +461,19 @@ public void addResourceTypeCacheCandidate(String resourceType, Integer resourceT\n \n     }\n \n-    @Override\n-    public Resource insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n-            throws FHIRPersistenceException {\n-        final String METHODNAME = \"insert(Resource, List<ExtractedParameterValue>\";\n-        log.entering(CLASSNAME, METHODNAME);\n+    public boolean isPostgreSqlDatabase() throws FHIRPersistenceDBConnectException, SQLException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTEyMzE2", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396512316", "createdAt": "2020-04-20T14:33:46Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozMzo0NlrOGIXl6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozMzo0NlrOGIXl6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyODMyOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        }\n          \n          \n            \n                        else {\n          \n          \n            \n                        } else {", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411428329", "createdAt": "2020-04-20T14:33:46Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/FhirRefSequenceDAOImpl.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+\n+/**\n+ * DAO to obtain the next value from FHIR_REF_SEQUENCE\n+ *\n+ */\n+public class FhirRefSequenceDAOImpl implements FhirRefSequenceDAO {\n+    private final Connection conn;\n+\n+    /**\n+     * Public constructor\n+     */\n+    public FhirRefSequenceDAOImpl(Connection c) {\n+        this.conn = c;\n+    }\n+\n+    @Override\n+    public int nextValue() throws SQLException {\n+        int result;\n+        final String SEQ = \"select nextval('fhir_ref_sequence')\";\n+\n+        try (PreparedStatement stmt = conn.prepareStatement(SEQ)) {\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                result = rs.getInt(1);\n+            }\n+            else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 40}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTEyNTg3", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396512587", "createdAt": "2020-04-20T14:34:03Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozNDowM1rOGIXm2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozNDowM1rOGIXm2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyODU2OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411428569", "createdAt": "2020-04-20T14:34:03Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/FhirSequenceDAOImpl.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirSequenceDAO;\n+\n+/**\n+ * DAO to obtain the next value from FHIR_SEQUENCE\n+ *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 18}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTE0MDg4", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396514088", "createdAt": "2020-04-20T14:35:42Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozNTo0MlrOGIXrsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozNTo0MlrOGIXrsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQyOTgwOQ==", "bodyText": "Suggested change", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411429809", "createdAt": "2020-04-20T14:35:42Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlParameterNamesDAO.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterNameDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+\n+public class PostgreSqlParameterNamesDAO extends ParameterNameDAOImpl {\n+    private final FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    public PostgreSqlParameterNamesDAO(Connection c, FhirRefSequenceDAO fsd) {\n+        super(c);\n+        this.fhirRefSequenceDAO = fsd;\n+    }\n+\n+    @Override\n+    public int readOrAddParameterNameId(String parameterName) throws FHIRPersistenceDataAccessException  {\n+        // As the system is concurrent, we have to handle cases where another thread\n+        // might create the entry after we selected and found nothing\n+        Integer result = getParameterId(parameterName);\n+\n+        // Create the resource if we don't have it already (set by the continue handler)\n+        if (result == null) {\n+            try {\n+                result = fhirRefSequenceDAO.nextValue();\n+\n+                final String INS = \"INSERT INTO parameter_names (parameter_name_id, parameter_name) VALUES (?, ?)\";\n+                try (PreparedStatement stmt = getConnection().prepareStatement(INS)) {\n+                    // bind parameters\n+                    stmt.setInt(1, result);\n+                    stmt.setString(2, parameterName);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (\"23505\".equals(e.getSQLState())) {\n+                    // another thread snuck in and created the record, so we need to fetch the correct id\n+                    result = getParameterId(parameterName);\n+\n+                    if (result == null) {\n+                        // would be extremely weird, but good to protect against anyway\n+                        throw new IllegalStateException(\"No parameter id returned after duplicate found!\");\n+                    }\n+                }\n+                else {\n+                    throw new FHIRPersistenceDataAccessException(\"parameterName=\" + parameterName, e);\n+                }\n+            }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 58}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTE0Nzc3", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396514777", "createdAt": "2020-04-20T14:36:25Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozNjoyNlrOGIXt4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozNjoyNlrOGIXt4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMDM3MA==", "bodyText": "is sql1 special ? just curious about sql1 meaning.", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411430370", "createdAt": "2020-04-20T14:36:26Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlParameterNamesDAO.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterNameDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+\n+public class PostgreSqlParameterNamesDAO extends ParameterNameDAOImpl {\n+    private final FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    public PostgreSqlParameterNamesDAO(Connection c, FhirRefSequenceDAO fsd) {\n+        super(c);\n+        this.fhirRefSequenceDAO = fsd;\n+    }\n+\n+    @Override\n+    public int readOrAddParameterNameId(String parameterName) throws FHIRPersistenceDataAccessException  {\n+        // As the system is concurrent, we have to handle cases where another thread\n+        // might create the entry after we selected and found nothing\n+        Integer result = getParameterId(parameterName);\n+\n+        // Create the resource if we don't have it already (set by the continue handler)\n+        if (result == null) {\n+            try {\n+                result = fhirRefSequenceDAO.nextValue();\n+\n+                final String INS = \"INSERT INTO parameter_names (parameter_name_id, parameter_name) VALUES (?, ?)\";\n+                try (PreparedStatement stmt = getConnection().prepareStatement(INS)) {\n+                    // bind parameters\n+                    stmt.setInt(1, result);\n+                    stmt.setString(2, parameterName);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (\"23505\".equals(e.getSQLState())) {\n+                    // another thread snuck in and created the record, so we need to fetch the correct id\n+                    result = getParameterId(parameterName);\n+\n+                    if (result == null) {\n+                        // would be extremely weird, but good to protect against anyway\n+                        throw new IllegalStateException(\"No parameter id returned after duplicate found!\");\n+                    }\n+                }\n+                else {\n+                    throw new FHIRPersistenceDataAccessException(\"parameterName=\" + parameterName, e);\n+                }\n+            }\n+\n+        }\n+\n+        // cannot be null, so safe to return as an int\n+        return result;\n+    }\n+\n+    /**\n+     * Read the id for the named type\n+     * @param parameterName\n+     * @return the database id, or null if the named record is not found\n+     * @throws FHIRPersistenceDataAccessException\n+     */\n+    protected Integer getParameterId(String parameterName) throws FHIRPersistenceDataAccessException {\n+        Integer result;\n+\n+        String sql1 = \"SELECT parameter_name_id FROM parameter_names WHERE parameter_name = ?\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 74}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTE0OTUx", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396514951", "createdAt": "2020-04-20T14:36:36Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozNjozNlrOGIXuVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozNjozNlrOGIXuVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMDQ4Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    }\n          \n          \n            \n                    catch (SQLException x) {\n          \n          \n            \n                    } catch (SQLException x) {", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411430486", "createdAt": "2020-04-20T14:36:36Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlParameterNamesDAO.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterNameDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+\n+public class PostgreSqlParameterNamesDAO extends ParameterNameDAOImpl {\n+    private final FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    public PostgreSqlParameterNamesDAO(Connection c, FhirRefSequenceDAO fsd) {\n+        super(c);\n+        this.fhirRefSequenceDAO = fsd;\n+    }\n+\n+    @Override\n+    public int readOrAddParameterNameId(String parameterName) throws FHIRPersistenceDataAccessException  {\n+        // As the system is concurrent, we have to handle cases where another thread\n+        // might create the entry after we selected and found nothing\n+        Integer result = getParameterId(parameterName);\n+\n+        // Create the resource if we don't have it already (set by the continue handler)\n+        if (result == null) {\n+            try {\n+                result = fhirRefSequenceDAO.nextValue();\n+\n+                final String INS = \"INSERT INTO parameter_names (parameter_name_id, parameter_name) VALUES (?, ?)\";\n+                try (PreparedStatement stmt = getConnection().prepareStatement(INS)) {\n+                    // bind parameters\n+                    stmt.setInt(1, result);\n+                    stmt.setString(2, parameterName);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (\"23505\".equals(e.getSQLState())) {\n+                    // another thread snuck in and created the record, so we need to fetch the correct id\n+                    result = getParameterId(parameterName);\n+\n+                    if (result == null) {\n+                        // would be extremely weird, but good to protect against anyway\n+                        throw new IllegalStateException(\"No parameter id returned after duplicate found!\");\n+                    }\n+                }\n+                else {\n+                    throw new FHIRPersistenceDataAccessException(\"parameterName=\" + parameterName, e);\n+                }\n+            }\n+\n+        }\n+\n+        // cannot be null, so safe to return as an int\n+        return result;\n+    }\n+\n+    /**\n+     * Read the id for the named type\n+     * @param parameterName\n+     * @return the database id, or null if the named record is not found\n+     * @throws FHIRPersistenceDataAccessException\n+     */\n+    protected Integer getParameterId(String parameterName) throws FHIRPersistenceDataAccessException {\n+        Integer result;\n+\n+        String sql1 = \"SELECT parameter_name_id FROM parameter_names WHERE parameter_name = ?\";\n+\n+        try (PreparedStatement stmt = getConnection().prepareStatement(sql1)) {\n+            stmt.setString(1, parameterName);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                result = rs.getInt(1);\n+            }\n+            else {\n+                result = null;\n+            }\n+        }\n+        catch (SQLException x) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 86}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTE1MTc5", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396515179", "createdAt": "2020-04-20T14:36:50Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozNjo1MFrOGIXvFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozNjo1MFrOGIXvFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMDY3OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        }\n          \n          \n            \n                        else {\n          \n          \n            \n                        }  else {", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411430678", "createdAt": "2020-04-20T14:36:50Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlParameterNamesDAO.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterNameDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+\n+public class PostgreSqlParameterNamesDAO extends ParameterNameDAOImpl {\n+    private final FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    public PostgreSqlParameterNamesDAO(Connection c, FhirRefSequenceDAO fsd) {\n+        super(c);\n+        this.fhirRefSequenceDAO = fsd;\n+    }\n+\n+    @Override\n+    public int readOrAddParameterNameId(String parameterName) throws FHIRPersistenceDataAccessException  {\n+        // As the system is concurrent, we have to handle cases where another thread\n+        // might create the entry after we selected and found nothing\n+        Integer result = getParameterId(parameterName);\n+\n+        // Create the resource if we don't have it already (set by the continue handler)\n+        if (result == null) {\n+            try {\n+                result = fhirRefSequenceDAO.nextValue();\n+\n+                final String INS = \"INSERT INTO parameter_names (parameter_name_id, parameter_name) VALUES (?, ?)\";\n+                try (PreparedStatement stmt = getConnection().prepareStatement(INS)) {\n+                    // bind parameters\n+                    stmt.setInt(1, result);\n+                    stmt.setString(2, parameterName);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (\"23505\".equals(e.getSQLState())) {\n+                    // another thread snuck in and created the record, so we need to fetch the correct id\n+                    result = getParameterId(parameterName);\n+\n+                    if (result == null) {\n+                        // would be extremely weird, but good to protect against anyway\n+                        throw new IllegalStateException(\"No parameter id returned after duplicate found!\");\n+                    }\n+                }\n+                else {\n+                    throw new FHIRPersistenceDataAccessException(\"parameterName=\" + parameterName, e);\n+                }\n+            }\n+\n+        }\n+\n+        // cannot be null, so safe to return as an int\n+        return result;\n+    }\n+\n+    /**\n+     * Read the id for the named type\n+     * @param parameterName\n+     * @return the database id, or null if the named record is not found\n+     * @throws FHIRPersistenceDataAccessException\n+     */\n+    protected Integer getParameterId(String parameterName) throws FHIRPersistenceDataAccessException {\n+        Integer result;\n+\n+        String sql1 = \"SELECT parameter_name_id FROM parameter_names WHERE parameter_name = ?\";\n+\n+        try (PreparedStatement stmt = getConnection().prepareStatement(sql1)) {\n+            stmt.setString(1, parameterName);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                result = rs.getInt(1);\n+            }\n+            else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 82}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTE2MDM0", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396516034", "createdAt": "2020-04-20T14:37:45Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozNzo0NVrOGIXxlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozNzo0NVrOGIXxlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMTMxOQ==", "bodyText": "Do we want to use DSTU2 reference? I think we should remove.", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411431319", "createdAt": "2020-04-20T14:37:45Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,533 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an Apache PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 49}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTE2NzE2", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396516716", "createdAt": "2020-04-20T14:38:29Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozODozMFrOGIXz9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozODozMFrOGIXz9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMTkyNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Data access object for writing FHIR resources to an Apache PostgreSql database.\n          \n          \n            \n             * Data access object for writing FHIR resources to an PostgreSql database.", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411431925", "createdAt": "2020-04-20T14:38:30Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,533 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an Apache PostgreSql database.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 46}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTE3MzM2", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396517336", "createdAt": "2020-04-20T14:39:10Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozOToxMFrOGIX19g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDozOToxMFrOGIX19g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMjQzOA==", "bodyText": "Suggested change", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411432438", "createdAt": "2020-04-20T14:39:10Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,533 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an Apache PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 144}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTE4MTUy", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396518152", "createdAt": "2020-04-20T14:40:02Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0MDowM1rOGIX4yA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0MDowM1rOGIX4yA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMzE2MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        }\n          \n          \n            \n                        else {\n          \n          \n            \n                        } else {", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411433160", "createdAt": "2020-04-20T14:40:03Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,533 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an Apache PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+\n+    }\n+\n+    /**\n+     * Store the resource in the database, creating a new logical_resource entry if this is\n+     * the first version of this resource, or creating a new resource entry if this a new\n+     * version of an existing logical resource. The logic tracks closely the DB2 stored\n+     * procedure implementation, including locking of the logical_resource and handling\n+     * concurrency issues using the standard insert-or-update pattern:\n+     * <pre>\n+     *   SELECT FOR UPDATE                 -- try and get a write lock\n+     *   IF NOT FOUND THEN                 -- doesn't exist, so we don't have a lock\n+     *     INSERT new logical resource     -- create the record - if OK, we own the lock\n+     *     IF DUPLICATE THEN               -- someone else beat us to the create\n+     *       SELECT FOR UPDATE             -- so we need to try again for a write lock\n+     *     ...\n+     *   ...\n+     * </pre>\n+     *\n+     * This works because we never delete a logical_resource record, and so don't have to deal\n+     * with concurrency issues caused when deletes are mingled with inserts/updates\n+     *\n+     * Note the execution flow aligns very closely with the DB2 stored procedure\n+     * implementation (fhir-persistence-schema/src/main/resources/add_any_resource.sql)\n+     *\n+     * @param tablePrefix\n+     * @param parameters\n+     * @param p_logical_id\n+     * @param p_payload\n+     * @param p_last_updated\n+     * @param p_is_deleted\n+     * @param p_source_key\n+     * @param p_version\n+     *\n+     * @return the resource_id for the entry we created\n+     * @throws Exception\n+     */\n+    public long storeResource(String tablePrefix, List<ExtractedParameterValue> parameters, String p_logical_id, byte[] p_payload, Timestamp p_last_updated, boolean p_is_deleted,\n+        String p_source_key, Integer p_version, Connection conn) throws Exception {\n+\n+        final String METHODNAME = \"storeResource() for \" + tablePrefix + \" resource\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Long v_logical_resource_id = null;\n+        Long v_current_resource_id = null;\n+        Long v_resource_id = null;\n+        Integer v_resource_type_id = null;\n+        boolean v_new_resource = false;\n+        boolean v_not_found = false;\n+        boolean v_duplicate = false;\n+        int v_version = 0;\n+        int v_insert_version = 0;\n+\n+        String v_resource_type = tablePrefix;\n+\n+        // Map the resource type name to the normalized id value in the database\n+        v_resource_type_id = getResourceTypeId(v_resource_type, conn);\n+        if (v_resource_type_id == null) {\n+            // programming error, as this should've been created earlier\n+            throw new IllegalStateException(\"resource type not found: \" + v_resource_type);\n+        }\n+\n+        // Get a lock at the system-wide logical resource level. Note the Derby-specific syntax\n+        final String SELECT_FOR_UPDATE = \"SELECT logical_resource_id FROM logical_resources WHERE resource_type_id = ? AND logical_id = ? FOR UPDATE\";\n+        try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+            stmt.setInt(1, v_resource_type_id);\n+            stmt.setString(2, p_logical_id);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                v_logical_resource_id = rs.getLong(1);\n+            }\n+            else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 244}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTE4MzM4", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396518338", "createdAt": "2020-04-20T14:40:13Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0MDoxNFrOGIX5bQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0MDoxNFrOGIX5bQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMzMyNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            }\n          \n          \n            \n                            else {\n          \n          \n            \n                            } else {", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411433325", "createdAt": "2020-04-20T14:40:14Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,533 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an Apache PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+\n+    }\n+\n+    /**\n+     * Store the resource in the database, creating a new logical_resource entry if this is\n+     * the first version of this resource, or creating a new resource entry if this a new\n+     * version of an existing logical resource. The logic tracks closely the DB2 stored\n+     * procedure implementation, including locking of the logical_resource and handling\n+     * concurrency issues using the standard insert-or-update pattern:\n+     * <pre>\n+     *   SELECT FOR UPDATE                 -- try and get a write lock\n+     *   IF NOT FOUND THEN                 -- doesn't exist, so we don't have a lock\n+     *     INSERT new logical resource     -- create the record - if OK, we own the lock\n+     *     IF DUPLICATE THEN               -- someone else beat us to the create\n+     *       SELECT FOR UPDATE             -- so we need to try again for a write lock\n+     *     ...\n+     *   ...\n+     * </pre>\n+     *\n+     * This works because we never delete a logical_resource record, and so don't have to deal\n+     * with concurrency issues caused when deletes are mingled with inserts/updates\n+     *\n+     * Note the execution flow aligns very closely with the DB2 stored procedure\n+     * implementation (fhir-persistence-schema/src/main/resources/add_any_resource.sql)\n+     *\n+     * @param tablePrefix\n+     * @param parameters\n+     * @param p_logical_id\n+     * @param p_payload\n+     * @param p_last_updated\n+     * @param p_is_deleted\n+     * @param p_source_key\n+     * @param p_version\n+     *\n+     * @return the resource_id for the entry we created\n+     * @throws Exception\n+     */\n+    public long storeResource(String tablePrefix, List<ExtractedParameterValue> parameters, String p_logical_id, byte[] p_payload, Timestamp p_last_updated, boolean p_is_deleted,\n+        String p_source_key, Integer p_version, Connection conn) throws Exception {\n+\n+        final String METHODNAME = \"storeResource() for \" + tablePrefix + \" resource\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Long v_logical_resource_id = null;\n+        Long v_current_resource_id = null;\n+        Long v_resource_id = null;\n+        Integer v_resource_type_id = null;\n+        boolean v_new_resource = false;\n+        boolean v_not_found = false;\n+        boolean v_duplicate = false;\n+        int v_version = 0;\n+        int v_insert_version = 0;\n+\n+        String v_resource_type = tablePrefix;\n+\n+        // Map the resource type name to the normalized id value in the database\n+        v_resource_type_id = getResourceTypeId(v_resource_type, conn);\n+        if (v_resource_type_id == null) {\n+            // programming error, as this should've been created earlier\n+            throw new IllegalStateException(\"resource type not found: \" + v_resource_type);\n+        }\n+\n+        // Get a lock at the system-wide logical resource level. Note the Derby-specific syntax\n+        final String SELECT_FOR_UPDATE = \"SELECT logical_resource_id FROM logical_resources WHERE resource_type_id = ? AND logical_id = ? FOR UPDATE\";\n+        try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+            stmt.setInt(1, v_resource_type_id);\n+            stmt.setString(2, p_logical_id);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                v_logical_resource_id = rs.getLong(1);\n+            }\n+            else {\n+                v_not_found = true;\n+                v_logical_resource_id = -1L; // just to be careful\n+            }\n+        }\n+\n+        // Create the logical resource if we don't have it already\n+        if (v_not_found) {\n+            // grab the id we want to use for the new logical resource instance\n+            final String sql2 = \"SELECT nextval('fhir_sequence')\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_logical_resource_id = res.getLong(1);\n+                }\n+                else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 259}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTE4NjU0", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396518654", "createdAt": "2020-04-20T14:40:34Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0MDozNFrOGIX6iA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0MDozNFrOGIX6iA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMzYwOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            }\n          \n          \n            \n                            else {\n          \n          \n            \n                            }  else {", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411433608", "createdAt": "2020-04-20T14:40:34Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,533 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an Apache PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+\n+    }\n+\n+    /**\n+     * Store the resource in the database, creating a new logical_resource entry if this is\n+     * the first version of this resource, or creating a new resource entry if this a new\n+     * version of an existing logical resource. The logic tracks closely the DB2 stored\n+     * procedure implementation, including locking of the logical_resource and handling\n+     * concurrency issues using the standard insert-or-update pattern:\n+     * <pre>\n+     *   SELECT FOR UPDATE                 -- try and get a write lock\n+     *   IF NOT FOUND THEN                 -- doesn't exist, so we don't have a lock\n+     *     INSERT new logical resource     -- create the record - if OK, we own the lock\n+     *     IF DUPLICATE THEN               -- someone else beat us to the create\n+     *       SELECT FOR UPDATE             -- so we need to try again for a write lock\n+     *     ...\n+     *   ...\n+     * </pre>\n+     *\n+     * This works because we never delete a logical_resource record, and so don't have to deal\n+     * with concurrency issues caused when deletes are mingled with inserts/updates\n+     *\n+     * Note the execution flow aligns very closely with the DB2 stored procedure\n+     * implementation (fhir-persistence-schema/src/main/resources/add_any_resource.sql)\n+     *\n+     * @param tablePrefix\n+     * @param parameters\n+     * @param p_logical_id\n+     * @param p_payload\n+     * @param p_last_updated\n+     * @param p_is_deleted\n+     * @param p_source_key\n+     * @param p_version\n+     *\n+     * @return the resource_id for the entry we created\n+     * @throws Exception\n+     */\n+    public long storeResource(String tablePrefix, List<ExtractedParameterValue> parameters, String p_logical_id, byte[] p_payload, Timestamp p_last_updated, boolean p_is_deleted,\n+        String p_source_key, Integer p_version, Connection conn) throws Exception {\n+\n+        final String METHODNAME = \"storeResource() for \" + tablePrefix + \" resource\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Long v_logical_resource_id = null;\n+        Long v_current_resource_id = null;\n+        Long v_resource_id = null;\n+        Integer v_resource_type_id = null;\n+        boolean v_new_resource = false;\n+        boolean v_not_found = false;\n+        boolean v_duplicate = false;\n+        int v_version = 0;\n+        int v_insert_version = 0;\n+\n+        String v_resource_type = tablePrefix;\n+\n+        // Map the resource type name to the normalized id value in the database\n+        v_resource_type_id = getResourceTypeId(v_resource_type, conn);\n+        if (v_resource_type_id == null) {\n+            // programming error, as this should've been created earlier\n+            throw new IllegalStateException(\"resource type not found: \" + v_resource_type);\n+        }\n+\n+        // Get a lock at the system-wide logical resource level. Note the Derby-specific syntax\n+        final String SELECT_FOR_UPDATE = \"SELECT logical_resource_id FROM logical_resources WHERE resource_type_id = ? AND logical_id = ? FOR UPDATE\";\n+        try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+            stmt.setInt(1, v_resource_type_id);\n+            stmt.setString(2, p_logical_id);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                v_logical_resource_id = rs.getLong(1);\n+            }\n+            else {\n+                v_not_found = true;\n+                v_logical_resource_id = -1L; // just to be careful\n+            }\n+        }\n+\n+        // Create the logical resource if we don't have it already\n+        if (v_not_found) {\n+            // grab the id we want to use for the new logical resource instance\n+            final String sql2 = \"SELECT nextval('fhir_sequence')\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_logical_resource_id = res.getLong(1);\n+                }\n+                else {\n+                    // not going to happen, unless someone butchers the statement being executed\n+                    throw new IllegalStateException(\"VALUES failed to return a row: \" + sql2);\n+                }\n+            }\n+\n+            try {\n+                // insert the system-wide logical resource record.\n+                final String sql3 = \"INSERT INTO logical_resources (logical_resource_id, resource_type_id, logical_id) VALUES (?, ?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setInt(2, v_resource_type_id);\n+                    stmt.setString(3, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (translator.isDuplicate(e)) {\n+                    v_duplicate = true;\n+                }\n+                else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 279}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTE4ODYz", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396518863", "createdAt": "2020-04-20T14:40:46Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0MDo0NlrOGIX7KA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0MDo0NlrOGIX7KA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMzc2OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                }\n          \n          \n            \n                                else {\n          \n          \n            \n                                    // Extremely unlikely as we should never delete logical resource records\n          \n          \n            \n                                } else {\n          \n          \n            \n                                    // Extremely unlikely as we should never delete logical resource records", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411433768", "createdAt": "2020-04-20T14:40:46Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,533 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an Apache PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+\n+    }\n+\n+    /**\n+     * Store the resource in the database, creating a new logical_resource entry if this is\n+     * the first version of this resource, or creating a new resource entry if this a new\n+     * version of an existing logical resource. The logic tracks closely the DB2 stored\n+     * procedure implementation, including locking of the logical_resource and handling\n+     * concurrency issues using the standard insert-or-update pattern:\n+     * <pre>\n+     *   SELECT FOR UPDATE                 -- try and get a write lock\n+     *   IF NOT FOUND THEN                 -- doesn't exist, so we don't have a lock\n+     *     INSERT new logical resource     -- create the record - if OK, we own the lock\n+     *     IF DUPLICATE THEN               -- someone else beat us to the create\n+     *       SELECT FOR UPDATE             -- so we need to try again for a write lock\n+     *     ...\n+     *   ...\n+     * </pre>\n+     *\n+     * This works because we never delete a logical_resource record, and so don't have to deal\n+     * with concurrency issues caused when deletes are mingled with inserts/updates\n+     *\n+     * Note the execution flow aligns very closely with the DB2 stored procedure\n+     * implementation (fhir-persistence-schema/src/main/resources/add_any_resource.sql)\n+     *\n+     * @param tablePrefix\n+     * @param parameters\n+     * @param p_logical_id\n+     * @param p_payload\n+     * @param p_last_updated\n+     * @param p_is_deleted\n+     * @param p_source_key\n+     * @param p_version\n+     *\n+     * @return the resource_id for the entry we created\n+     * @throws Exception\n+     */\n+    public long storeResource(String tablePrefix, List<ExtractedParameterValue> parameters, String p_logical_id, byte[] p_payload, Timestamp p_last_updated, boolean p_is_deleted,\n+        String p_source_key, Integer p_version, Connection conn) throws Exception {\n+\n+        final String METHODNAME = \"storeResource() for \" + tablePrefix + \" resource\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Long v_logical_resource_id = null;\n+        Long v_current_resource_id = null;\n+        Long v_resource_id = null;\n+        Integer v_resource_type_id = null;\n+        boolean v_new_resource = false;\n+        boolean v_not_found = false;\n+        boolean v_duplicate = false;\n+        int v_version = 0;\n+        int v_insert_version = 0;\n+\n+        String v_resource_type = tablePrefix;\n+\n+        // Map the resource type name to the normalized id value in the database\n+        v_resource_type_id = getResourceTypeId(v_resource_type, conn);\n+        if (v_resource_type_id == null) {\n+            // programming error, as this should've been created earlier\n+            throw new IllegalStateException(\"resource type not found: \" + v_resource_type);\n+        }\n+\n+        // Get a lock at the system-wide logical resource level. Note the Derby-specific syntax\n+        final String SELECT_FOR_UPDATE = \"SELECT logical_resource_id FROM logical_resources WHERE resource_type_id = ? AND logical_id = ? FOR UPDATE\";\n+        try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+            stmt.setInt(1, v_resource_type_id);\n+            stmt.setString(2, p_logical_id);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                v_logical_resource_id = rs.getLong(1);\n+            }\n+            else {\n+                v_not_found = true;\n+                v_logical_resource_id = -1L; // just to be careful\n+            }\n+        }\n+\n+        // Create the logical resource if we don't have it already\n+        if (v_not_found) {\n+            // grab the id we want to use for the new logical resource instance\n+            final String sql2 = \"SELECT nextval('fhir_sequence')\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_logical_resource_id = res.getLong(1);\n+                }\n+                else {\n+                    // not going to happen, unless someone butchers the statement being executed\n+                    throw new IllegalStateException(\"VALUES failed to return a row: \" + sql2);\n+                }\n+            }\n+\n+            try {\n+                // insert the system-wide logical resource record.\n+                final String sql3 = \"INSERT INTO logical_resources (logical_resource_id, resource_type_id, logical_id) VALUES (?, ?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setInt(2, v_resource_type_id);\n+                    stmt.setString(3, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (translator.isDuplicate(e)) {\n+                    v_duplicate = true;\n+                }\n+                else {\n+                    throw e;\n+                }\n+            }\n+\n+            /**\n+             * remember that we have a concurrent system...so there is a possibility\n+             * that another thread snuck in before us and created the logical resource. This\n+             * is easy to handle, just turn around and read it\n+             */\n+            if (v_duplicate) {\n+                try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+                    // bind parameters\n+                    stmt.setInt(1, v_resource_type_id);\n+                    stmt.setString(2, p_logical_id);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        v_logical_resource_id = res.getLong(1);\n+                    }\n+                    else {\n+                        // Extremely unlikely as we should never delete logical resource records", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 299}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTE5MDU5", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396519059", "createdAt": "2020-04-20T14:40:58Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0MDo1OFrOGIX72Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0MDo1OFrOGIX72Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzMzk0NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        }\n          \n          \n            \n                        else {\n          \n          \n            \n                        } else {", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411433945", "createdAt": "2020-04-20T14:40:58Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,533 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an Apache PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+\n+    }\n+\n+    /**\n+     * Store the resource in the database, creating a new logical_resource entry if this is\n+     * the first version of this resource, or creating a new resource entry if this a new\n+     * version of an existing logical resource. The logic tracks closely the DB2 stored\n+     * procedure implementation, including locking of the logical_resource and handling\n+     * concurrency issues using the standard insert-or-update pattern:\n+     * <pre>\n+     *   SELECT FOR UPDATE                 -- try and get a write lock\n+     *   IF NOT FOUND THEN                 -- doesn't exist, so we don't have a lock\n+     *     INSERT new logical resource     -- create the record - if OK, we own the lock\n+     *     IF DUPLICATE THEN               -- someone else beat us to the create\n+     *       SELECT FOR UPDATE             -- so we need to try again for a write lock\n+     *     ...\n+     *   ...\n+     * </pre>\n+     *\n+     * This works because we never delete a logical_resource record, and so don't have to deal\n+     * with concurrency issues caused when deletes are mingled with inserts/updates\n+     *\n+     * Note the execution flow aligns very closely with the DB2 stored procedure\n+     * implementation (fhir-persistence-schema/src/main/resources/add_any_resource.sql)\n+     *\n+     * @param tablePrefix\n+     * @param parameters\n+     * @param p_logical_id\n+     * @param p_payload\n+     * @param p_last_updated\n+     * @param p_is_deleted\n+     * @param p_source_key\n+     * @param p_version\n+     *\n+     * @return the resource_id for the entry we created\n+     * @throws Exception\n+     */\n+    public long storeResource(String tablePrefix, List<ExtractedParameterValue> parameters, String p_logical_id, byte[] p_payload, Timestamp p_last_updated, boolean p_is_deleted,\n+        String p_source_key, Integer p_version, Connection conn) throws Exception {\n+\n+        final String METHODNAME = \"storeResource() for \" + tablePrefix + \" resource\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Long v_logical_resource_id = null;\n+        Long v_current_resource_id = null;\n+        Long v_resource_id = null;\n+        Integer v_resource_type_id = null;\n+        boolean v_new_resource = false;\n+        boolean v_not_found = false;\n+        boolean v_duplicate = false;\n+        int v_version = 0;\n+        int v_insert_version = 0;\n+\n+        String v_resource_type = tablePrefix;\n+\n+        // Map the resource type name to the normalized id value in the database\n+        v_resource_type_id = getResourceTypeId(v_resource_type, conn);\n+        if (v_resource_type_id == null) {\n+            // programming error, as this should've been created earlier\n+            throw new IllegalStateException(\"resource type not found: \" + v_resource_type);\n+        }\n+\n+        // Get a lock at the system-wide logical resource level. Note the Derby-specific syntax\n+        final String SELECT_FOR_UPDATE = \"SELECT logical_resource_id FROM logical_resources WHERE resource_type_id = ? AND logical_id = ? FOR UPDATE\";\n+        try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+            stmt.setInt(1, v_resource_type_id);\n+            stmt.setString(2, p_logical_id);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                v_logical_resource_id = rs.getLong(1);\n+            }\n+            else {\n+                v_not_found = true;\n+                v_logical_resource_id = -1L; // just to be careful\n+            }\n+        }\n+\n+        // Create the logical resource if we don't have it already\n+        if (v_not_found) {\n+            // grab the id we want to use for the new logical resource instance\n+            final String sql2 = \"SELECT nextval('fhir_sequence')\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_logical_resource_id = res.getLong(1);\n+                }\n+                else {\n+                    // not going to happen, unless someone butchers the statement being executed\n+                    throw new IllegalStateException(\"VALUES failed to return a row: \" + sql2);\n+                }\n+            }\n+\n+            try {\n+                // insert the system-wide logical resource record.\n+                final String sql3 = \"INSERT INTO logical_resources (logical_resource_id, resource_type_id, logical_id) VALUES (?, ?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setInt(2, v_resource_type_id);\n+                    stmt.setString(3, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (translator.isDuplicate(e)) {\n+                    v_duplicate = true;\n+                }\n+                else {\n+                    throw e;\n+                }\n+            }\n+\n+            /**\n+             * remember that we have a concurrent system...so there is a possibility\n+             * that another thread snuck in before us and created the logical resource. This\n+             * is easy to handle, just turn around and read it\n+             */\n+            if (v_duplicate) {\n+                try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+                    // bind parameters\n+                    stmt.setInt(1, v_resource_type_id);\n+                    stmt.setString(2, p_logical_id);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        v_logical_resource_id = res.getLong(1);\n+                    }\n+                    else {\n+                        // Extremely unlikely as we should never delete logical resource records\n+                        throw new IllegalStateException(\"Logical resource was deleted: \" + tablePrefix + \"/\" + p_logical_id);\n+                    }\n+                }\n+            }\n+            else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 304}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTE5MzIy", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396519322", "createdAt": "2020-04-20T14:41:15Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0MToxNVrOGIX8zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0MToxNVrOGIX8zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzNDE5MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            }\n          \n          \n            \n                            else {\n          \n          \n            \n                            } else {", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411434191", "createdAt": "2020-04-20T14:41:15Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,533 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an Apache PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+\n+    }\n+\n+    /**\n+     * Store the resource in the database, creating a new logical_resource entry if this is\n+     * the first version of this resource, or creating a new resource entry if this a new\n+     * version of an existing logical resource. The logic tracks closely the DB2 stored\n+     * procedure implementation, including locking of the logical_resource and handling\n+     * concurrency issues using the standard insert-or-update pattern:\n+     * <pre>\n+     *   SELECT FOR UPDATE                 -- try and get a write lock\n+     *   IF NOT FOUND THEN                 -- doesn't exist, so we don't have a lock\n+     *     INSERT new logical resource     -- create the record - if OK, we own the lock\n+     *     IF DUPLICATE THEN               -- someone else beat us to the create\n+     *       SELECT FOR UPDATE             -- so we need to try again for a write lock\n+     *     ...\n+     *   ...\n+     * </pre>\n+     *\n+     * This works because we never delete a logical_resource record, and so don't have to deal\n+     * with concurrency issues caused when deletes are mingled with inserts/updates\n+     *\n+     * Note the execution flow aligns very closely with the DB2 stored procedure\n+     * implementation (fhir-persistence-schema/src/main/resources/add_any_resource.sql)\n+     *\n+     * @param tablePrefix\n+     * @param parameters\n+     * @param p_logical_id\n+     * @param p_payload\n+     * @param p_last_updated\n+     * @param p_is_deleted\n+     * @param p_source_key\n+     * @param p_version\n+     *\n+     * @return the resource_id for the entry we created\n+     * @throws Exception\n+     */\n+    public long storeResource(String tablePrefix, List<ExtractedParameterValue> parameters, String p_logical_id, byte[] p_payload, Timestamp p_last_updated, boolean p_is_deleted,\n+        String p_source_key, Integer p_version, Connection conn) throws Exception {\n+\n+        final String METHODNAME = \"storeResource() for \" + tablePrefix + \" resource\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Long v_logical_resource_id = null;\n+        Long v_current_resource_id = null;\n+        Long v_resource_id = null;\n+        Integer v_resource_type_id = null;\n+        boolean v_new_resource = false;\n+        boolean v_not_found = false;\n+        boolean v_duplicate = false;\n+        int v_version = 0;\n+        int v_insert_version = 0;\n+\n+        String v_resource_type = tablePrefix;\n+\n+        // Map the resource type name to the normalized id value in the database\n+        v_resource_type_id = getResourceTypeId(v_resource_type, conn);\n+        if (v_resource_type_id == null) {\n+            // programming error, as this should've been created earlier\n+            throw new IllegalStateException(\"resource type not found: \" + v_resource_type);\n+        }\n+\n+        // Get a lock at the system-wide logical resource level. Note the Derby-specific syntax\n+        final String SELECT_FOR_UPDATE = \"SELECT logical_resource_id FROM logical_resources WHERE resource_type_id = ? AND logical_id = ? FOR UPDATE\";\n+        try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+            stmt.setInt(1, v_resource_type_id);\n+            stmt.setString(2, p_logical_id);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                v_logical_resource_id = rs.getLong(1);\n+            }\n+            else {\n+                v_not_found = true;\n+                v_logical_resource_id = -1L; // just to be careful\n+            }\n+        }\n+\n+        // Create the logical resource if we don't have it already\n+        if (v_not_found) {\n+            // grab the id we want to use for the new logical resource instance\n+            final String sql2 = \"SELECT nextval('fhir_sequence')\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_logical_resource_id = res.getLong(1);\n+                }\n+                else {\n+                    // not going to happen, unless someone butchers the statement being executed\n+                    throw new IllegalStateException(\"VALUES failed to return a row: \" + sql2);\n+                }\n+            }\n+\n+            try {\n+                // insert the system-wide logical resource record.\n+                final String sql3 = \"INSERT INTO logical_resources (logical_resource_id, resource_type_id, logical_id) VALUES (?, ?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setInt(2, v_resource_type_id);\n+                    stmt.setString(3, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (translator.isDuplicate(e)) {\n+                    v_duplicate = true;\n+                }\n+                else {\n+                    throw e;\n+                }\n+            }\n+\n+            /**\n+             * remember that we have a concurrent system...so there is a possibility\n+             * that another thread snuck in before us and created the logical resource. This\n+             * is easy to handle, just turn around and read it\n+             */\n+            if (v_duplicate) {\n+                try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+                    // bind parameters\n+                    stmt.setInt(1, v_resource_type_id);\n+                    stmt.setString(2, p_logical_id);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        v_logical_resource_id = res.getLong(1);\n+                    }\n+                    else {\n+                        // Extremely unlikely as we should never delete logical resource records\n+                        throw new IllegalStateException(\"Logical resource was deleted: \" + tablePrefix + \"/\" + p_logical_id);\n+                    }\n+                }\n+            }\n+            else {\n+                v_new_resource = true;\n+\n+                // Insert the resource-specific logical resource record. Remember that logical_id is denormalized\n+                // so it gets stored again here for convenience\n+                final String sql3 = \"INSERT INTO \" + tablePrefix + \"_logical_resources (logical_resource_id, logical_id) VALUES (?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setString(2, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            }\n+        }\n+\n+        if (!v_new_resource) {\n+            // existing resource.  We need to know the current version from the\n+            // resource-specific logical resources table.\n+            final String sql3 = \"SELECT current_resource_id FROM \" + tablePrefix + \"_logical_resources WHERE logical_resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                stmt.setLong(1, v_logical_resource_id);\n+                ResultSet rs = stmt.executeQuery();\n+                if (rs.next()) {\n+                    v_current_resource_id = rs.getLong(1);\n+                }\n+                else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 329}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTE5NTU4", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396519558", "createdAt": "2020-04-20T14:41:30Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0MTozMFrOGIX9ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0MTozMFrOGIX9ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzNDQwMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            }\n          \n          \n            \n                            else {\n          \n          \n            \n                            } else {", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411434403", "createdAt": "2020-04-20T14:41:30Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,533 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an Apache PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+\n+    }\n+\n+    /**\n+     * Store the resource in the database, creating a new logical_resource entry if this is\n+     * the first version of this resource, or creating a new resource entry if this a new\n+     * version of an existing logical resource. The logic tracks closely the DB2 stored\n+     * procedure implementation, including locking of the logical_resource and handling\n+     * concurrency issues using the standard insert-or-update pattern:\n+     * <pre>\n+     *   SELECT FOR UPDATE                 -- try and get a write lock\n+     *   IF NOT FOUND THEN                 -- doesn't exist, so we don't have a lock\n+     *     INSERT new logical resource     -- create the record - if OK, we own the lock\n+     *     IF DUPLICATE THEN               -- someone else beat us to the create\n+     *       SELECT FOR UPDATE             -- so we need to try again for a write lock\n+     *     ...\n+     *   ...\n+     * </pre>\n+     *\n+     * This works because we never delete a logical_resource record, and so don't have to deal\n+     * with concurrency issues caused when deletes are mingled with inserts/updates\n+     *\n+     * Note the execution flow aligns very closely with the DB2 stored procedure\n+     * implementation (fhir-persistence-schema/src/main/resources/add_any_resource.sql)\n+     *\n+     * @param tablePrefix\n+     * @param parameters\n+     * @param p_logical_id\n+     * @param p_payload\n+     * @param p_last_updated\n+     * @param p_is_deleted\n+     * @param p_source_key\n+     * @param p_version\n+     *\n+     * @return the resource_id for the entry we created\n+     * @throws Exception\n+     */\n+    public long storeResource(String tablePrefix, List<ExtractedParameterValue> parameters, String p_logical_id, byte[] p_payload, Timestamp p_last_updated, boolean p_is_deleted,\n+        String p_source_key, Integer p_version, Connection conn) throws Exception {\n+\n+        final String METHODNAME = \"storeResource() for \" + tablePrefix + \" resource\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Long v_logical_resource_id = null;\n+        Long v_current_resource_id = null;\n+        Long v_resource_id = null;\n+        Integer v_resource_type_id = null;\n+        boolean v_new_resource = false;\n+        boolean v_not_found = false;\n+        boolean v_duplicate = false;\n+        int v_version = 0;\n+        int v_insert_version = 0;\n+\n+        String v_resource_type = tablePrefix;\n+\n+        // Map the resource type name to the normalized id value in the database\n+        v_resource_type_id = getResourceTypeId(v_resource_type, conn);\n+        if (v_resource_type_id == null) {\n+            // programming error, as this should've been created earlier\n+            throw new IllegalStateException(\"resource type not found: \" + v_resource_type);\n+        }\n+\n+        // Get a lock at the system-wide logical resource level. Note the Derby-specific syntax\n+        final String SELECT_FOR_UPDATE = \"SELECT logical_resource_id FROM logical_resources WHERE resource_type_id = ? AND logical_id = ? FOR UPDATE\";\n+        try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+            stmt.setInt(1, v_resource_type_id);\n+            stmt.setString(2, p_logical_id);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                v_logical_resource_id = rs.getLong(1);\n+            }\n+            else {\n+                v_not_found = true;\n+                v_logical_resource_id = -1L; // just to be careful\n+            }\n+        }\n+\n+        // Create the logical resource if we don't have it already\n+        if (v_not_found) {\n+            // grab the id we want to use for the new logical resource instance\n+            final String sql2 = \"SELECT nextval('fhir_sequence')\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_logical_resource_id = res.getLong(1);\n+                }\n+                else {\n+                    // not going to happen, unless someone butchers the statement being executed\n+                    throw new IllegalStateException(\"VALUES failed to return a row: \" + sql2);\n+                }\n+            }\n+\n+            try {\n+                // insert the system-wide logical resource record.\n+                final String sql3 = \"INSERT INTO logical_resources (logical_resource_id, resource_type_id, logical_id) VALUES (?, ?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setInt(2, v_resource_type_id);\n+                    stmt.setString(3, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (translator.isDuplicate(e)) {\n+                    v_duplicate = true;\n+                }\n+                else {\n+                    throw e;\n+                }\n+            }\n+\n+            /**\n+             * remember that we have a concurrent system...so there is a possibility\n+             * that another thread snuck in before us and created the logical resource. This\n+             * is easy to handle, just turn around and read it\n+             */\n+            if (v_duplicate) {\n+                try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+                    // bind parameters\n+                    stmt.setInt(1, v_resource_type_id);\n+                    stmt.setString(2, p_logical_id);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        v_logical_resource_id = res.getLong(1);\n+                    }\n+                    else {\n+                        // Extremely unlikely as we should never delete logical resource records\n+                        throw new IllegalStateException(\"Logical resource was deleted: \" + tablePrefix + \"/\" + p_logical_id);\n+                    }\n+                }\n+            }\n+            else {\n+                v_new_resource = true;\n+\n+                // Insert the resource-specific logical resource record. Remember that logical_id is denormalized\n+                // so it gets stored again here for convenience\n+                final String sql3 = \"INSERT INTO \" + tablePrefix + \"_logical_resources (logical_resource_id, logical_id) VALUES (?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setString(2, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            }\n+        }\n+\n+        if (!v_new_resource) {\n+            // existing resource.  We need to know the current version from the\n+            // resource-specific logical resources table.\n+            final String sql3 = \"SELECT current_resource_id FROM \" + tablePrefix + \"_logical_resources WHERE logical_resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                stmt.setLong(1, v_logical_resource_id);\n+                ResultSet rs = stmt.executeQuery();\n+                if (rs.next()) {\n+                    v_current_resource_id = rs.getLong(1);\n+                }\n+                else {\n+                    // This database is broken, because we shouldn't have logical_resource records without\n+                    // corresponding resource-specific logical_resource records.\n+                    throw new SQLException(\"Logical_id record '\" + p_logical_id + \"' missing for resource \" + tablePrefix);\n+                }\n+            }\n+\n+            // so if we are storing a specific version, do a quick check to make\n+            // sure that this version doesn't currently exist. This is only done when processing\n+            // replication messages which might be duplicated. We want the operation to be idempotent,\n+            // so if the resource already exists, we don't need to do anything else.\n+\n+            if (p_version != null) {\n+                final String sqlStmt = \"SELECT resource_id FROM \" + tablePrefix + \"_resources dr WHERE dr.logical_resource_id = ? AND dr.version_id = ?\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sqlStmt)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setLong(2, p_version);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        // this version of this resource already exists, so we bail out right away\n+                        v_resource_id = res.getLong(1);\n+                        return v_resource_id;\n+                    }\n+                }\n+            }\n+\n+            // Grab the version value for the current version (identified by v_current_resource_id)\n+            final String sql4 = \"SELECT version_id FROM \" + tablePrefix + \"_resources WHERE resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql4)) {\n+                stmt.setLong(1, v_current_resource_id);\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_version = res.getInt(1);\n+                }\n+                else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 364}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTE5NzI3", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396519727", "createdAt": "2020-04-20T14:41:40Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0MTo0MFrOGIX-GQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0MTo0MFrOGIX-GQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzNDUyMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    }\n          \n          \n            \n                    else {\n          \n          \n            \n                    } else {", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411434521", "createdAt": "2020-04-20T14:41:40Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,533 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an Apache PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+\n+    }\n+\n+    /**\n+     * Store the resource in the database, creating a new logical_resource entry if this is\n+     * the first version of this resource, or creating a new resource entry if this a new\n+     * version of an existing logical resource. The logic tracks closely the DB2 stored\n+     * procedure implementation, including locking of the logical_resource and handling\n+     * concurrency issues using the standard insert-or-update pattern:\n+     * <pre>\n+     *   SELECT FOR UPDATE                 -- try and get a write lock\n+     *   IF NOT FOUND THEN                 -- doesn't exist, so we don't have a lock\n+     *     INSERT new logical resource     -- create the record - if OK, we own the lock\n+     *     IF DUPLICATE THEN               -- someone else beat us to the create\n+     *       SELECT FOR UPDATE             -- so we need to try again for a write lock\n+     *     ...\n+     *   ...\n+     * </pre>\n+     *\n+     * This works because we never delete a logical_resource record, and so don't have to deal\n+     * with concurrency issues caused when deletes are mingled with inserts/updates\n+     *\n+     * Note the execution flow aligns very closely with the DB2 stored procedure\n+     * implementation (fhir-persistence-schema/src/main/resources/add_any_resource.sql)\n+     *\n+     * @param tablePrefix\n+     * @param parameters\n+     * @param p_logical_id\n+     * @param p_payload\n+     * @param p_last_updated\n+     * @param p_is_deleted\n+     * @param p_source_key\n+     * @param p_version\n+     *\n+     * @return the resource_id for the entry we created\n+     * @throws Exception\n+     */\n+    public long storeResource(String tablePrefix, List<ExtractedParameterValue> parameters, String p_logical_id, byte[] p_payload, Timestamp p_last_updated, boolean p_is_deleted,\n+        String p_source_key, Integer p_version, Connection conn) throws Exception {\n+\n+        final String METHODNAME = \"storeResource() for \" + tablePrefix + \" resource\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Long v_logical_resource_id = null;\n+        Long v_current_resource_id = null;\n+        Long v_resource_id = null;\n+        Integer v_resource_type_id = null;\n+        boolean v_new_resource = false;\n+        boolean v_not_found = false;\n+        boolean v_duplicate = false;\n+        int v_version = 0;\n+        int v_insert_version = 0;\n+\n+        String v_resource_type = tablePrefix;\n+\n+        // Map the resource type name to the normalized id value in the database\n+        v_resource_type_id = getResourceTypeId(v_resource_type, conn);\n+        if (v_resource_type_id == null) {\n+            // programming error, as this should've been created earlier\n+            throw new IllegalStateException(\"resource type not found: \" + v_resource_type);\n+        }\n+\n+        // Get a lock at the system-wide logical resource level. Note the Derby-specific syntax\n+        final String SELECT_FOR_UPDATE = \"SELECT logical_resource_id FROM logical_resources WHERE resource_type_id = ? AND logical_id = ? FOR UPDATE\";\n+        try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+            stmt.setInt(1, v_resource_type_id);\n+            stmt.setString(2, p_logical_id);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                v_logical_resource_id = rs.getLong(1);\n+            }\n+            else {\n+                v_not_found = true;\n+                v_logical_resource_id = -1L; // just to be careful\n+            }\n+        }\n+\n+        // Create the logical resource if we don't have it already\n+        if (v_not_found) {\n+            // grab the id we want to use for the new logical resource instance\n+            final String sql2 = \"SELECT nextval('fhir_sequence')\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_logical_resource_id = res.getLong(1);\n+                }\n+                else {\n+                    // not going to happen, unless someone butchers the statement being executed\n+                    throw new IllegalStateException(\"VALUES failed to return a row: \" + sql2);\n+                }\n+            }\n+\n+            try {\n+                // insert the system-wide logical resource record.\n+                final String sql3 = \"INSERT INTO logical_resources (logical_resource_id, resource_type_id, logical_id) VALUES (?, ?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setInt(2, v_resource_type_id);\n+                    stmt.setString(3, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (translator.isDuplicate(e)) {\n+                    v_duplicate = true;\n+                }\n+                else {\n+                    throw e;\n+                }\n+            }\n+\n+            /**\n+             * remember that we have a concurrent system...so there is a possibility\n+             * that another thread snuck in before us and created the logical resource. This\n+             * is easy to handle, just turn around and read it\n+             */\n+            if (v_duplicate) {\n+                try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+                    // bind parameters\n+                    stmt.setInt(1, v_resource_type_id);\n+                    stmt.setString(2, p_logical_id);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        v_logical_resource_id = res.getLong(1);\n+                    }\n+                    else {\n+                        // Extremely unlikely as we should never delete logical resource records\n+                        throw new IllegalStateException(\"Logical resource was deleted: \" + tablePrefix + \"/\" + p_logical_id);\n+                    }\n+                }\n+            }\n+            else {\n+                v_new_resource = true;\n+\n+                // Insert the resource-specific logical resource record. Remember that logical_id is denormalized\n+                // so it gets stored again here for convenience\n+                final String sql3 = \"INSERT INTO \" + tablePrefix + \"_logical_resources (logical_resource_id, logical_id) VALUES (?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setString(2, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            }\n+        }\n+\n+        if (!v_new_resource) {\n+            // existing resource.  We need to know the current version from the\n+            // resource-specific logical resources table.\n+            final String sql3 = \"SELECT current_resource_id FROM \" + tablePrefix + \"_logical_resources WHERE logical_resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                stmt.setLong(1, v_logical_resource_id);\n+                ResultSet rs = stmt.executeQuery();\n+                if (rs.next()) {\n+                    v_current_resource_id = rs.getLong(1);\n+                }\n+                else {\n+                    // This database is broken, because we shouldn't have logical_resource records without\n+                    // corresponding resource-specific logical_resource records.\n+                    throw new SQLException(\"Logical_id record '\" + p_logical_id + \"' missing for resource \" + tablePrefix);\n+                }\n+            }\n+\n+            // so if we are storing a specific version, do a quick check to make\n+            // sure that this version doesn't currently exist. This is only done when processing\n+            // replication messages which might be duplicated. We want the operation to be idempotent,\n+            // so if the resource already exists, we don't need to do anything else.\n+\n+            if (p_version != null) {\n+                final String sqlStmt = \"SELECT resource_id FROM \" + tablePrefix + \"_resources dr WHERE dr.logical_resource_id = ? AND dr.version_id = ?\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sqlStmt)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setLong(2, p_version);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        // this version of this resource already exists, so we bail out right away\n+                        v_resource_id = res.getLong(1);\n+                        return v_resource_id;\n+                    }\n+                }\n+            }\n+\n+            // Grab the version value for the current version (identified by v_current_resource_id)\n+            final String sql4 = \"SELECT version_id FROM \" + tablePrefix + \"_resources WHERE resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql4)) {\n+                stmt.setLong(1, v_current_resource_id);\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_version = res.getInt(1);\n+                }\n+                else {\n+                    throw new IllegalStateException(\"current resource not found: \"\n+                            + tablePrefix + \"_resources.resource_id=\" + v_current_resource_id);\n+                }\n+            }\n+\n+            //If we have been passed a version number, this means that this is a replicated\n+            //resource, and so we only need to delete parameters if the given version is\n+            // later than the current version\n+            if (p_version == null || p_version > v_version) {\n+                // existing resource, so need to delete all its parameters\n+                // delete composites first, or else the foreign keys there restrict deletes on referenced tables\n+                deleteFromParameterTable(conn, tablePrefix + \"_composites\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_str_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_number_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_date_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_latlng_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_token_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_quantity_values\", v_logical_resource_id);\n+            }\n+        }\n+\n+        // Persist the data using the given version number if required\n+        if (p_version != null) {\n+            v_insert_version = p_version;\n+        }\n+        else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 390}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTE5ODcx", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396519871", "createdAt": "2020-04-20T14:41:49Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0MTo0OVrOGIX-qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0MTo0OVrOGIX-qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzNDY2Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        }\n          \n          \n            \n                        else {\n          \n          \n            \n                        } else {", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411434667", "createdAt": "2020-04-20T14:41:49Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,533 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an Apache PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+\n+    }\n+\n+    /**\n+     * Store the resource in the database, creating a new logical_resource entry if this is\n+     * the first version of this resource, or creating a new resource entry if this a new\n+     * version of an existing logical resource. The logic tracks closely the DB2 stored\n+     * procedure implementation, including locking of the logical_resource and handling\n+     * concurrency issues using the standard insert-or-update pattern:\n+     * <pre>\n+     *   SELECT FOR UPDATE                 -- try and get a write lock\n+     *   IF NOT FOUND THEN                 -- doesn't exist, so we don't have a lock\n+     *     INSERT new logical resource     -- create the record - if OK, we own the lock\n+     *     IF DUPLICATE THEN               -- someone else beat us to the create\n+     *       SELECT FOR UPDATE             -- so we need to try again for a write lock\n+     *     ...\n+     *   ...\n+     * </pre>\n+     *\n+     * This works because we never delete a logical_resource record, and so don't have to deal\n+     * with concurrency issues caused when deletes are mingled with inserts/updates\n+     *\n+     * Note the execution flow aligns very closely with the DB2 stored procedure\n+     * implementation (fhir-persistence-schema/src/main/resources/add_any_resource.sql)\n+     *\n+     * @param tablePrefix\n+     * @param parameters\n+     * @param p_logical_id\n+     * @param p_payload\n+     * @param p_last_updated\n+     * @param p_is_deleted\n+     * @param p_source_key\n+     * @param p_version\n+     *\n+     * @return the resource_id for the entry we created\n+     * @throws Exception\n+     */\n+    public long storeResource(String tablePrefix, List<ExtractedParameterValue> parameters, String p_logical_id, byte[] p_payload, Timestamp p_last_updated, boolean p_is_deleted,\n+        String p_source_key, Integer p_version, Connection conn) throws Exception {\n+\n+        final String METHODNAME = \"storeResource() for \" + tablePrefix + \" resource\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Long v_logical_resource_id = null;\n+        Long v_current_resource_id = null;\n+        Long v_resource_id = null;\n+        Integer v_resource_type_id = null;\n+        boolean v_new_resource = false;\n+        boolean v_not_found = false;\n+        boolean v_duplicate = false;\n+        int v_version = 0;\n+        int v_insert_version = 0;\n+\n+        String v_resource_type = tablePrefix;\n+\n+        // Map the resource type name to the normalized id value in the database\n+        v_resource_type_id = getResourceTypeId(v_resource_type, conn);\n+        if (v_resource_type_id == null) {\n+            // programming error, as this should've been created earlier\n+            throw new IllegalStateException(\"resource type not found: \" + v_resource_type);\n+        }\n+\n+        // Get a lock at the system-wide logical resource level. Note the Derby-specific syntax\n+        final String SELECT_FOR_UPDATE = \"SELECT logical_resource_id FROM logical_resources WHERE resource_type_id = ? AND logical_id = ? FOR UPDATE\";\n+        try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+            stmt.setInt(1, v_resource_type_id);\n+            stmt.setString(2, p_logical_id);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                v_logical_resource_id = rs.getLong(1);\n+            }\n+            else {\n+                v_not_found = true;\n+                v_logical_resource_id = -1L; // just to be careful\n+            }\n+        }\n+\n+        // Create the logical resource if we don't have it already\n+        if (v_not_found) {\n+            // grab the id we want to use for the new logical resource instance\n+            final String sql2 = \"SELECT nextval('fhir_sequence')\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_logical_resource_id = res.getLong(1);\n+                }\n+                else {\n+                    // not going to happen, unless someone butchers the statement being executed\n+                    throw new IllegalStateException(\"VALUES failed to return a row: \" + sql2);\n+                }\n+            }\n+\n+            try {\n+                // insert the system-wide logical resource record.\n+                final String sql3 = \"INSERT INTO logical_resources (logical_resource_id, resource_type_id, logical_id) VALUES (?, ?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setInt(2, v_resource_type_id);\n+                    stmt.setString(3, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (translator.isDuplicate(e)) {\n+                    v_duplicate = true;\n+                }\n+                else {\n+                    throw e;\n+                }\n+            }\n+\n+            /**\n+             * remember that we have a concurrent system...so there is a possibility\n+             * that another thread snuck in before us and created the logical resource. This\n+             * is easy to handle, just turn around and read it\n+             */\n+            if (v_duplicate) {\n+                try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+                    // bind parameters\n+                    stmt.setInt(1, v_resource_type_id);\n+                    stmt.setString(2, p_logical_id);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        v_logical_resource_id = res.getLong(1);\n+                    }\n+                    else {\n+                        // Extremely unlikely as we should never delete logical resource records\n+                        throw new IllegalStateException(\"Logical resource was deleted: \" + tablePrefix + \"/\" + p_logical_id);\n+                    }\n+                }\n+            }\n+            else {\n+                v_new_resource = true;\n+\n+                // Insert the resource-specific logical resource record. Remember that logical_id is denormalized\n+                // so it gets stored again here for convenience\n+                final String sql3 = \"INSERT INTO \" + tablePrefix + \"_logical_resources (logical_resource_id, logical_id) VALUES (?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setString(2, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            }\n+        }\n+\n+        if (!v_new_resource) {\n+            // existing resource.  We need to know the current version from the\n+            // resource-specific logical resources table.\n+            final String sql3 = \"SELECT current_resource_id FROM \" + tablePrefix + \"_logical_resources WHERE logical_resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                stmt.setLong(1, v_logical_resource_id);\n+                ResultSet rs = stmt.executeQuery();\n+                if (rs.next()) {\n+                    v_current_resource_id = rs.getLong(1);\n+                }\n+                else {\n+                    // This database is broken, because we shouldn't have logical_resource records without\n+                    // corresponding resource-specific logical_resource records.\n+                    throw new SQLException(\"Logical_id record '\" + p_logical_id + \"' missing for resource \" + tablePrefix);\n+                }\n+            }\n+\n+            // so if we are storing a specific version, do a quick check to make\n+            // sure that this version doesn't currently exist. This is only done when processing\n+            // replication messages which might be duplicated. We want the operation to be idempotent,\n+            // so if the resource already exists, we don't need to do anything else.\n+\n+            if (p_version != null) {\n+                final String sqlStmt = \"SELECT resource_id FROM \" + tablePrefix + \"_resources dr WHERE dr.logical_resource_id = ? AND dr.version_id = ?\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sqlStmt)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setLong(2, p_version);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        // this version of this resource already exists, so we bail out right away\n+                        v_resource_id = res.getLong(1);\n+                        return v_resource_id;\n+                    }\n+                }\n+            }\n+\n+            // Grab the version value for the current version (identified by v_current_resource_id)\n+            final String sql4 = \"SELECT version_id FROM \" + tablePrefix + \"_resources WHERE resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql4)) {\n+                stmt.setLong(1, v_current_resource_id);\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_version = res.getInt(1);\n+                }\n+                else {\n+                    throw new IllegalStateException(\"current resource not found: \"\n+                            + tablePrefix + \"_resources.resource_id=\" + v_current_resource_id);\n+                }\n+            }\n+\n+            //If we have been passed a version number, this means that this is a replicated\n+            //resource, and so we only need to delete parameters if the given version is\n+            // later than the current version\n+            if (p_version == null || p_version > v_version) {\n+                // existing resource, so need to delete all its parameters\n+                // delete composites first, or else the foreign keys there restrict deletes on referenced tables\n+                deleteFromParameterTable(conn, tablePrefix + \"_composites\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_str_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_number_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_date_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_latlng_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_token_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_quantity_values\", v_logical_resource_id);\n+            }\n+        }\n+\n+        // Persist the data using the given version number if required\n+        if (p_version != null) {\n+            v_insert_version = p_version;\n+        }\n+        else {\n+            // remember we have a write (update) lock on the logical version, so we can safely calculate\n+            // the next version value here\n+            v_insert_version = v_version + 1;\n+\n+        }\n+\n+        /**\n+         * Create the new resource version.\n+         * Alpha version uses last_updated time from the app-server, so we keep that here\n+         */\n+        String sql2 = \"SELECT nextval('fhir_sequence')\";\n+        try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+            ResultSet res = stmt.executeQuery();\n+            if (res.next()) {\n+                v_resource_id = res.getLong(1); //Assign result of the above query\n+            }\n+            else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 407}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTIwMDY2", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396520066", "createdAt": "2020-04-20T14:42:03Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0MjowM1rOGIX_Ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0MjowM1rOGIX_Ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzNDgxMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        }\n          \n          \n            \n                        else {\n          \n          \n            \n                            result = null;\n          \n          \n            \n                        } else {\n          \n          \n            \n                            result = null;", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411434811", "createdAt": "2020-04-20T14:42:03Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,533 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an Apache PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+\n+    }\n+\n+    /**\n+     * Store the resource in the database, creating a new logical_resource entry if this is\n+     * the first version of this resource, or creating a new resource entry if this a new\n+     * version of an existing logical resource. The logic tracks closely the DB2 stored\n+     * procedure implementation, including locking of the logical_resource and handling\n+     * concurrency issues using the standard insert-or-update pattern:\n+     * <pre>\n+     *   SELECT FOR UPDATE                 -- try and get a write lock\n+     *   IF NOT FOUND THEN                 -- doesn't exist, so we don't have a lock\n+     *     INSERT new logical resource     -- create the record - if OK, we own the lock\n+     *     IF DUPLICATE THEN               -- someone else beat us to the create\n+     *       SELECT FOR UPDATE             -- so we need to try again for a write lock\n+     *     ...\n+     *   ...\n+     * </pre>\n+     *\n+     * This works because we never delete a logical_resource record, and so don't have to deal\n+     * with concurrency issues caused when deletes are mingled with inserts/updates\n+     *\n+     * Note the execution flow aligns very closely with the DB2 stored procedure\n+     * implementation (fhir-persistence-schema/src/main/resources/add_any_resource.sql)\n+     *\n+     * @param tablePrefix\n+     * @param parameters\n+     * @param p_logical_id\n+     * @param p_payload\n+     * @param p_last_updated\n+     * @param p_is_deleted\n+     * @param p_source_key\n+     * @param p_version\n+     *\n+     * @return the resource_id for the entry we created\n+     * @throws Exception\n+     */\n+    public long storeResource(String tablePrefix, List<ExtractedParameterValue> parameters, String p_logical_id, byte[] p_payload, Timestamp p_last_updated, boolean p_is_deleted,\n+        String p_source_key, Integer p_version, Connection conn) throws Exception {\n+\n+        final String METHODNAME = \"storeResource() for \" + tablePrefix + \" resource\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Long v_logical_resource_id = null;\n+        Long v_current_resource_id = null;\n+        Long v_resource_id = null;\n+        Integer v_resource_type_id = null;\n+        boolean v_new_resource = false;\n+        boolean v_not_found = false;\n+        boolean v_duplicate = false;\n+        int v_version = 0;\n+        int v_insert_version = 0;\n+\n+        String v_resource_type = tablePrefix;\n+\n+        // Map the resource type name to the normalized id value in the database\n+        v_resource_type_id = getResourceTypeId(v_resource_type, conn);\n+        if (v_resource_type_id == null) {\n+            // programming error, as this should've been created earlier\n+            throw new IllegalStateException(\"resource type not found: \" + v_resource_type);\n+        }\n+\n+        // Get a lock at the system-wide logical resource level. Note the Derby-specific syntax\n+        final String SELECT_FOR_UPDATE = \"SELECT logical_resource_id FROM logical_resources WHERE resource_type_id = ? AND logical_id = ? FOR UPDATE\";\n+        try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+            stmt.setInt(1, v_resource_type_id);\n+            stmt.setString(2, p_logical_id);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                v_logical_resource_id = rs.getLong(1);\n+            }\n+            else {\n+                v_not_found = true;\n+                v_logical_resource_id = -1L; // just to be careful\n+            }\n+        }\n+\n+        // Create the logical resource if we don't have it already\n+        if (v_not_found) {\n+            // grab the id we want to use for the new logical resource instance\n+            final String sql2 = \"SELECT nextval('fhir_sequence')\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_logical_resource_id = res.getLong(1);\n+                }\n+                else {\n+                    // not going to happen, unless someone butchers the statement being executed\n+                    throw new IllegalStateException(\"VALUES failed to return a row: \" + sql2);\n+                }\n+            }\n+\n+            try {\n+                // insert the system-wide logical resource record.\n+                final String sql3 = \"INSERT INTO logical_resources (logical_resource_id, resource_type_id, logical_id) VALUES (?, ?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setInt(2, v_resource_type_id);\n+                    stmt.setString(3, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (translator.isDuplicate(e)) {\n+                    v_duplicate = true;\n+                }\n+                else {\n+                    throw e;\n+                }\n+            }\n+\n+            /**\n+             * remember that we have a concurrent system...so there is a possibility\n+             * that another thread snuck in before us and created the logical resource. This\n+             * is easy to handle, just turn around and read it\n+             */\n+            if (v_duplicate) {\n+                try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+                    // bind parameters\n+                    stmt.setInt(1, v_resource_type_id);\n+                    stmt.setString(2, p_logical_id);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        v_logical_resource_id = res.getLong(1);\n+                    }\n+                    else {\n+                        // Extremely unlikely as we should never delete logical resource records\n+                        throw new IllegalStateException(\"Logical resource was deleted: \" + tablePrefix + \"/\" + p_logical_id);\n+                    }\n+                }\n+            }\n+            else {\n+                v_new_resource = true;\n+\n+                // Insert the resource-specific logical resource record. Remember that logical_id is denormalized\n+                // so it gets stored again here for convenience\n+                final String sql3 = \"INSERT INTO \" + tablePrefix + \"_logical_resources (logical_resource_id, logical_id) VALUES (?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setString(2, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            }\n+        }\n+\n+        if (!v_new_resource) {\n+            // existing resource.  We need to know the current version from the\n+            // resource-specific logical resources table.\n+            final String sql3 = \"SELECT current_resource_id FROM \" + tablePrefix + \"_logical_resources WHERE logical_resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                stmt.setLong(1, v_logical_resource_id);\n+                ResultSet rs = stmt.executeQuery();\n+                if (rs.next()) {\n+                    v_current_resource_id = rs.getLong(1);\n+                }\n+                else {\n+                    // This database is broken, because we shouldn't have logical_resource records without\n+                    // corresponding resource-specific logical_resource records.\n+                    throw new SQLException(\"Logical_id record '\" + p_logical_id + \"' missing for resource \" + tablePrefix);\n+                }\n+            }\n+\n+            // so if we are storing a specific version, do a quick check to make\n+            // sure that this version doesn't currently exist. This is only done when processing\n+            // replication messages which might be duplicated. We want the operation to be idempotent,\n+            // so if the resource already exists, we don't need to do anything else.\n+\n+            if (p_version != null) {\n+                final String sqlStmt = \"SELECT resource_id FROM \" + tablePrefix + \"_resources dr WHERE dr.logical_resource_id = ? AND dr.version_id = ?\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sqlStmt)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setLong(2, p_version);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        // this version of this resource already exists, so we bail out right away\n+                        v_resource_id = res.getLong(1);\n+                        return v_resource_id;\n+                    }\n+                }\n+            }\n+\n+            // Grab the version value for the current version (identified by v_current_resource_id)\n+            final String sql4 = \"SELECT version_id FROM \" + tablePrefix + \"_resources WHERE resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql4)) {\n+                stmt.setLong(1, v_current_resource_id);\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_version = res.getInt(1);\n+                }\n+                else {\n+                    throw new IllegalStateException(\"current resource not found: \"\n+                            + tablePrefix + \"_resources.resource_id=\" + v_current_resource_id);\n+                }\n+            }\n+\n+            //If we have been passed a version number, this means that this is a replicated\n+            //resource, and so we only need to delete parameters if the given version is\n+            // later than the current version\n+            if (p_version == null || p_version > v_version) {\n+                // existing resource, so need to delete all its parameters\n+                // delete composites first, or else the foreign keys there restrict deletes on referenced tables\n+                deleteFromParameterTable(conn, tablePrefix + \"_composites\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_str_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_number_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_date_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_latlng_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_token_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_quantity_values\", v_logical_resource_id);\n+            }\n+        }\n+\n+        // Persist the data using the given version number if required\n+        if (p_version != null) {\n+            v_insert_version = p_version;\n+        }\n+        else {\n+            // remember we have a write (update) lock on the logical version, so we can safely calculate\n+            // the next version value here\n+            v_insert_version = v_version + 1;\n+\n+        }\n+\n+        /**\n+         * Create the new resource version.\n+         * Alpha version uses last_updated time from the app-server, so we keep that here\n+         */\n+        String sql2 = \"SELECT nextval('fhir_sequence')\";\n+        try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+            ResultSet res = stmt.executeQuery();\n+            if (res.next()) {\n+                v_resource_id = res.getLong(1); //Assign result of the above query\n+            }\n+            else {\n+                // unlikely\n+                throw new IllegalStateException(\"no row returned: \" + sql2);\n+            }\n+        }\n+\n+        // Finally we get to the big resource data insert\n+        String sql3 = \"INSERT INTO \" + tablePrefix + \"_resources (resource_id, logical_resource_id, version_id, data, last_updated, is_deleted) \"\n+                + \"VALUES (?,?,?,?,?,?)\";\n+        try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+            // bind parameters\n+            stmt.setLong(1, v_resource_id);\n+            stmt.setLong(2, v_logical_resource_id);\n+            stmt.setInt(3, v_insert_version);\n+            stmt.setBytes(4, p_payload);\n+            stmt.setTimestamp(5, p_last_updated, UTC);\n+            stmt.setString(6, p_is_deleted ? \"Y\" : \"N\");\n+            stmt.executeUpdate();\n+        }\n+\n+        if (p_version == null || p_version > v_version) {\n+            //only update the logical resource if the resource we are adding supercedes the\n+            //current resource\n+            String sql4 = \"UPDATE \" + tablePrefix + \"_logical_resources SET current_resource_id = ? WHERE logical_resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql4)) {\n+                // bind parameters\n+                stmt.setLong(1, v_resource_id);\n+                stmt.setLong(2, v_logical_resource_id);\n+                stmt.executeUpdate();\n+            }\n+\n+            // To keep things simple for the Derby use-case, we just use a visitor to\n+            // handle inserts of parameters directly in the resource parameter tables.\n+            // Note we don't get any parameters for the resource soft-delete operation\n+            if (parameters != null) {\n+                // Derby doesn't support partitioned multi-tenancy, so we disable it on the DAO:\n+                try (ParameterVisitorBatchDAO pvd = new ParameterVisitorBatchDAO(conn, null, tablePrefix, false, v_logical_resource_id, 100,\n+                    new ParameterNameCacheAdapter(parameterNameDAO), new CodeSystemCacheAdapter(codeSystemDAO))) {\n+                    for (ExtractedParameterValue p: parameters) {\n+                        p.accept(pvd);\n+                    }\n+                }\n+            }\n+        }\n+        logger.exiting(CLASSNAME, METHODNAME);\n+        return v_resource_id;\n+    }\n+\n+\n+    /**\n+     * Delete all parameters for the given resourceId from the parameters table\n+     *\n+     * @param conn\n+     * @param tableName\n+     * @param logicalResourceId\n+     * @throws SQLException\n+     */\n+    protected void deleteFromParameterTable(Connection conn, String tableName, long logicalResourceId) throws SQLException {\n+        final String delStrValues = \"DELETE FROM \" + tableName + \" WHERE logical_resource_id = ?\";\n+        try (PreparedStatement stmt = conn.prepareStatement(delStrValues)) {\n+            // bind parameters\n+            stmt.setLong(1, logicalResourceId);\n+            stmt.executeUpdate();\n+        }\n+\n+    }\n+\n+    /**\n+     * Read the id for the named type\n+     * @param resourceTypeName\n+     * @return the database id, or null if the named record is not found\n+     * @throws SQLException\n+     */\n+    protected Integer getResourceTypeId(String resourceTypeName, Connection conn) throws SQLException {\n+        Integer result;\n+\n+        final String sql1 = \"SELECT resource_type_id FROM resource_types WHERE resource_type = ?\";\n+\n+        try (PreparedStatement stmt = conn.prepareStatement(sql1)) {\n+            stmt.setString(1, resourceTypeName);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                result = rs.getInt(1);\n+            }\n+            else {\n+                result = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 492}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTIxODgx", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396521881", "createdAt": "2020-04-20T14:43:57Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0Mzo1N1rOGIYFLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0Mzo1N1rOGIYFLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzNjMzMw==", "bodyText": "no grants?\nIf we are not implementing here, we should create a backlog issue.", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411436333", "createdAt": "2020-04-20T14:43:57Z", "author": {"login": "prb112"}, "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/app/Main.java", "diffHunk": "@@ -765,7 +778,7 @@ protected void process() {\n      * @param groupName\n      */\n     protected void grantPrivileges(String groupName) {\n-        if (dbType == DbType.DERBY) {\n+        if (dbType == DbType.DERBY || dbType == DbType.POSTGRESQL) {\n             return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 63}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTIyNjQ4", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396522648", "createdAt": "2020-04-20T14:44:48Z", "commit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0NDo0OFrOGIYHlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0NDo0OFrOGIYHlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzNjk1MQ==", "bodyText": "Suggested change", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411436951", "createdAt": "2020-04-20T14:44:48Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/test/resources/test.jdbc-perform.properties", "diffHunk": "@@ -6,14 +6,23 @@\n #Don't need any configuration for derby embedded\n \n #Derby network properties\n-#dbUrl=jdbc:derby://localhost:1527/fhirdb\n+#dbUrl = jdbc:derby://localhost:1527/fhirdb\n \n #DB2 properties\n-dbDriverName=com.ibm.db2.jcc.DB2Driver\n-db.host=localhost\n-db.port=50000\n-db.database=fhirdb\n-user=db2inst1\n-password=change-password\n+db.host = localhost\n+db.port = 50000\n+db.database = fhirdb\n+user = db2inst1\n+password = change-password\n+\n+#PostgreSql properties\n+#db.host = localhost\n+#db.port = 5432\n+#db.database = fhirdb\n+#user = postgre\n+#password = change-password\n+\n+\n+#Common properties\n updateCreateEnabled=true\n-schemaName=FHIRDATA\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865ce7b2fd5a7e86d877e8ddb7b5ddec9b7fe148"}, "originalPosition": 31}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTI2MjE3", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396526217", "createdAt": "2020-04-20T14:48:38Z", "commit": {"oid": "91735b41e84b1932c6512ca41ddbfbd33c4ce73a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0ODozOFrOGIYTkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0ODozOFrOGIYTkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ0MDAxNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    public static FHIRResourceDAOType of(Connection con) throws SQLException, IllegalArgumentException {\n          \n          \n            \n                        String dbUrl = con.getMetaData().getURL();\n          \n          \n            \n                        dbUrl = dbUrl.toLowerCase();\n          \n          \n            \n                        if (dbUrl.contains(DB2.value)) {\n          \n          \n            \n                            return DB2;\n          \n          \n            \n                        } else if (dbUrl.contains(DERBY.value)) {\n          \n          \n            \n                            return DERBY;\n          \n          \n            \n                        } else if (dbUrl.contains(POSTGRESQL.value)) {\n          \n          \n            \n                            return POSTGRESQL;\n          \n          \n            \n                        } else {\n          \n          \n            \n                            throw new IllegalArgumentException(dbUrl);\n          \n          \n            \n                        }\n          \n          \n            \n            \n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n                    public static FHIRResourceDAOType of(Connection conn) throws SQLException, IllegalArgumentException {\n          \n          \n            \n                        String dbUrl = conn.getMetaData().getURL();\n          \n          \n            \n                        dbUrl = dbUrl.toLowerCase();\n          \n          \n            \n                        if (dbUrl.contains(DB2.value)) {\n          \n          \n            \n                            return DB2;\n          \n          \n            \n                        } else if (dbUrl.contains(DERBY.value)) {\n          \n          \n            \n                            return DERBY;\n          \n          \n            \n                        } else if (dbUrl.contains(POSTGRESQL.value)) {\n          \n          \n            \n                            return POSTGRESQL;\n          \n          \n            \n                        } else {\n          \n          \n            \n                            throw new IllegalArgumentException(dbUrl);\n          \n          \n            \n                        }\n          \n          \n            \n            \n          \n          \n            \n                    }\n          \n          \n            \n                }", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411440016", "createdAt": "2020-04-20T14:48:38Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/FHIRResourceDAOFactory.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.persistence.jdbc.dao.api.ResourceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyResourceDAO;\n+import com.ibm.fhir.persistence.jdbc.postgresql.PostgreSqlResourceDAO;\n+\n+public class FHIRResourceDAOFactory {\n+\n+    // The various DAO Types that are used in the JDBC Persistence layer. \n+    public enum DAOType {\n+        DB2(\"db2\"),\n+        DERBY(\"derby\"),\n+        POSTGRESQL(\"postgresql\");\n+\n+        private final String value;\n+\n+        FHIRResourceDAOType(String value) {\n+            this.value = value;\n+        }\n+\n+        public String value() {\n+            return value;\n+        }\n+\n+        public static FHIRResourceDAOType of(Connection con) throws SQLException, IllegalArgumentException {\n+            String dbUrl = con.getMetaData().getURL();\n+            dbUrl = dbUrl.toLowerCase();\n+            if (dbUrl.contains(DB2.value)) {\n+                return DB2;\n+            } else if (dbUrl.contains(DERBY.value)) {\n+                return DERBY;\n+            } else if (dbUrl.contains(POSTGRESQL.value)) {\n+                return POSTGRESQL;\n+            } else {\n+                throw new IllegalArgumentException(dbUrl);\n+            }\n+\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91735b41e84b1932c6512ca41ddbfbd33c4ce73a"}, "originalPosition": 51}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTI3NTIw", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396527520", "createdAt": "2020-04-20T14:49:59Z", "commit": {"oid": "91735b41e84b1932c6512ca41ddbfbd33c4ce73a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo1MDowMFrOGIYX2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo1MDowMFrOGIYX2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ0MTExMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static ResourceDAO getResourceDAO (Connection con) throws IllegalArgumentException, SQLException {\n          \n          \n            \n                    ResourceDAO resourceDAO = null;\n          \n          \n            \n                    switch (FHIRResourceDAOType.of(con)) {\n          \n          \n            \n                        case DB2:\n          \n          \n            \n                            resourceDAO = new ResourceDAOImpl(con);\n          \n          \n            \n                            break;\n          \n          \n            \n                        case DERBY:\n          \n          \n            \n                            resourceDAO = new DerbyResourceDAO(con);\n          \n          \n            \n                            break;\n          \n          \n            \n                        case POSTGRESQL:\n          \n          \n            \n                            resourceDAO = new PostgreSqlResourceDAO(con);\n          \n          \n            \n                            break;\n          \n          \n            \n                    }\n          \n          \n            \n                    return resourceDAO;\n          \n          \n            \n                }\n          \n          \n            \n                public static ResourceDAO getResourceDAO (Connection conn) throws IllegalArgumentException, SQLException {\n          \n          \n            \n                    ResourceDAO resourceDAO = null;\n          \n          \n            \n                    switch (FHIRResourceDAOType.of(conn)) {\n          \n          \n            \n                        case DB2:\n          \n          \n            \n                            resourceDAO = new ResourceDAOImpl(conn);\n          \n          \n            \n                            break;\n          \n          \n            \n                        case DERBY:\n          \n          \n            \n                            resourceDAO = new DerbyResourceDAO(conn);\n          \n          \n            \n                            break;\n          \n          \n            \n                        case POSTGRESQL:\n          \n          \n            \n                            resourceDAO = new PostgreSqlResourceDAO(conn);\n          \n          \n            \n                            break;\n          \n          \n            \n                    }\n          \n          \n            \n                    return resourceDAO;\n          \n          \n            \n                }", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411441113", "createdAt": "2020-04-20T14:50:00Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/FHIRResourceDAOFactory.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.persistence.jdbc.dao.api.ResourceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyResourceDAO;\n+import com.ibm.fhir.persistence.jdbc.postgresql.PostgreSqlResourceDAO;\n+\n+public class FHIRResourceDAOFactory {\n+\n+    // The various DAO Types that are used in the JDBC Persistence layer. \n+    public enum DAOType {\n+        DB2(\"db2\"),\n+        DERBY(\"derby\"),\n+        POSTGRESQL(\"postgresql\");\n+\n+        private final String value;\n+\n+        FHIRResourceDAOType(String value) {\n+            this.value = value;\n+        }\n+\n+        public String value() {\n+            return value;\n+        }\n+\n+        public static FHIRResourceDAOType of(Connection con) throws SQLException, IllegalArgumentException {\n+            String dbUrl = con.getMetaData().getURL();\n+            dbUrl = dbUrl.toLowerCase();\n+            if (dbUrl.contains(DB2.value)) {\n+                return DB2;\n+            } else if (dbUrl.contains(DERBY.value)) {\n+                return DERBY;\n+            } else if (dbUrl.contains(POSTGRESQL.value)) {\n+                return POSTGRESQL;\n+            } else {\n+                throw new IllegalArgumentException(dbUrl);\n+            }\n+\n+        }\n+    }\n+\n+   public static ResourceDAO getResourceDAO (Connection conn, TransactionSynchronizationRegistry trxSynchRegistry) throws IllegalArgumentException, SQLException {\n+        ResourceDAO resourceDAO = null;\n+        switch (FHIRResourceDAOType.of(con)) {\n+            case DB2:\n+                resourceDAO = new ResourceDAOImpl(trxSynchRegistry);\n+                break;\n+            case DERBY:\n+                resourceDAO = new DerbyResourceDAO(trxSynchRegistry);\n+                break;\n+            case POSTGRESQL:\n+                resourceDAO = new PostgreSqlResourceDAO(trxSynchRegistry);\n+                break;\n+        }\n+        return resourceDAO;\n+    }\n+\n+    public static ResourceDAO getResourceDAO (Connection con) throws IllegalArgumentException, SQLException {\n+        ResourceDAO resourceDAO = null;\n+        switch (FHIRResourceDAOType.of(con)) {\n+            case DB2:\n+                resourceDAO = new ResourceDAOImpl(con);\n+                break;\n+            case DERBY:\n+                resourceDAO = new DerbyResourceDAO(con);\n+                break;\n+            case POSTGRESQL:\n+                resourceDAO = new PostgreSqlResourceDAO(con);\n+                break;\n+        }\n+        return resourceDAO;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91735b41e84b1932c6512ca41ddbfbd33c4ce73a"}, "originalPosition": 83}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTI4NDA1", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396528405", "createdAt": "2020-04-20T14:50:57Z", "commit": {"oid": "861db13b68349b21a0bfcaff0945ee48d74fde2c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo1MDo1OFrOGIYa7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo1MDo1OFrOGIYa7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ0MTkwMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        }\n          \n          \n            \n                        else {\n          \n          \n            \n                        } else {", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411441900", "createdAt": "2020-04-20T14:50:58Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/FhirSequenceDAOImpl.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirSequenceDAO;\n+\n+/**\n+ * DAO to obtain the next value from FHIR_SEQUENCE\n+ */\n+public class FhirSequenceDAOImpl implements FhirSequenceDAO {\n+    private final Connection conn;\n+\n+    /**\n+     * Public constructor\n+     */\n+    public FhirSequenceDAOImpl(Connection c) {\n+        this.conn = c;\n+    }\n+\n+    @Override\n+    public long nextValue() throws SQLException {\n+        long result;\n+        final String SEQ = \"select nextval('fhir_sequence')\";\n+\n+        try (PreparedStatement stmt = conn.prepareStatement(SEQ)) {\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                result = rs.getLong(1);\n+            }\n+            else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "861db13b68349b21a0bfcaff0945ee48d74fde2c"}, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTM4NzEx", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396538711", "createdAt": "2020-04-20T15:01:37Z", "commit": {"oid": "861db13b68349b21a0bfcaff0945ee48d74fde2c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNTowMTozN1rOGIY8lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNTowMTozN1rOGIY8lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ1MDUxOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Builds and manages the multi-tenant FHIR R4 RDBMS schema (Db2), includes creates and updates schema for PostgreSql, also includes Derby support for use in tests.\n          \n          \n            \n            Builds and manages the multi-tenant FHIR R4 RDBMS schema for Db2 and PostgreSQL and includes Derby support for testing.", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411450519", "createdAt": "2020-04-20T15:01:37Z", "author": {"login": "prb112"}, "path": "fhir-persistence-schema/README.md", "diffHunk": "@@ -1,13 +1,13 @@\n # IBM FHIR Server - fhir-persistence-schema\n \n-Builds and manages the multi-tenant FHIR R4 RDBMS schema (Db2). Includes Derby support for use in tests.\n+Builds and manages the multi-tenant FHIR R4 RDBMS schema (Db2), includes creates and updates schema for PostgreSql, also includes Derby support for use in tests.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "861db13b68349b21a0bfcaff0945ee48d74fde2c"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTM5NTU4", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396539558", "createdAt": "2020-04-20T15:02:35Z", "commit": {"oid": "861db13b68349b21a0bfcaff0945ee48d74fde2c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNTowMjozNlrOGIY_mQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNTowMjozNlrOGIY_mQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ1MTI4OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n      \n    \n    \n  \n\nunneeded line", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411451289", "createdAt": "2020-04-20T15:02:36Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,524 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "861db13b68349b21a0bfcaff0945ee48d74fde2c"}, "originalPosition": 173}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTQxODEy", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396541812", "createdAt": "2020-04-20T15:05:02Z", "commit": {"oid": "861db13b68349b21a0bfcaff0945ee48d74fde2c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNTowNTowMlrOGIZHkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNTowNTowMlrOGIZHkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ1MzMyOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * Alpha version uses last_updated time from the app-server, so we keep that here\n          \n          \n            \n                     * uses last_updated time from the app-server, so we have consistency between the various DAOs", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411453328", "createdAt": "2020-04-20T15:05:02Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,524 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+\n+    }\n+\n+    /**\n+     * Store the resource in the database, creating a new logical_resource entry if this is\n+     * the first version of this resource, or creating a new resource entry if this a new\n+     * version of an existing logical resource. The logic tracks closely the DB2 stored\n+     * procedure implementation, including locking of the logical_resource and handling\n+     * concurrency issues using the standard insert-or-update pattern:\n+     * <pre>\n+     *   SELECT FOR UPDATE                 -- try and get a write lock\n+     *   IF NOT FOUND THEN                 -- doesn't exist, so we don't have a lock\n+     *     INSERT new logical resource     -- create the record - if OK, we own the lock\n+     *     IF DUPLICATE THEN               -- someone else beat us to the create\n+     *       SELECT FOR UPDATE             -- so we need to try again for a write lock\n+     *     ...\n+     *   ...\n+     * </pre>\n+     *\n+     * This works because we never delete a logical_resource record, and so don't have to deal\n+     * with concurrency issues caused when deletes are mingled with inserts/updates\n+     *\n+     * Note the execution flow aligns very closely with the DB2 stored procedure\n+     * implementation (fhir-persistence-schema/src/main/resources/add_any_resource.sql)\n+     *\n+     * @param tablePrefix\n+     * @param parameters\n+     * @param p_logical_id\n+     * @param p_payload\n+     * @param p_last_updated\n+     * @param p_is_deleted\n+     * @param p_source_key\n+     * @param p_version\n+     *\n+     * @return the resource_id for the entry we created\n+     * @throws Exception\n+     */\n+    public long storeResource(String tablePrefix, List<ExtractedParameterValue> parameters, String p_logical_id, byte[] p_payload, Timestamp p_last_updated, boolean p_is_deleted,\n+        String p_source_key, Integer p_version, Connection conn) throws Exception {\n+\n+        final String METHODNAME = \"storeResource() for \" + tablePrefix + \" resource\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Long v_logical_resource_id = null;\n+        Long v_current_resource_id = null;\n+        Long v_resource_id = null;\n+        Integer v_resource_type_id = null;\n+        boolean v_new_resource = false;\n+        boolean v_not_found = false;\n+        boolean v_duplicate = false;\n+        int v_version = 0;\n+        int v_insert_version = 0;\n+\n+        String v_resource_type = tablePrefix;\n+\n+        // Map the resource type name to the normalized id value in the database\n+        v_resource_type_id = getResourceTypeId(v_resource_type, conn);\n+        if (v_resource_type_id == null) {\n+            // programming error, as this should've been created earlier\n+            throw new IllegalStateException(\"resource type not found: \" + v_resource_type);\n+        }\n+\n+        // Get a lock at the system-wide logical resource level. Note the Derby-specific syntax\n+        final String SELECT_FOR_UPDATE = \"SELECT logical_resource_id FROM logical_resources WHERE resource_type_id = ? AND logical_id = ? FOR UPDATE\";\n+        try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+            stmt.setInt(1, v_resource_type_id);\n+            stmt.setString(2, p_logical_id);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                v_logical_resource_id = rs.getLong(1);\n+            } else {\n+                v_not_found = true;\n+                v_logical_resource_id = -1L; // just to be careful\n+            }\n+        }\n+\n+        // Create the logical resource if we don't have it already\n+        if (v_not_found) {\n+            // grab the id we want to use for the new logical resource instance\n+            final String sql2 = \"SELECT nextval('fhir_sequence')\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_logical_resource_id = res.getLong(1);\n+                } else {\n+                    // not going to happen, unless someone butchers the statement being executed\n+                    throw new IllegalStateException(\"VALUES failed to return a row: \" + sql2);\n+                }\n+            }\n+\n+            try {\n+                // insert the system-wide logical resource record.\n+                final String sql3 = \"INSERT INTO logical_resources (logical_resource_id, resource_type_id, logical_id) VALUES (?, ?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setInt(2, v_resource_type_id);\n+                    stmt.setString(3, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (translator.isDuplicate(e)) {\n+                    v_duplicate = true;\n+                }  else {\n+                    throw e;\n+                }\n+            }\n+\n+            /**\n+             * remember that we have a concurrent system...so there is a possibility\n+             * that another thread snuck in before us and created the logical resource. This\n+             * is easy to handle, just turn around and read it\n+             */\n+            if (v_duplicate) {\n+                try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+                    // bind parameters\n+                    stmt.setInt(1, v_resource_type_id);\n+                    stmt.setString(2, p_logical_id);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        v_logical_resource_id = res.getLong(1);\n+                    } else {\n+                        // Extremely unlikely as we should never delete logical resource records\n+                        throw new IllegalStateException(\"Logical resource was deleted: \" + tablePrefix + \"/\" + p_logical_id);\n+                    }\n+                }\n+            } else {\n+                v_new_resource = true;\n+\n+                // Insert the resource-specific logical resource record. Remember that logical_id is denormalized\n+                // so it gets stored again here for convenience\n+                final String sql3 = \"INSERT INTO \" + tablePrefix + \"_logical_resources (logical_resource_id, logical_id) VALUES (?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setString(2, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            }\n+        }\n+\n+        if (!v_new_resource) {\n+            // existing resource.  We need to know the current version from the\n+            // resource-specific logical resources table.\n+            final String sql3 = \"SELECT current_resource_id FROM \" + tablePrefix + \"_logical_resources WHERE logical_resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                stmt.setLong(1, v_logical_resource_id);\n+                ResultSet rs = stmt.executeQuery();\n+                if (rs.next()) {\n+                    v_current_resource_id = rs.getLong(1);\n+                }\n+                else {\n+                    // This database is broken, because we shouldn't have logical_resource records without\n+                    // corresponding resource-specific logical_resource records.\n+                    throw new SQLException(\"Logical_id record '\" + p_logical_id + \"' missing for resource \" + tablePrefix);\n+                }\n+            }\n+\n+            // so if we are storing a specific version, do a quick check to make\n+            // sure that this version doesn't currently exist. This is only done when processing\n+            // replication messages which might be duplicated. We want the operation to be idempotent,\n+            // so if the resource already exists, we don't need to do anything else.\n+\n+            if (p_version != null) {\n+                final String sqlStmt = \"SELECT resource_id FROM \" + tablePrefix + \"_resources dr WHERE dr.logical_resource_id = ? AND dr.version_id = ?\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sqlStmt)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setLong(2, p_version);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        // this version of this resource already exists, so we bail out right away\n+                        v_resource_id = res.getLong(1);\n+                        return v_resource_id;\n+                    }\n+                }\n+            }\n+\n+            // Grab the version value for the current version (identified by v_current_resource_id)\n+            final String sql4 = \"SELECT version_id FROM \" + tablePrefix + \"_resources WHERE resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql4)) {\n+                stmt.setLong(1, v_current_resource_id);\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_version = res.getInt(1);\n+                } else {\n+                    throw new IllegalStateException(\"current resource not found: \"\n+                            + tablePrefix + \"_resources.resource_id=\" + v_current_resource_id);\n+                }\n+            }\n+\n+            //If we have been passed a version number, this means that this is a replicated\n+            //resource, and so we only need to delete parameters if the given version is\n+            // later than the current version\n+            if (p_version == null || p_version > v_version) {\n+                // existing resource, so need to delete all its parameters\n+                // delete composites first, or else the foreign keys there restrict deletes on referenced tables\n+                deleteFromParameterTable(conn, tablePrefix + \"_composites\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_str_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_number_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_date_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_latlng_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_token_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_quantity_values\", v_logical_resource_id);\n+            }\n+        }\n+\n+        // Persist the data using the given version number if required\n+        if (p_version != null) {\n+            v_insert_version = p_version;\n+        } else {\n+            // remember we have a write (update) lock on the logical version, so we can safely calculate\n+            // the next version value here\n+            v_insert_version = v_version + 1;\n+\n+        }\n+\n+        /**\n+         * Create the new resource version.\n+         * Alpha version uses last_updated time from the app-server, so we keep that here", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "861db13b68349b21a0bfcaff0945ee48d74fde2c"}, "originalPosition": 392}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTQyMzEw", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396542310", "createdAt": "2020-04-20T15:05:33Z", "commit": {"oid": "861db13b68349b21a0bfcaff0945ee48d74fde2c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNTowNTozM1rOGIZJRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNTowNTozM1rOGIZJRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ1Mzc2Nw==", "bodyText": "Suggested change", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411453767", "createdAt": "2020-04-20T15:05:33Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,524 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+\n+    }\n+\n+    /**\n+     * Store the resource in the database, creating a new logical_resource entry if this is\n+     * the first version of this resource, or creating a new resource entry if this a new\n+     * version of an existing logical resource. The logic tracks closely the DB2 stored\n+     * procedure implementation, including locking of the logical_resource and handling\n+     * concurrency issues using the standard insert-or-update pattern:\n+     * <pre>\n+     *   SELECT FOR UPDATE                 -- try and get a write lock\n+     *   IF NOT FOUND THEN                 -- doesn't exist, so we don't have a lock\n+     *     INSERT new logical resource     -- create the record - if OK, we own the lock\n+     *     IF DUPLICATE THEN               -- someone else beat us to the create\n+     *       SELECT FOR UPDATE             -- so we need to try again for a write lock\n+     *     ...\n+     *   ...\n+     * </pre>\n+     *\n+     * This works because we never delete a logical_resource record, and so don't have to deal\n+     * with concurrency issues caused when deletes are mingled with inserts/updates\n+     *\n+     * Note the execution flow aligns very closely with the DB2 stored procedure\n+     * implementation (fhir-persistence-schema/src/main/resources/add_any_resource.sql)\n+     *\n+     * @param tablePrefix\n+     * @param parameters\n+     * @param p_logical_id\n+     * @param p_payload\n+     * @param p_last_updated\n+     * @param p_is_deleted\n+     * @param p_source_key\n+     * @param p_version\n+     *\n+     * @return the resource_id for the entry we created\n+     * @throws Exception\n+     */\n+    public long storeResource(String tablePrefix, List<ExtractedParameterValue> parameters, String p_logical_id, byte[] p_payload, Timestamp p_last_updated, boolean p_is_deleted,\n+        String p_source_key, Integer p_version, Connection conn) throws Exception {\n+\n+        final String METHODNAME = \"storeResource() for \" + tablePrefix + \" resource\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Long v_logical_resource_id = null;\n+        Long v_current_resource_id = null;\n+        Long v_resource_id = null;\n+        Integer v_resource_type_id = null;\n+        boolean v_new_resource = false;\n+        boolean v_not_found = false;\n+        boolean v_duplicate = false;\n+        int v_version = 0;\n+        int v_insert_version = 0;\n+\n+        String v_resource_type = tablePrefix;\n+\n+        // Map the resource type name to the normalized id value in the database\n+        v_resource_type_id = getResourceTypeId(v_resource_type, conn);\n+        if (v_resource_type_id == null) {\n+            // programming error, as this should've been created earlier\n+            throw new IllegalStateException(\"resource type not found: \" + v_resource_type);\n+        }\n+\n+        // Get a lock at the system-wide logical resource level. Note the Derby-specific syntax\n+        final String SELECT_FOR_UPDATE = \"SELECT logical_resource_id FROM logical_resources WHERE resource_type_id = ? AND logical_id = ? FOR UPDATE\";\n+        try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+            stmt.setInt(1, v_resource_type_id);\n+            stmt.setString(2, p_logical_id);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                v_logical_resource_id = rs.getLong(1);\n+            } else {\n+                v_not_found = true;\n+                v_logical_resource_id = -1L; // just to be careful\n+            }\n+        }\n+\n+        // Create the logical resource if we don't have it already\n+        if (v_not_found) {\n+            // grab the id we want to use for the new logical resource instance\n+            final String sql2 = \"SELECT nextval('fhir_sequence')\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_logical_resource_id = res.getLong(1);\n+                } else {\n+                    // not going to happen, unless someone butchers the statement being executed\n+                    throw new IllegalStateException(\"VALUES failed to return a row: \" + sql2);\n+                }\n+            }\n+\n+            try {\n+                // insert the system-wide logical resource record.\n+                final String sql3 = \"INSERT INTO logical_resources (logical_resource_id, resource_type_id, logical_id) VALUES (?, ?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setInt(2, v_resource_type_id);\n+                    stmt.setString(3, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (translator.isDuplicate(e)) {\n+                    v_duplicate = true;\n+                }  else {\n+                    throw e;\n+                }\n+            }\n+\n+            /**\n+             * remember that we have a concurrent system...so there is a possibility\n+             * that another thread snuck in before us and created the logical resource. This\n+             * is easy to handle, just turn around and read it\n+             */\n+            if (v_duplicate) {\n+                try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+                    // bind parameters\n+                    stmt.setInt(1, v_resource_type_id);\n+                    stmt.setString(2, p_logical_id);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        v_logical_resource_id = res.getLong(1);\n+                    } else {\n+                        // Extremely unlikely as we should never delete logical resource records\n+                        throw new IllegalStateException(\"Logical resource was deleted: \" + tablePrefix + \"/\" + p_logical_id);\n+                    }\n+                }\n+            } else {\n+                v_new_resource = true;\n+\n+                // Insert the resource-specific logical resource record. Remember that logical_id is denormalized\n+                // so it gets stored again here for convenience\n+                final String sql3 = \"INSERT INTO \" + tablePrefix + \"_logical_resources (logical_resource_id, logical_id) VALUES (?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setString(2, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            }\n+        }\n+\n+        if (!v_new_resource) {\n+            // existing resource.  We need to know the current version from the\n+            // resource-specific logical resources table.\n+            final String sql3 = \"SELECT current_resource_id FROM \" + tablePrefix + \"_logical_resources WHERE logical_resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                stmt.setLong(1, v_logical_resource_id);\n+                ResultSet rs = stmt.executeQuery();\n+                if (rs.next()) {\n+                    v_current_resource_id = rs.getLong(1);\n+                }\n+                else {\n+                    // This database is broken, because we shouldn't have logical_resource records without\n+                    // corresponding resource-specific logical_resource records.\n+                    throw new SQLException(\"Logical_id record '\" + p_logical_id + \"' missing for resource \" + tablePrefix);\n+                }\n+            }\n+\n+            // so if we are storing a specific version, do a quick check to make\n+            // sure that this version doesn't currently exist. This is only done when processing\n+            // replication messages which might be duplicated. We want the operation to be idempotent,\n+            // so if the resource already exists, we don't need to do anything else.\n+\n+            if (p_version != null) {\n+                final String sqlStmt = \"SELECT resource_id FROM \" + tablePrefix + \"_resources dr WHERE dr.logical_resource_id = ? AND dr.version_id = ?\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sqlStmt)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setLong(2, p_version);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        // this version of this resource already exists, so we bail out right away\n+                        v_resource_id = res.getLong(1);\n+                        return v_resource_id;\n+                    }\n+                }\n+            }\n+\n+            // Grab the version value for the current version (identified by v_current_resource_id)\n+            final String sql4 = \"SELECT version_id FROM \" + tablePrefix + \"_resources WHERE resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql4)) {\n+                stmt.setLong(1, v_current_resource_id);\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_version = res.getInt(1);\n+                } else {\n+                    throw new IllegalStateException(\"current resource not found: \"\n+                            + tablePrefix + \"_resources.resource_id=\" + v_current_resource_id);\n+                }\n+            }\n+\n+            //If we have been passed a version number, this means that this is a replicated\n+            //resource, and so we only need to delete parameters if the given version is\n+            // later than the current version\n+            if (p_version == null || p_version > v_version) {\n+                // existing resource, so need to delete all its parameters\n+                // delete composites first, or else the foreign keys there restrict deletes on referenced tables\n+                deleteFromParameterTable(conn, tablePrefix + \"_composites\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_str_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_number_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_date_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_latlng_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_token_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_quantity_values\", v_logical_resource_id);\n+            }\n+        }\n+\n+        // Persist the data using the given version number if required\n+        if (p_version != null) {\n+            v_insert_version = p_version;\n+        } else {\n+            // remember we have a write (update) lock on the logical version, so we can safely calculate\n+            // the next version value here\n+            v_insert_version = v_version + 1;\n+\n+        }\n+\n+        /**\n+         * Create the new resource version.\n+         * Alpha version uses last_updated time from the app-server, so we keep that here\n+         */\n+        String sql2 = \"SELECT nextval('fhir_sequence')\";\n+        try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+            ResultSet res = stmt.executeQuery();\n+            if (res.next()) {\n+                v_resource_id = res.getLong(1); //Assign result of the above query\n+            } else {\n+                // unlikely\n+                throw new IllegalStateException(\"no row returned: \" + sql2);\n+            }\n+        }\n+\n+        // Finally we get to the big resource data insert\n+        String sql3 = \"INSERT INTO \" + tablePrefix + \"_resources (resource_id, logical_resource_id, version_id, data, last_updated, is_deleted) \"\n+                + \"VALUES (?,?,?,?,?,?)\";\n+        try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+            // bind parameters\n+            stmt.setLong(1, v_resource_id);\n+            stmt.setLong(2, v_logical_resource_id);\n+            stmt.setInt(3, v_insert_version);\n+            stmt.setBytes(4, p_payload);\n+            stmt.setTimestamp(5, p_last_updated, UTC);\n+            stmt.setString(6, p_is_deleted ? \"Y\" : \"N\");\n+            stmt.executeUpdate();\n+        }\n+\n+        if (p_version == null || p_version > v_version) {\n+            //only update the logical resource if the resource we are adding supercedes the\n+            //current resource\n+            String sql4 = \"UPDATE \" + tablePrefix + \"_logical_resources SET current_resource_id = ? WHERE logical_resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql4)) {\n+                // bind parameters\n+                stmt.setLong(1, v_resource_id);\n+                stmt.setLong(2, v_logical_resource_id);\n+                stmt.executeUpdate();\n+            }\n+\n+            // To keep things simple for the Derby use-case, we just use a visitor to\n+            // handle inserts of parameters directly in the resource parameter tables.\n+            // Note we don't get any parameters for the resource soft-delete operation\n+            if (parameters != null) {\n+                // Derby doesn't support partitioned multi-tenancy, so we disable it on the DAO:\n+                try (ParameterVisitorBatchDAO pvd = new ParameterVisitorBatchDAO(conn, null, tablePrefix, false, v_logical_resource_id, 100,\n+                    new ParameterNameCacheAdapter(parameterNameDAO), new CodeSystemCacheAdapter(codeSystemDAO))) {\n+                    for (ExtractedParameterValue p: parameters) {\n+                        p.accept(pvd);\n+                    }\n+                }\n+            }\n+        }\n+        logger.exiting(CLASSNAME, METHODNAME);\n+        return v_resource_id;\n+    }\n+\n+\n+    /**\n+     * Delete all parameters for the given resourceId from the parameters table\n+     *\n+     * @param conn\n+     * @param tableName\n+     * @param logicalResourceId\n+     * @throws SQLException\n+     */\n+    protected void deleteFromParameterTable(Connection conn, String tableName, long logicalResourceId) throws SQLException {\n+        final String delStrValues = \"DELETE FROM \" + tableName + \" WHERE logical_resource_id = ?\";\n+        try (PreparedStatement stmt = conn.prepareStatement(delStrValues)) {\n+            // bind parameters\n+            stmt.setLong(1, logicalResourceId);\n+            stmt.executeUpdate();\n+        }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "861db13b68349b21a0bfcaff0945ee48d74fde2c"}, "originalPosition": 463}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTQyNTU5", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396542559", "createdAt": "2020-04-20T15:05:49Z", "commit": {"oid": "861db13b68349b21a0bfcaff0945ee48d74fde2c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNTowNTo0OVrOGIZKEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNTowNTo0OVrOGIZKEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ1Mzk3MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Integer result;\n          \n          \n            \n                    Integer result = null;", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411453971", "createdAt": "2020-04-20T15:05:49Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,524 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+\n+    }\n+\n+    /**\n+     * Store the resource in the database, creating a new logical_resource entry if this is\n+     * the first version of this resource, or creating a new resource entry if this a new\n+     * version of an existing logical resource. The logic tracks closely the DB2 stored\n+     * procedure implementation, including locking of the logical_resource and handling\n+     * concurrency issues using the standard insert-or-update pattern:\n+     * <pre>\n+     *   SELECT FOR UPDATE                 -- try and get a write lock\n+     *   IF NOT FOUND THEN                 -- doesn't exist, so we don't have a lock\n+     *     INSERT new logical resource     -- create the record - if OK, we own the lock\n+     *     IF DUPLICATE THEN               -- someone else beat us to the create\n+     *       SELECT FOR UPDATE             -- so we need to try again for a write lock\n+     *     ...\n+     *   ...\n+     * </pre>\n+     *\n+     * This works because we never delete a logical_resource record, and so don't have to deal\n+     * with concurrency issues caused when deletes are mingled with inserts/updates\n+     *\n+     * Note the execution flow aligns very closely with the DB2 stored procedure\n+     * implementation (fhir-persistence-schema/src/main/resources/add_any_resource.sql)\n+     *\n+     * @param tablePrefix\n+     * @param parameters\n+     * @param p_logical_id\n+     * @param p_payload\n+     * @param p_last_updated\n+     * @param p_is_deleted\n+     * @param p_source_key\n+     * @param p_version\n+     *\n+     * @return the resource_id for the entry we created\n+     * @throws Exception\n+     */\n+    public long storeResource(String tablePrefix, List<ExtractedParameterValue> parameters, String p_logical_id, byte[] p_payload, Timestamp p_last_updated, boolean p_is_deleted,\n+        String p_source_key, Integer p_version, Connection conn) throws Exception {\n+\n+        final String METHODNAME = \"storeResource() for \" + tablePrefix + \" resource\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Long v_logical_resource_id = null;\n+        Long v_current_resource_id = null;\n+        Long v_resource_id = null;\n+        Integer v_resource_type_id = null;\n+        boolean v_new_resource = false;\n+        boolean v_not_found = false;\n+        boolean v_duplicate = false;\n+        int v_version = 0;\n+        int v_insert_version = 0;\n+\n+        String v_resource_type = tablePrefix;\n+\n+        // Map the resource type name to the normalized id value in the database\n+        v_resource_type_id = getResourceTypeId(v_resource_type, conn);\n+        if (v_resource_type_id == null) {\n+            // programming error, as this should've been created earlier\n+            throw new IllegalStateException(\"resource type not found: \" + v_resource_type);\n+        }\n+\n+        // Get a lock at the system-wide logical resource level. Note the Derby-specific syntax\n+        final String SELECT_FOR_UPDATE = \"SELECT logical_resource_id FROM logical_resources WHERE resource_type_id = ? AND logical_id = ? FOR UPDATE\";\n+        try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+            stmt.setInt(1, v_resource_type_id);\n+            stmt.setString(2, p_logical_id);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                v_logical_resource_id = rs.getLong(1);\n+            } else {\n+                v_not_found = true;\n+                v_logical_resource_id = -1L; // just to be careful\n+            }\n+        }\n+\n+        // Create the logical resource if we don't have it already\n+        if (v_not_found) {\n+            // grab the id we want to use for the new logical resource instance\n+            final String sql2 = \"SELECT nextval('fhir_sequence')\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_logical_resource_id = res.getLong(1);\n+                } else {\n+                    // not going to happen, unless someone butchers the statement being executed\n+                    throw new IllegalStateException(\"VALUES failed to return a row: \" + sql2);\n+                }\n+            }\n+\n+            try {\n+                // insert the system-wide logical resource record.\n+                final String sql3 = \"INSERT INTO logical_resources (logical_resource_id, resource_type_id, logical_id) VALUES (?, ?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setInt(2, v_resource_type_id);\n+                    stmt.setString(3, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (translator.isDuplicate(e)) {\n+                    v_duplicate = true;\n+                }  else {\n+                    throw e;\n+                }\n+            }\n+\n+            /**\n+             * remember that we have a concurrent system...so there is a possibility\n+             * that another thread snuck in before us and created the logical resource. This\n+             * is easy to handle, just turn around and read it\n+             */\n+            if (v_duplicate) {\n+                try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+                    // bind parameters\n+                    stmt.setInt(1, v_resource_type_id);\n+                    stmt.setString(2, p_logical_id);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        v_logical_resource_id = res.getLong(1);\n+                    } else {\n+                        // Extremely unlikely as we should never delete logical resource records\n+                        throw new IllegalStateException(\"Logical resource was deleted: \" + tablePrefix + \"/\" + p_logical_id);\n+                    }\n+                }\n+            } else {\n+                v_new_resource = true;\n+\n+                // Insert the resource-specific logical resource record. Remember that logical_id is denormalized\n+                // so it gets stored again here for convenience\n+                final String sql3 = \"INSERT INTO \" + tablePrefix + \"_logical_resources (logical_resource_id, logical_id) VALUES (?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setString(2, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            }\n+        }\n+\n+        if (!v_new_resource) {\n+            // existing resource.  We need to know the current version from the\n+            // resource-specific logical resources table.\n+            final String sql3 = \"SELECT current_resource_id FROM \" + tablePrefix + \"_logical_resources WHERE logical_resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                stmt.setLong(1, v_logical_resource_id);\n+                ResultSet rs = stmt.executeQuery();\n+                if (rs.next()) {\n+                    v_current_resource_id = rs.getLong(1);\n+                }\n+                else {\n+                    // This database is broken, because we shouldn't have logical_resource records without\n+                    // corresponding resource-specific logical_resource records.\n+                    throw new SQLException(\"Logical_id record '\" + p_logical_id + \"' missing for resource \" + tablePrefix);\n+                }\n+            }\n+\n+            // so if we are storing a specific version, do a quick check to make\n+            // sure that this version doesn't currently exist. This is only done when processing\n+            // replication messages which might be duplicated. We want the operation to be idempotent,\n+            // so if the resource already exists, we don't need to do anything else.\n+\n+            if (p_version != null) {\n+                final String sqlStmt = \"SELECT resource_id FROM \" + tablePrefix + \"_resources dr WHERE dr.logical_resource_id = ? AND dr.version_id = ?\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sqlStmt)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setLong(2, p_version);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        // this version of this resource already exists, so we bail out right away\n+                        v_resource_id = res.getLong(1);\n+                        return v_resource_id;\n+                    }\n+                }\n+            }\n+\n+            // Grab the version value for the current version (identified by v_current_resource_id)\n+            final String sql4 = \"SELECT version_id FROM \" + tablePrefix + \"_resources WHERE resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql4)) {\n+                stmt.setLong(1, v_current_resource_id);\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_version = res.getInt(1);\n+                } else {\n+                    throw new IllegalStateException(\"current resource not found: \"\n+                            + tablePrefix + \"_resources.resource_id=\" + v_current_resource_id);\n+                }\n+            }\n+\n+            //If we have been passed a version number, this means that this is a replicated\n+            //resource, and so we only need to delete parameters if the given version is\n+            // later than the current version\n+            if (p_version == null || p_version > v_version) {\n+                // existing resource, so need to delete all its parameters\n+                // delete composites first, or else the foreign keys there restrict deletes on referenced tables\n+                deleteFromParameterTable(conn, tablePrefix + \"_composites\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_str_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_number_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_date_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_latlng_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_token_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_quantity_values\", v_logical_resource_id);\n+            }\n+        }\n+\n+        // Persist the data using the given version number if required\n+        if (p_version != null) {\n+            v_insert_version = p_version;\n+        } else {\n+            // remember we have a write (update) lock on the logical version, so we can safely calculate\n+            // the next version value here\n+            v_insert_version = v_version + 1;\n+\n+        }\n+\n+        /**\n+         * Create the new resource version.\n+         * Alpha version uses last_updated time from the app-server, so we keep that here\n+         */\n+        String sql2 = \"SELECT nextval('fhir_sequence')\";\n+        try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+            ResultSet res = stmt.executeQuery();\n+            if (res.next()) {\n+                v_resource_id = res.getLong(1); //Assign result of the above query\n+            } else {\n+                // unlikely\n+                throw new IllegalStateException(\"no row returned: \" + sql2);\n+            }\n+        }\n+\n+        // Finally we get to the big resource data insert\n+        String sql3 = \"INSERT INTO \" + tablePrefix + \"_resources (resource_id, logical_resource_id, version_id, data, last_updated, is_deleted) \"\n+                + \"VALUES (?,?,?,?,?,?)\";\n+        try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+            // bind parameters\n+            stmt.setLong(1, v_resource_id);\n+            stmt.setLong(2, v_logical_resource_id);\n+            stmt.setInt(3, v_insert_version);\n+            stmt.setBytes(4, p_payload);\n+            stmt.setTimestamp(5, p_last_updated, UTC);\n+            stmt.setString(6, p_is_deleted ? \"Y\" : \"N\");\n+            stmt.executeUpdate();\n+        }\n+\n+        if (p_version == null || p_version > v_version) {\n+            //only update the logical resource if the resource we are adding supercedes the\n+            //current resource\n+            String sql4 = \"UPDATE \" + tablePrefix + \"_logical_resources SET current_resource_id = ? WHERE logical_resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql4)) {\n+                // bind parameters\n+                stmt.setLong(1, v_resource_id);\n+                stmt.setLong(2, v_logical_resource_id);\n+                stmt.executeUpdate();\n+            }\n+\n+            // To keep things simple for the Derby use-case, we just use a visitor to\n+            // handle inserts of parameters directly in the resource parameter tables.\n+            // Note we don't get any parameters for the resource soft-delete operation\n+            if (parameters != null) {\n+                // Derby doesn't support partitioned multi-tenancy, so we disable it on the DAO:\n+                try (ParameterVisitorBatchDAO pvd = new ParameterVisitorBatchDAO(conn, null, tablePrefix, false, v_logical_resource_id, 100,\n+                    new ParameterNameCacheAdapter(parameterNameDAO), new CodeSystemCacheAdapter(codeSystemDAO))) {\n+                    for (ExtractedParameterValue p: parameters) {\n+                        p.accept(pvd);\n+                    }\n+                }\n+            }\n+        }\n+        logger.exiting(CLASSNAME, METHODNAME);\n+        return v_resource_id;\n+    }\n+\n+\n+    /**\n+     * Delete all parameters for the given resourceId from the parameters table\n+     *\n+     * @param conn\n+     * @param tableName\n+     * @param logicalResourceId\n+     * @throws SQLException\n+     */\n+    protected void deleteFromParameterTable(Connection conn, String tableName, long logicalResourceId) throws SQLException {\n+        final String delStrValues = \"DELETE FROM \" + tableName + \" WHERE logical_resource_id = ?\";\n+        try (PreparedStatement stmt = conn.prepareStatement(delStrValues)) {\n+            // bind parameters\n+            stmt.setLong(1, logicalResourceId);\n+            stmt.executeUpdate();\n+        }\n+\n+    }\n+\n+    /**\n+     * Read the id for the named type\n+     * @param resourceTypeName\n+     * @return the database id, or null if the named record is not found\n+     * @throws SQLException\n+     */\n+    protected Integer getResourceTypeId(String resourceTypeName, Connection conn) throws SQLException {\n+        Integer result;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "861db13b68349b21a0bfcaff0945ee48d74fde2c"}, "originalPosition": 473}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTQyNzk2", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396542796", "createdAt": "2020-04-20T15:06:04Z", "commit": {"oid": "861db13b68349b21a0bfcaff0945ee48d74fde2c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNTowNjowNVrOGIZK7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNTowNjowNVrOGIZK7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ1NDE5MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            result = rs.getInt(1);\n          \n          \n            \n                        } else {\n          \n          \n            \n                            result = null;\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                            result = rs.getInt(1);\n          \n          \n            \n                        }\n          \n          \n            \n                    }", "url": "https://github.com/IBM/FHIR/pull/914#discussion_r411454191", "createdAt": "2020-04-20T15:06:05Z", "author": {"login": "prb112"}, "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -0,0 +1,524 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.jdbc.postgresql;\n+\n+import static com.ibm.fhir.persistence.jdbc.JDBCConstants.UTC;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Timestamp;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.ibm.fhir.database.utils.postgresql.PostgreSqlTranslator;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceVersionIdMismatchException;\n+import com.ibm.fhir.persistence.jdbc.dao.api.CodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.api.ParameterNameDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterVisitorBatchDAO;\n+import com.ibm.fhir.persistence.jdbc.dao.impl.ResourceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.CodeSystemCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyCodeSystemDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.DerbyParameterNamesDAO;\n+import com.ibm.fhir.persistence.jdbc.derby.FhirRefSequenceDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.derby.ParameterNameCacheAdapter;\n+import com.ibm.fhir.persistence.jdbc.dto.ExtractedParameterValue;\n+import com.ibm.fhir.persistence.jdbc.dto.Resource;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBConnectException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceFKVException;\n+import com.ibm.fhir.persistence.jdbc.util.ResourceTypesCache;\n+\n+/**\n+ * Data access object for writing FHIR resources to an PostgreSql database.\n+ *\n+ * @implNote The original implementation (for DSTU2) used a global temporary table\n+ * to pass the parameter list into the stored procedure, but this approach\n+ * exposed some query optimizer issues in DB2 resulting in significant\n+ * concurrency problems (related to dynamic statistics collection and\n+ * query compilation). The solution used row type arrays instead, but these\n+ * aren't supported in PostgreSql, and have since been replaced by a DAO-based\n+ * batch statements due to issues with dynamic SQL and array types in DB2.\n+ * <br>\n+ * So this class follows the logic of the stored procedure, but does so\n+ * using a series of individual JDBC statements.\n+ */\n+public class PostgreSqlResourceDAO extends ResourceDAOImpl {\n+    private static final Logger logger = Logger.getLogger(PostgreSqlResourceDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlResourceDAO.class.getSimpleName();\n+\n+    private static final PostgreSqlTranslator translator = new PostgreSqlTranslator();\n+\n+    // DAO used to obtain sequence values from FHIR_REF_SEQUENCE\n+    private FhirRefSequenceDAO fhirRefSequenceDAO;\n+\n+    // DAO used to manage parameter_names\n+    private ParameterNameDAO parameterNameDAO;\n+\n+    // DAO used to manage code_systems\n+    private CodeSystemDAO codeSystemDAO;\n+\n+    public PostgreSqlResourceDAO(Connection managedConnection) {\n+        super(managedConnection);\n+    }\n+\n+    public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry) {\n+        super(trxSynchRegistry);\n+    }\n+\n+    /**\n+     * Inserts the passed FHIR Resource and associated search parameters to a Derby or PostgreSql FHIR database.\n+     * The search parameters are stored first by calling the passed parameterDao. Then the Resource is stored\n+     * by sql.\n+     * @param resource The FHIR Resource to be inserted.\n+     * @param parameters The Resource's search parameters to be inserted.\n+     * @param parameterDao\n+     * @return The Resource DTO\n+     * @throws FHIRPersistenceDataAccessException\n+     * @throws FHIRPersistenceDBConnectException\n+     * @throws FHIRPersistenceVersionIdMismatchException\n+     */\n+    @Override\n+    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+            throws FHIRPersistenceException {\n+        final String METHODNAME = \"insert\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        Integer resourceTypeId;\n+        Timestamp lastUpdated;\n+        boolean acquiredFromCache;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+\n+            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+            this.parameterNameDAO = new DerbyParameterNamesDAO(connection, fhirRefSequenceDAO);\n+            this.codeSystemDAO = new DerbyCodeSystemDAO(connection, fhirRefSequenceDAO);\n+\n+            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+            if (resourceTypeId == null) {\n+                acquiredFromCache = false;\n+                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+            } else {\n+                acquiredFromCache = true;\n+            }\n+\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+            }\n+\n+            lastUpdated = resource.getLastUpdated();\n+            dbCallStartTime = System.nanoTime();\n+\n+            final String sourceKey = UUID.randomUUID().toString();\n+\n+            long resourceId = this.storeResource(resource.getResourceType(),\n+                parameters,\n+                resource.getLogicalId(),\n+                resource.getData(),\n+                lastUpdated,\n+                resource.isDeleted(),\n+                sourceKey,\n+                resource.getVersionId(),\n+                connection\n+                );\n+\n+\n+            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+\n+            resource.setId(resourceId);\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+            throw e;\n+        } catch(SQLIntegrityConstraintViolationException e) {\n+            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } catch(SQLException e) {\n+            if (\"99001\".equals(e.getSQLState())) {\n+                // this is just a concurrency update, so there's no need to log the SQLException here\n+                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+            } else {\n+                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                throw severe(logger, fx, e);\n+            }\n+        } catch(Throwable e) {\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(null, connection);\n+            logger.exiting(CLASSNAME, METHODNAME);\n+        }\n+\n+        return resource;\n+\n+    }\n+\n+    /**\n+     * Store the resource in the database, creating a new logical_resource entry if this is\n+     * the first version of this resource, or creating a new resource entry if this a new\n+     * version of an existing logical resource. The logic tracks closely the DB2 stored\n+     * procedure implementation, including locking of the logical_resource and handling\n+     * concurrency issues using the standard insert-or-update pattern:\n+     * <pre>\n+     *   SELECT FOR UPDATE                 -- try and get a write lock\n+     *   IF NOT FOUND THEN                 -- doesn't exist, so we don't have a lock\n+     *     INSERT new logical resource     -- create the record - if OK, we own the lock\n+     *     IF DUPLICATE THEN               -- someone else beat us to the create\n+     *       SELECT FOR UPDATE             -- so we need to try again for a write lock\n+     *     ...\n+     *   ...\n+     * </pre>\n+     *\n+     * This works because we never delete a logical_resource record, and so don't have to deal\n+     * with concurrency issues caused when deletes are mingled with inserts/updates\n+     *\n+     * Note the execution flow aligns very closely with the DB2 stored procedure\n+     * implementation (fhir-persistence-schema/src/main/resources/add_any_resource.sql)\n+     *\n+     * @param tablePrefix\n+     * @param parameters\n+     * @param p_logical_id\n+     * @param p_payload\n+     * @param p_last_updated\n+     * @param p_is_deleted\n+     * @param p_source_key\n+     * @param p_version\n+     *\n+     * @return the resource_id for the entry we created\n+     * @throws Exception\n+     */\n+    public long storeResource(String tablePrefix, List<ExtractedParameterValue> parameters, String p_logical_id, byte[] p_payload, Timestamp p_last_updated, boolean p_is_deleted,\n+        String p_source_key, Integer p_version, Connection conn) throws Exception {\n+\n+        final String METHODNAME = \"storeResource() for \" + tablePrefix + \" resource\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Long v_logical_resource_id = null;\n+        Long v_current_resource_id = null;\n+        Long v_resource_id = null;\n+        Integer v_resource_type_id = null;\n+        boolean v_new_resource = false;\n+        boolean v_not_found = false;\n+        boolean v_duplicate = false;\n+        int v_version = 0;\n+        int v_insert_version = 0;\n+\n+        String v_resource_type = tablePrefix;\n+\n+        // Map the resource type name to the normalized id value in the database\n+        v_resource_type_id = getResourceTypeId(v_resource_type, conn);\n+        if (v_resource_type_id == null) {\n+            // programming error, as this should've been created earlier\n+            throw new IllegalStateException(\"resource type not found: \" + v_resource_type);\n+        }\n+\n+        // Get a lock at the system-wide logical resource level. Note the Derby-specific syntax\n+        final String SELECT_FOR_UPDATE = \"SELECT logical_resource_id FROM logical_resources WHERE resource_type_id = ? AND logical_id = ? FOR UPDATE\";\n+        try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+            stmt.setInt(1, v_resource_type_id);\n+            stmt.setString(2, p_logical_id);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                v_logical_resource_id = rs.getLong(1);\n+            } else {\n+                v_not_found = true;\n+                v_logical_resource_id = -1L; // just to be careful\n+            }\n+        }\n+\n+        // Create the logical resource if we don't have it already\n+        if (v_not_found) {\n+            // grab the id we want to use for the new logical resource instance\n+            final String sql2 = \"SELECT nextval('fhir_sequence')\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_logical_resource_id = res.getLong(1);\n+                } else {\n+                    // not going to happen, unless someone butchers the statement being executed\n+                    throw new IllegalStateException(\"VALUES failed to return a row: \" + sql2);\n+                }\n+            }\n+\n+            try {\n+                // insert the system-wide logical resource record.\n+                final String sql3 = \"INSERT INTO logical_resources (logical_resource_id, resource_type_id, logical_id) VALUES (?, ?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setInt(2, v_resource_type_id);\n+                    stmt.setString(3, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                if (translator.isDuplicate(e)) {\n+                    v_duplicate = true;\n+                }  else {\n+                    throw e;\n+                }\n+            }\n+\n+            /**\n+             * remember that we have a concurrent system...so there is a possibility\n+             * that another thread snuck in before us and created the logical resource. This\n+             * is easy to handle, just turn around and read it\n+             */\n+            if (v_duplicate) {\n+                try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n+                    // bind parameters\n+                    stmt.setInt(1, v_resource_type_id);\n+                    stmt.setString(2, p_logical_id);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        v_logical_resource_id = res.getLong(1);\n+                    } else {\n+                        // Extremely unlikely as we should never delete logical resource records\n+                        throw new IllegalStateException(\"Logical resource was deleted: \" + tablePrefix + \"/\" + p_logical_id);\n+                    }\n+                }\n+            } else {\n+                v_new_resource = true;\n+\n+                // Insert the resource-specific logical resource record. Remember that logical_id is denormalized\n+                // so it gets stored again here for convenience\n+                final String sql3 = \"INSERT INTO \" + tablePrefix + \"_logical_resources (logical_resource_id, logical_id) VALUES (?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setString(2, p_logical_id);\n+                    stmt.executeUpdate();\n+                }\n+            }\n+        }\n+\n+        if (!v_new_resource) {\n+            // existing resource.  We need to know the current version from the\n+            // resource-specific logical resources table.\n+            final String sql3 = \"SELECT current_resource_id FROM \" + tablePrefix + \"_logical_resources WHERE logical_resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+                stmt.setLong(1, v_logical_resource_id);\n+                ResultSet rs = stmt.executeQuery();\n+                if (rs.next()) {\n+                    v_current_resource_id = rs.getLong(1);\n+                }\n+                else {\n+                    // This database is broken, because we shouldn't have logical_resource records without\n+                    // corresponding resource-specific logical_resource records.\n+                    throw new SQLException(\"Logical_id record '\" + p_logical_id + \"' missing for resource \" + tablePrefix);\n+                }\n+            }\n+\n+            // so if we are storing a specific version, do a quick check to make\n+            // sure that this version doesn't currently exist. This is only done when processing\n+            // replication messages which might be duplicated. We want the operation to be idempotent,\n+            // so if the resource already exists, we don't need to do anything else.\n+\n+            if (p_version != null) {\n+                final String sqlStmt = \"SELECT resource_id FROM \" + tablePrefix + \"_resources dr WHERE dr.logical_resource_id = ? AND dr.version_id = ?\";\n+                try (PreparedStatement stmt = conn.prepareStatement(sqlStmt)) {\n+                    // bind parameters\n+                    stmt.setLong(1, v_logical_resource_id);\n+                    stmt.setLong(2, p_version);\n+                    ResultSet res = stmt.executeQuery();\n+                    if (res.next()) {\n+                        // this version of this resource already exists, so we bail out right away\n+                        v_resource_id = res.getLong(1);\n+                        return v_resource_id;\n+                    }\n+                }\n+            }\n+\n+            // Grab the version value for the current version (identified by v_current_resource_id)\n+            final String sql4 = \"SELECT version_id FROM \" + tablePrefix + \"_resources WHERE resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql4)) {\n+                stmt.setLong(1, v_current_resource_id);\n+                ResultSet res = stmt.executeQuery();\n+                if (res.next()) {\n+                    v_version = res.getInt(1);\n+                } else {\n+                    throw new IllegalStateException(\"current resource not found: \"\n+                            + tablePrefix + \"_resources.resource_id=\" + v_current_resource_id);\n+                }\n+            }\n+\n+            //If we have been passed a version number, this means that this is a replicated\n+            //resource, and so we only need to delete parameters if the given version is\n+            // later than the current version\n+            if (p_version == null || p_version > v_version) {\n+                // existing resource, so need to delete all its parameters\n+                // delete composites first, or else the foreign keys there restrict deletes on referenced tables\n+                deleteFromParameterTable(conn, tablePrefix + \"_composites\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_str_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_number_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_date_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_latlng_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_token_values\", v_logical_resource_id);\n+                deleteFromParameterTable(conn, tablePrefix + \"_quantity_values\", v_logical_resource_id);\n+            }\n+        }\n+\n+        // Persist the data using the given version number if required\n+        if (p_version != null) {\n+            v_insert_version = p_version;\n+        } else {\n+            // remember we have a write (update) lock on the logical version, so we can safely calculate\n+            // the next version value here\n+            v_insert_version = v_version + 1;\n+\n+        }\n+\n+        /**\n+         * Create the new resource version.\n+         * Alpha version uses last_updated time from the app-server, so we keep that here\n+         */\n+        String sql2 = \"SELECT nextval('fhir_sequence')\";\n+        try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n+            ResultSet res = stmt.executeQuery();\n+            if (res.next()) {\n+                v_resource_id = res.getLong(1); //Assign result of the above query\n+            } else {\n+                // unlikely\n+                throw new IllegalStateException(\"no row returned: \" + sql2);\n+            }\n+        }\n+\n+        // Finally we get to the big resource data insert\n+        String sql3 = \"INSERT INTO \" + tablePrefix + \"_resources (resource_id, logical_resource_id, version_id, data, last_updated, is_deleted) \"\n+                + \"VALUES (?,?,?,?,?,?)\";\n+        try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n+            // bind parameters\n+            stmt.setLong(1, v_resource_id);\n+            stmt.setLong(2, v_logical_resource_id);\n+            stmt.setInt(3, v_insert_version);\n+            stmt.setBytes(4, p_payload);\n+            stmt.setTimestamp(5, p_last_updated, UTC);\n+            stmt.setString(6, p_is_deleted ? \"Y\" : \"N\");\n+            stmt.executeUpdate();\n+        }\n+\n+        if (p_version == null || p_version > v_version) {\n+            //only update the logical resource if the resource we are adding supercedes the\n+            //current resource\n+            String sql4 = \"UPDATE \" + tablePrefix + \"_logical_resources SET current_resource_id = ? WHERE logical_resource_id = ?\";\n+            try (PreparedStatement stmt = conn.prepareStatement(sql4)) {\n+                // bind parameters\n+                stmt.setLong(1, v_resource_id);\n+                stmt.setLong(2, v_logical_resource_id);\n+                stmt.executeUpdate();\n+            }\n+\n+            // To keep things simple for the Derby use-case, we just use a visitor to\n+            // handle inserts of parameters directly in the resource parameter tables.\n+            // Note we don't get any parameters for the resource soft-delete operation\n+            if (parameters != null) {\n+                // Derby doesn't support partitioned multi-tenancy, so we disable it on the DAO:\n+                try (ParameterVisitorBatchDAO pvd = new ParameterVisitorBatchDAO(conn, null, tablePrefix, false, v_logical_resource_id, 100,\n+                    new ParameterNameCacheAdapter(parameterNameDAO), new CodeSystemCacheAdapter(codeSystemDAO))) {\n+                    for (ExtractedParameterValue p: parameters) {\n+                        p.accept(pvd);\n+                    }\n+                }\n+            }\n+        }\n+        logger.exiting(CLASSNAME, METHODNAME);\n+        return v_resource_id;\n+    }\n+\n+\n+    /**\n+     * Delete all parameters for the given resourceId from the parameters table\n+     *\n+     * @param conn\n+     * @param tableName\n+     * @param logicalResourceId\n+     * @throws SQLException\n+     */\n+    protected void deleteFromParameterTable(Connection conn, String tableName, long logicalResourceId) throws SQLException {\n+        final String delStrValues = \"DELETE FROM \" + tableName + \" WHERE logical_resource_id = ?\";\n+        try (PreparedStatement stmt = conn.prepareStatement(delStrValues)) {\n+            // bind parameters\n+            stmt.setLong(1, logicalResourceId);\n+            stmt.executeUpdate();\n+        }\n+\n+    }\n+\n+    /**\n+     * Read the id for the named type\n+     * @param resourceTypeName\n+     * @return the database id, or null if the named record is not found\n+     * @throws SQLException\n+     */\n+    protected Integer getResourceTypeId(String resourceTypeName, Connection conn) throws SQLException {\n+        Integer result;\n+\n+        final String sql1 = \"SELECT resource_type_id FROM resource_types WHERE resource_type = ?\";\n+\n+        try (PreparedStatement stmt = conn.prepareStatement(sql1)) {\n+            stmt.setString(1, resourceTypeName);\n+            ResultSet rs = stmt.executeQuery();\n+            if (rs.next()) {\n+                result = rs.getInt(1);\n+            } else {\n+                result = null;\n+            }\n+        }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "861db13b68349b21a0bfcaff0945ee48d74fde2c"}, "originalPosition": 486}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTQ1NjUw", "url": "https://github.com/IBM/FHIR/pull/914#pullrequestreview-396545650", "createdAt": "2020-04-20T15:09:09Z", "commit": {"oid": "da9c04f1c5f94a92812d695b871857eda3d6248a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b1a390133d862dde7ce3bee1b89162a7c86236d", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/8b1a390133d862dde7ce3bee1b89162a7c86236d", "committedDate": "2020-04-20T19:39:26Z", "message": "issue #913 isExportPublic setting is not per-tenant\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d963a109e28bec0a42a6b27d3ab7e1ffa7380687", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/d963a109e28bec0a42a6b27d3ab7e1ffa7380687", "committedDate": "2020-04-20T19:39:26Z", "message": "issue #877 initial code drop for postgresql support\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e41222ced416f81baf5cd2b6f020a4bf9daae435", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/e41222ced416f81baf5cd2b6f020a4bf9daae435", "committedDate": "2020-04-20T19:39:26Z", "message": "issue #877 properties files for postgresql test\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8f6810da67d43c8ea279775fdb2c5a2d555176a6", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/8f6810da67d43c8ea279775fdb2c5a2d555176a6", "committedDate": "2020-04-20T19:39:26Z", "message": "issue #877 update jdbc test properties files and document\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "18a7f0197b4d168ca4d095260d5834514cf764ea", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/18a7f0197b4d168ca4d095260d5834514cf764ea", "committedDate": "2020-04-20T19:39:26Z", "message": "issue #877 add postgresql to server configure\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "26a853a034db321fcfa9f92682bf2bce6f94cab8", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/26a853a034db321fcfa9f92682bf2bce6f94cab8", "committedDate": "2020-04-20T19:39:26Z", "message": "issue #877 add postgresql to schema management readme.\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3cdb2a88d5ad3762b6298414adfe75e826b132cb", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/3cdb2a88d5ad3762b6298414adfe75e826b132cb", "committedDate": "2020-04-20T19:39:26Z", "message": "issue #877 add postgresql driver dir in server.xml\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d69aabb19d79832220c793d401b3c406505148ed", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/d69aabb19d79832220c793d401b3c406505148ed", "committedDate": "2020-04-20T19:39:26Z", "message": "issue #877 code refactor\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f91ce0d77d237a0ffa6911eb5786fde1039eb1ae", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/f91ce0d77d237a0ffa6911eb5786fde1039eb1ae", "committedDate": "2020-04-20T19:39:26Z", "message": "issue #877 change server.xml per review comments\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c4f876169d14d17c54c18a6b64325f0edc9d29c", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/4c4f876169d14d17c54c18a6b64325f0edc9d29c", "committedDate": "2020-04-20T19:39:26Z", "message": "issue #877 minor document update\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee000cc54b9d48050c345b498da8a100bef611f0", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/ee000cc54b9d48050c345b498da8a100bef611f0", "committedDate": "2020-04-20T19:39:26Z", "message": "issue #877 Enable postgresql as javabatch job repo\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "63b42efb9b160491ebc4eca57972c8e9cfbcc4d9", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/63b42efb9b160491ebc4eca57972c8e9cfbcc4d9", "committedDate": "2020-04-20T19:39:26Z", "message": "issue #877 minor update to instruction\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ce5b2bb2590650023867ea2579e8cdf23cb1f848", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/ce5b2bb2590650023867ea2579e8cdf23cb1f848", "committedDate": "2020-04-20T19:39:26Z", "message": "issue #877 updates per review comments\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0fd1ad735a810d16db7a331650026f8a73d7941f", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/0fd1ad735a810d16db7a331650026f8a73d7941f", "committedDate": "2020-04-20T19:39:26Z", "message": "issue #877 minor update to comments of postgresql batch ddl\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e2904dd442454b102bdc9525e91cb4ec388f1d4b", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/e2904dd442454b102bdc9525e91cb4ec388f1d4b", "committedDate": "2020-04-20T19:39:26Z", "message": "issue #877 update codes for addcolum\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2043f180e5c68366e3ad19fb5cf2f515b8a36dd5", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/2043f180e5c68366e3ad19fb5cf2f515b8a36dd5", "committedDate": "2020-04-20T19:39:26Z", "message": "issue #877 minor update to force a rebuild\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "815f16890dd6300107f4d503bb11ab93fb6e1f7b", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/815f16890dd6300107f4d503bb11ab93fb6e1f7b", "committedDate": "2020-04-20T19:39:26Z", "message": "Update docs/src/pages/guides/FHIRServerUsersGuide.md\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "19dee0b948c58336d34fbda5f357640318d222dc", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/19dee0b948c58336d34fbda5f357640318d222dc", "committedDate": "2020-04-20T19:39:26Z", "message": "Update docs/src/pages/guides/FHIRServerUsersGuide.md\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e98dabddc63da6676e4d67c78db617c7f48852e3", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/e98dabddc63da6676e4d67c78db617c7f48852e3", "committedDate": "2020-04-20T19:39:26Z", "message": "Update fhir-bulkimportexport-webapp/src/test/resources/batchPersistence-postgresql.ddl\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa8a6b8a72f6509d7a32bca329258c93317391d3", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/aa8a6b8a72f6509d7a32bca329258c93317391d3", "committedDate": "2020-04-20T19:39:26Z", "message": "Update fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlDoesTableExist.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "116f282fbac23c9c22e7d77226db17a9b08a28d8", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/116f282fbac23c9c22e7d77226db17a9b08a28d8", "committedDate": "2020-04-20T19:39:26Z", "message": "Update fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlTranslator.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c59d7bd49a0beed125c2a08fd5d90228715c304", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/5c59d7bd49a0beed125c2a08fd5d90228715c304", "committedDate": "2020-04-20T19:39:26Z", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlParameterNamesDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d5260182f56b12f18c9ec8b6b6cfe0a3d0c5f68b", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/d5260182f56b12f18c9ec8b6b6cfe0a3d0c5f68b", "committedDate": "2020-04-20T19:39:26Z", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlParameterNamesDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f7d98d771c0964c47ce5b8d11f9c59c2a37b060", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/9f7d98d771c0964c47ce5b8d11f9c59c2a37b060", "committedDate": "2020-04-20T19:39:26Z", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/FhirSequenceDAOImpl.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fec6c21810781939d263dd5345b3507318550658", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/fec6c21810781939d263dd5345b3507318550658", "committedDate": "2020-04-20T19:39:26Z", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/FhirRefSequenceDAOImpl.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c8cd6ad205d2fa92c6c6d980f3f6a43f66e0fb88", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/c8cd6ad205d2fa92c6c6d980f3f6a43f66e0fb88", "committedDate": "2020-04-20T19:39:26Z", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/FHIRResourceDAOFactory.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7689d34718edde99c337c4760f14a456bd80e2dd", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/7689d34718edde99c337c4760f14a456bd80e2dd", "committedDate": "2020-04-20T19:39:26Z", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/FHIRResourceDAOFactory.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "48a79eb2b71f7fb1f12a279ede1bf3958f92b9b5", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/48a79eb2b71f7fb1f12a279ede1bf3958f92b9b5", "committedDate": "2020-04-20T19:39:26Z", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/FHIRResourceDAOFactory.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "22da532b8134a6c2d123bee531373c774529ec00", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/22da532b8134a6c2d123bee531373c774529ec00", "committedDate": "2020-04-20T19:39:26Z", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2e25b8ba7378cedce209864bb2d714ab5bb1f39f", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/2e25b8ba7378cedce209864bb2d714ab5bb1f39f", "committedDate": "2020-04-20T19:39:27Z", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "62a4402385b0d704c273738bbb03b4531211292e", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/62a4402385b0d704c273738bbb03b4531211292e", "committedDate": "2020-04-20T19:39:27Z", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f5c6637bdbd1a33a2a266e969e5c335de765c6b9", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/f5c6637bdbd1a33a2a266e969e5c335de765c6b9", "committedDate": "2020-04-20T19:39:27Z", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b650b7ded3d70427488aefb0bb060b03c5c77716", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/b650b7ded3d70427488aefb0bb060b03c5c77716", "committedDate": "2020-04-20T19:39:27Z", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "61446b4c970f123bb5500bb891ead756bd07cb6e", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/61446b4c970f123bb5500bb891ead756bd07cb6e", "committedDate": "2020-04-20T19:39:27Z", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0acd7d043ee0b0c028a595af3a4ef35b05f3ad7a", "author": {"user": {"login": "albertwang-ibm", "name": "Albert(Xu) Wang"}}, "url": "https://github.com/IBM/FHIR/commit/0acd7d043ee0b0c028a595af3a4ef35b05f3ad7a", "committedDate": "2020-04-20T19:39:27Z", "message": "Update fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java\r\n\r\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>\n\nCo-Authored-By: Paul Bastide <pbastide@us.ibm.com>\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 588, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}