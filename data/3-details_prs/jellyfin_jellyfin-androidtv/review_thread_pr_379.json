{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg0OTY1Mjc2", "number": 379, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNVQyMDoyNDoyM1rODoI9ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNVQyMDo0NToxNFrODoJC5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNDE2NDc4OnYy", "diffSide": "RIGHT", "path": "app/src/main/java/org/jellyfin/androidtv/details/DetailsOverviewPresenter.kt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNVQyMDoyNDoyM1rOF2hEKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMTowNzozNlrOF5jN_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjcwOTE2MQ==", "bodyText": "We probably should decide on one image handling library before we ship this", "url": "https://github.com/jellyfin/jellyfin-androidtv/pull/379#discussion_r392709161", "createdAt": "2020-03-15T20:24:23Z", "author": {"login": "AndreasGB"}, "path": "app/src/main/java/org/jellyfin/androidtv/details/DetailsOverviewPresenter.kt", "diffHunk": "@@ -52,17 +68,41 @@ class DetailsDescriptionPresenter : Presenter() {\n \t\tval textStreamValue: TextView = view.details_description_streams_text_value\n \t}\n \n-\toverride fun onCreateViewHolder(parent: ViewGroup): ViewHolder {\n+\toverride fun createRowViewHolder(parent: ViewGroup): ViewHolder {\n \t\tval view = LayoutInflater\n \t\t\t.from(parent.context)\n \t\t\t.inflate(R.layout.row_details_description, parent, false)\n \n \t\treturn ViewHolder(view)\n \t}\n \n-\toverride fun onBindViewHolder(viewHolder: Presenter.ViewHolder, item: Any) {\n+\toverride fun onBindRowViewHolder(viewHolder: RowPresenter.ViewHolder, row: Any) {\n \t\tviewHolder as ViewHolder\n-\t\titem as BaseItem\n+\t\trow as DetailsOverviewRow\n+\t\tval item = row.item\n+\n+\t\t// banner\n+\t\t//todo hide banner view when none found, support multiple banners\n+\t\titem.images.backdrops.firstOrNull()?.let {\n+\t\t\t// Android doesn't crop automatically but Glide does\n+\t\t\t// Picasso can also do this but doesn't read the XML attributes of the target view for it\n+\t\t\t// so the way Glide does it is preferred to avoid duplicate settings\n+\t\t\tGlide.with(viewHolder.view.context).load(it.url).into(viewHolder.banner)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e6fdc48362329d965a6801ab57458d47c2e37dc"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg5MDE3Mw==", "bodyText": "I made a separate issue for this.", "url": "https://github.com/jellyfin/jellyfin-androidtv/pull/379#discussion_r395890173", "createdAt": "2020-03-20T21:07:36Z", "author": {"login": "nielsvanvelzen"}, "path": "app/src/main/java/org/jellyfin/androidtv/details/DetailsOverviewPresenter.kt", "diffHunk": "@@ -52,17 +68,41 @@ class DetailsDescriptionPresenter : Presenter() {\n \t\tval textStreamValue: TextView = view.details_description_streams_text_value\n \t}\n \n-\toverride fun onCreateViewHolder(parent: ViewGroup): ViewHolder {\n+\toverride fun createRowViewHolder(parent: ViewGroup): ViewHolder {\n \t\tval view = LayoutInflater\n \t\t\t.from(parent.context)\n \t\t\t.inflate(R.layout.row_details_description, parent, false)\n \n \t\treturn ViewHolder(view)\n \t}\n \n-\toverride fun onBindViewHolder(viewHolder: Presenter.ViewHolder, item: Any) {\n+\toverride fun onBindRowViewHolder(viewHolder: RowPresenter.ViewHolder, row: Any) {\n \t\tviewHolder as ViewHolder\n-\t\titem as BaseItem\n+\t\trow as DetailsOverviewRow\n+\t\tval item = row.item\n+\n+\t\t// banner\n+\t\t//todo hide banner view when none found, support multiple banners\n+\t\titem.images.backdrops.firstOrNull()?.let {\n+\t\t\t// Android doesn't crop automatically but Glide does\n+\t\t\t// Picasso can also do this but doesn't read the XML attributes of the target view for it\n+\t\t\t// so the way Glide does it is preferred to avoid duplicate settings\n+\t\t\tGlide.with(viewHolder.view.context).load(it.url).into(viewHolder.banner)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjcwOTE2MQ=="}, "originalCommit": {"oid": "9e6fdc48362329d965a6801ab57458d47c2e37dc"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNDE3ODI4OnYy", "diffSide": "RIGHT", "path": "app/src/main/java/org/jellyfin/androidtv/details/actions/ActionAdapter.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNVQyMDo0NToxNFrOF2hLKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNVQyMDo0NToxNFrOF2hLKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjcxMDk1Mw==", "bodyText": "Should this be changed on unbind?", "url": "https://github.com/jellyfin/jellyfin-androidtv/pull/379#discussion_r392710953", "createdAt": "2020-03-15T20:45:14Z", "author": {"login": "AndreasGB"}, "path": "app/src/main/java/org/jellyfin/androidtv/details/actions/ActionAdapter.kt", "diffHunk": "@@ -1,86 +1,74 @@\n package org.jellyfin.androidtv.details.actions\n \n+import android.content.res.ColorStateList\n+import android.os.Build\n import android.view.LayoutInflater\n import android.view.View\n import android.view.ViewGroup\n import android.widget.Button\n-import androidx.leanback.widget.Action\n-import androidx.leanback.widget.ObjectAdapter\n-import androidx.leanback.widget.Presenter\n+import androidx.lifecycle.Lifecycle\n+import androidx.lifecycle.LifecycleOwner\n+import androidx.lifecycle.LifecycleRegistry\n+import androidx.lifecycle.Observer\n+import androidx.recyclerview.widget.RecyclerView\n+import kotlinx.coroutines.Dispatchers\n+import kotlinx.coroutines.GlobalScope\n+import kotlinx.coroutines.launch\n import org.jellyfin.androidtv.R\n \n-class ActionAdapter : ObjectAdapter(ActionPresenter()) {\n-\tprivate val actions = arrayListOf<Action>()\n-\tprivate var visibleActions = emptyList<Action>()\n+class ActionAdapter() {\n+\tfun createViewHolder(parent: ViewGroup): ActionViewHolder {\n+\t\tval view = LayoutInflater\n+\t\t\t.from(parent.context)\n+\t\t\t.inflate(R.layout.action, parent, false)\n \n-\tfun add(action: Action) {\n-\t\t// Add action\n-\t\tactions += action\n-\n-\t\t// Bind listener\n-\t\tif (action is BaseAction) action.onVisibilityChanged = ::commit\n+\t\treturn ActionViewHolder(view)\n \t}\n \n-\tfun commit() {\n-\t\t// Update visible actions\n-\t\tvisibleActions = actions.filter { action -> action !is BaseAction || action.isVisible }\n-\n-\t\t// Notify the actions have changed\n-\t\tnotifyChanged()\n-\t}\n-\n-\toverride fun size() = visibleActions.size\n-\toverride fun get(position: Int) = visibleActions.getOrNull(position)\n-\n-\tfun setVisibility(action: BaseAction, visible: Boolean) {\n-\t\taction.isVisible = visible\n-\n-\t\tcommit()\n-\t}\n-\n-\tprivate class ActionPresenter : Presenter() {\n-\t\toverride fun onCreateViewHolder(parent: ViewGroup): ViewHolder {\n-\t\t\tval view = LayoutInflater\n-\t\t\t\t.from(parent.context)\n-\t\t\t\t.inflate(R.layout.action, parent, false)\n-\n-\t\t\treturn ActionViewHolder(view)\n+\tfun bindViewHolder(viewHolder: ActionViewHolder, action: Action) {\n+\t\t// Visibility\n+\t\taction.visible.observe(viewHolder, Observer { visible ->\n+\t\t\tviewHolder.view.visibility = if (visible) View.VISIBLE else View.GONE\n+\t\t\tviewHolder.button.visibility = if (visible) View.VISIBLE else View.GONE\n+\t\t})\n+\n+\t\t// Icon\n+\t\taction.icon.observe(viewHolder, Observer { icon ->\n+\t\t\tviewHolder.button.setCompoundDrawablesWithIntrinsicBounds(null, icon, null, null)\n+\t\t})\n+\n+\t\t// Text\n+\t\taction.text.observe(viewHolder, Observer { text ->\n+\t\t\tviewHolder.button.text = text\n+\t\t})\n+\n+\t\t// Active state\n+\t\tif (action is ToggleableAction) {\n+\t\t\taction.active.observe(viewHolder, Observer { active ->\n+\t\t\t\tval color = viewHolder.button.resources.getColor(if (active) R.color.action_active else R.color.white)\n+\t\t\t\tviewHolder.button.setTextColor(color)\n+\t\t\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M)\n+\t\t\t\t\tviewHolder.button.compoundDrawableTintList = ColorStateList.valueOf(color)\n+\t\t\t})\n \t\t}\n \n-\t\toverride fun onBindViewHolder(viewHolder: ViewHolder, action: Any) {\n-\t\t\t// Cast types\n-\t\t\taction as Action\n-\t\t\tviewHolder as ActionViewHolder\n-\n-\t\t\t// Set data\n-\t\t\tviewHolder.button.setCompoundDrawablesWithIntrinsicBounds(null, action.icon, null, null)\n-\t\t\tviewHolder.button.text = action.label1\n-\n-\t\t\tif (action is SecondariesPopupAction) {\n-\t\t\t\taction.anchor = viewHolder.button\n-\t\t\t}\n-\n-\t\t\tif (action is ToggleAction) {\n-\t\t\t\tval color = if (action.active) R.color.action_active else R.color.white\n-\n-\t\t\t\tviewHolder.button.apply {\n-\t\t\t\t\taction.icon.setTint(resources.getColor(color))\n-\t\t\t\t\tsetTextColor(resources.getColor(color))\n-\t\t\t\t}\n+\t\t// Click listener\n+\t\tviewHolder.button.setOnClickListener { view ->\n+\t\t\tGlobalScope.launch(Dispatchers.Main) {\n+\t\t\t\taction.onClick(view)\n \t\t\t}\n \t\t}\n \n-\t\toverride fun onUnbindViewHolder(viewHolder: ViewHolder) {\n-\t\t\tviewHolder as ActionViewHolder\n+\t\t// Set state so the observers initialize\n+\t\tviewHolder.lifecycle.currentState = Lifecycle.State.STARTED", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e6fdc48362329d965a6801ab57458d47c2e37dc"}, "originalPosition": 121}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1041, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}