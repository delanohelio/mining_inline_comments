{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI0NTg1Mzg2", "number": 3206, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMzoyODo1NVrOE7ileQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMzoyODo1NVrOE7ileQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODY4MDg5OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/spongepowered/common/mixin/core/world/gen/ChunkProviderServerMixin.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMzoyODo1NVrOH3PqEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNTo1Mzo0MVrOH3VczA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY5MDI1Nw==", "bodyText": "Just clarify something for me here: this seems to change the logic such that chunk data and extra chunk data will never be saved if the max chunk lifetime is disabled because this check will then always succeed and fall through to the continue? Shouldn't this check only pass if the chunk isn't due to be unloaded in the first place?", "url": "https://github.com/SpongePowered/Sponge/pull/3206#discussion_r527690257", "createdAt": "2020-11-20T13:28:55Z", "author": {"login": "dualspiral"}, "path": "src/main/java/org/spongepowered/common/mixin/core/world/gen/ChunkProviderServerMixin.java", "diffHunk": "@@ -268,22 +270,34 @@ public boolean tick()\n             final Iterator<Chunk> iterator = this.loadedChunks.values().iterator();\n             int chunksUnloaded = 0;\n             final long now = System.currentTimeMillis();\n+            final long world_time = this.world.getTotalWorldTime();\n             while (chunksUnloaded < this.impl$maxChunkUnloads && iterator.hasNext()) {\n                 final Chunk chunk = iterator.next();\n                 final ChunkBridge spongeChunk = (ChunkBridge) chunk;\n-                if (chunk != null && chunk.unloadQueued && !spongeChunk.bridge$isPersistedChunk()) {\n+                if (chunk == null || spongeChunk.bridge$isPersistedChunk()) {\n+                    continue;\n+                }\n+                if (chunk.unloadQueued) {\n                     if (this.bridge$getChunkUnloadDelay() > 0) {\n                         if ((now - spongeChunk.bridge$getScheduledForUnload()) < this.impl$chunkUnloadDelay) {\n                             continue;\n                         }\n                         spongeChunk.bridge$setScheduledForUnload(-1);\n                     }\n                     chunk.onUnload();\n-                    this.saveChunkData(chunk);\n-                    this.saveChunkExtraData(chunk);\n+                }\n+                // max lifetime only applies to chunks that should stay loaded but still need saving once in a while\n+                else if (this.impl$maxChunkLifetime <= 0 // if setting is disabled", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edd1d1df3baeb133c1aca17550eaa5245ee896b8"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY5MjkwNg==", "bodyText": "Oh, wait, I see, else if. Got it.", "url": "https://github.com/SpongePowered/Sponge/pull/3206#discussion_r527692906", "createdAt": "2020-11-20T13:33:41Z", "author": {"login": "dualspiral"}, "path": "src/main/java/org/spongepowered/common/mixin/core/world/gen/ChunkProviderServerMixin.java", "diffHunk": "@@ -268,22 +270,34 @@ public boolean tick()\n             final Iterator<Chunk> iterator = this.loadedChunks.values().iterator();\n             int chunksUnloaded = 0;\n             final long now = System.currentTimeMillis();\n+            final long world_time = this.world.getTotalWorldTime();\n             while (chunksUnloaded < this.impl$maxChunkUnloads && iterator.hasNext()) {\n                 final Chunk chunk = iterator.next();\n                 final ChunkBridge spongeChunk = (ChunkBridge) chunk;\n-                if (chunk != null && chunk.unloadQueued && !spongeChunk.bridge$isPersistedChunk()) {\n+                if (chunk == null || spongeChunk.bridge$isPersistedChunk()) {\n+                    continue;\n+                }\n+                if (chunk.unloadQueued) {\n                     if (this.bridge$getChunkUnloadDelay() > 0) {\n                         if ((now - spongeChunk.bridge$getScheduledForUnload()) < this.impl$chunkUnloadDelay) {\n                             continue;\n                         }\n                         spongeChunk.bridge$setScheduledForUnload(-1);\n                     }\n                     chunk.onUnload();\n-                    this.saveChunkData(chunk);\n-                    this.saveChunkExtraData(chunk);\n+                }\n+                // max lifetime only applies to chunks that should stay loaded but still need saving once in a while\n+                else if (this.impl$maxChunkLifetime <= 0 // if setting is disabled", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY5MDI1Nw=="}, "originalCommit": {"oid": "edd1d1df3baeb133c1aca17550eaa5245ee896b8"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzc4NTE2NA==", "bodyText": "Exactly. If the chunk is scheduled for unload - it's lifetime doesn't need to be checked - we just fall through to the saving code.", "url": "https://github.com/SpongePowered/Sponge/pull/3206#discussion_r527785164", "createdAt": "2020-11-20T15:53:41Z", "author": {"login": "PolyacovYury"}, "path": "src/main/java/org/spongepowered/common/mixin/core/world/gen/ChunkProviderServerMixin.java", "diffHunk": "@@ -268,22 +270,34 @@ public boolean tick()\n             final Iterator<Chunk> iterator = this.loadedChunks.values().iterator();\n             int chunksUnloaded = 0;\n             final long now = System.currentTimeMillis();\n+            final long world_time = this.world.getTotalWorldTime();\n             while (chunksUnloaded < this.impl$maxChunkUnloads && iterator.hasNext()) {\n                 final Chunk chunk = iterator.next();\n                 final ChunkBridge spongeChunk = (ChunkBridge) chunk;\n-                if (chunk != null && chunk.unloadQueued && !spongeChunk.bridge$isPersistedChunk()) {\n+                if (chunk == null || spongeChunk.bridge$isPersistedChunk()) {\n+                    continue;\n+                }\n+                if (chunk.unloadQueued) {\n                     if (this.bridge$getChunkUnloadDelay() > 0) {\n                         if ((now - spongeChunk.bridge$getScheduledForUnload()) < this.impl$chunkUnloadDelay) {\n                             continue;\n                         }\n                         spongeChunk.bridge$setScheduledForUnload(-1);\n                     }\n                     chunk.onUnload();\n-                    this.saveChunkData(chunk);\n-                    this.saveChunkExtraData(chunk);\n+                }\n+                // max lifetime only applies to chunks that should stay loaded but still need saving once in a while\n+                else if (this.impl$maxChunkLifetime <= 0 // if setting is disabled", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY5MDI1Nw=="}, "originalCommit": {"oid": "edd1d1df3baeb133c1aca17550eaa5245ee896b8"}, "originalPosition": 40}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2512, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}