{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIyMDYzMzU4", "number": 2620, "title": "API8 Fixing Data Impl", "bodyText": "for reference\nSpongePowered/SpongeAPI#1996\nhttps://gist.github.com/Faithcaio/4e0f85887c0921a96160603a6b8c555f", "createdAt": "2020-05-22T17:40:08Z", "url": "https://github.com/SpongePowered/Sponge/pull/2620", "merged": true, "mergeCommit": {"oid": "0ee1ec86d495d1e8f90c8eceb75651ac0e542c69"}, "closed": true, "closedAt": "2020-05-31T22:04:23Z", "author": {"login": "Faithcaio"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABckE7eGABqjMzNjY5MzcxMjI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABckWbMNABqjMzNjc3MjEwMTk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b8f51f2d587761b155c0f7c3dd8882cd036a1e99", "author": {"user": {"login": "Faithcaio", "name": "Faithcaio"}}, "url": "https://github.com/SpongePowered/Sponge/commit/b8f51f2d587761b155c0f7c3dd8882cd036a1e99", "committedDate": "2020-05-23T11:10:42Z", "message": "looking better"}, "afterCommit": {"oid": "f3c98dd27204e8181525d92c657a099855405c42", "author": {"user": {"login": "Faithcaio", "name": "Faithcaio"}}, "url": "https://github.com/SpongePowered/Sponge/commit/f3c98dd27204e8181525d92c657a099855405c42", "committedDate": "2020-05-23T11:11:39Z", "message": "looking better"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3Mjc1NTI3", "url": "https://github.com/SpongePowered/Sponge/pull/2620#pullrequestreview-417275527", "createdAt": "2020-05-23T12:34:12Z", "commit": {"oid": "f3c98dd27204e8181525d92c657a099855405c42"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QxMjozNDoxMlrOGZpLjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QxMjo0NToyM1rOGZpOyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0MjI4NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final Map<Class<?>, DataBuilder<?>> builders = Maps.newHashMap();\n          \n          \n            \n                private final Map<Class<?>, DataBuilder<?>> builders = new IdentityHashMap<>();", "url": "https://github.com/SpongePowered/Sponge/pull/2620#discussion_r429542284", "createdAt": "2020-05-23T12:34:12Z", "author": {"login": "ImMorpheus"}, "path": "src/main/java/org/spongepowered/common/data/SpongeDataManager.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * This file is part of Sponge, licensed under the MIT License (MIT).\n+ *\n+ * Copyright (c) SpongePowered <https://www.spongepowered.org>\n+ * Copyright (c) contributors\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.spongepowered.common.data;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.MapMaker;\n+import com.google.common.collect.Maps;\n+import com.google.common.reflect.TypeToken;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+import net.minecraft.nbt.CompoundNBT;\n+import net.minecraft.nbt.INBT;\n+import net.minecraft.nbt.ListNBT;\n+import net.minecraft.util.registry.Registry;\n+import ninja.leaping.configurate.objectmapping.serialize.TypeSerializers;\n+import org.spongepowered.api.CatalogKey;\n+import org.spongepowered.api.CatalogType;\n+import org.spongepowered.api.data.DataHolder;\n+import org.spongepowered.api.data.DataHolderBuilder;\n+import org.spongepowered.api.data.DataManager;\n+import org.spongepowered.api.data.DataManipulator;\n+import org.spongepowered.api.data.DataManipulator.Mutable;\n+import org.spongepowered.api.data.DataProvider;\n+import org.spongepowered.api.data.DataRegistration;\n+import org.spongepowered.api.data.Key;\n+import org.spongepowered.api.data.persistence.AbstractDataBuilder;\n+import org.spongepowered.api.data.persistence.DataBuilder;\n+import org.spongepowered.api.data.persistence.DataContainer;\n+import org.spongepowered.api.data.persistence.DataContentUpdater;\n+import org.spongepowered.api.data.persistence.DataSerializable;\n+import org.spongepowered.api.data.persistence.DataStore;\n+import org.spongepowered.api.data.persistence.DataTranslator;\n+import org.spongepowered.api.data.persistence.DataView;\n+import org.spongepowered.api.data.persistence.Queries;\n+import org.spongepowered.api.plugin.PluginContainer;\n+import org.spongepowered.common.SpongeImpl;\n+import org.spongepowered.common.bridge.data.CustomDataHolderBridge;\n+import org.spongepowered.common.config.DataSerializableTypeSerializer;\n+import org.spongepowered.common.data.persistence.NbtTranslator;\n+import org.spongepowered.common.registry.MappedRegistry;\n+import org.spongepowered.common.registry.SpongeCatalogRegistry;\n+import org.spongepowered.common.util.Constants;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+@Singleton\n+public final class SpongeDataManager implements DataManager {\n+    private static final SpongeDataManager INSTANCE = new SpongeDataManager();\n+\n+    private static final TypeToken<CatalogType> catalogTypeToken = TypeToken.of(CatalogType.class);\n+    private static final TypeToken<DataSerializable> dataSerializableTypeToken = TypeToken.of(DataSerializable.class);\n+\n+    static {\n+        TypeSerializers.getDefaultSerializers().registerPredicate(\n+            // We have a separate type serializer for CatalogTypes, so we explicitly discount them here.\n+            // See https://github.com/SpongePowered/SpongeCommon/issues/1348\n+            x -> dataSerializableTypeToken.isSupertypeOf(x) && !catalogTypeToken.isSupertypeOf(x), new DataSerializableTypeSerializer()\n+        );\n+    }\n+\n+    // Builders\n+    private final Map<Class<?>, DataBuilder<?>> builders = Maps.newHashMap();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f3c98dd27204e8181525d92c657a099855405c42"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0MjMyNg==", "bodyText": "You can replace contains + put with putIfAbsent and check the return value", "url": "https://github.com/SpongePowered/Sponge/pull/2620#discussion_r429542326", "createdAt": "2020-05-23T12:34:59Z", "author": {"login": "ImMorpheus"}, "path": "src/main/java/org/spongepowered/common/data/SpongeDataManager.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * This file is part of Sponge, licensed under the MIT License (MIT).\n+ *\n+ * Copyright (c) SpongePowered <https://www.spongepowered.org>\n+ * Copyright (c) contributors\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.spongepowered.common.data;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.MapMaker;\n+import com.google.common.collect.Maps;\n+import com.google.common.reflect.TypeToken;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+import net.minecraft.nbt.CompoundNBT;\n+import net.minecraft.nbt.INBT;\n+import net.minecraft.nbt.ListNBT;\n+import net.minecraft.util.registry.Registry;\n+import ninja.leaping.configurate.objectmapping.serialize.TypeSerializers;\n+import org.spongepowered.api.CatalogKey;\n+import org.spongepowered.api.CatalogType;\n+import org.spongepowered.api.data.DataHolder;\n+import org.spongepowered.api.data.DataHolderBuilder;\n+import org.spongepowered.api.data.DataManager;\n+import org.spongepowered.api.data.DataManipulator;\n+import org.spongepowered.api.data.DataManipulator.Mutable;\n+import org.spongepowered.api.data.DataProvider;\n+import org.spongepowered.api.data.DataRegistration;\n+import org.spongepowered.api.data.Key;\n+import org.spongepowered.api.data.persistence.AbstractDataBuilder;\n+import org.spongepowered.api.data.persistence.DataBuilder;\n+import org.spongepowered.api.data.persistence.DataContainer;\n+import org.spongepowered.api.data.persistence.DataContentUpdater;\n+import org.spongepowered.api.data.persistence.DataSerializable;\n+import org.spongepowered.api.data.persistence.DataStore;\n+import org.spongepowered.api.data.persistence.DataTranslator;\n+import org.spongepowered.api.data.persistence.DataView;\n+import org.spongepowered.api.data.persistence.Queries;\n+import org.spongepowered.api.plugin.PluginContainer;\n+import org.spongepowered.common.SpongeImpl;\n+import org.spongepowered.common.bridge.data.CustomDataHolderBridge;\n+import org.spongepowered.common.config.DataSerializableTypeSerializer;\n+import org.spongepowered.common.data.persistence.NbtTranslator;\n+import org.spongepowered.common.registry.MappedRegistry;\n+import org.spongepowered.common.registry.SpongeCatalogRegistry;\n+import org.spongepowered.common.util.Constants;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+@Singleton\n+public final class SpongeDataManager implements DataManager {\n+    private static final SpongeDataManager INSTANCE = new SpongeDataManager();\n+\n+    private static final TypeToken<CatalogType> catalogTypeToken = TypeToken.of(CatalogType.class);\n+    private static final TypeToken<DataSerializable> dataSerializableTypeToken = TypeToken.of(DataSerializable.class);\n+\n+    static {\n+        TypeSerializers.getDefaultSerializers().registerPredicate(\n+            // We have a separate type serializer for CatalogTypes, so we explicitly discount them here.\n+            // See https://github.com/SpongePowered/SpongeCommon/issues/1348\n+            x -> dataSerializableTypeToken.isSupertypeOf(x) && !catalogTypeToken.isSupertypeOf(x), new DataSerializableTypeSerializer()\n+        );\n+    }\n+\n+    // Builders\n+    private final Map<Class<?>, DataBuilder<?>> builders = Maps.newHashMap();\n+\n+\n+    private final Map<Class<? extends DataHolder.Immutable<?>>, DataHolderBuilder.Immutable<?, ?>> immutableDataBuilderMap = new MapMaker()\n+        .concurrencyLevel(4)\n+        .makeMap();\n+    // Content updaters\n+    private final Map<Class<? extends DataSerializable>, List<DataContentUpdater>> updatersMap = new IdentityHashMap<>();\n+\n+\n+    static boolean allowRegistrations = true;\n+    private List<DataContentUpdater> customDataUpdaters = new ArrayList<>();\n+\n+\n+    public static SpongeDataManager getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    @Inject\n+    private SpongeDataManager() {}\n+\n+    @Override\n+    public <T extends DataSerializable> void registerBuilder(Class<T> clazz, DataBuilder<T> builder) {\n+        Preconditions.checkNotNull(clazz);\n+        Preconditions.checkNotNull(builder);\n+        if (!this.builders.containsKey(clazz)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f3c98dd27204e8181525d92c657a099855405c42"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0MjM2Nw==", "bodyText": "Same as above", "url": "https://github.com/SpongePowered/Sponge/pull/2620#discussion_r429542367", "createdAt": "2020-05-23T12:35:25Z", "author": {"login": "ImMorpheus"}, "path": "src/main/java/org/spongepowered/common/data/SpongeDataManager.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * This file is part of Sponge, licensed under the MIT License (MIT).\n+ *\n+ * Copyright (c) SpongePowered <https://www.spongepowered.org>\n+ * Copyright (c) contributors\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.spongepowered.common.data;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.MapMaker;\n+import com.google.common.collect.Maps;\n+import com.google.common.reflect.TypeToken;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+import net.minecraft.nbt.CompoundNBT;\n+import net.minecraft.nbt.INBT;\n+import net.minecraft.nbt.ListNBT;\n+import net.minecraft.util.registry.Registry;\n+import ninja.leaping.configurate.objectmapping.serialize.TypeSerializers;\n+import org.spongepowered.api.CatalogKey;\n+import org.spongepowered.api.CatalogType;\n+import org.spongepowered.api.data.DataHolder;\n+import org.spongepowered.api.data.DataHolderBuilder;\n+import org.spongepowered.api.data.DataManager;\n+import org.spongepowered.api.data.DataManipulator;\n+import org.spongepowered.api.data.DataManipulator.Mutable;\n+import org.spongepowered.api.data.DataProvider;\n+import org.spongepowered.api.data.DataRegistration;\n+import org.spongepowered.api.data.Key;\n+import org.spongepowered.api.data.persistence.AbstractDataBuilder;\n+import org.spongepowered.api.data.persistence.DataBuilder;\n+import org.spongepowered.api.data.persistence.DataContainer;\n+import org.spongepowered.api.data.persistence.DataContentUpdater;\n+import org.spongepowered.api.data.persistence.DataSerializable;\n+import org.spongepowered.api.data.persistence.DataStore;\n+import org.spongepowered.api.data.persistence.DataTranslator;\n+import org.spongepowered.api.data.persistence.DataView;\n+import org.spongepowered.api.data.persistence.Queries;\n+import org.spongepowered.api.plugin.PluginContainer;\n+import org.spongepowered.common.SpongeImpl;\n+import org.spongepowered.common.bridge.data.CustomDataHolderBridge;\n+import org.spongepowered.common.config.DataSerializableTypeSerializer;\n+import org.spongepowered.common.data.persistence.NbtTranslator;\n+import org.spongepowered.common.registry.MappedRegistry;\n+import org.spongepowered.common.registry.SpongeCatalogRegistry;\n+import org.spongepowered.common.util.Constants;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+@Singleton\n+public final class SpongeDataManager implements DataManager {\n+    private static final SpongeDataManager INSTANCE = new SpongeDataManager();\n+\n+    private static final TypeToken<CatalogType> catalogTypeToken = TypeToken.of(CatalogType.class);\n+    private static final TypeToken<DataSerializable> dataSerializableTypeToken = TypeToken.of(DataSerializable.class);\n+\n+    static {\n+        TypeSerializers.getDefaultSerializers().registerPredicate(\n+            // We have a separate type serializer for CatalogTypes, so we explicitly discount them here.\n+            // See https://github.com/SpongePowered/SpongeCommon/issues/1348\n+            x -> dataSerializableTypeToken.isSupertypeOf(x) && !catalogTypeToken.isSupertypeOf(x), new DataSerializableTypeSerializer()\n+        );\n+    }\n+\n+    // Builders\n+    private final Map<Class<?>, DataBuilder<?>> builders = Maps.newHashMap();\n+\n+\n+    private final Map<Class<? extends DataHolder.Immutable<?>>, DataHolderBuilder.Immutable<?, ?>> immutableDataBuilderMap = new MapMaker()\n+        .concurrencyLevel(4)\n+        .makeMap();\n+    // Content updaters\n+    private final Map<Class<? extends DataSerializable>, List<DataContentUpdater>> updatersMap = new IdentityHashMap<>();\n+\n+\n+    static boolean allowRegistrations = true;\n+    private List<DataContentUpdater> customDataUpdaters = new ArrayList<>();\n+\n+\n+    public static SpongeDataManager getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    @Inject\n+    private SpongeDataManager() {}\n+\n+    @Override\n+    public <T extends DataSerializable> void registerBuilder(Class<T> clazz, DataBuilder<T> builder) {\n+        Preconditions.checkNotNull(clazz);\n+        Preconditions.checkNotNull(builder);\n+        if (!this.builders.containsKey(clazz)) {\n+            if (!(builder instanceof AbstractDataBuilder)) {\n+                SpongeImpl.getLogger().warn(\"A custom DataBuilder is not extending AbstractDataBuilder! It is recommended that \"\n+                                            + \"the custom data builder does extend it to gain automated content versioning updates and maintain \"\n+                                            + \"simplicity. The offending builder's class is: {}\", builder.getClass());\n+            }\n+            this.builders.put(clazz, builder);\n+        } else {\n+            SpongeImpl.getLogger().warn(\"A DataBuilder has already been registered for {}. Attempted to register {} instead.\", clazz,\n+                    builder.getClass());\n+        }\n+    }\n+\n+    @Override\n+    public <T extends DataSerializable> void registerContentUpdater(Class<T> clazz, DataContentUpdater updater) {\n+        Preconditions.checkNotNull(updater, \"DataContentUpdater was null!\");\n+        if (!this.updatersMap.containsKey(Preconditions.checkNotNull(clazz, \"DataSerializable class was null!\"))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f3c98dd27204e8181525d92c657a099855405c42"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0MjQ0NQ==", "bodyText": "Replace contains + get with get and check if the return value is null", "url": "https://github.com/SpongePowered/Sponge/pull/2620#discussion_r429542445", "createdAt": "2020-05-23T12:36:34Z", "author": {"login": "ImMorpheus"}, "path": "src/main/java/org/spongepowered/common/data/SpongeDataManager.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * This file is part of Sponge, licensed under the MIT License (MIT).\n+ *\n+ * Copyright (c) SpongePowered <https://www.spongepowered.org>\n+ * Copyright (c) contributors\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.spongepowered.common.data;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.MapMaker;\n+import com.google.common.collect.Maps;\n+import com.google.common.reflect.TypeToken;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+import net.minecraft.nbt.CompoundNBT;\n+import net.minecraft.nbt.INBT;\n+import net.minecraft.nbt.ListNBT;\n+import net.minecraft.util.registry.Registry;\n+import ninja.leaping.configurate.objectmapping.serialize.TypeSerializers;\n+import org.spongepowered.api.CatalogKey;\n+import org.spongepowered.api.CatalogType;\n+import org.spongepowered.api.data.DataHolder;\n+import org.spongepowered.api.data.DataHolderBuilder;\n+import org.spongepowered.api.data.DataManager;\n+import org.spongepowered.api.data.DataManipulator;\n+import org.spongepowered.api.data.DataManipulator.Mutable;\n+import org.spongepowered.api.data.DataProvider;\n+import org.spongepowered.api.data.DataRegistration;\n+import org.spongepowered.api.data.Key;\n+import org.spongepowered.api.data.persistence.AbstractDataBuilder;\n+import org.spongepowered.api.data.persistence.DataBuilder;\n+import org.spongepowered.api.data.persistence.DataContainer;\n+import org.spongepowered.api.data.persistence.DataContentUpdater;\n+import org.spongepowered.api.data.persistence.DataSerializable;\n+import org.spongepowered.api.data.persistence.DataStore;\n+import org.spongepowered.api.data.persistence.DataTranslator;\n+import org.spongepowered.api.data.persistence.DataView;\n+import org.spongepowered.api.data.persistence.Queries;\n+import org.spongepowered.api.plugin.PluginContainer;\n+import org.spongepowered.common.SpongeImpl;\n+import org.spongepowered.common.bridge.data.CustomDataHolderBridge;\n+import org.spongepowered.common.config.DataSerializableTypeSerializer;\n+import org.spongepowered.common.data.persistence.NbtTranslator;\n+import org.spongepowered.common.registry.MappedRegistry;\n+import org.spongepowered.common.registry.SpongeCatalogRegistry;\n+import org.spongepowered.common.util.Constants;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+@Singleton\n+public final class SpongeDataManager implements DataManager {\n+    private static final SpongeDataManager INSTANCE = new SpongeDataManager();\n+\n+    private static final TypeToken<CatalogType> catalogTypeToken = TypeToken.of(CatalogType.class);\n+    private static final TypeToken<DataSerializable> dataSerializableTypeToken = TypeToken.of(DataSerializable.class);\n+\n+    static {\n+        TypeSerializers.getDefaultSerializers().registerPredicate(\n+            // We have a separate type serializer for CatalogTypes, so we explicitly discount them here.\n+            // See https://github.com/SpongePowered/SpongeCommon/issues/1348\n+            x -> dataSerializableTypeToken.isSupertypeOf(x) && !catalogTypeToken.isSupertypeOf(x), new DataSerializableTypeSerializer()\n+        );\n+    }\n+\n+    // Builders\n+    private final Map<Class<?>, DataBuilder<?>> builders = Maps.newHashMap();\n+\n+\n+    private final Map<Class<? extends DataHolder.Immutable<?>>, DataHolderBuilder.Immutable<?, ?>> immutableDataBuilderMap = new MapMaker()\n+        .concurrencyLevel(4)\n+        .makeMap();\n+    // Content updaters\n+    private final Map<Class<? extends DataSerializable>, List<DataContentUpdater>> updatersMap = new IdentityHashMap<>();\n+\n+\n+    static boolean allowRegistrations = true;\n+    private List<DataContentUpdater> customDataUpdaters = new ArrayList<>();\n+\n+\n+    public static SpongeDataManager getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    @Inject\n+    private SpongeDataManager() {}\n+\n+    @Override\n+    public <T extends DataSerializable> void registerBuilder(Class<T> clazz, DataBuilder<T> builder) {\n+        Preconditions.checkNotNull(clazz);\n+        Preconditions.checkNotNull(builder);\n+        if (!this.builders.containsKey(clazz)) {\n+            if (!(builder instanceof AbstractDataBuilder)) {\n+                SpongeImpl.getLogger().warn(\"A custom DataBuilder is not extending AbstractDataBuilder! It is recommended that \"\n+                                            + \"the custom data builder does extend it to gain automated content versioning updates and maintain \"\n+                                            + \"simplicity. The offending builder's class is: {}\", builder.getClass());\n+            }\n+            this.builders.put(clazz, builder);\n+        } else {\n+            SpongeImpl.getLogger().warn(\"A DataBuilder has already been registered for {}. Attempted to register {} instead.\", clazz,\n+                    builder.getClass());\n+        }\n+    }\n+\n+    @Override\n+    public <T extends DataSerializable> void registerContentUpdater(Class<T> clazz, DataContentUpdater updater) {\n+        Preconditions.checkNotNull(updater, \"DataContentUpdater was null!\");\n+        if (!this.updatersMap.containsKey(Preconditions.checkNotNull(clazz, \"DataSerializable class was null!\"))) {\n+            this.updatersMap.put(clazz, new ArrayList<>());\n+        }\n+        final List<DataContentUpdater> updaters = this.updatersMap.get(clazz);\n+        updaters.add(updater);\n+        Collections.sort(updaters, Constants.Functional.DATA_CONTENT_UPDATER_COMPARATOR);\n+    }\n+\n+    public void registerCustomDataContentUpdater(DataContentUpdater updater) {\n+        this.customDataUpdaters.add(updater);\n+    }\n+\n+    @Override\n+    public <T extends DataSerializable> Optional<DataContentUpdater> getWrappedContentUpdater(Class<T> clazz, final int fromVersion, final int toVersion) {\n+        Preconditions.checkArgument(fromVersion != toVersion, \"Attempting to convert to the same version!\");\n+        Preconditions.checkArgument(fromVersion < toVersion, \"Attempting to backwards convert data! This isn't supported!\");\n+        final List<DataContentUpdater> updaters = this.updatersMap.get(\n+            Preconditions.checkNotNull(clazz, \"DataSerializable class was null!\"));\n+        if (updaters == null) {\n+            return Optional.empty();\n+        }\n+        return getWrappedContentUpdater(clazz, fromVersion, toVersion, updaters);\n+    }\n+\n+    private static Optional<DataContentUpdater> getWrappedContentUpdater(Class<?> clazz, int fromVersion, int toVersion, List<DataContentUpdater> updaters) {\n+        ImmutableList.Builder<DataContentUpdater> builder = ImmutableList.builder();\n+        int version = fromVersion;\n+        for (DataContentUpdater updater : updaters) {\n+            if (updater.getInputVersion() == version) {\n+                if (updater.getOutputVersion() > toVersion) {\n+                    continue;\n+                }\n+                version = updater.getOutputVersion();\n+                builder.add(updater);\n+            }\n+        }\n+        if (version < toVersion || version > toVersion) { // There wasn't a registered updater for the version being requested\n+            Exception e = new IllegalStateException(\"The requested content version for: \" + clazz.getSimpleName() + \" was requested, \"\n+                                                    + \"\\nhowever, the versions supplied: from \"+ fromVersion + \" to \" + toVersion + \" is impossible\"\n+                                                    + \"\\nas the latest version registered is: \" + version+\". Please notify the developer of\"\n+                                                    + \"\\nthe requested consumed DataSerializable of this error.\");\n+            e.printStackTrace();\n+            return Optional.empty();\n+        }\n+        return Optional.of(new DataUpdaterDelegate(builder.build(), fromVersion, toVersion));\n+    }\n+\n+    @Override\n+    @SuppressWarnings({\"unchecked\"})\n+    public <T extends DataSerializable> Optional<DataBuilder<T>> getBuilder(Class<T> clazz) {\n+        Preconditions.checkNotNull(clazz);\n+        if (this.builders.containsKey(clazz)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f3c98dd27204e8181525d92c657a099855405c42"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0MjQ2Mw==", "bodyText": "You can replace contains + put with putIfAbsent and check the return value", "url": "https://github.com/SpongePowered/Sponge/pull/2620#discussion_r429542463", "createdAt": "2020-05-23T12:36:58Z", "author": {"login": "ImMorpheus"}, "path": "src/main/java/org/spongepowered/common/data/SpongeDataManager.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * This file is part of Sponge, licensed under the MIT License (MIT).\n+ *\n+ * Copyright (c) SpongePowered <https://www.spongepowered.org>\n+ * Copyright (c) contributors\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.spongepowered.common.data;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.MapMaker;\n+import com.google.common.collect.Maps;\n+import com.google.common.reflect.TypeToken;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+import net.minecraft.nbt.CompoundNBT;\n+import net.minecraft.nbt.INBT;\n+import net.minecraft.nbt.ListNBT;\n+import net.minecraft.util.registry.Registry;\n+import ninja.leaping.configurate.objectmapping.serialize.TypeSerializers;\n+import org.spongepowered.api.CatalogKey;\n+import org.spongepowered.api.CatalogType;\n+import org.spongepowered.api.data.DataHolder;\n+import org.spongepowered.api.data.DataHolderBuilder;\n+import org.spongepowered.api.data.DataManager;\n+import org.spongepowered.api.data.DataManipulator;\n+import org.spongepowered.api.data.DataManipulator.Mutable;\n+import org.spongepowered.api.data.DataProvider;\n+import org.spongepowered.api.data.DataRegistration;\n+import org.spongepowered.api.data.Key;\n+import org.spongepowered.api.data.persistence.AbstractDataBuilder;\n+import org.spongepowered.api.data.persistence.DataBuilder;\n+import org.spongepowered.api.data.persistence.DataContainer;\n+import org.spongepowered.api.data.persistence.DataContentUpdater;\n+import org.spongepowered.api.data.persistence.DataSerializable;\n+import org.spongepowered.api.data.persistence.DataStore;\n+import org.spongepowered.api.data.persistence.DataTranslator;\n+import org.spongepowered.api.data.persistence.DataView;\n+import org.spongepowered.api.data.persistence.Queries;\n+import org.spongepowered.api.plugin.PluginContainer;\n+import org.spongepowered.common.SpongeImpl;\n+import org.spongepowered.common.bridge.data.CustomDataHolderBridge;\n+import org.spongepowered.common.config.DataSerializableTypeSerializer;\n+import org.spongepowered.common.data.persistence.NbtTranslator;\n+import org.spongepowered.common.registry.MappedRegistry;\n+import org.spongepowered.common.registry.SpongeCatalogRegistry;\n+import org.spongepowered.common.util.Constants;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+@Singleton\n+public final class SpongeDataManager implements DataManager {\n+    private static final SpongeDataManager INSTANCE = new SpongeDataManager();\n+\n+    private static final TypeToken<CatalogType> catalogTypeToken = TypeToken.of(CatalogType.class);\n+    private static final TypeToken<DataSerializable> dataSerializableTypeToken = TypeToken.of(DataSerializable.class);\n+\n+    static {\n+        TypeSerializers.getDefaultSerializers().registerPredicate(\n+            // We have a separate type serializer for CatalogTypes, so we explicitly discount them here.\n+            // See https://github.com/SpongePowered/SpongeCommon/issues/1348\n+            x -> dataSerializableTypeToken.isSupertypeOf(x) && !catalogTypeToken.isSupertypeOf(x), new DataSerializableTypeSerializer()\n+        );\n+    }\n+\n+    // Builders\n+    private final Map<Class<?>, DataBuilder<?>> builders = Maps.newHashMap();\n+\n+\n+    private final Map<Class<? extends DataHolder.Immutable<?>>, DataHolderBuilder.Immutable<?, ?>> immutableDataBuilderMap = new MapMaker()\n+        .concurrencyLevel(4)\n+        .makeMap();\n+    // Content updaters\n+    private final Map<Class<? extends DataSerializable>, List<DataContentUpdater>> updatersMap = new IdentityHashMap<>();\n+\n+\n+    static boolean allowRegistrations = true;\n+    private List<DataContentUpdater> customDataUpdaters = new ArrayList<>();\n+\n+\n+    public static SpongeDataManager getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    @Inject\n+    private SpongeDataManager() {}\n+\n+    @Override\n+    public <T extends DataSerializable> void registerBuilder(Class<T> clazz, DataBuilder<T> builder) {\n+        Preconditions.checkNotNull(clazz);\n+        Preconditions.checkNotNull(builder);\n+        if (!this.builders.containsKey(clazz)) {\n+            if (!(builder instanceof AbstractDataBuilder)) {\n+                SpongeImpl.getLogger().warn(\"A custom DataBuilder is not extending AbstractDataBuilder! It is recommended that \"\n+                                            + \"the custom data builder does extend it to gain automated content versioning updates and maintain \"\n+                                            + \"simplicity. The offending builder's class is: {}\", builder.getClass());\n+            }\n+            this.builders.put(clazz, builder);\n+        } else {\n+            SpongeImpl.getLogger().warn(\"A DataBuilder has already been registered for {}. Attempted to register {} instead.\", clazz,\n+                    builder.getClass());\n+        }\n+    }\n+\n+    @Override\n+    public <T extends DataSerializable> void registerContentUpdater(Class<T> clazz, DataContentUpdater updater) {\n+        Preconditions.checkNotNull(updater, \"DataContentUpdater was null!\");\n+        if (!this.updatersMap.containsKey(Preconditions.checkNotNull(clazz, \"DataSerializable class was null!\"))) {\n+            this.updatersMap.put(clazz, new ArrayList<>());\n+        }\n+        final List<DataContentUpdater> updaters = this.updatersMap.get(clazz);\n+        updaters.add(updater);\n+        Collections.sort(updaters, Constants.Functional.DATA_CONTENT_UPDATER_COMPARATOR);\n+    }\n+\n+    public void registerCustomDataContentUpdater(DataContentUpdater updater) {\n+        this.customDataUpdaters.add(updater);\n+    }\n+\n+    @Override\n+    public <T extends DataSerializable> Optional<DataContentUpdater> getWrappedContentUpdater(Class<T> clazz, final int fromVersion, final int toVersion) {\n+        Preconditions.checkArgument(fromVersion != toVersion, \"Attempting to convert to the same version!\");\n+        Preconditions.checkArgument(fromVersion < toVersion, \"Attempting to backwards convert data! This isn't supported!\");\n+        final List<DataContentUpdater> updaters = this.updatersMap.get(\n+            Preconditions.checkNotNull(clazz, \"DataSerializable class was null!\"));\n+        if (updaters == null) {\n+            return Optional.empty();\n+        }\n+        return getWrappedContentUpdater(clazz, fromVersion, toVersion, updaters);\n+    }\n+\n+    private static Optional<DataContentUpdater> getWrappedContentUpdater(Class<?> clazz, int fromVersion, int toVersion, List<DataContentUpdater> updaters) {\n+        ImmutableList.Builder<DataContentUpdater> builder = ImmutableList.builder();\n+        int version = fromVersion;\n+        for (DataContentUpdater updater : updaters) {\n+            if (updater.getInputVersion() == version) {\n+                if (updater.getOutputVersion() > toVersion) {\n+                    continue;\n+                }\n+                version = updater.getOutputVersion();\n+                builder.add(updater);\n+            }\n+        }\n+        if (version < toVersion || version > toVersion) { // There wasn't a registered updater for the version being requested\n+            Exception e = new IllegalStateException(\"The requested content version for: \" + clazz.getSimpleName() + \" was requested, \"\n+                                                    + \"\\nhowever, the versions supplied: from \"+ fromVersion + \" to \" + toVersion + \" is impossible\"\n+                                                    + \"\\nas the latest version registered is: \" + version+\". Please notify the developer of\"\n+                                                    + \"\\nthe requested consumed DataSerializable of this error.\");\n+            e.printStackTrace();\n+            return Optional.empty();\n+        }\n+        return Optional.of(new DataUpdaterDelegate(builder.build(), fromVersion, toVersion));\n+    }\n+\n+    @Override\n+    @SuppressWarnings({\"unchecked\"})\n+    public <T extends DataSerializable> Optional<DataBuilder<T>> getBuilder(Class<T> clazz) {\n+        Preconditions.checkNotNull(clazz);\n+        if (this.builders.containsKey(clazz)) {\n+            return Optional.of((DataBuilder<T>) this.builders.get(clazz));\n+        } else if (this.immutableDataBuilderMap.containsKey(clazz)) {\n+            return Optional.of((DataBuilder<T>) this.immutableDataBuilderMap.get(clazz));\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    @Override\n+    public <T extends DataSerializable> Optional<T> deserialize(Class<T> clazz, final DataView dataView) {\n+        final Optional<DataBuilder<T>> optional = this.getBuilder(clazz);\n+        return optional.flatMap(tDataBuilder -> tDataBuilder.build(dataView));\n+    }\n+\n+    @Override\n+    public <T extends DataHolder.Immutable<T>, B extends DataHolderBuilder.Immutable<T, B>> void register(Class<T> holderClass, B builder) {\n+        if (!this.immutableDataBuilderMap.containsKey(Preconditions.checkNotNull(holderClass))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f3c98dd27204e8181525d92c657a099855405c42"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0MjQ3Ng==", "bodyText": "Same as above", "url": "https://github.com/SpongePowered/Sponge/pull/2620#discussion_r429542476", "createdAt": "2020-05-23T12:37:13Z", "author": {"login": "ImMorpheus"}, "path": "src/main/java/org/spongepowered/common/data/SpongeDataManager.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * This file is part of Sponge, licensed under the MIT License (MIT).\n+ *\n+ * Copyright (c) SpongePowered <https://www.spongepowered.org>\n+ * Copyright (c) contributors\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.spongepowered.common.data;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.MapMaker;\n+import com.google.common.collect.Maps;\n+import com.google.common.reflect.TypeToken;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+import net.minecraft.nbt.CompoundNBT;\n+import net.minecraft.nbt.INBT;\n+import net.minecraft.nbt.ListNBT;\n+import net.minecraft.util.registry.Registry;\n+import ninja.leaping.configurate.objectmapping.serialize.TypeSerializers;\n+import org.spongepowered.api.CatalogKey;\n+import org.spongepowered.api.CatalogType;\n+import org.spongepowered.api.data.DataHolder;\n+import org.spongepowered.api.data.DataHolderBuilder;\n+import org.spongepowered.api.data.DataManager;\n+import org.spongepowered.api.data.DataManipulator;\n+import org.spongepowered.api.data.DataManipulator.Mutable;\n+import org.spongepowered.api.data.DataProvider;\n+import org.spongepowered.api.data.DataRegistration;\n+import org.spongepowered.api.data.Key;\n+import org.spongepowered.api.data.persistence.AbstractDataBuilder;\n+import org.spongepowered.api.data.persistence.DataBuilder;\n+import org.spongepowered.api.data.persistence.DataContainer;\n+import org.spongepowered.api.data.persistence.DataContentUpdater;\n+import org.spongepowered.api.data.persistence.DataSerializable;\n+import org.spongepowered.api.data.persistence.DataStore;\n+import org.spongepowered.api.data.persistence.DataTranslator;\n+import org.spongepowered.api.data.persistence.DataView;\n+import org.spongepowered.api.data.persistence.Queries;\n+import org.spongepowered.api.plugin.PluginContainer;\n+import org.spongepowered.common.SpongeImpl;\n+import org.spongepowered.common.bridge.data.CustomDataHolderBridge;\n+import org.spongepowered.common.config.DataSerializableTypeSerializer;\n+import org.spongepowered.common.data.persistence.NbtTranslator;\n+import org.spongepowered.common.registry.MappedRegistry;\n+import org.spongepowered.common.registry.SpongeCatalogRegistry;\n+import org.spongepowered.common.util.Constants;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+@Singleton\n+public final class SpongeDataManager implements DataManager {\n+    private static final SpongeDataManager INSTANCE = new SpongeDataManager();\n+\n+    private static final TypeToken<CatalogType> catalogTypeToken = TypeToken.of(CatalogType.class);\n+    private static final TypeToken<DataSerializable> dataSerializableTypeToken = TypeToken.of(DataSerializable.class);\n+\n+    static {\n+        TypeSerializers.getDefaultSerializers().registerPredicate(\n+            // We have a separate type serializer for CatalogTypes, so we explicitly discount them here.\n+            // See https://github.com/SpongePowered/SpongeCommon/issues/1348\n+            x -> dataSerializableTypeToken.isSupertypeOf(x) && !catalogTypeToken.isSupertypeOf(x), new DataSerializableTypeSerializer()\n+        );\n+    }\n+\n+    // Builders\n+    private final Map<Class<?>, DataBuilder<?>> builders = Maps.newHashMap();\n+\n+\n+    private final Map<Class<? extends DataHolder.Immutable<?>>, DataHolderBuilder.Immutable<?, ?>> immutableDataBuilderMap = new MapMaker()\n+        .concurrencyLevel(4)\n+        .makeMap();\n+    // Content updaters\n+    private final Map<Class<? extends DataSerializable>, List<DataContentUpdater>> updatersMap = new IdentityHashMap<>();\n+\n+\n+    static boolean allowRegistrations = true;\n+    private List<DataContentUpdater> customDataUpdaters = new ArrayList<>();\n+\n+\n+    public static SpongeDataManager getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    @Inject\n+    private SpongeDataManager() {}\n+\n+    @Override\n+    public <T extends DataSerializable> void registerBuilder(Class<T> clazz, DataBuilder<T> builder) {\n+        Preconditions.checkNotNull(clazz);\n+        Preconditions.checkNotNull(builder);\n+        if (!this.builders.containsKey(clazz)) {\n+            if (!(builder instanceof AbstractDataBuilder)) {\n+                SpongeImpl.getLogger().warn(\"A custom DataBuilder is not extending AbstractDataBuilder! It is recommended that \"\n+                                            + \"the custom data builder does extend it to gain automated content versioning updates and maintain \"\n+                                            + \"simplicity. The offending builder's class is: {}\", builder.getClass());\n+            }\n+            this.builders.put(clazz, builder);\n+        } else {\n+            SpongeImpl.getLogger().warn(\"A DataBuilder has already been registered for {}. Attempted to register {} instead.\", clazz,\n+                    builder.getClass());\n+        }\n+    }\n+\n+    @Override\n+    public <T extends DataSerializable> void registerContentUpdater(Class<T> clazz, DataContentUpdater updater) {\n+        Preconditions.checkNotNull(updater, \"DataContentUpdater was null!\");\n+        if (!this.updatersMap.containsKey(Preconditions.checkNotNull(clazz, \"DataSerializable class was null!\"))) {\n+            this.updatersMap.put(clazz, new ArrayList<>());\n+        }\n+        final List<DataContentUpdater> updaters = this.updatersMap.get(clazz);\n+        updaters.add(updater);\n+        Collections.sort(updaters, Constants.Functional.DATA_CONTENT_UPDATER_COMPARATOR);\n+    }\n+\n+    public void registerCustomDataContentUpdater(DataContentUpdater updater) {\n+        this.customDataUpdaters.add(updater);\n+    }\n+\n+    @Override\n+    public <T extends DataSerializable> Optional<DataContentUpdater> getWrappedContentUpdater(Class<T> clazz, final int fromVersion, final int toVersion) {\n+        Preconditions.checkArgument(fromVersion != toVersion, \"Attempting to convert to the same version!\");\n+        Preconditions.checkArgument(fromVersion < toVersion, \"Attempting to backwards convert data! This isn't supported!\");\n+        final List<DataContentUpdater> updaters = this.updatersMap.get(\n+            Preconditions.checkNotNull(clazz, \"DataSerializable class was null!\"));\n+        if (updaters == null) {\n+            return Optional.empty();\n+        }\n+        return getWrappedContentUpdater(clazz, fromVersion, toVersion, updaters);\n+    }\n+\n+    private static Optional<DataContentUpdater> getWrappedContentUpdater(Class<?> clazz, int fromVersion, int toVersion, List<DataContentUpdater> updaters) {\n+        ImmutableList.Builder<DataContentUpdater> builder = ImmutableList.builder();\n+        int version = fromVersion;\n+        for (DataContentUpdater updater : updaters) {\n+            if (updater.getInputVersion() == version) {\n+                if (updater.getOutputVersion() > toVersion) {\n+                    continue;\n+                }\n+                version = updater.getOutputVersion();\n+                builder.add(updater);\n+            }\n+        }\n+        if (version < toVersion || version > toVersion) { // There wasn't a registered updater for the version being requested\n+            Exception e = new IllegalStateException(\"The requested content version for: \" + clazz.getSimpleName() + \" was requested, \"\n+                                                    + \"\\nhowever, the versions supplied: from \"+ fromVersion + \" to \" + toVersion + \" is impossible\"\n+                                                    + \"\\nas the latest version registered is: \" + version+\". Please notify the developer of\"\n+                                                    + \"\\nthe requested consumed DataSerializable of this error.\");\n+            e.printStackTrace();\n+            return Optional.empty();\n+        }\n+        return Optional.of(new DataUpdaterDelegate(builder.build(), fromVersion, toVersion));\n+    }\n+\n+    @Override\n+    @SuppressWarnings({\"unchecked\"})\n+    public <T extends DataSerializable> Optional<DataBuilder<T>> getBuilder(Class<T> clazz) {\n+        Preconditions.checkNotNull(clazz);\n+        if (this.builders.containsKey(clazz)) {\n+            return Optional.of((DataBuilder<T>) this.builders.get(clazz));\n+        } else if (this.immutableDataBuilderMap.containsKey(clazz)) {\n+            return Optional.of((DataBuilder<T>) this.immutableDataBuilderMap.get(clazz));\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    @Override\n+    public <T extends DataSerializable> Optional<T> deserialize(Class<T> clazz, final DataView dataView) {\n+        final Optional<DataBuilder<T>> optional = this.getBuilder(clazz);\n+        return optional.flatMap(tDataBuilder -> tDataBuilder.build(dataView));\n+    }\n+\n+    @Override\n+    public <T extends DataHolder.Immutable<T>, B extends DataHolderBuilder.Immutable<T, B>> void register(Class<T> holderClass, B builder) {\n+        if (!this.immutableDataBuilderMap.containsKey(Preconditions.checkNotNull(holderClass))) {\n+            this.immutableDataBuilderMap.put(holderClass, Preconditions.checkNotNull(builder));\n+        } else {\n+            throw new IllegalStateException(\"Already registered the DataUtil for \" + holderClass.getCanonicalName());\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <T extends DataHolder.Immutable<T>, B extends DataHolderBuilder.Immutable<T, B>> Optional<B> getImmutableBuilder(Class<T> holderClass) {\n+        return Optional.ofNullable((B) this.immutableDataBuilderMap.get(Preconditions.checkNotNull(holderClass)));\n+    }\n+\n+    public static void finalizeRegistration() {\n+        allowRegistrations = false;\n+        registerKeyListeners();\n+    }\n+\n+    @Override\n+    public void registerLegacyManipulatorIds(String legacyId, DataRegistration registration) {\n+        Preconditions.checkState(allowRegistrations);\n+        if (this.legacyRegistrations.containsKey(legacyId)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f3c98dd27204e8181525d92c657a099855405c42"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0MjU3MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final Map<PluginContainer, List<SpongeDataRegistration>> pluginRegistrations = new HashMap<>();\n          \n          \n            \n                private final Map<PluginContainer, List<SpongeDataRegistration>> pluginRegistrations = new IdentityHashMap<>();", "url": "https://github.com/SpongePowered/Sponge/pull/2620#discussion_r429542570", "createdAt": "2020-05-23T12:38:09Z", "author": {"login": "ImMorpheus"}, "path": "src/main/java/org/spongepowered/common/data/SpongeDataManager.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * This file is part of Sponge, licensed under the MIT License (MIT).\n+ *\n+ * Copyright (c) SpongePowered <https://www.spongepowered.org>\n+ * Copyright (c) contributors\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.spongepowered.common.data;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.MapMaker;\n+import com.google.common.collect.Maps;\n+import com.google.common.reflect.TypeToken;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+import net.minecraft.nbt.CompoundNBT;\n+import net.minecraft.nbt.INBT;\n+import net.minecraft.nbt.ListNBT;\n+import net.minecraft.util.registry.Registry;\n+import ninja.leaping.configurate.objectmapping.serialize.TypeSerializers;\n+import org.spongepowered.api.CatalogKey;\n+import org.spongepowered.api.CatalogType;\n+import org.spongepowered.api.data.DataHolder;\n+import org.spongepowered.api.data.DataHolderBuilder;\n+import org.spongepowered.api.data.DataManager;\n+import org.spongepowered.api.data.DataManipulator;\n+import org.spongepowered.api.data.DataManipulator.Mutable;\n+import org.spongepowered.api.data.DataProvider;\n+import org.spongepowered.api.data.DataRegistration;\n+import org.spongepowered.api.data.Key;\n+import org.spongepowered.api.data.persistence.AbstractDataBuilder;\n+import org.spongepowered.api.data.persistence.DataBuilder;\n+import org.spongepowered.api.data.persistence.DataContainer;\n+import org.spongepowered.api.data.persistence.DataContentUpdater;\n+import org.spongepowered.api.data.persistence.DataSerializable;\n+import org.spongepowered.api.data.persistence.DataStore;\n+import org.spongepowered.api.data.persistence.DataTranslator;\n+import org.spongepowered.api.data.persistence.DataView;\n+import org.spongepowered.api.data.persistence.Queries;\n+import org.spongepowered.api.plugin.PluginContainer;\n+import org.spongepowered.common.SpongeImpl;\n+import org.spongepowered.common.bridge.data.CustomDataHolderBridge;\n+import org.spongepowered.common.config.DataSerializableTypeSerializer;\n+import org.spongepowered.common.data.persistence.NbtTranslator;\n+import org.spongepowered.common.registry.MappedRegistry;\n+import org.spongepowered.common.registry.SpongeCatalogRegistry;\n+import org.spongepowered.common.util.Constants;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+@Singleton\n+public final class SpongeDataManager implements DataManager {\n+    private static final SpongeDataManager INSTANCE = new SpongeDataManager();\n+\n+    private static final TypeToken<CatalogType> catalogTypeToken = TypeToken.of(CatalogType.class);\n+    private static final TypeToken<DataSerializable> dataSerializableTypeToken = TypeToken.of(DataSerializable.class);\n+\n+    static {\n+        TypeSerializers.getDefaultSerializers().registerPredicate(\n+            // We have a separate type serializer for CatalogTypes, so we explicitly discount them here.\n+            // See https://github.com/SpongePowered/SpongeCommon/issues/1348\n+            x -> dataSerializableTypeToken.isSupertypeOf(x) && !catalogTypeToken.isSupertypeOf(x), new DataSerializableTypeSerializer()\n+        );\n+    }\n+\n+    // Builders\n+    private final Map<Class<?>, DataBuilder<?>> builders = Maps.newHashMap();\n+\n+\n+    private final Map<Class<? extends DataHolder.Immutable<?>>, DataHolderBuilder.Immutable<?, ?>> immutableDataBuilderMap = new MapMaker()\n+        .concurrencyLevel(4)\n+        .makeMap();\n+    // Content updaters\n+    private final Map<Class<? extends DataSerializable>, List<DataContentUpdater>> updatersMap = new IdentityHashMap<>();\n+\n+\n+    static boolean allowRegistrations = true;\n+    private List<DataContentUpdater> customDataUpdaters = new ArrayList<>();\n+\n+\n+    public static SpongeDataManager getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    @Inject\n+    private SpongeDataManager() {}\n+\n+    @Override\n+    public <T extends DataSerializable> void registerBuilder(Class<T> clazz, DataBuilder<T> builder) {\n+        Preconditions.checkNotNull(clazz);\n+        Preconditions.checkNotNull(builder);\n+        if (!this.builders.containsKey(clazz)) {\n+            if (!(builder instanceof AbstractDataBuilder)) {\n+                SpongeImpl.getLogger().warn(\"A custom DataBuilder is not extending AbstractDataBuilder! It is recommended that \"\n+                                            + \"the custom data builder does extend it to gain automated content versioning updates and maintain \"\n+                                            + \"simplicity. The offending builder's class is: {}\", builder.getClass());\n+            }\n+            this.builders.put(clazz, builder);\n+        } else {\n+            SpongeImpl.getLogger().warn(\"A DataBuilder has already been registered for {}. Attempted to register {} instead.\", clazz,\n+                    builder.getClass());\n+        }\n+    }\n+\n+    @Override\n+    public <T extends DataSerializable> void registerContentUpdater(Class<T> clazz, DataContentUpdater updater) {\n+        Preconditions.checkNotNull(updater, \"DataContentUpdater was null!\");\n+        if (!this.updatersMap.containsKey(Preconditions.checkNotNull(clazz, \"DataSerializable class was null!\"))) {\n+            this.updatersMap.put(clazz, new ArrayList<>());\n+        }\n+        final List<DataContentUpdater> updaters = this.updatersMap.get(clazz);\n+        updaters.add(updater);\n+        Collections.sort(updaters, Constants.Functional.DATA_CONTENT_UPDATER_COMPARATOR);\n+    }\n+\n+    public void registerCustomDataContentUpdater(DataContentUpdater updater) {\n+        this.customDataUpdaters.add(updater);\n+    }\n+\n+    @Override\n+    public <T extends DataSerializable> Optional<DataContentUpdater> getWrappedContentUpdater(Class<T> clazz, final int fromVersion, final int toVersion) {\n+        Preconditions.checkArgument(fromVersion != toVersion, \"Attempting to convert to the same version!\");\n+        Preconditions.checkArgument(fromVersion < toVersion, \"Attempting to backwards convert data! This isn't supported!\");\n+        final List<DataContentUpdater> updaters = this.updatersMap.get(\n+            Preconditions.checkNotNull(clazz, \"DataSerializable class was null!\"));\n+        if (updaters == null) {\n+            return Optional.empty();\n+        }\n+        return getWrappedContentUpdater(clazz, fromVersion, toVersion, updaters);\n+    }\n+\n+    private static Optional<DataContentUpdater> getWrappedContentUpdater(Class<?> clazz, int fromVersion, int toVersion, List<DataContentUpdater> updaters) {\n+        ImmutableList.Builder<DataContentUpdater> builder = ImmutableList.builder();\n+        int version = fromVersion;\n+        for (DataContentUpdater updater : updaters) {\n+            if (updater.getInputVersion() == version) {\n+                if (updater.getOutputVersion() > toVersion) {\n+                    continue;\n+                }\n+                version = updater.getOutputVersion();\n+                builder.add(updater);\n+            }\n+        }\n+        if (version < toVersion || version > toVersion) { // There wasn't a registered updater for the version being requested\n+            Exception e = new IllegalStateException(\"The requested content version for: \" + clazz.getSimpleName() + \" was requested, \"\n+                                                    + \"\\nhowever, the versions supplied: from \"+ fromVersion + \" to \" + toVersion + \" is impossible\"\n+                                                    + \"\\nas the latest version registered is: \" + version+\". Please notify the developer of\"\n+                                                    + \"\\nthe requested consumed DataSerializable of this error.\");\n+            e.printStackTrace();\n+            return Optional.empty();\n+        }\n+        return Optional.of(new DataUpdaterDelegate(builder.build(), fromVersion, toVersion));\n+    }\n+\n+    @Override\n+    @SuppressWarnings({\"unchecked\"})\n+    public <T extends DataSerializable> Optional<DataBuilder<T>> getBuilder(Class<T> clazz) {\n+        Preconditions.checkNotNull(clazz);\n+        if (this.builders.containsKey(clazz)) {\n+            return Optional.of((DataBuilder<T>) this.builders.get(clazz));\n+        } else if (this.immutableDataBuilderMap.containsKey(clazz)) {\n+            return Optional.of((DataBuilder<T>) this.immutableDataBuilderMap.get(clazz));\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    @Override\n+    public <T extends DataSerializable> Optional<T> deserialize(Class<T> clazz, final DataView dataView) {\n+        final Optional<DataBuilder<T>> optional = this.getBuilder(clazz);\n+        return optional.flatMap(tDataBuilder -> tDataBuilder.build(dataView));\n+    }\n+\n+    @Override\n+    public <T extends DataHolder.Immutable<T>, B extends DataHolderBuilder.Immutable<T, B>> void register(Class<T> holderClass, B builder) {\n+        if (!this.immutableDataBuilderMap.containsKey(Preconditions.checkNotNull(holderClass))) {\n+            this.immutableDataBuilderMap.put(holderClass, Preconditions.checkNotNull(builder));\n+        } else {\n+            throw new IllegalStateException(\"Already registered the DataUtil for \" + holderClass.getCanonicalName());\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <T extends DataHolder.Immutable<T>, B extends DataHolderBuilder.Immutable<T, B>> Optional<B> getImmutableBuilder(Class<T> holderClass) {\n+        return Optional.ofNullable((B) this.immutableDataBuilderMap.get(Preconditions.checkNotNull(holderClass)));\n+    }\n+\n+    public static void finalizeRegistration() {\n+        allowRegistrations = false;\n+        registerKeyListeners();\n+    }\n+\n+    @Override\n+    public void registerLegacyManipulatorIds(String legacyId, DataRegistration registration) {\n+        Preconditions.checkState(allowRegistrations);\n+        if (this.legacyRegistrations.containsKey(legacyId)) {\n+            throw new IllegalStateException(\"Legacy registration id already registered: id\" + legacyId + \" for registration: \" + registration);\n+        }\n+        this.legacyRegistrations.put(legacyId, (SpongeDataRegistration) registration);\n+    }\n+\n+    public Optional<DataRegistration> getRegistrationForLegacyId(String id) {\n+        return Optional.ofNullable(this.legacyRegistrations.get(id));\n+    }\n+\n+    @SuppressWarnings(value = {\"unchecked\", \"rawtypes\"})\n+    @Override\n+    public <T> Optional<DataTranslator<T>> getTranslator(Class<T> objectClass) {\n+        final Registry<DataTranslator> registry = SpongeImpl.getRegistry().getCatalogRegistry().getRegistry(DataTranslator.class);\n+        final DataTranslator reverseMapping = ((MappedRegistry<DataTranslator, Class>) registry).getReverseMapping(objectClass);\n+        return Optional.ofNullable(reverseMapping);\n+    }\n+\n+    @Override\n+    public Collection<DataRegistration> getAllRegistrationsFor(PluginContainer container) {\n+\n+        return Collections.unmodifiableCollection(this.pluginRegistrations.getOrDefault(container, Collections.emptyList()));\n+    }\n+\n+    @Override\n+    public DataContainer createContainer() {\n+        return new MemoryDataContainer();\n+    }\n+\n+    @Override\n+    public DataContainer createContainer(DataView.SafetyMode safety) {\n+        return new MemoryDataContainer(safety);\n+    }\n+\n+    void validateRegistration(SpongeDataRegistration registration) {\n+        Preconditions.checkState(allowRegistrations);\n+\n+        CatalogKey key = registration.key;\n+        PluginContainer plugin = registration.plugin;\n+\n+        Map<Key, DataProvider> dataProviderMap = registration.dataProviderMap;\n+        Map<TypeToken, DataStore> dataStoreMap = registration.dataStoreMap;\n+        List<Key<?>> keys = registration.keys;\n+\n+        // TODO\n+    }\n+\n+    public static boolean areRegistrationsComplete() {\n+        return !allowRegistrations;\n+    }\n+\n+    private final Map<PluginContainer, List<SpongeDataRegistration>> pluginRegistrations = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f3c98dd27204e8181525d92c657a099855405c42"}, "originalPosition": 273}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0MjcwNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Map<TypeToken, DataStore> dataStoreMap = new HashMap<>();\n          \n          \n            \n                Map<TypeToken, DataStore> dataStoreMap = new IdentityHashMap<>();", "url": "https://github.com/SpongePowered/Sponge/pull/2620#discussion_r429542704", "createdAt": "2020-05-23T12:40:27Z", "author": {"login": "ImMorpheus"}, "path": "src/main/java/org/spongepowered/common/data/SpongeDataRegistrationBuilder.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * This file is part of Sponge, licensed under the MIT License (MIT).\n+ *\n+ * Copyright (c) SpongePowered <https://www.spongepowered.org>\n+ * Copyright (c) contributors\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.spongepowered.common.data;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.reflect.TypeToken;\n+import org.spongepowered.api.CatalogKey;\n+import org.spongepowered.api.data.DataProvider;\n+import org.spongepowered.api.data.DataRegistration;\n+import org.spongepowered.api.data.DuplicateDataStoreException;\n+import org.spongepowered.api.data.DuplicateProviderException;\n+import org.spongepowered.api.data.Key;\n+import org.spongepowered.api.data.persistence.DataStore;\n+import org.spongepowered.common.SpongeImplHooks;\n+import org.spongepowered.common.util.SpongeCatalogBuilder;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public final class SpongeDataRegistrationBuilder extends SpongeCatalogBuilder<DataRegistration, DataRegistration.Builder> implements DataRegistration.Builder{\n+\n+    Map<Key, DataProvider> dataProviderMap = new HashMap<>();\n+    Map<TypeToken, DataStore> dataStoreMap = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f3c98dd27204e8181525d92c657a099855405c42"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0Mjg0Mw==", "bodyText": "Collections#addAll", "url": "https://github.com/SpongePowered/Sponge/pull/2620#discussion_r429542843", "createdAt": "2020-05-23T12:41:49Z", "author": {"login": "ImMorpheus"}, "path": "src/main/java/org/spongepowered/common/data/SpongeDataRegistrationBuilder.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * This file is part of Sponge, licensed under the MIT License (MIT).\n+ *\n+ * Copyright (c) SpongePowered <https://www.spongepowered.org>\n+ * Copyright (c) contributors\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.spongepowered.common.data;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.reflect.TypeToken;\n+import org.spongepowered.api.CatalogKey;\n+import org.spongepowered.api.data.DataProvider;\n+import org.spongepowered.api.data.DataRegistration;\n+import org.spongepowered.api.data.DuplicateDataStoreException;\n+import org.spongepowered.api.data.DuplicateProviderException;\n+import org.spongepowered.api.data.Key;\n+import org.spongepowered.api.data.persistence.DataStore;\n+import org.spongepowered.common.SpongeImplHooks;\n+import org.spongepowered.common.util.SpongeCatalogBuilder;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public final class SpongeDataRegistrationBuilder extends SpongeCatalogBuilder<DataRegistration, DataRegistration.Builder> implements DataRegistration.Builder{\n+\n+    Map<Key, DataProvider> dataProviderMap = new HashMap<>();\n+    Map<TypeToken, DataStore> dataStoreMap = new HashMap<>();\n+    List<Key<?>> keys = new ArrayList<>();\n+\n+    @Override\n+    public DataRegistration.Builder store(DataStore store) throws DuplicateDataStoreException {\n+        this.dataStoreMap.put(store.getSupportedToken(), store);\n+        return this;\n+    }\n+\n+    @Override\n+    public DataRegistration.Builder provider(DataProvider<?, ?> provider) throws DuplicateProviderException {\n+        this.dataProviderMap.put(provider.getKey(), provider);\n+        return this;\n+    }\n+\n+    @Override\n+    public DataRegistration.Builder key(Key<?> key) {\n+        this.keys.add(key);\n+        return this;\n+    }\n+\n+    @Override\n+    public DataRegistration.Builder key(Key<?> key, Key<?>... others) {\n+        this.keys.add(key);\n+        this.keys.addAll(Arrays.asList(others));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f3c98dd27204e8181525d92c657a099855405c42"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0Mjg2MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.dataStoreMap = new HashMap<>();\n          \n          \n            \n                    this.dataStoreMap = new IdentityHashMap<>();", "url": "https://github.com/SpongePowered/Sponge/pull/2620#discussion_r429542860", "createdAt": "2020-05-23T12:42:03Z", "author": {"login": "ImMorpheus"}, "path": "src/main/java/org/spongepowered/common/data/SpongeDataRegistrationBuilder.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * This file is part of Sponge, licensed under the MIT License (MIT).\n+ *\n+ * Copyright (c) SpongePowered <https://www.spongepowered.org>\n+ * Copyright (c) contributors\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.spongepowered.common.data;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.reflect.TypeToken;\n+import org.spongepowered.api.CatalogKey;\n+import org.spongepowered.api.data.DataProvider;\n+import org.spongepowered.api.data.DataRegistration;\n+import org.spongepowered.api.data.DuplicateDataStoreException;\n+import org.spongepowered.api.data.DuplicateProviderException;\n+import org.spongepowered.api.data.Key;\n+import org.spongepowered.api.data.persistence.DataStore;\n+import org.spongepowered.common.SpongeImplHooks;\n+import org.spongepowered.common.util.SpongeCatalogBuilder;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public final class SpongeDataRegistrationBuilder extends SpongeCatalogBuilder<DataRegistration, DataRegistration.Builder> implements DataRegistration.Builder{\n+\n+    Map<Key, DataProvider> dataProviderMap = new HashMap<>();\n+    Map<TypeToken, DataStore> dataStoreMap = new HashMap<>();\n+    List<Key<?>> keys = new ArrayList<>();\n+\n+    @Override\n+    public DataRegistration.Builder store(DataStore store) throws DuplicateDataStoreException {\n+        this.dataStoreMap.put(store.getSupportedToken(), store);\n+        return this;\n+    }\n+\n+    @Override\n+    public DataRegistration.Builder provider(DataProvider<?, ?> provider) throws DuplicateProviderException {\n+        this.dataProviderMap.put(provider.getKey(), provider);\n+        return this;\n+    }\n+\n+    @Override\n+    public DataRegistration.Builder key(Key<?> key) {\n+        this.keys.add(key);\n+        return this;\n+    }\n+\n+    @Override\n+    public DataRegistration.Builder key(Key<?> key, Key<?>... others) {\n+        this.keys.add(key);\n+        this.keys.addAll(Arrays.asList(others));\n+        return this;\n+    }\n+\n+    @Override\n+    public DataRegistration.Builder key(Iterable<Key<?>> keys) {\n+        keys.forEach(this.keys::add);\n+        return this;\n+    }\n+\n+    @Override\n+    protected DataRegistration build(CatalogKey key) {\n+        // TODO restrictions?\n+        return new SpongeDataRegistration(key, SpongeImplHooks.getActiveModContainer(), this);\n+    }\n+\n+    @Override\n+    public SpongeDataRegistrationBuilder reset() {\n+        super.reset();\n+        this.dataProviderMap = new HashMap<>();\n+        this.dataStoreMap = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f3c98dd27204e8181525d92c657a099855405c42"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0MzExNA==", "bodyText": "Replace get + put with computeIfAbsent", "url": "https://github.com/SpongePowered/Sponge/pull/2620#discussion_r429543114", "createdAt": "2020-05-23T12:45:23Z", "author": {"login": "ImMorpheus"}, "path": "src/main/java/org/spongepowered/common/registry/SpongeCatalogRegistry.java", "diffHunk": "@@ -302,6 +308,22 @@ public SpongeCatalogRegistry registerRegistry(Class<CatalogType> catalogClass, C\n         return this;\n     }\n \n+    private <T extends CatalogType> SpongeCatalogRegistry registerCallbackRegistry(Class<T> catalogClass, CatalogKey key, BiConsumer<ResourceLocation, T> callback) {\n+        checkNotNull(catalogClass);\n+        checkNotNull(key);\n+\n+        if (this.registries.get(key) != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f3c98dd27204e8181525d92c657a099855405c42"}, "originalPosition": 35}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9f4bb8fa5012a990cd9592a10ed2cca8135f35a5", "author": {"user": {"login": "Faithcaio", "name": "Faithcaio"}}, "url": "https://github.com/SpongePowered/Sponge/commit/9f4bb8fa5012a990cd9592a10ed2cca8135f35a5", "committedDate": "2020-05-23T14:13:22Z", "message": "comments"}, "afterCommit": {"oid": "d453bc0329726c53176b029cfa5c7d29eca13dbe", "author": {"user": {"login": "Faithcaio", "name": "Faithcaio"}}, "url": "https://github.com/SpongePowered/Sponge/commit/d453bc0329726c53176b029cfa5c7d29eca13dbe", "committedDate": "2020-05-23T19:06:54Z", "message": "comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1849345bb44af620308c36a4cb1f90cfaf9add1d", "author": {"user": {"login": "Faithcaio", "name": "Faithcaio"}}, "url": "https://github.com/SpongePowered/Sponge/commit/1849345bb44af620308c36a4cb1f90cfaf9add1d", "committedDate": "2020-05-24T07:29:06Z", "message": "move stuff back from invalid"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb7acdb7d2e7bef817f8439638330df6ccd30bf5", "author": {"user": {"login": "Faithcaio", "name": "Faithcaio"}}, "url": "https://github.com/SpongePowered/Sponge/commit/bb7acdb7d2e7bef817f8439638330df6ccd30bf5", "committedDate": "2020-05-24T07:32:33Z", "message": "implement custom data"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "accf6b84ce69209969e2402ae755d1dcf2b60bb5", "author": {"user": {"login": "Faithcaio", "name": "Faithcaio"}}, "url": "https://github.com/SpongePowered/Sponge/commit/accf6b84ce69209969e2402ae755d1dcf2b60bb5", "committedDate": "2020-05-24T07:33:34Z", "message": "keylistener"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "005b98dc98d823e7ea2d685952cd015be7ef04e2", "author": {"user": {"login": "Faithcaio", "name": "Faithcaio"}}, "url": "https://github.com/SpongePowered/Sponge/commit/005b98dc98d823e7ea2d685952cd015be7ef04e2", "committedDate": "2020-05-23T21:55:11Z", "message": "key listeners and data fixers"}, "afterCommit": {"oid": "accf6b84ce69209969e2402ae755d1dcf2b60bb5", "author": {"user": {"login": "Faithcaio", "name": "Faithcaio"}}, "url": "https://github.com/SpongePowered/Sponge/commit/accf6b84ce69209969e2402ae755d1dcf2b60bb5", "committedDate": "2020-05-24T07:33:34Z", "message": "keylistener"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 914, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}