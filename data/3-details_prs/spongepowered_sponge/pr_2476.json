{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYxODExNzYz", "number": 2476, "title": "PhaseTracker 1.14 Upgrade", "bodyText": "This leaves a lot to be desired currently as it's a WIP.\nWhat's the update?\nThe PhaseTracker is essentially an adaptation of pairing server-focused changes occurring in a World to an Event factory with specific Cause population based on the processing of a IPhaseState. If that's enough to make you ask \"huh??\" then it might be recommended to read a little bit about Events and their causes. The PhaseTracker is a wedged implementation of logging BlockState, BlockEntity, Entity, and ItemStack changes within a World during specific operations, such as:\n\nAn Entity performing work during a Game tick\nA Player interacting with a block\nA Block \"growing\" into a different Block\netc.\n\nBecause of how intrinsically \"wired\" the system is to the engine, it needs hooks in various areas of the Game logic to say \"hey, we're gonna be ticking an Entity here!\" Currently, for stable-7 or Minecraft 1.12, it's doing this mostly well (sans some incompatibility with some mods and their design, no fault of theirs, just differences in how the system needs to be improved), but as it's shown, it's still very much tied to the game's core logic.\nOk, so update the hooks then?\nOf course! How could I be so blind! Just update the tens of thousands of lines that make the system... Ok, it's not really tens of thousands, it's closer to maybe 20k, but short of the hooks, the actual logic processes need to be reviewed and re-analyzed with caution since 1.14's block logic has changed enough that some parts of the system are needing to be re-engineered.\nCore concepts of the Update\nPhaseTracker per Thread\nWith the PhaseTracker being so integral to many systems in the game logic, and to support client sided effects and events, along with asynchronous world generation events, the PhaseTracker is redesigned to have two primary instances (CLIENT and SERVER) while the purposed getInstance() will return a Thread appropriate variant. Because of this, we'll be able to appropriately associate individual PhaseTrackers to pooled PhaseContexts via PooledPhaseState. What this means is that the pools of recycled contexts will be per-thread, and furthermore be sanity checked to the PhaseTracker instance that created them. Uniquely, this will sanity check closures of PhaseContexts to avoid asynchronous closures without knowing which thread originally entered said state.\nSplitting the PhaseTracker associated code from all Mixins into a separate package\nThis is mostly an organizational effort to verify \"who does what and why\". When looking at WorldServerMixin, it's difficult to read as to what this method is doing and why, except that it's interacting with a \"proxy\" for some reason. This, on top of several scattered areas where we have PhaseState entries, it becomes difficult to see what sections of code are to support the PhaseTracker, using the PhaseTracker for context population, or simply using the PhaseTracker for throwing events. Lastly, because testing of Sponge code without the PhaseTracker involvement and possible bugs/side effects, there's no \"switch\" to flip, except by removing the main hooks and hoping nothing else breaks in the process of those missing hooks.\nLikewise, because the injections/redirects/etc. would now be in a separate Mixin bundle, we can too prefix those with tracker$ to further identify what methods are coming from where.\nSo here's a laundry list of things I need to have done for the update:\n\n Update BlockTransaction to keep track of neighbor \"shape updates\" being requested, etc.\n Update SpongeBlockProxy to be a simplified IWorld proxy so fewer mixins have to exist\nThis is up for debate, and only possible in 1.13+ because of the introduction of the super interface. Since we can implement IWorld, the contracts for various block methods only actually require an IWorld instance, allowing us to better track changes and TileEntity additions.\n Review whether there's enough \"hooks\" in some mixins to split out into another mixing package/plugin\nThis would theoretically allow us to entirely disable the PhaseTracker without disabling events being thrown\nWe'd be able to improve visibility of what mixins/injections are for what purpose, when some are stubs or proxy-related injections.\n Review BlockChangeFlag API exposure, we have a bit we can expand on for better plugin control", "createdAt": "2020-01-12T09:38:24Z", "url": "https://github.com/SpongePowered/Sponge/pull/2476", "merged": true, "mergeCommit": {"oid": "4a68ea25002cd40d42cebba8178bb61096223ec1"}, "closed": true, "closedAt": "2020-02-02T16:54:41Z", "author": {"login": "gabizou"}, "timelineItems": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb5OtLnAH2gAyMzYxODExNzYzOjA5NDEyZDcwODViM2QxMmEzMzJhNjg3ZGEyMGM1MWRjMWU4MTAzNWI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb7yn_uAH2gAyMzYxODExNzYzOjRhNjhlYTI1MDAyY2Q0MGQ0MmNlYmJhODE3OGJiNjEwOTYyMjNlYzE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "09412d7085b3d12a332a687da20c51dc1e81035b", "author": {"user": {"login": "gabizou", "name": "Gabriel Harris-Rouquette"}}, "url": "https://github.com/SpongePowered/Sponge/commit/09412d7085b3d12a332a687da20c51dc1e81035b", "committedDate": "2020-01-11T08:16:38Z", "message": "Start dicing and slicing. Lost a lot of work from a branch somewhere.\n\nSigned-off-by: Gabriel Harris-Rouquette <gabizou@me.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f4f9ed72f8babc0d4ad4f30d6d2f92444f50ffde", "author": {"user": {"login": "gabizou", "name": "Gabriel Harris-Rouquette"}}, "url": "https://github.com/SpongePowered/Sponge/commit/f4f9ed72f8babc0d4ad4f30d6d2f92444f50ffde", "committedDate": "2020-01-11T10:07:23Z", "message": "Add back the block change flag registration and handling. Restart documenting the block physics process to re-re-re-re-re-rewrite the core of logging these changes.\n\nSigned-off-by: Gabriel Harris-Rouquette <gabizou@me.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c74933fbfd73f7f2628aed69d38746e8811e173e", "author": {"user": {"login": "gabizou", "name": "Gabriel Harris-Rouquette"}}, "url": "https://github.com/SpongePowered/Sponge/commit/c74933fbfd73f7f2628aed69d38746e8811e173e", "committedDate": "2020-01-12T08:07:51Z", "message": "Work in progress to getting the PhaseTracker hooks working again. Restarted WorldMixin and ServerWorldMixin.\n\nSigned-off-by: Gabriel Harris-Rouquette <gabizou@me.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxNTYzODgx", "url": "https://github.com/SpongePowered/Sponge/pull/2476#pullrequestreview-341563881", "createdAt": "2020-01-12T09:40:24Z", "commit": {"oid": "c74933fbfd73f7f2628aed69d38746e8811e173e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQwOTo0MDoyNFrOFcom5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQwOTo0MDoyNFrOFcom5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU2OTc2NA==", "bodyText": "@dualspiral @Zidane I'm introducing this due to the nature of now having possibly multiple threads accessing the same values/stacks, and avoiding the cache getting corrupted, I figured this would be optimal, but I'd ask for someone more knowledgeable than I about threading.", "url": "https://github.com/SpongePowered/Sponge/pull/2476#discussion_r365569764", "createdAt": "2020-01-12T09:40:24Z", "author": {"login": "gabizou"}, "path": "src/main/java/org/spongepowered/common/event/tracking/PooledPhaseState.java", "diffHunk": "@@ -25,45 +25,62 @@\n package org.spongepowered.common.event.tracking;\n \n import java.util.ArrayDeque;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import javax.annotation.Nullable;\n \n public abstract class PooledPhaseState<C extends PhaseContext<C>> implements IPhaseState<C> {\n \n-    private final ArrayDeque<C> contextPool = PhaseTracker.SERVER.createContextPool(this);\n+    private static final ConcurrentHashMap<IPhaseState<?>, ArrayDeque<? extends PhaseContext<?>>> stateContextPool = new ConcurrentHashMap<>();\n+    private final ArrayDeque<C> contextPool;\n     @Nullable private C cached;\n+    final ReentrantLock lock = new ReentrantLock();\n \n     protected PooledPhaseState() {\n+        final ArrayDeque<C> pool = new ArrayDeque<>();\n+        PooledPhaseState.stateContextPool.put(this, pool);\n+        this.contextPool = pool;\n     }\n \n     @Override\n     public final C createPhaseContext() {\n-        if (this.cached != null && !this.cached.isCompleted) {\n-            final C cached = this.cached;\n-            this.cached = null;\n-            return cached;\n+        this.lock.lock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c74933fbfd73f7f2628aed69d38746e8811e173e"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxNTY0MDQx", "url": "https://github.com/SpongePowered/Sponge/pull/2476#pullrequestreview-341564041", "createdAt": "2020-01-12T09:43:47Z", "commit": {"oid": "c74933fbfd73f7f2628aed69d38746e8811e173e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQwOTo0Mzo0N1rOFconxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQwOTo0Mzo0N1rOFconxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU2OTk4OQ==", "bodyText": "@Zidane if you can, please tell me this is the correct way of doing it for Sponge provided types?", "url": "https://github.com/SpongePowered/Sponge/pull/2476#discussion_r365569989", "createdAt": "2020-01-12T09:43:47Z", "author": {"login": "gabizou"}, "path": "src/main/java/org/spongepowered/common/registry/builtin/supplier/EventContextKeySupplier.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package org.spongepowered.common.registry.builtin.supplier;\n+\n+import com.google.common.reflect.TypeToken;\n+import org.spongepowered.api.CatalogKey;\n+import org.spongepowered.api.block.BlockSnapshot;\n+import org.spongepowered.api.data.type.HandType;\n+import org.spongepowered.api.entity.living.player.Player;\n+import org.spongepowered.api.entity.living.player.User;\n+import org.spongepowered.api.event.block.ChangeBlockEvent;\n+import org.spongepowered.api.event.cause.EventContextKey;\n+import org.spongepowered.api.event.cause.entity.damage.DamageType;\n+import org.spongepowered.api.event.cause.entity.damage.source.DamageSource;\n+import org.spongepowered.api.event.cause.entity.dismount.DismountType;\n+import org.spongepowered.api.event.cause.entity.spawn.SpawnType;\n+import org.spongepowered.api.event.cause.entity.teleport.TeleportType;\n+import org.spongepowered.api.item.inventory.ItemStackSnapshot;\n+import org.spongepowered.api.plugin.PluginContainer;\n+import org.spongepowered.api.profile.GameProfile;\n+import org.spongepowered.api.projectile.source.ProjectileSource;\n+import org.spongepowered.api.service.ServiceManager;\n+import org.spongepowered.api.world.LocatableBlock;\n+import org.spongepowered.api.world.World;\n+import org.spongepowered.common.event.SpongeEventContextKey;\n+\n+import java.util.stream.Stream;\n+\n+@SuppressWarnings(\"UnstableApiUsage\")\n+public class EventContextKeySupplier {\n+\n+    public static Stream<EventContextKey<?>> stream() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c74933fbfd73f7f2628aed69d38746e8811e173e"}, "originalPosition": 30}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxNTcyMTg0", "url": "https://github.com/SpongePowered/Sponge/pull/2476#pullrequestreview-341572184", "createdAt": "2020-01-12T12:29:16Z", "commit": {"oid": "c74933fbfd73f7f2628aed69d38746e8811e173e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQxMjoyOToxNlrOFcpNqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQxMjoyOToxNlrOFcpNqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU3OTY4OA==", "bodyText": "Similarly, to my comment above, if this object is per phase tracker instance, you can just lock from here.", "url": "https://github.com/SpongePowered/Sponge/pull/2476#discussion_r365579688", "createdAt": "2020-01-12T12:29:16Z", "author": {"login": "dualspiral"}, "path": "src/main/java/org/spongepowered/common/event/tracking/PooledPhaseState.java", "diffHunk": "@@ -25,45 +25,62 @@\n package org.spongepowered.common.event.tracking;\n \n import java.util.ArrayDeque;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantLock;\n \n import javax.annotation.Nullable;\n \n public abstract class PooledPhaseState<C extends PhaseContext<C>> implements IPhaseState<C> {\n \n-    private final ArrayDeque<C> contextPool = PhaseTracker.SERVER.createContextPool(this);\n+    private static final ConcurrentHashMap<IPhaseState<?>, ArrayDeque<? extends PhaseContext<?>>> stateContextPool = new ConcurrentHashMap<>();\n+    private final ArrayDeque<C> contextPool;\n     @Nullable private C cached;\n+    final ReentrantLock lock = new ReentrantLock();\n \n     protected PooledPhaseState() {\n+        final ArrayDeque<C> pool = new ArrayDeque<>();\n+        PooledPhaseState.stateContextPool.put(this, pool);\n+        this.contextPool = pool;\n     }\n \n     @Override\n     public final C createPhaseContext() {\n-        if (this.cached != null && !this.cached.isCompleted) {\n-            final C cached = this.cached;\n-            this.cached = null;\n-            return cached;\n+        this.lock.lock();\n+        try {\n+            if (this.cached != null && !this.cached.isCompleted) {\n+                final C cached = this.cached;\n+                this.cached = null;\n+                return cached;\n+            }\n+            final C peek = this.contextPool.pollFirst();\n+            if (peek != null) {\n+                this.cached = peek;\n+                return peek;\n+            }\n+            this.cached = this.createNewContext();\n+            return this.cached;\n+        } finally {\n+            this.lock.unlock();\n         }\n-        final C peek = this.contextPool.pollFirst();\n-        if (peek != null) {\n-            this.cached = peek;\n-            return peek;\n-        }\n-        this.cached = this.createNewContext();\n-        return this.cached;\n     }\n \n     final void releaseContextFromPool(final C context) {\n-        if (this.cached == context) {\n-            return;\n-        }\n-        if (this.cached == null) {\n-            // We can cache this context to recycle it if it's requested later.\n-            // If there's no requests and just pushing, then it can be pushed to the\n-            // deque.\n-            this.cached = context;\n-            return;\n+        this.lock.lock();\n+        try {\n+            if (this.cached == context) {\n+                return;\n+            }\n+            if (this.cached == null) {\n+                // We can cache this context to recycle it if it's requested later.\n+                // If there's no requests and just pushing, then it can be pushed to the\n+                // deque.\n+                this.cached = context;\n+                return;\n+            }\n+            this.contextPool.push(context);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c74933fbfd73f7f2628aed69d38746e8811e173e"}, "originalPosition": 77}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxNTgzODky", "url": "https://github.com/SpongePowered/Sponge/pull/2476#pullrequestreview-341583892", "createdAt": "2020-01-12T16:02:28Z", "commit": {"oid": "c74933fbfd73f7f2628aed69d38746e8811e173e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQxNjowMjoyOFrOFcqBag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQxNjowMjoyOFrOFcqBag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU5MjkzOA==", "bodyText": "Delete name parameter unless it is a NamedCatalogType.", "url": "https://github.com/SpongePowered/Sponge/pull/2476#discussion_r365592938", "createdAt": "2020-01-12T16:02:28Z", "author": {"login": "Zidane"}, "path": "src/main/java/org/spongepowered/common/data/type/SpongeSpawnType.java", "diffHunk": "@@ -30,7 +30,18 @@\n \n public final class SpongeSpawnType extends SpongeCatalogType implements SpawnType {\n \n-    public SpongeSpawnType(CatalogKey key) {\n+    private boolean isForced = false;\n+\n+    public SpongeSpawnType(CatalogKey key, String name) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c74933fbfd73f7f2628aed69d38746e8811e173e"}, "originalPosition": 7}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxNTgzODk5", "url": "https://github.com/SpongePowered/Sponge/pull/2476#pullrequestreview-341583899", "createdAt": "2020-01-12T16:02:40Z", "commit": {"oid": "c74933fbfd73f7f2628aed69d38746e8811e173e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQxNjowMjo0MFrOFcqBcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQxNjowMjo0MFrOFcqBcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU5Mjk0Ng==", "bodyText": "id -> key", "url": "https://github.com/SpongePowered/Sponge/pull/2476#discussion_r365592946", "createdAt": "2020-01-12T16:02:40Z", "author": {"login": "Zidane"}, "path": "src/main/java/org/spongepowered/common/event/SpongeEventContextKey.java", "diffHunk": "@@ -27,38 +27,34 @@\n import static com.google.common.base.Preconditions.checkNotNull;\n \n import com.google.common.base.MoreObjects;\n+import com.google.common.reflect.TypeToken;\n+import org.spongepowered.api.CatalogKey;\n import org.spongepowered.api.event.cause.EventContextKey;\n \n+@SuppressWarnings(\"UnstableApiUsage\")\n public final class SpongeEventContextKey<T> implements EventContextKey<T> {\n \n-    private final String id;\n-    private final Class<T> allowed;\n-    private final String name;\n+    private final CatalogKey id;\n+    private final TypeToken<T> allowed;\n \n     SpongeEventContextKey(SpongeEventContextKeyBuilder<T> builder) {\n-        this.id = builder.id;\n+        this.id = builder.key;\n         this.allowed = builder.typeClass;\n-        this.name = builder.name;\n     }\n \n-    public SpongeEventContextKey(String id, String name, Class<T> allowed) {\n+    public SpongeEventContextKey(CatalogKey id, TypeToken<T> allowed) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c74933fbfd73f7f2628aed69d38746e8811e173e"}, "originalPosition": 25}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxNTgzOTgz", "url": "https://github.com/SpongePowered/Sponge/pull/2476#pullrequestreview-341583983", "createdAt": "2020-01-12T16:03:42Z", "commit": {"oid": "c74933fbfd73f7f2628aed69d38746e8811e173e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQxNjowMzo0M1rOFcqB7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQxNjowMzo0M1rOFcqB7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU5MzA2OQ==", "bodyText": "These are not catalogs, correct?", "url": "https://github.com/SpongePowered/Sponge/pull/2476#discussion_r365593069", "createdAt": "2020-01-12T16:03:43Z", "author": {"login": "Zidane"}, "path": "src/main/java/org/spongepowered/common/event/tracking/BlockChangeFlagManager.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * This file is part of Sponge, licensed under the MIT License (MIT).\n+ *\n+ * Copyright (c) SpongePowered <https://www.spongepowered.org>\n+ * Copyright (c) contributors\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.spongepowered.common.event.tracking;\n+\n+import com.google.common.collect.ImmutableList;\n+import it.unimi.dsi.fastutil.ints.Int2ObjectLinkedOpenHashMap;\n+import it.unimi.dsi.fastutil.ints.Int2ObjectMap;\n+import org.spongepowered.api.world.BlockChangeFlag;\n+import org.spongepowered.common.util.Constants;\n+import org.spongepowered.common.world.SpongeBlockChangeFlag;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+\n+public final class BlockChangeFlagManager {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c74933fbfd73f7f2628aed69d38746e8811e173e"}, "originalPosition": 41}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxNTg0MTQ4", "url": "https://github.com/SpongePowered/Sponge/pull/2476#pullrequestreview-341584148", "createdAt": "2020-01-12T16:06:35Z", "commit": {"oid": "c74933fbfd73f7f2628aed69d38746e8811e173e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQxNjowNjozNVrOFcqCnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQxNjowNjozNVrOFcqCnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU5MzI0NA==", "bodyText": "type.getKey().getFormatted()", "url": "https://github.com/SpongePowered/Sponge/pull/2476#discussion_r365593244", "createdAt": "2020-01-12T16:06:35Z", "author": {"login": "Zidane"}, "path": "src/main/java/org/spongepowered/common/event/tracking/PhaseTracker.java", "diffHunk": "@@ -342,363 +296,77 @@ void completePhase(final IPhaseState<?> prevState) {\n \n     }\n \n-    private void printRunnawayPhaseCompletion(final IPhaseState<?> state) {\n-        if (!SpongeImpl.getGlobalConfigAdapter().getConfig().getPhaseTracker().isVerbose() && !this.hasPrintedAboutRunnawayPhases) {\n-            // Avoiding spam logs.\n-            return;\n-        }\n-        final PrettyPrinter printer = new PrettyPrinter(60);\n-        printer.add(\"Completing Phase\").centre().hr();\n-        printer.addWrapped(60, \"Detecting a runaway phase! Potentially a problem \"\n-                               + \"where something isn't completing a phase!!! Sponge will stop printing\"\n-                               + \"after three more times to avoid generating extra logs\");\n-        printer.add();\n-        printer.addWrapped(60, \"%s : %s\", \"Completing phase\", state);\n-        printer.add(\" Phases Remaining:\");\n-        printPhaseStackWithException(this, printer, new Exception(\"RunawayPhase\"));\n-        printer.trace(System.err, SpongeImpl.getLogger(), Level.ERROR);\n-        if (!SpongeImpl.getGlobalConfigAdapter().getConfig().getPhaseTracker().isVerbose() && this.printRunawayCount++ > 3) {\n-            this.hasPrintedAboutRunnawayPhases = true;\n-        }\n-    }\n-\n-    public void generateVersionInfo(final PrettyPrinter printer) {\n-        for (final PluginContainer pluginContainer : SpongeImpl.getInternalPlugins()) {\n-            pluginContainer.getVersion().ifPresent(version ->\n-                    printer.add(\"%s : %s\", pluginContainer.getName(), version)\n-            );\n-        }\n-    }\n-\n-    private void printIncorrectPhaseCompletion(final IPhaseState<?> prevState, final IPhaseState<?> state) {\n-        if (!SpongeImpl.getGlobalConfigAdapter().getConfig().getPhaseTracker().isVerbose() && !this.completedIncorrectStates.isEmpty()) {\n-            for (final Tuple<IPhaseState<?>, IPhaseState<?>> tuple : this.completedIncorrectStates) {\n-                if ((tuple.getFirst().equals(prevState)\n-                        && tuple.getSecond().equals(state))) {\n-                    // we've already printed once about the previous state and the current state\n-                    // being completed incorrectly. only print it once.\n-                    return;\n-                }\n-            }\n-        }\n-\n-        final PrettyPrinter printer = new PrettyPrinter(60).add(\"Completing incorrect phase\").centre().hr()\n-                .addWrapped(\"Sponge's tracking system is very dependent on knowing when\"\n-                        + \" a change to any world takes place, however, we are attempting\"\n-                        + \" to complete a \\\"phase\\\" other than the one we most recently entered.\"\n-                        + \" This is an error usually on Sponge's part, so a report\"\n-                        + \" is required on the issue tracker on GitHub.\").hr()\n-                .add(\"Expected to exit phase: %s\", prevState)\n-                .add(\"But instead found phase: %s\", state)\n-                .add(\"StackTrace:\")\n-                .add(new Exception());\n-        printer.add(\" Phases Remaining:\");\n-        printPhaseStackWithException(this, printer, new Exception(\"Incorrect Phase Completion\"));\n-        printer.trace(System.err, SpongeImpl.getLogger(), Level.ERROR);\n-        if (!SpongeImpl.getGlobalConfigAdapter().getConfig().getPhaseTracker().isVerbose()) {\n-            this.completedIncorrectStates.add(new Tuple<>(prevState, state));\n-        }\n-    }\n-\n-    private void printEmptyStackOnCompletion(final PhaseContext<?> context) {\n-        if (this.hasPrintedEmptyOnce) {\n-            // We want to only mention it once that we are completing an\n-            // empty state, of course something is bound to break, but\n-            // we don't want to spam megabytes worth of log files just\n-            // because of it.\n-            return;\n-        }\n-        final PrettyPrinter printer = new PrettyPrinter(60).add(\"Unexpectedly Completing An Empty Stack\").centre().hr()\n-                .addWrapped(60, \"Sponge's tracking system is very dependent on knowing when\"\n-                                + \" a change to any world takes place, however, we have been told\"\n-                                + \" to complete a \\\"phase\\\" without having entered any phases.\"\n-                                + \" This is an error usually on Sponge's part, so a report\"\n-                                + \" is required on the issue tracker on GitHub.\").hr()\n-                .add(\"StackTrace:\")\n-                .add(new Exception())\n-                .add(\"Phase being completed:\");\n-        PHASE_PRINTER.accept(printer, context);\n-        printer.add();\n-        this.generateVersionInfo(printer);\n-        printer.trace(System.err, SpongeImpl.getLogger(), Level.ERROR);\n-        if (!SpongeImpl.getGlobalConfigAdapter().getConfig().getPhaseTracker().isVerbose()) {\n-            this.hasPrintedEmptyOnce = true;\n-        }\n-    }\n-\n-    private void printRunawayPhase(final IPhaseState<?> state, final PhaseContext<?> context) {\n-        if (!SpongeImpl.getGlobalConfigAdapter().getConfig().getPhaseTracker().isVerbose() && !this.hasPrintedAboutRunnawayPhases) {\n-            // Avoiding spam logs.\n-            return;\n-        }\n-        final PrettyPrinter printer = new PrettyPrinter(60);\n-        printer.add(\"Switching Phase\").centre().hr();\n-        printer.addWrapped(60, \"Detecting a runaway phase! Potentially a problem where something isn't completing a phase!!!\");\n-        printer.add(\"  %s : %s\", \"Entering State\", state);\n-        CONTEXT_PRINTER.accept(printer, context);\n-        printer.addWrapped(60, \"%s :\", \"Phases remaining\");\n-        printPhaseStackWithException(this, printer, new Exception(\"RunawayPhase\"));\n-        printer.trace(System.err, SpongeImpl.getLogger(), Level.ERROR);\n-        if (!SpongeImpl.getGlobalConfigAdapter().getConfig().getPhaseTracker().isVerbose() && this.printRunawayCount++ > SpongeImpl.getGlobalConfigAdapter().getConfig().getPhaseTracker().getMaximumRunawayCount()) {\n-            this.hasPrintedAboutRunnawayPhases = true;\n-        }\n-    }\n-\n-    public static void printNullSourceForBlock(final ServerWorld worldServer, final BlockPos pos, final Block blockIn, final BlockPos otherPos,\n-        final NullPointerException e) {\n-        final PhaseTracker instance = PhaseTracker.getInstance();\n-        final PrettyPrinter printer = new PrettyPrinter(60).add(\"Null Source Block from Unknown Source!\").centre().hr()\n-            .addWrapped(\"Hey, Sponge is saving the game from crashing or spamming because some source \"\n-                        + \"put up a \\\"null\\\" Block as it's source for sending out a neighbor notification. \"\n-                        + \"This is usually unsupported as the game will silently ignore some nulls by \"\n-                        + \"performing \\\"==\\\" checks instead of calling methods, potentially making an \"\n-                        + \"NPE. Because Sponge uses the source block to build information for tracking, \"\n-                        + \"Sponge has to save the game from crashing by reporting this issue. Because the \"\n-                        + \"source is unknown, it's recommended to report this issue to SpongeCommon's \"\n-                        + \"issue tracker on GitHub. Please provide the following information: \")\n-            .add()\n-            .add(\" %s : %s\", \"Source position\", pos)\n-            .add(\" %s : %s\", \"World\", ((World) worldServer).getName())\n-            .add(\" %s : %s\", \"Source Block Recovered\", blockIn)\n-            .add(\" %s : %s\", \"Notified Position\", otherPos).add();\n-\n-        printPhaseStackWithException(instance, printer, e);\n-        printer\n-            .log(SpongeImpl.getLogger(), Level.WARN);\n-    }\n-\n-\n-    public static void printNullSourceBlockWithTile(\n-        final BlockPos pos, final Block blockIn, final BlockPos otherPos, final BlockEntityType type, final boolean useTile,\n-        final NullPointerException e) {\n-        final PhaseTracker instance = PhaseTracker.getInstance();\n-        final PrettyPrinter printer = new PrettyPrinter(60).add(\"Null Source Block on TileEntity!\").centre().hr()\n-            .addWrapped(\"Hey, Sponge is saving the game from crashing because a TileEntity \"\n-                        + \"is sending out a \\'null\\' Block as it's source (more likely) and \"\n-                        + \"attempting to perform a neighbor notification with it. Because \"\n-                        + \"this is guaranteed to lead to a crash or a spam of reports, \"\n-                        + \"Sponge is going ahead and fixing the issue. The offending Tile \"\n-                        + \"is \" + type.getId())\n-            .add()\n-            .add(\"%s : %s\", \"Source position\", pos)\n-            .add(\"%s : %s\", \"Source TileEntity\", type)\n-            .add(\"%s : %s\", \"Recovered using TileEntity as Source\", useTile)\n-            .add(\"%s : %s\", \"Source Block Recovered\", blockIn)\n-            .add(\"%s : %s\", \"Notified Position\", otherPos);\n-        printPhaseStackWithException(instance, printer, e);\n-        printer\n-            .log(SpongeImpl.getLogger(), Level.WARN);\n-    }\n-\n-    public static void printNullSourceBlockNeighborNotificationWithNoTileSource(final BlockPos pos, final Block blockIn, final BlockPos otherPos,\n-        final NullPointerException e) {\n-        final PhaseTracker instance = PhaseTracker.getInstance();\n-        final PrettyPrinter printer = new PrettyPrinter(60).add(\"Null Source Block on TileEntity!\").centre().hr()\n-            .addWrapped(\"Hey, Sponge is saving the game from crashing because a TileEntity \"\n-                        + \"is sending out a \\'null\\' Block as it's source (more likely) and \"\n-                        + \"attempting to perform a neighbor notification with it. Because \"\n-                        + \"this is guaranteed to lead to a crash or a spam of reports, \"\n-                        + \"Sponge is going ahead and fixing the issue. The offending Tile \"\n-                        + \"is unknown, so we don't have any way to configure a reporting for you\")\n-            .add()\n-            .add(\"%s : %s\", \"Source position\", pos)\n-            .add(\"%s : %s\", \"Source TileEntity\", \"UNKNOWN\")\n-            .add(\"%s : %s\", \"Recovered using TileEntity as Source\", \"false\")\n-            .add(\"%s : %s\", \"Source Block Recovered\", blockIn)\n-            .add(\"%s : %s\", \"Notified Position\", otherPos);\n-        printPhaseStackWithException(instance, printer, e);\n-        printer\n-            .log(SpongeImpl.getLogger(), Level.WARN);\n-    }\n-\n-    public static void printPhaseStackWithException(final PhaseTracker instance, final PrettyPrinter printer, final Throwable e) {\n-        instance.stack.forEach(data -> PHASE_PRINTER.accept(printer, data));\n-        printer.add()\n-            .add(\" %s :\", \"StackTrace\")\n-            .add(e)\n-            .add();\n-        instance.generateVersionInfo(printer);\n-    }\n-\n-\n-    public void printMessageWithCaughtException(final String header, final String subHeader, @Nullable final Throwable e) {\n-        this.printMessageWithCaughtException(header, subHeader, this.getCurrentState(), this.getCurrentContext(), e);\n-    }\n-\n-    private void printMessageWithCaughtException(final String header, final String subHeader, final IPhaseState<?> state, final PhaseContext<?> context, @Nullable final Throwable t) {\n-        final PrettyPrinter printer = new PrettyPrinter(60);\n-        printer.add(header).centre().hr()\n-                .add(\"%s %s\", subHeader, state)\n-                .addWrapped(60, \"%s :\", \"PhaseContext\");\n-        CONTEXT_PRINTER.accept(printer, context);\n-        printer.addWrapped(60, \"%s :\", \"Phases remaining\");\n-        this.stack.forEach(data -> PHASE_PRINTER.accept(printer, data));\n-        if (t != null) {\n-            printer.add(\"Stacktrace:\")\n-                    .add(t);\n-            if (t.getCause() != null) {\n-                printer.add(t.getCause());\n-            }\n-        }\n-        printer.add();\n-        this.generateVersionInfo(printer);\n-        printer.trace(System.err, SpongeImpl.getLogger(), Level.ERROR);\n-    }\n-\n-    public void printExceptionFromPhase(final Throwable e, final PhaseContext<?> context) {\n-        if (!SpongeImpl.getGlobalConfigAdapter().getConfig().getPhaseTracker().isVerbose() && !this.printedExceptionsForState.isEmpty()) {\n-            for (final IPhaseState<?> iPhaseState : this.printedExceptionsForState) {\n-                if (context.state == iPhaseState) {\n-                    return;\n-                }\n-            }\n-        }\n-        final PrettyPrinter printer = new PrettyPrinter(60).add(\"Exception occurred during a PhaseState\").centre().hr()\n-            .addWrapped(\"Sponge's tracking system makes a best effort to not throw exceptions randomly but sometimes it is inevitable. In most \"\n-                    + \"cases, something else triggered this exception and Sponge prevented a crash by catching it. The following stacktrace can be \"\n-                    + \"used to help pinpoint the cause.\").hr()\n-            .add(\"The PhaseState having an exception: %s\", context.state)\n-            .add(\"The PhaseContext:\")\n-            ;\n-        printer\n-            .add(context.printCustom(printer, 4));\n-        printPhaseStackWithException(this, printer, e);\n-\n-        printer.trace(System.err, SpongeImpl.getLogger(), Level.ERROR);\n-        if (!SpongeImpl.getGlobalConfigAdapter().getConfig().getPhaseTracker().isVerbose()) {\n-            this.printedExceptionsForState.add(context.state);\n-        }\n-    }\n \n     private void checkPhaseContextProcessed(final IPhaseState<?> state, final PhaseContext<?> context) {\n-        if (!SpongeImpl.getGlobalConfigAdapter().getConfig().getPhaseTracker().isVerbose() && this.printedExceptionsForUnprocessedState.contains(state)) {\n+        if (!SpongeImpl.getGlobalConfigAdapter().getConfig().getPhaseTracker().isVerbose() && PhasePrinter.printedExceptionsForUnprocessedState.contains(state)) {\n             return;\n         }\n \n         if (context.notAllCapturesProcessed()) {\n-            this.printUnprocessedPhaseContextObjects(state, context);\n-            this.printedExceptionsForUnprocessedState.add(state);\n-\n-        }\n-    }\n-\n-    private void printUnprocessedPhaseContextObjects(final IPhaseState<?> state, final PhaseContext<?> context) {\n-        this.printMessageWithCaughtException(\"Failed to process all PhaseContext captured!\",\n-                \"During the processing of a phase, certain objects were captured in a PhaseContext. All of them should have been removed from the PhaseContext by this point\",\n-                state, context, null);\n-    }\n+            PhasePrinter.printUnprocessedPhaseContextObjects(this.stack, state, context);\n+            PhasePrinter.printedExceptionsForUnprocessedState.add(state);\n \n-    private void printBlockTrackingException(final PhaseContext<?> phaseData, final IPhaseState<?> phaseState, final Throwable e) {\n-        if (!SpongeImpl.getGlobalConfigAdapter().getConfig().getPhaseTracker().isVerbose() && !this.printedExceptionsForBlocks.isEmpty()) {\n-            if (this.printedExceptionsForBlocks.contains(phaseState)) {\n-                return;\n-            }\n-        }\n-        final PrettyPrinter printer = new PrettyPrinter(60).add(\"Exception attempting to capture a block change!\").centre().hr();\n-        this.printPhasestack(phaseData, e, printer);\n-        printer.trace(System.err, SpongeImpl.getLogger(), Level.ERROR);\n-        if (!SpongeImpl.getGlobalConfigAdapter().getConfig().getPhaseTracker().isVerbose()) {\n-            this.printedExceptionsForBlocks.add(phaseState);\n-        }\n-    }\n-\n-    private void printPhasestack(final PhaseContext<?> phaseData, final Throwable e, final PrettyPrinter printer) {\n-        printer.addWrapped(60, \"%s :\", \"PhaseContext\");\n-        CONTEXT_PRINTER.accept(printer, phaseData);\n-        printer.addWrapped(60, \"%s :\", \"Phases remaining\");\n-        this.stack.forEach(data -> PHASE_PRINTER.accept(printer, data));\n-        printer.add(\"Stacktrace:\");\n-        printer.add(e);\n-    }\n-\n-    private void printUnexpectedBlockChange(final ServerWorldBridge mixinWorld, final BlockPos pos, final net.minecraft.block.BlockState currentState,\n-                                            final net.minecraft.block.BlockState newState) {\n-        if (!SpongeImpl.getGlobalConfigAdapter().getConfig().getPhaseTracker().isVerbose()) {\n-            return;\n         }\n-        new PrettyPrinter(60).add(\"Unexpected World Change Detected!\").centre().hr()\n-            .add(\"Sponge's tracking system is very dependent on knowing when\\n\"\n-                 + \"a change to any world takes place, however there are chances\\n\"\n-                 + \"where Sponge does not know of changes that mods may perform.\\n\"\n-                 + \"In cases like this, it is best to report to Sponge to get this\\n\"\n-                 + \"change tracked correctly and accurately.\").hr()\n-            .add()\n-            .add(\"%s : %s\", \"World\", mixinWorld)\n-            .add(\"%s : %s\", \"Position\", pos)\n-            .add(\"%s : %s\", \"Current State\", currentState)\n-            .add(\"%s : %s\", \"New State\", newState)\n-            .add()\n-            .add(\"StackTrace:\")\n-            .add(new Exception())\n-            .trace(System.err, SpongeImpl.getLogger(), Level.ERROR);\n     }\n \n-    private void printExceptionSpawningEntity(final PhaseContext<?> context, final Throwable e) {\n-        if (!SpongeImpl.getGlobalConfigAdapter().getConfig().getPhaseTracker().isVerbose() && !this.printedExceptionsForEntities.isEmpty()) {\n-            if (this.printedExceptionsForEntities.contains(context.state)) {\n-                return;\n-            }\n-        }\n-        final PrettyPrinter printer = new PrettyPrinter(60).add(\"Exception attempting to capture or spawn an Entity!\").centre().hr();\n-        this.printPhasestack(context, e, printer);\n-        printer.log(SpongeImpl.getLogger(), Level.ERROR);\n-        if (!SpongeImpl.getGlobalConfigAdapter().getConfig().getPhaseTracker().isVerbose()) {\n-            this.printedExceptionsForEntities.add(context.state);\n-        }\n-    }\n \n     public static Block validateBlockForNeighborNotification(final ServerWorld worldServer, final BlockPos pos, @Nullable Block blockIn,\n         final BlockPos otherPos, final Chunk chunk) {\n         if (blockIn == null) {\n             // If the block is null, check with the PhaseState to see if it can perform a safe way\n-            final PhaseContext<?> currentContext = getInstance().getCurrentContext();\n+            final PhaseContext<?> currentContext = PhaseTracker.getInstance().getCurrentContext();\n             final PhaseTrackerCategory trackerConfig = SpongeImpl.getGlobalConfigAdapter().getConfig().getPhaseTracker();\n \n             if (currentContext.state == TickPhase.Tick.TILE_ENTITY) {\n                 // Try to save ourselves\n-                final BlockEntityType type = currentContext\n-                    .getSource(org.spongepowered.api.block.entity.BlockEntity.class)\n-                    .map(org.spongepowered.api.block.entity.BlockEntity::getType)\n-                    .orElse(null);\n+                final TileEntity source = (TileEntity) currentContext.getSource();\n+\n+                final TileEntityType<?> type = Optional.ofNullable(source)\n+                        .map(TileEntity::getType)\n+                        .orElse(null);\n                 if (type != null) {\n+                    ResourceLocation id = TileEntityType.getId(type);\n+                    if (id == null) {\n+                        id = new ResourceLocation(source.getClass().getCanonicalName());\n+                    }\n                     final Map<String, Boolean> autoFixedTiles = trackerConfig.getAutoFixedTiles();\n-                    final boolean contained = autoFixedTiles.containsKey(type.getId());\n+                    final boolean contained = autoFixedTiles.containsKey(type.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c74933fbfd73f7f2628aed69d38746e8811e173e"}, "originalPosition": 603}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxNTg0MjE0", "url": "https://github.com/SpongePowered/Sponge/pull/2476#pullrequestreview-341584214", "createdAt": "2020-01-12T16:07:41Z", "commit": {"oid": "c74933fbfd73f7f2628aed69d38746e8811e173e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQxNjowNzo0MlrOFcqC6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQxNjowNzo0MlrOFcqC6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU5MzMyMQ==", "bodyText": "Do not pass back IDs to crash reports, pass their keys", "url": "https://github.com/SpongePowered/Sponge/pull/2476#discussion_r365593321", "createdAt": "2020-01-12T16:07:42Z", "author": {"login": "Zidane"}, "path": "src/main/java/org/spongepowered/common/event/tracking/PhaseTracker.java", "diffHunk": "@@ -791,22 +460,22 @@ public void notifyBlockOfStateChange(final ServerWorldBridge mixinWorld, final n\n                 // the try with resources will perform a close without the phase context being entered, leading to issues of closing\n                 // other phase contexts.\n                 // Refer to https://github.com/SpongePowered/SpongeForge/issues/2706\n-                if (PhaseTracker.checkMaxBlockProcessingDepth(state, peek, context.getDepth())) {\n+                if (PhasePrinter.checkMaxBlockProcessingDepth(state, peek, context.getDepth())) {\n                     return;\n                 }\n                 // Sponge End\n \n-                notifyState.neighborChanged(((ServerWorld) mixinWorld), notifyPos, sourceBlock, sourcePos);\n+                notifyState.neighborChanged(((ServerWorld) mixinWorld), notifyPos, sourceBlock, sourcePos, isMoving);\n             }\n         } catch (final Throwable throwable) {\n             final CrashReport crashreport = CrashReport.makeCrashReport(throwable, \"Exception while updating neighbours\");\n             final CrashReportCategory crashreportcategory = crashreport.makeCategory(\"Block being updated\");\n             crashreportcategory.addDetail(\"Source block type\", () -> {\n                 try {\n-                    return String.format(\"ID #%d (%s // %s)\", Block.getIdFromBlock(sourceBlock),\n+                    return String.format(\"ID #%d (%s // %s)\", Registry.BLOCK.getId(sourceBlock),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c74933fbfd73f7f2628aed69d38746e8811e173e"}, "originalPosition": 709}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxNTg0MjI3", "url": "https://github.com/SpongePowered/Sponge/pull/2476#pullrequestreview-341584227", "createdAt": "2020-01-12T16:07:57Z", "commit": {"oid": "c74933fbfd73f7f2628aed69d38746e8811e173e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQxNjowNzo1OFrOFcqC9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQxNjowNzo1OFrOFcqC9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU5MzMzMw==", "bodyText": "mixinWorld -> worldBridge", "url": "https://github.com/SpongePowered/Sponge/pull/2476#discussion_r365593333", "createdAt": "2020-01-12T16:07:58Z", "author": {"login": "Zidane"}, "path": "src/main/java/org/spongepowered/common/event/tracking/PhaseTracker.java", "diffHunk": "@@ -815,51 +484,51 @@ public void notifyBlockOfStateChange(final ServerWorldBridge mixinWorld, final n\n     }\n \n     /**\n-     * Replacement of {@link WorldServer#setBlockState(BlockPos, IBlockState, int)}\n-     * that adds cause tracking.\n+     * Replacement of {@link ServerWorld#setBlockState(BlockPos, net.minecraft.block.BlockState, int)}\n+     * with the additions of cause tracking\n      *\n      * @param pos The position of the block state to set\n      * @param newState The new state\n      * @param flag The notification flags\n      * @return True if the block was successfully set (or captured)\n      */\n     @SuppressWarnings(\"rawtypes\")\n-    public boolean setBlockState(final ServerWorldBridge mixinWorld, final BlockPos pos, final net.minecraft.block.BlockState newState, final BlockChangeFlag flag) {\n+    public boolean setBlockState(final ServerWorldBridge mixinWorld, final BlockPos pos,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c74933fbfd73f7f2628aed69d38746e8811e173e"}, "originalPosition": 733}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxNTg0Mjc0", "url": "https://github.com/SpongePowered/Sponge/pull/2476#pullrequestreview-341584274", "createdAt": "2020-01-12T16:08:38Z", "commit": {"oid": "c74933fbfd73f7f2628aed69d38746e8811e173e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQxNjowODozOFrOFcqDJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQxNjowODozOFrOFcqDJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU5MzM4MA==", "bodyText": ".", "url": "https://github.com/SpongePowered/Sponge/pull/2476#discussion_r365593380", "createdAt": "2020-01-12T16:08:38Z", "author": {"login": "Zidane"}, "path": "src/main/java/org/spongepowered/common/event/tracking/PhaseTracker.java", "diffHunk": "@@ -871,38 +540,36 @@ public boolean setBlockState(final ServerWorldBridge mixinWorld, final BlockPos\n \n         final PhaseContext<?> context = this.stack.peek();\n         final IPhaseState<?> phaseState = context.state;\n-        final boolean isComplete = phaseState == GeneralPhase.State.COMPLETE;\n-        // Do a sanity check, if we're not in any phase state that accepts block changes, well, why the hell are\n-        // we doing any changes?? The changes themselves will still go through, but we want to be as verbose\n-        // about those changes as possible, if we're configured to do so.\n-        if (isComplete && SpongeImpl.getGlobalConfigAdapter().getConfig().getPhaseTracker().isVerbose()) { // Fail fast.\n-            // The random occurrence that we're told to complete a phase\n-            // while a world is being changed unknowingly.\n-//            this.printUnexpectedBlockChange(mixinWorld, pos, currentState, newState);\n-        }\n+\n         // We can allow the block to get changed, regardless how it's captured, not captured, etc.\n         // because ChunkMixin will perform the necessary changes, and appropriately prevent any specific\n         // physics handling.\n \n         final ChunkBridge mixinChunk = (ChunkBridge) chunk;\n         // Sponge - Use our mixin method that allows using the BlockChangeFlag.\n \n-        final net.minecraft.block.BlockState originalBlockState = mixinChunk.bridge$setBlockState(pos, newState, currentState, spongeFlag);\n+        // Up until this point, we've been setting up sponge stuff, this next line is from vanilla\n+        // where it tells the chunk to set the new state, but we have to call our custom method\n+        // to do transaction handling\n+        // final net.minecraft.block.BlockState blockstate = chunk.setBlockState(pos, newState, (flags & 64) != 0);\n+        final net.minecraft.block.BlockState originalState = mixinChunk.bridge$setBlockState(pos, newState, currentState, spongeFlag);\n         // Sponge End\n-        if (originalBlockState == null) {\n+        if (originalState == null) {\n             return false;\n-        }\n+        } // else { // Sponge - redundant else\n \n-        // else { // Sponge - unnecessary formatting\n-        // Forge changes the BlockState.getLightOpacity to use Forge's hook.\n-        if (SpongeImplHooks.getBlockLightOpacity(newState, minecraftWorld, pos) != oldOpacity || SpongeImplHooks.getChunkPosLight(newState, minecraftWorld, pos) != oldLight) {\n-            // Sponge - End\n-            minecraftWorld.profiler.startSection(\"checkLight\");\n-            minecraftWorld.checkLight(pos);\n-            minecraftWorld.profiler.endSection();\n+        // blockstate1 -> newWorldState\n+        final net.minecraft.block.BlockState newWorldState = world.getBlockState(pos);\n+        if (newWorldState != originalState && (newWorldState.getOpacity(world, pos) != originalState.getOpacity(world, pos) || newWorldState.getLightValue() != originalState.getLightValue() || newWorldState.func_215691_g() || originalState.func_215691_g())) {\n+            // this.profiler.startSection(\"queueCheckLight\");\n+            world.getProfiler().startSection(\"queueCheckLight\");\n+            // this.getChunkProvider().getLightManager().checkBlock(pos);\n+            world.getChunkProvider().getLightManager().checkBlock(pos);\n+            // this.profiler.endSection();\n+            world.getProfiler().endSection();\n         }\n \n-        // Sponge Start - At this point, we can stop and check for captures.\n+        // Sponge Start - At this point, we can stop and check for captures;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c74933fbfd73f7f2628aed69d38746e8811e173e"}, "originalPosition": 847}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxNTg0NDI1", "url": "https://github.com/SpongePowered/Sponge/pull/2476#pullrequestreview-341584425", "createdAt": "2020-01-12T16:11:08Z", "commit": {"oid": "c74933fbfd73f7f2628aed69d38746e8811e173e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQxNjoxMTowOVrOFcqDzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQxNjoxMTowOVrOFcqDzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU5MzU0OA==", "bodyText": "Use SpongeImpl method to collapse first two branches", "url": "https://github.com/SpongePowered/Sponge/pull/2476#discussion_r365593548", "createdAt": "2020-01-12T16:11:09Z", "author": {"login": "Zidane"}, "path": "src/main/java/org/spongepowered/common/event/tracking/PhaseTracker.java", "diffHunk": "@@ -1169,115 +857,21 @@ public boolean spawnEntityWithCause(final World world, final Entity entity) {\n      * @return True if the entity spawn is on the main thread.\n      */\n     public static boolean isEntitySpawnInvalid(final Entity entity) {\n-        if (Sponge.isServerAvailable() && (Sponge.getServer().isMainThread() || SpongeImpl.getServer().isServerStopped())) {\n+        if (Sponge.isServerAvailable() && (Sponge.getServer().onMainThread() || SpongeImpl.getServer().isServerStopped())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c74933fbfd73f7f2628aed69d38746e8811e173e"}, "originalPosition": 1127}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxNTg0NDgw", "url": "https://github.com/SpongePowered/Sponge/pull/2476#pullrequestreview-341584480", "createdAt": "2020-01-12T16:12:01Z", "commit": {"oid": "c74933fbfd73f7f2628aed69d38746e8811e173e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQxNjoxMjowMVrOFcqEDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQxNjoxMjowMVrOFcqEDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU5MzYxMg==", "bodyText": "Do not reference supplier classes in common code. Simply do SpawnTypes.BLAH.get()", "url": "https://github.com/SpongePowered/Sponge/pull/2476#discussion_r365593612", "createdAt": "2020-01-12T16:12:01Z", "author": {"login": "Zidane"}, "path": "src/main/java/org/spongepowered/common/event/tracking/PhaseTracker.java", "diffHunk": "@@ -84,25 +85,19 @@\n import org.spongepowered.common.event.tracking.phase.tick.NeighborNotificationContext;\n import org.spongepowered.common.event.tracking.phase.tick.TickPhase;\n import org.spongepowered.common.mixin.accessor.world.server.ServerWorldAccessor;\n-import org.spongepowered.common.registry.type.event.SpawnTypeRegistryModule;\n+import org.spongepowered.common.registry.builtin.supplier.SpawnTypeSupplier;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c74933fbfd73f7f2628aed69d38746e8811e173e"}, "originalPosition": 56}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxNTg0NjQ4", "url": "https://github.com/SpongePowered/Sponge/pull/2476#pullrequestreview-341584648", "createdAt": "2020-01-12T16:14:42Z", "commit": {"oid": "c74933fbfd73f7f2628aed69d38746e8811e173e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQxNjoxNDo0M1rOFcqE3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQxNjoxNDo0M1rOFcqE3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU5MzgyMA==", "bodyText": "mixinEntity -> entityBridge", "url": "https://github.com/SpongePowered/Sponge/pull/2476#discussion_r365593820", "createdAt": "2020-01-12T16:14:43Z", "author": {"login": "Zidane"}, "path": "src/main/java/org/spongepowered/common/event/tracking/TrackingUtil.java", "diffHunk": "@@ -142,7 +143,36 @@\n         });\n     public static final int WIDTH = 40;\n \n-    public static void tickEntity(final net.minecraft.entity.Entity entity) {\n+    public static void tickEntity(final Consumer<net.minecraft.entity.Entity> consumer, final net.minecraft.entity.Entity entity) {\n+        checkArgument(entity instanceof Entity, \"Entity %s is not an instance of SpongeAPI's Entity!\", entity);\n+        checkNotNull(entity, \"Cannot capture on a null ticking entity!\");\n+        final EntityBridge mixinEntity = (EntityBridge) entity;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c74933fbfd73f7f2628aed69d38746e8811e173e"}, "originalPosition": 45}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxNTg0OTE4", "url": "https://github.com/SpongePowered/Sponge/pull/2476#pullrequestreview-341584918", "createdAt": "2020-01-12T16:20:09Z", "commit": {"oid": "c74933fbfd73f7f2628aed69d38746e8811e173e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQxNjoyMDowOVrOFcqF8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQxNjoyMDowOVrOFcqF8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU5NDA5OQ==", "bodyText": "Same here, stream package and named like the stream classes.\nIn all honesty, the supplier classes are simply for supplying Vanilla registry entries.", "url": "https://github.com/SpongePowered/Sponge/pull/2476#discussion_r365594099", "createdAt": "2020-01-12T16:20:09Z", "author": {"login": "Zidane"}, "path": "src/main/java/org/spongepowered/common/registry/builtin/supplier/SpawnTypeSupplier.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package org.spongepowered.common.registry.builtin.supplier;\n+\n+import org.spongepowered.api.CatalogKey;\n+import org.spongepowered.api.event.cause.entity.spawn.SpawnType;\n+import org.spongepowered.common.data.type.SpongeSpawnType;\n+\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+public class SpawnTypeSupplier {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c74933fbfd73f7f2628aed69d38746e8811e173e"}, "originalPosition": 10}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxNTg0OTM4", "url": "https://github.com/SpongePowered/Sponge/pull/2476#pullrequestreview-341584938", "createdAt": "2020-01-12T16:20:30Z", "commit": {"oid": "c74933fbfd73f7f2628aed69d38746e8811e173e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQxNjoyMDozMFrOFcqGAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQxNjoyMDozMFrOFcqGAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU5NDExNA==", "bodyText": "Is there a reason this is here? Why isn't this in the API?", "url": "https://github.com/SpongePowered/Sponge/pull/2476#discussion_r365594114", "createdAt": "2020-01-12T16:20:30Z", "author": {"login": "Zidane"}, "path": "src/main/java/org/spongepowered/common/registry/builtin/supplier/SpawnTypeSupplier.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package org.spongepowered.common.registry.builtin.supplier;\n+\n+import org.spongepowered.api.CatalogKey;\n+import org.spongepowered.api.event.cause.entity.spawn.SpawnType;\n+import org.spongepowered.common.data.type.SpongeSpawnType;\n+\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+public class SpawnTypeSupplier {\n+\n+    public static SpawnType FORCED = new SpongeSpawnType(CatalogKey.sponge(\"forced\"), \"Forced\").forced();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c74933fbfd73f7f2628aed69d38746e8811e173e"}, "originalPosition": 12}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b29db9b5c47ef24ba69359d73ab375c0f605546f", "author": {"user": {"login": "gabizou", "name": "Gabriel Harris-Rouquette"}}, "url": "https://github.com/SpongePowered/Sponge/commit/b29db9b5c47ef24ba69359d73ab375c0f605546f", "committedDate": "2020-01-13T11:54:30Z", "message": "Per Thread PhaseTrackers and pooling.\n\nSigned-off-by: Gabriel Harris-Rouquette <gabizou@me.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a68ea25002cd40d42cebba8178bb61096223ec1", "author": {"user": {"login": "gabizou", "name": "Gabriel Harris-Rouquette"}}, "url": "https://github.com/SpongePowered/Sponge/commit/4a68ea25002cd40d42cebba8178bb61096223ec1", "committedDate": "2020-01-19T07:15:24Z", "message": "Allow partial rescheduling of asynchronous block changes onto the main thread on server controlled worlds.\n\nSigned-off-by: Gabriel Harris-Rouquette <gabizou@me.com>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 840, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}