{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI0NzI0MjMw", "number": 2627, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQyMzowNDowN1rOEBJLJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNjoxNjoyN1rOEJu4GA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NjM0MzQwOnYy", "diffSide": "RIGHT", "path": "src/mixins/java/org/spongepowered/common/mixin/api/mcp/world/IWorldReaderMixin_API.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQyMzowNDowN1rOGc1w_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQwOToxMzoyOFrOGc3vMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NDIwNg==", "bodyText": "These default implemented methods should throw exceptions for us to look at to implement.", "url": "https://github.com/SpongePowered/Sponge/pull/2627#discussion_r432894206", "createdAt": "2020-05-30T23:04:07Z", "author": {"login": "gabizou"}, "path": "src/mixins/java/org/spongepowered/common/mixin/api/mcp/world/IWorldReaderMixin_API.java", "diffHunk": "@@ -103,6 +105,11 @@ default boolean hasLiquid(final int x, final int y, final int z) {\n         return this.shadow$hasWater(new BlockPos(x, y, z));\n     }\n \n+    @Override\n+    default boolean containsAnyLiquids(AABB aabb) {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e352cb76662a8112bf1a80575ea736a7e19e6c3"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkyNjUxNA==", "bodyText": "implemented this one\nthe others that are not in invalid now throw exceptions\nIWorldMixin_LocationBasedDataHolder_API and ServerWorldMixin_InteractableVolume_API\nare in invalid so they should get looked at anyways\nI just extracted the not implemented methods from the mixins there were in previously.", "url": "https://github.com/SpongePowered/Sponge/pull/2627#discussion_r432926514", "createdAt": "2020-05-31T09:13:28Z", "author": {"login": "Faithcaio"}, "path": "src/mixins/java/org/spongepowered/common/mixin/api/mcp/world/IWorldReaderMixin_API.java", "diffHunk": "@@ -103,6 +105,11 @@ default boolean hasLiquid(final int x, final int y, final int z) {\n         return this.shadow$hasWater(new BlockPos(x, y, z));\n     }\n \n+    @Override\n+    default boolean containsAnyLiquids(AABB aabb) {\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NDIwNg=="}, "originalCommit": {"oid": "1e352cb76662a8112bf1a80575ea736a7e19e6c3"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NjU5NTE2OnYy", "diffSide": "RIGHT", "path": "src/mixins/java/org/spongepowered/common/mixin/api/mcp/world/IWorldMixin_API.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQwOToxNTo0OVrOGc3v8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQwOToxNTo0OVrOGc3v8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkyNjcwNg==", "bodyText": "@gabizou api7 code was capturing stuff in this method. Is this needed here?\nOtherwise IWorldGenerationReaderMixin_API already has the redirect to the shadow$setBlockState", "url": "https://github.com/SpongePowered/Sponge/pull/2627#discussion_r432926706", "createdAt": "2020-05-31T09:15:49Z", "author": {"login": "Faithcaio"}, "path": "src/mixins/java/org/spongepowered/common/mixin/api/mcp/world/IWorldMixin_API.java", "diffHunk": "@@ -191,158 +218,179 @@ default WorldProperties getProperties() {\n         return (WorldProperties) this.shadow$getWorldInfo();\n     }\n \n-    @Override\n-    default boolean setBlock(final Vector3i position, final BlockState block) {\n-        throw new UnsupportedOperationException(\"Unfortunately, you've found an extended class of IWorld that isn't part of Sponge API: \" + this.getClass());\n-    }\n-\n-    @Override\n-    default boolean setBlock(final int x, final int y, final int z, final BlockState block) {\n-        throw new UnsupportedOperationException(\"Unfortunately, you've found an extended class of IWorld that isn't part of Sponge API: \" + this.getClass());\n-    }\n-\n-    @Override\n-    default boolean setBlock(final Vector3i position, final BlockState state, final BlockChangeFlag flag) {\n-        throw new UnsupportedOperationException(\"Unfortunately, you've found an extended class of IWorld that isn't part of Sponge API: \" + this.getClass());\n-    }\n+    // MutableEntityVolume\n \n     @Override\n     default Entity createEntity(final EntityType<?> type, final Vector3d position) throws IllegalArgumentException, IllegalStateException {\n-        return null;\n+        return this.impl$createEntity(type, position, false);\n     }\n \n     @Override\n     default Entity createEntityNaturally(final EntityType<?> type, final Vector3d position) throws IllegalArgumentException, IllegalStateException {\n-        return null;\n+        return this.impl$createEntity(type, position, true);\n     }\n \n     @Override\n     default Optional<Entity> createEntity(final DataContainer entityContainer) {\n-        return Optional.empty();\n+        throw new UnsupportedOperationException(\"Implement me\"); // TODO implement me\n     }\n \n     @Override\n     default Optional<Entity> createEntity(final DataContainer entityContainer, final Vector3d position) {\n-        return Optional.empty();\n+        throw new UnsupportedOperationException(\"Implement me\"); // TODO implement me\n     }\n \n-    @Override\n-    default Collection<Entity> spawnEntities(final Iterable<? extends Entity> entities) {\n-        return null;\n-    }\n-\n-    @Override default int getHeight(final HeightType type, final int x, final int z) {\n-        return 0;\n-    }\n-\n-    @Override\n-    default <E> Optional<E> get(final int x, final int y, final int z, final Key<? extends Value<E>> key) {\n-        return Optional.empty();\n-    }\n-\n-    @Override\n-    default <E, V extends Value<E>> Optional<V> getValue(final int x, final int y, final int z, final Key<V> key) {\n-        return Optional.empty();\n-    }\n-\n-    @Override\n-    default boolean supports(final int x, final int y, final int z, final Key<?> key) {\n-        return false;\n-    }\n-\n-    @Override\n-    default Set<Key<?>> getKeys(final int x, final int y, final int z) {\n-        return null;\n-    }\n+    default Entity impl$createEntity(EntityType<?> type, Vector3d position, boolean naturally) throws IllegalArgumentException, IllegalStateException {\n+        checkNotNull(type, \"The entity type cannot be null!\");\n+        checkNotNull(position, \"The position cannot be null!\");\n \n-    @Override\n-    default Set<Value.Immutable<?>> getValues(final int x, final int y, final int z) {\n-        return null;\n-    }\n+        if (type == net.minecraft.entity.EntityType.PLAYER) {\n+            // Unable to construct these\n+            throw new IllegalArgumentException(\"Cannot construct \" + type.getKey() + \" please look to using entity types correctly!\");\n+        }\n \n-    @Override\n-    default <E> DataTransactionResult offer(final int x, final int y, final int z, final Key<? extends Value<E>> key, final E value) {\n-        return null;\n-    }\n+        net.minecraft.entity.Entity entity = null;\n+        final double x = position.getX();\n+        final double y = position.getY();\n+        final double z = position.getZ();\n+        World thisWorld = this.shadow$getWorld();\n+        // Not all entities have a single World parameter as their constructor\n+        if (type == net.minecraft.entity.EntityType.LIGHTNING_BOLT) {\n+            entity = new LightningBoltEntity(thisWorld, x, y, z, false);\n+        }\n+        // TODO - archetypes should solve the problem of calling the correct constructor\n+        if (type == net.minecraft.entity.EntityType.ENDER_PEARL) {\n+            ArmorStandEntity tempEntity = new ArmorStandEntity(thisWorld, x, y, z);\n+            tempEntity.posY -= tempEntity.getEyeHeight();\n+            entity = new EnderPearlEntity(thisWorld, tempEntity);\n+            ((EnderPearl) entity).offer(Keys.SHOOTER, UnknownProjectileSource.UNKNOWN);\n+        }\n+        // Some entities need to have non-null fields (and the easiest way to\n+        // set them is to use the more specialised constructor).\n+        if (type == net.minecraft.entity.EntityType.FALLING_BLOCK) {\n+            entity = new FallingBlockEntity(thisWorld, x, y, z, Blocks.SAND.getDefaultState());\n+        }\n+        if (type == net.minecraft.entity.EntityType.ITEM) {\n+            entity = new ItemEntity(thisWorld, x, y, z, new ItemStack(Blocks.STONE));\n+        }\n \n-    @Override\n-    default DataTransactionResult remove(final int x, final int y, final int z, final Key<?> key) {\n-        return null;\n-    }\n+        if (entity == null) {\n+            try {\n+                entity = ((net.minecraft.entity.EntityType) type).create(thisWorld);\n+                entity.setPosition(x, y, z);\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"There was an issue attempting to construct \" + type.getKey(), e);\n+            }\n+        }\n \n-    @Override\n-    default DataTransactionResult undo(final int x, final int y, final int z, final DataTransactionResult result) {\n-        return null;\n-    }\n+        // TODO - replace this with an actual check\n+        /*\n+        if (entity instanceof EntityHanging) {\n+            if (((EntityHanging) entity).facingDirection == null) {\n+                // TODO Some sort of detection of a valid direction?\n+                // i.e scan immediate blocks for something to attach onto.\n+                ((EntityHanging) entity).facingDirection = EnumFacing.NORTH;\n+            }\n+            if (!((EntityHanging) entity).onValidSurface()) {\n+                return Optional.empty();\n+            }\n+        }*/\n+\n+        if (naturally && entity instanceof MobEntity) {\n+            // Adding the default equipment\n+            final DifficultyInstance difficulty = this.shadow$getDifficultyForLocation(new BlockPos(x, y, z));\n+            ((MobEntityAccessor)entity).accessor$setEquipmentBasedOnDifficulty(difficulty);\n+        }\n \n-    @Override\n-    default DataTransactionResult copyFrom(final int xTo, final int yTo, final int zTo, final DataHolder from) {\n-        return null;\n-    }\n+        if (entity instanceof PaintingEntity) {\n+            // This is default when art is null when reading from NBT, could\n+            // choose a random art instead?\n+            ((PaintingEntity) entity).art = PaintingType.KEBAB;\n+        }\n \n-    @Override\n-    default DataTransactionResult copyFrom(\n-        final int xTo, final int yTo, final int zTo, final DataHolder from, final MergeFunction function) {\n-        return null;\n+        return (Entity) entity;\n     }\n \n     @Override\n-    default DataTransactionResult copyFrom(final int xTo, final int yTo, final int zTo, final int xFrom, final int yFrom, final int zFrom, final MergeFunction function) {\n-        return null;\n-    }\n+    default Collection<Entity> spawnEntities(final Iterable<? extends Entity> entities) {\n+        final List<Entity> entitiesToSpawn = new NonNullArrayList<>();\n+        entities.forEach(entitiesToSpawn::add);\n+        final SpawnEntityEvent.Custom event = SpongeEventFactory\n+                .createSpawnEntityEventCustom(Sponge.getCauseStackManager().getCurrentCause(), entitiesToSpawn);\n+        if (Sponge.getEventManager().post(event)) {\n+            return ImmutableList.of();\n+        }\n+        for (final Entity entity : event.getEntities()) {\n+            EntityUtil.processEntitySpawn(entity, Optional::empty);\n+        }\n \n-    @Override\n-    default boolean validateRawData(final int x, final int y, final int z, final DataView container) {\n-        return false;\n+        final ImmutableList.Builder<Entity> builder = ImmutableList.builder();\n+        for (final Entity entity : event.getEntities()) {\n+            builder.add(entity);\n+        }\n+        return builder.build();\n     }\n \n     @Override\n-    default void setRawData(final int x, final int y, final int z, final DataView container) throws InvalidDataException {\n+    default boolean spawnEntity(Entity entity) {\n+        return IWorldWriterMixin_API.super.spawnEntity(entity); // TODO is capature needed here?\n \n+        Preconditions.checkNotNull(entity, \"The entity cannot be null!\");\n+        if (PhaseTracker.isEntitySpawnInvalid(entity)) {\n+            return true;\n+        }\n+        final PhaseTracker phaseTracker = PhaseTracker.getInstance();\n+        final IPhaseState<?> state = phaseTracker.getCurrentState();\n+        if (!state.alreadyCapturingEntitySpawns()) {\n+            try (final BasicPluginContext context = PluginPhase.State.CUSTOM_SPAWN.createPhaseContext(PhaseTracker.SERVER)) {\n+                context.buildAndSwitch();\n+                phaseTracker.spawnEntityWithCause((org.spongepowered.api.world.World<?>) this, entity);\n+                return true;\n+            }\n+        }\n+        return phaseTracker.spawnEntityWithCause((org.spongepowered.api.world.World<?>) this, entity);\n     }\n \n-    @Override\n-    default int getSeaLevel() {\n-        return 0;\n-    }\n+    // HeightAwareVolume\n \n     @Override\n-    default ScheduledUpdateList<BlockType> getScheduledBlockUpdates() {\n-        return null;\n+    default int getHeight(final HeightType type, final int x, final int z) {\n+        return IWorldReaderMixin_API.super.getHeight(type, x, z);\n     }\n \n-    @Override\n-    default ScheduledUpdateList<FluidType> getScheduledFluidUpdates() {\n-        return null;\n-    }\n+    // MutableBlockVolume\n \n     @Override\n-    default boolean setBlock(final int x, final int y, final int z, final BlockState state, final BlockChangeFlag flag) {\n-        return false;\n+    default boolean removeBlock(int x, int y, int z) {\n+        return IWorldGenerationReaderMixin_API.super.removeBlock(x, y, z);\n     }\n \n     @Override\n-    default boolean spawnEntity(final Entity entity) {\n-        return false;\n-    }\n+    default boolean setBlock(int x, int y, int z, org.spongepowered.api.block.BlockState blockState, BlockChangeFlag flag) {\n+        return IWorldGenerationReaderMixin_API.super.setBlock(x, y, z, blockState, flag); // TODO is capture needed here?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97efe8819ab46ab6f42600514cf899f3759d990b"}, "originalPosition": 409}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NjU5NTU3OnYy", "diffSide": "RIGHT", "path": "src/mixins/java/org/spongepowered/common/mixin/api/mcp/world/IWorldMixin_API.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQwOToxNjoyOVrOGc3wJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQwOToxNjoyOVrOGc3wJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkyNjc1Nw==", "bodyText": "@gabizou api7 code was capturing stuff in this method. Is this needed here?\nOtherwise IWorldWriterMixin_API already has the redirect to the shadow$addEntity", "url": "https://github.com/SpongePowered/Sponge/pull/2627#discussion_r432926757", "createdAt": "2020-05-31T09:16:29Z", "author": {"login": "Faithcaio"}, "path": "src/mixins/java/org/spongepowered/common/mixin/api/mcp/world/IWorldMixin_API.java", "diffHunk": "@@ -191,158 +218,179 @@ default WorldProperties getProperties() {\n         return (WorldProperties) this.shadow$getWorldInfo();\n     }\n \n-    @Override\n-    default boolean setBlock(final Vector3i position, final BlockState block) {\n-        throw new UnsupportedOperationException(\"Unfortunately, you've found an extended class of IWorld that isn't part of Sponge API: \" + this.getClass());\n-    }\n-\n-    @Override\n-    default boolean setBlock(final int x, final int y, final int z, final BlockState block) {\n-        throw new UnsupportedOperationException(\"Unfortunately, you've found an extended class of IWorld that isn't part of Sponge API: \" + this.getClass());\n-    }\n-\n-    @Override\n-    default boolean setBlock(final Vector3i position, final BlockState state, final BlockChangeFlag flag) {\n-        throw new UnsupportedOperationException(\"Unfortunately, you've found an extended class of IWorld that isn't part of Sponge API: \" + this.getClass());\n-    }\n+    // MutableEntityVolume\n \n     @Override\n     default Entity createEntity(final EntityType<?> type, final Vector3d position) throws IllegalArgumentException, IllegalStateException {\n-        return null;\n+        return this.impl$createEntity(type, position, false);\n     }\n \n     @Override\n     default Entity createEntityNaturally(final EntityType<?> type, final Vector3d position) throws IllegalArgumentException, IllegalStateException {\n-        return null;\n+        return this.impl$createEntity(type, position, true);\n     }\n \n     @Override\n     default Optional<Entity> createEntity(final DataContainer entityContainer) {\n-        return Optional.empty();\n+        throw new UnsupportedOperationException(\"Implement me\"); // TODO implement me\n     }\n \n     @Override\n     default Optional<Entity> createEntity(final DataContainer entityContainer, final Vector3d position) {\n-        return Optional.empty();\n+        throw new UnsupportedOperationException(\"Implement me\"); // TODO implement me\n     }\n \n-    @Override\n-    default Collection<Entity> spawnEntities(final Iterable<? extends Entity> entities) {\n-        return null;\n-    }\n-\n-    @Override default int getHeight(final HeightType type, final int x, final int z) {\n-        return 0;\n-    }\n-\n-    @Override\n-    default <E> Optional<E> get(final int x, final int y, final int z, final Key<? extends Value<E>> key) {\n-        return Optional.empty();\n-    }\n-\n-    @Override\n-    default <E, V extends Value<E>> Optional<V> getValue(final int x, final int y, final int z, final Key<V> key) {\n-        return Optional.empty();\n-    }\n-\n-    @Override\n-    default boolean supports(final int x, final int y, final int z, final Key<?> key) {\n-        return false;\n-    }\n-\n-    @Override\n-    default Set<Key<?>> getKeys(final int x, final int y, final int z) {\n-        return null;\n-    }\n+    default Entity impl$createEntity(EntityType<?> type, Vector3d position, boolean naturally) throws IllegalArgumentException, IllegalStateException {\n+        checkNotNull(type, \"The entity type cannot be null!\");\n+        checkNotNull(position, \"The position cannot be null!\");\n \n-    @Override\n-    default Set<Value.Immutable<?>> getValues(final int x, final int y, final int z) {\n-        return null;\n-    }\n+        if (type == net.minecraft.entity.EntityType.PLAYER) {\n+            // Unable to construct these\n+            throw new IllegalArgumentException(\"Cannot construct \" + type.getKey() + \" please look to using entity types correctly!\");\n+        }\n \n-    @Override\n-    default <E> DataTransactionResult offer(final int x, final int y, final int z, final Key<? extends Value<E>> key, final E value) {\n-        return null;\n-    }\n+        net.minecraft.entity.Entity entity = null;\n+        final double x = position.getX();\n+        final double y = position.getY();\n+        final double z = position.getZ();\n+        World thisWorld = this.shadow$getWorld();\n+        // Not all entities have a single World parameter as their constructor\n+        if (type == net.minecraft.entity.EntityType.LIGHTNING_BOLT) {\n+            entity = new LightningBoltEntity(thisWorld, x, y, z, false);\n+        }\n+        // TODO - archetypes should solve the problem of calling the correct constructor\n+        if (type == net.minecraft.entity.EntityType.ENDER_PEARL) {\n+            ArmorStandEntity tempEntity = new ArmorStandEntity(thisWorld, x, y, z);\n+            tempEntity.posY -= tempEntity.getEyeHeight();\n+            entity = new EnderPearlEntity(thisWorld, tempEntity);\n+            ((EnderPearl) entity).offer(Keys.SHOOTER, UnknownProjectileSource.UNKNOWN);\n+        }\n+        // Some entities need to have non-null fields (and the easiest way to\n+        // set them is to use the more specialised constructor).\n+        if (type == net.minecraft.entity.EntityType.FALLING_BLOCK) {\n+            entity = new FallingBlockEntity(thisWorld, x, y, z, Blocks.SAND.getDefaultState());\n+        }\n+        if (type == net.minecraft.entity.EntityType.ITEM) {\n+            entity = new ItemEntity(thisWorld, x, y, z, new ItemStack(Blocks.STONE));\n+        }\n \n-    @Override\n-    default DataTransactionResult remove(final int x, final int y, final int z, final Key<?> key) {\n-        return null;\n-    }\n+        if (entity == null) {\n+            try {\n+                entity = ((net.minecraft.entity.EntityType) type).create(thisWorld);\n+                entity.setPosition(x, y, z);\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"There was an issue attempting to construct \" + type.getKey(), e);\n+            }\n+        }\n \n-    @Override\n-    default DataTransactionResult undo(final int x, final int y, final int z, final DataTransactionResult result) {\n-        return null;\n-    }\n+        // TODO - replace this with an actual check\n+        /*\n+        if (entity instanceof EntityHanging) {\n+            if (((EntityHanging) entity).facingDirection == null) {\n+                // TODO Some sort of detection of a valid direction?\n+                // i.e scan immediate blocks for something to attach onto.\n+                ((EntityHanging) entity).facingDirection = EnumFacing.NORTH;\n+            }\n+            if (!((EntityHanging) entity).onValidSurface()) {\n+                return Optional.empty();\n+            }\n+        }*/\n+\n+        if (naturally && entity instanceof MobEntity) {\n+            // Adding the default equipment\n+            final DifficultyInstance difficulty = this.shadow$getDifficultyForLocation(new BlockPos(x, y, z));\n+            ((MobEntityAccessor)entity).accessor$setEquipmentBasedOnDifficulty(difficulty);\n+        }\n \n-    @Override\n-    default DataTransactionResult copyFrom(final int xTo, final int yTo, final int zTo, final DataHolder from) {\n-        return null;\n-    }\n+        if (entity instanceof PaintingEntity) {\n+            // This is default when art is null when reading from NBT, could\n+            // choose a random art instead?\n+            ((PaintingEntity) entity).art = PaintingType.KEBAB;\n+        }\n \n-    @Override\n-    default DataTransactionResult copyFrom(\n-        final int xTo, final int yTo, final int zTo, final DataHolder from, final MergeFunction function) {\n-        return null;\n+        return (Entity) entity;\n     }\n \n     @Override\n-    default DataTransactionResult copyFrom(final int xTo, final int yTo, final int zTo, final int xFrom, final int yFrom, final int zFrom, final MergeFunction function) {\n-        return null;\n-    }\n+    default Collection<Entity> spawnEntities(final Iterable<? extends Entity> entities) {\n+        final List<Entity> entitiesToSpawn = new NonNullArrayList<>();\n+        entities.forEach(entitiesToSpawn::add);\n+        final SpawnEntityEvent.Custom event = SpongeEventFactory\n+                .createSpawnEntityEventCustom(Sponge.getCauseStackManager().getCurrentCause(), entitiesToSpawn);\n+        if (Sponge.getEventManager().post(event)) {\n+            return ImmutableList.of();\n+        }\n+        for (final Entity entity : event.getEntities()) {\n+            EntityUtil.processEntitySpawn(entity, Optional::empty);\n+        }\n \n-    @Override\n-    default boolean validateRawData(final int x, final int y, final int z, final DataView container) {\n-        return false;\n+        final ImmutableList.Builder<Entity> builder = ImmutableList.builder();\n+        for (final Entity entity : event.getEntities()) {\n+            builder.add(entity);\n+        }\n+        return builder.build();\n     }\n \n     @Override\n-    default void setRawData(final int x, final int y, final int z, final DataView container) throws InvalidDataException {\n+    default boolean spawnEntity(Entity entity) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97efe8819ab46ab6f42600514cf899f3759d990b"}, "originalPosition": 359}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NjQwNTE2OnYy", "diffSide": "RIGHT", "path": "src/mixins/java/org/spongepowered/common/mixin/api/mcp/world/WorldMixin_API.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNjoxNjowM1rOGqYS9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNjoxNjowM1rOGqYS9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA5MTQ0Ng==", "bodyText": "@gabizou move this up to ServerWorld?", "url": "https://github.com/SpongePowered/Sponge/pull/2627#discussion_r447091446", "createdAt": "2020-06-29T16:16:03Z", "author": {"login": "Faithcaio"}, "path": "src/mixins/java/org/spongepowered/common/mixin/api/mcp/world/WorldMixin_API.java", "diffHunk": "@@ -58,319 +57,457 @@\n import net.minecraft.world.chunk.IChunk;\n import net.minecraft.world.dimension.Dimension;\n import net.minecraft.world.gen.Heightmap;\n-import net.minecraft.world.storage.MapData;\n+import net.minecraft.world.server.ServerChunkProvider;\n import net.minecraft.world.storage.WorldInfo;\n-import org.apache.logging.log4j.Logger;\n import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.spongepowered.api.Server;\n import org.spongepowered.api.block.BlockSnapshot;\n+import org.spongepowered.api.data.Keys;\n+import org.spongepowered.api.effect.particle.ParticleEffect;\n+import org.spongepowered.api.effect.sound.SoundType;\n+import org.spongepowered.api.effect.sound.music.MusicDisc;\n import org.spongepowered.api.entity.living.player.Player;\n import org.spongepowered.api.service.context.Context;\n+import org.spongepowered.api.service.context.Context;\n+import org.spongepowered.api.text.BookView;\n+import org.spongepowered.api.text.title.Title;\n+import org.spongepowered.api.util.TemporalUnits;\n import org.spongepowered.api.world.BlockChangeFlag;\n+import org.spongepowered.api.world.BlockChangeFlags;\n+import org.spongepowered.api.world.BoundedWorldView;\n+import org.spongepowered.api.world.HeightTypes;\n import org.spongepowered.api.world.ServerLocation;\n import org.spongepowered.api.world.World;\n import org.spongepowered.api.world.chunk.Chunk;\n import org.spongepowered.api.world.volume.archetype.ArchetypeVolume;\n import org.spongepowered.api.world.weather.Weather;\n+import org.spongepowered.api.world.volume.archetype.ArchetypeVolume;\n+import org.spongepowered.api.world.volume.block.ImmutableBlockVolume;\n+import org.spongepowered.api.world.volume.block.UnmodifiableBlockVolume;\n+import org.spongepowered.api.world.volume.entity.ImmutableEntityVolume;\n+import org.spongepowered.api.world.volume.entity.UnmodifiableEntityVolume;\n+import org.spongepowered.api.world.weather.Weather;\n+import org.spongepowered.api.world.weather.Weathers;\n import org.spongepowered.asm.mixin.Final;\n import org.spongepowered.asm.mixin.Mixin;\n import org.spongepowered.asm.mixin.Shadow;\n+import org.spongepowered.common.SpongeImpl;\n+import org.spongepowered.common.accessor.network.play.server.SChangeBlockPacketAccessor;\n+import org.spongepowered.common.accessor.world.server.ChunkManagerAccessor;\n+import org.spongepowered.common.block.SpongeBlockSnapshotBuilder;\n+import org.spongepowered.common.bridge.world.ServerWorldBridge;\n+import org.spongepowered.common.bridge.world.chunk.ChunkBridge;\n+import org.spongepowered.common.effect.particle.SpongeParticleHelper;\n+import org.spongepowered.common.effect.record.SpongeRecordType;\n+import org.spongepowered.common.event.tracking.TrackingUtil;\n+import org.spongepowered.common.util.BookFaker;\n+import org.spongepowered.common.util.Constants;\n+import org.spongepowered.common.util.VecHelper;\n+import org.spongepowered.common.world.storage.SpongeChunkLayout;\n import org.spongepowered.math.vector.Vector3d;\n import org.spongepowered.math.vector.Vector3i;\n \n-import java.io.IOException;\n import java.time.Duration;\n+import java.util.ArrayList;\n import java.util.Collection;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Optional;\n import java.util.Random;\n import java.util.UUID;\n-import java.util.function.Consumer;\n import java.util.function.Predicate;\n+import java.util.function.Supplier;\n \n @Mixin(net.minecraft.world.World.class)\n public abstract class WorldMixin_API<W extends World<W>> implements IWorldMixin_API<W>, World<W>, IEnvironmentBlockReaderMixin_API, AutoCloseable {\n-    @Shadow protected static @Final Logger LOGGER;\n-    @Shadow private static @Final Direction[] FACING_VALUES;\n-    @Shadow public@Final List<TileEntity> loadedTileEntityList;\n-    @Shadow public@Final List<TileEntity> tickableTileEntities;\n-    @Shadow protected@Final List<TileEntity> addedTileEntityList;\n-    @Shadow protected @Final List<TileEntity> tileEntitiesToBeRemoved;\n-    @Shadow private @Final long cloudColour;\n-    @Shadow private @Final Thread mainThread;\n-    @Shadow private int skylightSubtracted;\n-    @Shadow protected int updateLCG;\n-    @Shadow protected @Final int DIST_HASH_MAGIC;\n-    @Shadow protected float prevRainingStrength;\n-    @Shadow protected float rainingStrength;\n-    @Shadow protected float prevThunderingStrength;\n-    @Shadow protected float thunderingStrength;\n-    @Shadow private int lastLightningBolt;\n+\n     @Shadow public @Final Random rand;\n-    @Shadow public @Final Dimension dimension;\n-    @Shadow protected @Final AbstractChunkProvider chunkProvider;\n     @Shadow protected @Final WorldInfo worldInfo;\n-    @Shadow private @Final IProfiler profiler;\n-    @Shadow public @Final boolean isRemote;\n-    @Shadow protected boolean processingLoadedTiles;\n-    @Shadow private @Final WorldBorder worldBorder;\n+\n     // Shadowed methods and fields for reference. All should be prefixed with 'shadow$' to avoid confusion\n \n     @Shadow public abstract Biome shadow$getBiome(BlockPos p_180494_1_);\n-    @Shadow public abstract boolean shadow$isRemote();\n     @Shadow public abstract @javax.annotation.Nullable MinecraftServer shadow$getServer();\n-    @Shadow public abstract BlockState shadow$getGroundAboveSeaLevel(BlockPos p_184141_1_);\n-    @Shadow public static boolean shadow$isValid(BlockPos p_175701_0_) {\n-        throw new UnsupportedOperationException(\"Shadowed isInWorldBounds\");\n-    }\n-    @Shadow public static boolean shadow$isOutsideBuildHeight(BlockPos p_189509_0_) {\n-        throw new UnsupportedOperationException(\"Shadowed isOutisdeBuildheight\");\n-    }\n-    @Shadow public static boolean shadow$isYOutOfBounds(int p_217405_0_) {\n-        throw new UnsupportedOperationException(\"Shadowed isOutsideBuildHeight\");\n-    }\n     @Shadow public abstract net.minecraft.world.chunk.Chunk shadow$getChunkAt(BlockPos p_175726_1_);\n-    @Shadow public abstract net.minecraft.world.chunk.Chunk shadow$getChunk(int p_212866_1_, int p_212866_2_);\n     @Shadow public abstract IChunk shadow$getChunk(int p_217353_1_, int p_217353_2_, ChunkStatus p_217353_3_, boolean p_217353_4_);\n     @Shadow public abstract boolean shadow$setBlockState(BlockPos p_180501_1_, BlockState p_180501_2_, int p_180501_3_);\n-    @Shadow public abstract void shadow$onBlockStateChange(BlockPos p_217393_1_, BlockState p_217393_2_, BlockState p_217393_3_);\n     @Shadow public abstract boolean shadow$removeBlock(BlockPos p_217377_1_, boolean p_217377_2_);\n     @Shadow public abstract boolean shadow$destroyBlock(BlockPos p_175655_1_, boolean p_175655_2_);\n-    @Shadow public abstract boolean shadow$setBlockState(BlockPos p_175656_1_, BlockState p_175656_2_);\n-    @Shadow public abstract void shadow$notifyBlockUpdate(BlockPos p_184138_1_, BlockState p_184138_2_, BlockState p_184138_3_, int p_184138_4_);\n-    @Shadow public abstract void shadow$notifyNeighbors(BlockPos p_195592_1_, Block p_195592_2_);\n-    @Shadow public abstract void shadow$func_225319_b(BlockPos p_225319_1_, BlockState p_225319_2_, BlockState p_225319_3_);\n-    @Shadow public abstract void shadow$notifyNeighborsOfStateChange(BlockPos p_195593_1_, Block p_195593_2_);\n-    @Shadow public abstract void shadow$notifyNeighborsOfStateExcept(BlockPos p_175695_1_, Block p_175695_2_, Direction p_175695_3_);\n-    @Shadow public abstract void shadow$neighborChanged(BlockPos p_190524_1_, Block p_190524_2_, BlockPos p_190524_3_);\n-    @Shadow public abstract int shadow$getLightSubtracted(BlockPos p_201669_1_, int p_201669_2_);\n     @Shadow public abstract int shadow$getHeight(Heightmap.Type p_201676_1_, int p_201676_2_, int p_201676_3_);\n     @Shadow public abstract int shadow$getLightFor(LightType p_175642_1_, BlockPos p_175642_2_);\n     @Shadow public abstract BlockState shadow$getBlockState(BlockPos p_180495_1_);\n-    @Shadow public abstract IFluidState getFluidState(BlockPos p_204610_1_);\n-    @Shadow public abstract boolean shadow$isDaytime();\n-    @Shadow public abstract void shadow$playSound(@javax.annotation.Nullable PlayerEntity p_184133_1_, BlockPos p_184133_2_, SoundEvent p_184133_3_, SoundCategory p_184133_4_, float p_184133_5_, float p_184133_6_);\n     @Shadow public abstract void shadow$playSound(@javax.annotation.Nullable PlayerEntity p_184148_1_, double p_184148_2_, double p_184148_4_, double p_184148_6_, SoundEvent p_184148_8_, SoundCategory p_184148_9_, float p_184148_10_, float p_184148_11_);\n-    @Shadow public abstract void shadow$playMovingSound(@javax.annotation.Nullable PlayerEntity p_217384_1_, Entity p_217384_2_, SoundEvent p_217384_3_, SoundCategory p_217384_4_, float p_217384_5_, float p_217384_6_);\n-    @Shadow public abstract void shadow$playSound(double p_184134_1_, double p_184134_3_, double p_184134_5_, SoundEvent p_184134_7_, SoundCategory p_184134_8_, float p_184134_9_, float p_184134_10_, boolean p_184134_11_);\n-    @Shadow public abstract void shadow$addParticle(IParticleData p_195594_1_, double p_195594_2_, double p_195594_4_, double p_195594_6_, double p_195594_8_, double p_195594_10_, double p_195594_12_);\n-    @Shadow public abstract void shadow$addOptionalParticle(IParticleData p_195589_1_, double p_195589_2_, double p_195589_4_, double p_195589_6_, double p_195589_8_, double p_195589_10_, double p_195589_12_);\n-    @Shadow public abstract void shadow$addOptionalParticle(IParticleData p_217404_1_, boolean p_217404_2_, double p_217404_3_, double p_217404_5_, double p_217404_7_, double p_217404_9_, double p_217404_11_, double p_217404_13_);\n-    @Shadow public abstract float shadow$getCelestialAngleRadians(float p_72929_1_);\n-    @Shadow public abstract boolean shadow$addTileEntity(TileEntity p_175700_1_);\n-    @Shadow public abstract void shadow$addTileEntities(Collection<TileEntity> p_147448_1_);\n-    @Shadow public abstract void shadow$tickBlockEntities(); // tileTileEntities\n-    @Shadow public abstract void shadow$guardEntityTick(Consumer<Entity> p_217390_1_, Entity p_217390_2_);\n-    @Shadow public abstract boolean shadow$checkBlockCollision(AxisAlignedBB p_72829_1_);\n-    @Shadow public abstract boolean shadow$isFlammableWithin(AxisAlignedBB p_147470_1_);\n-    @Shadow public abstract boolean shadow$isMaterialInBB(AxisAlignedBB p_72875_1_, Material p_72875_2_);\n-    @Shadow public abstract net.minecraft.world.Explosion shadow$createExplosion(@javax.annotation.Nullable Entity p_217385_1_, double p_217385_2_, double p_217385_4_, double p_217385_6_, float p_217385_8_, net.minecraft.world.Explosion.Mode p_217385_9_);\n-    @Shadow public abstract net.minecraft.world.Explosion shadow$createExplosion(@javax.annotation.Nullable Entity p_217398_1_, double p_217398_2_, double p_217398_4_, double p_217398_6_, float p_217398_8_, boolean p_217398_9_, net.minecraft.world.Explosion.Mode p_217398_10_);\n-    @Shadow public abstract net.minecraft.world.Explosion shadow$createExplosion(@javax.annotation.Nullable Entity p_217401_1_, @javax.annotation.Nullable DamageSource p_217401_2_, double p_217401_3_, double p_217401_5_, double p_217401_7_, float p_217401_9_, boolean p_217401_10_, net.minecraft.world.Explosion.Mode p_217401_11_);\n-    @Shadow public abstract boolean shadow$extinguishFire(@javax.annotation.Nullable PlayerEntity p_175719_1_, BlockPos p_175719_2_, Direction p_175719_3_);\n     @Shadow public abstract @javax.annotation.Nullable TileEntity shadow$getTileEntity(BlockPos p_175625_1_);\n-    @Shadow private @javax.annotation.Nullable TileEntity shadow$getPendingTileEntityAt(BlockPos p_189508_1_) {\n-        // Shadowed\n-        return null;\n-    }\n-    @Shadow public abstract void shadow$setTileEntity(BlockPos p_175690_1_, @javax.annotation.Nullable TileEntity p_175690_2_);\n-    @Shadow public abstract void shadow$removeTileEntity(BlockPos p_175713_1_);\n-    @Shadow public abstract boolean shadow$isBlockPresent(BlockPos p_195588_1_);\n-    @Shadow public abstract boolean shadow$isTopSolid(BlockPos p_217400_1_, Entity p_217400_2_) ;\n-    @Shadow public abstract void shadow$calculateInitialSkylight();\n-    @Shadow public abstract void shadow$setAllowedSpawnTypes(boolean p_72891_1_, boolean p_72891_2_);\n-    @Shadow protected abstract void shadow$calculateInitialWeather();\n-    @Shadow public abstract void shadow$close() throws IOException;\n-    @Shadow public abstract ChunkStatus shadow$getChunkStatus();\n     @Shadow public abstract List<Entity> shadow$getEntitiesInAABBexcluding(@javax.annotation.Nullable Entity p_175674_1_, AxisAlignedBB p_175674_2_, @javax.annotation.Nullable Predicate<? super Entity> p_175674_3_);\n-    @Shadow public abstract List<Entity> shadow$getEntitiesWithinAABB(@javax.annotation.Nullable EntityType<?> p_217394_1_, AxisAlignedBB p_217394_2_, Predicate<? super Entity> p_217394_3_);\n     @Shadow public abstract <T extends Entity> List<T> shadow$getEntitiesWithinAABB(Class<? extends T> p_175647_1_, AxisAlignedBB p_175647_2_, @javax.annotation.Nullable Predicate<? super T> p_175647_3_);\n-    @Shadow public abstract <T extends Entity> List<T> shadow$func_225316_b(Class<? extends T> p_225316_1_, AxisAlignedBB p_225316_2_, @javax.annotation.Nullable Predicate<? super T> p_225316_3_);\n-    @Shadow public abstract @javax.annotation.Nullable Entity shadow$getEntityByID(int p_73045_1_);\n-    @Shadow public abstract void shadow$markChunkDirty(BlockPos p_175646_1_, TileEntity p_175646_2_);\n     @Shadow public abstract int shadow$getSeaLevel();\n-    @Shadow public abstract net.minecraft.world.World shadow$getWorld();\n-    @Shadow public abstract WorldType shadow$getWorldType();\n-    @Shadow public abstract int shadow$getStrongPower(BlockPos p_175676_1_);\n-    @Shadow public abstract boolean shadow$isSidePowered(BlockPos p_175709_1_, Direction p_175709_2_);\n-    @Shadow public abstract int shadow$getRedstonePower(BlockPos p_175651_1_, Direction p_175651_2_);\n-    @Shadow public abstract boolean shadow$isBlockPowered(BlockPos p_175640_1_);\n-    @Shadow public abstract int shadow$getRedstonePowerFromNeighbors(BlockPos p_175687_1_);\n-    @Shadow public abstract void shadow$setGameTime(long gametime);\n     @Shadow public abstract long shadow$getSeed();\n-    @Shadow public abstract long shadow$getGameTime();\n-    @Shadow public abstract long shadow$getDayTime();\n-    @Shadow public abstract void shadow$setDayTime(long delay);\n-    @Shadow protected abstract void shadow$advanceTime();\n-    @Shadow public abstract BlockPos shadow$getSpawnPoint();\n-    @Shadow public abstract void shadow$setSpawnPoint(BlockPos p_175652_1_);\n-    @Shadow public abstract boolean shadow$isBlockModifiable(PlayerEntity p_175660_1_, BlockPos p_175660_2_);\n-    @Shadow public abstract void shadow$setEntityState(Entity p_72960_1_, byte p_72960_2_);\n     @Shadow public abstract AbstractChunkProvider shadow$getChunkProvider();\n-    @Shadow public abstract void shadow$addBlockEvent(BlockPos p_175641_1_, Block p_175641_2_, int p_175641_3_, int p_175641_4_);\n     @Shadow public abstract WorldInfo shadow$getWorldInfo();\n-    @Shadow public abstract GameRules shadow$getGameRules();\n-    @Shadow public abstract float shadow$getThunderStrength(float p_72819_1_);\n-    @Shadow public abstract float shadow$getRainStrength(float p_72867_1_);\n     @Shadow public abstract boolean shadow$isThundering();\n     @Shadow public abstract boolean shadow$isRaining();\n-    @Shadow public abstract boolean shadow$isRainingAt(BlockPos p_175727_1_);\n-    @Shadow public abstract boolean shadow$isBlockinHighHumidity(BlockPos p_180502_1_);\n-    @Shadow public abstract @javax.annotation.Nullable MapData shadow$getMapData(String p_217406_1_);\n-    @Shadow public abstract void shadow$registerMapData(MapData p_217399_1_);\n-    @Shadow public abstract int shadow$getNextMapId();\n-    @Shadow public abstract void shadow$playBroadcastSound(int p_175669_1_, BlockPos p_175669_2_, int p_175669_3_);\n-    @Shadow public abstract int shadow$getActualHeight();\n-    @Shadow public abstract CrashReportCategory shadow$fillCrashReport(CrashReport p_72914_1_);\n-    @Shadow public abstract void shadow$sendBlockBreakProgress(int p_175715_1_, BlockPos p_175715_2_, int p_175715_3_);\n-    @Shadow public abstract Scoreboard shadow$getScoreboard();\n-    @Shadow public abstract void shadow$updateComparatorOutputLevel(BlockPos p_175666_1_, Block p_175666_2_);\n     @Shadow public abstract DifficultyInstance shadow$getDifficultyForLocation(BlockPos p_175649_1_);\n     @Shadow public abstract int shadow$getSkylightSubtracted();\n-    @Shadow public abstract void shadow$setLastLightningBolt(int p_175702_1_);\n     @Shadow public abstract WorldBorder shadow$getWorldBorder();\n-    @Shadow public abstract void shadow$sendPacketToServer(IPacket<?> p_184135_1_);\n-    @Shadow public abstract @javax.annotation.Nullable BlockPos shadow$findNearestStructure(String p_211157_1_, BlockPos p_211157_2_, int p_211157_3_, boolean p_211157_4_);\n     @Shadow public abstract Dimension shadow$getDimension();\n     @Shadow public abstract Random shadow$getRandom();\n     @Shadow public abstract boolean shadow$hasBlockState(BlockPos p_217375_1_, Predicate<BlockState> p_217375_2_);\n-    @Shadow public abstract RecipeManager shadow$getRecipeManager();\n-    @Shadow public abstract NetworkTagManager shadow$getTags();\n-    @Shadow public abstract BlockPos shadow$getBlockRandomPos(int p_217383_1_, int p_217383_2_, int p_217383_3_, int p_217383_4_);\n-    @Shadow public abstract boolean shadow$isSaveDisabled();\n-    @Shadow public abstract IProfiler shadow$getProfiler();\n     @Shadow public abstract BlockPos shadow$getHeight(Heightmap.Type p_205770_1_, BlockPos p_205770_2_);\n \n+    // World\n+\n+    @Override\n+    public Server getServer() {\n+        // TODO API Optional or remove from non ServerWorld?\n+        throw new UnsupportedOperationException(\"implement me\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "842adf2f757a8d0a1585ed74f0ba85a0ec45fd8f"}, "originalPosition": 275}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NjQwNjY0OnYy", "diffSide": "RIGHT", "path": "src/mixins/java/org/spongepowered/common/mixin/api/mcp/world/WorldMixin_API.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNjoxNjoyN1rOGqYT1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNjoxNjoyN1rOGqYT1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA5MTY2OQ==", "bodyText": "@gabizou move LocationCreator up to ServerWorld?", "url": "https://github.com/SpongePowered/Sponge/pull/2627#discussion_r447091669", "createdAt": "2020-06-29T16:16:27Z", "author": {"login": "Faithcaio"}, "path": "src/mixins/java/org/spongepowered/common/mixin/api/mcp/world/WorldMixin_API.java", "diffHunk": "@@ -58,319 +57,457 @@\n import net.minecraft.world.chunk.IChunk;\n import net.minecraft.world.dimension.Dimension;\n import net.minecraft.world.gen.Heightmap;\n-import net.minecraft.world.storage.MapData;\n+import net.minecraft.world.server.ServerChunkProvider;\n import net.minecraft.world.storage.WorldInfo;\n-import org.apache.logging.log4j.Logger;\n import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.spongepowered.api.Server;\n import org.spongepowered.api.block.BlockSnapshot;\n+import org.spongepowered.api.data.Keys;\n+import org.spongepowered.api.effect.particle.ParticleEffect;\n+import org.spongepowered.api.effect.sound.SoundType;\n+import org.spongepowered.api.effect.sound.music.MusicDisc;\n import org.spongepowered.api.entity.living.player.Player;\n import org.spongepowered.api.service.context.Context;\n+import org.spongepowered.api.service.context.Context;\n+import org.spongepowered.api.text.BookView;\n+import org.spongepowered.api.text.title.Title;\n+import org.spongepowered.api.util.TemporalUnits;\n import org.spongepowered.api.world.BlockChangeFlag;\n+import org.spongepowered.api.world.BlockChangeFlags;\n+import org.spongepowered.api.world.BoundedWorldView;\n+import org.spongepowered.api.world.HeightTypes;\n import org.spongepowered.api.world.ServerLocation;\n import org.spongepowered.api.world.World;\n import org.spongepowered.api.world.chunk.Chunk;\n import org.spongepowered.api.world.volume.archetype.ArchetypeVolume;\n import org.spongepowered.api.world.weather.Weather;\n+import org.spongepowered.api.world.volume.archetype.ArchetypeVolume;\n+import org.spongepowered.api.world.volume.block.ImmutableBlockVolume;\n+import org.spongepowered.api.world.volume.block.UnmodifiableBlockVolume;\n+import org.spongepowered.api.world.volume.entity.ImmutableEntityVolume;\n+import org.spongepowered.api.world.volume.entity.UnmodifiableEntityVolume;\n+import org.spongepowered.api.world.weather.Weather;\n+import org.spongepowered.api.world.weather.Weathers;\n import org.spongepowered.asm.mixin.Final;\n import org.spongepowered.asm.mixin.Mixin;\n import org.spongepowered.asm.mixin.Shadow;\n+import org.spongepowered.common.SpongeImpl;\n+import org.spongepowered.common.accessor.network.play.server.SChangeBlockPacketAccessor;\n+import org.spongepowered.common.accessor.world.server.ChunkManagerAccessor;\n+import org.spongepowered.common.block.SpongeBlockSnapshotBuilder;\n+import org.spongepowered.common.bridge.world.ServerWorldBridge;\n+import org.spongepowered.common.bridge.world.chunk.ChunkBridge;\n+import org.spongepowered.common.effect.particle.SpongeParticleHelper;\n+import org.spongepowered.common.effect.record.SpongeRecordType;\n+import org.spongepowered.common.event.tracking.TrackingUtil;\n+import org.spongepowered.common.util.BookFaker;\n+import org.spongepowered.common.util.Constants;\n+import org.spongepowered.common.util.VecHelper;\n+import org.spongepowered.common.world.storage.SpongeChunkLayout;\n import org.spongepowered.math.vector.Vector3d;\n import org.spongepowered.math.vector.Vector3i;\n \n-import java.io.IOException;\n import java.time.Duration;\n+import java.util.ArrayList;\n import java.util.Collection;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Optional;\n import java.util.Random;\n import java.util.UUID;\n-import java.util.function.Consumer;\n import java.util.function.Predicate;\n+import java.util.function.Supplier;\n \n @Mixin(net.minecraft.world.World.class)\n public abstract class WorldMixin_API<W extends World<W>> implements IWorldMixin_API<W>, World<W>, IEnvironmentBlockReaderMixin_API, AutoCloseable {\n-    @Shadow protected static @Final Logger LOGGER;\n-    @Shadow private static @Final Direction[] FACING_VALUES;\n-    @Shadow public@Final List<TileEntity> loadedTileEntityList;\n-    @Shadow public@Final List<TileEntity> tickableTileEntities;\n-    @Shadow protected@Final List<TileEntity> addedTileEntityList;\n-    @Shadow protected @Final List<TileEntity> tileEntitiesToBeRemoved;\n-    @Shadow private @Final long cloudColour;\n-    @Shadow private @Final Thread mainThread;\n-    @Shadow private int skylightSubtracted;\n-    @Shadow protected int updateLCG;\n-    @Shadow protected @Final int DIST_HASH_MAGIC;\n-    @Shadow protected float prevRainingStrength;\n-    @Shadow protected float rainingStrength;\n-    @Shadow protected float prevThunderingStrength;\n-    @Shadow protected float thunderingStrength;\n-    @Shadow private int lastLightningBolt;\n+\n     @Shadow public @Final Random rand;\n-    @Shadow public @Final Dimension dimension;\n-    @Shadow protected @Final AbstractChunkProvider chunkProvider;\n     @Shadow protected @Final WorldInfo worldInfo;\n-    @Shadow private @Final IProfiler profiler;\n-    @Shadow public @Final boolean isRemote;\n-    @Shadow protected boolean processingLoadedTiles;\n-    @Shadow private @Final WorldBorder worldBorder;\n+\n     // Shadowed methods and fields for reference. All should be prefixed with 'shadow$' to avoid confusion\n \n     @Shadow public abstract Biome shadow$getBiome(BlockPos p_180494_1_);\n-    @Shadow public abstract boolean shadow$isRemote();\n     @Shadow public abstract @javax.annotation.Nullable MinecraftServer shadow$getServer();\n-    @Shadow public abstract BlockState shadow$getGroundAboveSeaLevel(BlockPos p_184141_1_);\n-    @Shadow public static boolean shadow$isValid(BlockPos p_175701_0_) {\n-        throw new UnsupportedOperationException(\"Shadowed isInWorldBounds\");\n-    }\n-    @Shadow public static boolean shadow$isOutsideBuildHeight(BlockPos p_189509_0_) {\n-        throw new UnsupportedOperationException(\"Shadowed isOutisdeBuildheight\");\n-    }\n-    @Shadow public static boolean shadow$isYOutOfBounds(int p_217405_0_) {\n-        throw new UnsupportedOperationException(\"Shadowed isOutsideBuildHeight\");\n-    }\n     @Shadow public abstract net.minecraft.world.chunk.Chunk shadow$getChunkAt(BlockPos p_175726_1_);\n-    @Shadow public abstract net.minecraft.world.chunk.Chunk shadow$getChunk(int p_212866_1_, int p_212866_2_);\n     @Shadow public abstract IChunk shadow$getChunk(int p_217353_1_, int p_217353_2_, ChunkStatus p_217353_3_, boolean p_217353_4_);\n     @Shadow public abstract boolean shadow$setBlockState(BlockPos p_180501_1_, BlockState p_180501_2_, int p_180501_3_);\n-    @Shadow public abstract void shadow$onBlockStateChange(BlockPos p_217393_1_, BlockState p_217393_2_, BlockState p_217393_3_);\n     @Shadow public abstract boolean shadow$removeBlock(BlockPos p_217377_1_, boolean p_217377_2_);\n     @Shadow public abstract boolean shadow$destroyBlock(BlockPos p_175655_1_, boolean p_175655_2_);\n-    @Shadow public abstract boolean shadow$setBlockState(BlockPos p_175656_1_, BlockState p_175656_2_);\n-    @Shadow public abstract void shadow$notifyBlockUpdate(BlockPos p_184138_1_, BlockState p_184138_2_, BlockState p_184138_3_, int p_184138_4_);\n-    @Shadow public abstract void shadow$notifyNeighbors(BlockPos p_195592_1_, Block p_195592_2_);\n-    @Shadow public abstract void shadow$func_225319_b(BlockPos p_225319_1_, BlockState p_225319_2_, BlockState p_225319_3_);\n-    @Shadow public abstract void shadow$notifyNeighborsOfStateChange(BlockPos p_195593_1_, Block p_195593_2_);\n-    @Shadow public abstract void shadow$notifyNeighborsOfStateExcept(BlockPos p_175695_1_, Block p_175695_2_, Direction p_175695_3_);\n-    @Shadow public abstract void shadow$neighborChanged(BlockPos p_190524_1_, Block p_190524_2_, BlockPos p_190524_3_);\n-    @Shadow public abstract int shadow$getLightSubtracted(BlockPos p_201669_1_, int p_201669_2_);\n     @Shadow public abstract int shadow$getHeight(Heightmap.Type p_201676_1_, int p_201676_2_, int p_201676_3_);\n     @Shadow public abstract int shadow$getLightFor(LightType p_175642_1_, BlockPos p_175642_2_);\n     @Shadow public abstract BlockState shadow$getBlockState(BlockPos p_180495_1_);\n-    @Shadow public abstract IFluidState getFluidState(BlockPos p_204610_1_);\n-    @Shadow public abstract boolean shadow$isDaytime();\n-    @Shadow public abstract void shadow$playSound(@javax.annotation.Nullable PlayerEntity p_184133_1_, BlockPos p_184133_2_, SoundEvent p_184133_3_, SoundCategory p_184133_4_, float p_184133_5_, float p_184133_6_);\n     @Shadow public abstract void shadow$playSound(@javax.annotation.Nullable PlayerEntity p_184148_1_, double p_184148_2_, double p_184148_4_, double p_184148_6_, SoundEvent p_184148_8_, SoundCategory p_184148_9_, float p_184148_10_, float p_184148_11_);\n-    @Shadow public abstract void shadow$playMovingSound(@javax.annotation.Nullable PlayerEntity p_217384_1_, Entity p_217384_2_, SoundEvent p_217384_3_, SoundCategory p_217384_4_, float p_217384_5_, float p_217384_6_);\n-    @Shadow public abstract void shadow$playSound(double p_184134_1_, double p_184134_3_, double p_184134_5_, SoundEvent p_184134_7_, SoundCategory p_184134_8_, float p_184134_9_, float p_184134_10_, boolean p_184134_11_);\n-    @Shadow public abstract void shadow$addParticle(IParticleData p_195594_1_, double p_195594_2_, double p_195594_4_, double p_195594_6_, double p_195594_8_, double p_195594_10_, double p_195594_12_);\n-    @Shadow public abstract void shadow$addOptionalParticle(IParticleData p_195589_1_, double p_195589_2_, double p_195589_4_, double p_195589_6_, double p_195589_8_, double p_195589_10_, double p_195589_12_);\n-    @Shadow public abstract void shadow$addOptionalParticle(IParticleData p_217404_1_, boolean p_217404_2_, double p_217404_3_, double p_217404_5_, double p_217404_7_, double p_217404_9_, double p_217404_11_, double p_217404_13_);\n-    @Shadow public abstract float shadow$getCelestialAngleRadians(float p_72929_1_);\n-    @Shadow public abstract boolean shadow$addTileEntity(TileEntity p_175700_1_);\n-    @Shadow public abstract void shadow$addTileEntities(Collection<TileEntity> p_147448_1_);\n-    @Shadow public abstract void shadow$tickBlockEntities(); // tileTileEntities\n-    @Shadow public abstract void shadow$guardEntityTick(Consumer<Entity> p_217390_1_, Entity p_217390_2_);\n-    @Shadow public abstract boolean shadow$checkBlockCollision(AxisAlignedBB p_72829_1_);\n-    @Shadow public abstract boolean shadow$isFlammableWithin(AxisAlignedBB p_147470_1_);\n-    @Shadow public abstract boolean shadow$isMaterialInBB(AxisAlignedBB p_72875_1_, Material p_72875_2_);\n-    @Shadow public abstract net.minecraft.world.Explosion shadow$createExplosion(@javax.annotation.Nullable Entity p_217385_1_, double p_217385_2_, double p_217385_4_, double p_217385_6_, float p_217385_8_, net.minecraft.world.Explosion.Mode p_217385_9_);\n-    @Shadow public abstract net.minecraft.world.Explosion shadow$createExplosion(@javax.annotation.Nullable Entity p_217398_1_, double p_217398_2_, double p_217398_4_, double p_217398_6_, float p_217398_8_, boolean p_217398_9_, net.minecraft.world.Explosion.Mode p_217398_10_);\n-    @Shadow public abstract net.minecraft.world.Explosion shadow$createExplosion(@javax.annotation.Nullable Entity p_217401_1_, @javax.annotation.Nullable DamageSource p_217401_2_, double p_217401_3_, double p_217401_5_, double p_217401_7_, float p_217401_9_, boolean p_217401_10_, net.minecraft.world.Explosion.Mode p_217401_11_);\n-    @Shadow public abstract boolean shadow$extinguishFire(@javax.annotation.Nullable PlayerEntity p_175719_1_, BlockPos p_175719_2_, Direction p_175719_3_);\n     @Shadow public abstract @javax.annotation.Nullable TileEntity shadow$getTileEntity(BlockPos p_175625_1_);\n-    @Shadow private @javax.annotation.Nullable TileEntity shadow$getPendingTileEntityAt(BlockPos p_189508_1_) {\n-        // Shadowed\n-        return null;\n-    }\n-    @Shadow public abstract void shadow$setTileEntity(BlockPos p_175690_1_, @javax.annotation.Nullable TileEntity p_175690_2_);\n-    @Shadow public abstract void shadow$removeTileEntity(BlockPos p_175713_1_);\n-    @Shadow public abstract boolean shadow$isBlockPresent(BlockPos p_195588_1_);\n-    @Shadow public abstract boolean shadow$isTopSolid(BlockPos p_217400_1_, Entity p_217400_2_) ;\n-    @Shadow public abstract void shadow$calculateInitialSkylight();\n-    @Shadow public abstract void shadow$setAllowedSpawnTypes(boolean p_72891_1_, boolean p_72891_2_);\n-    @Shadow protected abstract void shadow$calculateInitialWeather();\n-    @Shadow public abstract void shadow$close() throws IOException;\n-    @Shadow public abstract ChunkStatus shadow$getChunkStatus();\n     @Shadow public abstract List<Entity> shadow$getEntitiesInAABBexcluding(@javax.annotation.Nullable Entity p_175674_1_, AxisAlignedBB p_175674_2_, @javax.annotation.Nullable Predicate<? super Entity> p_175674_3_);\n-    @Shadow public abstract List<Entity> shadow$getEntitiesWithinAABB(@javax.annotation.Nullable EntityType<?> p_217394_1_, AxisAlignedBB p_217394_2_, Predicate<? super Entity> p_217394_3_);\n     @Shadow public abstract <T extends Entity> List<T> shadow$getEntitiesWithinAABB(Class<? extends T> p_175647_1_, AxisAlignedBB p_175647_2_, @javax.annotation.Nullable Predicate<? super T> p_175647_3_);\n-    @Shadow public abstract <T extends Entity> List<T> shadow$func_225316_b(Class<? extends T> p_225316_1_, AxisAlignedBB p_225316_2_, @javax.annotation.Nullable Predicate<? super T> p_225316_3_);\n-    @Shadow public abstract @javax.annotation.Nullable Entity shadow$getEntityByID(int p_73045_1_);\n-    @Shadow public abstract void shadow$markChunkDirty(BlockPos p_175646_1_, TileEntity p_175646_2_);\n     @Shadow public abstract int shadow$getSeaLevel();\n-    @Shadow public abstract net.minecraft.world.World shadow$getWorld();\n-    @Shadow public abstract WorldType shadow$getWorldType();\n-    @Shadow public abstract int shadow$getStrongPower(BlockPos p_175676_1_);\n-    @Shadow public abstract boolean shadow$isSidePowered(BlockPos p_175709_1_, Direction p_175709_2_);\n-    @Shadow public abstract int shadow$getRedstonePower(BlockPos p_175651_1_, Direction p_175651_2_);\n-    @Shadow public abstract boolean shadow$isBlockPowered(BlockPos p_175640_1_);\n-    @Shadow public abstract int shadow$getRedstonePowerFromNeighbors(BlockPos p_175687_1_);\n-    @Shadow public abstract void shadow$setGameTime(long gametime);\n     @Shadow public abstract long shadow$getSeed();\n-    @Shadow public abstract long shadow$getGameTime();\n-    @Shadow public abstract long shadow$getDayTime();\n-    @Shadow public abstract void shadow$setDayTime(long delay);\n-    @Shadow protected abstract void shadow$advanceTime();\n-    @Shadow public abstract BlockPos shadow$getSpawnPoint();\n-    @Shadow public abstract void shadow$setSpawnPoint(BlockPos p_175652_1_);\n-    @Shadow public abstract boolean shadow$isBlockModifiable(PlayerEntity p_175660_1_, BlockPos p_175660_2_);\n-    @Shadow public abstract void shadow$setEntityState(Entity p_72960_1_, byte p_72960_2_);\n     @Shadow public abstract AbstractChunkProvider shadow$getChunkProvider();\n-    @Shadow public abstract void shadow$addBlockEvent(BlockPos p_175641_1_, Block p_175641_2_, int p_175641_3_, int p_175641_4_);\n     @Shadow public abstract WorldInfo shadow$getWorldInfo();\n-    @Shadow public abstract GameRules shadow$getGameRules();\n-    @Shadow public abstract float shadow$getThunderStrength(float p_72819_1_);\n-    @Shadow public abstract float shadow$getRainStrength(float p_72867_1_);\n     @Shadow public abstract boolean shadow$isThundering();\n     @Shadow public abstract boolean shadow$isRaining();\n-    @Shadow public abstract boolean shadow$isRainingAt(BlockPos p_175727_1_);\n-    @Shadow public abstract boolean shadow$isBlockinHighHumidity(BlockPos p_180502_1_);\n-    @Shadow public abstract @javax.annotation.Nullable MapData shadow$getMapData(String p_217406_1_);\n-    @Shadow public abstract void shadow$registerMapData(MapData p_217399_1_);\n-    @Shadow public abstract int shadow$getNextMapId();\n-    @Shadow public abstract void shadow$playBroadcastSound(int p_175669_1_, BlockPos p_175669_2_, int p_175669_3_);\n-    @Shadow public abstract int shadow$getActualHeight();\n-    @Shadow public abstract CrashReportCategory shadow$fillCrashReport(CrashReport p_72914_1_);\n-    @Shadow public abstract void shadow$sendBlockBreakProgress(int p_175715_1_, BlockPos p_175715_2_, int p_175715_3_);\n-    @Shadow public abstract Scoreboard shadow$getScoreboard();\n-    @Shadow public abstract void shadow$updateComparatorOutputLevel(BlockPos p_175666_1_, Block p_175666_2_);\n     @Shadow public abstract DifficultyInstance shadow$getDifficultyForLocation(BlockPos p_175649_1_);\n     @Shadow public abstract int shadow$getSkylightSubtracted();\n-    @Shadow public abstract void shadow$setLastLightningBolt(int p_175702_1_);\n     @Shadow public abstract WorldBorder shadow$getWorldBorder();\n-    @Shadow public abstract void shadow$sendPacketToServer(IPacket<?> p_184135_1_);\n-    @Shadow public abstract @javax.annotation.Nullable BlockPos shadow$findNearestStructure(String p_211157_1_, BlockPos p_211157_2_, int p_211157_3_, boolean p_211157_4_);\n     @Shadow public abstract Dimension shadow$getDimension();\n     @Shadow public abstract Random shadow$getRandom();\n     @Shadow public abstract boolean shadow$hasBlockState(BlockPos p_217375_1_, Predicate<BlockState> p_217375_2_);\n-    @Shadow public abstract RecipeManager shadow$getRecipeManager();\n-    @Shadow public abstract NetworkTagManager shadow$getTags();\n-    @Shadow public abstract BlockPos shadow$getBlockRandomPos(int p_217383_1_, int p_217383_2_, int p_217383_3_, int p_217383_4_);\n-    @Shadow public abstract boolean shadow$isSaveDisabled();\n-    @Shadow public abstract IProfiler shadow$getProfiler();\n     @Shadow public abstract BlockPos shadow$getHeight(Heightmap.Type p_205770_1_, BlockPos p_205770_2_);\n \n+    // World\n+\n+    @Override\n+    public Server getServer() {\n+        // TODO API Optional or remove from non ServerWorld?\n+        throw new UnsupportedOperationException(\"implement me\");\n+    }\n+\n+    @Override\n+    public boolean isLoaded() {\n+        return SpongeImpl.getWorldManager().getWorld(this.shadow$getDimension().getType()) == (Object) this;\n+    }\n+\n     @Override\n+    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n     public Optional<? extends Player> getClosestPlayer(int x, int y, int z, double distance, Predicate<? super Player> predicate) {\n-        return Optional.empty();\n+        final PlayerEntity player = this.shadow$getClosestPlayer(x, y, z, distance, (Predicate) predicate);\n+        return Optional.ofNullable((Player) player);\n     }\n \n     @Override\n     public BlockSnapshot createSnapshot(int x, int y, int z) {\n-        return null;\n+        if (!this.containsBlock(x, y, z)) {\n+            return BlockSnapshot.empty();\n+        }\n+\n+        if (!this.isChunkLoaded(x, y, z, false)) { // TODO bitshift in old impl?\n+            return BlockSnapshot.empty();\n+        }\n+        final BlockPos pos = new BlockPos(x, y, z);\n+        final SpongeBlockSnapshotBuilder builder = SpongeBlockSnapshotBuilder.pooled();\n+        builder.worldId(this.getProperties().getUniqueId())\n+                .position(new Vector3i(x, y, z));\n+        final net.minecraft.world.chunk.Chunk chunk = this.shadow$getChunkAt(pos);\n+        final net.minecraft.block.BlockState state = chunk.getBlockState(pos);\n+        builder.blockState(state);\n+        final net.minecraft.tileentity.TileEntity tile = chunk.getTileEntity(pos, net.minecraft.world.chunk.Chunk.CreateEntityType.CHECK);\n+        if (tile != null) {\n+            TrackingUtil.addTileEntityToBuilder(tile, builder);\n+        }\n+        ((ChunkBridge) chunk).bridge$getBlockOwnerUUID(pos).ifPresent(builder::creator);\n+        ((ChunkBridge) chunk).bridge$getBlockNotifierUUID(pos).ifPresent(builder::notifier);\n+\n+        builder.flag(BlockChangeFlags.NONE);\n+        return builder.build();\n     }\n \n     @Override\n     public boolean restoreSnapshot(BlockSnapshot snapshot, boolean force, BlockChangeFlag flag) {\n-        return false;\n+        return snapshot.restore(force, flag);\n     }\n \n     @Override\n     public boolean restoreSnapshot(int x, int y, int z, BlockSnapshot snapshot, boolean force, BlockChangeFlag flag) {\n-        return false;\n+        return snapshot.withLocation(this.getLocation(x, y, z)).restore(force, flag);\n     }\n \n     @Override\n-    public Chunk getChunkAtBlock(Vector3i blockPosition) {\n-        return null;\n+    public Chunk getChunk(int cx, int cy, int cz) {\n+        return (Chunk) IWorldMixin_API.super.getChunk(cx, cy, cz);\n     }\n \n     @Override\n-    public Chunk getChunkAtBlock(int bx, int by, int bz) {\n-        return null;\n+    public Optional<Chunk> loadChunk(int cx, int cy, int cz, boolean shouldGenerate) {\n+        if (!SpongeChunkLayout.instance.isValidChunk(cx, cy, cz)) {\n+            return Optional.empty();\n+        }\n+        final AbstractChunkProvider chunkProvider = this.shadow$getChunkProvider();\n+        // If we aren't generating, return the chunk\n+        if (!shouldGenerate) {\n+            // TODO correct ChunkStatus?\n+            return Optional.ofNullable((Chunk) chunkProvider.getChunk(cx, cz, ChunkStatus.EMPTY, true));\n+        }\n+        // TODO correct ChunkStatus?\n+        return Optional.ofNullable((Chunk) chunkProvider.getChunk(cx, cz, ChunkStatus.FULL, true));\n     }\n \n     @Override\n-    public Chunk getChunk(Vector3i chunkPos) {\n-        return null;\n+    public Iterable<Chunk> getLoadedChunks() {\n+        final AbstractChunkProvider chunkProvider = this.shadow$getChunkProvider();\n+        if (chunkProvider instanceof ServerChunkProvider) {\n+            final ChunkManagerAccessor chunkManager = (ChunkManagerAccessor) ((ServerChunkProvider) chunkProvider).chunkManager;\n+            final List<Chunk> chunks = new ArrayList<>();\n+            chunkManager.accessor$getLoadedChunksIterable().forEach(holder -> chunks.add((Chunk) holder.func_219298_c()));\n+            return chunks;\n+        }\n+        return Collections.emptyList();\n     }\n \n+    // LocationCreator\n+\n+    // TODO this is on World?\n+    @Override\n+    public ServerLocation getLocation(Vector3i position) {\n+        return ServerLocation.of(this, position);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "842adf2f757a8d0a1585ed74f0ba85a0ec45fd8f"}, "originalPosition": 374}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2662, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}