{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQwODk5NTUw", "number": 2653, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QxMjoxNzo1OVrOEJV93w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxODo0Mzo0OFrOEMnKuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MjMyNTQzOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/spongepowered/common/config/category/ServicesCategory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QxMjoxNzo1OVrOGp1W6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QxMjoxNzo1OVrOGp1W6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjUxOTAxNg==", "bodyText": "Please include a comment here before merging.", "url": "https://github.com/SpongePowered/Sponge/pull/2653#discussion_r446519016", "createdAt": "2020-06-27T12:17:59Z", "author": {"login": "ST-DDT"}, "path": "src/main/java/org/spongepowered/common/config/category/ServicesCategory.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package org.spongepowered.common.config.category;\n+\n+import ninja.leaping.configurate.objectmapping.Setting;\n+import ninja.leaping.configurate.objectmapping.serialize.ConfigSerializable;\n+\n+@ConfigSerializable\n+public class ServicesCategory extends ConfigCategory {\n+\n+    @Setting(value = \"service-plugin\",\n+            comment = \"Services specified here can be implemented by plugins. To ensure that a\"\n+                    + \"specific plugin implements a given service, set the relevant option to its\"\n+                    + \"plugin ID. If you wish to use Sponge's default for a given service, use\"\n+                    + \"'sponge' as the ID.\\n\\n\"\n+                    + \"If the plugin ID is unknown, or the option is set to '?', all plugins will\"\n+                    + \"be given the opportunity to register their service. If multiple plugins\"\n+                    + \"attempt to register, one will be picked in an implementation dependent way.\"\n+                    + \"If no plugins attempt to register a service, the Sponge default will be used\"\n+                    + \"if one exists.\\n\\n\"\n+                    + \"No Sponge default service exists for the Economy service.\")\n+    private ServicePluginSubCategory servicePlugin = new ServicePluginSubCategory();\n+\n+    public ServicePluginSubCategory getServicePlugin() {\n+        return this.servicePlugin;\n+    }\n+\n+    @ConfigSerializable\n+    public static class ServicePluginSubCategory {\n+\n+        @Setting(\"ban-service\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a53094421516ef92941b32ce0d94b4aab025999e"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MjM2OTY0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/spongepowered/common/service/SpongeServiceProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QxMjo1OTozN1rOGp1sCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNFQxNjo0NzowNFrOGs83cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjUyNDQyNQ==", "bodyText": "IMO this should fail, if the specified plugin does not exist or does not provide the service.\nThe admin probably selected that plugin for a reason.", "url": "https://github.com/SpongePowered/Sponge/pull/2653#discussion_r446524425", "createdAt": "2020-06-27T12:59:37Z", "author": {"login": "ST-DDT"}, "path": "src/main/java/org/spongepowered/common/service/SpongeServiceProvider.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package org.spongepowered.common.service;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.reflect.TypeToken;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.spongepowered.api.Sponge;\n+import org.spongepowered.api.event.service.ProvideServiceEvent;\n+import org.spongepowered.api.service.ServiceProvider;\n+import org.spongepowered.api.service.ServiceRegistration;\n+import org.spongepowered.api.service.ban.BanService;\n+import org.spongepowered.api.service.economy.EconomyService;\n+import org.spongepowered.api.service.pagination.PaginationService;\n+import org.spongepowered.api.service.permission.PermissionService;\n+import org.spongepowered.api.service.sql.SqlService;\n+import org.spongepowered.api.service.user.UserStorageService;\n+import org.spongepowered.api.service.whitelist.WhitelistService;\n+import org.spongepowered.api.util.Tuple;\n+import org.spongepowered.common.SpongeImpl;\n+import org.spongepowered.common.config.category.ServicesCategory;\n+import org.spongepowered.common.event.SpongeEventManager;\n+import org.spongepowered.common.event.service.ProvideServiceEventImpl;\n+import org.spongepowered.common.service.ban.SpongeBanService;\n+import org.spongepowered.common.service.permission.SpongePermissionService;\n+import org.spongepowered.common.service.sql.SqlServiceImpl;\n+import org.spongepowered.common.service.user.SpongeUserStorageService;\n+import org.spongepowered.common.service.whitelist.SpongeWhitelistService;\n+import org.spongepowered.plugin.PluginContainer;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+public class SpongeServiceProvider implements ServiceProvider {\n+\n+    // Contains all the services and defaults.\n+    // Zidane, I'm sorry for the horrible type signatures. I just wanted to throw this together quickly!\n+    private static final ImmutableMap<Class<?>, Tuple<Function<ServicesCategory.ServicePluginSubCategory, String>, Supplier<?>>> AVAILABLE_SERVICES =\n+            ImmutableMap.<Class<?>, Tuple<Function<ServicesCategory.ServicePluginSubCategory, String>, Supplier<?>>>builder()\n+                    .put(BanService.class, Tuple.of(ServicesCategory.ServicePluginSubCategory::getBanService, SpongeBanService::new))\n+                    .put(EconomyService.class, Tuple.of(ServicesCategory.ServicePluginSubCategory::getEconomyService, () -> null))\n+                    // TODO: currently in invalid\n+                    .put(PaginationService.class, Tuple.of(ServicesCategory.ServicePluginSubCategory::getPaginationService, () -> null))\n+                    .put(PermissionService.class,\n+                            Tuple.of(ServicesCategory.ServicePluginSubCategory::getPermissionService, SpongePermissionService::new))\n+                    .put(SqlService.class, Tuple.of(ServicesCategory.ServicePluginSubCategory::getSqlService, SqlServiceImpl::new))\n+                    .put(UserStorageService.class,\n+                            Tuple.of(ServicesCategory.ServicePluginSubCategory::getUserStorageService, SpongeUserStorageService::new))\n+                    .put(WhitelistService.class,\n+                            Tuple.of(ServicesCategory.ServicePluginSubCategory::getWhitelistService, SpongeWhitelistService::new))\n+                    .build();\n+\n+    /**\n+     * Discovers services by querying plugins with the\n+     * {@link ProvideServiceEvent}. To be called at the appropriate moment in\n+     * the lifecycle.\n+     *\n+     * @param servicePluginSubCategory The config sub category\n+     * @return The completed provider\n+     */\n+    public static SpongeServiceProvider discoverServices(final ServicesCategory.ServicePluginSubCategory servicePluginSubCategory) {\n+        final ImmutableMap.Builder<Class<?>, Registration<?>> services = ImmutableMap.builder();\n+\n+        // We loop over all available services and try to discover each one.\n+        // This does NOT support third party service interfaces, only impls.\n+        for (final Map.Entry<Class<?>, Tuple<Function<ServicesCategory.ServicePluginSubCategory, String>, Supplier<?>>> candidate :\n+                AVAILABLE_SERVICES.entrySet()) {\n+\n+            // If the configration file has a specific plugin ID, we look for it. If it's there, we will ONLY query that\n+            // plugin.\n+            final Optional<PluginContainer> specificPluginContainer =\n+                    Sponge.getPluginManager().getPlugin(candidate.getValue().getFirst().apply(servicePluginSubCategory));\n+            final Collection<PluginContainer> toQuery =\n+                    specificPluginContainer.<Collection<PluginContainer>>map(ImmutableList::of).orElseGet(Sponge.getPluginManager()::getPlugins);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a53094421516ef92941b32ce0d94b4aab025999e"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTc4Nzc2Mw==", "bodyText": "Just asked @Zidane about this, we're going to print a huge warning instead.", "url": "https://github.com/SpongePowered/Sponge/pull/2653#discussion_r449787763", "createdAt": "2020-07-04T16:47:04Z", "author": {"login": "dualspiral"}, "path": "src/main/java/org/spongepowered/common/service/SpongeServiceProvider.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package org.spongepowered.common.service;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.reflect.TypeToken;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.spongepowered.api.Sponge;\n+import org.spongepowered.api.event.service.ProvideServiceEvent;\n+import org.spongepowered.api.service.ServiceProvider;\n+import org.spongepowered.api.service.ServiceRegistration;\n+import org.spongepowered.api.service.ban.BanService;\n+import org.spongepowered.api.service.economy.EconomyService;\n+import org.spongepowered.api.service.pagination.PaginationService;\n+import org.spongepowered.api.service.permission.PermissionService;\n+import org.spongepowered.api.service.sql.SqlService;\n+import org.spongepowered.api.service.user.UserStorageService;\n+import org.spongepowered.api.service.whitelist.WhitelistService;\n+import org.spongepowered.api.util.Tuple;\n+import org.spongepowered.common.SpongeImpl;\n+import org.spongepowered.common.config.category.ServicesCategory;\n+import org.spongepowered.common.event.SpongeEventManager;\n+import org.spongepowered.common.event.service.ProvideServiceEventImpl;\n+import org.spongepowered.common.service.ban.SpongeBanService;\n+import org.spongepowered.common.service.permission.SpongePermissionService;\n+import org.spongepowered.common.service.sql.SqlServiceImpl;\n+import org.spongepowered.common.service.user.SpongeUserStorageService;\n+import org.spongepowered.common.service.whitelist.SpongeWhitelistService;\n+import org.spongepowered.plugin.PluginContainer;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+public class SpongeServiceProvider implements ServiceProvider {\n+\n+    // Contains all the services and defaults.\n+    // Zidane, I'm sorry for the horrible type signatures. I just wanted to throw this together quickly!\n+    private static final ImmutableMap<Class<?>, Tuple<Function<ServicesCategory.ServicePluginSubCategory, String>, Supplier<?>>> AVAILABLE_SERVICES =\n+            ImmutableMap.<Class<?>, Tuple<Function<ServicesCategory.ServicePluginSubCategory, String>, Supplier<?>>>builder()\n+                    .put(BanService.class, Tuple.of(ServicesCategory.ServicePluginSubCategory::getBanService, SpongeBanService::new))\n+                    .put(EconomyService.class, Tuple.of(ServicesCategory.ServicePluginSubCategory::getEconomyService, () -> null))\n+                    // TODO: currently in invalid\n+                    .put(PaginationService.class, Tuple.of(ServicesCategory.ServicePluginSubCategory::getPaginationService, () -> null))\n+                    .put(PermissionService.class,\n+                            Tuple.of(ServicesCategory.ServicePluginSubCategory::getPermissionService, SpongePermissionService::new))\n+                    .put(SqlService.class, Tuple.of(ServicesCategory.ServicePluginSubCategory::getSqlService, SqlServiceImpl::new))\n+                    .put(UserStorageService.class,\n+                            Tuple.of(ServicesCategory.ServicePluginSubCategory::getUserStorageService, SpongeUserStorageService::new))\n+                    .put(WhitelistService.class,\n+                            Tuple.of(ServicesCategory.ServicePluginSubCategory::getWhitelistService, SpongeWhitelistService::new))\n+                    .build();\n+\n+    /**\n+     * Discovers services by querying plugins with the\n+     * {@link ProvideServiceEvent}. To be called at the appropriate moment in\n+     * the lifecycle.\n+     *\n+     * @param servicePluginSubCategory The config sub category\n+     * @return The completed provider\n+     */\n+    public static SpongeServiceProvider discoverServices(final ServicesCategory.ServicePluginSubCategory servicePluginSubCategory) {\n+        final ImmutableMap.Builder<Class<?>, Registration<?>> services = ImmutableMap.builder();\n+\n+        // We loop over all available services and try to discover each one.\n+        // This does NOT support third party service interfaces, only impls.\n+        for (final Map.Entry<Class<?>, Tuple<Function<ServicesCategory.ServicePluginSubCategory, String>, Supplier<?>>> candidate :\n+                AVAILABLE_SERVICES.entrySet()) {\n+\n+            // If the configration file has a specific plugin ID, we look for it. If it's there, we will ONLY query that\n+            // plugin.\n+            final Optional<PluginContainer> specificPluginContainer =\n+                    Sponge.getPluginManager().getPlugin(candidate.getValue().getFirst().apply(servicePluginSubCategory));\n+            final Collection<PluginContainer> toQuery =\n+                    specificPluginContainer.<Collection<PluginContainer>>map(ImmutableList::of).orElseGet(Sponge.getPluginManager()::getPlugins);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjUyNDQyNQ=="}, "originalCommit": {"oid": "a53094421516ef92941b32ce0d94b4aab025999e"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMzc5NzQ0OnYy", "diffSide": "RIGHT", "path": "vanilla/invalid/java/org/spongepowered/server/SpongeVanilla.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNFQxNjowMDo1NVrOGs8qIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNFQxNjoxNDo0NlrOGs8t-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTc4NDM1Mg==", "bodyText": "mmmh", "url": "https://github.com/SpongePowered/Sponge/pull/2653#discussion_r449784352", "createdAt": "2020-07-04T16:00:55Z", "author": {"login": "ImMorpheus"}, "path": "vanilla/invalid/java/org/spongepowered/server/SpongeVanilla.java", "diffHunk": "@@ -179,9 +174,17 @@ public void onServerStopping() {\n     }\n \n     public void onServerStopped() throws IOException {\n+<<<<<<< HEAD\n         SpongeCommon.postState(GameState.SERVER_STOPPED, SpongeEventFactory.createGameStoppedServerEvent(Sponge.getCauseStackManager().getCurrentCause()));\n         ((SqlServiceImpl) this.game.getServiceManager().provideUnchecked(SqlService.class)).close();\n         SpongeCommon.getConfigSaveManager().flush();\n+=======\n+        SpongeImpl.postState(GameState.SERVER_STOPPED, SpongeEventFactory.createGameStoppedServerEvent(Sponge.getCauseStackManager().getCurrentCause()));\n+        if (this.game.getServiceProvider().sqlService() instanceof SqlServiceImpl) {\n+            ((SqlServiceImpl) this.game.getServiceProvider().sqlService()).close();\n+        }\n+        SpongeImpl.getConfigSaveManager().flush();\n+>>>>>>> 1762dc36f... Add entry point to service provider, make changes to support this", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6022f63c6d82e274ddc4b92d400834b80a9f6935"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTc4NTMzNw==", "bodyText": "At least it's invalid, though I thought I'd picked these all up.", "url": "https://github.com/SpongePowered/Sponge/pull/2653#discussion_r449785337", "createdAt": "2020-07-04T16:14:46Z", "author": {"login": "dualspiral"}, "path": "vanilla/invalid/java/org/spongepowered/server/SpongeVanilla.java", "diffHunk": "@@ -179,9 +174,17 @@ public void onServerStopping() {\n     }\n \n     public void onServerStopped() throws IOException {\n+<<<<<<< HEAD\n         SpongeCommon.postState(GameState.SERVER_STOPPED, SpongeEventFactory.createGameStoppedServerEvent(Sponge.getCauseStackManager().getCurrentCause()));\n         ((SqlServiceImpl) this.game.getServiceManager().provideUnchecked(SqlService.class)).close();\n         SpongeCommon.getConfigSaveManager().flush();\n+=======\n+        SpongeImpl.postState(GameState.SERVER_STOPPED, SpongeEventFactory.createGameStoppedServerEvent(Sponge.getCauseStackManager().getCurrentCause()));\n+        if (this.game.getServiceProvider().sqlService() instanceof SqlServiceImpl) {\n+            ((SqlServiceImpl) this.game.getServiceProvider().sqlService()).close();\n+        }\n+        SpongeImpl.getConfigSaveManager().flush();\n+>>>>>>> 1762dc36f... Add entry point to service provider, make changes to support this", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTc4NDM1Mg=="}, "originalCommit": {"oid": "6022f63c6d82e274ddc4b92d400834b80a9f6935"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMzgwMDIyOnYy", "diffSide": "RIGHT", "path": "src/mixins/java/org/spongepowered/common/mixin/core/service/permission/SubjectMixin.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNFQxNjowNTozMlrOGs8rgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNFQxNjoxNToxN1rOGs8uHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTc4NDcwNg==", "bodyText": "Now that callbacks are gone can this be simplified to a bipredicate (as a lambda I mean) ?", "url": "https://github.com/SpongePowered/Sponge/pull/2653#discussion_r449784706", "createdAt": "2020-07-04T16:05:32Z", "author": {"login": "ImMorpheus"}, "path": "src/mixins/java/org/spongepowered/common/mixin/core/service/permission/SubjectMixin.java", "diffHunk": "@@ -70,15 +70,14 @@ private void subjectConstructor(final CallbackInfo ci) {\n     @Override\n     public Optional<SubjectReference> bridge$resolveReferenceOptional() {\n         if (this.impl$subjectReference == null) {\n-            final Optional<PermissionService> serv = SpongeCommon.getGame().getServiceManager().provide(PermissionService.class);\n-            serv.ifPresent(permissionService -> new SubjectSettingCallback(this).test(permissionService));\n+            new SubjectSettingCallback(this).test(SpongeCommon.getGame().getServiceProvider().permissionService());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6022f63c6d82e274ddc4b92d400834b80a9f6935"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTc4NTM3Mg==", "bodyText": "More likely to be a static method, the callback isn't really a callback anymore and we don't need to pass a method reference around.", "url": "https://github.com/SpongePowered/Sponge/pull/2653#discussion_r449785372", "createdAt": "2020-07-04T16:15:17Z", "author": {"login": "dualspiral"}, "path": "src/mixins/java/org/spongepowered/common/mixin/core/service/permission/SubjectMixin.java", "diffHunk": "@@ -70,15 +70,14 @@ private void subjectConstructor(final CallbackInfo ci) {\n     @Override\n     public Optional<SubjectReference> bridge$resolveReferenceOptional() {\n         if (this.impl$subjectReference == null) {\n-            final Optional<PermissionService> serv = SpongeCommon.getGame().getServiceManager().provide(PermissionService.class);\n-            serv.ifPresent(permissionService -> new SubjectSettingCallback(this).test(permissionService));\n+            new SubjectSettingCallback(this).test(SpongeCommon.getGame().getServiceProvider().permissionService());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTc4NDcwNg=="}, "originalCommit": {"oid": "6022f63c6d82e274ddc4b92d400834b80a9f6935"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMzgwMTcxOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/spongepowered/common/service/SpongeServiceProvider.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNFQxNjowODoyOVrOGs8sNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNFQxNjoyMjoyN1rOGs8wQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTc4NDg4Nw==", "bodyText": "\"No provider is registered for the service '\" + service.getName() + \"'\", service\" (this is the current errore message).\nShouldn't this thrown a ProvisioningException ?", "url": "https://github.com/SpongePowered/Sponge/pull/2653#discussion_r449784887", "createdAt": "2020-07-04T16:08:29Z", "author": {"login": "ImMorpheus"}, "path": "src/main/java/org/spongepowered/common/service/SpongeServiceProvider.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/*\n+ * This file is part of Sponge, licensed under the MIT License (MIT).\n+ *\n+ * Copyright (c) SpongePowered <https://www.spongepowered.org>\n+ * Copyright (c) contributors\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.spongepowered.common.service;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.reflect.TypeToken;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.spongepowered.api.Sponge;\n+import org.spongepowered.api.event.lifecycle.ProvideServiceEvent;\n+import org.spongepowered.api.service.ServiceProvider;\n+import org.spongepowered.api.service.ServiceRegistration;\n+import org.spongepowered.api.service.ban.BanService;\n+import org.spongepowered.api.service.economy.EconomyService;\n+import org.spongepowered.api.service.pagination.PaginationService;\n+import org.spongepowered.api.service.permission.PermissionService;\n+import org.spongepowered.api.service.sql.SqlService;\n+import org.spongepowered.api.service.user.UserStorageService;\n+import org.spongepowered.api.service.whitelist.WhitelistService;\n+import org.spongepowered.api.util.Tuple;\n+import org.spongepowered.common.SpongeCommon;\n+import org.spongepowered.common.config.category.ServicesCategory;\n+import org.spongepowered.common.event.SpongeEventManager;\n+import org.spongepowered.common.event.service.ProvideServiceEventImpl;\n+import org.spongepowered.common.launch.Launcher;\n+import org.spongepowered.common.service.ban.SpongeBanService;\n+import org.spongepowered.common.service.permission.SpongePermissionService;\n+import org.spongepowered.common.service.sql.SqlServiceImpl;\n+import org.spongepowered.common.service.user.SpongeUserStorageService;\n+import org.spongepowered.common.service.whitelist.SpongeWhitelistService;\n+import org.spongepowered.plugin.PluginContainer;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+public class SpongeServiceProvider implements ServiceProvider {\n+\n+    // Contains all the services and defaults.\n+    // Zidane, I'm sorry for the horrible type signatures. I just wanted to throw this together quickly!\n+    private static final ImmutableMap<Class<?>, Tuple<Function<ServicesCategory.ServicePluginSubCategory, String>, Supplier<?>>> AVAILABLE_SERVICES =\n+            ImmutableMap.<Class<?>, Tuple<Function<ServicesCategory.ServicePluginSubCategory, String>, Supplier<?>>>builder()\n+                    .put(BanService.class, Tuple.of(ServicesCategory.ServicePluginSubCategory::getBanService, SpongeBanService::new))\n+                    .put(EconomyService.class, Tuple.of(ServicesCategory.ServicePluginSubCategory::getEconomyService, () -> null))\n+                    // TODO: currently in invalid, will need doing when text comes back up\n+                    .put(PaginationService.class, Tuple.of(ServicesCategory.ServicePluginSubCategory::getPaginationService, () -> null))\n+                    .put(PermissionService.class,\n+                            Tuple.of(ServicesCategory.ServicePluginSubCategory::getPermissionService, SpongePermissionService::new))\n+                    .put(SqlService.class, Tuple.of(ServicesCategory.ServicePluginSubCategory::getSqlService, SqlServiceImpl::new))\n+                    .put(UserStorageService.class,\n+                            Tuple.of(ServicesCategory.ServicePluginSubCategory::getUserStorageService, SpongeUserStorageService::new))\n+                    .put(WhitelistService.class,\n+                            Tuple.of(ServicesCategory.ServicePluginSubCategory::getWhitelistService, SpongeWhitelistService::new))\n+                    .build();\n+\n+    /**\n+     * Discovers services by querying plugins with the\n+     * {@link ProvideServiceEvent}. To be called at the appropriate moment in\n+     * the lifecycle.\n+     *\n+     * @param servicePluginSubCategory The config sub category\n+     * @return The completed provider\n+     */\n+    public static SpongeServiceProvider discoverServices(final ServicesCategory.ServicePluginSubCategory servicePluginSubCategory) {\n+        final ImmutableMap.Builder<Class<?>, Registration<?>> services = ImmutableMap.builder();\n+\n+        // We loop over all available services and try to discover each one.\n+        // This does NOT support third party service interfaces, only impls.\n+        for (final Map.Entry<Class<?>, Tuple<Function<ServicesCategory.ServicePluginSubCategory, String>, Supplier<?>>> candidate :\n+                AVAILABLE_SERVICES.entrySet()) {\n+\n+            // If the configuration file has a specific plugin ID, we look for it. If it's there, we will ONLY query that\n+            // plugin.\n+            final Optional<PluginContainer> specificPluginContainer =\n+                    Sponge.getPluginManager().getPlugin(candidate.getValue().getFirst().apply(servicePluginSubCategory));\n+            final Collection<PluginContainer> toQuery =\n+                    specificPluginContainer.<Collection<PluginContainer>>map(ImmutableList::of).orElseGet(Sponge.getPluginManager()::getPlugins);\n+\n+            Registration<?> registration = null;\n+            final Iterator<PluginContainer> pluginContainerIterator = toQuery.iterator();\n+            while (registration == null && pluginContainerIterator.hasNext()) {\n+                final PluginContainer pluginContainer = pluginContainerIterator.next();\n+                if (!Launcher.getInstance().getLauncherPlugins().contains(pluginContainer)) {\n+                    registration = getSpecificRegistration(pluginContainer, candidate.getKey());\n+                }\n+            }\n+\n+            if (registration == null) {\n+                // If we don't have a registration, we try a Sponge one (which is lowest priority)\n+                registration = createRegistration(\n+                        candidate.getKey(),\n+                        candidate.getValue().getSecond(),\n+                        Launcher.getInstance().getCommonPlugin());\n+            }\n+\n+            // If after all that we have a registration, we... register it.\n+            if (registration != null) {\n+                services.put(candidate.getKey(), registration);\n+                SpongeCommon.getLogger().info(\"Registered service {} to plugin {}.\",\n+                        registration.clazz.getSimpleName(),\n+                        registration.pluginContainer.getMetadata().getId());\n+            }\n+        }\n+\n+        // Ta-da.\n+        return new SpongeServiceProvider(services.build());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Nullable\n+    private static <T> Registration<T> createRegistration(final Class<T> clazz, final Supplier<?> supplier, final PluginContainer container) {\n+        final T impl = (T) supplier.get();\n+        if (impl == null) {\n+            return null;\n+        }\n+        return new Registration<>(clazz, (T) supplier.get(), container);\n+    }\n+\n+    @Nullable\n+    private static <T> Registration<T> getSpecificRegistration(final PluginContainer container, final Class<T> service) {\n+        final ProvideServiceEventImpl<T> event =\n+                new ProvideServiceEventImpl<>(SpongeCommon.getCauseStackManager().getCurrentCause(), TypeToken.of(service));\n+\n+        // This is the actual query - a generic event.\n+        ((SpongeEventManager) Sponge.getEventManager()).post(event, container);\n+        if (event.getSuggestion() != null) {\n+            try {\n+                return new Registration<>(service, event.getSuggestion().get(), container);\n+            } catch (final Throwable e) { // if the service can't be created\n+                SpongeCommon.getLogger().error(\"Could not create service {} from plugin {}.\",\n+                        service.getSimpleName(),\n+                        container.getMetadata().getId(),\n+                        e);\n+                return null;\n+            }\n+        }\n+        SpongeCommon.getLogger().error(\"Could not create service {} from plugin {}, no service was provided.\", service.getSimpleName(),\n+                container.getMetadata().getId());\n+        return null;\n+    }\n+\n+    // --\n+\n+    private final Map<Class<?>, Registration<?>> services;\n+\n+    public SpongeServiceProvider(final Map<Class<?>, Registration<?>> services) {\n+        this.services = ImmutableMap.copyOf(services);\n+    }\n+\n+    @Override\n+    @NonNull\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> Optional<T> provide(@NonNull final Class<T> serviceClass) {\n+        final Registration<T> registration = (Registration<T>) this.services.get(serviceClass);\n+        if (registration != null) {\n+            return Optional.of(registration.service());\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    @NonNull\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> Optional<ServiceRegistration<T>> getRegistration(@NonNull final Class<T> serviceClass) {\n+        return Optional.ofNullable((ServiceRegistration<T>) this.services.get(serviceClass));\n+    }\n+\n+    @NonNull\n+    @SuppressWarnings(\"unchecked\")\n+    private <T> T provideUnchecked(final Class<T> serviceClass) {\n+        final Registration<T> registration = (Registration<T>) this.services.get(serviceClass);\n+        if (registration != null) {\n+            return registration.service();\n+        }\n+        throw new IllegalStateException(\"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6022f63c6d82e274ddc4b92d400834b80a9f6935"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTc4NTcxNw==", "bodyText": "It's probably worth noting that this is a private method, so the rationale was simply that this never should happen. So ISE is fine - the object is in an illegal state if this is called and the service isn't there.\nGiven that exception does not exist, no.", "url": "https://github.com/SpongePowered/Sponge/pull/2653#discussion_r449785717", "createdAt": "2020-07-04T16:20:09Z", "author": {"login": "dualspiral"}, "path": "src/main/java/org/spongepowered/common/service/SpongeServiceProvider.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/*\n+ * This file is part of Sponge, licensed under the MIT License (MIT).\n+ *\n+ * Copyright (c) SpongePowered <https://www.spongepowered.org>\n+ * Copyright (c) contributors\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.spongepowered.common.service;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.reflect.TypeToken;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.spongepowered.api.Sponge;\n+import org.spongepowered.api.event.lifecycle.ProvideServiceEvent;\n+import org.spongepowered.api.service.ServiceProvider;\n+import org.spongepowered.api.service.ServiceRegistration;\n+import org.spongepowered.api.service.ban.BanService;\n+import org.spongepowered.api.service.economy.EconomyService;\n+import org.spongepowered.api.service.pagination.PaginationService;\n+import org.spongepowered.api.service.permission.PermissionService;\n+import org.spongepowered.api.service.sql.SqlService;\n+import org.spongepowered.api.service.user.UserStorageService;\n+import org.spongepowered.api.service.whitelist.WhitelistService;\n+import org.spongepowered.api.util.Tuple;\n+import org.spongepowered.common.SpongeCommon;\n+import org.spongepowered.common.config.category.ServicesCategory;\n+import org.spongepowered.common.event.SpongeEventManager;\n+import org.spongepowered.common.event.service.ProvideServiceEventImpl;\n+import org.spongepowered.common.launch.Launcher;\n+import org.spongepowered.common.service.ban.SpongeBanService;\n+import org.spongepowered.common.service.permission.SpongePermissionService;\n+import org.spongepowered.common.service.sql.SqlServiceImpl;\n+import org.spongepowered.common.service.user.SpongeUserStorageService;\n+import org.spongepowered.common.service.whitelist.SpongeWhitelistService;\n+import org.spongepowered.plugin.PluginContainer;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+public class SpongeServiceProvider implements ServiceProvider {\n+\n+    // Contains all the services and defaults.\n+    // Zidane, I'm sorry for the horrible type signatures. I just wanted to throw this together quickly!\n+    private static final ImmutableMap<Class<?>, Tuple<Function<ServicesCategory.ServicePluginSubCategory, String>, Supplier<?>>> AVAILABLE_SERVICES =\n+            ImmutableMap.<Class<?>, Tuple<Function<ServicesCategory.ServicePluginSubCategory, String>, Supplier<?>>>builder()\n+                    .put(BanService.class, Tuple.of(ServicesCategory.ServicePluginSubCategory::getBanService, SpongeBanService::new))\n+                    .put(EconomyService.class, Tuple.of(ServicesCategory.ServicePluginSubCategory::getEconomyService, () -> null))\n+                    // TODO: currently in invalid, will need doing when text comes back up\n+                    .put(PaginationService.class, Tuple.of(ServicesCategory.ServicePluginSubCategory::getPaginationService, () -> null))\n+                    .put(PermissionService.class,\n+                            Tuple.of(ServicesCategory.ServicePluginSubCategory::getPermissionService, SpongePermissionService::new))\n+                    .put(SqlService.class, Tuple.of(ServicesCategory.ServicePluginSubCategory::getSqlService, SqlServiceImpl::new))\n+                    .put(UserStorageService.class,\n+                            Tuple.of(ServicesCategory.ServicePluginSubCategory::getUserStorageService, SpongeUserStorageService::new))\n+                    .put(WhitelistService.class,\n+                            Tuple.of(ServicesCategory.ServicePluginSubCategory::getWhitelistService, SpongeWhitelistService::new))\n+                    .build();\n+\n+    /**\n+     * Discovers services by querying plugins with the\n+     * {@link ProvideServiceEvent}. To be called at the appropriate moment in\n+     * the lifecycle.\n+     *\n+     * @param servicePluginSubCategory The config sub category\n+     * @return The completed provider\n+     */\n+    public static SpongeServiceProvider discoverServices(final ServicesCategory.ServicePluginSubCategory servicePluginSubCategory) {\n+        final ImmutableMap.Builder<Class<?>, Registration<?>> services = ImmutableMap.builder();\n+\n+        // We loop over all available services and try to discover each one.\n+        // This does NOT support third party service interfaces, only impls.\n+        for (final Map.Entry<Class<?>, Tuple<Function<ServicesCategory.ServicePluginSubCategory, String>, Supplier<?>>> candidate :\n+                AVAILABLE_SERVICES.entrySet()) {\n+\n+            // If the configuration file has a specific plugin ID, we look for it. If it's there, we will ONLY query that\n+            // plugin.\n+            final Optional<PluginContainer> specificPluginContainer =\n+                    Sponge.getPluginManager().getPlugin(candidate.getValue().getFirst().apply(servicePluginSubCategory));\n+            final Collection<PluginContainer> toQuery =\n+                    specificPluginContainer.<Collection<PluginContainer>>map(ImmutableList::of).orElseGet(Sponge.getPluginManager()::getPlugins);\n+\n+            Registration<?> registration = null;\n+            final Iterator<PluginContainer> pluginContainerIterator = toQuery.iterator();\n+            while (registration == null && pluginContainerIterator.hasNext()) {\n+                final PluginContainer pluginContainer = pluginContainerIterator.next();\n+                if (!Launcher.getInstance().getLauncherPlugins().contains(pluginContainer)) {\n+                    registration = getSpecificRegistration(pluginContainer, candidate.getKey());\n+                }\n+            }\n+\n+            if (registration == null) {\n+                // If we don't have a registration, we try a Sponge one (which is lowest priority)\n+                registration = createRegistration(\n+                        candidate.getKey(),\n+                        candidate.getValue().getSecond(),\n+                        Launcher.getInstance().getCommonPlugin());\n+            }\n+\n+            // If after all that we have a registration, we... register it.\n+            if (registration != null) {\n+                services.put(candidate.getKey(), registration);\n+                SpongeCommon.getLogger().info(\"Registered service {} to plugin {}.\",\n+                        registration.clazz.getSimpleName(),\n+                        registration.pluginContainer.getMetadata().getId());\n+            }\n+        }\n+\n+        // Ta-da.\n+        return new SpongeServiceProvider(services.build());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Nullable\n+    private static <T> Registration<T> createRegistration(final Class<T> clazz, final Supplier<?> supplier, final PluginContainer container) {\n+        final T impl = (T) supplier.get();\n+        if (impl == null) {\n+            return null;\n+        }\n+        return new Registration<>(clazz, (T) supplier.get(), container);\n+    }\n+\n+    @Nullable\n+    private static <T> Registration<T> getSpecificRegistration(final PluginContainer container, final Class<T> service) {\n+        final ProvideServiceEventImpl<T> event =\n+                new ProvideServiceEventImpl<>(SpongeCommon.getCauseStackManager().getCurrentCause(), TypeToken.of(service));\n+\n+        // This is the actual query - a generic event.\n+        ((SpongeEventManager) Sponge.getEventManager()).post(event, container);\n+        if (event.getSuggestion() != null) {\n+            try {\n+                return new Registration<>(service, event.getSuggestion().get(), container);\n+            } catch (final Throwable e) { // if the service can't be created\n+                SpongeCommon.getLogger().error(\"Could not create service {} from plugin {}.\",\n+                        service.getSimpleName(),\n+                        container.getMetadata().getId(),\n+                        e);\n+                return null;\n+            }\n+        }\n+        SpongeCommon.getLogger().error(\"Could not create service {} from plugin {}, no service was provided.\", service.getSimpleName(),\n+                container.getMetadata().getId());\n+        return null;\n+    }\n+\n+    // --\n+\n+    private final Map<Class<?>, Registration<?>> services;\n+\n+    public SpongeServiceProvider(final Map<Class<?>, Registration<?>> services) {\n+        this.services = ImmutableMap.copyOf(services);\n+    }\n+\n+    @Override\n+    @NonNull\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> Optional<T> provide(@NonNull final Class<T> serviceClass) {\n+        final Registration<T> registration = (Registration<T>) this.services.get(serviceClass);\n+        if (registration != null) {\n+            return Optional.of(registration.service());\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    @NonNull\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> Optional<ServiceRegistration<T>> getRegistration(@NonNull final Class<T> serviceClass) {\n+        return Optional.ofNullable((ServiceRegistration<T>) this.services.get(serviceClass));\n+    }\n+\n+    @NonNull\n+    @SuppressWarnings(\"unchecked\")\n+    private <T> T provideUnchecked(final Class<T> serviceClass) {\n+        final Registration<T> registration = (Registration<T>) this.services.get(serviceClass);\n+        if (registration != null) {\n+            return registration.service();\n+        }\n+        throw new IllegalStateException(\"\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTc4NDg4Nw=="}, "originalCommit": {"oid": "6022f63c6d82e274ddc4b92d400834b80a9f6935"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTc4NTkyMg==", "bodyText": "I missed the exception was remove in the API PR", "url": "https://github.com/SpongePowered/Sponge/pull/2653#discussion_r449785922", "createdAt": "2020-07-04T16:22:27Z", "author": {"login": "ImMorpheus"}, "path": "src/main/java/org/spongepowered/common/service/SpongeServiceProvider.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/*\n+ * This file is part of Sponge, licensed under the MIT License (MIT).\n+ *\n+ * Copyright (c) SpongePowered <https://www.spongepowered.org>\n+ * Copyright (c) contributors\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.spongepowered.common.service;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.reflect.TypeToken;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.spongepowered.api.Sponge;\n+import org.spongepowered.api.event.lifecycle.ProvideServiceEvent;\n+import org.spongepowered.api.service.ServiceProvider;\n+import org.spongepowered.api.service.ServiceRegistration;\n+import org.spongepowered.api.service.ban.BanService;\n+import org.spongepowered.api.service.economy.EconomyService;\n+import org.spongepowered.api.service.pagination.PaginationService;\n+import org.spongepowered.api.service.permission.PermissionService;\n+import org.spongepowered.api.service.sql.SqlService;\n+import org.spongepowered.api.service.user.UserStorageService;\n+import org.spongepowered.api.service.whitelist.WhitelistService;\n+import org.spongepowered.api.util.Tuple;\n+import org.spongepowered.common.SpongeCommon;\n+import org.spongepowered.common.config.category.ServicesCategory;\n+import org.spongepowered.common.event.SpongeEventManager;\n+import org.spongepowered.common.event.service.ProvideServiceEventImpl;\n+import org.spongepowered.common.launch.Launcher;\n+import org.spongepowered.common.service.ban.SpongeBanService;\n+import org.spongepowered.common.service.permission.SpongePermissionService;\n+import org.spongepowered.common.service.sql.SqlServiceImpl;\n+import org.spongepowered.common.service.user.SpongeUserStorageService;\n+import org.spongepowered.common.service.whitelist.SpongeWhitelistService;\n+import org.spongepowered.plugin.PluginContainer;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+public class SpongeServiceProvider implements ServiceProvider {\n+\n+    // Contains all the services and defaults.\n+    // Zidane, I'm sorry for the horrible type signatures. I just wanted to throw this together quickly!\n+    private static final ImmutableMap<Class<?>, Tuple<Function<ServicesCategory.ServicePluginSubCategory, String>, Supplier<?>>> AVAILABLE_SERVICES =\n+            ImmutableMap.<Class<?>, Tuple<Function<ServicesCategory.ServicePluginSubCategory, String>, Supplier<?>>>builder()\n+                    .put(BanService.class, Tuple.of(ServicesCategory.ServicePluginSubCategory::getBanService, SpongeBanService::new))\n+                    .put(EconomyService.class, Tuple.of(ServicesCategory.ServicePluginSubCategory::getEconomyService, () -> null))\n+                    // TODO: currently in invalid, will need doing when text comes back up\n+                    .put(PaginationService.class, Tuple.of(ServicesCategory.ServicePluginSubCategory::getPaginationService, () -> null))\n+                    .put(PermissionService.class,\n+                            Tuple.of(ServicesCategory.ServicePluginSubCategory::getPermissionService, SpongePermissionService::new))\n+                    .put(SqlService.class, Tuple.of(ServicesCategory.ServicePluginSubCategory::getSqlService, SqlServiceImpl::new))\n+                    .put(UserStorageService.class,\n+                            Tuple.of(ServicesCategory.ServicePluginSubCategory::getUserStorageService, SpongeUserStorageService::new))\n+                    .put(WhitelistService.class,\n+                            Tuple.of(ServicesCategory.ServicePluginSubCategory::getWhitelistService, SpongeWhitelistService::new))\n+                    .build();\n+\n+    /**\n+     * Discovers services by querying plugins with the\n+     * {@link ProvideServiceEvent}. To be called at the appropriate moment in\n+     * the lifecycle.\n+     *\n+     * @param servicePluginSubCategory The config sub category\n+     * @return The completed provider\n+     */\n+    public static SpongeServiceProvider discoverServices(final ServicesCategory.ServicePluginSubCategory servicePluginSubCategory) {\n+        final ImmutableMap.Builder<Class<?>, Registration<?>> services = ImmutableMap.builder();\n+\n+        // We loop over all available services and try to discover each one.\n+        // This does NOT support third party service interfaces, only impls.\n+        for (final Map.Entry<Class<?>, Tuple<Function<ServicesCategory.ServicePluginSubCategory, String>, Supplier<?>>> candidate :\n+                AVAILABLE_SERVICES.entrySet()) {\n+\n+            // If the configuration file has a specific plugin ID, we look for it. If it's there, we will ONLY query that\n+            // plugin.\n+            final Optional<PluginContainer> specificPluginContainer =\n+                    Sponge.getPluginManager().getPlugin(candidate.getValue().getFirst().apply(servicePluginSubCategory));\n+            final Collection<PluginContainer> toQuery =\n+                    specificPluginContainer.<Collection<PluginContainer>>map(ImmutableList::of).orElseGet(Sponge.getPluginManager()::getPlugins);\n+\n+            Registration<?> registration = null;\n+            final Iterator<PluginContainer> pluginContainerIterator = toQuery.iterator();\n+            while (registration == null && pluginContainerIterator.hasNext()) {\n+                final PluginContainer pluginContainer = pluginContainerIterator.next();\n+                if (!Launcher.getInstance().getLauncherPlugins().contains(pluginContainer)) {\n+                    registration = getSpecificRegistration(pluginContainer, candidate.getKey());\n+                }\n+            }\n+\n+            if (registration == null) {\n+                // If we don't have a registration, we try a Sponge one (which is lowest priority)\n+                registration = createRegistration(\n+                        candidate.getKey(),\n+                        candidate.getValue().getSecond(),\n+                        Launcher.getInstance().getCommonPlugin());\n+            }\n+\n+            // If after all that we have a registration, we... register it.\n+            if (registration != null) {\n+                services.put(candidate.getKey(), registration);\n+                SpongeCommon.getLogger().info(\"Registered service {} to plugin {}.\",\n+                        registration.clazz.getSimpleName(),\n+                        registration.pluginContainer.getMetadata().getId());\n+            }\n+        }\n+\n+        // Ta-da.\n+        return new SpongeServiceProvider(services.build());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Nullable\n+    private static <T> Registration<T> createRegistration(final Class<T> clazz, final Supplier<?> supplier, final PluginContainer container) {\n+        final T impl = (T) supplier.get();\n+        if (impl == null) {\n+            return null;\n+        }\n+        return new Registration<>(clazz, (T) supplier.get(), container);\n+    }\n+\n+    @Nullable\n+    private static <T> Registration<T> getSpecificRegistration(final PluginContainer container, final Class<T> service) {\n+        final ProvideServiceEventImpl<T> event =\n+                new ProvideServiceEventImpl<>(SpongeCommon.getCauseStackManager().getCurrentCause(), TypeToken.of(service));\n+\n+        // This is the actual query - a generic event.\n+        ((SpongeEventManager) Sponge.getEventManager()).post(event, container);\n+        if (event.getSuggestion() != null) {\n+            try {\n+                return new Registration<>(service, event.getSuggestion().get(), container);\n+            } catch (final Throwable e) { // if the service can't be created\n+                SpongeCommon.getLogger().error(\"Could not create service {} from plugin {}.\",\n+                        service.getSimpleName(),\n+                        container.getMetadata().getId(),\n+                        e);\n+                return null;\n+            }\n+        }\n+        SpongeCommon.getLogger().error(\"Could not create service {} from plugin {}, no service was provided.\", service.getSimpleName(),\n+                container.getMetadata().getId());\n+        return null;\n+    }\n+\n+    // --\n+\n+    private final Map<Class<?>, Registration<?>> services;\n+\n+    public SpongeServiceProvider(final Map<Class<?>, Registration<?>> services) {\n+        this.services = ImmutableMap.copyOf(services);\n+    }\n+\n+    @Override\n+    @NonNull\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> Optional<T> provide(@NonNull final Class<T> serviceClass) {\n+        final Registration<T> registration = (Registration<T>) this.services.get(serviceClass);\n+        if (registration != null) {\n+            return Optional.of(registration.service());\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    @NonNull\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> Optional<ServiceRegistration<T>> getRegistration(@NonNull final Class<T> serviceClass) {\n+        return Optional.ofNullable((ServiceRegistration<T>) this.services.get(serviceClass));\n+    }\n+\n+    @NonNull\n+    @SuppressWarnings(\"unchecked\")\n+    private <T> T provideUnchecked(final Class<T> serviceClass) {\n+        final Registration<T> registration = (Registration<T>) this.services.get(serviceClass);\n+        if (registration != null) {\n+            return registration.service();\n+        }\n+        throw new IllegalStateException(\"\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTc4NDg4Nw=="}, "originalCommit": {"oid": "6022f63c6d82e274ddc4b92d400834b80a9f6935"}, "originalPosition": 202}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMzg1NzM5OnYy", "diffSide": "RIGHT", "path": "vanilla/invalid/java/org/spongepowered/server/SpongeVanilla.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNFQxNzo0MDo1M1rOGs9Gow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNFQxNzo1MzoyNVrOGs9KFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTc5MTY1MQ==", "bodyText": "You reverted back to SpongeImpl.", "url": "https://github.com/SpongePowered/Sponge/pull/2653#discussion_r449791651", "createdAt": "2020-07-04T17:40:53Z", "author": {"login": "Zidane"}, "path": "vanilla/invalid/java/org/spongepowered/server/SpongeVanilla.java", "diffHunk": "@@ -179,9 +174,11 @@ public void onServerStopping() {\n     }\n \n     public void onServerStopped() throws IOException {\n-        SpongeCommon.postState(GameState.SERVER_STOPPED, SpongeEventFactory.createGameStoppedServerEvent(Sponge.getCauseStackManager().getCurrentCause()));\n-        ((SqlServiceImpl) this.game.getServiceManager().provideUnchecked(SqlService.class)).close();\n-        SpongeCommon.getConfigSaveManager().flush();\n+        SpongeImpl.postState(GameState.SERVER_STOPPED, SpongeEventFactory.createGameStoppedServerEvent(Sponge.getCauseStackManager().getCurrentCause()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "534572f0c166c9ef6877edddf531efa286e112ad"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTc5MjUzNA==", "bodyText": "Given GameState is also gone, that line might as well go.", "url": "https://github.com/SpongePowered/Sponge/pull/2653#discussion_r449792534", "createdAt": "2020-07-04T17:53:25Z", "author": {"login": "dualspiral"}, "path": "vanilla/invalid/java/org/spongepowered/server/SpongeVanilla.java", "diffHunk": "@@ -179,9 +174,11 @@ public void onServerStopping() {\n     }\n \n     public void onServerStopped() throws IOException {\n-        SpongeCommon.postState(GameState.SERVER_STOPPED, SpongeEventFactory.createGameStoppedServerEvent(Sponge.getCauseStackManager().getCurrentCause()));\n-        ((SqlServiceImpl) this.game.getServiceManager().provideUnchecked(SqlService.class)).close();\n-        SpongeCommon.getConfigSaveManager().flush();\n+        SpongeImpl.postState(GameState.SERVER_STOPPED, SpongeEventFactory.createGameStoppedServerEvent(Sponge.getCauseStackManager().getCurrentCause()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTc5MTY1MQ=="}, "originalCommit": {"oid": "534572f0c166c9ef6877edddf531efa286e112ad"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMzg1ODUyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/spongepowered/common/service/permission/SpongePermissionService.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNFQxNzo0Mjo1MlrOGs9HKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNFQxNzo1NzoxOFrOGs9LMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTc5MTc4Nw==", "bodyText": "Would it be worth injecting the SpongeGame instance? Would require turning these into Singletons and creating them via the injector only if you need too.", "url": "https://github.com/SpongePowered/Sponge/pull/2653#discussion_r449791787", "createdAt": "2020-07-04T17:42:52Z", "author": {"login": "Zidane"}, "path": "src/main/java/org/spongepowered/common/service/permission/SpongePermissionService.java", "diffHunk": "@@ -66,8 +67,8 @@\n     private final SpongeSubjectCollection defaultCollection;\n     private final SpongeSubject defaultData;\n \n-    public SpongePermissionService(Game game) {\n-        this.game = game;\n+    public SpongePermissionService() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "534572f0c166c9ef6877edddf531efa286e112ad"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTc5MjYyMw==", "bodyText": "Yes, if we're okay with passing an injector to the service provider.", "url": "https://github.com/SpongePowered/Sponge/pull/2653#discussion_r449792623", "createdAt": "2020-07-04T17:54:52Z", "author": {"login": "dualspiral"}, "path": "src/main/java/org/spongepowered/common/service/permission/SpongePermissionService.java", "diffHunk": "@@ -66,8 +67,8 @@\n     private final SpongeSubjectCollection defaultCollection;\n     private final SpongeSubject defaultData;\n \n-    public SpongePermissionService(Game game) {\n-        this.game = game;\n+    public SpongePermissionService() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTc5MTc4Nw=="}, "originalCommit": {"oid": "534572f0c166c9ef6877edddf531efa286e112ad"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTc5MjgxOQ==", "bodyText": "I don't see an issue with it.", "url": "https://github.com/SpongePowered/Sponge/pull/2653#discussion_r449792819", "createdAt": "2020-07-04T17:57:18Z", "author": {"login": "Zidane"}, "path": "src/main/java/org/spongepowered/common/service/permission/SpongePermissionService.java", "diffHunk": "@@ -66,8 +67,8 @@\n     private final SpongeSubjectCollection defaultCollection;\n     private final SpongeSubject defaultData;\n \n-    public SpongePermissionService(Game game) {\n-        this.game = game;\n+    public SpongePermissionService() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTc5MTc4Nw=="}, "originalCommit": {"oid": "534572f0c166c9ef6877edddf531efa286e112ad"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMzg2MTExOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/spongepowered/common/event/service/ProvideServiceEventImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNFQxNzo0Nzo0M1rOGs9Icw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNFQxNzo0Nzo0M1rOGs9Icw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTc5MjExNQ==", "bodyText": "I like final things.", "url": "https://github.com/SpongePowered/Sponge/pull/2653#discussion_r449792115", "createdAt": "2020-07-04T17:47:43Z", "author": {"login": "Zidane"}, "path": "src/main/java/org/spongepowered/common/event/service/ProvideServiceEventImpl.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * This file is part of Sponge, licensed under the MIT License (MIT).\n+ *\n+ * Copyright (c) SpongePowered <https://www.spongepowered.org>\n+ * Copyright (c) contributors\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.spongepowered.common.event.service;\n+\n+import com.google.common.reflect.TypeToken;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.spongepowered.api.event.cause.Cause;\n+import org.spongepowered.api.event.lifecycle.ProvideServiceEvent;\n+\n+import java.util.function.Supplier;\n+\n+// Specialised logic is required for this.\n+public class ProvideServiceEventImpl<T> implements ProvideServiceEvent<T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "534572f0c166c9ef6877edddf531efa286e112ad"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMzg2MTM3OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/spongepowered/common/config/category/ServicesCategory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNFQxNzo0ODowMFrOGs9IkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNFQxNzo0ODowMFrOGs9IkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTc5MjE0NQ==", "bodyText": "I like final things.", "url": "https://github.com/SpongePowered/Sponge/pull/2653#discussion_r449792145", "createdAt": "2020-07-04T17:48:00Z", "author": {"login": "Zidane"}, "path": "src/main/java/org/spongepowered/common/config/category/ServicesCategory.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * This file is part of Sponge, licensed under the MIT License (MIT).\n+ *\n+ * Copyright (c) SpongePowered <https://www.spongepowered.org>\n+ * Copyright (c) contributors\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.spongepowered.common.config.category;\n+\n+import ninja.leaping.configurate.objectmapping.Setting;\n+import ninja.leaping.configurate.objectmapping.serialize.ConfigSerializable;\n+\n+@ConfigSerializable\n+public class ServicesCategory extends ConfigCategory {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "534572f0c166c9ef6877edddf531efa286e112ad"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxNjU4ODE0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/spongepowered/common/config/category/ServicesCategory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxODo0MDoxNlrOGu0s-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxOTowMjo1NVrOGu1cqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc1MTE2Mw==", "bodyText": "SqlService is dead", "url": "https://github.com/SpongePowered/Sponge/pull/2653#discussion_r451751163", "createdAt": "2020-07-08T18:40:16Z", "author": {"login": "ImMorpheus"}, "path": "src/main/java/org/spongepowered/common/config/category/ServicesCategory.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * This file is part of Sponge, licensed under the MIT License (MIT).\n+ *\n+ * Copyright (c) SpongePowered <https://www.spongepowered.org>\n+ * Copyright (c) contributors\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.spongepowered.common.config.category;\n+\n+import ninja.leaping.configurate.objectmapping.Setting;\n+import ninja.leaping.configurate.objectmapping.serialize.ConfigSerializable;\n+\n+@ConfigSerializable\n+public final class ServicesCategory extends ConfigCategory {\n+\n+    @Setting(value = \"service-plugin\",\n+            comment = \"Services specified here can be implemented by plugins. To ensure that a\"\n+                    + \"specific plugin implements a given service, set the relevant option to its\"\n+                    + \"plugin ID. If you wish to use Sponge's default for a given service, use\"\n+                    + \"'sponge' as the ID.\\n\\n\"\n+                    + \"If the plugin ID is unknown, or the option is set to '?', all plugins will\"\n+                    + \"be given the opportunity to register their service. If multiple plugins\"\n+                    + \"attempt to register, one will be picked in an implementation dependent way.\"\n+                    + \"If no plugins attempt to register a service, the Sponge default will be used\"\n+                    + \"if one exists.\\n\\n\"\n+                    + \"No Sponge default service exists for the Economy service.\")\n+    private ServicePluginSubCategory servicePlugin = new ServicePluginSubCategory();\n+\n+    public ServicePluginSubCategory getServicePlugin() {\n+        return this.servicePlugin;\n+    }\n+\n+    @ConfigSerializable\n+    public static final class ServicePluginSubCategory {\n+\n+        @Setting(value = \"ban-service\", comment = \"Specifies the plugin that will provide the ban service\")\n+        private String banService = \"?\";\n+\n+        @Setting(value = \"economy-service\", comment = \"Specifies the plugin that will provide the economy service\")\n+        private String economyService = \"?\";\n+\n+        @Setting(value = \"pagination-service\", comment = \"Specifies the plugin that will provide the pagination service\")\n+        private String paginationService = \"?\";\n+\n+        @Setting(value = \"permission-service\", comment = \"Specifies the plugin that will provide the permission service\")\n+        private String permissionService = \"?\";\n+\n+        @Setting(value = \"sql-service\", comment = \"Specifies the plugin that will provide the SQL service\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72582947566c9e7ff6d756a57941097a8dfd8927"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2MzM2OA==", "bodyText": "Good spot.", "url": "https://github.com/SpongePowered/Sponge/pull/2653#discussion_r451763368", "createdAt": "2020-07-08T19:02:55Z", "author": {"login": "dualspiral"}, "path": "src/main/java/org/spongepowered/common/config/category/ServicesCategory.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * This file is part of Sponge, licensed under the MIT License (MIT).\n+ *\n+ * Copyright (c) SpongePowered <https://www.spongepowered.org>\n+ * Copyright (c) contributors\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.spongepowered.common.config.category;\n+\n+import ninja.leaping.configurate.objectmapping.Setting;\n+import ninja.leaping.configurate.objectmapping.serialize.ConfigSerializable;\n+\n+@ConfigSerializable\n+public final class ServicesCategory extends ConfigCategory {\n+\n+    @Setting(value = \"service-plugin\",\n+            comment = \"Services specified here can be implemented by plugins. To ensure that a\"\n+                    + \"specific plugin implements a given service, set the relevant option to its\"\n+                    + \"plugin ID. If you wish to use Sponge's default for a given service, use\"\n+                    + \"'sponge' as the ID.\\n\\n\"\n+                    + \"If the plugin ID is unknown, or the option is set to '?', all plugins will\"\n+                    + \"be given the opportunity to register their service. If multiple plugins\"\n+                    + \"attempt to register, one will be picked in an implementation dependent way.\"\n+                    + \"If no plugins attempt to register a service, the Sponge default will be used\"\n+                    + \"if one exists.\\n\\n\"\n+                    + \"No Sponge default service exists for the Economy service.\")\n+    private ServicePluginSubCategory servicePlugin = new ServicePluginSubCategory();\n+\n+    public ServicePluginSubCategory getServicePlugin() {\n+        return this.servicePlugin;\n+    }\n+\n+    @ConfigSerializable\n+    public static final class ServicePluginSubCategory {\n+\n+        @Setting(value = \"ban-service\", comment = \"Specifies the plugin that will provide the ban service\")\n+        private String banService = \"?\";\n+\n+        @Setting(value = \"economy-service\", comment = \"Specifies the plugin that will provide the economy service\")\n+        private String economyService = \"?\";\n+\n+        @Setting(value = \"pagination-service\", comment = \"Specifies the plugin that will provide the pagination service\")\n+        private String paginationService = \"?\";\n+\n+        @Setting(value = \"permission-service\", comment = \"Specifies the plugin that will provide the permission service\")\n+        private String permissionService = \"?\";\n+\n+        @Setting(value = \"sql-service\", comment = \"Specifies the plugin that will provide the SQL service\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc1MTE2Mw=="}, "originalCommit": {"oid": "72582947566c9e7ff6d756a57941097a8dfd8927"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxNjYwMDkxOnYy", "diffSide": "RIGHT", "path": "src/mixins/java/org/spongepowered/common/mixin/tracker/world/chunk/ChunkMixin_OwnershipTracked.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxODo0Mzo0OFrOGu004g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxOTowMjo0MFrOGu1cIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc1MzE4Ng==", "bodyText": "This was causing a big performance issue in api7.\nIt should use the user storage service when the world is not fake (not the opposite).\n(see ChunkMixin_Tracker)", "url": "https://github.com/SpongePowered/Sponge/pull/2653#discussion_r451753186", "createdAt": "2020-07-08T18:43:48Z", "author": {"login": "ImMorpheus"}, "path": "src/mixins/java/org/spongepowered/common/mixin/tracker/world/chunk/ChunkMixin_OwnershipTracked.java", "diffHunk": "@@ -88,7 +88,9 @@\n             + \"/function/Consumer;)V\", at = @At(\"RETURN\"))\n     private void tracker$setUpUserService(final World world, final ChunkPos pos, final Biome[] biomes, final UpgradeData data, final ITickList<Block> blockTickList,\n                                           final ITickList<Fluid> fluidTickList, final long inhabitedTime, final ChunkSection[] sections, final Consumer<Chunk> chunkConsumer, final CallbackInfo ci) {\n-        this.tracker$userStorageService = world != null && !((WorldBridge) world).bridge$isFake() ? null : Sponge.getServiceProvider().userStorageService();\n+        this.tracker$userStorageService = world != null && !((WorldBridge) world).bridge$isFake()\n+                                  ? null\n+                                  : SpongeCommon.getGame().getServiceProvider().userStorageService();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72582947566c9e7ff6d756a57941097a8dfd8927"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2MzIzMg==", "bodyText": "I'm not interested in making logic changes outside the replacement of the service system in this PR because otherwise it'll never end.", "url": "https://github.com/SpongePowered/Sponge/pull/2653#discussion_r451763232", "createdAt": "2020-07-08T19:02:40Z", "author": {"login": "dualspiral"}, "path": "src/mixins/java/org/spongepowered/common/mixin/tracker/world/chunk/ChunkMixin_OwnershipTracked.java", "diffHunk": "@@ -88,7 +88,9 @@\n             + \"/function/Consumer;)V\", at = @At(\"RETURN\"))\n     private void tracker$setUpUserService(final World world, final ChunkPos pos, final Biome[] biomes, final UpgradeData data, final ITickList<Block> blockTickList,\n                                           final ITickList<Fluid> fluidTickList, final long inhabitedTime, final ChunkSection[] sections, final Consumer<Chunk> chunkConsumer, final CallbackInfo ci) {\n-        this.tracker$userStorageService = world != null && !((WorldBridge) world).bridge$isFake() ? null : Sponge.getServiceProvider().userStorageService();\n+        this.tracker$userStorageService = world != null && !((WorldBridge) world).bridge$isFake()\n+                                  ? null\n+                                  : SpongeCommon.getGame().getServiceProvider().userStorageService();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc1MzE4Ng=="}, "originalCommit": {"oid": "72582947566c9e7ff6d756a57941097a8dfd8927"}, "originalPosition": 7}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2522, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}