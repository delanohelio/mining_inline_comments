{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE2OTMwNjY2", "number": 2609, "reviewThreads": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwMjozNzoyMlrOD746zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNTo0NjoxMlrOD8VHgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MTI1MTM1OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/spongepowered/common/event/damage/SpongeEntityDamageSourceBuilder.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwMjozNzoyMlrOGUfeOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwMjozNzoyMlrOGUfeOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0MDM0Ng==", "bodyText": "this is negotiated based on the mixin  and damage source to type provider.", "url": "https://github.com/SpongePowered/Sponge/pull/2609#discussion_r424140346", "createdAt": "2020-05-13T02:37:22Z", "author": {"login": "gabizou"}, "path": "src/main/java/org/spongepowered/common/event/damage/SpongeEntityDamageSourceBuilder.java", "diffHunk": "@@ -49,8 +49,8 @@ public SpongeEntityDamageSourceBuilder entity(final Entity entity) {\n     public EntityDamageSource build() throws IllegalStateException {\n         checkState(this.damageType != null, \"Damage type cannot be null!\");\n         checkState(this.reference.get() != null);\n-        final net.minecraft.util.EntityDamageSource damageSource =\n-            new net.minecraft.util.EntityDamageSource(this.damageType.getId(), (net.minecraft.entity.Entity) this.reference.get());\n+        final net.minecraft.util.EntityDamageSource damageSource = // TODO damageType String is used for the translation key!", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "114ecf0142e7d251731ee967790e4eb4a42935be"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTg1NzUyOnYy", "diffSide": "RIGHT", "path": "src/accessors/java/org/spongepowered/common/accessor/entity/player/ServerPlayerEntityAccessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNTozODoyNVrOGVMt2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNTowNjo0M1rOGVgxmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg4MTYyNA==", "bodyText": "Do we not even have one of these from before?", "url": "https://github.com/SpongePowered/Sponge/pull/2609#discussion_r424881624", "createdAt": "2020-05-14T05:38:25Z", "author": {"login": "gabizou"}, "path": "src/accessors/java/org/spongepowered/common/accessor/entity/player/ServerPlayerEntityAccessor.java", "diffHunk": "@@ -22,33 +22,15 @@\n  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n  * THE SOFTWARE.\n  */\n-package org.spongepowered.common.mixin.api.mcp.item;\n+package org.spongepowered.common.accessor.entity.player;\n \n-import net.minecraft.entity.merchant.IMerchant;\n-import net.minecraft.item.MerchantOffer;\n-import net.minecraft.item.MerchantOffers;\n-import org.spongepowered.api.item.merchant.Merchant;\n-import org.spongepowered.api.item.merchant.TradeOffer;\n-import org.spongepowered.api.item.merchant.TradeOfferListMutator;\n+import net.minecraft.entity.player.ServerPlayerEntity;\n+import net.minecraft.util.math.Vec3d;\n import org.spongepowered.asm.mixin.Mixin;\n-import org.spongepowered.common.item.util.TradeOfferUtil;\n-import java.util.List;\n-import java.util.Random;\n+import org.spongepowered.asm.mixin.gen.Accessor;\n \n-@Mixin(MerchantOffers.class)\n-public interface MerchantOffersMixin_API extends TradeOfferListMutator {\n-\n-    @Override\n-    default void accept(final Merchant owner, final List<TradeOffer> tradeOffers, final Random random) {\n-        final MerchantOffers tempList = new MerchantOffers();\n-        for (final TradeOffer offer : tradeOffers) {\n-            tempList.add(TradeOfferUtil.toNative(offer));\n-        }\n-        addMerchantRecipe((IMerchant) owner, tempList, random);\n-        tradeOffers.clear();\n-        for (final MerchantOffer recipe : tempList) {\n-            tradeOffers.add(TradeOfferUtil.fromNative(recipe));\n-        }\n-    }\n+@Mixin(ServerPlayerEntity.class)\n+public interface ServerPlayerEntityAccessor {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6160b635c9b939b79f879290c1eda656df7f0bbe"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIxMDI2NQ==", "bodyText": "I dont see another accessor for ServerPlayerEntity", "url": "https://github.com/SpongePowered/Sponge/pull/2609#discussion_r425210265", "createdAt": "2020-05-14T15:06:43Z", "author": {"login": "Faithcaio"}, "path": "src/accessors/java/org/spongepowered/common/accessor/entity/player/ServerPlayerEntityAccessor.java", "diffHunk": "@@ -22,33 +22,15 @@\n  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n  * THE SOFTWARE.\n  */\n-package org.spongepowered.common.mixin.api.mcp.item;\n+package org.spongepowered.common.accessor.entity.player;\n \n-import net.minecraft.entity.merchant.IMerchant;\n-import net.minecraft.item.MerchantOffer;\n-import net.minecraft.item.MerchantOffers;\n-import org.spongepowered.api.item.merchant.Merchant;\n-import org.spongepowered.api.item.merchant.TradeOffer;\n-import org.spongepowered.api.item.merchant.TradeOfferListMutator;\n+import net.minecraft.entity.player.ServerPlayerEntity;\n+import net.minecraft.util.math.Vec3d;\n import org.spongepowered.asm.mixin.Mixin;\n-import org.spongepowered.common.item.util.TradeOfferUtil;\n-import java.util.List;\n-import java.util.Random;\n+import org.spongepowered.asm.mixin.gen.Accessor;\n \n-@Mixin(MerchantOffers.class)\n-public interface MerchantOffersMixin_API extends TradeOfferListMutator {\n-\n-    @Override\n-    default void accept(final Merchant owner, final List<TradeOffer> tradeOffers, final Random random) {\n-        final MerchantOffers tempList = new MerchantOffers();\n-        for (final TradeOffer offer : tradeOffers) {\n-            tempList.add(TradeOfferUtil.toNative(offer));\n-        }\n-        addMerchantRecipe((IMerchant) owner, tempList, random);\n-        tradeOffers.clear();\n-        for (final MerchantOffer recipe : tempList) {\n-            tradeOffers.add(TradeOfferUtil.fromNative(recipe));\n-        }\n-    }\n+@Mixin(ServerPlayerEntity.class)\n+public interface ServerPlayerEntityAccessor {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg4MTYyNA=="}, "originalCommit": {"oid": "6160b635c9b939b79f879290c1eda656df7f0bbe"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTg1ODcxOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/spongepowered/common/bridge/block/DyeColorBlockBridge.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNTozOToxNlrOGVMuxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNTozOToxNlrOGVMuxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg4MTg2MA==", "bodyText": "I'd rather\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable DyeColor bridge$getDyeColor();\n          \n          \n            \n                Optional<DyeColor> bridge$getDyeColor();", "url": "https://github.com/SpongePowered/Sponge/pull/2609#discussion_r424881860", "createdAt": "2020-05-14T05:39:16Z", "author": {"login": "gabizou"}, "path": "src/main/java/org/spongepowered/common/bridge/block/DyeColorBlockBridge.java", "diffHunk": "@@ -26,7 +26,10 @@\n \n import net.minecraft.item.DyeColor;\n \n-public interface DyeableBlockBridge {\n+import javax.annotation.Nullable;\n+\n+public interface DyeColorBlockBridge {\n \n     void bridge$setDyeColor(DyeColor dyeColor);\n+    @Nullable DyeColor bridge$getDyeColor();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6160b635c9b939b79f879290c1eda656df7f0bbe"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTg2MDAxOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/spongepowered/common/data/provider/DataProviderRegistry.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNTo0MDowM1rOGVMvlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNTo0MDowM1rOGVMvlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg4MjA2OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Stream<DataProvider> stream = this.dataProviders.keySet().stream()\n          \n          \n            \n                    final Stream<DataProvider> stream = this.dataProviders.keySet().stream()", "url": "https://github.com/SpongePowered/Sponge/pull/2609#discussion_r424882069", "createdAt": "2020-05-14T05:40:03Z", "author": {"login": "gabizou"}, "path": "src/main/java/org/spongepowered/common/data/provider/DataProviderRegistry.java", "diffHunk": "@@ -100,10 +101,10 @@ private static boolean filterHolderType(DataProvider<?,?> provider, Class<?> hol\n     }\n \n     private DataProviderLookup loadProviderLookup(Class<?> holderType) {\n-        return new DataProviderLookup(this.dataProviders.keySet().stream()\n-                .map(key -> this.getProvider(key, holderType))\n-                .filter(provider -> !(provider instanceof EmptyDataProvider))\n-                .collect(Collectors.toMap(DataProvider::getKey, Function.identity())));\n+        Stream<DataProvider> stream = this.dataProviders.keySet().stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6160b635c9b939b79f879290c1eda656df7f0bbe"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTg2Mjc5OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/spongepowered/common/data/provider/DataProviderRegistry.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNTo0MToyNlrOGVMxPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNDo1Njo0MlrOGVgT1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg4MjQ5Mw==", "bodyText": "This is really janky to read. Either collect on the stream above or declare a new variable to pass in.", "url": "https://github.com/SpongePowered/Sponge/pull/2609#discussion_r424882493", "createdAt": "2020-05-14T05:41:26Z", "author": {"login": "gabizou"}, "path": "src/main/java/org/spongepowered/common/data/provider/DataProviderRegistry.java", "diffHunk": "@@ -100,10 +101,10 @@ private static boolean filterHolderType(DataProvider<?,?> provider, Class<?> hol\n     }\n \n     private DataProviderLookup loadProviderLookup(Class<?> holderType) {\n-        return new DataProviderLookup(this.dataProviders.keySet().stream()\n-                .map(key -> this.getProvider(key, holderType))\n-                .filter(provider -> !(provider instanceof EmptyDataProvider))\n-                .collect(Collectors.toMap(DataProvider::getKey, Function.identity())));\n+        Stream<DataProvider> stream = this.dataProviders.keySet().stream()\n+                .map(key -> this.getProvider((Key) key, holderType))\n+                .filter(provider -> !(provider instanceof EmptyDataProvider));\n+        return new DataProviderLookup(stream.collect(Collectors.toMap(p -> (Key<?>) p.getKey(), p -> (DataProvider<?, ?>) p)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6160b635c9b939b79f879290c1eda656df7f0bbe"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIwMjY0Ng==", "bodyText": "Collection on the stream caused incompatible types compile errors", "url": "https://github.com/SpongePowered/Sponge/pull/2609#discussion_r425202646", "createdAt": "2020-05-14T14:56:42Z", "author": {"login": "Faithcaio"}, "path": "src/main/java/org/spongepowered/common/data/provider/DataProviderRegistry.java", "diffHunk": "@@ -100,10 +101,10 @@ private static boolean filterHolderType(DataProvider<?,?> provider, Class<?> hol\n     }\n \n     private DataProviderLookup loadProviderLookup(Class<?> holderType) {\n-        return new DataProviderLookup(this.dataProviders.keySet().stream()\n-                .map(key -> this.getProvider(key, holderType))\n-                .filter(provider -> !(provider instanceof EmptyDataProvider))\n-                .collect(Collectors.toMap(DataProvider::getKey, Function.identity())));\n+        Stream<DataProvider> stream = this.dataProviders.keySet().stream()\n+                .map(key -> this.getProvider((Key) key, holderType))\n+                .filter(provider -> !(provider instanceof EmptyDataProvider));\n+        return new DataProviderLookup(stream.collect(Collectors.toMap(p -> (Key<?>) p.getKey(), p -> (DataProvider<?, ?>) p)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg4MjQ5Mw=="}, "originalCommit": {"oid": "6160b635c9b939b79f879290c1eda656df7f0bbe"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTg2MzAwOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/spongepowered/common/data/provider/DataProviderRegistry.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNTo0MTozNFrOGVMxXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNTo0MTozNFrOGVMxXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg4MjUyNw==", "bodyText": "final", "url": "https://github.com/SpongePowered/Sponge/pull/2609#discussion_r424882527", "createdAt": "2020-05-14T05:41:34Z", "author": {"login": "gabizou"}, "path": "src/main/java/org/spongepowered/common/data/provider/DataProviderRegistry.java", "diffHunk": "@@ -143,10 +144,9 @@ public DataProviderLookup getProviderLookup(Class<?> dataHolderType) {\n      */\n     public DataProviderLookup buildLookup(Predicate<DataProvider<?,?>> predicate) {\n         //noinspection unchecked,rawtypes\n-        final Map<Key<?>, DataProvider<?,?>> dataProviders = this.dataProviders.keySet().stream()\n-                .map(key -> buildDelegateProvider(key, (List) this.dataProviders.get(key).stream().filter(predicate)))\n-                .collect(Collectors.toMap(DataProvider::getKey, Function.identity()));\n-        return new DataProviderLookup(dataProviders);\n+        Stream<DataProvider> stream = this.dataProviders.keySet().stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6160b635c9b939b79f879290c1eda656df7f0bbe"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTg2MzI0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/spongepowered/common/data/provider/DataProviderRegistry.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNTo0MTo0M1rOGVMxiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNTo0MTo0M1rOGVMxiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg4MjU2OA==", "bodyText": "Same as before, janky to read..", "url": "https://github.com/SpongePowered/Sponge/pull/2609#discussion_r424882568", "createdAt": "2020-05-14T05:41:43Z", "author": {"login": "gabizou"}, "path": "src/main/java/org/spongepowered/common/data/provider/DataProviderRegistry.java", "diffHunk": "@@ -143,10 +144,9 @@ public DataProviderLookup getProviderLookup(Class<?> dataHolderType) {\n      */\n     public DataProviderLookup buildLookup(Predicate<DataProvider<?,?>> predicate) {\n         //noinspection unchecked,rawtypes\n-        final Map<Key<?>, DataProvider<?,?>> dataProviders = this.dataProviders.keySet().stream()\n-                .map(key -> buildDelegateProvider(key, (List) this.dataProviders.get(key).stream().filter(predicate)))\n-                .collect(Collectors.toMap(DataProvider::getKey, Function.identity()));\n-        return new DataProviderLookup(dataProviders);\n+        Stream<DataProvider> stream = this.dataProviders.keySet().stream()\n+                .map(key -> buildDelegateProvider((Key) key, (List) this.dataProviders.get(key).stream().filter(predicate)));\n+        return new DataProviderLookup(stream.collect(Collectors.toMap(p -> (Key<?>) p.getKey(), p -> (DataProvider<?, ?>) p)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6160b635c9b939b79f879290c1eda656df7f0bbe"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTg2NTQ2OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/spongepowered/common/data/provider/item/stack/ItemStackDyeColorProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNTo0Mjo0OVrOGVMy4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNTo0Mjo0OVrOGVMy4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg4MjkxNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Item item = dataHolder.getItem();\n          \n          \n            \n                    if (item instanceof BlockItem) {\n          \n          \n            \n                        Block block = ((BlockItem) item).getBlock();\n          \n          \n            \n                        net.minecraft.item.DyeColor color = ((DyeColorBlockBridge) block).bridge$getDyeColor();\n          \n          \n            \n                        return Optional.ofNullable((DyeColor) (Object) color);\n          \n          \n            \n                    final Item item = dataHolder.getItem();\n          \n          \n            \n                    if (item instanceof BlockItem) {\n          \n          \n            \n                        final Block block = ((BlockItem) item).getBlock();\n          \n          \n            \n                        return ((DyeColorBlockBridge) block)..bridge$getDyeColor();\n          \n      \n    \n    \n  \n\nThis way you have the optional already provided by the bridge implementation", "url": "https://github.com/SpongePowered/Sponge/pull/2609#discussion_r424882914", "createdAt": "2020-05-14T05:42:49Z", "author": {"login": "gabizou"}, "path": "src/main/java/org/spongepowered/common/data/provider/item/stack/ItemStackDyeColorProvider.java", "diffHunk": "@@ -40,17 +41,19 @@ public ItemStackDyeColorProvider() {\n         super(Keys.DYE_COLOR);\n     }\n \n-    /**\n-     * Maybe try mixin injection in {@link Block.Properties#create(Material, net.minecraft.item.DyeColor)}\n-     * to capture DyeColor.\n-     */\n     @Override\n     protected Optional<DyeColor> getFrom(ItemStack dataHolder) {\n-        return ((DyeColorItemBrige)dataHolder).bridge$getDyeColor();\n+        Item item = dataHolder.getItem();\n+        if (item instanceof BlockItem) {\n+            Block block = ((BlockItem) item).getBlock();\n+            net.minecraft.item.DyeColor color = ((DyeColorBlockBridge) block).bridge$getDyeColor();\n+            return Optional.ofNullable((DyeColor) (Object) color);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6160b635c9b939b79f879290c1eda656df7f0bbe"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTg2NjUyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/spongepowered/common/data/util/StateHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNTo0MzoyNFrOGVMzhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNTo0MzoyNFrOGVMzhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg4MzA3OA==", "bodyText": "Gonna need a class level suppress warnings for raw usage", "url": "https://github.com/SpongePowered/Sponge/pull/2609#discussion_r424883078", "createdAt": "2020-05-14T05:43:24Z", "author": {"login": "gabizou"}, "path": "src/main/java/org/spongepowered/common/data/util/StateHelper.java", "diffHunk": "@@ -35,7 +35,7 @@\n     public static <O, S extends StateHolder<O, S>> S copyStatesFrom(S original, StateHolder<?,?> from) {\n         for (final Map.Entry<IProperty<?>, Comparable<?>> entry : from.getValues().entrySet()) {\n             if (original.has(entry.getKey())) {\n-                original = (S) original.with(entry.getKey(), (Comparable) entry.getValue());\n+                original = (S) original.with((IProperty) entry.getKey(), (Comparable) entry.getValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6160b635c9b939b79f879290c1eda656df7f0bbe"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTg2Nzc1OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/spongepowered/common/entity/EntityUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNTo0NDowNlrOGVM0SQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNTo0NDowNlrOGVM0SQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg4MzI3Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        DimensionType fromType = fromWorld.getDimension().getType();\n          \n          \n            \n                        DimensionType toType = toWorld.getDimension().getType();\n          \n          \n            \n                        final DimensionType fromType = fromWorld.getDimension().getType();\n          \n          \n            \n                        final DimensionType toType = toWorld.getDimension().getType();", "url": "https://github.com/SpongePowered/Sponge/pull/2609#discussion_r424883273", "createdAt": "2020-05-14T05:44:06Z", "author": {"login": "gabizou"}, "path": "src/main/java/org/spongepowered/common/entity/EntityUtil.java", "diffHunk": "@@ -406,72 +407,69 @@ public static ServerPlayerEntity transferPlayerToWorld(final ServerPlayerEntity\n             toWorld = (ServerWorld) event.getToWorld();\n         }\n \n-        final int dimensionId;\n+        final DimensionType dimensionId;\n \n         if (!((ServerPlayerEntityBridge) player).bridge$usesCustomClient()) {\n \n             // Check if the world we're going to matches our provider type. if so, we need to send a fake respawn packet to clear chunks\n-            final int fromClientDimId = WorldManager.getClientDimensionId(player, fromWorld);\n-            final int toClientDimId = WorldManager.getClientDimensionId(player, toWorld);\n+            DimensionType fromType = fromWorld.getDimension().getType();\n+            DimensionType toType = toWorld.getDimension().getType();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6160b635c9b939b79f879290c1eda656df7f0bbe"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTg2ODc2OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/spongepowered/common/entity/EntityUtil.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNTo0NDo0MVrOGVM08g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxOToxNjowMVrOGVqs6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg4MzQ0Mg==", "bodyText": "@Zidane is this right with dimension handling? I'd imagine the type could be the same but the dimension id assigned by the WorldManager could be different?", "url": "https://github.com/SpongePowered/Sponge/pull/2609#discussion_r424883442", "createdAt": "2020-05-14T05:44:41Z", "author": {"login": "gabizou"}, "path": "src/main/java/org/spongepowered/common/entity/EntityUtil.java", "diffHunk": "@@ -406,72 +407,69 @@ public static ServerPlayerEntity transferPlayerToWorld(final ServerPlayerEntity\n             toWorld = (ServerWorld) event.getToWorld();\n         }\n \n-        final int dimensionId;\n+        final DimensionType dimensionId;\n \n         if (!((ServerPlayerEntityBridge) player).bridge$usesCustomClient()) {\n \n             // Check if the world we're going to matches our provider type. if so, we need to send a fake respawn packet to clear chunks\n-            final int fromClientDimId = WorldManager.getClientDimensionId(player, fromWorld);\n-            final int toClientDimId = WorldManager.getClientDimensionId(player, toWorld);\n+            DimensionType fromType = fromWorld.getDimension().getType();\n+            DimensionType toType = toWorld.getDimension().getType();\n \n-            if (fromClientDimId == toClientDimId) {\n-                final int fakeDimId;\n-                switch (fromClientDimId) {\n+            if (fromType == toType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6160b635c9b939b79f879290c1eda656df7f0bbe"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE5OTM4OQ==", "bodyText": "This is to send a fake respawn packet to vanilla clients in case the dimension type is not changing.\nThis entire teleport things needs extensive testing anyways once we can actually start a server.\nMaybe its not needed anymore?", "url": "https://github.com/SpongePowered/Sponge/pull/2609#discussion_r425199389", "createdAt": "2020-05-14T14:52:39Z", "author": {"login": "Faithcaio"}, "path": "src/main/java/org/spongepowered/common/entity/EntityUtil.java", "diffHunk": "@@ -406,72 +407,69 @@ public static ServerPlayerEntity transferPlayerToWorld(final ServerPlayerEntity\n             toWorld = (ServerWorld) event.getToWorld();\n         }\n \n-        final int dimensionId;\n+        final DimensionType dimensionId;\n \n         if (!((ServerPlayerEntityBridge) player).bridge$usesCustomClient()) {\n \n             // Check if the world we're going to matches our provider type. if so, we need to send a fake respawn packet to clear chunks\n-            final int fromClientDimId = WorldManager.getClientDimensionId(player, fromWorld);\n-            final int toClientDimId = WorldManager.getClientDimensionId(player, toWorld);\n+            DimensionType fromType = fromWorld.getDimension().getType();\n+            DimensionType toType = toWorld.getDimension().getType();\n \n-            if (fromClientDimId == toClientDimId) {\n-                final int fakeDimId;\n-                switch (fromClientDimId) {\n+            if (fromType == toType) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg4MzQ0Mg=="}, "originalCommit": {"oid": "6160b635c9b939b79f879290c1eda656df7f0bbe"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIwNDU1Ng==", "bodyText": "No you still have to fake sent a dimension change else you must send an unload packet for every chunk.\nThat is not including the other fun things the client sets based on the dimension.", "url": "https://github.com/SpongePowered/Sponge/pull/2609#discussion_r425204556", "createdAt": "2020-05-14T14:59:01Z", "author": {"login": "Zidane"}, "path": "src/main/java/org/spongepowered/common/entity/EntityUtil.java", "diffHunk": "@@ -406,72 +407,69 @@ public static ServerPlayerEntity transferPlayerToWorld(final ServerPlayerEntity\n             toWorld = (ServerWorld) event.getToWorld();\n         }\n \n-        final int dimensionId;\n+        final DimensionType dimensionId;\n \n         if (!((ServerPlayerEntityBridge) player).bridge$usesCustomClient()) {\n \n             // Check if the world we're going to matches our provider type. if so, we need to send a fake respawn packet to clear chunks\n-            final int fromClientDimId = WorldManager.getClientDimensionId(player, fromWorld);\n-            final int toClientDimId = WorldManager.getClientDimensionId(player, toWorld);\n+            DimensionType fromType = fromWorld.getDimension().getType();\n+            DimensionType toType = toWorld.getDimension().getType();\n \n-            if (fromClientDimId == toClientDimId) {\n-                final int fakeDimId;\n-                switch (fromClientDimId) {\n+            if (fromType == toType) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg4MzQ0Mg=="}, "originalCommit": {"oid": "6160b635c9b939b79f879290c1eda656df7f0bbe"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM3MjkwNw==", "bodyText": "I think this is still mentioned in the protocol wiki", "url": "https://github.com/SpongePowered/Sponge/pull/2609#discussion_r425372907", "createdAt": "2020-05-14T19:16:01Z", "author": {"login": "i509VCB"}, "path": "src/main/java/org/spongepowered/common/entity/EntityUtil.java", "diffHunk": "@@ -406,72 +407,69 @@ public static ServerPlayerEntity transferPlayerToWorld(final ServerPlayerEntity\n             toWorld = (ServerWorld) event.getToWorld();\n         }\n \n-        final int dimensionId;\n+        final DimensionType dimensionId;\n \n         if (!((ServerPlayerEntityBridge) player).bridge$usesCustomClient()) {\n \n             // Check if the world we're going to matches our provider type. if so, we need to send a fake respawn packet to clear chunks\n-            final int fromClientDimId = WorldManager.getClientDimensionId(player, fromWorld);\n-            final int toClientDimId = WorldManager.getClientDimensionId(player, toWorld);\n+            DimensionType fromType = fromWorld.getDimension().getType();\n+            DimensionType toType = toWorld.getDimension().getType();\n \n-            if (fromClientDimId == toClientDimId) {\n-                final int fakeDimId;\n-                switch (fromClientDimId) {\n+            if (fromType == toType) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg4MzQ0Mg=="}, "originalCommit": {"oid": "6160b635c9b939b79f879290c1eda656df7f0bbe"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTg2OTM1OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/spongepowered/common/entity/EntityUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNTo0NDo1OFrOGVM1QQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNTo0NDo1OFrOGVM1QQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg4MzUyMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Vec3d enteredNetherPosition = ((ServerPlayerEntityAccessor) player).accessor$getEnteredNetherPosition();\n          \n          \n            \n                        final Vec3d enteredNetherPosition = ((ServerPlayerEntityAccessor) player).accessor$getEnteredNetherPosition();", "url": "https://github.com/SpongePowered/Sponge/pull/2609#discussion_r424883521", "createdAt": "2020-05-14T05:44:58Z", "author": {"login": "gabizou"}, "path": "src/main/java/org/spongepowered/common/entity/EntityUtil.java", "diffHunk": "@@ -406,72 +407,69 @@ public static ServerPlayerEntity transferPlayerToWorld(final ServerPlayerEntity\n             toWorld = (ServerWorld) event.getToWorld();\n         }\n \n-        final int dimensionId;\n+        final DimensionType dimensionId;\n \n         if (!((ServerPlayerEntityBridge) player).bridge$usesCustomClient()) {\n \n             // Check if the world we're going to matches our provider type. if so, we need to send a fake respawn packet to clear chunks\n-            final int fromClientDimId = WorldManager.getClientDimensionId(player, fromWorld);\n-            final int toClientDimId = WorldManager.getClientDimensionId(player, toWorld);\n+            DimensionType fromType = fromWorld.getDimension().getType();\n+            DimensionType toType = toWorld.getDimension().getType();\n \n-            if (fromClientDimId == toClientDimId) {\n-                final int fakeDimId;\n-                switch (fromClientDimId) {\n+            if (fromType == toType) {\n+                final DimensionType fakeDim;\n+                switch (fromType.getId()) {\n                     case 1:\n-                        fakeDimId = -1;\n+                        fakeDim = DimensionType.THE_NETHER;\n                         break;\n                     case 0:\n-                        fakeDimId = 1;\n+                        fakeDim = DimensionType.THE_END;\n                         break;\n                     default:\n-                        fakeDimId = 0;\n+                        fakeDim = DimensionType.OVERWORLD;\n                         break;\n                 }\n \n-                player.connection.sendPacket(new SRespawnPacket(fakeDimId, toWorld.getDifficulty(), toWorld.getWorldType(),\n-                        player.interactionManager.getGameType()));\n+                player.connection.sendPacket(new SRespawnPacket(fakeDim, toWorld.getWorldType(), player.interactionManager.getGameType()));\n             }\n \n-            dimensionId = toClientDimId;\n+            dimensionId = toType;\n         } else {\n             // We're a custom client, their problem to handle the client provider\n-            WorldManager.sendDimensionRegistration(player, toWorld.dimension);\n+            NetworkUtil.sendDimensionRegistration(player, toWorld.dimension);\n \n-            dimensionId = ((ServerWorldBridge) toWorld).bridge$getDimensionId();\n+            dimensionId = toWorld.getDimension().getType();\n         }\n \n-        player.connection.sendPacket(new SRespawnPacket(dimensionId, toWorld.getDifficulty(), toWorld.getWorldType(),\n-            player.interactionManager.getGameType()));\n+        player.connection.sendPacket(new SRespawnPacket(dimensionId, toWorld.getWorldType(), player.interactionManager.getGameType()));\n+\n \n-        player.dimension = ((ServerWorldBridge) toWorld).bridge$getDimensionId(); // If a Vanilla client, dimensionId could be a provider id.\n+        player.dimension = toWorld.getDimension().getType(); // If a Vanilla client, dimensionId could be a provider id.\n         player.setWorld(toWorld);\n \n         playerList.updatePermissionLevel(player);\n \n-        fromWorld.removeEntityDangerously(player);\n+        fromWorld.removePlayer(player);\n         player.removed = false;\n \n         final Vector3d position = toTransform.getPosition();\n         player.setLocationAndAngles(position.getX(), position.getY(), position.getZ(), (float) toTransform.getYaw(), (float) toTransform.getPitch());\n \n         try (final PhaseContext<?> ignored = EntityPhase.State.CHANGING_DIMENSION.createPhaseContext(PhaseTracker.SERVER).setTargetWorld(toWorld).buildAndSwitch()) {\n-            toWorld.addEntity0(player);\n-            toWorld.updateEntityWithOptionalForce(player, false);\n+            toWorld.addEntity(player);\n+            toWorld.updateEntity(player);\n         }\n \n-        // preparePlayer\n-        fromWorld.getPlayerChunkMap().removePlayer(player);\n-        toWorld.getPlayerChunkMap().addPlayer(player);\n+        toWorld.chunkCheck(player);\n \n-        final Vector3i toChunkPosition = toTransform.getLocation().getChunkPosition();\n-        toWorld.getChunkProvider().provideChunk(toChunkPosition.getX(), toChunkPosition.getZ());\n+        toWorld.getChunkAt(VecHelper.toBlockPos(toTransform.getPosition()));\n \n         if (event instanceof MoveEntityEvent.Teleport.Portal) {\n             CriteriaTriggers.CHANGED_DIMENSION.trigger(player, fromWorld.dimension.getType(), toWorld.dimension.getType());\n \n-            if (fromWorld.dimension.getType() == DimensionType.NETHER && toWorld.dimension.getType() == DimensionType.OVERWORLD\n-                && player.getEnteredNetherPosition() != null) {\n-                CriteriaTriggers.NETHER_TRAVEL.trigger(player, player.getEnteredNetherPosition());\n+            Vec3d enteredNetherPosition = ((ServerPlayerEntityAccessor) player).accessor$getEnteredNetherPosition();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6160b635c9b939b79f879290c1eda656df7f0bbe"}, "originalPosition": 188}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTg2OTg4OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/spongepowered/common/entity/EntityUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNTo0NToxN1rOGVM1kA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNTo0NToxN1rOGVM1kA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg4MzYwMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        CatalogKey key = ((DimensionTypeBridge) toWorld.dimension.getType()).bridge$getKey();\n          \n          \n            \n                        final CatalogKey key = ((DimensionTypeBridge) toWorld.dimension.getType()).bridge$getKey();", "url": "https://github.com/SpongePowered/Sponge/pull/2609#discussion_r424883600", "createdAt": "2020-05-14T05:45:17Z", "author": {"login": "gabizou"}, "path": "src/main/java/org/spongepowered/common/entity/EntityUtil.java", "diffHunk": "@@ -520,30 +516,22 @@ private static InvokingTeleporterContext createInvokingTeleporterPhase(final Ent\n         final Transform fromTransform = sEntity.getTransform();\n         final ServerWorld fromWorld = ((ServerWorld) entity.world);\n \n-        int toDimensionId = ((ServerWorldBridge) toWorld).bridge$getDimensionId();\n-\n-        // Entering End Portal in End goes to Overworld in Vanilla\n-        if (toDimensionId == 1 && fromWorld.dimension instanceof EndDimension) {\n-            toDimensionId = 0;\n-        }\n-\n-        toWorld = mcServer.getWorld(toDimensionId);\n-\n         final Map<String, String> portalAgents =\n             ((WorldInfoBridge) fromWorld.getWorldInfo()).bridge$getConfigAdapter().getConfig().getWorld().getPortalAgents();\n         final String worldName;\n \n         // Check if we're to use a different teleporter for this world\n         if (teleporter.getClass().getName().equals(\"net.minecraft.world.Teleporter\")) {\n-            worldName = portalAgents.get(\"minecraft:default_\" + toWorld.dimension.getType().getName().toLowerCase(Locale.ENGLISH));\n+            CatalogKey key = ((DimensionTypeBridge) toWorld.dimension.getType()).bridge$getKey();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6160b635c9b939b79f879290c1eda656df7f0bbe"}, "originalPosition": 226}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTg3MDM2OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/spongepowered/common/entity/EntityUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNTo0NTozNFrOGVM13A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNTo0NTozNFrOGVM13A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg4MzY3Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    World world = ((org.spongepowered.api.entity.Entity) entityIn).getWorld();\n          \n          \n            \n                    final World world = ((org.spongepowered.api.entity.Entity) entityIn).getWorld();", "url": "https://github.com/SpongePowered/Sponge/pull/2609#discussion_r424883676", "createdAt": "2020-05-14T05:45:34Z", "author": {"login": "gabizou"}, "path": "src/main/java/org/spongepowered/common/entity/EntityUtil.java", "diffHunk": "@@ -661,18 +649,19 @@ public static boolean isEntityDead(final net.minecraft.entity.Entity entity) {\n \n     public static MoveEntityEvent.Teleport handleDisplaceEntityTeleportEvent(final Entity entityIn, final Location location) {\n         final Transform fromTransform = ((org.spongepowered.api.entity.Entity) entityIn).getTransform();\n-        final Transform toTransform = fromTransform.withPosition(location.getPosition()).withRotation(location.get).setRotation(new Vector3d(entityIn.rotationPitch, entityIn.rotationYaw, 0));\n-        return handleDisplaceEntityTeleportEvent(entityIn, fromTransform, toTransform);\n+        final Transform toTransform = fromTransform.withPosition(location.getPosition()).withRotation(new Vector3d(entityIn.rotationPitch, entityIn.rotationYaw, 0));\n+        return handleDisplaceEntityTeleportEvent(entityIn, fromTransform, toTransform, ((org.spongepowered.api.entity.Entity) entityIn).getWorld(), location.getWorld());\n     }\n \n     public static MoveEntityEvent.Teleport handleDisplaceEntityTeleportEvent(final Entity entityIn, final double posX, final double posY, final double posZ, final float yaw, final float pitch) {\n+        World world = ((org.spongepowered.api.entity.Entity) entityIn).getWorld();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6160b635c9b939b79f879290c1eda656df7f0bbe"}, "originalPosition": 283}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTg3MTM4OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/spongepowered/common/event/tracking/phase/plugin/ListenerPhaseContext.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNTo0NjoxMlrOGVM2hQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNTo0NjoxMlrOGVM2hQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg4Mzg0NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                ListenerPhaseContext(final IPhaseState<L> state, PhaseTracker tracker) {\n          \n          \n            \n                ListenerPhaseContext(final IPhaseState<L> state, final PhaseTracker tracker) {", "url": "https://github.com/SpongePowered/Sponge/pull/2609#discussion_r424883845", "createdAt": "2020-05-14T05:46:12Z", "author": {"login": "gabizou"}, "path": "src/main/java/org/spongepowered/common/event/tracking/phase/plugin/ListenerPhaseContext.java", "diffHunk": "@@ -43,7 +44,7 @@\n     Object object;\n     private CapturePlayer capturePlayer;\n \n-    ListenerPhaseContext(final IPhaseState<L> state) {\n+    ListenerPhaseContext(final IPhaseState<L> state, PhaseTracker tracker) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6160b635c9b939b79f879290c1eda656df7f0bbe"}, "originalPosition": 13}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2643, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}