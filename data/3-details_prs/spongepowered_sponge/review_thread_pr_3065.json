{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ5NDc1MjAz", "number": 3065, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNDowMToxMVrOEOsvtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNDoxMTo1OVrOEOtCHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzODQ4NjMxOnYy", "diffSide": "RIGHT", "path": "src/accessors/java/org/spongepowered/common/accessor/network/play/CustomPayloadPacketAccessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNDowMToxMVrOGx_k2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNDowMToxMVrOGx_k2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTA3NTAzNA==", "bodyText": "Nope. Same deal with the net handler bridge, should be a bridge.", "url": "https://github.com/SpongePowered/Sponge/pull/3065#discussion_r455075034", "createdAt": "2020-07-15T14:01:11Z", "author": {"login": "gabizou"}, "path": "src/accessors/java/org/spongepowered/common/accessor/network/play/CustomPayloadPacketAccessor.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * This file is part of Sponge, licensed under the MIT License (MIT).\n+ *\n+ * Copyright (c) SpongePowered <https://www.spongepowered.org>\n+ * Copyright (c) contributors\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.spongepowered.common.accessor.network.play;\n+\n+import net.minecraft.network.PacketBuffer;\n+import net.minecraft.util.ResourceLocation;\n+\n+public interface CustomPayloadPacketAccessor {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6372a712f6e4bfa4ee1f10763ffee8c7e1b55ec"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzODQ5Mjg0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/spongepowered/common/network/channel/ChannelConstants.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNDowMjo0NVrOGx_pGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNDowMjo0NVrOGx_pGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTA3NjEyMg==", "bodyText": "Move to common's constants class.", "url": "https://github.com/SpongePowered/Sponge/pull/3065#discussion_r455076122", "createdAt": "2020-07-15T14:02:45Z", "author": {"login": "gabizou"}, "path": "src/main/java/org/spongepowered/common/network/channel/ChannelConstants.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * This file is part of Sponge, licensed under the MIT License (MIT).\n+ *\n+ * Copyright (c) SpongePowered <https://www.spongepowered.org>\n+ * Copyright (c) contributors\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.spongepowered.common.network.channel;\n+\n+import org.spongepowered.api.ResourceKey;\n+\n+public final class ChannelConstants {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6372a712f6e4bfa4ee1f10763ffee8c7e1b55ec"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzODUwMzMyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/spongepowered/common/network/channel/RegisterChannelHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNDowNToxNVrOGx_v-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNDowNToxNVrOGx_v-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTA3Nzg4MA==", "bodyText": "Move to constants", "url": "https://github.com/SpongePowered/Sponge/pull/3065#discussion_r455077880", "createdAt": "2020-07-15T14:05:15Z", "author": {"login": "gabizou"}, "path": "src/main/java/org/spongepowered/common/network/channel/RegisterChannelHelper.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * This file is part of Sponge, licensed under the MIT License (MIT).\n+ *\n+ * Copyright (c) SpongePowered <https://www.spongepowered.org>\n+ * Copyright (c) contributors\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.spongepowered.common.network.channel;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Splitter;\n+import io.netty.buffer.Unpooled;\n+import org.spongepowered.api.ResourceKey;\n+import org.spongepowered.api.network.channel.ChannelBuf;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public final class RegisterChannelHelper {\n+\n+    /**\n+     * A minecraft channel used to register channels keys.\n+     */\n+    public static final ResourceKey REGISTER_KEY = ResourceKey.minecraft(\"register\");\n+\n+    /**\n+     * A minecraft channel used to unregister channels keys.\n+     */\n+    public static final ResourceKey UNREGISTER_KEY = ResourceKey.minecraft(\"unregister\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6372a712f6e4bfa4ee1f10763ffee8c7e1b55ec"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzODUxNTMxOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/spongepowered/common/network/channel/SpongeChannelRegistry.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNDowNzo0OVrOGx_3qA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNDoyMDo1OVrOGyAdfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTA3OTg0OA==", "bodyText": "Can use the PhaseTracker as is now. But if this whole class shebang is usable from multiple threads, you may have to change the map used to at least ConcurrentHashMap.", "url": "https://github.com/SpongePowered/Sponge/pull/3065#discussion_r455079848", "createdAt": "2020-07-15T14:07:49Z", "author": {"login": "gabizou"}, "path": "src/main/java/org/spongepowered/common/network/channel/SpongeChannelRegistry.java", "diffHunk": "@@ -24,29 +24,298 @@\n  */\n package org.spongepowered.common.network.channel;\n \n-import com.google.inject.Singleton;\n+import static java.util.Objects.requireNonNull;\n+\n+import com.google.common.collect.ImmutableList;\n+import net.minecraft.network.IPacket;\n+import net.minecraft.network.login.client.CCustomPayloadLoginPacket;\n+import net.minecraft.network.login.server.SCustomPayloadLoginPacket;\n+import net.minecraft.network.play.client.CCustomPayloadPacket;\n+import net.minecraft.network.play.server.SCustomPayloadPlayPacket;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.spongepowered.api.Game;\n import org.spongepowered.api.ResourceKey;\n+import org.spongepowered.api.Sponge;\n+import org.spongepowered.api.event.cause.Cause;\n+import org.spongepowered.api.event.cause.EventContext;\n+import org.spongepowered.api.event.lifecycle.RegisterChannelEvent;\n+import org.spongepowered.api.network.EngineConnection;\n import org.spongepowered.api.network.channel.Channel;\n+import org.spongepowered.api.network.channel.ChannelBuf;\n import org.spongepowered.api.network.channel.ChannelRegistry;\n+import org.spongepowered.api.network.channel.NoResponseException;\n+import org.spongepowered.api.network.channel.packet.PacketChannel;\n+import org.spongepowered.api.network.channel.packet.basic.BasicPacketChannel;\n+import org.spongepowered.api.network.channel.raw.RawDataChannel;\n+import org.spongepowered.api.registry.DuplicateRegistrationException;\n+import org.spongepowered.common.SpongeCommon;\n+import org.spongepowered.common.accessor.network.login.client.CCustomPayloadLoginPacketAccessor;\n+import org.spongepowered.common.accessor.network.login.server.SCustomPayloadLoginPacketAccessor;\n+import org.spongepowered.common.accessor.network.play.CustomPayloadPacketAccessor;\n+import org.spongepowered.common.network.channel.packet.SpongeBasicPacketChannel;\n+import org.spongepowered.common.network.channel.packet.SpongePacketChannel;\n+import org.spongepowered.common.network.channel.raw.SpongeRawDataChannel;\n \n import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.BiFunction;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class SpongeChannelRegistry implements ChannelRegistry {\n+\n+    private final Map<ResourceKey, Channel> channels = new HashMap<>();\n+    private final Map<Class<?>, BiFunction<ResourceKey, SpongeChannelRegistry, Channel>> channelBuilders = new HashMap<>();\n+\n+    private final ChannelBufferAllocator bufferAllocator;\n \n-@Singleton\n-public final class SpongeChannelRegistry implements ChannelRegistry {\n+    public SpongeChannelRegistry(final ChannelBufferAllocator bufferAllocator) {\n+        this.bufferAllocator = bufferAllocator;\n+\n+        this.registerChannelType(RawDataChannel.class, SpongeRawDataChannel::new);\n+        this.registerChannelType(BasicPacketChannel.class, SpongeBasicPacketChannel::new);\n+        this.registerChannelType(PacketChannel.class, SpongePacketChannel::new);\n+    }\n+\n+    public ChannelBufferAllocator getBufferAllocator() {\n+        return this.bufferAllocator;\n+    }\n+\n+    private <T extends Channel> void registerChannelType(\n+            final Class<T> channelType, final BiFunction<ResourceKey, SpongeChannelRegistry, T> builder) {\n+        this.channelBuilders.put(channelType, (BiFunction<ResourceKey, SpongeChannelRegistry, Channel>) builder);\n+    }\n+\n+    public <C extends Channel> C createChannel(final ResourceKey channelKey, final Class<C> channelType) throws DuplicateRegistrationException {\n+        requireNonNull(channelKey, \"channelKey\");\n+        requireNonNull(channelType, \"channelType\");\n+        if (this.channels.containsKey(channelKey)) {\n+            throw new DuplicateRegistrationException(\"The channel key \\\"\" + channelKey + \"\\\" is already in use.\");\n+        }\n+        final @Nullable BiFunction<ResourceKey, SpongeChannelRegistry, Channel> builder = this.channelBuilders.get(channelType);\n+        if (builder == null) {\n+            throw new IllegalArgumentException(\"Unsupported channel type: \" + channelType);\n+        }\n+        final Channel channel = builder.apply(channelKey, this);\n+        this.channels.put(channelKey, channel);\n+        return (C) channel;\n+    }\n \n     @Override\n-    public Optional<Channel> get(ResourceKey channelKey) {\n-        return Optional.empty();\n+    public Optional<Channel> get(final ResourceKey channelKey) {\n+        requireNonNull(channelKey, \"channelKey\");\n+        return Optional.ofNullable(this.channels.get(channelKey));\n     }\n \n     @Override\n-    public <C extends Channel> C getOfType(ResourceKey channelKey, Class<C> channelType) {\n-        return null;\n+    public <C extends Channel> C getOfType(final ResourceKey channelKey, final Class<C> channelType) {\n+        requireNonNull(channelKey, \"channelKey\");\n+        requireNonNull(channelType, \"channelType\");\n+        final @Nullable Channel binding = this.channels.get(channelKey);\n+        if (binding != null) {\n+            if (!channelType.isInstance(binding)) {\n+                throw new IllegalStateException(\"There's already a channel registered for \"\n+                        + channelKey + \", but it is not of the requested type \" + channelType);\n+            }\n+            return (C) binding;\n+        }\n+        return this.createChannel(channelKey, channelType);\n     }\n \n     @Override\n     public Collection<Channel> getChannels() {\n-        return null;\n+        return ImmutableList.copyOf(this.channels.values());\n+    }\n+\n+    private static final class ChannelRegistrationsResult {\n+\n+        private final CompletableFuture<Void> future;\n+\n+        private ChannelRegistrationsResult(final CompletableFuture<Void> future) {\n+            this.future = future;\n+        }\n+    }\n+\n+    public void postRegistryEvent() {\n+        final Cause cause = Cause.of(EventContext.empty(), this);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6372a712f6e4bfa4ee1f10763ffee8c7e1b55ec"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTA4OTUzMg==", "bodyText": "Depends where you call this in the lifecycle.\nPart of the lifecycle is before the engine(s) are even created. If so, cannot use PhaseTracker.\nEven if you could, don't see a point. We explicitly know what the cause will always be here, no reason to grab one from the CauseStack.", "url": "https://github.com/SpongePowered/Sponge/pull/3065#discussion_r455089532", "createdAt": "2020-07-15T14:20:59Z", "author": {"login": "Zidane"}, "path": "src/main/java/org/spongepowered/common/network/channel/SpongeChannelRegistry.java", "diffHunk": "@@ -24,29 +24,298 @@\n  */\n package org.spongepowered.common.network.channel;\n \n-import com.google.inject.Singleton;\n+import static java.util.Objects.requireNonNull;\n+\n+import com.google.common.collect.ImmutableList;\n+import net.minecraft.network.IPacket;\n+import net.minecraft.network.login.client.CCustomPayloadLoginPacket;\n+import net.minecraft.network.login.server.SCustomPayloadLoginPacket;\n+import net.minecraft.network.play.client.CCustomPayloadPacket;\n+import net.minecraft.network.play.server.SCustomPayloadPlayPacket;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.spongepowered.api.Game;\n import org.spongepowered.api.ResourceKey;\n+import org.spongepowered.api.Sponge;\n+import org.spongepowered.api.event.cause.Cause;\n+import org.spongepowered.api.event.cause.EventContext;\n+import org.spongepowered.api.event.lifecycle.RegisterChannelEvent;\n+import org.spongepowered.api.network.EngineConnection;\n import org.spongepowered.api.network.channel.Channel;\n+import org.spongepowered.api.network.channel.ChannelBuf;\n import org.spongepowered.api.network.channel.ChannelRegistry;\n+import org.spongepowered.api.network.channel.NoResponseException;\n+import org.spongepowered.api.network.channel.packet.PacketChannel;\n+import org.spongepowered.api.network.channel.packet.basic.BasicPacketChannel;\n+import org.spongepowered.api.network.channel.raw.RawDataChannel;\n+import org.spongepowered.api.registry.DuplicateRegistrationException;\n+import org.spongepowered.common.SpongeCommon;\n+import org.spongepowered.common.accessor.network.login.client.CCustomPayloadLoginPacketAccessor;\n+import org.spongepowered.common.accessor.network.login.server.SCustomPayloadLoginPacketAccessor;\n+import org.spongepowered.common.accessor.network.play.CustomPayloadPacketAccessor;\n+import org.spongepowered.common.network.channel.packet.SpongeBasicPacketChannel;\n+import org.spongepowered.common.network.channel.packet.SpongePacketChannel;\n+import org.spongepowered.common.network.channel.raw.SpongeRawDataChannel;\n \n import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.BiFunction;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class SpongeChannelRegistry implements ChannelRegistry {\n+\n+    private final Map<ResourceKey, Channel> channels = new HashMap<>();\n+    private final Map<Class<?>, BiFunction<ResourceKey, SpongeChannelRegistry, Channel>> channelBuilders = new HashMap<>();\n+\n+    private final ChannelBufferAllocator bufferAllocator;\n \n-@Singleton\n-public final class SpongeChannelRegistry implements ChannelRegistry {\n+    public SpongeChannelRegistry(final ChannelBufferAllocator bufferAllocator) {\n+        this.bufferAllocator = bufferAllocator;\n+\n+        this.registerChannelType(RawDataChannel.class, SpongeRawDataChannel::new);\n+        this.registerChannelType(BasicPacketChannel.class, SpongeBasicPacketChannel::new);\n+        this.registerChannelType(PacketChannel.class, SpongePacketChannel::new);\n+    }\n+\n+    public ChannelBufferAllocator getBufferAllocator() {\n+        return this.bufferAllocator;\n+    }\n+\n+    private <T extends Channel> void registerChannelType(\n+            final Class<T> channelType, final BiFunction<ResourceKey, SpongeChannelRegistry, T> builder) {\n+        this.channelBuilders.put(channelType, (BiFunction<ResourceKey, SpongeChannelRegistry, Channel>) builder);\n+    }\n+\n+    public <C extends Channel> C createChannel(final ResourceKey channelKey, final Class<C> channelType) throws DuplicateRegistrationException {\n+        requireNonNull(channelKey, \"channelKey\");\n+        requireNonNull(channelType, \"channelType\");\n+        if (this.channels.containsKey(channelKey)) {\n+            throw new DuplicateRegistrationException(\"The channel key \\\"\" + channelKey + \"\\\" is already in use.\");\n+        }\n+        final @Nullable BiFunction<ResourceKey, SpongeChannelRegistry, Channel> builder = this.channelBuilders.get(channelType);\n+        if (builder == null) {\n+            throw new IllegalArgumentException(\"Unsupported channel type: \" + channelType);\n+        }\n+        final Channel channel = builder.apply(channelKey, this);\n+        this.channels.put(channelKey, channel);\n+        return (C) channel;\n+    }\n \n     @Override\n-    public Optional<Channel> get(ResourceKey channelKey) {\n-        return Optional.empty();\n+    public Optional<Channel> get(final ResourceKey channelKey) {\n+        requireNonNull(channelKey, \"channelKey\");\n+        return Optional.ofNullable(this.channels.get(channelKey));\n     }\n \n     @Override\n-    public <C extends Channel> C getOfType(ResourceKey channelKey, Class<C> channelType) {\n-        return null;\n+    public <C extends Channel> C getOfType(final ResourceKey channelKey, final Class<C> channelType) {\n+        requireNonNull(channelKey, \"channelKey\");\n+        requireNonNull(channelType, \"channelType\");\n+        final @Nullable Channel binding = this.channels.get(channelKey);\n+        if (binding != null) {\n+            if (!channelType.isInstance(binding)) {\n+                throw new IllegalStateException(\"There's already a channel registered for \"\n+                        + channelKey + \", but it is not of the requested type \" + channelType);\n+            }\n+            return (C) binding;\n+        }\n+        return this.createChannel(channelKey, channelType);\n     }\n \n     @Override\n     public Collection<Channel> getChannels() {\n-        return null;\n+        return ImmutableList.copyOf(this.channels.values());\n+    }\n+\n+    private static final class ChannelRegistrationsResult {\n+\n+        private final CompletableFuture<Void> future;\n+\n+        private ChannelRegistrationsResult(final CompletableFuture<Void> future) {\n+            this.future = future;\n+        }\n+    }\n+\n+    public void postRegistryEvent() {\n+        final Cause cause = Cause.of(EventContext.empty(), this);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTA3OTg0OA=="}, "originalCommit": {"oid": "a6372a712f6e4bfa4ee1f10763ffee8c7e1b55ec"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzODUyNjI1OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/spongepowered/common/network/channel/TransactionStore.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNDoxMDoxOVrOGx_-qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQxNToyNjoyMlrOGzwTDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTA4MTY0Mg==", "bodyText": "Does asMap render the cache as invalid? Haven't read the javadoc on caffeine in a moment, but I'd figure it would make a copy as a Map.", "url": "https://github.com/SpongePowered/Sponge/pull/3065#discussion_r455081642", "createdAt": "2020-07-15T14:10:19Z", "author": {"login": "gabizou"}, "path": "src/main/java/org/spongepowered/common/network/channel/TransactionStore.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * This file is part of Sponge, licensed under the MIT License (MIT).\n+ *\n+ * Copyright (c) SpongePowered <https://www.spongepowered.org>\n+ * Copyright (c) contributors\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.spongepowered.common.network.channel;\n+\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.RemovalCause;\n+import com.github.benmanes.caffeine.cache.RemovalListener;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.spongepowered.api.network.EngineConnection;\n+import org.spongepowered.api.network.channel.TimeoutException;\n+\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A storage for transaction id mappings.\n+ */\n+public final class TransactionStore {\n+\n+    private final Supplier<EngineConnection> connection;\n+\n+    private final AtomicInteger counter = new AtomicInteger();\n+    private final ConcurrentMap<Integer, Entry> lookup = Caffeine.newBuilder()\n+            .expireAfterAccess(1, TimeUnit.MINUTES)\n+            .removalListener((RemovalListener<Integer, Entry>) (key, value, cause) -> {\n+                if (cause == RemovalCause.EXPIRED && value != null) {\n+                    value.getChannel().handleTransactionResponse(\n+                            getConnection(), value.getData(), TransactionResult.failure(new TimeoutException()));\n+                }\n+            })\n+            .build().asMap();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c93b795b8359dbef1ab85b5b6008dc29f06179b6"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkyMTg3MA==", "bodyText": "asMap returns a view of the cache", "url": "https://github.com/SpongePowered/Sponge/pull/3065#discussion_r456921870", "createdAt": "2020-07-19T15:26:22Z", "author": {"login": "Cybermaxke"}, "path": "src/main/java/org/spongepowered/common/network/channel/TransactionStore.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * This file is part of Sponge, licensed under the MIT License (MIT).\n+ *\n+ * Copyright (c) SpongePowered <https://www.spongepowered.org>\n+ * Copyright (c) contributors\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.spongepowered.common.network.channel;\n+\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.RemovalCause;\n+import com.github.benmanes.caffeine.cache.RemovalListener;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.spongepowered.api.network.EngineConnection;\n+import org.spongepowered.api.network.channel.TimeoutException;\n+\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A storage for transaction id mappings.\n+ */\n+public final class TransactionStore {\n+\n+    private final Supplier<EngineConnection> connection;\n+\n+    private final AtomicInteger counter = new AtomicInteger();\n+    private final ConcurrentMap<Integer, Entry> lookup = Caffeine.newBuilder()\n+            .expireAfterAccess(1, TimeUnit.MINUTES)\n+            .removalListener((RemovalListener<Integer, Entry>) (key, value, cause) -> {\n+                if (cause == RemovalCause.EXPIRED && value != null) {\n+                    value.getChannel().handleTransactionResponse(\n+                            getConnection(), value.getData(), TransactionResult.failure(new TimeoutException()));\n+                }\n+            })\n+            .build().asMap();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTA4MTY0Mg=="}, "originalCommit": {"oid": "c93b795b8359dbef1ab85b5b6008dc29f06179b6"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzODUzMzQyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/spongepowered/common/network/channel/packet/AbstractPacketChannel.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNDoxMTo1OVrOGyADRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNDoxMTo1OVrOGyADRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTA4MjgyMQ==", "bodyText": "Concurrent?", "url": "https://github.com/SpongePowered/Sponge/pull/3065#discussion_r455082821", "createdAt": "2020-07-15T14:11:59Z", "author": {"login": "gabizou"}, "path": "src/main/java/org/spongepowered/common/network/channel/packet/AbstractPacketChannel.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * This file is part of Sponge, licensed under the MIT License (MIT).\n+ *\n+ * Copyright (c) SpongePowered <https://www.spongepowered.org>\n+ * Copyright (c) contributors\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.spongepowered.common.network.channel.packet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.netty.handler.codec.CodecException;\n+import io.netty.handler.codec.DecoderException;\n+import io.netty.handler.codec.EncoderException;\n+import it.unimi.dsi.fastutil.ints.Int2ObjectMap;\n+import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.spongepowered.api.ResourceKey;\n+import org.spongepowered.api.network.EngineConnection;\n+import org.spongepowered.api.network.channel.ChannelBuf;\n+import org.spongepowered.api.network.channel.ChannelException;\n+import org.spongepowered.api.network.channel.packet.FixedTransactionalPacketBinding;\n+import org.spongepowered.api.network.channel.packet.HandlerPacketBinding;\n+import org.spongepowered.api.network.channel.packet.Packet;\n+import org.spongepowered.api.network.channel.packet.PacketBinding;\n+import org.spongepowered.api.network.channel.packet.PacketHandler;\n+import org.spongepowered.api.network.channel.packet.RequestPacket;\n+import org.spongepowered.api.network.channel.packet.ResponsePacketHandler;\n+import org.spongepowered.api.network.channel.packet.TransactionalPacketBinding;\n+import org.spongepowered.api.network.channel.packet.TransactionalPacketRegistry;\n+import org.spongepowered.common.SpongeCommon;\n+import org.spongepowered.common.network.channel.ChannelBuffers;\n+import org.spongepowered.common.network.channel.SpongeChannel;\n+import org.spongepowered.common.network.channel.SpongeChannelRegistry;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+\n+public abstract class AbstractPacketChannel extends SpongeChannel implements TransactionalPacketRegistry {\n+\n+    protected final Map<Class<?>, PacketBinding<?>> byType = new HashMap<>();\n+    protected final Int2ObjectMap<PacketBinding<?>> byOpcode = new Int2ObjectOpenHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c93b795b8359dbef1ab85b5b6008dc29f06179b6"}, "originalPosition": 64}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2542, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}