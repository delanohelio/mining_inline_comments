{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUxNzY0NzM5", "number": 2907, "title": "Add client-side HAProxy support", "bodyText": "#2589\nMotivation\nTry to mature client-side proxy related API by adding support for HAProxy.\nModifications\nMisc\nI am thinking of the following behavior:\nProxyConfig.haproxy(src, dest)\n\nUse explicitly available source/dest address info if available\n\nProxyConfig.haproxy()\n\nUse proxiedAddress from ServiceRequestContext if available (for HAProxy only, not FORWARDED).\nOtherwise use connection localAddress, endpoint address\n\nthis behavior is consistent with other clients like curl", "createdAt": "2020-07-18T07:11:45Z", "url": "https://github.com/line/armeria/pull/2907", "merged": true, "mergeCommit": {"oid": "0cdb477ce4c9f4f38998bd65fbc7fcfa0d9b458e"}, "closed": true, "closedAt": "2020-08-03T09:28:53Z", "author": {"login": "jrhee17"}, "timelineItems": {"totalCount": 27, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc4SjvLAH2gAyNDUxNzY0NzM5OjEzZjk5ZGI1NzBiOGE3MmYyNTNhMmQ2Nzg3YjllNGU3YzYyMjZlMzM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc7NwJRAFqTQ1OTg0MDY5Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "13f99db570b8a72f253a2d6787b9e4e7c6226e33", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/13f99db570b8a72f253a2d6787b9e4e7c6226e33", "committedDate": "2020-07-25T06:23:10Z", "message": "add failing tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6582e8ad60b5b14562331dba792d5cd063b0eb36", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/6582e8ad60b5b14562331dba792d5cd063b0eb36", "committedDate": "2020-07-25T13:33:18Z", "message": "add minimal working implementation"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cb57c8b4e84d723c546fd030d7fc4a8d91188f23", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/cb57c8b4e84d723c546fd030d7fc4a8d91188f23", "committedDate": "2020-07-25T13:53:41Z", "message": "add minimal working implementation"}, "afterCommit": {"oid": "6582e8ad60b5b14562331dba792d5cd063b0eb36", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/6582e8ad60b5b14562331dba792d5cd063b0eb36", "committedDate": "2020-07-25T13:33:18Z", "message": "add minimal working implementation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c2902a774f288d72371dd46b222a3c74e43d413", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/2c2902a774f288d72371dd46b222a3c74e43d413", "committedDate": "2020-07-25T15:09:11Z", "message": "fix hanging tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "822f7c30fa65ac8ea4159799887d0b93ee43deb0", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/822f7c30fa65ac8ea4159799887d0b93ee43deb0", "committedDate": "2020-07-26T06:26:49Z", "message": "refactor haproxyselector, improve tests, failure handling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21d67faf1c9de0f729ddd26aa5dd56d37701a8ae", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/21d67faf1c9de0f729ddd26aa5dd56d37701a8ae", "committedDate": "2020-07-26T07:14:08Z", "message": "flaky test, verify h1c retires, move api"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1NDY4MzA2", "url": "https://github.com/line/armeria/pull/2907#pullrequestreview-455468306", "createdAt": "2020-07-27T04:45:59Z", "commit": {"oid": "21d67faf1c9de0f729ddd26aa5dd56d37701a8ae"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QwNDo0NTo1OVrOG3TfIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QwNDo1MDozNVrOG3TjLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY0NDEzMQ==", "bodyText": "Just Exception or Throwable?", "url": "https://github.com/line/armeria/pull/2907#discussion_r460644131", "createdAt": "2020-07-27T04:45:59Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/HAProxyHandler.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyCommand.PROXY;\n+import static io.netty.handler.codec.haproxy.HAProxyProtocolVersion.V2;\n+import static io.netty.handler.codec.haproxy.HAProxyProxiedProtocol.TCP4;\n+\n+import java.net.Inet4Address;\n+import java.net.Inet6Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.client.proxy.HAProxyConfig;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.handler.codec.haproxy.HAProxyMessage;\n+import io.netty.handler.codec.haproxy.HAProxyMessageEncoder;\n+import io.netty.handler.proxy.ProxyConnectException;\n+\n+class HAProxyHandler extends ChannelOutboundHandlerAdapter {\n+    private static final Logger logger = LoggerFactory.getLogger(HAProxyHandler.class);\n+\n+    private final HAProxyConfig haProxyConfig;\n+\n+    HAProxyHandler(HAProxyConfig haProxyConfig) {\n+        this.haProxyConfig = haProxyConfig;\n+    }\n+\n+    @Override\n+    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n+        ctx.pipeline().addBefore(ctx.name(), null, HAProxyMessageEncoder.INSTANCE);\n+        super.handlerAdded(ctx);\n+    }\n+\n+    @Override\n+    public void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress,\n+                        SocketAddress localAddress, ChannelPromise promise) throws Exception {\n+        promise.addListener(f -> {\n+            if (!f.isSuccess()) {\n+                return;\n+            }\n+            try {\n+                ctx.write(createMessage(haProxyConfig, ctx.channel())).addListener(f0 -> {\n+                    if (f0.isSuccess()) {\n+                        ctx.pipeline().remove(HAProxyMessageEncoder.INSTANCE);\n+                    } else {\n+                        ctx.fireExceptionCaught(new ProxyConnectException(f.cause()));\n+                        ctx.close();\n+                    }\n+                });\n+            } catch (RuntimeException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21d67faf1c9de0f729ddd26aa5dd56d37701a8ae"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY0NDMxNg==", "bodyText": "How about throwing a ProxyConnectException instead of IAE?\nCould you include the source and destination addresses in the exception message?", "url": "https://github.com/line/armeria/pull/2907#discussion_r460644316", "createdAt": "2020-07-27T04:46:50Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/HAProxyHandler.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyCommand.PROXY;\n+import static io.netty.handler.codec.haproxy.HAProxyProtocolVersion.V2;\n+import static io.netty.handler.codec.haproxy.HAProxyProxiedProtocol.TCP4;\n+\n+import java.net.Inet4Address;\n+import java.net.Inet6Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.client.proxy.HAProxyConfig;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.handler.codec.haproxy.HAProxyMessage;\n+import io.netty.handler.codec.haproxy.HAProxyMessageEncoder;\n+import io.netty.handler.proxy.ProxyConnectException;\n+\n+class HAProxyHandler extends ChannelOutboundHandlerAdapter {\n+    private static final Logger logger = LoggerFactory.getLogger(HAProxyHandler.class);\n+\n+    private final HAProxyConfig haProxyConfig;\n+\n+    HAProxyHandler(HAProxyConfig haProxyConfig) {\n+        this.haProxyConfig = haProxyConfig;\n+    }\n+\n+    @Override\n+    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n+        ctx.pipeline().addBefore(ctx.name(), null, HAProxyMessageEncoder.INSTANCE);\n+        super.handlerAdded(ctx);\n+    }\n+\n+    @Override\n+    public void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress,\n+                        SocketAddress localAddress, ChannelPromise promise) throws Exception {\n+        promise.addListener(f -> {\n+            if (!f.isSuccess()) {\n+                return;\n+            }\n+            try {\n+                ctx.write(createMessage(haProxyConfig, ctx.channel())).addListener(f0 -> {\n+                    if (f0.isSuccess()) {\n+                        ctx.pipeline().remove(HAProxyMessageEncoder.INSTANCE);\n+                    } else {\n+                        ctx.fireExceptionCaught(new ProxyConnectException(f.cause()));\n+                        ctx.close();\n+                    }\n+                });\n+            } catch (RuntimeException e) {\n+                ctx.channel().eventLoop().execute(\n+                        () -> ctx.pipeline().fireUserEventTriggered(new ProxyConnectException(e)));\n+                ctx.close();\n+            } finally {\n+                ctx.pipeline().remove(this);\n+            }\n+        });\n+        super.connect(ctx, remoteAddress, localAddress, promise);\n+    }\n+\n+    private static HAProxyMessage createMessage(HAProxyConfig haProxyConfig,\n+                                                Channel channel) throws ProxyConnectException {\n+        final InetSocketAddress srcSocketAddress =\n+                haProxyConfig.srcAddress() != null ? haProxyConfig.srcAddress()\n+                                                   : (InetSocketAddress) channel.localAddress();\n+        final InetSocketAddress destSockAddress = haProxyConfig.proxyAddress();\n+        assert destSockAddress != null;\n+\n+        final InetAddress srcAddress = srcSocketAddress.getAddress();\n+        final InetAddress destAddress = destSockAddress.getAddress();\n+\n+        if (srcAddress instanceof Inet4Address && destAddress instanceof Inet4Address) {\n+            return new HAProxyMessage(V2, PROXY, TCP4,\n+                                      srcAddress.getHostAddress(),\n+                                      destAddress.getHostAddress(),\n+                                      srcSocketAddress.getPort(), destSockAddress.getPort());\n+        } else if (srcAddress instanceof Inet6Address && destAddress instanceof Inet6Address) {\n+            return new HAProxyMessage(V2, PROXY, TCP4,\n+                                      srcAddress.getHostAddress(),\n+                                      destAddress.getHostAddress(),\n+                                      srcSocketAddress.getPort(), destSockAddress.getPort());\n+        } else {\n+            logger.warn(\"Incompatible PROXY address types. srcSocketAddress: {}, destSockAddress: {}\",\n+                        srcAddress.getClass(), destAddress.getClass());\n+            throw new IllegalArgumentException(\"incompatible addresses\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21d67faf1c9de0f729ddd26aa5dd56d37701a8ae"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY0NDYxNg==", "bodyText": "// TODO(jrhee17): <more specific action items>", "url": "https://github.com/line/armeria/pull/2907#discussion_r460644616", "createdAt": "2020-07-27T04:48:14Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpSessionHandler.java", "diffHunk": "@@ -336,7 +336,9 @@ public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exc\n                 throw new Error(); // Should never reach here.\n             }\n \n-            if (poolKey.proxyConfig.proxyType() != ProxyType.DIRECT) {\n+            // TODO: this can be improved", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21d67faf1c9de0f729ddd26aa5dd56d37701a8ae"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY0NDg5NQ==", "bodyText": "sourceAddress?", "url": "https://github.com/line/armeria/pull/2907#discussion_r460644895", "createdAt": "2020-07-27T04:49:30Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/proxy/HAProxyConfig.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.proxy;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Objects;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.MoreObjects;\n+\n+/**\n+ * HAPROXY proxy configuration.\n+ */\n+public final class HAProxyConfig extends ProxyConfig {\n+\n+    @Nullable\n+    private final InetSocketAddress srcAddress;\n+\n+    private final InetSocketAddress destAddress;\n+\n+    HAProxyConfig(InetSocketAddress destAddress) {\n+        srcAddress = null;\n+        this.destAddress = destAddress;\n+    }\n+\n+    HAProxyConfig(InetSocketAddress srcAddress, InetSocketAddress destAddress) {\n+        checkArgument(srcAddress.getAddress().getClass() == destAddress.getAddress().getClass(),\n+                      \"srcAddress and destAddress should be the same type\");\n+        this.srcAddress = srcAddress;\n+        this.destAddress = destAddress;\n+    }\n+\n+    @Override\n+    public InetSocketAddress proxyAddress() {\n+        return destAddress;\n+    }\n+\n+    @Override\n+    public ProxyType proxyType() {\n+        return ProxyType.HAPROXY;\n+    }\n+\n+    /**\n+     * TBU.\n+     */\n+    @Nullable\n+    public InetSocketAddress srcAddress() {\n+        return srcAddress;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21d67faf1c9de0f729ddd26aa5dd56d37701a8ae"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY0NTE2Nw==", "bodyText": "proxy protocol -> protocol?", "url": "https://github.com/line/armeria/pull/2907#discussion_r460645167", "createdAt": "2020-07-27T04:50:35Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/proxy/ProxyType.java", "diffHunk": "@@ -39,5 +39,10 @@\n     /**\n      * CONNECT proxy protocol.\n      */\n-    CONNECT\n+    CONNECT,\n+\n+    /**\n+     * HAPROXY proxy protocol.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21d67faf1c9de0f729ddd26aa5dd56d37701a8ae"}, "originalPosition": 8}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "31c2c4fa282b1b15d288516631e5dc00e2d4f369", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/31c2c4fa282b1b15d288516631e5dc00e2d4f369", "committedDate": "2020-07-28T10:40:18Z", "message": "fix javadocs, rename variables"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2NTMxMDIx", "url": "https://github.com/line/armeria/pull/2907#pullrequestreview-456531021", "createdAt": "2020-07-28T11:12:21Z", "commit": {"oid": "31c2c4fa282b1b15d288516631e5dc00e2d4f369"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxMToxMjoyMVrOG4H1hQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxMToxNjo1OFrOG4H_GQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTUwMTgyOQ==", "bodyText": "Shouldn't we call ctx.close() after calling fireUserEventTriggered()?", "url": "https://github.com/line/armeria/pull/2907#discussion_r461501829", "createdAt": "2020-07-28T11:12:21Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/HAProxyHandler.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyCommand.PROXY;\n+import static io.netty.handler.codec.haproxy.HAProxyProtocolVersion.V2;\n+import static io.netty.handler.codec.haproxy.HAProxyProxiedProtocol.TCP4;\n+\n+import java.net.Inet4Address;\n+import java.net.Inet6Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.client.proxy.HAProxyConfig;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.handler.codec.haproxy.HAProxyMessage;\n+import io.netty.handler.codec.haproxy.HAProxyMessageEncoder;\n+import io.netty.handler.proxy.ProxyConnectException;\n+\n+class HAProxyHandler extends ChannelOutboundHandlerAdapter {\n+    private static final Logger logger = LoggerFactory.getLogger(HAProxyHandler.class);\n+\n+    private final HAProxyConfig haProxyConfig;\n+\n+    HAProxyHandler(HAProxyConfig haProxyConfig) {\n+        this.haProxyConfig = haProxyConfig;\n+    }\n+\n+    @Override\n+    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n+        ctx.pipeline().addBefore(ctx.name(), null, HAProxyMessageEncoder.INSTANCE);\n+        super.handlerAdded(ctx);\n+    }\n+\n+    @Override\n+    public void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress,\n+                        SocketAddress localAddress, ChannelPromise promise) throws Exception {\n+        promise.addListener(f -> {\n+            if (!f.isSuccess()) {\n+                return;\n+            }\n+            try {\n+                ctx.write(createMessage(haProxyConfig, ctx.channel())).addListener(f0 -> {\n+                    if (f0.isSuccess()) {\n+                        ctx.pipeline().remove(HAProxyMessageEncoder.INSTANCE);\n+                    } else {\n+                        ctx.fireExceptionCaught(new ProxyConnectException(f0.cause()));\n+                        ctx.close();\n+                    }\n+                });\n+            } catch (Exception e) {\n+                ctx.channel().eventLoop().execute(\n+                        () -> ctx.pipeline().fireUserEventTriggered(new ProxyConnectException(e)));\n+                ctx.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31c2c4fa282b1b15d288516631e5dc00e2d4f369"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTUwNDI4MQ==", "bodyText": "nit: consistency? socket or sock\nOr we could just srdAddress and destAddress", "url": "https://github.com/line/armeria/pull/2907#discussion_r461504281", "createdAt": "2020-07-28T11:16:58Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/HAProxyHandler.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyCommand.PROXY;\n+import static io.netty.handler.codec.haproxy.HAProxyProtocolVersion.V2;\n+import static io.netty.handler.codec.haproxy.HAProxyProxiedProtocol.TCP4;\n+\n+import java.net.Inet4Address;\n+import java.net.Inet6Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.client.proxy.HAProxyConfig;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.handler.codec.haproxy.HAProxyMessage;\n+import io.netty.handler.codec.haproxy.HAProxyMessageEncoder;\n+import io.netty.handler.proxy.ProxyConnectException;\n+\n+class HAProxyHandler extends ChannelOutboundHandlerAdapter {\n+    private static final Logger logger = LoggerFactory.getLogger(HAProxyHandler.class);\n+\n+    private final HAProxyConfig haProxyConfig;\n+\n+    HAProxyHandler(HAProxyConfig haProxyConfig) {\n+        this.haProxyConfig = haProxyConfig;\n+    }\n+\n+    @Override\n+    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n+        ctx.pipeline().addBefore(ctx.name(), null, HAProxyMessageEncoder.INSTANCE);\n+        super.handlerAdded(ctx);\n+    }\n+\n+    @Override\n+    public void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress,\n+                        SocketAddress localAddress, ChannelPromise promise) throws Exception {\n+        promise.addListener(f -> {\n+            if (!f.isSuccess()) {\n+                return;\n+            }\n+            try {\n+                ctx.write(createMessage(haProxyConfig, ctx.channel())).addListener(f0 -> {\n+                    if (f0.isSuccess()) {\n+                        ctx.pipeline().remove(HAProxyMessageEncoder.INSTANCE);\n+                    } else {\n+                        ctx.fireExceptionCaught(new ProxyConnectException(f0.cause()));\n+                        ctx.close();\n+                    }\n+                });\n+            } catch (Exception e) {\n+                ctx.channel().eventLoop().execute(\n+                        () -> ctx.pipeline().fireUserEventTriggered(new ProxyConnectException(e)));\n+                ctx.close();\n+            } finally {\n+                ctx.pipeline().remove(this);\n+            }\n+        });\n+        super.connect(ctx, remoteAddress, localAddress, promise);\n+    }\n+\n+    private static HAProxyMessage createMessage(HAProxyConfig haProxyConfig,\n+                                                Channel channel) throws ProxyConnectException {\n+        final InetSocketAddress srcSocketAddress =\n+                haProxyConfig.sourceAddress() != null ? haProxyConfig.sourceAddress()\n+                                                      : (InetSocketAddress) channel.localAddress();\n+        final InetSocketAddress destSockAddress = haProxyConfig.proxyAddress();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31c2c4fa282b1b15d288516631e5dc00e2d4f369"}, "originalPosition": 89}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab500a254487d6428d182ae231c09b9bc5a73fa5", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/ab500a254487d6428d182ae231c09b9bc5a73fa5", "committedDate": "2020-07-28T14:18:32Z", "message": "close after userevent, consistent naming"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3MTczNjc5", "url": "https://github.com/line/armeria/pull/2907#pullrequestreview-457173679", "createdAt": "2020-07-29T03:43:21Z", "commit": {"oid": "ab500a254487d6428d182ae231c09b9bc5a73fa5"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwMzo0MzoyMVrOG4ndRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwMzo0Mzo1NlrOG4ndug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxOTkwOA==", "bodyText": "Could move this method to ProxyType and make it a member method?", "url": "https://github.com/line/armeria/pull/2907#discussion_r462019908", "createdAt": "2020-07-29T03:43:21Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpSessionHandler.java", "diffHunk": "@@ -446,4 +447,8 @@ static void setPendingException(ChannelHandlerContext ctx, Throwable cause) {\n             logger.warn(\"{} Unexpected suppressed exception:\", ctx.channel(), cause);\n         }\n     }\n+\n+    private static boolean isTunnelingProxy(ProxyType proxyType) {\n+        return proxyType != ProxyType.DIRECT && proxyType != ProxyType.HAPROXY;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab500a254487d6428d182ae231c09b9bc5a73fa5"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAyMDAyNg==", "bodyText": "Could add a hyperlink to the HAPROXY web page.", "url": "https://github.com/line/armeria/pull/2907#discussion_r462020026", "createdAt": "2020-07-29T03:43:56Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/proxy/HAProxyConfig.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.proxy;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Objects;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.MoreObjects;\n+\n+/**\n+ * HAPROXY configuration.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab500a254487d6428d182ae231c09b9bc5a73fa5"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3Mjk2MTcx", "url": "https://github.com/line/armeria/pull/2907#pullrequestreview-457296171", "createdAt": "2020-07-29T08:18:19Z", "commit": {"oid": "ab500a254487d6428d182ae231c09b9bc5a73fa5"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwODoxODoxOVrOG4tuCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwODozNDozOVrOG4uWhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEyMjUwNQ==", "bodyText": "nit: final class", "url": "https://github.com/line/armeria/pull/2907#discussion_r462122505", "createdAt": "2020-07-29T08:18:19Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/HAProxyHandler.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyCommand.PROXY;\n+import static io.netty.handler.codec.haproxy.HAProxyProtocolVersion.V2;\n+import static io.netty.handler.codec.haproxy.HAProxyProxiedProtocol.TCP4;\n+\n+import java.net.Inet4Address;\n+import java.net.Inet6Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.client.proxy.HAProxyConfig;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.handler.codec.haproxy.HAProxyMessage;\n+import io.netty.handler.codec.haproxy.HAProxyMessageEncoder;\n+import io.netty.handler.proxy.ProxyConnectException;\n+\n+class HAProxyHandler extends ChannelOutboundHandlerAdapter {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab500a254487d6428d182ae231c09b9bc5a73fa5"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEzMjg3MA==", "bodyText": "I'm wondering if we need to complete this promise after HAProxyMessage is written successfully so that any message does not go through HAProxyMessageEncoder before it's removed. \ud83e\udd14", "url": "https://github.com/line/armeria/pull/2907#discussion_r462132870", "createdAt": "2020-07-29T08:34:39Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/HAProxyHandler.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyCommand.PROXY;\n+import static io.netty.handler.codec.haproxy.HAProxyProtocolVersion.V2;\n+import static io.netty.handler.codec.haproxy.HAProxyProxiedProtocol.TCP4;\n+\n+import java.net.Inet4Address;\n+import java.net.Inet6Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.client.proxy.HAProxyConfig;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.handler.codec.haproxy.HAProxyMessage;\n+import io.netty.handler.codec.haproxy.HAProxyMessageEncoder;\n+import io.netty.handler.proxy.ProxyConnectException;\n+\n+class HAProxyHandler extends ChannelOutboundHandlerAdapter {\n+    private static final Logger logger = LoggerFactory.getLogger(HAProxyHandler.class);\n+\n+    private final HAProxyConfig haProxyConfig;\n+\n+    HAProxyHandler(HAProxyConfig haProxyConfig) {\n+        this.haProxyConfig = haProxyConfig;\n+    }\n+\n+    @Override\n+    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n+        ctx.pipeline().addBefore(ctx.name(), null, HAProxyMessageEncoder.INSTANCE);\n+        super.handlerAdded(ctx);\n+    }\n+\n+    @Override\n+    public void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress,\n+                        SocketAddress localAddress, ChannelPromise promise) throws Exception {\n+        promise.addListener(f -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab500a254487d6428d182ae231c09b9bc5a73fa5"}, "originalPosition": 60}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3MzExMTI0", "url": "https://github.com/line/armeria/pull/2907#pullrequestreview-457311124", "createdAt": "2020-07-29T08:37:34Z", "commit": {"oid": "ab500a254487d6428d182ae231c09b9bc5a73fa5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwODozNzozNFrOG4udMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwODozNzozNFrOG4udMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEzNDU3Nw==", "bodyText": "Can we follow the pattern?\nfinal EventLoop eventLoop = ctx.channel().eventLoop();\nif (eventLoop.inEventLoop()) {\n    ctx.pipeline().fireUserEventTriggered(new ProxyConnectException(e));\n    ctx.close();\n} else {\n    ....\n}", "url": "https://github.com/line/armeria/pull/2907#discussion_r462134577", "createdAt": "2020-07-29T08:37:34Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/HAProxyHandler.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyCommand.PROXY;\n+import static io.netty.handler.codec.haproxy.HAProxyProtocolVersion.V2;\n+import static io.netty.handler.codec.haproxy.HAProxyProxiedProtocol.TCP4;\n+\n+import java.net.Inet4Address;\n+import java.net.Inet6Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.client.proxy.HAProxyConfig;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.handler.codec.haproxy.HAProxyMessage;\n+import io.netty.handler.codec.haproxy.HAProxyMessageEncoder;\n+import io.netty.handler.proxy.ProxyConnectException;\n+\n+class HAProxyHandler extends ChannelOutboundHandlerAdapter {\n+    private static final Logger logger = LoggerFactory.getLogger(HAProxyHandler.class);\n+\n+    private final HAProxyConfig haProxyConfig;\n+\n+    HAProxyHandler(HAProxyConfig haProxyConfig) {\n+        this.haProxyConfig = haProxyConfig;\n+    }\n+\n+    @Override\n+    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n+        ctx.pipeline().addBefore(ctx.name(), null, HAProxyMessageEncoder.INSTANCE);\n+        super.handlerAdded(ctx);\n+    }\n+\n+    @Override\n+    public void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress,\n+                        SocketAddress localAddress, ChannelPromise promise) throws Exception {\n+        promise.addListener(f -> {\n+            if (!f.isSuccess()) {\n+                return;\n+            }\n+            try {\n+                ctx.write(createMessage(haProxyConfig, ctx.channel())).addListener(f0 -> {\n+                    if (f0.isSuccess()) {\n+                        ctx.pipeline().remove(HAProxyMessageEncoder.INSTANCE);\n+                    } else {\n+                        ctx.fireExceptionCaught(new ProxyConnectException(f0.cause()));\n+                        ctx.close();\n+                    }\n+                });\n+            } catch (Exception e) {\n+                ctx.channel().eventLoop().execute(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab500a254487d6428d182ae231c09b9bc5a73fa5"}, "originalPosition": 74}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3MzE3OTk1", "url": "https://github.com/line/armeria/pull/2907#pullrequestreview-457317995", "createdAt": "2020-07-29T08:46:50Z", "commit": {"oid": "ab500a254487d6428d182ae231c09b9bc5a73fa5"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwODo0Njo1MFrOG4uxzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwODo0NzoyMlrOG4uzHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEzOTg1Mg==", "bodyText": "It's fine to add another version which only takes destinationAddress?", "url": "https://github.com/line/armeria/pull/2907#discussion_r462139852", "createdAt": "2020-07-29T08:46:50Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/proxy/ProxyConfig.java", "diffHunk": "@@ -119,6 +119,21 @@ public static ConnectProxyConfig connect(\n                                       requireNonNull(password, \"password\"), useTls);\n     }\n \n+    /**\n+     * Creates a {@code ProxyConfig} configuration for HAProxy protocol.\n+     *\n+     * @param sourceAddress the source address\n+     * @param destinationAddress the destination address\n+     */\n+    public static HAProxyConfig haproxy(\n+            InetSocketAddress sourceAddress, InetSocketAddress destinationAddress) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab500a254487d6428d182ae231c09b9bc5a73fa5"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE0MDE5MQ==", "bodyText": "How about making this as enum singleton?", "url": "https://github.com/line/armeria/pull/2907#discussion_r462140191", "createdAt": "2020-07-29T08:47:22Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/proxy/HAProxyConfigSelector.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.proxy;\n+\n+import java.net.InetSocketAddress;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ProxiedAddresses;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+class HAProxyConfigSelector implements ProxyConfigSelector {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab500a254487d6428d182ae231c09b9bc5a73fa5"}, "originalPosition": 27}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9873f1edb058fe3a7887149e8276183387c88269", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/9873f1edb058fe3a7887149e8276183387c88269", "committedDate": "2020-07-29T11:02:36Z", "message": "hide iae, add isTunnel, prefer singleton"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3NjE1NDc0", "url": "https://github.com/line/armeria/pull/2907#pullrequestreview-457615474", "createdAt": "2020-07-29T15:04:41Z", "commit": {"oid": "9873f1edb058fe3a7887149e8276183387c88269"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNTowNDo0MVrOG484KQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNToyNTo1NVrOG4916Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM3MDg1Nw==", "bodyText": "Could call ServiceRequestContext.currentOrNull() directly?", "url": "https://github.com/line/armeria/pull/2907#discussion_r462370857", "createdAt": "2020-07-29T15:04:41Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/client/proxy/HAProxyConfigSelector.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.proxy;\n+\n+import java.net.InetSocketAddress;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ProxiedAddresses;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+final class HAProxyConfigSelector implements ProxyConfigSelector {\n+\n+    private HAProxyConfigSelector() {\n+    }\n+\n+    static final HAProxyConfigSelector INSTANCE = new HAProxyConfigSelector();\n+\n+    @Override\n+    public ProxyConfig select(SessionProtocol protocol, Endpoint endpoint) {\n+        // use proxy information in context if available\n+        final ClientRequestContext clientCtx = ClientRequestContext.currentOrNull();\n+        if (clientCtx != null && clientCtx.root() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9873f1edb058fe3a7887149e8276183387c88269"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM4NjY2NQ==", "bodyText": "nit: Introduce a local variable for future.cause()?", "url": "https://github.com/line/armeria/pull/2907#discussion_r462386665", "createdAt": "2020-07-29T15:25:55Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -531,6 +536,9 @@ private void notifyConnect(SessionProtocol desiredProtocol, PoolKey key, Future<\n                     }\n                 });\n             } else {\n+                if (future.cause() instanceof ProxyConnectException) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9873f1edb058fe3a7887149e8276183387c88269"}, "originalPosition": 30}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c199cef542f6cbd2ac4d44e07ac0fc99142beef9", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/c199cef542f6cbd2ac4d44e07ac0fc99142beef9", "committedDate": "2020-07-30T16:48:55Z", "message": "connect to proxyaddress instead of client endpoint"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d3ea52b2e1ebd443d6275f2c08a99544f4dfec81", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/d3ea52b2e1ebd443d6275f2c08a99544f4dfec81", "committedDate": "2020-07-30T16:43:28Z", "message": "connect to proxyaddress instead of client endpoint"}, "afterCommit": {"oid": "c199cef542f6cbd2ac4d44e07ac0fc99142beef9", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/c199cef542f6cbd2ac4d44e07ac0fc99142beef9", "committedDate": "2020-07-30T16:48:55Z", "message": "connect to proxyaddress instead of client endpoint"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NzIyNDA3", "url": "https://github.com/line/armeria/pull/2907#pullrequestreview-459722407", "createdAt": "2020-08-03T03:01:10Z", "commit": {"oid": "c199cef542f6cbd2ac4d44e07ac0fc99142beef9"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QwMzowMToxMFrOG6quyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QwMzowMToxMFrOG6quyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE3MDY5Ng==", "bodyText": "Shouldn't this come before .add()s?", "url": "https://github.com/line/armeria/pull/2907#discussion_r464170696", "createdAt": "2020-08-03T03:01:10Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/proxy/HAProxyConfig.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.proxy;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Objects;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.MoreObjects;\n+\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+/**\n+ * <a href=\"http://www.haproxy.org/download/1.8/doc/proxy-protocol.txt\">HAPROXY configuration.</a>\n+ */\n+public final class HAProxyConfig extends ProxyConfig {\n+\n+    private final InetSocketAddress proxyAddress;\n+\n+    @Nullable\n+    private final InetSocketAddress sourceAddress;\n+\n+    HAProxyConfig(InetSocketAddress proxyAddress) {\n+        this.proxyAddress = proxyAddress;\n+        sourceAddress = null;\n+    }\n+\n+    HAProxyConfig(InetSocketAddress proxyAddress, InetSocketAddress sourceAddress) {\n+        checkArgument(sourceAddress.getAddress().getClass() == proxyAddress.getAddress().getClass(),\n+                      \"sourceAddress and proxyAddress should be the same type\");\n+        this.proxyAddress = proxyAddress;\n+        this.sourceAddress = sourceAddress;\n+    }\n+\n+    @Override\n+    public ProxyType proxyType() {\n+        return ProxyType.HAPROXY;\n+    }\n+\n+    @Override\n+    public InetSocketAddress proxyAddress() {\n+        return proxyAddress;\n+    }\n+\n+    /**\n+     * Represents the source address. When this value is {@code null}, it will be inferred\n+     * from either the {@link ServiceRequestContext} or the local connection address.\n+     */\n+    @Nullable\n+    public InetSocketAddress sourceAddress() {\n+        return sourceAddress;\n+    }\n+\n+    @Override\n+    public boolean equals(@Nullable Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (!(o instanceof HAProxyConfig)) {\n+            return false;\n+        }\n+        final HAProxyConfig that = (HAProxyConfig) o;\n+        return proxyAddress.equals(that.proxyAddress) &&\n+               Objects.equals(sourceAddress, that.sourceAddress);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(proxyAddress, sourceAddress);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return MoreObjects.toStringHelper(this)\n+                          .add(\"proxyType\", proxyType())\n+                          .add(\"proxyAddress\", proxyAddress)\n+                          .add(\"sourceAddress\", sourceAddress)\n+                          .omitNullValues()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c199cef542f6cbd2ac4d44e07ac0fc99142beef9"}, "originalPosition": 95}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NzQzODkz", "url": "https://github.com/line/armeria/pull/2907#pullrequestreview-459743893", "createdAt": "2020-08-03T04:39:14Z", "commit": {"oid": "c199cef542f6cbd2ac4d44e07ac0fc99142beef9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QwNDozOToxNFrOG6r73A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QwNDozOToxNFrOG6r73A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE5MDQyOA==", "bodyText": "nit: Could replace with join()? Unless you intended to control a specific timeout, JUnit will do it for you.\n\n  \n    \n      armeria/testing-internal/src/main/resources/junit-platform.properties\n    \n    \n         Line 1\n      in\n      ad0350c\n    \n    \n    \n    \n\n        \n          \n           junit.jupiter.execution.timeout.default = 60s", "url": "https://github.com/line/armeria/pull/2907#discussion_r464190428", "createdAt": "2020-08-03T04:39:14Z", "author": {"login": "ikhoon"}, "path": "core/src/test/java/com/linecorp/armeria/client/proxy/HAProxyClientIntegrationTest.java", "diffHunk": "@@ -0,0 +1,393 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.proxy;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.awaitility.Awaitility.await;\n+import static org.junit.jupiter.params.provider.Arguments.arguments;\n+\n+import java.net.ConnectException;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.ArgumentsProvider;\n+import org.junit.jupiter.params.provider.ArgumentsSource;\n+\n+import com.linecorp.armeria.client.ClientFactory;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.UnprocessedRequestException;\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.client.logging.LoggingClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.logging.RequestLogProperty;\n+import com.linecorp.armeria.common.util.SafeCloseable;\n+import com.linecorp.armeria.internal.testing.DynamicBehaviorHandler;\n+import com.linecorp.armeria.internal.testing.NettyServerExtension;\n+import com.linecorp.armeria.server.ProxiedAddresses;\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.testing.junit5.server.ServerExtension;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.handler.codec.haproxy.HAProxyMessage;\n+import io.netty.handler.codec.haproxy.HAProxyMessageDecoder;\n+import io.netty.handler.codec.http.DefaultFullHttpResponse;\n+import io.netty.handler.codec.http.DefaultHttpHeaders;\n+import io.netty.handler.codec.http.EmptyHttpHeaders;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaders;\n+import io.netty.handler.codec.http.HttpObjectAggregator;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.logging.LoggingHandler;\n+import io.netty.util.ReferenceCountUtil;\n+\n+class HAProxyClientIntegrationTest {\n+    private static final String PROXY_PATH = \"/proxy\";\n+    private static final DynamicBehaviorHandler DYNAMIC_HANDLER = new DynamicBehaviorHandler();\n+\n+    @RegisterExtension\n+    static ServerExtension backendServer = new ServerExtension() {\n+        @Override\n+        protected void configure(ServerBuilder sb) throws Exception {\n+            sb.port(0, SessionProtocol.HTTP, SessionProtocol.PROXY);\n+            sb.port(0, SessionProtocol.HTTPS, SessionProtocol.PROXY);\n+            sb.tlsSelfSigned();\n+            sb.service(PROXY_PATH, (ctx, req) -> {\n+                assertThat(ctx.proxiedAddresses().destinationAddresses()).hasSize(1);\n+                final String proxyString = String.format(\"%s-%s\", ctx.proxiedAddresses().sourceAddress(),\n+                                                         ctx.proxiedAddresses().destinationAddresses().get(0));\n+                return HttpResponse.of(proxyString);\n+            });\n+        }\n+    };\n+\n+    @RegisterExtension\n+    static NettyServerExtension http1Server = new NettyServerExtension() {\n+        @Override\n+        protected void configure(Channel ch) throws Exception {\n+            ch.pipeline().addLast(new LoggingHandler(getClass()));\n+            ch.pipeline().addLast(new HAProxyMessageDecoder());\n+            ch.pipeline().addLast(new HttpServerCodec());\n+            ch.pipeline().addLast(new HttpObjectAggregator(1024));\n+            ch.pipeline().addLast(DYNAMIC_HANDLER);\n+        }\n+    };\n+\n+    @ParameterizedTest\n+    @ArgumentsSource(ProtocolEndpointProvider.class)\n+    void testExplicitHAProxy(SessionProtocol sessionProtocol, InetSocketAddress proxyAddr) throws Exception {\n+        final InetSocketAddress srcAddr = new InetSocketAddress(\"127.0.0.2\", 82);\n+        final InetSocketAddress destAddr = new InetSocketAddress(\"127.0.0.3\", 83);\n+        final Endpoint destEndpoint = Endpoint.of(destAddr.getHostString(), destAddr.getPort());\n+\n+        try (ClientFactory clientFactory =\n+                     ClientFactory.builder()\n+                                  .proxyConfig(ProxyConfig.haproxy(proxyAddr, srcAddr))\n+                                  .tlsNoVerify()\n+                                  .useHttp2Preface(true)\n+                                  .build()) {\n+\n+            final WebClient webClient = WebClient.builder(sessionProtocol, destEndpoint)\n+                                                 .factory(clientFactory)\n+                                                 .decorator(LoggingClient.newDecorator())\n+                                                 .build();\n+            final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                    webClient.get(PROXY_PATH).aggregate();\n+\n+            final AggregatedHttpResponse response = responseFuture.get(10, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c199cef542f6cbd2ac4d44e07ac0fc99142beef9"}, "originalPosition": 131}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NzQ0MDg0", "url": "https://github.com/line/armeria/pull/2907#pullrequestreview-459744084", "createdAt": "2020-08-03T04:40:00Z", "commit": {"oid": "c199cef542f6cbd2ac4d44e07ac0fc99142beef9"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QwNDo0MDowMFrOG6r8nA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QwNDo1MzoxMFrOG6sG8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE5MDYyMA==", "bodyText": "Ditto", "url": "https://github.com/line/armeria/pull/2907#discussion_r464190620", "createdAt": "2020-08-03T04:40:00Z", "author": {"login": "ikhoon"}, "path": "core/src/test/java/com/linecorp/armeria/client/proxy/HAProxyClientIntegrationTest.java", "diffHunk": "@@ -0,0 +1,393 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.proxy;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.awaitility.Awaitility.await;\n+import static org.junit.jupiter.params.provider.Arguments.arguments;\n+\n+import java.net.ConnectException;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.ArgumentsProvider;\n+import org.junit.jupiter.params.provider.ArgumentsSource;\n+\n+import com.linecorp.armeria.client.ClientFactory;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.UnprocessedRequestException;\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.client.logging.LoggingClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.logging.RequestLogProperty;\n+import com.linecorp.armeria.common.util.SafeCloseable;\n+import com.linecorp.armeria.internal.testing.DynamicBehaviorHandler;\n+import com.linecorp.armeria.internal.testing.NettyServerExtension;\n+import com.linecorp.armeria.server.ProxiedAddresses;\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.testing.junit5.server.ServerExtension;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.handler.codec.haproxy.HAProxyMessage;\n+import io.netty.handler.codec.haproxy.HAProxyMessageDecoder;\n+import io.netty.handler.codec.http.DefaultFullHttpResponse;\n+import io.netty.handler.codec.http.DefaultHttpHeaders;\n+import io.netty.handler.codec.http.EmptyHttpHeaders;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaders;\n+import io.netty.handler.codec.http.HttpObjectAggregator;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.logging.LoggingHandler;\n+import io.netty.util.ReferenceCountUtil;\n+\n+class HAProxyClientIntegrationTest {\n+    private static final String PROXY_PATH = \"/proxy\";\n+    private static final DynamicBehaviorHandler DYNAMIC_HANDLER = new DynamicBehaviorHandler();\n+\n+    @RegisterExtension\n+    static ServerExtension backendServer = new ServerExtension() {\n+        @Override\n+        protected void configure(ServerBuilder sb) throws Exception {\n+            sb.port(0, SessionProtocol.HTTP, SessionProtocol.PROXY);\n+            sb.port(0, SessionProtocol.HTTPS, SessionProtocol.PROXY);\n+            sb.tlsSelfSigned();\n+            sb.service(PROXY_PATH, (ctx, req) -> {\n+                assertThat(ctx.proxiedAddresses().destinationAddresses()).hasSize(1);\n+                final String proxyString = String.format(\"%s-%s\", ctx.proxiedAddresses().sourceAddress(),\n+                                                         ctx.proxiedAddresses().destinationAddresses().get(0));\n+                return HttpResponse.of(proxyString);\n+            });\n+        }\n+    };\n+\n+    @RegisterExtension\n+    static NettyServerExtension http1Server = new NettyServerExtension() {\n+        @Override\n+        protected void configure(Channel ch) throws Exception {\n+            ch.pipeline().addLast(new LoggingHandler(getClass()));\n+            ch.pipeline().addLast(new HAProxyMessageDecoder());\n+            ch.pipeline().addLast(new HttpServerCodec());\n+            ch.pipeline().addLast(new HttpObjectAggregator(1024));\n+            ch.pipeline().addLast(DYNAMIC_HANDLER);\n+        }\n+    };\n+\n+    @ParameterizedTest\n+    @ArgumentsSource(ProtocolEndpointProvider.class)\n+    void testExplicitHAProxy(SessionProtocol sessionProtocol, InetSocketAddress proxyAddr) throws Exception {\n+        final InetSocketAddress srcAddr = new InetSocketAddress(\"127.0.0.2\", 82);\n+        final InetSocketAddress destAddr = new InetSocketAddress(\"127.0.0.3\", 83);\n+        final Endpoint destEndpoint = Endpoint.of(destAddr.getHostString(), destAddr.getPort());\n+\n+        try (ClientFactory clientFactory =\n+                     ClientFactory.builder()\n+                                  .proxyConfig(ProxyConfig.haproxy(proxyAddr, srcAddr))\n+                                  .tlsNoVerify()\n+                                  .useHttp2Preface(true)\n+                                  .build()) {\n+\n+            final WebClient webClient = WebClient.builder(sessionProtocol, destEndpoint)\n+                                                 .factory(clientFactory)\n+                                                 .decorator(LoggingClient.newDecorator())\n+                                                 .build();\n+            final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                    webClient.get(PROXY_PATH).aggregate();\n+\n+            final AggregatedHttpResponse response = responseFuture.get(10, TimeUnit.SECONDS);\n+            assertThat(response.status()).isEqualTo(HttpStatus.OK);\n+            final String expectedResponse = String.format(\"%s-%s\", srcAddr,\n+                                                          destAddr);\n+            assertThat(response.contentUtf8()).isEqualTo(expectedResponse);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ArgumentsSource(ProtocolEndpointProvider.class)\n+    void testSourceAddrFromRootContextIfAvailable(\n+            SessionProtocol sessionProtocol, InetSocketAddress proxyAddr) throws Exception {\n+        final InetSocketAddress srcAddr = new InetSocketAddress(\"127.0.0.2\", 82);\n+        final InetSocketAddress destAddr = new InetSocketAddress(\"127.0.0.3\", 83);\n+        final Endpoint destEndpoint = Endpoint.of(destAddr.getHostString(), destAddr.getPort());\n+\n+        final ServiceRequestContext serviceRequestContext =\n+                ServiceRequestContext.builder(\n+                        HttpRequest.of(HttpMethod.GET, \"/\"))\n+                                     .proxiedAddresses(ProxiedAddresses.of(srcAddr)).build();\n+\n+        try (SafeCloseable ignored = serviceRequestContext.push();\n+             ClientFactory clientFactory =\n+                     ClientFactory.builder()\n+                                  .proxyConfig(ProxyConfig.haproxy(proxyAddr))\n+                                  .tlsNoVerify()\n+                                  .useHttp2Preface(true)\n+                                  .build()) {\n+\n+            final WebClient webClient = WebClient.builder(sessionProtocol, destEndpoint)\n+                                                 .factory(clientFactory)\n+                                                 .decorator(LoggingClient.newDecorator())\n+                                                 .build();\n+            final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                    webClient.get(PROXY_PATH).aggregate();\n+\n+            final AggregatedHttpResponse response = responseFuture.get(10, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c199cef542f6cbd2ac4d44e07ac0fc99142beef9"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE5MTU1Nw==", "bodyText": "Could simplify:\nStream.concat(SessionProtocol.httpValues().stream(), SessionProtocol.httpsValues().stream())\n      .map(p -> arguments(p, backendServer.httpSocketAddress()));", "url": "https://github.com/line/armeria/pull/2907#discussion_r464191557", "createdAt": "2020-08-03T04:44:33Z", "author": {"login": "ikhoon"}, "path": "core/src/test/java/com/linecorp/armeria/client/proxy/HAProxyClientIntegrationTest.java", "diffHunk": "@@ -0,0 +1,393 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.proxy;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.awaitility.Awaitility.await;\n+import static org.junit.jupiter.params.provider.Arguments.arguments;\n+\n+import java.net.ConnectException;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.ArgumentsProvider;\n+import org.junit.jupiter.params.provider.ArgumentsSource;\n+\n+import com.linecorp.armeria.client.ClientFactory;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.UnprocessedRequestException;\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.client.logging.LoggingClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.logging.RequestLogProperty;\n+import com.linecorp.armeria.common.util.SafeCloseable;\n+import com.linecorp.armeria.internal.testing.DynamicBehaviorHandler;\n+import com.linecorp.armeria.internal.testing.NettyServerExtension;\n+import com.linecorp.armeria.server.ProxiedAddresses;\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.testing.junit5.server.ServerExtension;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.handler.codec.haproxy.HAProxyMessage;\n+import io.netty.handler.codec.haproxy.HAProxyMessageDecoder;\n+import io.netty.handler.codec.http.DefaultFullHttpResponse;\n+import io.netty.handler.codec.http.DefaultHttpHeaders;\n+import io.netty.handler.codec.http.EmptyHttpHeaders;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaders;\n+import io.netty.handler.codec.http.HttpObjectAggregator;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.logging.LoggingHandler;\n+import io.netty.util.ReferenceCountUtil;\n+\n+class HAProxyClientIntegrationTest {\n+    private static final String PROXY_PATH = \"/proxy\";\n+    private static final DynamicBehaviorHandler DYNAMIC_HANDLER = new DynamicBehaviorHandler();\n+\n+    @RegisterExtension\n+    static ServerExtension backendServer = new ServerExtension() {\n+        @Override\n+        protected void configure(ServerBuilder sb) throws Exception {\n+            sb.port(0, SessionProtocol.HTTP, SessionProtocol.PROXY);\n+            sb.port(0, SessionProtocol.HTTPS, SessionProtocol.PROXY);\n+            sb.tlsSelfSigned();\n+            sb.service(PROXY_PATH, (ctx, req) -> {\n+                assertThat(ctx.proxiedAddresses().destinationAddresses()).hasSize(1);\n+                final String proxyString = String.format(\"%s-%s\", ctx.proxiedAddresses().sourceAddress(),\n+                                                         ctx.proxiedAddresses().destinationAddresses().get(0));\n+                return HttpResponse.of(proxyString);\n+            });\n+        }\n+    };\n+\n+    @RegisterExtension\n+    static NettyServerExtension http1Server = new NettyServerExtension() {\n+        @Override\n+        protected void configure(Channel ch) throws Exception {\n+            ch.pipeline().addLast(new LoggingHandler(getClass()));\n+            ch.pipeline().addLast(new HAProxyMessageDecoder());\n+            ch.pipeline().addLast(new HttpServerCodec());\n+            ch.pipeline().addLast(new HttpObjectAggregator(1024));\n+            ch.pipeline().addLast(DYNAMIC_HANDLER);\n+        }\n+    };\n+\n+    @ParameterizedTest\n+    @ArgumentsSource(ProtocolEndpointProvider.class)\n+    void testExplicitHAProxy(SessionProtocol sessionProtocol, InetSocketAddress proxyAddr) throws Exception {\n+        final InetSocketAddress srcAddr = new InetSocketAddress(\"127.0.0.2\", 82);\n+        final InetSocketAddress destAddr = new InetSocketAddress(\"127.0.0.3\", 83);\n+        final Endpoint destEndpoint = Endpoint.of(destAddr.getHostString(), destAddr.getPort());\n+\n+        try (ClientFactory clientFactory =\n+                     ClientFactory.builder()\n+                                  .proxyConfig(ProxyConfig.haproxy(proxyAddr, srcAddr))\n+                                  .tlsNoVerify()\n+                                  .useHttp2Preface(true)\n+                                  .build()) {\n+\n+            final WebClient webClient = WebClient.builder(sessionProtocol, destEndpoint)\n+                                                 .factory(clientFactory)\n+                                                 .decorator(LoggingClient.newDecorator())\n+                                                 .build();\n+            final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                    webClient.get(PROXY_PATH).aggregate();\n+\n+            final AggregatedHttpResponse response = responseFuture.get(10, TimeUnit.SECONDS);\n+            assertThat(response.status()).isEqualTo(HttpStatus.OK);\n+            final String expectedResponse = String.format(\"%s-%s\", srcAddr,\n+                                                          destAddr);\n+            assertThat(response.contentUtf8()).isEqualTo(expectedResponse);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ArgumentsSource(ProtocolEndpointProvider.class)\n+    void testSourceAddrFromRootContextIfAvailable(\n+            SessionProtocol sessionProtocol, InetSocketAddress proxyAddr) throws Exception {\n+        final InetSocketAddress srcAddr = new InetSocketAddress(\"127.0.0.2\", 82);\n+        final InetSocketAddress destAddr = new InetSocketAddress(\"127.0.0.3\", 83);\n+        final Endpoint destEndpoint = Endpoint.of(destAddr.getHostString(), destAddr.getPort());\n+\n+        final ServiceRequestContext serviceRequestContext =\n+                ServiceRequestContext.builder(\n+                        HttpRequest.of(HttpMethod.GET, \"/\"))\n+                                     .proxiedAddresses(ProxiedAddresses.of(srcAddr)).build();\n+\n+        try (SafeCloseable ignored = serviceRequestContext.push();\n+             ClientFactory clientFactory =\n+                     ClientFactory.builder()\n+                                  .proxyConfig(ProxyConfig.haproxy(proxyAddr))\n+                                  .tlsNoVerify()\n+                                  .useHttp2Preface(true)\n+                                  .build()) {\n+\n+            final WebClient webClient = WebClient.builder(sessionProtocol, destEndpoint)\n+                                                 .factory(clientFactory)\n+                                                 .decorator(LoggingClient.newDecorator())\n+                                                 .build();\n+            final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                    webClient.get(PROXY_PATH).aggregate();\n+\n+            final AggregatedHttpResponse response = responseFuture.get(10, TimeUnit.SECONDS);\n+            assertThat(response.status()).isEqualTo(HttpStatus.OK);\n+            assertThat(destEndpoint.ipAddr()).isNotNull();\n+\n+            final String expectedResponse = String.format(\"%s-%s\", srcAddr, destAddr);\n+            assertThat(response.contentUtf8()).isEqualTo(expectedResponse);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ArgumentsSource(ProtocolEndpointProvider.class)\n+    void testImplicitHAProxyWithoutRootContextUsesDefault(\n+            SessionProtocol sessionProtocol, InetSocketAddress proxyAddr) throws Exception {\n+        final InetSocketAddress destAddr = new InetSocketAddress(\"127.0.0.3\", 83);\n+        final Endpoint destEndpoint = Endpoint.of(destAddr.getHostString(), destAddr.getPort());\n+        try (ClientFactory clientFactory =\n+                     ClientFactory.builder()\n+                                  .proxyConfig(ProxyConfig.haproxy(proxyAddr))\n+                                  .tlsNoVerify()\n+                                  .useHttp2Preface(true)\n+                                  .build()) {\n+\n+            final AtomicReference<InetSocketAddress> srcAddressRef = new AtomicReference<>();\n+            final WebClient webClient =\n+                    WebClient.builder(sessionProtocol, destEndpoint)\n+                             .factory(clientFactory)\n+                             .decorator(LoggingClient.newDecorator())\n+                             .decorator((delegate, ctx, req) -> {\n+                                 final HttpResponse response = delegate.execute(ctx, req);\n+                                 await().atMost(10, TimeUnit.SECONDS).until(\n+                                         () -> ctx.log().isAvailable(RequestLogProperty.SESSION));\n+                                 srcAddressRef.set(ctx.localAddress());\n+                                 return response;\n+                             })\n+                             .build();\n+            final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                    webClient.get(PROXY_PATH).aggregate();\n+\n+            final AggregatedHttpResponse response = responseFuture.get(10, TimeUnit.SECONDS);\n+            assertThat(response.status()).isEqualTo(HttpStatus.OK);\n+            final String expectedResponse = String.format(\"%s-%s\", srcAddressRef.get(), destAddr);\n+            assertThat(response.contentUtf8()).isEqualTo(expectedResponse);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ArgumentsSource(ProtocolEndpointProvider.class)\n+    void testDifferentIpFamily(SessionProtocol sessionProtocol, InetSocketAddress proxyAddr) throws Exception {\n+        final InetSocketAddress srcAddr = new InetSocketAddress(\"127.0.0.2\", 82);\n+        final InetSocketAddress destAddr = new InetSocketAddress(\"0:0:0:0:0:0:0:1\", 83);\n+        final Endpoint destEndpoint = Endpoint.of(destAddr.getHostString(), destAddr.getPort());\n+        try (ClientFactory clientFactory =\n+                     ClientFactory.builder()\n+                                  .proxyConfig(ProxyConfig.haproxy(proxyAddr, srcAddr))\n+                                  .tlsNoVerify()\n+                                  .useHttp2Preface(true)\n+                                  .build()) {\n+\n+            final WebClient webClient = WebClient.builder(sessionProtocol, destEndpoint)\n+                                                 .factory(clientFactory)\n+                                                 .decorator(LoggingClient.newDecorator())\n+                                                 .build();\n+            final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                    webClient.get(PROXY_PATH).aggregate();\n+\n+            final AggregatedHttpResponse response = responseFuture.get(10, TimeUnit.SECONDS);\n+            assertThat(response.status()).isEqualTo(HttpStatus.OK);\n+            final String expectedResponse = String.format(\"%s-%s\", srcAddr, destAddr);\n+            assertThat(response.contentUtf8()).isEqualTo(expectedResponse);\n+        }\n+    }\n+\n+    @Test\n+    void testConnectionFailure() throws Exception {\n+        final int unusedPort;\n+        try (ServerSocket ss = new ServerSocket(0)) {\n+            unusedPort = ss.getLocalPort();\n+        }\n+        try (ClientFactory clientFactory =\n+                     ClientFactory.builder()\n+                                  .proxyConfig(ProxyConfig.haproxy(new InetSocketAddress(unusedPort)))\n+                                  .useHttp2Preface(true)\n+                                  .build()) {\n+\n+            final WebClient webClient = WebClient.builder(SessionProtocol.H1C, backendServer.httpEndpoint())\n+                                                 .factory(clientFactory)\n+                                                 .decorator(LoggingClient.newDecorator())\n+                                                 .build();\n+            final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                    webClient.get(PROXY_PATH).aggregate();\n+\n+            assertThatThrownBy(() -> responseFuture.get(10, TimeUnit.SECONDS))\n+                    .isInstanceOf(ExecutionException.class)\n+                    .hasCauseInstanceOf(UnprocessedRequestException.class)\n+                    .hasRootCauseInstanceOf(ConnectException.class);\n+        }\n+    }\n+\n+    @Test\n+    void testHttpProxyUpgradeRequestFailure() throws Exception {\n+        final InetSocketAddress srcAddr = new InetSocketAddress(\"127.0.0.2\", 82);\n+        final InetSocketAddress destAddr = new InetSocketAddress(\"127.0.0.2\", 82);\n+        final Endpoint destEndpoint = Endpoint.of(destAddr.getHostString(), destAddr.getPort());\n+        final Endpoint proxyEndpoint = http1Server.endpoint();\n+        assert proxyEndpoint.ipAddr() != null;\n+        final InetSocketAddress proxyAddr = new InetSocketAddress(proxyEndpoint.ipAddr(), proxyEndpoint.port());\n+\n+        final AtomicReference<HAProxyMessage> msgRef = new AtomicReference<>();\n+        DYNAMIC_HANDLER.setChannelReadCustomizer((ctx, msg) -> {\n+            if (msg instanceof HAProxyMessage) {\n+                msgRef.set((HAProxyMessage) msg);\n+                return;\n+            }\n+            final FullHttpRequest request = (FullHttpRequest) msg;\n+            final DefaultFullHttpResponse response;\n+            if (\"h2c\".equals(request.headers().get(HttpHeaderNames.UPGRADE))) {\n+                // reject http2 upgrade requests\n+                final HttpHeaders headers = new DefaultHttpHeaders().add(HttpHeaderNames.CONNECTION, \"close\");\n+                response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n+                                                       HttpResponseStatus.NOT_IMPLEMENTED,\n+                                                       Unpooled.EMPTY_BUFFER,\n+                                                       headers,\n+                                                       EmptyHttpHeaders.INSTANCE);\n+            } else {\n+                response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n+                                                       HttpResponseStatus.OK,\n+                                                       Unpooled.copiedBuffer(strRepr(msgRef.get()),\n+                                                                             StandardCharsets.US_ASCII));\n+            }\n+\n+            ReferenceCountUtil.release(msg);\n+            ctx.writeAndFlush(response);\n+            ctx.close();\n+        });\n+\n+        try (ClientFactory clientFactory =\n+                     ClientFactory.builder()\n+                                  .proxyConfig(ProxyConfig.haproxy(proxyAddr, srcAddr))\n+                                  .useHttp2Preface(false)\n+                                  .build()) {\n+\n+            final WebClient webClient = WebClient.builder(SessionProtocol.HTTP, destEndpoint)\n+                                                 .factory(clientFactory)\n+                                                 .decorator(LoggingClient.newDecorator())\n+                                                 .build();\n+            final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                    webClient.get(PROXY_PATH).aggregate();\n+            final AggregatedHttpResponse response = responseFuture.get(10, TimeUnit.SECONDS);\n+            assertThat(response.status()).isEqualTo(HttpStatus.OK);\n+            final String expectedResponse = String.format(\"%s-%s\", srcAddr, destAddr);\n+            assertThat(response.contentUtf8()).isEqualTo(expectedResponse);\n+        }\n+    }\n+\n+    @Test\n+    void testHttpProxyPrefaceFailure() throws Exception {\n+        final InetSocketAddress srcAddr = new InetSocketAddress(\"127.0.0.2\", 82);\n+        final InetSocketAddress destAddr = new InetSocketAddress(\"127.0.0.2\", 82);\n+        final Endpoint destEndpoint = Endpoint.of(destAddr.getHostString(), destAddr.getPort());\n+        final Endpoint proxyEndpoint = http1Server.endpoint();\n+        assert proxyEndpoint.ipAddr() != null;\n+        final InetSocketAddress proxyAddr = new InetSocketAddress(proxyEndpoint.ipAddr(), proxyEndpoint.port());\n+\n+        final AtomicReference<HAProxyMessage> msgRef = new AtomicReference<>();\n+        DYNAMIC_HANDLER.setChannelReadCustomizer((ctx, msg) -> {\n+            if (msg instanceof HAProxyMessage) {\n+                msgRef.set((HAProxyMessage) msg);\n+                return;\n+            }\n+            final FullHttpRequest request = (FullHttpRequest) msg;\n+            final DefaultFullHttpResponse response;\n+            if (\"PRI\".equals(request.method().name())) {\n+                // reject http2 preface\n+                final HttpHeaders headers = new DefaultHttpHeaders().add(HttpHeaderNames.CONNECTION, \"close\");\n+                response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n+                                                       HttpResponseStatus.NOT_IMPLEMENTED,\n+                                                       Unpooled.EMPTY_BUFFER,\n+                                                       headers,\n+                                                       EmptyHttpHeaders.INSTANCE);\n+            } else {\n+                response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n+                                                       HttpResponseStatus.OK,\n+                                                       Unpooled.copiedBuffer(strRepr(msgRef.get()),\n+                                                                             StandardCharsets.US_ASCII));\n+            }\n+\n+            ReferenceCountUtil.release(msg);\n+            ctx.writeAndFlush(response);\n+            ctx.close();\n+        });\n+\n+        try (ClientFactory clientFactory =\n+                     ClientFactory.builder()\n+                                  .proxyConfig(ProxyConfig.haproxy(proxyAddr, srcAddr))\n+                                  .useHttp2Preface(true)\n+                                  .build()) {\n+\n+            final WebClient webClient = WebClient.builder(SessionProtocol.HTTP, destEndpoint)\n+                                                 .factory(clientFactory)\n+                                                 .decorator(LoggingClient.newDecorator())\n+                                                 .build();\n+            final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                    webClient.get(PROXY_PATH).aggregate();\n+            final AggregatedHttpResponse response = responseFuture.get(10, TimeUnit.SECONDS);\n+            assertThat(response.status()).isEqualTo(HttpStatus.OK);\n+            final String expectedResponse = String.format(\"%s-%s\", srcAddr, destAddr);\n+            assertThat(response.contentUtf8()).isEqualTo(expectedResponse);\n+        }\n+    }\n+\n+    private static class ProtocolEndpointProvider implements ArgumentsProvider {\n+        @Override\n+        public Stream<? extends Arguments> provideArguments(ExtensionContext context) {\n+            return Stream.concat(\n+                    SessionProtocol.httpValues().stream()\n+                                   .map(p -> arguments(p, backendServer.httpSocketAddress())),\n+                    SessionProtocol.httpsValues().stream()\n+                                   .map(p -> arguments(p, backendServer.httpsSocketAddress()))\n+            );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c199cef542f6cbd2ac4d44e07ac0fc99142beef9"}, "originalPosition": 385}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE5Mjc5Mw==", "bodyText": "Could use ctx.log().whenAvailable(RequestLogProperty.SESSION).thenXXX\nctx.log()\n   .whenAvailable(RequestLogProperty.SESSION)\n   .thenAccept(log ->  srcAddressRef.set(log.context().localAddress()));", "url": "https://github.com/line/armeria/pull/2907#discussion_r464192793", "createdAt": "2020-08-03T04:50:57Z", "author": {"login": "ikhoon"}, "path": "core/src/test/java/com/linecorp/armeria/client/proxy/HAProxyClientIntegrationTest.java", "diffHunk": "@@ -0,0 +1,393 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.proxy;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.awaitility.Awaitility.await;\n+import static org.junit.jupiter.params.provider.Arguments.arguments;\n+\n+import java.net.ConnectException;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.ArgumentsProvider;\n+import org.junit.jupiter.params.provider.ArgumentsSource;\n+\n+import com.linecorp.armeria.client.ClientFactory;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.UnprocessedRequestException;\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.client.logging.LoggingClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.logging.RequestLogProperty;\n+import com.linecorp.armeria.common.util.SafeCloseable;\n+import com.linecorp.armeria.internal.testing.DynamicBehaviorHandler;\n+import com.linecorp.armeria.internal.testing.NettyServerExtension;\n+import com.linecorp.armeria.server.ProxiedAddresses;\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.testing.junit5.server.ServerExtension;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.handler.codec.haproxy.HAProxyMessage;\n+import io.netty.handler.codec.haproxy.HAProxyMessageDecoder;\n+import io.netty.handler.codec.http.DefaultFullHttpResponse;\n+import io.netty.handler.codec.http.DefaultHttpHeaders;\n+import io.netty.handler.codec.http.EmptyHttpHeaders;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaders;\n+import io.netty.handler.codec.http.HttpObjectAggregator;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.logging.LoggingHandler;\n+import io.netty.util.ReferenceCountUtil;\n+\n+class HAProxyClientIntegrationTest {\n+    private static final String PROXY_PATH = \"/proxy\";\n+    private static final DynamicBehaviorHandler DYNAMIC_HANDLER = new DynamicBehaviorHandler();\n+\n+    @RegisterExtension\n+    static ServerExtension backendServer = new ServerExtension() {\n+        @Override\n+        protected void configure(ServerBuilder sb) throws Exception {\n+            sb.port(0, SessionProtocol.HTTP, SessionProtocol.PROXY);\n+            sb.port(0, SessionProtocol.HTTPS, SessionProtocol.PROXY);\n+            sb.tlsSelfSigned();\n+            sb.service(PROXY_PATH, (ctx, req) -> {\n+                assertThat(ctx.proxiedAddresses().destinationAddresses()).hasSize(1);\n+                final String proxyString = String.format(\"%s-%s\", ctx.proxiedAddresses().sourceAddress(),\n+                                                         ctx.proxiedAddresses().destinationAddresses().get(0));\n+                return HttpResponse.of(proxyString);\n+            });\n+        }\n+    };\n+\n+    @RegisterExtension\n+    static NettyServerExtension http1Server = new NettyServerExtension() {\n+        @Override\n+        protected void configure(Channel ch) throws Exception {\n+            ch.pipeline().addLast(new LoggingHandler(getClass()));\n+            ch.pipeline().addLast(new HAProxyMessageDecoder());\n+            ch.pipeline().addLast(new HttpServerCodec());\n+            ch.pipeline().addLast(new HttpObjectAggregator(1024));\n+            ch.pipeline().addLast(DYNAMIC_HANDLER);\n+        }\n+    };\n+\n+    @ParameterizedTest\n+    @ArgumentsSource(ProtocolEndpointProvider.class)\n+    void testExplicitHAProxy(SessionProtocol sessionProtocol, InetSocketAddress proxyAddr) throws Exception {\n+        final InetSocketAddress srcAddr = new InetSocketAddress(\"127.0.0.2\", 82);\n+        final InetSocketAddress destAddr = new InetSocketAddress(\"127.0.0.3\", 83);\n+        final Endpoint destEndpoint = Endpoint.of(destAddr.getHostString(), destAddr.getPort());\n+\n+        try (ClientFactory clientFactory =\n+                     ClientFactory.builder()\n+                                  .proxyConfig(ProxyConfig.haproxy(proxyAddr, srcAddr))\n+                                  .tlsNoVerify()\n+                                  .useHttp2Preface(true)\n+                                  .build()) {\n+\n+            final WebClient webClient = WebClient.builder(sessionProtocol, destEndpoint)\n+                                                 .factory(clientFactory)\n+                                                 .decorator(LoggingClient.newDecorator())\n+                                                 .build();\n+            final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                    webClient.get(PROXY_PATH).aggregate();\n+\n+            final AggregatedHttpResponse response = responseFuture.get(10, TimeUnit.SECONDS);\n+            assertThat(response.status()).isEqualTo(HttpStatus.OK);\n+            final String expectedResponse = String.format(\"%s-%s\", srcAddr,\n+                                                          destAddr);\n+            assertThat(response.contentUtf8()).isEqualTo(expectedResponse);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ArgumentsSource(ProtocolEndpointProvider.class)\n+    void testSourceAddrFromRootContextIfAvailable(\n+            SessionProtocol sessionProtocol, InetSocketAddress proxyAddr) throws Exception {\n+        final InetSocketAddress srcAddr = new InetSocketAddress(\"127.0.0.2\", 82);\n+        final InetSocketAddress destAddr = new InetSocketAddress(\"127.0.0.3\", 83);\n+        final Endpoint destEndpoint = Endpoint.of(destAddr.getHostString(), destAddr.getPort());\n+\n+        final ServiceRequestContext serviceRequestContext =\n+                ServiceRequestContext.builder(\n+                        HttpRequest.of(HttpMethod.GET, \"/\"))\n+                                     .proxiedAddresses(ProxiedAddresses.of(srcAddr)).build();\n+\n+        try (SafeCloseable ignored = serviceRequestContext.push();\n+             ClientFactory clientFactory =\n+                     ClientFactory.builder()\n+                                  .proxyConfig(ProxyConfig.haproxy(proxyAddr))\n+                                  .tlsNoVerify()\n+                                  .useHttp2Preface(true)\n+                                  .build()) {\n+\n+            final WebClient webClient = WebClient.builder(sessionProtocol, destEndpoint)\n+                                                 .factory(clientFactory)\n+                                                 .decorator(LoggingClient.newDecorator())\n+                                                 .build();\n+            final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                    webClient.get(PROXY_PATH).aggregate();\n+\n+            final AggregatedHttpResponse response = responseFuture.get(10, TimeUnit.SECONDS);\n+            assertThat(response.status()).isEqualTo(HttpStatus.OK);\n+            assertThat(destEndpoint.ipAddr()).isNotNull();\n+\n+            final String expectedResponse = String.format(\"%s-%s\", srcAddr, destAddr);\n+            assertThat(response.contentUtf8()).isEqualTo(expectedResponse);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ArgumentsSource(ProtocolEndpointProvider.class)\n+    void testImplicitHAProxyWithoutRootContextUsesDefault(\n+            SessionProtocol sessionProtocol, InetSocketAddress proxyAddr) throws Exception {\n+        final InetSocketAddress destAddr = new InetSocketAddress(\"127.0.0.3\", 83);\n+        final Endpoint destEndpoint = Endpoint.of(destAddr.getHostString(), destAddr.getPort());\n+        try (ClientFactory clientFactory =\n+                     ClientFactory.builder()\n+                                  .proxyConfig(ProxyConfig.haproxy(proxyAddr))\n+                                  .tlsNoVerify()\n+                                  .useHttp2Preface(true)\n+                                  .build()) {\n+\n+            final AtomicReference<InetSocketAddress> srcAddressRef = new AtomicReference<>();\n+            final WebClient webClient =\n+                    WebClient.builder(sessionProtocol, destEndpoint)\n+                             .factory(clientFactory)\n+                             .decorator(LoggingClient.newDecorator())\n+                             .decorator((delegate, ctx, req) -> {\n+                                 final HttpResponse response = delegate.execute(ctx, req);\n+                                 await().atMost(10, TimeUnit.SECONDS).until(\n+                                         () -> ctx.log().isAvailable(RequestLogProperty.SESSION));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c199cef542f6cbd2ac4d44e07ac0fc99142beef9"}, "originalPosition": 197}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE5MzI2NA==", "bodyText": "Ditto", "url": "https://github.com/line/armeria/pull/2907#discussion_r464193264", "createdAt": "2020-08-03T04:53:10Z", "author": {"login": "ikhoon"}, "path": "core/src/test/java/com/linecorp/armeria/client/proxy/HAProxyClientIntegrationTest.java", "diffHunk": "@@ -0,0 +1,393 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.proxy;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.awaitility.Awaitility.await;\n+import static org.junit.jupiter.params.provider.Arguments.arguments;\n+\n+import java.net.ConnectException;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.ArgumentsProvider;\n+import org.junit.jupiter.params.provider.ArgumentsSource;\n+\n+import com.linecorp.armeria.client.ClientFactory;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.UnprocessedRequestException;\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.client.logging.LoggingClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.logging.RequestLogProperty;\n+import com.linecorp.armeria.common.util.SafeCloseable;\n+import com.linecorp.armeria.internal.testing.DynamicBehaviorHandler;\n+import com.linecorp.armeria.internal.testing.NettyServerExtension;\n+import com.linecorp.armeria.server.ProxiedAddresses;\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.testing.junit5.server.ServerExtension;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.handler.codec.haproxy.HAProxyMessage;\n+import io.netty.handler.codec.haproxy.HAProxyMessageDecoder;\n+import io.netty.handler.codec.http.DefaultFullHttpResponse;\n+import io.netty.handler.codec.http.DefaultHttpHeaders;\n+import io.netty.handler.codec.http.EmptyHttpHeaders;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaders;\n+import io.netty.handler.codec.http.HttpObjectAggregator;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.logging.LoggingHandler;\n+import io.netty.util.ReferenceCountUtil;\n+\n+class HAProxyClientIntegrationTest {\n+    private static final String PROXY_PATH = \"/proxy\";\n+    private static final DynamicBehaviorHandler DYNAMIC_HANDLER = new DynamicBehaviorHandler();\n+\n+    @RegisterExtension\n+    static ServerExtension backendServer = new ServerExtension() {\n+        @Override\n+        protected void configure(ServerBuilder sb) throws Exception {\n+            sb.port(0, SessionProtocol.HTTP, SessionProtocol.PROXY);\n+            sb.port(0, SessionProtocol.HTTPS, SessionProtocol.PROXY);\n+            sb.tlsSelfSigned();\n+            sb.service(PROXY_PATH, (ctx, req) -> {\n+                assertThat(ctx.proxiedAddresses().destinationAddresses()).hasSize(1);\n+                final String proxyString = String.format(\"%s-%s\", ctx.proxiedAddresses().sourceAddress(),\n+                                                         ctx.proxiedAddresses().destinationAddresses().get(0));\n+                return HttpResponse.of(proxyString);\n+            });\n+        }\n+    };\n+\n+    @RegisterExtension\n+    static NettyServerExtension http1Server = new NettyServerExtension() {\n+        @Override\n+        protected void configure(Channel ch) throws Exception {\n+            ch.pipeline().addLast(new LoggingHandler(getClass()));\n+            ch.pipeline().addLast(new HAProxyMessageDecoder());\n+            ch.pipeline().addLast(new HttpServerCodec());\n+            ch.pipeline().addLast(new HttpObjectAggregator(1024));\n+            ch.pipeline().addLast(DYNAMIC_HANDLER);\n+        }\n+    };\n+\n+    @ParameterizedTest\n+    @ArgumentsSource(ProtocolEndpointProvider.class)\n+    void testExplicitHAProxy(SessionProtocol sessionProtocol, InetSocketAddress proxyAddr) throws Exception {\n+        final InetSocketAddress srcAddr = new InetSocketAddress(\"127.0.0.2\", 82);\n+        final InetSocketAddress destAddr = new InetSocketAddress(\"127.0.0.3\", 83);\n+        final Endpoint destEndpoint = Endpoint.of(destAddr.getHostString(), destAddr.getPort());\n+\n+        try (ClientFactory clientFactory =\n+                     ClientFactory.builder()\n+                                  .proxyConfig(ProxyConfig.haproxy(proxyAddr, srcAddr))\n+                                  .tlsNoVerify()\n+                                  .useHttp2Preface(true)\n+                                  .build()) {\n+\n+            final WebClient webClient = WebClient.builder(sessionProtocol, destEndpoint)\n+                                                 .factory(clientFactory)\n+                                                 .decorator(LoggingClient.newDecorator())\n+                                                 .build();\n+            final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                    webClient.get(PROXY_PATH).aggregate();\n+\n+            final AggregatedHttpResponse response = responseFuture.get(10, TimeUnit.SECONDS);\n+            assertThat(response.status()).isEqualTo(HttpStatus.OK);\n+            final String expectedResponse = String.format(\"%s-%s\", srcAddr,\n+                                                          destAddr);\n+            assertThat(response.contentUtf8()).isEqualTo(expectedResponse);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ArgumentsSource(ProtocolEndpointProvider.class)\n+    void testSourceAddrFromRootContextIfAvailable(\n+            SessionProtocol sessionProtocol, InetSocketAddress proxyAddr) throws Exception {\n+        final InetSocketAddress srcAddr = new InetSocketAddress(\"127.0.0.2\", 82);\n+        final InetSocketAddress destAddr = new InetSocketAddress(\"127.0.0.3\", 83);\n+        final Endpoint destEndpoint = Endpoint.of(destAddr.getHostString(), destAddr.getPort());\n+\n+        final ServiceRequestContext serviceRequestContext =\n+                ServiceRequestContext.builder(\n+                        HttpRequest.of(HttpMethod.GET, \"/\"))\n+                                     .proxiedAddresses(ProxiedAddresses.of(srcAddr)).build();\n+\n+        try (SafeCloseable ignored = serviceRequestContext.push();\n+             ClientFactory clientFactory =\n+                     ClientFactory.builder()\n+                                  .proxyConfig(ProxyConfig.haproxy(proxyAddr))\n+                                  .tlsNoVerify()\n+                                  .useHttp2Preface(true)\n+                                  .build()) {\n+\n+            final WebClient webClient = WebClient.builder(sessionProtocol, destEndpoint)\n+                                                 .factory(clientFactory)\n+                                                 .decorator(LoggingClient.newDecorator())\n+                                                 .build();\n+            final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                    webClient.get(PROXY_PATH).aggregate();\n+\n+            final AggregatedHttpResponse response = responseFuture.get(10, TimeUnit.SECONDS);\n+            assertThat(response.status()).isEqualTo(HttpStatus.OK);\n+            assertThat(destEndpoint.ipAddr()).isNotNull();\n+\n+            final String expectedResponse = String.format(\"%s-%s\", srcAddr, destAddr);\n+            assertThat(response.contentUtf8()).isEqualTo(expectedResponse);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ArgumentsSource(ProtocolEndpointProvider.class)\n+    void testImplicitHAProxyWithoutRootContextUsesDefault(\n+            SessionProtocol sessionProtocol, InetSocketAddress proxyAddr) throws Exception {\n+        final InetSocketAddress destAddr = new InetSocketAddress(\"127.0.0.3\", 83);\n+        final Endpoint destEndpoint = Endpoint.of(destAddr.getHostString(), destAddr.getPort());\n+        try (ClientFactory clientFactory =\n+                     ClientFactory.builder()\n+                                  .proxyConfig(ProxyConfig.haproxy(proxyAddr))\n+                                  .tlsNoVerify()\n+                                  .useHttp2Preface(true)\n+                                  .build()) {\n+\n+            final AtomicReference<InetSocketAddress> srcAddressRef = new AtomicReference<>();\n+            final WebClient webClient =\n+                    WebClient.builder(sessionProtocol, destEndpoint)\n+                             .factory(clientFactory)\n+                             .decorator(LoggingClient.newDecorator())\n+                             .decorator((delegate, ctx, req) -> {\n+                                 final HttpResponse response = delegate.execute(ctx, req);\n+                                 await().atMost(10, TimeUnit.SECONDS).until(\n+                                         () -> ctx.log().isAvailable(RequestLogProperty.SESSION));\n+                                 srcAddressRef.set(ctx.localAddress());\n+                                 return response;\n+                             })\n+                             .build();\n+            final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                    webClient.get(PROXY_PATH).aggregate();\n+\n+            final AggregatedHttpResponse response = responseFuture.get(10, TimeUnit.SECONDS);\n+            assertThat(response.status()).isEqualTo(HttpStatus.OK);\n+            final String expectedResponse = String.format(\"%s-%s\", srcAddressRef.get(), destAddr);\n+            assertThat(response.contentUtf8()).isEqualTo(expectedResponse);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ArgumentsSource(ProtocolEndpointProvider.class)\n+    void testDifferentIpFamily(SessionProtocol sessionProtocol, InetSocketAddress proxyAddr) throws Exception {\n+        final InetSocketAddress srcAddr = new InetSocketAddress(\"127.0.0.2\", 82);\n+        final InetSocketAddress destAddr = new InetSocketAddress(\"0:0:0:0:0:0:0:1\", 83);\n+        final Endpoint destEndpoint = Endpoint.of(destAddr.getHostString(), destAddr.getPort());\n+        try (ClientFactory clientFactory =\n+                     ClientFactory.builder()\n+                                  .proxyConfig(ProxyConfig.haproxy(proxyAddr, srcAddr))\n+                                  .tlsNoVerify()\n+                                  .useHttp2Preface(true)\n+                                  .build()) {\n+\n+            final WebClient webClient = WebClient.builder(sessionProtocol, destEndpoint)\n+                                                 .factory(clientFactory)\n+                                                 .decorator(LoggingClient.newDecorator())\n+                                                 .build();\n+            final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                    webClient.get(PROXY_PATH).aggregate();\n+\n+            final AggregatedHttpResponse response = responseFuture.get(10, TimeUnit.SECONDS);\n+            assertThat(response.status()).isEqualTo(HttpStatus.OK);\n+            final String expectedResponse = String.format(\"%s-%s\", srcAddr, destAddr);\n+            assertThat(response.contentUtf8()).isEqualTo(expectedResponse);\n+        }\n+    }\n+\n+    @Test\n+    void testConnectionFailure() throws Exception {\n+        final int unusedPort;\n+        try (ServerSocket ss = new ServerSocket(0)) {\n+            unusedPort = ss.getLocalPort();\n+        }\n+        try (ClientFactory clientFactory =\n+                     ClientFactory.builder()\n+                                  .proxyConfig(ProxyConfig.haproxy(new InetSocketAddress(unusedPort)))\n+                                  .useHttp2Preface(true)\n+                                  .build()) {\n+\n+            final WebClient webClient = WebClient.builder(SessionProtocol.H1C, backendServer.httpEndpoint())\n+                                                 .factory(clientFactory)\n+                                                 .decorator(LoggingClient.newDecorator())\n+                                                 .build();\n+            final CompletableFuture<AggregatedHttpResponse> responseFuture =\n+                    webClient.get(PROXY_PATH).aggregate();\n+\n+            assertThatThrownBy(() -> responseFuture.get(10, TimeUnit.SECONDS))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c199cef542f6cbd2ac4d44e07ac0fc99142beef9"}, "originalPosition": 258}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dcc487f08af4fcb8c3c20a2a60f4a848acf9b58a", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/dcc487f08af4fcb8c3c20a2a60f4a848acf9b58a", "committedDate": "2020-08-03T05:51:39Z", "message": "prefer join, omitNullValues first"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bb4d896c8e1f53769c1369763fc7401574a92a51", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/bb4d896c8e1f53769c1369763fc7401574a92a51", "committedDate": "2020-08-03T05:38:59Z", "message": "prefer join, omitNullValues first"}, "afterCommit": {"oid": "dcc487f08af4fcb8c3c20a2a60f4a848acf9b58a", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/dcc487f08af4fcb8c3c20a2a60f4a848acf9b58a", "committedDate": "2020-08-03T05:51:39Z", "message": "prefer join, omitNullValues first"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "52ed8e671f56642ad10ccd707361190ae6580979", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/52ed8e671f56642ad10ccd707361190ae6580979", "committedDate": "2020-08-03T07:00:10Z", "message": "Merge branch 'master' of https://github.com/line/armeria into feature/haproxy-client"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "832ea638e0dcfafa3c8165d186bb2bcb26dd6506", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/832ea638e0dcfafa3c8165d186bb2bcb26dd6506", "committedDate": "2020-08-03T07:01:26Z", "message": "directly use serviceReqCtx"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9422e33a330aa6384e5b8351e46555f5cff58b86", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/line/armeria/commit/9422e33a330aa6384e5b8351e46555f5cff58b86", "committedDate": "2020-08-03T08:22:01Z", "message": "avoid an extra instantiation if serviceCtx doesn't exist"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5ODQwNjk3", "url": "https://github.com/line/armeria/pull/2907#pullrequestreview-459840697", "createdAt": "2020-08-03T08:28:58Z", "commit": {"oid": "9422e33a330aa6384e5b8351e46555f5cff58b86"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4913, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}