{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkxMDQ3MTMy", "number": 2612, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNTo0MDoxNVrODpkE-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMzo0Mzo1M1rODp33bQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0OTA5MzA3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/common/metric/ExecutorServiceMetrics.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNTo0MDoxNVrOF40Xwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwMjoxMTozNVrOF5F_ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTEyMjYyNg==", "bodyText": "If we are putting this class to common, it has to be generic, i.e. The caller should be able to specify the prefix, rather than hard-coded with armeria.executor.", "url": "https://github.com/line/armeria/pull/2612#discussion_r395122626", "createdAt": "2020-03-19T15:40:15Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/common/metric/ExecutorServiceMetrics.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+/*\n+ * Copyright 2017 Pivotal Software, Inc.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linecorp.armeria.common.metric;\n+\n+import static java.util.Arrays.asList;\n+\n+import java.lang.reflect.Field;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ThreadPoolExecutor;\n+\n+import com.linecorp.armeria.common.util.UnstableApi;\n+\n+import io.micrometer.core.instrument.FunctionCounter;\n+import io.micrometer.core.instrument.Gauge;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.micrometer.core.instrument.binder.BaseUnits;\n+import io.micrometer.core.instrument.binder.MeterBinder;\n+import io.micrometer.core.lang.NonNullApi;\n+import io.micrometer.core.lang.NonNullFields;\n+import io.micrometer.core.lang.Nullable;\n+\n+/**\n+ * Monitors the status of executor service pools. Does not record timings on operations executed in the\n+ * {@link ExecutorService}, as this requires the instance to be wrapped.\n+ * Timings are provided separately by wrapping the executor service with {@link TimedExecutorService}.\n+ *\n+ * @author Jon Schneider\n+ * @author Clint Checketts\n+ * @author Johnny Lim\n+ */\n+@NonNullApi\n+@NonNullFields\n+@UnstableApi\n+public class ExecutorServiceMetrics implements MeterBinder {\n+\n+    // Forked from Micrometer 1.3.6\n+    // https://github.com/micrometer-metrics/micrometer/blob/e6ff3c2fe9542608a33a62b10fdf1222cd60feae/micrometer-core/src/main/java/io/micrometer/core/instrument/binder/jvm/ExecutorServiceMetrics.java\n+\n+    @Nullable\n+    private final ExecutorService executorService;\n+\n+    private final Iterable<Tag> tags;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ExecutorServiceMetrics(@Nullable ExecutorService executorService, String executorServiceName,\n+                                  Iterable<Tag> tags) {\n+        this.executorService = executorService;\n+        this.tags = Tags.concat(tags, \"name\", executorServiceName);\n+    }\n+\n+    /**\n+     * Record metrics on the use of an {@link Executor}.\n+     *\n+     * @param registry     The registry to bind metrics to.\n+     * @param executor     The executor to instrument.\n+     * @param executorName Will be used to tag metrics with \"name\".\n+     * @param tags         Tags to apply to all recorded metrics.\n+     * @return The instrumented executor, proxied.\n+     */\n+    public static Executor monitor(MeterRegistry registry, Executor executor, String executorName,\n+                                   Iterable<Tag> tags) {\n+        if (executor instanceof ExecutorService) {\n+            return monitor(registry, (ExecutorService) executor, executorName, tags);\n+        }\n+        return new TimedExecutor(registry, executor, executorName, tags);\n+    }\n+\n+    /**\n+     * Record metrics on the use of an {@link Executor}.\n+     *\n+     * @param registry     The registry to bind metrics to.\n+     * @param executor     The executor to instrument.\n+     * @param executorName Will be used to tag metrics with \"name\".\n+     * @param tags         Tags to apply to all recorded metrics.\n+     * @return The instrumented executor, proxied.\n+     */\n+    public static Executor monitor(MeterRegistry registry, Executor executor, String executorName,\n+                                   Tag... tags) {\n+        return monitor(registry, executor, executorName, asList(tags));\n+    }\n+\n+    /**\n+     * Record metrics on the use of an {@link ExecutorService}.\n+     *\n+     * @param registry            The registry to bind metrics to.\n+     * @param executor            The executor to instrument.\n+     * @param executorServiceName Will be used to tag metrics with \"name\".\n+     * @param tags                Tags to apply to all recorded metrics.\n+     * @return The instrumented executor, proxied.\n+     */\n+    public static ExecutorService monitor(MeterRegistry registry, ExecutorService executor,\n+                                          String executorServiceName, Iterable<Tag> tags) {\n+        if (executor instanceof ScheduledExecutorService) {\n+            return monitor(registry, (ScheduledExecutorService) executor, executorServiceName, tags);\n+        }\n+        new ExecutorServiceMetrics(executor, executorServiceName, tags).bindTo(registry);\n+        return new TimedExecutorService(registry, executor, executorServiceName, tags);\n+    }\n+\n+    /**\n+     * Record metrics on the use of an {@link ExecutorService}.\n+     *\n+     * @param registry            The registry to bind metrics to.\n+     * @param executor            The executor to instrument.\n+     * @param executorServiceName Will be used to tag metrics with \"name\".\n+     * @param tags                Tags to apply to all recorded metrics.\n+     * @return The instrumented executor, proxied.\n+     */\n+    public static ExecutorService monitor(MeterRegistry registry, ExecutorService executor,\n+                                          String executorServiceName, Tag... tags) {\n+        return monitor(registry, executor, executorServiceName, asList(tags));\n+    }\n+\n+    /**\n+     * Record metrics on the use of a {@link ScheduledExecutorService}.\n+     *\n+     * @param registry            The registry to bind metrics to.\n+     * @param executor            The scheduled executor to instrument.\n+     * @param executorServiceName Will be used to tag metrics with \"name\".\n+     * @param tags                Tags to apply to all recorded metrics.\n+     * @return The instrumented scheduled executor, proxied.\n+     * @since 1.3.0\n+     */\n+    public static ScheduledExecutorService monitor(MeterRegistry registry, ScheduledExecutorService executor,\n+                                                   String executorServiceName, Iterable<Tag> tags) {\n+        new ExecutorServiceMetrics(executor, executorServiceName, tags).bindTo(registry);\n+        return new TimedScheduledExecutorService(registry, executor, executorServiceName, tags);\n+    }\n+\n+    /**\n+     * Record metrics on the use of a {@link ScheduledExecutorService}.\n+     *\n+     * @param registry            The registry to bind metrics to.\n+     * @param executor            The scheduled executor to instrument.\n+     * @param executorServiceName Will be used to tag metrics with \"name\".\n+     * @param tags                Tags to apply to all recorded metrics.\n+     * @return The instrumented scheduled executor, proxied.\n+     * @since 1.3.0\n+     */\n+    public static ScheduledExecutorService monitor(MeterRegistry registry, ScheduledExecutorService executor,\n+                                                   String executorServiceName, Tag... tags) {\n+        return monitor(registry, executor, executorServiceName, asList(tags));\n+    }\n+\n+    private void monitor(MeterRegistry registry, @Nullable ThreadPoolExecutor tp) {\n+        if (tp == null) {\n+            return;\n+        }\n+\n+        FunctionCounter.builder(\"armeria.executor.completed\", tp, ThreadPoolExecutor::getCompletedTaskCount)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "153df04a7d01d5d5bc66276d9ca07a088e8aff91"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQxMTM1OA==", "bodyText": "I thought we temporarily use it. But specifying the prefix sounds good. \ud83d\udc4d", "url": "https://github.com/line/armeria/pull/2612#discussion_r395411358", "createdAt": "2020-03-20T02:11:35Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/common/metric/ExecutorServiceMetrics.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+/*\n+ * Copyright 2017 Pivotal Software, Inc.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linecorp.armeria.common.metric;\n+\n+import static java.util.Arrays.asList;\n+\n+import java.lang.reflect.Field;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ThreadPoolExecutor;\n+\n+import com.linecorp.armeria.common.util.UnstableApi;\n+\n+import io.micrometer.core.instrument.FunctionCounter;\n+import io.micrometer.core.instrument.Gauge;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.micrometer.core.instrument.binder.BaseUnits;\n+import io.micrometer.core.instrument.binder.MeterBinder;\n+import io.micrometer.core.lang.NonNullApi;\n+import io.micrometer.core.lang.NonNullFields;\n+import io.micrometer.core.lang.Nullable;\n+\n+/**\n+ * Monitors the status of executor service pools. Does not record timings on operations executed in the\n+ * {@link ExecutorService}, as this requires the instance to be wrapped.\n+ * Timings are provided separately by wrapping the executor service with {@link TimedExecutorService}.\n+ *\n+ * @author Jon Schneider\n+ * @author Clint Checketts\n+ * @author Johnny Lim\n+ */\n+@NonNullApi\n+@NonNullFields\n+@UnstableApi\n+public class ExecutorServiceMetrics implements MeterBinder {\n+\n+    // Forked from Micrometer 1.3.6\n+    // https://github.com/micrometer-metrics/micrometer/blob/e6ff3c2fe9542608a33a62b10fdf1222cd60feae/micrometer-core/src/main/java/io/micrometer/core/instrument/binder/jvm/ExecutorServiceMetrics.java\n+\n+    @Nullable\n+    private final ExecutorService executorService;\n+\n+    private final Iterable<Tag> tags;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ExecutorServiceMetrics(@Nullable ExecutorService executorService, String executorServiceName,\n+                                  Iterable<Tag> tags) {\n+        this.executorService = executorService;\n+        this.tags = Tags.concat(tags, \"name\", executorServiceName);\n+    }\n+\n+    /**\n+     * Record metrics on the use of an {@link Executor}.\n+     *\n+     * @param registry     The registry to bind metrics to.\n+     * @param executor     The executor to instrument.\n+     * @param executorName Will be used to tag metrics with \"name\".\n+     * @param tags         Tags to apply to all recorded metrics.\n+     * @return The instrumented executor, proxied.\n+     */\n+    public static Executor monitor(MeterRegistry registry, Executor executor, String executorName,\n+                                   Iterable<Tag> tags) {\n+        if (executor instanceof ExecutorService) {\n+            return monitor(registry, (ExecutorService) executor, executorName, tags);\n+        }\n+        return new TimedExecutor(registry, executor, executorName, tags);\n+    }\n+\n+    /**\n+     * Record metrics on the use of an {@link Executor}.\n+     *\n+     * @param registry     The registry to bind metrics to.\n+     * @param executor     The executor to instrument.\n+     * @param executorName Will be used to tag metrics with \"name\".\n+     * @param tags         Tags to apply to all recorded metrics.\n+     * @return The instrumented executor, proxied.\n+     */\n+    public static Executor monitor(MeterRegistry registry, Executor executor, String executorName,\n+                                   Tag... tags) {\n+        return monitor(registry, executor, executorName, asList(tags));\n+    }\n+\n+    /**\n+     * Record metrics on the use of an {@link ExecutorService}.\n+     *\n+     * @param registry            The registry to bind metrics to.\n+     * @param executor            The executor to instrument.\n+     * @param executorServiceName Will be used to tag metrics with \"name\".\n+     * @param tags                Tags to apply to all recorded metrics.\n+     * @return The instrumented executor, proxied.\n+     */\n+    public static ExecutorService monitor(MeterRegistry registry, ExecutorService executor,\n+                                          String executorServiceName, Iterable<Tag> tags) {\n+        if (executor instanceof ScheduledExecutorService) {\n+            return monitor(registry, (ScheduledExecutorService) executor, executorServiceName, tags);\n+        }\n+        new ExecutorServiceMetrics(executor, executorServiceName, tags).bindTo(registry);\n+        return new TimedExecutorService(registry, executor, executorServiceName, tags);\n+    }\n+\n+    /**\n+     * Record metrics on the use of an {@link ExecutorService}.\n+     *\n+     * @param registry            The registry to bind metrics to.\n+     * @param executor            The executor to instrument.\n+     * @param executorServiceName Will be used to tag metrics with \"name\".\n+     * @param tags                Tags to apply to all recorded metrics.\n+     * @return The instrumented executor, proxied.\n+     */\n+    public static ExecutorService monitor(MeterRegistry registry, ExecutorService executor,\n+                                          String executorServiceName, Tag... tags) {\n+        return monitor(registry, executor, executorServiceName, asList(tags));\n+    }\n+\n+    /**\n+     * Record metrics on the use of a {@link ScheduledExecutorService}.\n+     *\n+     * @param registry            The registry to bind metrics to.\n+     * @param executor            The scheduled executor to instrument.\n+     * @param executorServiceName Will be used to tag metrics with \"name\".\n+     * @param tags                Tags to apply to all recorded metrics.\n+     * @return The instrumented scheduled executor, proxied.\n+     * @since 1.3.0\n+     */\n+    public static ScheduledExecutorService monitor(MeterRegistry registry, ScheduledExecutorService executor,\n+                                                   String executorServiceName, Iterable<Tag> tags) {\n+        new ExecutorServiceMetrics(executor, executorServiceName, tags).bindTo(registry);\n+        return new TimedScheduledExecutorService(registry, executor, executorServiceName, tags);\n+    }\n+\n+    /**\n+     * Record metrics on the use of a {@link ScheduledExecutorService}.\n+     *\n+     * @param registry            The registry to bind metrics to.\n+     * @param executor            The scheduled executor to instrument.\n+     * @param executorServiceName Will be used to tag metrics with \"name\".\n+     * @param tags                Tags to apply to all recorded metrics.\n+     * @return The instrumented scheduled executor, proxied.\n+     * @since 1.3.0\n+     */\n+    public static ScheduledExecutorService monitor(MeterRegistry registry, ScheduledExecutorService executor,\n+                                                   String executorServiceName, Tag... tags) {\n+        return monitor(registry, executor, executorServiceName, asList(tags));\n+    }\n+\n+    private void monitor(MeterRegistry registry, @Nullable ThreadPoolExecutor tp) {\n+        if (tp == null) {\n+            return;\n+        }\n+\n+        FunctionCounter.builder(\"armeria.executor.completed\", tp, ThreadPoolExecutor::getCompletedTaskCount)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTEyMjYyNg=="}, "originalCommit": {"oid": "153df04a7d01d5d5bc66276d9ca07a088e8aff91"}, "originalPosition": 186}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0OTA5OTkyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/common/metric/ExecutorServiceMetrics.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNTo0MTo0NlrOF40cKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwMzozNjo1MVrOF5G56w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTEyMzc1NA==", "bodyText": "Please use our annotation", "url": "https://github.com/line/armeria/pull/2612#discussion_r395123754", "createdAt": "2020-03-19T15:41:46Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/common/metric/ExecutorServiceMetrics.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+/*\n+ * Copyright 2017 Pivotal Software, Inc.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linecorp.armeria.common.metric;\n+\n+import static java.util.Arrays.asList;\n+\n+import java.lang.reflect.Field;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ThreadPoolExecutor;\n+\n+import com.linecorp.armeria.common.util.UnstableApi;\n+\n+import io.micrometer.core.instrument.FunctionCounter;\n+import io.micrometer.core.instrument.Gauge;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.micrometer.core.instrument.binder.BaseUnits;\n+import io.micrometer.core.instrument.binder.MeterBinder;\n+import io.micrometer.core.lang.NonNullApi;\n+import io.micrometer.core.lang.NonNullFields;\n+import io.micrometer.core.lang.Nullable;\n+\n+/**\n+ * Monitors the status of executor service pools. Does not record timings on operations executed in the\n+ * {@link ExecutorService}, as this requires the instance to be wrapped.\n+ * Timings are provided separately by wrapping the executor service with {@link TimedExecutorService}.\n+ *\n+ * @author Jon Schneider\n+ * @author Clint Checketts\n+ * @author Johnny Lim\n+ */\n+@NonNullApi\n+@NonNullFields", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "153df04a7d01d5d5bc66276d9ca07a088e8aff91"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQyNjI4Mw==", "bodyText": "Removed.", "url": "https://github.com/line/armeria/pull/2612#discussion_r395426283", "createdAt": "2020-03-20T03:36:51Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/common/metric/ExecutorServiceMetrics.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+/*\n+ * Copyright 2017 Pivotal Software, Inc.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linecorp.armeria.common.metric;\n+\n+import static java.util.Arrays.asList;\n+\n+import java.lang.reflect.Field;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ThreadPoolExecutor;\n+\n+import com.linecorp.armeria.common.util.UnstableApi;\n+\n+import io.micrometer.core.instrument.FunctionCounter;\n+import io.micrometer.core.instrument.Gauge;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.micrometer.core.instrument.binder.BaseUnits;\n+import io.micrometer.core.instrument.binder.MeterBinder;\n+import io.micrometer.core.lang.NonNullApi;\n+import io.micrometer.core.lang.NonNullFields;\n+import io.micrometer.core.lang.Nullable;\n+\n+/**\n+ * Monitors the status of executor service pools. Does not record timings on operations executed in the\n+ * {@link ExecutorService}, as this requires the instance to be wrapped.\n+ * Timings are provided separately by wrapping the executor service with {@link TimedExecutorService}.\n+ *\n+ * @author Jon Schneider\n+ * @author Clint Checketts\n+ * @author Johnny Lim\n+ */\n+@NonNullApi\n+@NonNullFields", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTEyMzc1NA=="}, "originalCommit": {"oid": "153df04a7d01d5d5bc66276d9ca07a088e8aff91"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0OTEwNjkzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/common/metric/TimedExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNTo0MzoxOFrOF40gpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNjoxOTowMlrOF42Fxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTEyNDkwMw==", "bodyText": "How about hiding everything but ExecutorServiceMetrics to minimize the amount of forked public API?", "url": "https://github.com/line/armeria/pull/2612#discussion_r395124903", "createdAt": "2020-03-19T15:43:18Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/common/metric/TimedExecutor.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+/*\n+ * Copyright 2017 Pivotal Software, Inc.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linecorp.armeria.common.metric;\n+\n+import java.util.concurrent.Executor;\n+\n+import com.linecorp.armeria.common.util.UnstableApi;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.micrometer.core.instrument.Timer;\n+\n+/**\n+ * An {@link Executor} that is timed.\n+ */\n+@UnstableApi\n+public class TimedExecutor implements Executor {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "153df04a7d01d5d5bc66276d9ca07a088e8aff91"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE1MDc5MA==", "bodyText": "As you mentioned #2612 (comment), if ExecutorServiceMetrics is moved to common, we need to move to TimedExecutor to common to remove public modifier.\nIf it's fine, I can make it package private. \ud83d\ude00\nOops, I misunderstood your review. Don't care about this comment.", "url": "https://github.com/line/armeria/pull/2612#discussion_r395150790", "createdAt": "2020-03-19T16:19:02Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/common/metric/TimedExecutor.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+/*\n+ * Copyright 2017 Pivotal Software, Inc.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linecorp.armeria.common.metric;\n+\n+import java.util.concurrent.Executor;\n+\n+import com.linecorp.armeria.common.util.UnstableApi;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.micrometer.core.instrument.Timer;\n+\n+/**\n+ * An {@link Executor} that is timed.\n+ */\n+@UnstableApi\n+public class TimedExecutor implements Executor {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTEyNDkwMw=="}, "originalCommit": {"oid": "153df04a7d01d5d5bc66276d9ca07a088e8aff91"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0OTExNDc1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/server/ServerConfig.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNTo0NTowN1rOF40l9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNzoyOTowNFrOF45Bpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTEyNjI2MQ==", "bodyText": "Could you explain why we are not using TimedExecutorService here?", "url": "https://github.com/line/armeria/pull/2612#discussion_r395126261", "createdAt": "2020-03-19T15:45:07Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/server/ServerConfig.java", "diffHunk": "@@ -158,7 +158,9 @@\n                                    gracefulShutdownQuietPeriod, \"gracefulShutdownQuietPeriod\");\n \n         requireNonNull(blockingTaskExecutor, \"blockingTaskExecutor\");\n-        if (!(blockingTaskExecutor instanceof TimedExecutorService)) {\n+        if (!(blockingTaskExecutor instanceof TimedScheduledExecutorService ||\n+              blockingTaskExecutor instanceof\n+                      io.micrometer.core.instrument.internal.TimedScheduledExecutorService)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "153df04a7d01d5d5bc66276d9ca07a088e8aff91"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE0NDQ4OA==", "bodyText": "After rethinking, it was my mistake.\nI think The blockingTaskExecutor instance should be checked by all of TimedScheduledExecutorService, TimedExecutorService and TimedExecutor.\nBecause there is no inheritance between Timed*Executor*s.\nPlease let me know if I missed something. \ud83d\ude00", "url": "https://github.com/line/armeria/pull/2612#discussion_r395144488", "createdAt": "2020-03-19T16:10:10Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/server/ServerConfig.java", "diffHunk": "@@ -158,7 +158,9 @@\n                                    gracefulShutdownQuietPeriod, \"gracefulShutdownQuietPeriod\");\n \n         requireNonNull(blockingTaskExecutor, \"blockingTaskExecutor\");\n-        if (!(blockingTaskExecutor instanceof TimedExecutorService)) {\n+        if (!(blockingTaskExecutor instanceof TimedScheduledExecutorService ||\n+              blockingTaskExecutor instanceof\n+                      io.micrometer.core.instrument.internal.TimedScheduledExecutorService)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTEyNjI2MQ=="}, "originalCommit": {"oid": "153df04a7d01d5d5bc66276d9ca07a088e8aff91"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE5ODg4Nw==", "bodyText": "SGTM", "url": "https://github.com/line/armeria/pull/2612#discussion_r395198887", "createdAt": "2020-03-19T17:29:04Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/server/ServerConfig.java", "diffHunk": "@@ -158,7 +158,9 @@\n                                    gracefulShutdownQuietPeriod, \"gracefulShutdownQuietPeriod\");\n \n         requireNonNull(blockingTaskExecutor, \"blockingTaskExecutor\");\n-        if (!(blockingTaskExecutor instanceof TimedExecutorService)) {\n+        if (!(blockingTaskExecutor instanceof TimedScheduledExecutorService ||\n+              blockingTaskExecutor instanceof\n+                      io.micrometer.core.instrument.internal.TimedScheduledExecutorService)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTEyNjI2MQ=="}, "originalCommit": {"oid": "153df04a7d01d5d5bc66276d9ca07a088e8aff91"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MTQyNTczOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/internal/common/metric/ExecutorServiceMetrics.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwODozNjozNFrOF5LJvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwOTo1MTozNVrOF5NTvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ5NTg3MA==", "bodyText": "Just wondering if we could check this is an empty string or not, so metric doesn't look .completed", "url": "https://github.com/line/armeria/pull/2612#discussion_r395495870", "createdAt": "2020-03-20T08:36:34Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/internal/common/metric/ExecutorServiceMetrics.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+/*\n+ * Copyright 2017 Pivotal Software, Inc.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linecorp.armeria.internal.common.metric;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.lang.reflect.Field;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ThreadPoolExecutor;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.util.UnstableApi;\n+\n+import io.micrometer.core.instrument.FunctionCounter;\n+import io.micrometer.core.instrument.Gauge;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.micrometer.core.instrument.binder.BaseUnits;\n+import io.micrometer.core.instrument.binder.MeterBinder;\n+\n+/**\n+ * Monitors the status of executor service pools. Does not record timings on operations executed in the\n+ * {@link ExecutorService}, as this requires the instance to be wrapped.\n+ * Timings are provided separately by wrapping the executor service with {@link TimedExecutorService}.\n+ *\n+ * @author Jon Schneider\n+ * @author Clint Checketts\n+ * @author Johnny Lim\n+ */\n+@UnstableApi\n+public final class ExecutorServiceMetrics implements MeterBinder {\n+\n+    // TODO(ikhoon) Remove this class once upstream ExecutorServiceMetrics allows customizing a metric name.\n+\n+    // Forked from Micrometer 1.3.6\n+    // https://github.com/micrometer-metrics/micrometer/blob/e6ff3c2fe9542608a33a62b10fdf1222cd60feae/micrometer-core/src/main/java/io/micrometer/core/instrument/binder/jvm/ExecutorServiceMetrics.java\n+\n+    /**\n+     * Record metrics on the use of an {@link Executor}.\n+     *\n+     * @param registry the registry to bind metrics to.\n+     * @param executor the executor to instrument.\n+     * @param executorName will be used to tag metrics with \"name\".\n+     * @param metricPrefix the metricPrefix of the metric name.\n+     * @param tags tags to apply to all recorded metrics.\n+     * @return the instrumented executor, proxied.\n+     */\n+    public static Executor monitor(MeterRegistry registry, Executor executor, String executorName,\n+                                   String metricPrefix, Iterable<Tag> tags) {\n+        if (executor instanceof ExecutorService) {\n+            return monitor(registry, (ExecutorService) executor, executorName, metricPrefix, tags);\n+        }\n+\n+        requireNonNull(registry, \"registry\");\n+        requireNonNull(executor, \"executor\");\n+        requireNonNull(executorName, \"executorName\");\n+        requireNonNull(metricPrefix, \"metricPrefix\");\n+        requireNonNull(tags, \"tags\");\n+        return new TimedExecutor(registry, executor, executorName, metricPrefix, tags);\n+    }\n+\n+    /**\n+     * Record metrics on the use of an {@link Executor}.\n+     *\n+     * @param registry the registry to bind metrics to.\n+     * @param executor the executor to instrument.\n+     * @param executorName will be used to tag metrics with \"name\".\n+     * @param metricPrefix the prefix of the metric name.\n+     * @param tags tags to apply to all recorded metrics.\n+     * @return the instrumented executor, proxied.\n+     */\n+    public static Executor monitor(MeterRegistry registry, Executor executor, String executorName,\n+                                   String metricPrefix, Tag... tags) {\n+        requireNonNull(tags, \"tags\");\n+        return monitor(registry, executor, executorName, metricPrefix, asList(tags));\n+    }\n+\n+    /**\n+     * Record metrics on the use of an {@link ExecutorService}.\n+     *\n+     * @param registry the registry to bind metrics to.\n+     * @param executor the executor to instrument.\n+     * @param executorServiceName Will be used to tag metrics with \"name\".\n+     * @param metricPrefix the prefix of the metric name.\n+     * @param tags tags to apply to all recorded metrics.\n+     * @return the instrumented executor, proxied.\n+     */\n+    public static ExecutorService monitor(MeterRegistry registry, ExecutorService executor,\n+                                          String executorServiceName, String metricPrefix, Iterable<Tag> tags) {\n+        if (executor instanceof ScheduledExecutorService) {\n+            return monitor(registry, (ScheduledExecutorService) executor,\n+                           executorServiceName, metricPrefix, tags);\n+        }\n+\n+        requireNonNull(registry, \"registry\");\n+        requireNonNull(executor, \"executor\");\n+        requireNonNull(executorServiceName, \"executorServiceName\");\n+        requireNonNull(metricPrefix, \"metricPrefix\");\n+        requireNonNull(tags, \"tags\");\n+\n+        new ExecutorServiceMetrics(executor, executorServiceName, metricPrefix, tags).bindTo(registry);\n+        return new TimedExecutorService(registry, executor, executorServiceName, metricPrefix, tags);\n+    }\n+\n+    /**\n+     * Record metrics on the use of an {@link ExecutorService}.\n+     *\n+     * @param registry the registry to bind metrics to.\n+     * @param executor the executor to instrument.\n+     * @param executorServiceName will be used to tag metrics with \"name\".\n+     * @param metricPrefix the prefix of the metric name.\n+     * @param tags tags to apply to all recorded metrics.\n+     * @return the instrumented executor, proxied.\n+     */\n+    public static ExecutorService monitor(MeterRegistry registry, ExecutorService executor,\n+                                          String executorServiceName, String metricPrefix, Tag... tags) {\n+        requireNonNull(tags, \"tags\");\n+        return monitor(registry, executor, executorServiceName, metricPrefix, asList(tags));\n+    }\n+\n+    /**\n+     * Record metrics on the use of a {@link ScheduledExecutorService}.\n+     *\n+     * @param registry the registry to bind metrics to.\n+     * @param executor the scheduled executor to instrument.\n+     * @param executorServiceName Will be used to tag metrics with \"name\".\n+     * @param metricPrefix the prefix of the metric name.\n+     * @param tags tags to apply to all recorded metrics.\n+     * @return the instrumented scheduled executor, proxied.\n+     * @since 1.3.0\n+     */\n+    public static ScheduledExecutorService monitor(MeterRegistry registry, ScheduledExecutorService executor,\n+                                                   String executorServiceName, String metricPrefix,\n+                                                   Iterable<Tag> tags) {\n+        requireNonNull(registry, \"registry\");\n+        requireNonNull(executor, \"executor\");\n+        requireNonNull(executorServiceName, \"executorServiceName\");\n+        requireNonNull(metricPrefix, \"metricPrefix\");\n+        requireNonNull(tags, \"tags\");\n+\n+        new ExecutorServiceMetrics(executor, executorServiceName, metricPrefix, tags).bindTo(registry);\n+        return new TimedScheduledExecutorService(registry, executor, executorServiceName, metricPrefix, tags);\n+    }\n+\n+    /**\n+     * Record metrics on the use of a {@link ScheduledExecutorService}.\n+     *\n+     * @param registry the registry to bind metrics to.\n+     * @param executor the scheduled executor to instrument.\n+     * @param executorServiceName will be used to tag metrics with \"name\".\n+     * @param metricPrefix the prefix of the metric name.\n+     * @param tags tags to apply to all recorded metrics.\n+     * @return the instrumented scheduled executor, proxied.\n+     * @since 1.3.0\n+     */\n+    public static ScheduledExecutorService monitor(MeterRegistry registry, ScheduledExecutorService executor,\n+                                                   String executorServiceName, String metricPrefix,\n+                                                   Tag... tags) {\n+        requireNonNull(tags, \"tags\");\n+        return monitor(registry, executor, executorServiceName, metricPrefix, asList(tags));\n+    }\n+\n+    /**\n+     * Returns whether the specified {@link Executor} is monitored by {@link MeterRegistry}.\n+     */\n+    public static boolean isMonitoredExecutor(Executor executor) {\n+        return executor instanceof TimedScheduledExecutorService ||\n+               executor instanceof TimedExecutorService ||\n+               executor instanceof TimedExecutor ||\n+               executor instanceof io.micrometer.core.instrument.internal.TimedScheduledExecutorService ||\n+               executor instanceof io.micrometer.core.instrument.internal.TimedExecutorService ||\n+               executor instanceof io.micrometer.core.instrument.internal.TimedExecutor;\n+    }\n+\n+    /**\n+     * Every ScheduledThreadPoolExecutor created by {@link Executors} is wrapped. Also,\n+     * {@link Executors#newSingleThreadExecutor()} wrap a regular {@link ThreadPoolExecutor}.\n+     */\n+    @Nullable\n+    private static ThreadPoolExecutor unwrapThreadPoolExecutor(ExecutorService executor, Class<?> wrapper) {\n+        try {\n+            final Field e = wrapper.getDeclaredField(\"e\");\n+            e.setAccessible(true);\n+            return (ThreadPoolExecutor) e.get(executor);\n+        } catch (NoSuchFieldException | IllegalAccessException e) {\n+            // Do nothing. We simply can't get to the underlying ThreadPoolExecutor.\n+        }\n+        return null;\n+    }\n+\n+    @Nullable\n+    private final ExecutorService executorService;\n+    private final String metricPrefix;\n+    private final Iterable<Tag> tags;\n+\n+    private ExecutorServiceMetrics(@Nullable ExecutorService executorService, String executorServiceName,\n+                                   String metricPrefix, Iterable<Tag> tags) {\n+        this.executorService = executorService;\n+        this.metricPrefix = metricPrefix;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7eafe3700e6717314706c0bf0a6b7713e3ccfcd1"}, "originalPosition": 234}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTUyODkyOA==", "bodyText": "That sounds good. \ud83d\udc4d", "url": "https://github.com/line/armeria/pull/2612#discussion_r395528928", "createdAt": "2020-03-20T09:46:55Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/internal/common/metric/ExecutorServiceMetrics.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+/*\n+ * Copyright 2017 Pivotal Software, Inc.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linecorp.armeria.internal.common.metric;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.lang.reflect.Field;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ThreadPoolExecutor;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.util.UnstableApi;\n+\n+import io.micrometer.core.instrument.FunctionCounter;\n+import io.micrometer.core.instrument.Gauge;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.micrometer.core.instrument.binder.BaseUnits;\n+import io.micrometer.core.instrument.binder.MeterBinder;\n+\n+/**\n+ * Monitors the status of executor service pools. Does not record timings on operations executed in the\n+ * {@link ExecutorService}, as this requires the instance to be wrapped.\n+ * Timings are provided separately by wrapping the executor service with {@link TimedExecutorService}.\n+ *\n+ * @author Jon Schneider\n+ * @author Clint Checketts\n+ * @author Johnny Lim\n+ */\n+@UnstableApi\n+public final class ExecutorServiceMetrics implements MeterBinder {\n+\n+    // TODO(ikhoon) Remove this class once upstream ExecutorServiceMetrics allows customizing a metric name.\n+\n+    // Forked from Micrometer 1.3.6\n+    // https://github.com/micrometer-metrics/micrometer/blob/e6ff3c2fe9542608a33a62b10fdf1222cd60feae/micrometer-core/src/main/java/io/micrometer/core/instrument/binder/jvm/ExecutorServiceMetrics.java\n+\n+    /**\n+     * Record metrics on the use of an {@link Executor}.\n+     *\n+     * @param registry the registry to bind metrics to.\n+     * @param executor the executor to instrument.\n+     * @param executorName will be used to tag metrics with \"name\".\n+     * @param metricPrefix the metricPrefix of the metric name.\n+     * @param tags tags to apply to all recorded metrics.\n+     * @return the instrumented executor, proxied.\n+     */\n+    public static Executor monitor(MeterRegistry registry, Executor executor, String executorName,\n+                                   String metricPrefix, Iterable<Tag> tags) {\n+        if (executor instanceof ExecutorService) {\n+            return monitor(registry, (ExecutorService) executor, executorName, metricPrefix, tags);\n+        }\n+\n+        requireNonNull(registry, \"registry\");\n+        requireNonNull(executor, \"executor\");\n+        requireNonNull(executorName, \"executorName\");\n+        requireNonNull(metricPrefix, \"metricPrefix\");\n+        requireNonNull(tags, \"tags\");\n+        return new TimedExecutor(registry, executor, executorName, metricPrefix, tags);\n+    }\n+\n+    /**\n+     * Record metrics on the use of an {@link Executor}.\n+     *\n+     * @param registry the registry to bind metrics to.\n+     * @param executor the executor to instrument.\n+     * @param executorName will be used to tag metrics with \"name\".\n+     * @param metricPrefix the prefix of the metric name.\n+     * @param tags tags to apply to all recorded metrics.\n+     * @return the instrumented executor, proxied.\n+     */\n+    public static Executor monitor(MeterRegistry registry, Executor executor, String executorName,\n+                                   String metricPrefix, Tag... tags) {\n+        requireNonNull(tags, \"tags\");\n+        return monitor(registry, executor, executorName, metricPrefix, asList(tags));\n+    }\n+\n+    /**\n+     * Record metrics on the use of an {@link ExecutorService}.\n+     *\n+     * @param registry the registry to bind metrics to.\n+     * @param executor the executor to instrument.\n+     * @param executorServiceName Will be used to tag metrics with \"name\".\n+     * @param metricPrefix the prefix of the metric name.\n+     * @param tags tags to apply to all recorded metrics.\n+     * @return the instrumented executor, proxied.\n+     */\n+    public static ExecutorService monitor(MeterRegistry registry, ExecutorService executor,\n+                                          String executorServiceName, String metricPrefix, Iterable<Tag> tags) {\n+        if (executor instanceof ScheduledExecutorService) {\n+            return monitor(registry, (ScheduledExecutorService) executor,\n+                           executorServiceName, metricPrefix, tags);\n+        }\n+\n+        requireNonNull(registry, \"registry\");\n+        requireNonNull(executor, \"executor\");\n+        requireNonNull(executorServiceName, \"executorServiceName\");\n+        requireNonNull(metricPrefix, \"metricPrefix\");\n+        requireNonNull(tags, \"tags\");\n+\n+        new ExecutorServiceMetrics(executor, executorServiceName, metricPrefix, tags).bindTo(registry);\n+        return new TimedExecutorService(registry, executor, executorServiceName, metricPrefix, tags);\n+    }\n+\n+    /**\n+     * Record metrics on the use of an {@link ExecutorService}.\n+     *\n+     * @param registry the registry to bind metrics to.\n+     * @param executor the executor to instrument.\n+     * @param executorServiceName will be used to tag metrics with \"name\".\n+     * @param metricPrefix the prefix of the metric name.\n+     * @param tags tags to apply to all recorded metrics.\n+     * @return the instrumented executor, proxied.\n+     */\n+    public static ExecutorService monitor(MeterRegistry registry, ExecutorService executor,\n+                                          String executorServiceName, String metricPrefix, Tag... tags) {\n+        requireNonNull(tags, \"tags\");\n+        return monitor(registry, executor, executorServiceName, metricPrefix, asList(tags));\n+    }\n+\n+    /**\n+     * Record metrics on the use of a {@link ScheduledExecutorService}.\n+     *\n+     * @param registry the registry to bind metrics to.\n+     * @param executor the scheduled executor to instrument.\n+     * @param executorServiceName Will be used to tag metrics with \"name\".\n+     * @param metricPrefix the prefix of the metric name.\n+     * @param tags tags to apply to all recorded metrics.\n+     * @return the instrumented scheduled executor, proxied.\n+     * @since 1.3.0\n+     */\n+    public static ScheduledExecutorService monitor(MeterRegistry registry, ScheduledExecutorService executor,\n+                                                   String executorServiceName, String metricPrefix,\n+                                                   Iterable<Tag> tags) {\n+        requireNonNull(registry, \"registry\");\n+        requireNonNull(executor, \"executor\");\n+        requireNonNull(executorServiceName, \"executorServiceName\");\n+        requireNonNull(metricPrefix, \"metricPrefix\");\n+        requireNonNull(tags, \"tags\");\n+\n+        new ExecutorServiceMetrics(executor, executorServiceName, metricPrefix, tags).bindTo(registry);\n+        return new TimedScheduledExecutorService(registry, executor, executorServiceName, metricPrefix, tags);\n+    }\n+\n+    /**\n+     * Record metrics on the use of a {@link ScheduledExecutorService}.\n+     *\n+     * @param registry the registry to bind metrics to.\n+     * @param executor the scheduled executor to instrument.\n+     * @param executorServiceName will be used to tag metrics with \"name\".\n+     * @param metricPrefix the prefix of the metric name.\n+     * @param tags tags to apply to all recorded metrics.\n+     * @return the instrumented scheduled executor, proxied.\n+     * @since 1.3.0\n+     */\n+    public static ScheduledExecutorService monitor(MeterRegistry registry, ScheduledExecutorService executor,\n+                                                   String executorServiceName, String metricPrefix,\n+                                                   Tag... tags) {\n+        requireNonNull(tags, \"tags\");\n+        return monitor(registry, executor, executorServiceName, metricPrefix, asList(tags));\n+    }\n+\n+    /**\n+     * Returns whether the specified {@link Executor} is monitored by {@link MeterRegistry}.\n+     */\n+    public static boolean isMonitoredExecutor(Executor executor) {\n+        return executor instanceof TimedScheduledExecutorService ||\n+               executor instanceof TimedExecutorService ||\n+               executor instanceof TimedExecutor ||\n+               executor instanceof io.micrometer.core.instrument.internal.TimedScheduledExecutorService ||\n+               executor instanceof io.micrometer.core.instrument.internal.TimedExecutorService ||\n+               executor instanceof io.micrometer.core.instrument.internal.TimedExecutor;\n+    }\n+\n+    /**\n+     * Every ScheduledThreadPoolExecutor created by {@link Executors} is wrapped. Also,\n+     * {@link Executors#newSingleThreadExecutor()} wrap a regular {@link ThreadPoolExecutor}.\n+     */\n+    @Nullable\n+    private static ThreadPoolExecutor unwrapThreadPoolExecutor(ExecutorService executor, Class<?> wrapper) {\n+        try {\n+            final Field e = wrapper.getDeclaredField(\"e\");\n+            e.setAccessible(true);\n+            return (ThreadPoolExecutor) e.get(executor);\n+        } catch (NoSuchFieldException | IllegalAccessException e) {\n+            // Do nothing. We simply can't get to the underlying ThreadPoolExecutor.\n+        }\n+        return null;\n+    }\n+\n+    @Nullable\n+    private final ExecutorService executorService;\n+    private final String metricPrefix;\n+    private final Iterable<Tag> tags;\n+\n+    private ExecutorServiceMetrics(@Nullable ExecutorService executorService, String executorServiceName,\n+                                   String metricPrefix, Iterable<Tag> tags) {\n+        this.executorService = executorService;\n+        this.metricPrefix = metricPrefix;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ5NTg3MA=="}, "originalCommit": {"oid": "7eafe3700e6717314706c0bf0a6b7713e3ccfcd1"}, "originalPosition": 234}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTUzMTE5OA==", "bodyText": "Added for executorServiceName and metricPrefix", "url": "https://github.com/line/armeria/pull/2612#discussion_r395531198", "createdAt": "2020-03-20T09:51:35Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/internal/common/metric/ExecutorServiceMetrics.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+/*\n+ * Copyright 2017 Pivotal Software, Inc.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linecorp.armeria.internal.common.metric;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.lang.reflect.Field;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ThreadPoolExecutor;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.util.UnstableApi;\n+\n+import io.micrometer.core.instrument.FunctionCounter;\n+import io.micrometer.core.instrument.Gauge;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.micrometer.core.instrument.binder.BaseUnits;\n+import io.micrometer.core.instrument.binder.MeterBinder;\n+\n+/**\n+ * Monitors the status of executor service pools. Does not record timings on operations executed in the\n+ * {@link ExecutorService}, as this requires the instance to be wrapped.\n+ * Timings are provided separately by wrapping the executor service with {@link TimedExecutorService}.\n+ *\n+ * @author Jon Schneider\n+ * @author Clint Checketts\n+ * @author Johnny Lim\n+ */\n+@UnstableApi\n+public final class ExecutorServiceMetrics implements MeterBinder {\n+\n+    // TODO(ikhoon) Remove this class once upstream ExecutorServiceMetrics allows customizing a metric name.\n+\n+    // Forked from Micrometer 1.3.6\n+    // https://github.com/micrometer-metrics/micrometer/blob/e6ff3c2fe9542608a33a62b10fdf1222cd60feae/micrometer-core/src/main/java/io/micrometer/core/instrument/binder/jvm/ExecutorServiceMetrics.java\n+\n+    /**\n+     * Record metrics on the use of an {@link Executor}.\n+     *\n+     * @param registry the registry to bind metrics to.\n+     * @param executor the executor to instrument.\n+     * @param executorName will be used to tag metrics with \"name\".\n+     * @param metricPrefix the metricPrefix of the metric name.\n+     * @param tags tags to apply to all recorded metrics.\n+     * @return the instrumented executor, proxied.\n+     */\n+    public static Executor monitor(MeterRegistry registry, Executor executor, String executorName,\n+                                   String metricPrefix, Iterable<Tag> tags) {\n+        if (executor instanceof ExecutorService) {\n+            return monitor(registry, (ExecutorService) executor, executorName, metricPrefix, tags);\n+        }\n+\n+        requireNonNull(registry, \"registry\");\n+        requireNonNull(executor, \"executor\");\n+        requireNonNull(executorName, \"executorName\");\n+        requireNonNull(metricPrefix, \"metricPrefix\");\n+        requireNonNull(tags, \"tags\");\n+        return new TimedExecutor(registry, executor, executorName, metricPrefix, tags);\n+    }\n+\n+    /**\n+     * Record metrics on the use of an {@link Executor}.\n+     *\n+     * @param registry the registry to bind metrics to.\n+     * @param executor the executor to instrument.\n+     * @param executorName will be used to tag metrics with \"name\".\n+     * @param metricPrefix the prefix of the metric name.\n+     * @param tags tags to apply to all recorded metrics.\n+     * @return the instrumented executor, proxied.\n+     */\n+    public static Executor monitor(MeterRegistry registry, Executor executor, String executorName,\n+                                   String metricPrefix, Tag... tags) {\n+        requireNonNull(tags, \"tags\");\n+        return monitor(registry, executor, executorName, metricPrefix, asList(tags));\n+    }\n+\n+    /**\n+     * Record metrics on the use of an {@link ExecutorService}.\n+     *\n+     * @param registry the registry to bind metrics to.\n+     * @param executor the executor to instrument.\n+     * @param executorServiceName Will be used to tag metrics with \"name\".\n+     * @param metricPrefix the prefix of the metric name.\n+     * @param tags tags to apply to all recorded metrics.\n+     * @return the instrumented executor, proxied.\n+     */\n+    public static ExecutorService monitor(MeterRegistry registry, ExecutorService executor,\n+                                          String executorServiceName, String metricPrefix, Iterable<Tag> tags) {\n+        if (executor instanceof ScheduledExecutorService) {\n+            return monitor(registry, (ScheduledExecutorService) executor,\n+                           executorServiceName, metricPrefix, tags);\n+        }\n+\n+        requireNonNull(registry, \"registry\");\n+        requireNonNull(executor, \"executor\");\n+        requireNonNull(executorServiceName, \"executorServiceName\");\n+        requireNonNull(metricPrefix, \"metricPrefix\");\n+        requireNonNull(tags, \"tags\");\n+\n+        new ExecutorServiceMetrics(executor, executorServiceName, metricPrefix, tags).bindTo(registry);\n+        return new TimedExecutorService(registry, executor, executorServiceName, metricPrefix, tags);\n+    }\n+\n+    /**\n+     * Record metrics on the use of an {@link ExecutorService}.\n+     *\n+     * @param registry the registry to bind metrics to.\n+     * @param executor the executor to instrument.\n+     * @param executorServiceName will be used to tag metrics with \"name\".\n+     * @param metricPrefix the prefix of the metric name.\n+     * @param tags tags to apply to all recorded metrics.\n+     * @return the instrumented executor, proxied.\n+     */\n+    public static ExecutorService monitor(MeterRegistry registry, ExecutorService executor,\n+                                          String executorServiceName, String metricPrefix, Tag... tags) {\n+        requireNonNull(tags, \"tags\");\n+        return monitor(registry, executor, executorServiceName, metricPrefix, asList(tags));\n+    }\n+\n+    /**\n+     * Record metrics on the use of a {@link ScheduledExecutorService}.\n+     *\n+     * @param registry the registry to bind metrics to.\n+     * @param executor the scheduled executor to instrument.\n+     * @param executorServiceName Will be used to tag metrics with \"name\".\n+     * @param metricPrefix the prefix of the metric name.\n+     * @param tags tags to apply to all recorded metrics.\n+     * @return the instrumented scheduled executor, proxied.\n+     * @since 1.3.0\n+     */\n+    public static ScheduledExecutorService monitor(MeterRegistry registry, ScheduledExecutorService executor,\n+                                                   String executorServiceName, String metricPrefix,\n+                                                   Iterable<Tag> tags) {\n+        requireNonNull(registry, \"registry\");\n+        requireNonNull(executor, \"executor\");\n+        requireNonNull(executorServiceName, \"executorServiceName\");\n+        requireNonNull(metricPrefix, \"metricPrefix\");\n+        requireNonNull(tags, \"tags\");\n+\n+        new ExecutorServiceMetrics(executor, executorServiceName, metricPrefix, tags).bindTo(registry);\n+        return new TimedScheduledExecutorService(registry, executor, executorServiceName, metricPrefix, tags);\n+    }\n+\n+    /**\n+     * Record metrics on the use of a {@link ScheduledExecutorService}.\n+     *\n+     * @param registry the registry to bind metrics to.\n+     * @param executor the scheduled executor to instrument.\n+     * @param executorServiceName will be used to tag metrics with \"name\".\n+     * @param metricPrefix the prefix of the metric name.\n+     * @param tags tags to apply to all recorded metrics.\n+     * @return the instrumented scheduled executor, proxied.\n+     * @since 1.3.0\n+     */\n+    public static ScheduledExecutorService monitor(MeterRegistry registry, ScheduledExecutorService executor,\n+                                                   String executorServiceName, String metricPrefix,\n+                                                   Tag... tags) {\n+        requireNonNull(tags, \"tags\");\n+        return monitor(registry, executor, executorServiceName, metricPrefix, asList(tags));\n+    }\n+\n+    /**\n+     * Returns whether the specified {@link Executor} is monitored by {@link MeterRegistry}.\n+     */\n+    public static boolean isMonitoredExecutor(Executor executor) {\n+        return executor instanceof TimedScheduledExecutorService ||\n+               executor instanceof TimedExecutorService ||\n+               executor instanceof TimedExecutor ||\n+               executor instanceof io.micrometer.core.instrument.internal.TimedScheduledExecutorService ||\n+               executor instanceof io.micrometer.core.instrument.internal.TimedExecutorService ||\n+               executor instanceof io.micrometer.core.instrument.internal.TimedExecutor;\n+    }\n+\n+    /**\n+     * Every ScheduledThreadPoolExecutor created by {@link Executors} is wrapped. Also,\n+     * {@link Executors#newSingleThreadExecutor()} wrap a regular {@link ThreadPoolExecutor}.\n+     */\n+    @Nullable\n+    private static ThreadPoolExecutor unwrapThreadPoolExecutor(ExecutorService executor, Class<?> wrapper) {\n+        try {\n+            final Field e = wrapper.getDeclaredField(\"e\");\n+            e.setAccessible(true);\n+            return (ThreadPoolExecutor) e.get(executor);\n+        } catch (NoSuchFieldException | IllegalAccessException e) {\n+            // Do nothing. We simply can't get to the underlying ThreadPoolExecutor.\n+        }\n+        return null;\n+    }\n+\n+    @Nullable\n+    private final ExecutorService executorService;\n+    private final String metricPrefix;\n+    private final Iterable<Tag> tags;\n+\n+    private ExecutorServiceMetrics(@Nullable ExecutorService executorService, String executorServiceName,\n+                                   String metricPrefix, Iterable<Tag> tags) {\n+        this.executorService = executorService;\n+        this.metricPrefix = metricPrefix;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ5NTg3MA=="}, "originalCommit": {"oid": "7eafe3700e6717314706c0bf0a6b7713e3ccfcd1"}, "originalPosition": 234}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MjMzNTE3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/server/ServerConfig.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMzo0Mzo1M1rOF5UOKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMVQwNzo1MDoyOVrOF5oL5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0NDQ1OQ==", "bodyText": "Now that we have our own meter name, could we remove armeria from the executor name?", "url": "https://github.com/line/armeria/pull/2612#discussion_r395644459", "createdAt": "2020-03-20T13:43:53Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/server/ServerConfig.java", "diffHunk": "@@ -158,9 +157,10 @@\n                                    gracefulShutdownQuietPeriod, \"gracefulShutdownQuietPeriod\");\n \n         requireNonNull(blockingTaskExecutor, \"blockingTaskExecutor\");\n-        if (!(blockingTaskExecutor instanceof TimedExecutorService)) {\n-            blockingTaskExecutor = ExecutorServiceMetrics.monitor(meterRegistry, blockingTaskExecutor,\n-                                                                  \"armeriaBlockingTaskExecutor\");\n+        if (!ExecutorServiceMetrics.isMonitoredExecutor(blockingTaskExecutor)) {\n+            blockingTaskExecutor =\n+                    ExecutorServiceMetrics.monitor(meterRegistry, blockingTaskExecutor,\n+                                                   \"armeriaBlockingTaskExecutor\", \"armeria.executor\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "865fa6b4b14a35275b31a40c99330ebcee92c846"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk3MTU1OQ==", "bodyText": "Yes! \ud83d\ude0e", "url": "https://github.com/line/armeria/pull/2612#discussion_r395971559", "createdAt": "2020-03-21T07:50:29Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/server/ServerConfig.java", "diffHunk": "@@ -158,9 +157,10 @@\n                                    gracefulShutdownQuietPeriod, \"gracefulShutdownQuietPeriod\");\n \n         requireNonNull(blockingTaskExecutor, \"blockingTaskExecutor\");\n-        if (!(blockingTaskExecutor instanceof TimedExecutorService)) {\n-            blockingTaskExecutor = ExecutorServiceMetrics.monitor(meterRegistry, blockingTaskExecutor,\n-                                                                  \"armeriaBlockingTaskExecutor\");\n+        if (!ExecutorServiceMetrics.isMonitoredExecutor(blockingTaskExecutor)) {\n+            blockingTaskExecutor =\n+                    ExecutorServiceMetrics.monitor(meterRegistry, blockingTaskExecutor,\n+                                                   \"armeriaBlockingTaskExecutor\", \"armeria.executor\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0NDQ1OQ=="}, "originalCommit": {"oid": "865fa6b4b14a35275b31a40c99330ebcee92c846"}, "originalPosition": 22}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2794, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}