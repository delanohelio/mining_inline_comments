{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE5MzkwNjQ3", "number": 2724, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjoyMDozOVrOD9nQGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNjoxNjozMFrOD9pqLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTMyODI1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestScopedMdc.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjoyMDozOVrOGXNhYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjoyMDozOVrOGXNhYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5MTk2OA==", "bodyText": "nit: double dot.", "url": "https://github.com/line/armeria/pull/2724#discussion_r426991968", "createdAt": "2020-05-19T02:20:39Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestScopedMdc.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logging;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.lang.reflect.Field;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.slf4j.MDC;\n+import org.slf4j.spi.MDCAdapter;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.common.RequestContext;\n+\n+import io.netty.util.AttributeKey;\n+import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;\n+\n+/**\n+ * Provides the access to request-scoped {@link MDC} properties. All properties set via the access methods in\n+ * this class are bound to a {@link RequestContext}, unlike the traditional thread-local {@link MDC} properties.\n+ *\n+ * <h3>Updating the request-scoped context map</h3>\n+ *\n+ * <p>Update the request-scoped context map using {@link #put(RequestContext, String, String)},\n+ * {@link #putAll(RequestContext, Map)}, {@link #remove(RequestContext, String)} and\n+ * {@link #clear(RequestContext)}:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * RequestScopedMdc.put(ctx, \"transactionId\", \"1234\");\n+ * RequestScopedMdc.putAll(ctx, Map.of(\"foo\", \"1\", \"bar\", \"2\"));\n+ * }</pre></p>\n+ *\n+ * <h3>Transferring thread-local properties</h3>\n+ *\n+ * <p>Use {@link #copy(RequestContext, String)} or {@link #copyAll(RequestContext)} to copy some or all of\n+ * thread-local {@link MDC} properties to the request-scoped context map:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * MDC.put(\"transactionId\", \"1234\");\n+ * RequestScopedMdc.copy(ctx, \"transactionId\");\n+ * }</pre></p>\n+ *\n+ * <h3>Retrieving a value from the request-scoped context map</h3>\n+ *\n+ * <p>You can explicitly retrieve request-scoped properties using {@link #get(RequestContext, String)} or\n+ * {@link #getAll(RequestContext)}:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * String transactionId = RequestScopedMdc.get(ctx, \"transactionId\");\n+ * }</pre></p>\n+ *\n+ * <p>{@link RequestScopedMdc} replaces SLF4J's underlying {@link MDCAdapter} implementation so that\n+ * {@link MDC#get(String)} and {@link MDC#getCopyOfContextMap()} look into the request-scoped context map\n+ * before the thread-local context map:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * RequestScopedMdc.put(ctx, \"transactionId\", \"1234\");\n+ * try (SafeCloseable ignored = ctx.push()) {\n+ *     assert MDC.get(\"transactionId\").equals(\"1234\");\n+ *\n+ *     // A request-scoped property always gets higher priority:\n+ *     MDC.put(\"transactionId\", \"5678\");\n+ *     assert MDC.get(\"transactionId\").equals(\"1234\");\n+ * }\n+ *\n+ * // Now using the thread-local property\n+ * // because not in a request scope anymore\n+ * assert MDC.get(\"transactionId\").equals(\"5678\");\n+ * }</pre></p>\n+ */\n+public final class RequestScopedMdc {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(RequestScopedMdc.class);\n+\n+    private static final AttributeKey<Map<String, String>> MAP =\n+            AttributeKey.valueOf(RequestScopedMdc.class, \"map\");\n+\n+    private static final String ERROR_MESSAGE =\n+            \"Failed to replace the \" + MDCAdapter.class.getSimpleName() + \"; \" +\n+            RequestScopedMdc.class.getSimpleName() + \" will not work.\";\n+\n+    @Nullable\n+    private static final MDCAdapter delegate;\n+\n+    static {\n+        // Trigger the initialization of the default MDC adapter.\n+        MDC.get(\"\");\n+\n+        // Replace the default MDC adapter with ours.\n+        MDCAdapter oldAdapter = null;\n+        try {\n+            final Field mdcAdapterField = MDC.class.getDeclaredField(\"mdcAdapter\");\n+            mdcAdapterField.setAccessible(true);\n+            oldAdapter = (MDCAdapter) mdcAdapterField.get(null);\n+            mdcAdapterField.set(null, new Adapter(oldAdapter));\n+        } catch (Throwable t) {\n+            logger.warn(ERROR_MESSAGE, t);\n+        }\n+        delegate = oldAdapter;\n+    }\n+\n+    /**\n+     * Returns the value of the specified request-scoped {@link MDC} property bound to the specified\n+     * {@link RequestContext}..", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "647c0236a881cd2eae5b00ed584564b5a0e8a269"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTMyODkyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestScopedMdc.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjoyMDo1N1rOGXNhwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjoyMDo1N1rOGXNhwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5MjA2Ng==", "bodyText": "ditto", "url": "https://github.com/line/armeria/pull/2724#discussion_r426992066", "createdAt": "2020-05-19T02:20:57Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestScopedMdc.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logging;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.lang.reflect.Field;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.slf4j.MDC;\n+import org.slf4j.spi.MDCAdapter;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.common.RequestContext;\n+\n+import io.netty.util.AttributeKey;\n+import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;\n+\n+/**\n+ * Provides the access to request-scoped {@link MDC} properties. All properties set via the access methods in\n+ * this class are bound to a {@link RequestContext}, unlike the traditional thread-local {@link MDC} properties.\n+ *\n+ * <h3>Updating the request-scoped context map</h3>\n+ *\n+ * <p>Update the request-scoped context map using {@link #put(RequestContext, String, String)},\n+ * {@link #putAll(RequestContext, Map)}, {@link #remove(RequestContext, String)} and\n+ * {@link #clear(RequestContext)}:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * RequestScopedMdc.put(ctx, \"transactionId\", \"1234\");\n+ * RequestScopedMdc.putAll(ctx, Map.of(\"foo\", \"1\", \"bar\", \"2\"));\n+ * }</pre></p>\n+ *\n+ * <h3>Transferring thread-local properties</h3>\n+ *\n+ * <p>Use {@link #copy(RequestContext, String)} or {@link #copyAll(RequestContext)} to copy some or all of\n+ * thread-local {@link MDC} properties to the request-scoped context map:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * MDC.put(\"transactionId\", \"1234\");\n+ * RequestScopedMdc.copy(ctx, \"transactionId\");\n+ * }</pre></p>\n+ *\n+ * <h3>Retrieving a value from the request-scoped context map</h3>\n+ *\n+ * <p>You can explicitly retrieve request-scoped properties using {@link #get(RequestContext, String)} or\n+ * {@link #getAll(RequestContext)}:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * String transactionId = RequestScopedMdc.get(ctx, \"transactionId\");\n+ * }</pre></p>\n+ *\n+ * <p>{@link RequestScopedMdc} replaces SLF4J's underlying {@link MDCAdapter} implementation so that\n+ * {@link MDC#get(String)} and {@link MDC#getCopyOfContextMap()} look into the request-scoped context map\n+ * before the thread-local context map:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * RequestScopedMdc.put(ctx, \"transactionId\", \"1234\");\n+ * try (SafeCloseable ignored = ctx.push()) {\n+ *     assert MDC.get(\"transactionId\").equals(\"1234\");\n+ *\n+ *     // A request-scoped property always gets higher priority:\n+ *     MDC.put(\"transactionId\", \"5678\");\n+ *     assert MDC.get(\"transactionId\").equals(\"1234\");\n+ * }\n+ *\n+ * // Now using the thread-local property\n+ * // because not in a request scope anymore\n+ * assert MDC.get(\"transactionId\").equals(\"5678\");\n+ * }</pre></p>\n+ */\n+public final class RequestScopedMdc {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(RequestScopedMdc.class);\n+\n+    private static final AttributeKey<Map<String, String>> MAP =\n+            AttributeKey.valueOf(RequestScopedMdc.class, \"map\");\n+\n+    private static final String ERROR_MESSAGE =\n+            \"Failed to replace the \" + MDCAdapter.class.getSimpleName() + \"; \" +\n+            RequestScopedMdc.class.getSimpleName() + \" will not work.\";\n+\n+    @Nullable\n+    private static final MDCAdapter delegate;\n+\n+    static {\n+        // Trigger the initialization of the default MDC adapter.\n+        MDC.get(\"\");\n+\n+        // Replace the default MDC adapter with ours.\n+        MDCAdapter oldAdapter = null;\n+        try {\n+            final Field mdcAdapterField = MDC.class.getDeclaredField(\"mdcAdapter\");\n+            mdcAdapterField.setAccessible(true);\n+            oldAdapter = (MDCAdapter) mdcAdapterField.get(null);\n+            mdcAdapterField.set(null, new Adapter(oldAdapter));\n+        } catch (Throwable t) {\n+            logger.warn(ERROR_MESSAGE, t);\n+        }\n+        delegate = oldAdapter;\n+    }\n+\n+    /**\n+     * Returns the value of the specified request-scoped {@link MDC} property bound to the specified\n+     * {@link RequestContext}..\n+     *\n+     * @param ctx the {@link RequestContext}\n+     * @param key the key of the request-scoped {@link MDC} property\n+     *\n+     * @return the request-scoped {@link MDC} property. {@code null} if not found.\n+     */\n+    @Nullable\n+    public static String get(RequestContext ctx, String key) {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(key, \"key\");\n+        return getMap(ctx).get(key);\n+    }\n+\n+    /**\n+     * Returns the {@link Map} of all request-scoped {@link MDC} properties bound to the specified\n+     * {@link RequestContext}..", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "647c0236a881cd2eae5b00ed584564b5a0e8a269"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTMzNzk0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestScopedMdc.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjoyNjozMVrOGXNnZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjoyNjozMVrOGXNnZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5MzUxMQ==", "bodyText": "Isn't it better to always put unmodifiableMap to the context and return the map without making it unmodifiable? because the implementation supposes that reading is a lot than writing?", "url": "https://github.com/line/armeria/pull/2724#discussion_r426993511", "createdAt": "2020-05-19T02:26:31Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestScopedMdc.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logging;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.lang.reflect.Field;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.slf4j.MDC;\n+import org.slf4j.spi.MDCAdapter;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.common.RequestContext;\n+\n+import io.netty.util.AttributeKey;\n+import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;\n+\n+/**\n+ * Provides the access to request-scoped {@link MDC} properties. All properties set via the access methods in\n+ * this class are bound to a {@link RequestContext}, unlike the traditional thread-local {@link MDC} properties.\n+ *\n+ * <h3>Updating the request-scoped context map</h3>\n+ *\n+ * <p>Update the request-scoped context map using {@link #put(RequestContext, String, String)},\n+ * {@link #putAll(RequestContext, Map)}, {@link #remove(RequestContext, String)} and\n+ * {@link #clear(RequestContext)}:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * RequestScopedMdc.put(ctx, \"transactionId\", \"1234\");\n+ * RequestScopedMdc.putAll(ctx, Map.of(\"foo\", \"1\", \"bar\", \"2\"));\n+ * }</pre></p>\n+ *\n+ * <h3>Transferring thread-local properties</h3>\n+ *\n+ * <p>Use {@link #copy(RequestContext, String)} or {@link #copyAll(RequestContext)} to copy some or all of\n+ * thread-local {@link MDC} properties to the request-scoped context map:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * MDC.put(\"transactionId\", \"1234\");\n+ * RequestScopedMdc.copy(ctx, \"transactionId\");\n+ * }</pre></p>\n+ *\n+ * <h3>Retrieving a value from the request-scoped context map</h3>\n+ *\n+ * <p>You can explicitly retrieve request-scoped properties using {@link #get(RequestContext, String)} or\n+ * {@link #getAll(RequestContext)}:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * String transactionId = RequestScopedMdc.get(ctx, \"transactionId\");\n+ * }</pre></p>\n+ *\n+ * <p>{@link RequestScopedMdc} replaces SLF4J's underlying {@link MDCAdapter} implementation so that\n+ * {@link MDC#get(String)} and {@link MDC#getCopyOfContextMap()} look into the request-scoped context map\n+ * before the thread-local context map:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * RequestScopedMdc.put(ctx, \"transactionId\", \"1234\");\n+ * try (SafeCloseable ignored = ctx.push()) {\n+ *     assert MDC.get(\"transactionId\").equals(\"1234\");\n+ *\n+ *     // A request-scoped property always gets higher priority:\n+ *     MDC.put(\"transactionId\", \"5678\");\n+ *     assert MDC.get(\"transactionId\").equals(\"1234\");\n+ * }\n+ *\n+ * // Now using the thread-local property\n+ * // because not in a request scope anymore\n+ * assert MDC.get(\"transactionId\").equals(\"5678\");\n+ * }</pre></p>\n+ */\n+public final class RequestScopedMdc {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(RequestScopedMdc.class);\n+\n+    private static final AttributeKey<Map<String, String>> MAP =\n+            AttributeKey.valueOf(RequestScopedMdc.class, \"map\");\n+\n+    private static final String ERROR_MESSAGE =\n+            \"Failed to replace the \" + MDCAdapter.class.getSimpleName() + \"; \" +\n+            RequestScopedMdc.class.getSimpleName() + \" will not work.\";\n+\n+    @Nullable\n+    private static final MDCAdapter delegate;\n+\n+    static {\n+        // Trigger the initialization of the default MDC adapter.\n+        MDC.get(\"\");\n+\n+        // Replace the default MDC adapter with ours.\n+        MDCAdapter oldAdapter = null;\n+        try {\n+            final Field mdcAdapterField = MDC.class.getDeclaredField(\"mdcAdapter\");\n+            mdcAdapterField.setAccessible(true);\n+            oldAdapter = (MDCAdapter) mdcAdapterField.get(null);\n+            mdcAdapterField.set(null, new Adapter(oldAdapter));\n+        } catch (Throwable t) {\n+            logger.warn(ERROR_MESSAGE, t);\n+        }\n+        delegate = oldAdapter;\n+    }\n+\n+    /**\n+     * Returns the value of the specified request-scoped {@link MDC} property bound to the specified\n+     * {@link RequestContext}..\n+     *\n+     * @param ctx the {@link RequestContext}\n+     * @param key the key of the request-scoped {@link MDC} property\n+     *\n+     * @return the request-scoped {@link MDC} property. {@code null} if not found.\n+     */\n+    @Nullable\n+    public static String get(RequestContext ctx, String key) {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(key, \"key\");\n+        return getMap(ctx).get(key);\n+    }\n+\n+    /**\n+     * Returns the {@link Map} of all request-scoped {@link MDC} properties bound to the specified\n+     * {@link RequestContext}..\n+     *\n+     * @param ctx the {@link RequestContext}\n+     *\n+     * @return the {@link Map} that contains all request-scoped {@link MDC} properties.\n+     *         An empty {@link Map} if there are no request-scoped {@link MDC} properties.\n+     */\n+    public static Map<String, String> getAll(RequestContext ctx) {\n+        requireNonNull(ctx, \"ctx\");\n+        final Map<String, String> map = getMap(ctx);\n+        // Note: We ensure an empty map is always immutable.\n+        return map.isEmpty() ? map : Collections.unmodifiableMap(map);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "647c0236a881cd2eae5b00ed584564b5a0e8a269"}, "originalPosition": 152}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTM0OTkwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestScopedMdc.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjozMzowNVrOGXNuUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNTo1NjoyNVrOGXQ3LQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5NTI4Mg==", "bodyText": "I'm wondering we should add owdAttr to RequestContext so that we do not have to check the instance all the time. \ud83e\udd14", "url": "https://github.com/line/armeria/pull/2724#discussion_r426995282", "createdAt": "2020-05-19T02:33:05Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestScopedMdc.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logging;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.lang.reflect.Field;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.slf4j.MDC;\n+import org.slf4j.spi.MDCAdapter;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.common.RequestContext;\n+\n+import io.netty.util.AttributeKey;\n+import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;\n+\n+/**\n+ * Provides the access to request-scoped {@link MDC} properties. All properties set via the access methods in\n+ * this class are bound to a {@link RequestContext}, unlike the traditional thread-local {@link MDC} properties.\n+ *\n+ * <h3>Updating the request-scoped context map</h3>\n+ *\n+ * <p>Update the request-scoped context map using {@link #put(RequestContext, String, String)},\n+ * {@link #putAll(RequestContext, Map)}, {@link #remove(RequestContext, String)} and\n+ * {@link #clear(RequestContext)}:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * RequestScopedMdc.put(ctx, \"transactionId\", \"1234\");\n+ * RequestScopedMdc.putAll(ctx, Map.of(\"foo\", \"1\", \"bar\", \"2\"));\n+ * }</pre></p>\n+ *\n+ * <h3>Transferring thread-local properties</h3>\n+ *\n+ * <p>Use {@link #copy(RequestContext, String)} or {@link #copyAll(RequestContext)} to copy some or all of\n+ * thread-local {@link MDC} properties to the request-scoped context map:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * MDC.put(\"transactionId\", \"1234\");\n+ * RequestScopedMdc.copy(ctx, \"transactionId\");\n+ * }</pre></p>\n+ *\n+ * <h3>Retrieving a value from the request-scoped context map</h3>\n+ *\n+ * <p>You can explicitly retrieve request-scoped properties using {@link #get(RequestContext, String)} or\n+ * {@link #getAll(RequestContext)}:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * String transactionId = RequestScopedMdc.get(ctx, \"transactionId\");\n+ * }</pre></p>\n+ *\n+ * <p>{@link RequestScopedMdc} replaces SLF4J's underlying {@link MDCAdapter} implementation so that\n+ * {@link MDC#get(String)} and {@link MDC#getCopyOfContextMap()} look into the request-scoped context map\n+ * before the thread-local context map:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * RequestScopedMdc.put(ctx, \"transactionId\", \"1234\");\n+ * try (SafeCloseable ignored = ctx.push()) {\n+ *     assert MDC.get(\"transactionId\").equals(\"1234\");\n+ *\n+ *     // A request-scoped property always gets higher priority:\n+ *     MDC.put(\"transactionId\", \"5678\");\n+ *     assert MDC.get(\"transactionId\").equals(\"1234\");\n+ * }\n+ *\n+ * // Now using the thread-local property\n+ * // because not in a request scope anymore\n+ * assert MDC.get(\"transactionId\").equals(\"5678\");\n+ * }</pre></p>\n+ */\n+public final class RequestScopedMdc {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(RequestScopedMdc.class);\n+\n+    private static final AttributeKey<Map<String, String>> MAP =\n+            AttributeKey.valueOf(RequestScopedMdc.class, \"map\");\n+\n+    private static final String ERROR_MESSAGE =\n+            \"Failed to replace the \" + MDCAdapter.class.getSimpleName() + \"; \" +\n+            RequestScopedMdc.class.getSimpleName() + \" will not work.\";\n+\n+    @Nullable\n+    private static final MDCAdapter delegate;\n+\n+    static {\n+        // Trigger the initialization of the default MDC adapter.\n+        MDC.get(\"\");\n+\n+        // Replace the default MDC adapter with ours.\n+        MDCAdapter oldAdapter = null;\n+        try {\n+            final Field mdcAdapterField = MDC.class.getDeclaredField(\"mdcAdapter\");\n+            mdcAdapterField.setAccessible(true);\n+            oldAdapter = (MDCAdapter) mdcAdapterField.get(null);\n+            mdcAdapterField.set(null, new Adapter(oldAdapter));\n+        } catch (Throwable t) {\n+            logger.warn(ERROR_MESSAGE, t);\n+        }\n+        delegate = oldAdapter;\n+    }\n+\n+    /**\n+     * Returns the value of the specified request-scoped {@link MDC} property bound to the specified\n+     * {@link RequestContext}..\n+     *\n+     * @param ctx the {@link RequestContext}\n+     * @param key the key of the request-scoped {@link MDC} property\n+     *\n+     * @return the request-scoped {@link MDC} property. {@code null} if not found.\n+     */\n+    @Nullable\n+    public static String get(RequestContext ctx, String key) {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(key, \"key\");\n+        return getMap(ctx).get(key);\n+    }\n+\n+    /**\n+     * Returns the {@link Map} of all request-scoped {@link MDC} properties bound to the specified\n+     * {@link RequestContext}..\n+     *\n+     * @param ctx the {@link RequestContext}\n+     *\n+     * @return the {@link Map} that contains all request-scoped {@link MDC} properties.\n+     *         An empty {@link Map} if there are no request-scoped {@link MDC} properties.\n+     */\n+    public static Map<String, String> getAll(RequestContext ctx) {\n+        requireNonNull(ctx, \"ctx\");\n+        final Map<String, String> map = getMap(ctx);\n+        // Note: We ensure an empty map is always immutable.\n+        return map.isEmpty() ? map : Collections.unmodifiableMap(map);\n+    }\n+\n+    /**\n+     * Binds the specified request-scoped {@link MDC} property to the specified {@link RequestContext}.\n+     *\n+     * @param ctx   the {@link RequestContext}\n+     * @param key   the key of the request-scoped {@link MDC} property\n+     * @param value the value of the request-scoped {@link MDC} property\n+     */\n+    public static void put(RequestContext ctx, String key, @Nullable String value) {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(key, \"key\");\n+\n+        synchronized (ctx) {\n+            final Map<String, String> oldMap = getMap(ctx);\n+            final Map<String, String> newMap;\n+            if (oldMap.isEmpty()) {\n+                newMap = Collections.singletonMap(key, value);\n+            } else {\n+                newMap = new Object2ObjectOpenHashMap<>(oldMap.size() + 1);\n+                newMap.putAll(oldMap);\n+                newMap.put(key, value);\n+            }\n+            ctx.setAttr(MAP, newMap);\n+        }\n+    }\n+\n+    /**\n+     * Binds the specified request-scoped {@link MDC} properties to the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     * @param map the {@link Map} that contains the request-scoped {@link MDC} properties\n+     */\n+    public static void putAll(RequestContext ctx, Map<String, String> map) {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(map, \"map\");\n+        if (map.isEmpty()) {\n+            return;\n+        }\n+\n+        synchronized (ctx) {\n+            final Map<String, String> oldMap = getMap(ctx);\n+            final Map<String, String> newMap;\n+            if (oldMap.isEmpty()) {\n+                newMap = new Object2ObjectOpenHashMap<>(map);\n+            } else {\n+                newMap = new Object2ObjectOpenHashMap<>(oldMap.size() + map.size());\n+                newMap.putAll(oldMap);\n+                newMap.putAll(map);\n+            }\n+            ctx.setAttr(MAP, newMap);\n+        }\n+    }\n+\n+    /**\n+     * Copies the specified thread-local {@link MDC} property to the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     * @param key the key of the thread-local {@link MDC} property to copy\n+     */\n+    public static void copy(RequestContext ctx, String key) {\n+        checkState(delegate != null, ERROR_MESSAGE);\n+        put(ctx, key, delegate.get(key));\n+    }\n+\n+    /**\n+     * Copies all thread-local {@link MDC} properties to the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     */\n+    public static void copyAll(RequestContext ctx) {\n+        checkState(delegate != null, ERROR_MESSAGE);\n+        putAll(ctx, firstNonNull(delegate.getCopyOfContextMap(), Collections.emptyMap()));\n+    }\n+\n+    /**\n+     * Unbinds the specified request-scoped {@link MDC} property from the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     * @param key the key of the request-scoped {@link MDC} property to unbind\n+     */\n+    public static void remove(RequestContext ctx, String key) {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(key, \"key\");\n+\n+        synchronized (ctx) {\n+            final Map<String, String> oldMap = getMap(ctx);\n+            if (!oldMap.containsKey(key)) {\n+                return;\n+            }\n+\n+            final Map<String, String> newMap;\n+            if (oldMap.size() == 1) {\n+                newMap = Collections.emptyMap();\n+            } else {\n+                newMap = new Object2ObjectOpenHashMap<>(oldMap);\n+                newMap.remove(key);\n+            }\n+            ctx.setAttr(MAP, newMap);\n+        }\n+    }\n+\n+    /**\n+     * Unbinds all request-scoped {@link MDC} properties from the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     */\n+    public static void clear(RequestContext ctx) {\n+        requireNonNull(ctx, \"ctx\");\n+\n+        synchronized (ctx) {\n+            final Map<String, String> oldMap = getMap(ctx);\n+            if (!oldMap.isEmpty()) {\n+                ctx.setAttr(MAP, Collections.emptyMap());\n+            }\n+        }\n+    }\n+\n+    private static Map<String, String> getMap(RequestContext ctx) {\n+        final Map<String, String> map;\n+        if (ctx instanceof ClientRequestContext) {\n+            map = ((ClientRequestContext) ctx).ownAttr(MAP);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "647c0236a881cd2eae5b00ed584564b5a0e8a269"}, "originalPosition": 274}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA0NjcwMQ==", "bodyText": "Yeah, and computeOwnAttrIfAbsent(), etc. \ud83d\ude04", "url": "https://github.com/line/armeria/pull/2724#discussion_r427046701", "createdAt": "2020-05-19T05:56:25Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestScopedMdc.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logging;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.lang.reflect.Field;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.slf4j.MDC;\n+import org.slf4j.spi.MDCAdapter;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.common.RequestContext;\n+\n+import io.netty.util.AttributeKey;\n+import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;\n+\n+/**\n+ * Provides the access to request-scoped {@link MDC} properties. All properties set via the access methods in\n+ * this class are bound to a {@link RequestContext}, unlike the traditional thread-local {@link MDC} properties.\n+ *\n+ * <h3>Updating the request-scoped context map</h3>\n+ *\n+ * <p>Update the request-scoped context map using {@link #put(RequestContext, String, String)},\n+ * {@link #putAll(RequestContext, Map)}, {@link #remove(RequestContext, String)} and\n+ * {@link #clear(RequestContext)}:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * RequestScopedMdc.put(ctx, \"transactionId\", \"1234\");\n+ * RequestScopedMdc.putAll(ctx, Map.of(\"foo\", \"1\", \"bar\", \"2\"));\n+ * }</pre></p>\n+ *\n+ * <h3>Transferring thread-local properties</h3>\n+ *\n+ * <p>Use {@link #copy(RequestContext, String)} or {@link #copyAll(RequestContext)} to copy some or all of\n+ * thread-local {@link MDC} properties to the request-scoped context map:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * MDC.put(\"transactionId\", \"1234\");\n+ * RequestScopedMdc.copy(ctx, \"transactionId\");\n+ * }</pre></p>\n+ *\n+ * <h3>Retrieving a value from the request-scoped context map</h3>\n+ *\n+ * <p>You can explicitly retrieve request-scoped properties using {@link #get(RequestContext, String)} or\n+ * {@link #getAll(RequestContext)}:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * String transactionId = RequestScopedMdc.get(ctx, \"transactionId\");\n+ * }</pre></p>\n+ *\n+ * <p>{@link RequestScopedMdc} replaces SLF4J's underlying {@link MDCAdapter} implementation so that\n+ * {@link MDC#get(String)} and {@link MDC#getCopyOfContextMap()} look into the request-scoped context map\n+ * before the thread-local context map:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * RequestScopedMdc.put(ctx, \"transactionId\", \"1234\");\n+ * try (SafeCloseable ignored = ctx.push()) {\n+ *     assert MDC.get(\"transactionId\").equals(\"1234\");\n+ *\n+ *     // A request-scoped property always gets higher priority:\n+ *     MDC.put(\"transactionId\", \"5678\");\n+ *     assert MDC.get(\"transactionId\").equals(\"1234\");\n+ * }\n+ *\n+ * // Now using the thread-local property\n+ * // because not in a request scope anymore\n+ * assert MDC.get(\"transactionId\").equals(\"5678\");\n+ * }</pre></p>\n+ */\n+public final class RequestScopedMdc {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(RequestScopedMdc.class);\n+\n+    private static final AttributeKey<Map<String, String>> MAP =\n+            AttributeKey.valueOf(RequestScopedMdc.class, \"map\");\n+\n+    private static final String ERROR_MESSAGE =\n+            \"Failed to replace the \" + MDCAdapter.class.getSimpleName() + \"; \" +\n+            RequestScopedMdc.class.getSimpleName() + \" will not work.\";\n+\n+    @Nullable\n+    private static final MDCAdapter delegate;\n+\n+    static {\n+        // Trigger the initialization of the default MDC adapter.\n+        MDC.get(\"\");\n+\n+        // Replace the default MDC adapter with ours.\n+        MDCAdapter oldAdapter = null;\n+        try {\n+            final Field mdcAdapterField = MDC.class.getDeclaredField(\"mdcAdapter\");\n+            mdcAdapterField.setAccessible(true);\n+            oldAdapter = (MDCAdapter) mdcAdapterField.get(null);\n+            mdcAdapterField.set(null, new Adapter(oldAdapter));\n+        } catch (Throwable t) {\n+            logger.warn(ERROR_MESSAGE, t);\n+        }\n+        delegate = oldAdapter;\n+    }\n+\n+    /**\n+     * Returns the value of the specified request-scoped {@link MDC} property bound to the specified\n+     * {@link RequestContext}..\n+     *\n+     * @param ctx the {@link RequestContext}\n+     * @param key the key of the request-scoped {@link MDC} property\n+     *\n+     * @return the request-scoped {@link MDC} property. {@code null} if not found.\n+     */\n+    @Nullable\n+    public static String get(RequestContext ctx, String key) {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(key, \"key\");\n+        return getMap(ctx).get(key);\n+    }\n+\n+    /**\n+     * Returns the {@link Map} of all request-scoped {@link MDC} properties bound to the specified\n+     * {@link RequestContext}..\n+     *\n+     * @param ctx the {@link RequestContext}\n+     *\n+     * @return the {@link Map} that contains all request-scoped {@link MDC} properties.\n+     *         An empty {@link Map} if there are no request-scoped {@link MDC} properties.\n+     */\n+    public static Map<String, String> getAll(RequestContext ctx) {\n+        requireNonNull(ctx, \"ctx\");\n+        final Map<String, String> map = getMap(ctx);\n+        // Note: We ensure an empty map is always immutable.\n+        return map.isEmpty() ? map : Collections.unmodifiableMap(map);\n+    }\n+\n+    /**\n+     * Binds the specified request-scoped {@link MDC} property to the specified {@link RequestContext}.\n+     *\n+     * @param ctx   the {@link RequestContext}\n+     * @param key   the key of the request-scoped {@link MDC} property\n+     * @param value the value of the request-scoped {@link MDC} property\n+     */\n+    public static void put(RequestContext ctx, String key, @Nullable String value) {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(key, \"key\");\n+\n+        synchronized (ctx) {\n+            final Map<String, String> oldMap = getMap(ctx);\n+            final Map<String, String> newMap;\n+            if (oldMap.isEmpty()) {\n+                newMap = Collections.singletonMap(key, value);\n+            } else {\n+                newMap = new Object2ObjectOpenHashMap<>(oldMap.size() + 1);\n+                newMap.putAll(oldMap);\n+                newMap.put(key, value);\n+            }\n+            ctx.setAttr(MAP, newMap);\n+        }\n+    }\n+\n+    /**\n+     * Binds the specified request-scoped {@link MDC} properties to the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     * @param map the {@link Map} that contains the request-scoped {@link MDC} properties\n+     */\n+    public static void putAll(RequestContext ctx, Map<String, String> map) {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(map, \"map\");\n+        if (map.isEmpty()) {\n+            return;\n+        }\n+\n+        synchronized (ctx) {\n+            final Map<String, String> oldMap = getMap(ctx);\n+            final Map<String, String> newMap;\n+            if (oldMap.isEmpty()) {\n+                newMap = new Object2ObjectOpenHashMap<>(map);\n+            } else {\n+                newMap = new Object2ObjectOpenHashMap<>(oldMap.size() + map.size());\n+                newMap.putAll(oldMap);\n+                newMap.putAll(map);\n+            }\n+            ctx.setAttr(MAP, newMap);\n+        }\n+    }\n+\n+    /**\n+     * Copies the specified thread-local {@link MDC} property to the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     * @param key the key of the thread-local {@link MDC} property to copy\n+     */\n+    public static void copy(RequestContext ctx, String key) {\n+        checkState(delegate != null, ERROR_MESSAGE);\n+        put(ctx, key, delegate.get(key));\n+    }\n+\n+    /**\n+     * Copies all thread-local {@link MDC} properties to the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     */\n+    public static void copyAll(RequestContext ctx) {\n+        checkState(delegate != null, ERROR_MESSAGE);\n+        putAll(ctx, firstNonNull(delegate.getCopyOfContextMap(), Collections.emptyMap()));\n+    }\n+\n+    /**\n+     * Unbinds the specified request-scoped {@link MDC} property from the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     * @param key the key of the request-scoped {@link MDC} property to unbind\n+     */\n+    public static void remove(RequestContext ctx, String key) {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(key, \"key\");\n+\n+        synchronized (ctx) {\n+            final Map<String, String> oldMap = getMap(ctx);\n+            if (!oldMap.containsKey(key)) {\n+                return;\n+            }\n+\n+            final Map<String, String> newMap;\n+            if (oldMap.size() == 1) {\n+                newMap = Collections.emptyMap();\n+            } else {\n+                newMap = new Object2ObjectOpenHashMap<>(oldMap);\n+                newMap.remove(key);\n+            }\n+            ctx.setAttr(MAP, newMap);\n+        }\n+    }\n+\n+    /**\n+     * Unbinds all request-scoped {@link MDC} properties from the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     */\n+    public static void clear(RequestContext ctx) {\n+        requireNonNull(ctx, \"ctx\");\n+\n+        synchronized (ctx) {\n+            final Map<String, String> oldMap = getMap(ctx);\n+            if (!oldMap.isEmpty()) {\n+                ctx.setAttr(MAP, Collections.emptyMap());\n+            }\n+        }\n+    }\n+\n+    private static Map<String, String> getMap(RequestContext ctx) {\n+        final Map<String, String> map;\n+        if (ctx instanceof ClientRequestContext) {\n+            map = ((ClientRequestContext) ctx).ownAttr(MAP);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5NTI4Mg=="}, "originalCommit": {"oid": "647c0236a881cd2eae5b00ed584564b5a0e8a269"}, "originalPosition": 274}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTM1NTAyOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/common/logging/RequestScopedMdcTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjozNTo0OFrOGXNxVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMjozNTo0OFrOGXNxVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5NjA1NA==", "bodyText": "Let's add assertThat(MDC.get(\"foo\")).isNull();", "url": "https://github.com/line/armeria/pull/2724#discussion_r426996054", "createdAt": "2020-05-19T02:35:48Z", "author": {"login": "minwoox"}, "path": "core/src/test/java/com/linecorp/armeria/common/logging/RequestScopedMdcTest.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logging;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.Collections;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.slf4j.MDC;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.RequestContext;\n+import com.linecorp.armeria.common.util.SafeCloseable;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+class RequestScopedMdcTest {\n+\n+    @BeforeEach\n+    void beforeEach() {\n+        MDC.clear();\n+        assertThat(MDC.getCopyOfContextMap()).isIn(Collections.emptyMap(), null);\n+        assertThat(RequestContext.<RequestContext>currentOrNull()).isNull();\n+    }\n+\n+    @Test\n+    void threadLocalGet() {\n+        MDC.put(\"threadLocalProp\", \"1\");\n+        assertThat(MDC.get(\"threadLocalProp\")).isEqualTo(\"1\");\n+    }\n+\n+    @Test\n+    void get() {\n+        final ServiceRequestContext ctx = newContext();\n+        RequestScopedMdc.put(ctx, \"foo\", \"1\");\n+        assertThat(RequestScopedMdc.get(ctx, \"foo\")).isEqualTo(\"1\");\n+        try (SafeCloseable ignored = ctx.push()) {\n+            assertThat(MDC.get(\"foo\")).isEqualTo(\"1\");\n+            // Request-scoped property should have priority over thread-local one.\n+            MDC.put(\"foo\", \"2\");\n+            assertThat(MDC.get(\"foo\")).isEqualTo(\"1\");\n+\n+            // A client context must use its own map.\n+            final ClientRequestContext cctx = ClientRequestContext.of(HttpRequest.of(HttpMethod.GET, \"/\"));\n+            assertThat(cctx.root()).isSameAs(ctx);\n+            assertThat(RequestScopedMdc.get(cctx, \"foo\")).isNull();\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "647c0236a881cd2eae5b00ed584564b5a0e8a269"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTQxNDcyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestScopedMdc.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMzoxNDoyNFrOGXOWVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMzoxNDoyNFrOGXOWVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAwNTUyNg==", "bodyText": "Could remove @Nullable?", "url": "https://github.com/line/armeria/pull/2724#discussion_r427005526", "createdAt": "2020-05-19T03:14:24Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestScopedMdc.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logging;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.lang.reflect.Field;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.slf4j.MDC;\n+import org.slf4j.spi.MDCAdapter;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.common.RequestContext;\n+\n+import io.netty.util.AttributeKey;\n+import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;\n+\n+/**\n+ * Provides the access to request-scoped {@link MDC} properties. All properties set via the access methods in\n+ * this class are bound to a {@link RequestContext}, unlike the traditional thread-local {@link MDC} properties.\n+ *\n+ * <h3>Updating the request-scoped context map</h3>\n+ *\n+ * <p>Update the request-scoped context map using {@link #put(RequestContext, String, String)},\n+ * {@link #putAll(RequestContext, Map)}, {@link #remove(RequestContext, String)} and\n+ * {@link #clear(RequestContext)}:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * RequestScopedMdc.put(ctx, \"transactionId\", \"1234\");\n+ * RequestScopedMdc.putAll(ctx, Map.of(\"foo\", \"1\", \"bar\", \"2\"));\n+ * }</pre></p>\n+ *\n+ * <h3>Transferring thread-local properties</h3>\n+ *\n+ * <p>Use {@link #copy(RequestContext, String)} or {@link #copyAll(RequestContext)} to copy some or all of\n+ * thread-local {@link MDC} properties to the request-scoped context map:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * MDC.put(\"transactionId\", \"1234\");\n+ * RequestScopedMdc.copy(ctx, \"transactionId\");\n+ * }</pre></p>\n+ *\n+ * <h3>Retrieving a value from the request-scoped context map</h3>\n+ *\n+ * <p>You can explicitly retrieve request-scoped properties using {@link #get(RequestContext, String)} or\n+ * {@link #getAll(RequestContext)}:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * String transactionId = RequestScopedMdc.get(ctx, \"transactionId\");\n+ * }</pre></p>\n+ *\n+ * <p>{@link RequestScopedMdc} replaces SLF4J's underlying {@link MDCAdapter} implementation so that\n+ * {@link MDC#get(String)} and {@link MDC#getCopyOfContextMap()} look into the request-scoped context map\n+ * before the thread-local context map:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * RequestScopedMdc.put(ctx, \"transactionId\", \"1234\");\n+ * try (SafeCloseable ignored = ctx.push()) {\n+ *     assert MDC.get(\"transactionId\").equals(\"1234\");\n+ *\n+ *     // A request-scoped property always gets higher priority:\n+ *     MDC.put(\"transactionId\", \"5678\");\n+ *     assert MDC.get(\"transactionId\").equals(\"1234\");\n+ * }\n+ *\n+ * // Now using the thread-local property\n+ * // because not in a request scope anymore\n+ * assert MDC.get(\"transactionId\").equals(\"5678\");\n+ * }</pre></p>\n+ */\n+public final class RequestScopedMdc {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(RequestScopedMdc.class);\n+\n+    private static final AttributeKey<Map<String, String>> MAP =\n+            AttributeKey.valueOf(RequestScopedMdc.class, \"map\");\n+\n+    private static final String ERROR_MESSAGE =\n+            \"Failed to replace the \" + MDCAdapter.class.getSimpleName() + \"; \" +\n+            RequestScopedMdc.class.getSimpleName() + \" will not work.\";\n+\n+    @Nullable\n+    private static final MDCAdapter delegate;\n+\n+    static {\n+        // Trigger the initialization of the default MDC adapter.\n+        MDC.get(\"\");\n+\n+        // Replace the default MDC adapter with ours.\n+        MDCAdapter oldAdapter = null;\n+        try {\n+            final Field mdcAdapterField = MDC.class.getDeclaredField(\"mdcAdapter\");\n+            mdcAdapterField.setAccessible(true);\n+            oldAdapter = (MDCAdapter) mdcAdapterField.get(null);\n+            mdcAdapterField.set(null, new Adapter(oldAdapter));\n+        } catch (Throwable t) {\n+            logger.warn(ERROR_MESSAGE, t);\n+        }\n+        delegate = oldAdapter;\n+    }\n+\n+    /**\n+     * Returns the value of the specified request-scoped {@link MDC} property bound to the specified\n+     * {@link RequestContext}..\n+     *\n+     * @param ctx the {@link RequestContext}\n+     * @param key the key of the request-scoped {@link MDC} property\n+     *\n+     * @return the request-scoped {@link MDC} property. {@code null} if not found.\n+     */\n+    @Nullable\n+    public static String get(RequestContext ctx, String key) {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(key, \"key\");\n+        return getMap(ctx).get(key);\n+    }\n+\n+    /**\n+     * Returns the {@link Map} of all request-scoped {@link MDC} properties bound to the specified\n+     * {@link RequestContext}..\n+     *\n+     * @param ctx the {@link RequestContext}\n+     *\n+     * @return the {@link Map} that contains all request-scoped {@link MDC} properties.\n+     *         An empty {@link Map} if there are no request-scoped {@link MDC} properties.\n+     */\n+    public static Map<String, String> getAll(RequestContext ctx) {\n+        requireNonNull(ctx, \"ctx\");\n+        final Map<String, String> map = getMap(ctx);\n+        // Note: We ensure an empty map is always immutable.\n+        return map.isEmpty() ? map : Collections.unmodifiableMap(map);\n+    }\n+\n+    /**\n+     * Binds the specified request-scoped {@link MDC} property to the specified {@link RequestContext}.\n+     *\n+     * @param ctx   the {@link RequestContext}\n+     * @param key   the key of the request-scoped {@link MDC} property\n+     * @param value the value of the request-scoped {@link MDC} property\n+     */\n+    public static void put(RequestContext ctx, String key, @Nullable String value) {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(key, \"key\");\n+\n+        synchronized (ctx) {\n+            final Map<String, String> oldMap = getMap(ctx);\n+            final Map<String, String> newMap;\n+            if (oldMap.isEmpty()) {\n+                newMap = Collections.singletonMap(key, value);\n+            } else {\n+                newMap = new Object2ObjectOpenHashMap<>(oldMap.size() + 1);\n+                newMap.putAll(oldMap);\n+                newMap.put(key, value);\n+            }\n+            ctx.setAttr(MAP, newMap);\n+        }\n+    }\n+\n+    /**\n+     * Binds the specified request-scoped {@link MDC} properties to the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     * @param map the {@link Map} that contains the request-scoped {@link MDC} properties\n+     */\n+    public static void putAll(RequestContext ctx, Map<String, String> map) {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(map, \"map\");\n+        if (map.isEmpty()) {\n+            return;\n+        }\n+\n+        synchronized (ctx) {\n+            final Map<String, String> oldMap = getMap(ctx);\n+            final Map<String, String> newMap;\n+            if (oldMap.isEmpty()) {\n+                newMap = new Object2ObjectOpenHashMap<>(map);\n+            } else {\n+                newMap = new Object2ObjectOpenHashMap<>(oldMap.size() + map.size());\n+                newMap.putAll(oldMap);\n+                newMap.putAll(map);\n+            }\n+            ctx.setAttr(MAP, newMap);\n+        }\n+    }\n+\n+    /**\n+     * Copies the specified thread-local {@link MDC} property to the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     * @param key the key of the thread-local {@link MDC} property to copy\n+     */\n+    public static void copy(RequestContext ctx, String key) {\n+        checkState(delegate != null, ERROR_MESSAGE);\n+        put(ctx, key, delegate.get(key));\n+    }\n+\n+    /**\n+     * Copies all thread-local {@link MDC} properties to the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     */\n+    public static void copyAll(RequestContext ctx) {\n+        checkState(delegate != null, ERROR_MESSAGE);\n+        putAll(ctx, firstNonNull(delegate.getCopyOfContextMap(), Collections.emptyMap()));\n+    }\n+\n+    /**\n+     * Unbinds the specified request-scoped {@link MDC} property from the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     * @param key the key of the request-scoped {@link MDC} property to unbind\n+     */\n+    public static void remove(RequestContext ctx, String key) {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(key, \"key\");\n+\n+        synchronized (ctx) {\n+            final Map<String, String> oldMap = getMap(ctx);\n+            if (!oldMap.containsKey(key)) {\n+                return;\n+            }\n+\n+            final Map<String, String> newMap;\n+            if (oldMap.size() == 1) {\n+                newMap = Collections.emptyMap();\n+            } else {\n+                newMap = new Object2ObjectOpenHashMap<>(oldMap);\n+                newMap.remove(key);\n+            }\n+            ctx.setAttr(MAP, newMap);\n+        }\n+    }\n+\n+    /**\n+     * Unbinds all request-scoped {@link MDC} properties from the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     */\n+    public static void clear(RequestContext ctx) {\n+        requireNonNull(ctx, \"ctx\");\n+\n+        synchronized (ctx) {\n+            final Map<String, String> oldMap = getMap(ctx);\n+            if (!oldMap.isEmpty()) {\n+                ctx.setAttr(MAP, Collections.emptyMap());\n+            }\n+        }\n+    }\n+\n+    private static Map<String, String> getMap(RequestContext ctx) {\n+        final Map<String, String> map;\n+        if (ctx instanceof ClientRequestContext) {\n+            map = ((ClientRequestContext) ctx).ownAttr(MAP);\n+        } else {\n+            map = ctx.attr(MAP);\n+        }\n+        return firstNonNull(map, Collections.emptyMap());\n+    }\n+\n+    private RequestScopedMdc() {}\n+\n+    private static final class Adapter implements MDCAdapter {\n+\n+        private final MDCAdapter delegate;\n+\n+        Adapter(MDCAdapter delegate) {\n+            this.delegate = requireNonNull(delegate, \"delegate\");\n+        }\n+\n+        @Override\n+        @Nullable\n+        public String get(String key) {\n+            final RequestContext ctx = RequestContext.currentOrNull();\n+            if (ctx != null) {\n+                final String value = getMap(ctx).get(key);\n+                if (value != null) {\n+                    return value;\n+                }\n+            }\n+\n+            return delegate.get(key);\n+        }\n+\n+        @Override\n+        @Nullable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "647c0236a881cd2eae5b00ed584564b5a0e8a269"}, "originalPosition": 306}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTcyMjcwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestScopedMdc.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNjoxNjozMFrOGXRSnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNzoxNjoxNVrOGXS4ZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1MzcyNQ==", "bodyText": "Question: Is it intended to return the modifiable map?", "url": "https://github.com/line/armeria/pull/2724#discussion_r427053725", "createdAt": "2020-05-19T06:16:30Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestScopedMdc.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logging;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.lang.reflect.Field;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.slf4j.MDC;\n+import org.slf4j.spi.MDCAdapter;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.common.RequestContext;\n+\n+import io.netty.util.AttributeKey;\n+import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;\n+\n+/**\n+ * Provides the access to request-scoped {@link MDC} properties. All properties set via the access methods in\n+ * this class are bound to a {@link RequestContext}, unlike the traditional thread-local {@link MDC} properties.\n+ *\n+ * <h3>Updating the request-scoped context map</h3>\n+ *\n+ * <p>Update the request-scoped context map using {@link #put(RequestContext, String, String)},\n+ * {@link #putAll(RequestContext, Map)}, {@link #remove(RequestContext, String)} and\n+ * {@link #clear(RequestContext)}:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * RequestScopedMdc.put(ctx, \"transactionId\", \"1234\");\n+ * RequestScopedMdc.putAll(ctx, Map.of(\"foo\", \"1\", \"bar\", \"2\"));\n+ * }</pre></p>\n+ *\n+ * <h3>Transferring thread-local properties</h3>\n+ *\n+ * <p>Use {@link #copy(RequestContext, String)} or {@link #copyAll(RequestContext)} to copy some or all of\n+ * thread-local {@link MDC} properties to the request-scoped context map:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * MDC.put(\"transactionId\", \"1234\");\n+ * RequestScopedMdc.copy(ctx, \"transactionId\");\n+ * }</pre></p>\n+ *\n+ * <h3>Retrieving a value from the request-scoped context map</h3>\n+ *\n+ * <p>You can explicitly retrieve request-scoped properties using {@link #get(RequestContext, String)} or\n+ * {@link #getAll(RequestContext)}:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * String transactionId = RequestScopedMdc.get(ctx, \"transactionId\");\n+ * }</pre></p>\n+ *\n+ * <p>{@link RequestScopedMdc} replaces SLF4J's underlying {@link MDCAdapter} implementation so that\n+ * {@link MDC#get(String)} and {@link MDC#getCopyOfContextMap()} look into the request-scoped context map\n+ * before the thread-local context map:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * RequestScopedMdc.put(ctx, \"transactionId\", \"1234\");\n+ * try (SafeCloseable ignored = ctx.push()) {\n+ *     assert MDC.get(\"transactionId\").equals(\"1234\");\n+ *\n+ *     // A request-scoped property always gets higher priority:\n+ *     MDC.put(\"transactionId\", \"5678\");\n+ *     assert MDC.get(\"transactionId\").equals(\"1234\");\n+ * }\n+ *\n+ * // Now using the thread-local property\n+ * // because not in a request scope anymore\n+ * assert MDC.get(\"transactionId\").equals(\"5678\");\n+ * }</pre></p>\n+ */\n+public final class RequestScopedMdc {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(RequestScopedMdc.class);\n+\n+    private static final AttributeKey<Map<String, String>> MAP =\n+            AttributeKey.valueOf(RequestScopedMdc.class, \"map\");\n+\n+    private static final String ERROR_MESSAGE =\n+            \"Failed to replace the \" + MDCAdapter.class.getSimpleName() + \"; \" +\n+            RequestScopedMdc.class.getSimpleName() + \" will not work.\";\n+\n+    @Nullable\n+    private static final MDCAdapter delegate;\n+\n+    static {\n+        // Trigger the initialization of the default MDC adapter.\n+        MDC.get(\"\");\n+\n+        // Replace the default MDC adapter with ours.\n+        MDCAdapter oldAdapter = null;\n+        try {\n+            final Field mdcAdapterField = MDC.class.getDeclaredField(\"mdcAdapter\");\n+            mdcAdapterField.setAccessible(true);\n+            oldAdapter = (MDCAdapter) mdcAdapterField.get(null);\n+            mdcAdapterField.set(null, new Adapter(oldAdapter));\n+        } catch (Throwable t) {\n+            logger.warn(ERROR_MESSAGE, t);\n+        }\n+        delegate = oldAdapter;\n+    }\n+\n+    /**\n+     * Returns the value of the specified request-scoped {@link MDC} property bound to the specified\n+     * {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     * @param key the key of the request-scoped {@link MDC} property\n+     *\n+     * @return the request-scoped {@link MDC} property. {@code null} if not found.\n+     */\n+    @Nullable\n+    public static String get(RequestContext ctx, String key) {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(key, \"key\");\n+        return getMap(ctx).get(key);\n+    }\n+\n+    /**\n+     * Returns the {@link Map} of all request-scoped {@link MDC} properties bound to the specified\n+     * {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     *\n+     * @return the {@link Map} that contains all request-scoped {@link MDC} properties.\n+     *         An empty {@link Map} if there are no request-scoped {@link MDC} properties.\n+     */\n+    public static Map<String, String> getAll(RequestContext ctx) {\n+        requireNonNull(ctx, \"ctx\");\n+        return getMap(ctx);\n+    }\n+\n+    /**\n+     * Binds the specified request-scoped {@link MDC} property to the specified {@link RequestContext}.\n+     *\n+     * @param ctx   the {@link RequestContext}\n+     * @param key   the key of the request-scoped {@link MDC} property\n+     * @param value the value of the request-scoped {@link MDC} property\n+     */\n+    public static void put(RequestContext ctx, String key, @Nullable String value) {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(key, \"key\");\n+\n+        synchronized (ctx) {\n+            final Map<String, String> oldMap = getMap(ctx);\n+            final Map<String, String> newMap;\n+            if (oldMap.isEmpty()) {\n+                newMap = Collections.singletonMap(key, value);\n+            } else {\n+                final Object2ObjectOpenHashMap<String, String> tmp =\n+                        new Object2ObjectOpenHashMap<>(oldMap.size() + 1);\n+                tmp.putAll(oldMap);\n+                tmp.put(key, value);\n+                newMap = Collections.unmodifiableMap(tmp);\n+            }\n+            ctx.setAttr(MAP, newMap);\n+        }\n+    }\n+\n+    /**\n+     * Binds the specified request-scoped {@link MDC} properties to the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     * @param map the {@link Map} that contains the request-scoped {@link MDC} properties\n+     */\n+    public static void putAll(RequestContext ctx, Map<String, String> map) {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(map, \"map\");\n+        if (map.isEmpty()) {\n+            return;\n+        }\n+\n+        synchronized (ctx) {\n+            final Map<String, String> oldMap = getMap(ctx);\n+            final Map<String, String> newMap;\n+            if (oldMap.isEmpty()) {\n+                newMap = new Object2ObjectOpenHashMap<>(map);\n+            } else {\n+                newMap = new Object2ObjectOpenHashMap<>(oldMap.size() + map.size());\n+                newMap.putAll(oldMap);\n+                newMap.putAll(map);\n+            }\n+            ctx.setAttr(MAP, Collections.unmodifiableMap(newMap));\n+        }\n+    }\n+\n+    /**\n+     * Copies the specified thread-local {@link MDC} property to the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     * @param key the key of the thread-local {@link MDC} property to copy\n+     */\n+    public static void copy(RequestContext ctx, String key) {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(key, \"key\");\n+        checkState(delegate != null, ERROR_MESSAGE);\n+        put(ctx, key, delegate.get(key));\n+    }\n+\n+    /**\n+     * Copies all thread-local {@link MDC} properties to the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     */\n+    public static void copyAll(RequestContext ctx) {\n+        requireNonNull(ctx, \"ctx\");\n+        checkState(delegate != null, ERROR_MESSAGE);\n+\n+        final Map<String, String> map = delegate.getCopyOfContextMap();\n+        if (map == null || map.isEmpty()) {\n+            return;\n+        }\n+\n+        synchronized (ctx) {\n+            final Map<String, String> oldMap = getMap(ctx);\n+            final Map<String, String> newMap;\n+            if (oldMap.isEmpty()) {\n+                newMap = map;\n+            } else {\n+                newMap = new Object2ObjectOpenHashMap<>(oldMap.size() + map.size());\n+                newMap.putAll(oldMap);\n+                newMap.putAll(map);\n+            }\n+            ctx.setAttr(MAP, Collections.unmodifiableMap(newMap));\n+        }\n+    }\n+\n+    /**\n+     * Unbinds the specified request-scoped {@link MDC} property from the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     * @param key the key of the request-scoped {@link MDC} property to unbind\n+     */\n+    public static void remove(RequestContext ctx, String key) {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(key, \"key\");\n+\n+        synchronized (ctx) {\n+            final Map<String, String> oldMap = getMap(ctx);\n+            if (!oldMap.containsKey(key)) {\n+                return;\n+            }\n+\n+            final Map<String, String> newMap;\n+            if (oldMap.size() == 1) {\n+                newMap = Collections.emptyMap();\n+            } else {\n+                final Object2ObjectOpenHashMap<String, String> tmp = new Object2ObjectOpenHashMap<>(oldMap);\n+                tmp.remove(key);\n+                newMap = Collections.unmodifiableMap(tmp);\n+            }\n+            ctx.setAttr(MAP, newMap);\n+        }\n+    }\n+\n+    /**\n+     * Unbinds all request-scoped {@link MDC} properties from the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     */\n+    public static void clear(RequestContext ctx) {\n+        requireNonNull(ctx, \"ctx\");\n+\n+        synchronized (ctx) {\n+            final Map<String, String> oldMap = getMap(ctx);\n+            if (!oldMap.isEmpty()) {\n+                ctx.setAttr(MAP, Collections.emptyMap());\n+            }\n+        }\n+    }\n+\n+    private static Map<String, String> getMap(RequestContext ctx) {\n+        final Map<String, String> map;\n+        if (ctx instanceof ClientRequestContext) {\n+            map = ((ClientRequestContext) ctx).ownAttr(MAP);\n+        } else {\n+            map = ctx.attr(MAP);\n+        }\n+        return firstNonNull(map, Collections.emptyMap());\n+    }\n+\n+    private RequestScopedMdc() {}\n+\n+    private static final class Adapter implements MDCAdapter {\n+\n+        private final MDCAdapter delegate;\n+\n+        Adapter(MDCAdapter delegate) {\n+            this.delegate = requireNonNull(delegate, \"delegate\");\n+        }\n+\n+        @Override\n+        @Nullable\n+        public String get(String key) {\n+            final RequestContext ctx = RequestContext.currentOrNull();\n+            if (ctx != null) {\n+                final String value = getMap(ctx).get(key);\n+                if (value != null) {\n+                    return value;\n+                }\n+            }\n+\n+            return delegate.get(key);\n+        }\n+\n+        @Override\n+        public Map<String, String> getCopyOfContextMap() {\n+            final Map<String, String> threadLocalMap =\n+                    firstNonNull(delegate.getCopyOfContextMap(), Collections.emptyMap());\n+            final RequestContext ctx = RequestContext.currentOrNull();\n+            if (ctx == null) {\n+                // No context available\n+                return threadLocalMap;\n+            }\n+\n+            final Map<String, String> requestScopedMap =\n+                    firstNonNull(getMap(ctx), Collections.emptyMap());\n+            if (threadLocalMap.isEmpty()) {\n+                // No thread-local map available\n+                return requestScopedMap;\n+            }\n+\n+            // Thread-local map available\n+            if (requestScopedMap.isEmpty()) {\n+                // Only thread-local map available\n+                return threadLocalMap;\n+            }\n+\n+            // Both thread-local and request-scoped map available\n+            final Map<String, String> merged =\n+                    new Object2ObjectOpenHashMap<>(threadLocalMap.size() + requestScopedMap.size());\n+            merged.putAll(threadLocalMap);\n+            merged.putAll(requestScopedMap);\n+            return merged;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdc9e3689415b534ca60f1f8cfa4f20584d7ede0"}, "originalPosition": 354}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA2MDkyOA==", "bodyText": "The API documentation does not tell us whether we should return an unmodifiable map or not, so I took a cheaper path.", "url": "https://github.com/line/armeria/pull/2724#discussion_r427060928", "createdAt": "2020-05-19T06:34:54Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestScopedMdc.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logging;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.lang.reflect.Field;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.slf4j.MDC;\n+import org.slf4j.spi.MDCAdapter;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.common.RequestContext;\n+\n+import io.netty.util.AttributeKey;\n+import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;\n+\n+/**\n+ * Provides the access to request-scoped {@link MDC} properties. All properties set via the access methods in\n+ * this class are bound to a {@link RequestContext}, unlike the traditional thread-local {@link MDC} properties.\n+ *\n+ * <h3>Updating the request-scoped context map</h3>\n+ *\n+ * <p>Update the request-scoped context map using {@link #put(RequestContext, String, String)},\n+ * {@link #putAll(RequestContext, Map)}, {@link #remove(RequestContext, String)} and\n+ * {@link #clear(RequestContext)}:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * RequestScopedMdc.put(ctx, \"transactionId\", \"1234\");\n+ * RequestScopedMdc.putAll(ctx, Map.of(\"foo\", \"1\", \"bar\", \"2\"));\n+ * }</pre></p>\n+ *\n+ * <h3>Transferring thread-local properties</h3>\n+ *\n+ * <p>Use {@link #copy(RequestContext, String)} or {@link #copyAll(RequestContext)} to copy some or all of\n+ * thread-local {@link MDC} properties to the request-scoped context map:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * MDC.put(\"transactionId\", \"1234\");\n+ * RequestScopedMdc.copy(ctx, \"transactionId\");\n+ * }</pre></p>\n+ *\n+ * <h3>Retrieving a value from the request-scoped context map</h3>\n+ *\n+ * <p>You can explicitly retrieve request-scoped properties using {@link #get(RequestContext, String)} or\n+ * {@link #getAll(RequestContext)}:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * String transactionId = RequestScopedMdc.get(ctx, \"transactionId\");\n+ * }</pre></p>\n+ *\n+ * <p>{@link RequestScopedMdc} replaces SLF4J's underlying {@link MDCAdapter} implementation so that\n+ * {@link MDC#get(String)} and {@link MDC#getCopyOfContextMap()} look into the request-scoped context map\n+ * before the thread-local context map:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * RequestScopedMdc.put(ctx, \"transactionId\", \"1234\");\n+ * try (SafeCloseable ignored = ctx.push()) {\n+ *     assert MDC.get(\"transactionId\").equals(\"1234\");\n+ *\n+ *     // A request-scoped property always gets higher priority:\n+ *     MDC.put(\"transactionId\", \"5678\");\n+ *     assert MDC.get(\"transactionId\").equals(\"1234\");\n+ * }\n+ *\n+ * // Now using the thread-local property\n+ * // because not in a request scope anymore\n+ * assert MDC.get(\"transactionId\").equals(\"5678\");\n+ * }</pre></p>\n+ */\n+public final class RequestScopedMdc {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(RequestScopedMdc.class);\n+\n+    private static final AttributeKey<Map<String, String>> MAP =\n+            AttributeKey.valueOf(RequestScopedMdc.class, \"map\");\n+\n+    private static final String ERROR_MESSAGE =\n+            \"Failed to replace the \" + MDCAdapter.class.getSimpleName() + \"; \" +\n+            RequestScopedMdc.class.getSimpleName() + \" will not work.\";\n+\n+    @Nullable\n+    private static final MDCAdapter delegate;\n+\n+    static {\n+        // Trigger the initialization of the default MDC adapter.\n+        MDC.get(\"\");\n+\n+        // Replace the default MDC adapter with ours.\n+        MDCAdapter oldAdapter = null;\n+        try {\n+            final Field mdcAdapterField = MDC.class.getDeclaredField(\"mdcAdapter\");\n+            mdcAdapterField.setAccessible(true);\n+            oldAdapter = (MDCAdapter) mdcAdapterField.get(null);\n+            mdcAdapterField.set(null, new Adapter(oldAdapter));\n+        } catch (Throwable t) {\n+            logger.warn(ERROR_MESSAGE, t);\n+        }\n+        delegate = oldAdapter;\n+    }\n+\n+    /**\n+     * Returns the value of the specified request-scoped {@link MDC} property bound to the specified\n+     * {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     * @param key the key of the request-scoped {@link MDC} property\n+     *\n+     * @return the request-scoped {@link MDC} property. {@code null} if not found.\n+     */\n+    @Nullable\n+    public static String get(RequestContext ctx, String key) {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(key, \"key\");\n+        return getMap(ctx).get(key);\n+    }\n+\n+    /**\n+     * Returns the {@link Map} of all request-scoped {@link MDC} properties bound to the specified\n+     * {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     *\n+     * @return the {@link Map} that contains all request-scoped {@link MDC} properties.\n+     *         An empty {@link Map} if there are no request-scoped {@link MDC} properties.\n+     */\n+    public static Map<String, String> getAll(RequestContext ctx) {\n+        requireNonNull(ctx, \"ctx\");\n+        return getMap(ctx);\n+    }\n+\n+    /**\n+     * Binds the specified request-scoped {@link MDC} property to the specified {@link RequestContext}.\n+     *\n+     * @param ctx   the {@link RequestContext}\n+     * @param key   the key of the request-scoped {@link MDC} property\n+     * @param value the value of the request-scoped {@link MDC} property\n+     */\n+    public static void put(RequestContext ctx, String key, @Nullable String value) {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(key, \"key\");\n+\n+        synchronized (ctx) {\n+            final Map<String, String> oldMap = getMap(ctx);\n+            final Map<String, String> newMap;\n+            if (oldMap.isEmpty()) {\n+                newMap = Collections.singletonMap(key, value);\n+            } else {\n+                final Object2ObjectOpenHashMap<String, String> tmp =\n+                        new Object2ObjectOpenHashMap<>(oldMap.size() + 1);\n+                tmp.putAll(oldMap);\n+                tmp.put(key, value);\n+                newMap = Collections.unmodifiableMap(tmp);\n+            }\n+            ctx.setAttr(MAP, newMap);\n+        }\n+    }\n+\n+    /**\n+     * Binds the specified request-scoped {@link MDC} properties to the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     * @param map the {@link Map} that contains the request-scoped {@link MDC} properties\n+     */\n+    public static void putAll(RequestContext ctx, Map<String, String> map) {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(map, \"map\");\n+        if (map.isEmpty()) {\n+            return;\n+        }\n+\n+        synchronized (ctx) {\n+            final Map<String, String> oldMap = getMap(ctx);\n+            final Map<String, String> newMap;\n+            if (oldMap.isEmpty()) {\n+                newMap = new Object2ObjectOpenHashMap<>(map);\n+            } else {\n+                newMap = new Object2ObjectOpenHashMap<>(oldMap.size() + map.size());\n+                newMap.putAll(oldMap);\n+                newMap.putAll(map);\n+            }\n+            ctx.setAttr(MAP, Collections.unmodifiableMap(newMap));\n+        }\n+    }\n+\n+    /**\n+     * Copies the specified thread-local {@link MDC} property to the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     * @param key the key of the thread-local {@link MDC} property to copy\n+     */\n+    public static void copy(RequestContext ctx, String key) {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(key, \"key\");\n+        checkState(delegate != null, ERROR_MESSAGE);\n+        put(ctx, key, delegate.get(key));\n+    }\n+\n+    /**\n+     * Copies all thread-local {@link MDC} properties to the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     */\n+    public static void copyAll(RequestContext ctx) {\n+        requireNonNull(ctx, \"ctx\");\n+        checkState(delegate != null, ERROR_MESSAGE);\n+\n+        final Map<String, String> map = delegate.getCopyOfContextMap();\n+        if (map == null || map.isEmpty()) {\n+            return;\n+        }\n+\n+        synchronized (ctx) {\n+            final Map<String, String> oldMap = getMap(ctx);\n+            final Map<String, String> newMap;\n+            if (oldMap.isEmpty()) {\n+                newMap = map;\n+            } else {\n+                newMap = new Object2ObjectOpenHashMap<>(oldMap.size() + map.size());\n+                newMap.putAll(oldMap);\n+                newMap.putAll(map);\n+            }\n+            ctx.setAttr(MAP, Collections.unmodifiableMap(newMap));\n+        }\n+    }\n+\n+    /**\n+     * Unbinds the specified request-scoped {@link MDC} property from the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     * @param key the key of the request-scoped {@link MDC} property to unbind\n+     */\n+    public static void remove(RequestContext ctx, String key) {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(key, \"key\");\n+\n+        synchronized (ctx) {\n+            final Map<String, String> oldMap = getMap(ctx);\n+            if (!oldMap.containsKey(key)) {\n+                return;\n+            }\n+\n+            final Map<String, String> newMap;\n+            if (oldMap.size() == 1) {\n+                newMap = Collections.emptyMap();\n+            } else {\n+                final Object2ObjectOpenHashMap<String, String> tmp = new Object2ObjectOpenHashMap<>(oldMap);\n+                tmp.remove(key);\n+                newMap = Collections.unmodifiableMap(tmp);\n+            }\n+            ctx.setAttr(MAP, newMap);\n+        }\n+    }\n+\n+    /**\n+     * Unbinds all request-scoped {@link MDC} properties from the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     */\n+    public static void clear(RequestContext ctx) {\n+        requireNonNull(ctx, \"ctx\");\n+\n+        synchronized (ctx) {\n+            final Map<String, String> oldMap = getMap(ctx);\n+            if (!oldMap.isEmpty()) {\n+                ctx.setAttr(MAP, Collections.emptyMap());\n+            }\n+        }\n+    }\n+\n+    private static Map<String, String> getMap(RequestContext ctx) {\n+        final Map<String, String> map;\n+        if (ctx instanceof ClientRequestContext) {\n+            map = ((ClientRequestContext) ctx).ownAttr(MAP);\n+        } else {\n+            map = ctx.attr(MAP);\n+        }\n+        return firstNonNull(map, Collections.emptyMap());\n+    }\n+\n+    private RequestScopedMdc() {}\n+\n+    private static final class Adapter implements MDCAdapter {\n+\n+        private final MDCAdapter delegate;\n+\n+        Adapter(MDCAdapter delegate) {\n+            this.delegate = requireNonNull(delegate, \"delegate\");\n+        }\n+\n+        @Override\n+        @Nullable\n+        public String get(String key) {\n+            final RequestContext ctx = RequestContext.currentOrNull();\n+            if (ctx != null) {\n+                final String value = getMap(ctx).get(key);\n+                if (value != null) {\n+                    return value;\n+                }\n+            }\n+\n+            return delegate.get(key);\n+        }\n+\n+        @Override\n+        public Map<String, String> getCopyOfContextMap() {\n+            final Map<String, String> threadLocalMap =\n+                    firstNonNull(delegate.getCopyOfContextMap(), Collections.emptyMap());\n+            final RequestContext ctx = RequestContext.currentOrNull();\n+            if (ctx == null) {\n+                // No context available\n+                return threadLocalMap;\n+            }\n+\n+            final Map<String, String> requestScopedMap =\n+                    firstNonNull(getMap(ctx), Collections.emptyMap());\n+            if (threadLocalMap.isEmpty()) {\n+                // No thread-local map available\n+                return requestScopedMap;\n+            }\n+\n+            // Thread-local map available\n+            if (requestScopedMap.isEmpty()) {\n+                // Only thread-local map available\n+                return threadLocalMap;\n+            }\n+\n+            // Both thread-local and request-scoped map available\n+            final Map<String, String> merged =\n+                    new Object2ObjectOpenHashMap<>(threadLocalMap.size() + requestScopedMap.size());\n+            merged.putAll(threadLocalMap);\n+            merged.putAll(requestScopedMap);\n+            return merged;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1MzcyNQ=="}, "originalCommit": {"oid": "fdc9e3689415b534ca60f1f8cfa4f20584d7ede0"}, "originalPosition": 354}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA3OTc4MA==", "bodyText": "Yes, it seems so. Just wanted to make sure. \ud83d\ude09", "url": "https://github.com/line/armeria/pull/2724#discussion_r427079780", "createdAt": "2020-05-19T07:16:15Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestScopedMdc.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logging;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.lang.reflect.Field;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.slf4j.MDC;\n+import org.slf4j.spi.MDCAdapter;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.common.RequestContext;\n+\n+import io.netty.util.AttributeKey;\n+import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;\n+\n+/**\n+ * Provides the access to request-scoped {@link MDC} properties. All properties set via the access methods in\n+ * this class are bound to a {@link RequestContext}, unlike the traditional thread-local {@link MDC} properties.\n+ *\n+ * <h3>Updating the request-scoped context map</h3>\n+ *\n+ * <p>Update the request-scoped context map using {@link #put(RequestContext, String, String)},\n+ * {@link #putAll(RequestContext, Map)}, {@link #remove(RequestContext, String)} and\n+ * {@link #clear(RequestContext)}:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * RequestScopedMdc.put(ctx, \"transactionId\", \"1234\");\n+ * RequestScopedMdc.putAll(ctx, Map.of(\"foo\", \"1\", \"bar\", \"2\"));\n+ * }</pre></p>\n+ *\n+ * <h3>Transferring thread-local properties</h3>\n+ *\n+ * <p>Use {@link #copy(RequestContext, String)} or {@link #copyAll(RequestContext)} to copy some or all of\n+ * thread-local {@link MDC} properties to the request-scoped context map:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * MDC.put(\"transactionId\", \"1234\");\n+ * RequestScopedMdc.copy(ctx, \"transactionId\");\n+ * }</pre></p>\n+ *\n+ * <h3>Retrieving a value from the request-scoped context map</h3>\n+ *\n+ * <p>You can explicitly retrieve request-scoped properties using {@link #get(RequestContext, String)} or\n+ * {@link #getAll(RequestContext)}:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * String transactionId = RequestScopedMdc.get(ctx, \"transactionId\");\n+ * }</pre></p>\n+ *\n+ * <p>{@link RequestScopedMdc} replaces SLF4J's underlying {@link MDCAdapter} implementation so that\n+ * {@link MDC#get(String)} and {@link MDC#getCopyOfContextMap()} look into the request-scoped context map\n+ * before the thread-local context map:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * RequestScopedMdc.put(ctx, \"transactionId\", \"1234\");\n+ * try (SafeCloseable ignored = ctx.push()) {\n+ *     assert MDC.get(\"transactionId\").equals(\"1234\");\n+ *\n+ *     // A request-scoped property always gets higher priority:\n+ *     MDC.put(\"transactionId\", \"5678\");\n+ *     assert MDC.get(\"transactionId\").equals(\"1234\");\n+ * }\n+ *\n+ * // Now using the thread-local property\n+ * // because not in a request scope anymore\n+ * assert MDC.get(\"transactionId\").equals(\"5678\");\n+ * }</pre></p>\n+ */\n+public final class RequestScopedMdc {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(RequestScopedMdc.class);\n+\n+    private static final AttributeKey<Map<String, String>> MAP =\n+            AttributeKey.valueOf(RequestScopedMdc.class, \"map\");\n+\n+    private static final String ERROR_MESSAGE =\n+            \"Failed to replace the \" + MDCAdapter.class.getSimpleName() + \"; \" +\n+            RequestScopedMdc.class.getSimpleName() + \" will not work.\";\n+\n+    @Nullable\n+    private static final MDCAdapter delegate;\n+\n+    static {\n+        // Trigger the initialization of the default MDC adapter.\n+        MDC.get(\"\");\n+\n+        // Replace the default MDC adapter with ours.\n+        MDCAdapter oldAdapter = null;\n+        try {\n+            final Field mdcAdapterField = MDC.class.getDeclaredField(\"mdcAdapter\");\n+            mdcAdapterField.setAccessible(true);\n+            oldAdapter = (MDCAdapter) mdcAdapterField.get(null);\n+            mdcAdapterField.set(null, new Adapter(oldAdapter));\n+        } catch (Throwable t) {\n+            logger.warn(ERROR_MESSAGE, t);\n+        }\n+        delegate = oldAdapter;\n+    }\n+\n+    /**\n+     * Returns the value of the specified request-scoped {@link MDC} property bound to the specified\n+     * {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     * @param key the key of the request-scoped {@link MDC} property\n+     *\n+     * @return the request-scoped {@link MDC} property. {@code null} if not found.\n+     */\n+    @Nullable\n+    public static String get(RequestContext ctx, String key) {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(key, \"key\");\n+        return getMap(ctx).get(key);\n+    }\n+\n+    /**\n+     * Returns the {@link Map} of all request-scoped {@link MDC} properties bound to the specified\n+     * {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     *\n+     * @return the {@link Map} that contains all request-scoped {@link MDC} properties.\n+     *         An empty {@link Map} if there are no request-scoped {@link MDC} properties.\n+     */\n+    public static Map<String, String> getAll(RequestContext ctx) {\n+        requireNonNull(ctx, \"ctx\");\n+        return getMap(ctx);\n+    }\n+\n+    /**\n+     * Binds the specified request-scoped {@link MDC} property to the specified {@link RequestContext}.\n+     *\n+     * @param ctx   the {@link RequestContext}\n+     * @param key   the key of the request-scoped {@link MDC} property\n+     * @param value the value of the request-scoped {@link MDC} property\n+     */\n+    public static void put(RequestContext ctx, String key, @Nullable String value) {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(key, \"key\");\n+\n+        synchronized (ctx) {\n+            final Map<String, String> oldMap = getMap(ctx);\n+            final Map<String, String> newMap;\n+            if (oldMap.isEmpty()) {\n+                newMap = Collections.singletonMap(key, value);\n+            } else {\n+                final Object2ObjectOpenHashMap<String, String> tmp =\n+                        new Object2ObjectOpenHashMap<>(oldMap.size() + 1);\n+                tmp.putAll(oldMap);\n+                tmp.put(key, value);\n+                newMap = Collections.unmodifiableMap(tmp);\n+            }\n+            ctx.setAttr(MAP, newMap);\n+        }\n+    }\n+\n+    /**\n+     * Binds the specified request-scoped {@link MDC} properties to the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     * @param map the {@link Map} that contains the request-scoped {@link MDC} properties\n+     */\n+    public static void putAll(RequestContext ctx, Map<String, String> map) {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(map, \"map\");\n+        if (map.isEmpty()) {\n+            return;\n+        }\n+\n+        synchronized (ctx) {\n+            final Map<String, String> oldMap = getMap(ctx);\n+            final Map<String, String> newMap;\n+            if (oldMap.isEmpty()) {\n+                newMap = new Object2ObjectOpenHashMap<>(map);\n+            } else {\n+                newMap = new Object2ObjectOpenHashMap<>(oldMap.size() + map.size());\n+                newMap.putAll(oldMap);\n+                newMap.putAll(map);\n+            }\n+            ctx.setAttr(MAP, Collections.unmodifiableMap(newMap));\n+        }\n+    }\n+\n+    /**\n+     * Copies the specified thread-local {@link MDC} property to the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     * @param key the key of the thread-local {@link MDC} property to copy\n+     */\n+    public static void copy(RequestContext ctx, String key) {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(key, \"key\");\n+        checkState(delegate != null, ERROR_MESSAGE);\n+        put(ctx, key, delegate.get(key));\n+    }\n+\n+    /**\n+     * Copies all thread-local {@link MDC} properties to the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     */\n+    public static void copyAll(RequestContext ctx) {\n+        requireNonNull(ctx, \"ctx\");\n+        checkState(delegate != null, ERROR_MESSAGE);\n+\n+        final Map<String, String> map = delegate.getCopyOfContextMap();\n+        if (map == null || map.isEmpty()) {\n+            return;\n+        }\n+\n+        synchronized (ctx) {\n+            final Map<String, String> oldMap = getMap(ctx);\n+            final Map<String, String> newMap;\n+            if (oldMap.isEmpty()) {\n+                newMap = map;\n+            } else {\n+                newMap = new Object2ObjectOpenHashMap<>(oldMap.size() + map.size());\n+                newMap.putAll(oldMap);\n+                newMap.putAll(map);\n+            }\n+            ctx.setAttr(MAP, Collections.unmodifiableMap(newMap));\n+        }\n+    }\n+\n+    /**\n+     * Unbinds the specified request-scoped {@link MDC} property from the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     * @param key the key of the request-scoped {@link MDC} property to unbind\n+     */\n+    public static void remove(RequestContext ctx, String key) {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(key, \"key\");\n+\n+        synchronized (ctx) {\n+            final Map<String, String> oldMap = getMap(ctx);\n+            if (!oldMap.containsKey(key)) {\n+                return;\n+            }\n+\n+            final Map<String, String> newMap;\n+            if (oldMap.size() == 1) {\n+                newMap = Collections.emptyMap();\n+            } else {\n+                final Object2ObjectOpenHashMap<String, String> tmp = new Object2ObjectOpenHashMap<>(oldMap);\n+                tmp.remove(key);\n+                newMap = Collections.unmodifiableMap(tmp);\n+            }\n+            ctx.setAttr(MAP, newMap);\n+        }\n+    }\n+\n+    /**\n+     * Unbinds all request-scoped {@link MDC} properties from the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     */\n+    public static void clear(RequestContext ctx) {\n+        requireNonNull(ctx, \"ctx\");\n+\n+        synchronized (ctx) {\n+            final Map<String, String> oldMap = getMap(ctx);\n+            if (!oldMap.isEmpty()) {\n+                ctx.setAttr(MAP, Collections.emptyMap());\n+            }\n+        }\n+    }\n+\n+    private static Map<String, String> getMap(RequestContext ctx) {\n+        final Map<String, String> map;\n+        if (ctx instanceof ClientRequestContext) {\n+            map = ((ClientRequestContext) ctx).ownAttr(MAP);\n+        } else {\n+            map = ctx.attr(MAP);\n+        }\n+        return firstNonNull(map, Collections.emptyMap());\n+    }\n+\n+    private RequestScopedMdc() {}\n+\n+    private static final class Adapter implements MDCAdapter {\n+\n+        private final MDCAdapter delegate;\n+\n+        Adapter(MDCAdapter delegate) {\n+            this.delegate = requireNonNull(delegate, \"delegate\");\n+        }\n+\n+        @Override\n+        @Nullable\n+        public String get(String key) {\n+            final RequestContext ctx = RequestContext.currentOrNull();\n+            if (ctx != null) {\n+                final String value = getMap(ctx).get(key);\n+                if (value != null) {\n+                    return value;\n+                }\n+            }\n+\n+            return delegate.get(key);\n+        }\n+\n+        @Override\n+        public Map<String, String> getCopyOfContextMap() {\n+            final Map<String, String> threadLocalMap =\n+                    firstNonNull(delegate.getCopyOfContextMap(), Collections.emptyMap());\n+            final RequestContext ctx = RequestContext.currentOrNull();\n+            if (ctx == null) {\n+                // No context available\n+                return threadLocalMap;\n+            }\n+\n+            final Map<String, String> requestScopedMap =\n+                    firstNonNull(getMap(ctx), Collections.emptyMap());\n+            if (threadLocalMap.isEmpty()) {\n+                // No thread-local map available\n+                return requestScopedMap;\n+            }\n+\n+            // Thread-local map available\n+            if (requestScopedMap.isEmpty()) {\n+                // Only thread-local map available\n+                return threadLocalMap;\n+            }\n+\n+            // Both thread-local and request-scoped map available\n+            final Map<String, String> merged =\n+                    new Object2ObjectOpenHashMap<>(threadLocalMap.size() + requestScopedMap.size());\n+            merged.putAll(threadLocalMap);\n+            merged.putAll(requestScopedMap);\n+            return merged;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1MzcyNQ=="}, "originalCommit": {"oid": "fdc9e3689415b534ca60f1f8cfa4f20584d7ede0"}, "originalPosition": 354}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2633, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}