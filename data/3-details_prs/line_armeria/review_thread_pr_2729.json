{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIwMDcxMjYw", "number": 2729, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMjoyNToyNVrOD-CXeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMjozNjoxNVrOD-CeEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2Mzc3MDgwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestScopedMdc.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMjoyNToyNVrOGX5GXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMzo1NDoxNVrOGX6XTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcwNTk0OQ==", "bodyText": "Isn't it better to log (maybe once?) and return delegate.getCopyOfContextMap(); in this case?", "url": "https://github.com/line/armeria/pull/2729#discussion_r427705949", "createdAt": "2020-05-20T02:25:25Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestScopedMdc.java", "diffHunk": "@@ -224,24 +284,28 @@ public static void copy(RequestContext ctx, String key) {\n     public static void copyAll(RequestContext ctx) {\n         requireNonNull(ctx, \"ctx\");\n         checkState(delegate != null, ERROR_MESSAGE);\n-\n-        final Map<String, String> map = delegate.getCopyOfContextMap();\n-        if (map == null || map.isEmpty()) {\n-            return;\n+        final Map<String, String> map = getDelegateContextMap();\n+        if (map != null) {\n+            putAll(ctx, map);\n         }\n+    }\n \n-        synchronized (ctx) {\n-            final Map<String, String> oldMap = getMap(ctx);\n-            final Map<String, String> newMap;\n-            if (oldMap.isEmpty()) {\n-                newMap = map;\n-            } else {\n-                newMap = new Object2ObjectOpenHashMap<>(oldMap.size() + map.size());\n-                newMap.putAll(oldMap);\n-                newMap.putAll(map);\n+    @Nullable\n+    private static Map<String, String> getDelegateContextMap() {\n+        assert delegate != null;\n+        try {\n+            // Try to use `LogbackMDCAdapter.getPropertyMap()` which does not make a copy.\n+            @SuppressWarnings(\"unchecked\")\n+            final Map<String, String> map =\n+                    delegateGetPropertyMap != null ? (Map<String, String>) delegateGetPropertyMap.invokeExact()\n+                                                   : delegate.getCopyOfContextMap();\n+            if (map != null) {\n+                return map;\n             }\n-            ctx.setAttr(MAP, Collections.unmodifiableMap(newMap));\n+        } catch (Throwable t) {\n+            Exceptions.throwUnsafely(t);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a806d589b81132c88bea0bbe3e5f3b1d8da4a6b1"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcyNjY3MQ==", "bodyText": "We will never reach here, because we made sure invokeExact() works in the class initializer. If any exception is raised, it means it's a bug. Let me add some comment about this.", "url": "https://github.com/line/armeria/pull/2729#discussion_r427726671", "createdAt": "2020-05-20T03:54:15Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestScopedMdc.java", "diffHunk": "@@ -224,24 +284,28 @@ public static void copy(RequestContext ctx, String key) {\n     public static void copyAll(RequestContext ctx) {\n         requireNonNull(ctx, \"ctx\");\n         checkState(delegate != null, ERROR_MESSAGE);\n-\n-        final Map<String, String> map = delegate.getCopyOfContextMap();\n-        if (map == null || map.isEmpty()) {\n-            return;\n+        final Map<String, String> map = getDelegateContextMap();\n+        if (map != null) {\n+            putAll(ctx, map);\n         }\n+    }\n \n-        synchronized (ctx) {\n-            final Map<String, String> oldMap = getMap(ctx);\n-            final Map<String, String> newMap;\n-            if (oldMap.isEmpty()) {\n-                newMap = map;\n-            } else {\n-                newMap = new Object2ObjectOpenHashMap<>(oldMap.size() + map.size());\n-                newMap.putAll(oldMap);\n-                newMap.putAll(map);\n+    @Nullable\n+    private static Map<String, String> getDelegateContextMap() {\n+        assert delegate != null;\n+        try {\n+            // Try to use `LogbackMDCAdapter.getPropertyMap()` which does not make a copy.\n+            @SuppressWarnings(\"unchecked\")\n+            final Map<String, String> map =\n+                    delegateGetPropertyMap != null ? (Map<String, String>) delegateGetPropertyMap.invokeExact()\n+                                                   : delegate.getCopyOfContextMap();\n+            if (map != null) {\n+                return map;\n             }\n-            ctx.setAttr(MAP, Collections.unmodifiableMap(newMap));\n+        } catch (Throwable t) {\n+            Exceptions.throwUnsafely(t);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcwNTk0OQ=="}, "originalCommit": {"oid": "a806d589b81132c88bea0bbe3e5f3b1d8da4a6b1"}, "originalPosition": 208}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2Mzc3MTQ4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestScopedMdc.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMjoyNTo0NVrOGX5Gtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMjoyNTo0NVrOGX5Gtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcwNjAzOQ==", "bodyText": "We can just return map.", "url": "https://github.com/line/armeria/pull/2729#discussion_r427706039", "createdAt": "2020-05-20T02:25:45Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestScopedMdc.java", "diffHunk": "@@ -224,24 +284,28 @@ public static void copy(RequestContext ctx, String key) {\n     public static void copyAll(RequestContext ctx) {\n         requireNonNull(ctx, \"ctx\");\n         checkState(delegate != null, ERROR_MESSAGE);\n-\n-        final Map<String, String> map = delegate.getCopyOfContextMap();\n-        if (map == null || map.isEmpty()) {\n-            return;\n+        final Map<String, String> map = getDelegateContextMap();\n+        if (map != null) {\n+            putAll(ctx, map);\n         }\n+    }\n \n-        synchronized (ctx) {\n-            final Map<String, String> oldMap = getMap(ctx);\n-            final Map<String, String> newMap;\n-            if (oldMap.isEmpty()) {\n-                newMap = map;\n-            } else {\n-                newMap = new Object2ObjectOpenHashMap<>(oldMap.size() + map.size());\n-                newMap.putAll(oldMap);\n-                newMap.putAll(map);\n+    @Nullable\n+    private static Map<String, String> getDelegateContextMap() {\n+        assert delegate != null;\n+        try {\n+            // Try to use `LogbackMDCAdapter.getPropertyMap()` which does not make a copy.\n+            @SuppressWarnings(\"unchecked\")\n+            final Map<String, String> map =\n+                    delegateGetPropertyMap != null ? (Map<String, String>) delegateGetPropertyMap.invokeExact()\n+                                                   : delegate.getCopyOfContextMap();\n+            if (map != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a806d589b81132c88bea0bbe3e5f3b1d8da4a6b1"}, "originalPosition": 203}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2Mzc4NzY5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestScopedMdc.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMjozNjoxNVrOGX5RQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwNDowMTo0OFrOGX6eAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcwODczNw==", "bodyText": "Isn't this unmodifiable if the map is returned from here? https://github.com/line/armeria/pull/2729/files#diff-b35989b7cd6a82522044209c418a377dR193", "url": "https://github.com/line/armeria/pull/2729#discussion_r427708737", "createdAt": "2020-05-20T02:36:15Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestScopedMdc.java", "diffHunk": "@@ -319,35 +383,52 @@ public String get(String key) {\n \n         @Override\n         public Map<String, String> getCopyOfContextMap() {\n-            final Map<String, String> threadLocalMap =\n-                    firstNonNull(delegate.getCopyOfContextMap(), Collections.emptyMap());\n+            final Map<String, String> threadLocalMap = getDelegateContextMap();\n             final RequestContext ctx = RequestContext.currentOrNull();\n             if (ctx == null) {\n                 // No context available\n-                return threadLocalMap;\n+                if (threadLocalMap != null) {\n+                    return maybeCloneThreadLocalMap(threadLocalMap);\n+                } else {\n+                    return Object2ObjectMaps.emptyMap();\n+                }\n             }\n \n-            final Map<String, String> requestScopedMap =\n-                    firstNonNull(getMap(ctx), Collections.emptyMap());\n-            if (threadLocalMap.isEmpty()) {\n+            // Retrieve the request-scoped properties.\n+            // Note that this map is 1) unmodifiable and shared 2) or modifiable yet unshared,\n+            // which means it's OK to return as it is or mutate it.\n+            final Map<String, String> requestScopedMap = getAll(ctx);\n+            if (threadLocalMap == null || threadLocalMap.isEmpty()) {\n                 // No thread-local map available\n                 return requestScopedMap;\n             }\n \n             // Thread-local map available\n             if (requestScopedMap.isEmpty()) {\n                 // Only thread-local map available\n-                return threadLocalMap;\n+                return maybeCloneThreadLocalMap(threadLocalMap);\n             }\n \n             // Both thread-local and request-scoped map available\n-            final Map<String, String> merged =\n-                    new Object2ObjectOpenHashMap<>(threadLocalMap.size() + requestScopedMap.size());\n-            merged.putAll(threadLocalMap);\n-            merged.putAll(requestScopedMap);\n+            final Object2ObjectOpenHashMap<String, String> merged;\n+            if (requestScopedMap instanceof Object2ObjectOpenHashMap) {\n+                // Reuse the mutable copy returned by getAll() for less memory footprint.\n+                merged = (Object2ObjectOpenHashMap<String, String>) requestScopedMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a806d589b81132c88bea0bbe3e5f3b1d8da4a6b1"}, "originalPosition": 313}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcyNzQ5NQ==", "bodyText": "Yes. The map will not be an Object2ObjectOpenHashMap but be an Object2ObjectMaps.Unmodifiable or something. This code path is for the case where getAll() returns a mutable map, so we do not create two maps when merging twice.", "url": "https://github.com/line/armeria/pull/2729#discussion_r427727495", "createdAt": "2020-05-20T03:57:47Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestScopedMdc.java", "diffHunk": "@@ -319,35 +383,52 @@ public String get(String key) {\n \n         @Override\n         public Map<String, String> getCopyOfContextMap() {\n-            final Map<String, String> threadLocalMap =\n-                    firstNonNull(delegate.getCopyOfContextMap(), Collections.emptyMap());\n+            final Map<String, String> threadLocalMap = getDelegateContextMap();\n             final RequestContext ctx = RequestContext.currentOrNull();\n             if (ctx == null) {\n                 // No context available\n-                return threadLocalMap;\n+                if (threadLocalMap != null) {\n+                    return maybeCloneThreadLocalMap(threadLocalMap);\n+                } else {\n+                    return Object2ObjectMaps.emptyMap();\n+                }\n             }\n \n-            final Map<String, String> requestScopedMap =\n-                    firstNonNull(getMap(ctx), Collections.emptyMap());\n-            if (threadLocalMap.isEmpty()) {\n+            // Retrieve the request-scoped properties.\n+            // Note that this map is 1) unmodifiable and shared 2) or modifiable yet unshared,\n+            // which means it's OK to return as it is or mutate it.\n+            final Map<String, String> requestScopedMap = getAll(ctx);\n+            if (threadLocalMap == null || threadLocalMap.isEmpty()) {\n                 // No thread-local map available\n                 return requestScopedMap;\n             }\n \n             // Thread-local map available\n             if (requestScopedMap.isEmpty()) {\n                 // Only thread-local map available\n-                return threadLocalMap;\n+                return maybeCloneThreadLocalMap(threadLocalMap);\n             }\n \n             // Both thread-local and request-scoped map available\n-            final Map<String, String> merged =\n-                    new Object2ObjectOpenHashMap<>(threadLocalMap.size() + requestScopedMap.size());\n-            merged.putAll(threadLocalMap);\n-            merged.putAll(requestScopedMap);\n+            final Object2ObjectOpenHashMap<String, String> merged;\n+            if (requestScopedMap instanceof Object2ObjectOpenHashMap) {\n+                // Reuse the mutable copy returned by getAll() for less memory footprint.\n+                merged = (Object2ObjectOpenHashMap<String, String>) requestScopedMap;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcwODczNw=="}, "originalCommit": {"oid": "a806d589b81132c88bea0bbe3e5f3b1d8da4a6b1"}, "originalPosition": 313}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcyODM4Ng==", "bodyText": "Ah I thought the condition was requestScopedMap instanceof Object2ObjectMap. Sorry about it. \ud83d\ude09", "url": "https://github.com/line/armeria/pull/2729#discussion_r427728386", "createdAt": "2020-05-20T04:01:48Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestScopedMdc.java", "diffHunk": "@@ -319,35 +383,52 @@ public String get(String key) {\n \n         @Override\n         public Map<String, String> getCopyOfContextMap() {\n-            final Map<String, String> threadLocalMap =\n-                    firstNonNull(delegate.getCopyOfContextMap(), Collections.emptyMap());\n+            final Map<String, String> threadLocalMap = getDelegateContextMap();\n             final RequestContext ctx = RequestContext.currentOrNull();\n             if (ctx == null) {\n                 // No context available\n-                return threadLocalMap;\n+                if (threadLocalMap != null) {\n+                    return maybeCloneThreadLocalMap(threadLocalMap);\n+                } else {\n+                    return Object2ObjectMaps.emptyMap();\n+                }\n             }\n \n-            final Map<String, String> requestScopedMap =\n-                    firstNonNull(getMap(ctx), Collections.emptyMap());\n-            if (threadLocalMap.isEmpty()) {\n+            // Retrieve the request-scoped properties.\n+            // Note that this map is 1) unmodifiable and shared 2) or modifiable yet unshared,\n+            // which means it's OK to return as it is or mutate it.\n+            final Map<String, String> requestScopedMap = getAll(ctx);\n+            if (threadLocalMap == null || threadLocalMap.isEmpty()) {\n                 // No thread-local map available\n                 return requestScopedMap;\n             }\n \n             // Thread-local map available\n             if (requestScopedMap.isEmpty()) {\n                 // Only thread-local map available\n-                return threadLocalMap;\n+                return maybeCloneThreadLocalMap(threadLocalMap);\n             }\n \n             // Both thread-local and request-scoped map available\n-            final Map<String, String> merged =\n-                    new Object2ObjectOpenHashMap<>(threadLocalMap.size() + requestScopedMap.size());\n-            merged.putAll(threadLocalMap);\n-            merged.putAll(requestScopedMap);\n+            final Object2ObjectOpenHashMap<String, String> merged;\n+            if (requestScopedMap instanceof Object2ObjectOpenHashMap) {\n+                // Reuse the mutable copy returned by getAll() for less memory footprint.\n+                merged = (Object2ObjectOpenHashMap<String, String>) requestScopedMap;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcwODczNw=="}, "originalCommit": {"oid": "a806d589b81132c88bea0bbe3e5f3b1d8da4a6b1"}, "originalPosition": 313}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2641, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}