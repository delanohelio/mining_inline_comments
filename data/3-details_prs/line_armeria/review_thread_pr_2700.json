{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE2MTE2Mzk1", "number": 2700, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwNTo1Njo0OVrOD7gAzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwNzozOTo0NFrOD7hzXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNzE3MDcwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwNTo1Njo0OVrOGT3FXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwNjoxNDo0NVrOGT3dlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ3ODYyMg==", "bodyText": "Oops, I realized that we shouln't call timingsBuilder.pendingAcquisitionEnd(); if usePendingAcquisition(...) returns true.", "url": "https://github.com/line/armeria/pull/2700#discussion_r423478622", "createdAt": "2020-05-12T05:56:49Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -681,4 +642,102 @@ private void doRelease() {\n             }\n         }\n     }\n+\n+    /**\n+     * A variant of {@link CompletableFuture} that keeps its completion handlers into a separate list.\n+     * This yields better performance than {@link CompletableFuture#handle(BiFunction)} as the number of\n+     * added handlers increases because it does not create a long linked list with extra wrappers, which is\n+     * especially beneficial for Java 8 which suffers a huge performance hit when complementing a future with\n+     * a deep stack. See {@code cleanStack()} in Java 8 {@link CompletableFuture} for more information.\n+     */\n+    private final class ChannelAcquisitionFuture extends CompletableFuture<PooledChannel> {\n+\n+        @Nullable\n+        private List<Consumer<PooledChannel>> notifications;\n+\n+        void addChild(SessionProtocol desiredProtocol, PoolKey key,\n+                      ChannelAcquisitionFuture childPromise,\n+                      ClientConnectionTimingsBuilder timingsBuilder) {\n+\n+            // Add to the notification list if not complete yet.\n+            if (!isDone()) {\n+                if (notifications == null) {\n+                    notifications = new ArrayList<>();\n+                }\n+                notifications.add(pch -> notifyChild(desiredProtocol, key, childPromise, timingsBuilder, pch));\n+                return;\n+            }\n+\n+            // Invoke the notification task immediately if complete already.\n+            notifyChild(desiredProtocol, key, childPromise, timingsBuilder,\n+                        isCompletedExceptionally() ? null : getNow(null));\n+        }\n+\n+        private void notifyChild(SessionProtocol desiredProtocol, PoolKey key,\n+                                 ChannelAcquisitionFuture childPromise,\n+                                 ClientConnectionTimingsBuilder timingsBuilder,\n+                                 @Nullable PooledChannel pch) {\n+\n+            timingsBuilder.pendingAcquisitionEnd();\n+\n+            if (pch != null) {\n+                final SessionProtocol actualProtocol = pch.protocol();\n+                if (actualProtocol.isMultiplex()) {\n+                    final HttpSession session = HttpSession.get(pch.get());\n+                    if (session.incrementNumUnfinishedResponses()) {\n+                        childPromise.complete(pch);\n+                    } else if (!usePendingAcquisition(actualProtocol, key, childPromise, timingsBuilder)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "faf768bee452f578a1f629edb5e787a2ebf6b686"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ4NDgyMQ==", "bodyText": "Good point. Fixed but couldn't think of a good way to test this.", "url": "https://github.com/line/armeria/pull/2700#discussion_r423484821", "createdAt": "2020-05-12T06:14:45Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -681,4 +642,102 @@ private void doRelease() {\n             }\n         }\n     }\n+\n+    /**\n+     * A variant of {@link CompletableFuture} that keeps its completion handlers into a separate list.\n+     * This yields better performance than {@link CompletableFuture#handle(BiFunction)} as the number of\n+     * added handlers increases because it does not create a long linked list with extra wrappers, which is\n+     * especially beneficial for Java 8 which suffers a huge performance hit when complementing a future with\n+     * a deep stack. See {@code cleanStack()} in Java 8 {@link CompletableFuture} for more information.\n+     */\n+    private final class ChannelAcquisitionFuture extends CompletableFuture<PooledChannel> {\n+\n+        @Nullable\n+        private List<Consumer<PooledChannel>> notifications;\n+\n+        void addChild(SessionProtocol desiredProtocol, PoolKey key,\n+                      ChannelAcquisitionFuture childPromise,\n+                      ClientConnectionTimingsBuilder timingsBuilder) {\n+\n+            // Add to the notification list if not complete yet.\n+            if (!isDone()) {\n+                if (notifications == null) {\n+                    notifications = new ArrayList<>();\n+                }\n+                notifications.add(pch -> notifyChild(desiredProtocol, key, childPromise, timingsBuilder, pch));\n+                return;\n+            }\n+\n+            // Invoke the notification task immediately if complete already.\n+            notifyChild(desiredProtocol, key, childPromise, timingsBuilder,\n+                        isCompletedExceptionally() ? null : getNow(null));\n+        }\n+\n+        private void notifyChild(SessionProtocol desiredProtocol, PoolKey key,\n+                                 ChannelAcquisitionFuture childPromise,\n+                                 ClientConnectionTimingsBuilder timingsBuilder,\n+                                 @Nullable PooledChannel pch) {\n+\n+            timingsBuilder.pendingAcquisitionEnd();\n+\n+            if (pch != null) {\n+                final SessionProtocol actualProtocol = pch.protocol();\n+                if (actualProtocol.isMultiplex()) {\n+                    final HttpSession session = HttpSession.get(pch.get());\n+                    if (session.incrementNumUnfinishedResponses()) {\n+                        childPromise.complete(pch);\n+                    } else if (!usePendingAcquisition(actualProtocol, key, childPromise, timingsBuilder)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ3ODYyMg=="}, "originalCommit": {"oid": "faf768bee452f578a1f629edb5e787a2ebf6b686"}, "originalPosition": 212}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNzIxODc4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwNjoxNzo1OVrOGT3idQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwNjoxNzo1OVrOGT3idQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ4NjA2OQ==", "bodyText": "Think we can extract a helper for this and completeExceptionally code fragments", "url": "https://github.com/line/armeria/pull/2700#discussion_r423486069", "createdAt": "2020-05-12T06:17:59Z", "author": {"login": "anuraaga"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -681,4 +642,120 @@ private void doRelease() {\n             }\n         }\n     }\n+\n+    /**\n+     * A variant of {@link CompletableFuture} that keeps its completion handlers into a separate list.\n+     * This yields better performance than {@link CompletableFuture#handle(BiFunction)} as the number of\n+     * added handlers increases because it does not create a long linked list with extra wrappers, which is\n+     * especially beneficial for Java 8 which suffers a huge performance hit when complementing a future with\n+     * a deep stack. See {@code cleanStack()} in Java 8 {@link CompletableFuture} for more information.\n+     */\n+    private final class ChannelAcquisitionFuture extends CompletableFuture<PooledChannel> {\n+\n+        @Nullable\n+        private List<Consumer<PooledChannel>> notifications;\n+\n+        void addChild(SessionProtocol desiredProtocol, PoolKey key,\n+                      ChannelAcquisitionFuture childPromise,\n+                      ClientConnectionTimingsBuilder timingsBuilder) {\n+\n+            // Add to the notification list if not complete yet.\n+            if (!isDone()) {\n+                if (notifications == null) {\n+                    notifications = new ArrayList<>();\n+                }\n+                notifications.add(pch -> notifyChild(desiredProtocol, key, childPromise, timingsBuilder, pch));\n+                return;\n+            }\n+\n+            // Invoke the notification task immediately if complete already.\n+            notifyChild(desiredProtocol, key, childPromise, timingsBuilder,\n+                        isCompletedExceptionally() ? null : getNow(null));\n+        }\n+\n+        private void notifyChild(SessionProtocol desiredProtocol, PoolKey key,\n+                                 ChannelAcquisitionFuture childPromise,\n+                                 ClientConnectionTimingsBuilder timingsBuilder,\n+                                 @Nullable PooledChannel pch) {\n+\n+            // 1 - use the current pending acquisition.\n+            // 2 - create a new connection.\n+            // 3 - use another pending acquisition.\n+            final int result;\n+            if (pch != null) {\n+                final SessionProtocol actualProtocol = pch.protocol();\n+                if (actualProtocol.isMultiplex()) {\n+                    final HttpSession session = HttpSession.get(pch.get());\n+                    if (session.incrementNumUnfinishedResponses()) {\n+                        result = 1;\n+                    } else if (usePendingAcquisition(actualProtocol, key, childPromise, timingsBuilder)) {\n+                        result = 3;\n+                    } else {\n+                        result = 2;\n+                    }\n+                } else {\n+                    // Try to acquire again because the connection was not HTTP/2.\n+                    // We use the exact protocol (H1 or H1C) instead of 'desiredProtocol' so that\n+                    // we do not waste our time looking for pending acquisitions for the host\n+                    // that does not support HTTP/2.\n+                    final PooledChannel ch = acquireNow(actualProtocol, key);\n+                    if (ch != null) {\n+                        pch = ch;\n+                        result = 1;\n+                    } else {\n+                        result = 2;\n+                    }\n+                }\n+            } else {\n+                result = 2;\n+            }\n+\n+            switch (result) {\n+                case 1:\n+                    timingsBuilder.pendingAcquisitionEnd();\n+                    childPromise.complete(pch);\n+                    break;\n+                case 2:\n+                    timingsBuilder.pendingAcquisitionEnd();\n+                    connect(desiredProtocol, key, childPromise, timingsBuilder);\n+                    break;\n+                case 3:\n+                    // There's nothing to do because usePendingAcquisition() was called successfully above.\n+                    break;\n+            }\n+        }\n+\n+        @Override\n+        public boolean complete(PooledChannel value) {\n+            assert value != null;\n+            if (!super.complete(value)) {\n+                return false;\n+            }\n+\n+            final List<Consumer<PooledChannel>> notifications = this.notifications;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d38c5de050d39a9914b793b27f2dc84f3f05d95"}, "originalPosition": 258}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNzIyMDQ5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwNjoxODozOVrOGT3jeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwNzoxNTozMlrOGT5Imw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ4NjMyOQ==", "bodyText": "Can we define an enum for this for readability?", "url": "https://github.com/line/armeria/pull/2700#discussion_r423486329", "createdAt": "2020-05-12T06:18:39Z", "author": {"login": "anuraaga"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -681,4 +642,120 @@ private void doRelease() {\n             }\n         }\n     }\n+\n+    /**\n+     * A variant of {@link CompletableFuture} that keeps its completion handlers into a separate list.\n+     * This yields better performance than {@link CompletableFuture#handle(BiFunction)} as the number of\n+     * added handlers increases because it does not create a long linked list with extra wrappers, which is\n+     * especially beneficial for Java 8 which suffers a huge performance hit when complementing a future with\n+     * a deep stack. See {@code cleanStack()} in Java 8 {@link CompletableFuture} for more information.\n+     */\n+    private final class ChannelAcquisitionFuture extends CompletableFuture<PooledChannel> {\n+\n+        @Nullable\n+        private List<Consumer<PooledChannel>> notifications;\n+\n+        void addChild(SessionProtocol desiredProtocol, PoolKey key,\n+                      ChannelAcquisitionFuture childPromise,\n+                      ClientConnectionTimingsBuilder timingsBuilder) {\n+\n+            // Add to the notification list if not complete yet.\n+            if (!isDone()) {\n+                if (notifications == null) {\n+                    notifications = new ArrayList<>();\n+                }\n+                notifications.add(pch -> notifyChild(desiredProtocol, key, childPromise, timingsBuilder, pch));\n+                return;\n+            }\n+\n+            // Invoke the notification task immediately if complete already.\n+            notifyChild(desiredProtocol, key, childPromise, timingsBuilder,\n+                        isCompletedExceptionally() ? null : getNow(null));\n+        }\n+\n+        private void notifyChild(SessionProtocol desiredProtocol, PoolKey key,\n+                                 ChannelAcquisitionFuture childPromise,\n+                                 ClientConnectionTimingsBuilder timingsBuilder,\n+                                 @Nullable PooledChannel pch) {\n+\n+            // 1 - use the current pending acquisition.\n+            // 2 - create a new connection.\n+            // 3 - use another pending acquisition.\n+            final int result;\n+            if (pch != null) {\n+                final SessionProtocol actualProtocol = pch.protocol();\n+                if (actualProtocol.isMultiplex()) {\n+                    final HttpSession session = HttpSession.get(pch.get());\n+                    if (session.incrementNumUnfinishedResponses()) {\n+                        result = 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d38c5de050d39a9914b793b27f2dc84f3f05d95"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUxMjIxOQ==", "bodyText": "Done. \ud83d\udc4d", "url": "https://github.com/line/armeria/pull/2700#discussion_r423512219", "createdAt": "2020-05-12T07:15:32Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -681,4 +642,120 @@ private void doRelease() {\n             }\n         }\n     }\n+\n+    /**\n+     * A variant of {@link CompletableFuture} that keeps its completion handlers into a separate list.\n+     * This yields better performance than {@link CompletableFuture#handle(BiFunction)} as the number of\n+     * added handlers increases because it does not create a long linked list with extra wrappers, which is\n+     * especially beneficial for Java 8 which suffers a huge performance hit when complementing a future with\n+     * a deep stack. See {@code cleanStack()} in Java 8 {@link CompletableFuture} for more information.\n+     */\n+    private final class ChannelAcquisitionFuture extends CompletableFuture<PooledChannel> {\n+\n+        @Nullable\n+        private List<Consumer<PooledChannel>> notifications;\n+\n+        void addChild(SessionProtocol desiredProtocol, PoolKey key,\n+                      ChannelAcquisitionFuture childPromise,\n+                      ClientConnectionTimingsBuilder timingsBuilder) {\n+\n+            // Add to the notification list if not complete yet.\n+            if (!isDone()) {\n+                if (notifications == null) {\n+                    notifications = new ArrayList<>();\n+                }\n+                notifications.add(pch -> notifyChild(desiredProtocol, key, childPromise, timingsBuilder, pch));\n+                return;\n+            }\n+\n+            // Invoke the notification task immediately if complete already.\n+            notifyChild(desiredProtocol, key, childPromise, timingsBuilder,\n+                        isCompletedExceptionally() ? null : getNow(null));\n+        }\n+\n+        private void notifyChild(SessionProtocol desiredProtocol, PoolKey key,\n+                                 ChannelAcquisitionFuture childPromise,\n+                                 ClientConnectionTimingsBuilder timingsBuilder,\n+                                 @Nullable PooledChannel pch) {\n+\n+            // 1 - use the current pending acquisition.\n+            // 2 - create a new connection.\n+            // 3 - use another pending acquisition.\n+            final int result;\n+            if (pch != null) {\n+                final SessionProtocol actualProtocol = pch.protocol();\n+                if (actualProtocol.isMultiplex()) {\n+                    final HttpSession session = HttpSession.get(pch.get());\n+                    if (session.incrementNumUnfinishedResponses()) {\n+                        result = 1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ4NjMyOQ=="}, "originalCommit": {"oid": "0d38c5de050d39a9914b793b27f2dc84f3f05d95"}, "originalPosition": 213}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNzIyMjkyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwNjoxOTo0MlrOGT3k-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwNzozMjowM1rOGT5rag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ4NjcxNA==", "bodyText": "We could consider inlining a single notification since it seems like there will be two common cases, only one notification, or many notifications. But maybe premature", "url": "https://github.com/line/armeria/pull/2700#discussion_r423486714", "createdAt": "2020-05-12T06:19:42Z", "author": {"login": "anuraaga"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -681,4 +642,120 @@ private void doRelease() {\n             }\n         }\n     }\n+\n+    /**\n+     * A variant of {@link CompletableFuture} that keeps its completion handlers into a separate list.\n+     * This yields better performance than {@link CompletableFuture#handle(BiFunction)} as the number of\n+     * added handlers increases because it does not create a long linked list with extra wrappers, which is\n+     * especially beneficial for Java 8 which suffers a huge performance hit when complementing a future with\n+     * a deep stack. See {@code cleanStack()} in Java 8 {@link CompletableFuture} for more information.\n+     */\n+    private final class ChannelAcquisitionFuture extends CompletableFuture<PooledChannel> {\n+\n+        @Nullable\n+        private List<Consumer<PooledChannel>> notifications;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d38c5de050d39a9914b793b27f2dc84f3f05d95"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUyMTEzMA==", "bodyText": "Done. PTAL again \ud83d\ude04", "url": "https://github.com/line/armeria/pull/2700#discussion_r423521130", "createdAt": "2020-05-12T07:32:03Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -681,4 +642,120 @@ private void doRelease() {\n             }\n         }\n     }\n+\n+    /**\n+     * A variant of {@link CompletableFuture} that keeps its completion handlers into a separate list.\n+     * This yields better performance than {@link CompletableFuture#handle(BiFunction)} as the number of\n+     * added handlers increases because it does not create a long linked list with extra wrappers, which is\n+     * especially beneficial for Java 8 which suffers a huge performance hit when complementing a future with\n+     * a deep stack. See {@code cleanStack()} in Java 8 {@link CompletableFuture} for more information.\n+     */\n+    private final class ChannelAcquisitionFuture extends CompletableFuture<PooledChannel> {\n+\n+        @Nullable\n+        private List<Consumer<PooledChannel>> notifications;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ4NjcxNA=="}, "originalCommit": {"oid": "0d38c5de050d39a9914b793b27f2dc84f3f05d95"}, "originalPosition": 179}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNzQ2Mzk2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwNzozOTo0NFrOGT57uQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwNzozOTo0NFrOGT57uQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUyNTMwNQ==", "bodyText": "Sweet!", "url": "https://github.com/line/armeria/pull/2700#discussion_r423525305", "createdAt": "2020-05-12T07:39:44Z", "author": {"login": "anuraaga"}, "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -681,4 +642,175 @@ private void doRelease() {\n             }\n         }\n     }\n+\n+    /**\n+     * The result of piggybacked channel acquisition attempt.\n+     */\n+    private enum PiggybackedChannelAcquisitionResult {\n+        /**\n+         * Piggybacking succeeded. Use the channel from the current pending acquisition.\n+         */\n+        SUCCESS,\n+        /**\n+         * Piggybacking failed. Attempt to establish a new connection.\n+         */\n+        NEW_CONNECTION,\n+        /**\n+         * Piggybacking failed, but there's another pending acquisition.\n+         */\n+        PIGGYBACKED_AGAIN;\n+    }\n+\n+    /**\n+     * A variant of {@link CompletableFuture} that keeps its completion handlers into a separate list.\n+     * This yields better performance than {@link CompletableFuture#handle(BiFunction)} as the number of\n+     * added handlers increases because it does not create a long linked list with extra wrappers, which is\n+     * especially beneficial for Java 8 which suffers a huge performance hit when complementing a future with\n+     * a deep stack. See {@code cleanStack()} in Java 8 {@link CompletableFuture} for more information.\n+     */\n+    private final class ChannelAcquisitionFuture extends CompletableFuture<PooledChannel> {\n+\n+        /**\n+         * A {@code Consumer<PooledChannel>} if only 1 handler.\n+         * A {@code List<Consumer<PooledChannel>>} if there are 2+ handlers.\n+         */\n+        @Nullable\n+        private Object pendingPiggybackHandlers;\n+\n+        void piggyback(SessionProtocol desiredProtocol, PoolKey key,\n+                       ChannelAcquisitionFuture childPromise,\n+                       ClientConnectionTimingsBuilder timingsBuilder) {\n+\n+            // Add to the pending handler list if not complete yet.\n+            if (!isDone()) {\n+                final Consumer<PooledChannel> handler =\n+                        pch -> handlePiggyback(desiredProtocol, key, childPromise, timingsBuilder, pch);\n+\n+                if (pendingPiggybackHandlers == null) {\n+                    // The 1st handler\n+                    pendingPiggybackHandlers = handler;\n+                    return;\n+                }\n+\n+                if (!(pendingPiggybackHandlers instanceof List)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bf46483adc0ec59d454aa32412c676d06855ed1"}, "originalPosition": 218}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2589, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}