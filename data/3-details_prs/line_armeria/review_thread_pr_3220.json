{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM3OTE4Mjkx", "number": 3220, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMzowNTo1NFrOFE-P5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQwMzoyNzowNlrOFJbRww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNzU4NTAyOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/MethodChainingTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMzowNTo1NFrOIFPgCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxMDoxNzozN1rOIGDWew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM2Nzc1Mw==", "bodyText": "I am not sure if this is the right way \ud83d\ude05\nThese classes should not be changed like the class I raised as an issue.", "url": "https://github.com/line/armeria/pull/3220#discussion_r542367753", "createdAt": "2020-12-14T13:05:54Z", "author": {"login": "heowc"}, "path": "core/src/test/java/com/linecorp/armeria/MethodChainingTest.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria;\n+\n+import com.linecorp.armeria.internal.testing.AbstractMethodChainingTest;\n+\n+class MethodChainingTest extends AbstractMethodChainingTest {\n+\n+    MethodChainingTest() {\n+        super(\"com.linecorp.armeria.common.DefaultQueryParamsBuilder\",\n+              \"com.linecorp.armeria.common.DefaultRequestHeadersBuilder\",\n+              \"com.linecorp.armeria.common.DefaultHttpHeadersBuilder\",\n+              \"com.linecorp.armeria.common.DefaultResponseHeadersBuilder\",\n+              \"com.linecorp.armeria.client.ClientBuilder\",\n+              \"com.linecorp.armeria.server.file.HttpFileBuilder$FileSystemHttpFileBuilder\",\n+              \"com.linecorp.armeria.server.file.HttpFileBuilder$ClassPathHttpFileBuilder\",\n+              \"com.linecorp.armeria.server.file.HttpFileBuilder$NonExistentHttpFileBuilder\",\n+              \"com.linecorp.armeria.server.file.HttpFileBuilder$HttpDataFileBuilder\",\n+              \"com.linecorp.armeria.server.DomainMappingBuilder\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5688e8b3cf41f5d49785daf90a5990def924d9f"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA4NjEzNg==", "bodyText": "Maybe could we generalize the test algorithm a little bit so the tests pass even for these classes?", "url": "https://github.com/line/armeria/pull/3220#discussion_r543086136", "createdAt": "2020-12-15T06:43:56Z", "author": {"login": "trustin"}, "path": "core/src/test/java/com/linecorp/armeria/MethodChainingTest.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria;\n+\n+import com.linecorp.armeria.internal.testing.AbstractMethodChainingTest;\n+\n+class MethodChainingTest extends AbstractMethodChainingTest {\n+\n+    MethodChainingTest() {\n+        super(\"com.linecorp.armeria.common.DefaultQueryParamsBuilder\",\n+              \"com.linecorp.armeria.common.DefaultRequestHeadersBuilder\",\n+              \"com.linecorp.armeria.common.DefaultHttpHeadersBuilder\",\n+              \"com.linecorp.armeria.common.DefaultResponseHeadersBuilder\",\n+              \"com.linecorp.armeria.client.ClientBuilder\",\n+              \"com.linecorp.armeria.server.file.HttpFileBuilder$FileSystemHttpFileBuilder\",\n+              \"com.linecorp.armeria.server.file.HttpFileBuilder$ClassPathHttpFileBuilder\",\n+              \"com.linecorp.armeria.server.file.HttpFileBuilder$NonExistentHttpFileBuilder\",\n+              \"com.linecorp.armeria.server.file.HttpFileBuilder$HttpDataFileBuilder\",\n+              \"com.linecorp.armeria.server.DomainMappingBuilder\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM2Nzc1Mw=="}, "originalCommit": {"oid": "c5688e8b3cf41f5d49785daf90a5990def924d9f"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIxNzI3NQ==", "bodyText": "Hmm... From what I've been looking for, the difference is that the parent class has a build method.\nBut still not sure if this is correct \ud83d\ude05", "url": "https://github.com/line/armeria/pull/3220#discussion_r543217275", "createdAt": "2020-12-15T10:17:37Z", "author": {"login": "heowc"}, "path": "core/src/test/java/com/linecorp/armeria/MethodChainingTest.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria;\n+\n+import com.linecorp.armeria.internal.testing.AbstractMethodChainingTest;\n+\n+class MethodChainingTest extends AbstractMethodChainingTest {\n+\n+    MethodChainingTest() {\n+        super(\"com.linecorp.armeria.common.DefaultQueryParamsBuilder\",\n+              \"com.linecorp.armeria.common.DefaultRequestHeadersBuilder\",\n+              \"com.linecorp.armeria.common.DefaultHttpHeadersBuilder\",\n+              \"com.linecorp.armeria.common.DefaultResponseHeadersBuilder\",\n+              \"com.linecorp.armeria.client.ClientBuilder\",\n+              \"com.linecorp.armeria.server.file.HttpFileBuilder$FileSystemHttpFileBuilder\",\n+              \"com.linecorp.armeria.server.file.HttpFileBuilder$ClassPathHttpFileBuilder\",\n+              \"com.linecorp.armeria.server.file.HttpFileBuilder$NonExistentHttpFileBuilder\",\n+              \"com.linecorp.armeria.server.file.HttpFileBuilder$HttpDataFileBuilder\",\n+              \"com.linecorp.armeria.server.DomainMappingBuilder\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM2Nzc1Mw=="}, "originalCommit": {"oid": "c5688e8b3cf41f5d49785daf90a5990def924d9f"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNzYwNzU1OnYy", "diffSide": "RIGHT", "path": "testing-internal/src/main/java/com/linecorp/armeria/internal/testing/AbstractMethodChainingTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMzoxMDo1OFrOIFPs0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMzoxMDo1OFrOIFPs0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM3MTAyNQ==", "bodyText": "Exclude classes written from test code.\nExclude classes that are not suffixed with Builder.\nExclude classes to be ignored.", "url": "https://github.com/line/armeria/pull/3220#discussion_r542371025", "createdAt": "2020-12-14T13:10:58Z", "author": {"login": "heowc"}, "path": "testing-internal/src/main/java/com/linecorp/armeria/internal/testing/AbstractMethodChainingTest.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.testing;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.junit.jupiter.api.Test;\n+import org.reflections.ReflectionUtils;\n+import org.reflections.Reflections;\n+import org.reflections.scanners.SubTypesScanner;\n+import org.reflections.util.ClasspathHelper;\n+import org.reflections.util.ConfigurationBuilder;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+public abstract class AbstractMethodChainingTest {\n+\n+    private final List<String> ignoredClasses;\n+\n+    protected AbstractMethodChainingTest(String... ignoredClasses) {\n+        this.ignoredClasses = ImmutableList.copyOf(ignoredClasses);\n+    }\n+\n+    @Test\n+    void methodChaining() {\n+        final String packageName = getClass().getPackage().getName();\n+        findAllClasses(packageName).stream()\n+                                   .map(ReflectionUtils::forName)\n+                                   .filter(this::filterClass)\n+                                   .forEach(clazz -> {\n+                                       final List<Method> methods = getAllMethods(clazz);\n+                                       for (Method m : methods) {\n+                                           try {\n+                                               final Method overriddenMethod =\n+                                                       clazz.getDeclaredMethod(m.getName(),\n+                                                                               m.getParameterTypes());\n+                                               assertThat(overriddenMethod.getReturnType()).isSameAs(clazz);\n+                                           } catch (NoSuchMethodException e) {\n+                                               // ignored\n+                                           }\n+                                       }\n+                                   });\n+    }\n+\n+    private static Collection<String> findAllClasses(String packageName) {\n+        final Reflections reflections = new Reflections(\n+                new ConfigurationBuilder()\n+                        .setUrls(ClasspathHelper.forPackage(packageName))\n+                        .setScanners(new SubTypesScanner(false))\n+        );\n+        return reflections.getStore().get(\"SubTypesScanner\").values();\n+    }\n+\n+    private boolean filterClass(Class<?> clazz) {\n+        return declaredInTestClass(clazz) &&\n+               clazz.getName().endsWith(\"Builder\") &&\n+               !ignoredClasses.contains(clazz.getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5688e8b3cf41f5d49785daf90a5990def924d9f"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxODg4MDIwOnYy", "diffSide": "RIGHT", "path": "testing-internal/src/main/java/com/linecorp/armeria/internal/testing/AbstractMethodChainingTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwNzo0MTozOVrOIG32cA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwODoyNTo0NlrOIG5VLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA3NzQyNA==", "bodyText": "We don't need to call this method because we always check if the name ends with \"Builder\"?\n(the method check if the name of the class ends with \"Test\" which is exclusive)", "url": "https://github.com/line/armeria/pull/3220#discussion_r544077424", "createdAt": "2020-12-16T07:41:39Z", "author": {"login": "minwoox"}, "path": "testing-internal/src/main/java/com/linecorp/armeria/internal/testing/AbstractMethodChainingTest.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.testing;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.junit.jupiter.api.Test;\n+import org.reflections.ReflectionUtils;\n+import org.reflections.Reflections;\n+import org.reflections.adapters.JavaReflectionAdapter;\n+import org.reflections.scanners.SubTypesScanner;\n+import org.reflections.util.ClasspathHelper;\n+import org.reflections.util.ConfigurationBuilder;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+/**\n+ * Makes sure most builder overrides all overridden methods with the correct return type.\n+ */\n+public abstract class AbstractMethodChainingTest {\n+\n+    @Test\n+    void methodChaining() {\n+        final String packageName = getClass().getPackage().getName();\n+        findAllClasses(packageName).stream()\n+                                   .map(ReflectionUtils::forName)\n+                                   .filter(AbstractMethodChainingTest::filterClass)\n+                                   .forEach(clazz -> {\n+                                       final List<Method> methods = obtainMethods(clazz);\n+                                       for (Method m : methods) {\n+                                           try {\n+                                               final Method overriddenMethod =\n+                                                       clazz.getDeclaredMethod(m.getName(),\n+                                                                               m.getParameterTypes());\n+                                               assertThat(overriddenMethod.getReturnType()).isSameAs(clazz);\n+                                           } catch (NoSuchMethodException e) {\n+                                               // ignored\n+                                           }\n+                                       }\n+                                   });\n+    }\n+\n+    private static Collection<String> findAllClasses(String packageName) {\n+        final ConfigurationBuilder configuration = new ConfigurationBuilder()\n+                .setUrls(ClasspathHelper.forPackage(packageName))\n+                .setScanners(new SubTypesScanner())\n+                .setMetadataAdapter(new JavaReflectionAdapter());\n+        final Reflections reflections = new Reflections(configuration);\n+        return reflections.getStore().get(SubTypesScanner.class.getSimpleName()).values();\n+    }\n+\n+    private static boolean filterClass(Class<?> clazz) {\n+        return declaredInTestClass(clazz) &&", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83086b9bbccdde8742fb6120a59e539711b5c028"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEwMTY3OA==", "bodyText": "Removed", "url": "https://github.com/line/armeria/pull/3220#discussion_r544101678", "createdAt": "2020-12-16T08:25:46Z", "author": {"login": "heowc"}, "path": "testing-internal/src/main/java/com/linecorp/armeria/internal/testing/AbstractMethodChainingTest.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.testing;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.junit.jupiter.api.Test;\n+import org.reflections.ReflectionUtils;\n+import org.reflections.Reflections;\n+import org.reflections.adapters.JavaReflectionAdapter;\n+import org.reflections.scanners.SubTypesScanner;\n+import org.reflections.util.ClasspathHelper;\n+import org.reflections.util.ConfigurationBuilder;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+/**\n+ * Makes sure most builder overrides all overridden methods with the correct return type.\n+ */\n+public abstract class AbstractMethodChainingTest {\n+\n+    @Test\n+    void methodChaining() {\n+        final String packageName = getClass().getPackage().getName();\n+        findAllClasses(packageName).stream()\n+                                   .map(ReflectionUtils::forName)\n+                                   .filter(AbstractMethodChainingTest::filterClass)\n+                                   .forEach(clazz -> {\n+                                       final List<Method> methods = obtainMethods(clazz);\n+                                       for (Method m : methods) {\n+                                           try {\n+                                               final Method overriddenMethod =\n+                                                       clazz.getDeclaredMethod(m.getName(),\n+                                                                               m.getParameterTypes());\n+                                               assertThat(overriddenMethod.getReturnType()).isSameAs(clazz);\n+                                           } catch (NoSuchMethodException e) {\n+                                               // ignored\n+                                           }\n+                                       }\n+                                   });\n+    }\n+\n+    private static Collection<String> findAllClasses(String packageName) {\n+        final ConfigurationBuilder configuration = new ConfigurationBuilder()\n+                .setUrls(ClasspathHelper.forPackage(packageName))\n+                .setScanners(new SubTypesScanner())\n+                .setMetadataAdapter(new JavaReflectionAdapter());\n+        final Reflections reflections = new Reflections(configuration);\n+        return reflections.getStore().get(SubTypesScanner.class.getSimpleName()).values();\n+    }\n+\n+    private static boolean filterClass(Class<?> clazz) {\n+        return declaredInTestClass(clazz) &&", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA3NzQyNA=="}, "originalCommit": {"oid": "83086b9bbccdde8742fb6120a59e539711b5c028"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxODg4MTAxOnYy", "diffSide": "RIGHT", "path": "testing-internal/src/main/java/com/linecorp/armeria/internal/testing/AbstractMethodChainingTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwNzo0MTo0OFrOIG321g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwODoyNTo1NFrOIG5VhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA3NzUyNg==", "bodyText": "getSimpleName()?", "url": "https://github.com/line/armeria/pull/3220#discussion_r544077526", "createdAt": "2020-12-16T07:41:48Z", "author": {"login": "minwoox"}, "path": "testing-internal/src/main/java/com/linecorp/armeria/internal/testing/AbstractMethodChainingTest.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.testing;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.junit.jupiter.api.Test;\n+import org.reflections.ReflectionUtils;\n+import org.reflections.Reflections;\n+import org.reflections.adapters.JavaReflectionAdapter;\n+import org.reflections.scanners.SubTypesScanner;\n+import org.reflections.util.ClasspathHelper;\n+import org.reflections.util.ConfigurationBuilder;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+/**\n+ * Makes sure most builder overrides all overridden methods with the correct return type.\n+ */\n+public abstract class AbstractMethodChainingTest {\n+\n+    @Test\n+    void methodChaining() {\n+        final String packageName = getClass().getPackage().getName();\n+        findAllClasses(packageName).stream()\n+                                   .map(ReflectionUtils::forName)\n+                                   .filter(AbstractMethodChainingTest::filterClass)\n+                                   .forEach(clazz -> {\n+                                       final List<Method> methods = obtainMethods(clazz);\n+                                       for (Method m : methods) {\n+                                           try {\n+                                               final Method overriddenMethod =\n+                                                       clazz.getDeclaredMethod(m.getName(),\n+                                                                               m.getParameterTypes());\n+                                               assertThat(overriddenMethod.getReturnType()).isSameAs(clazz);\n+                                           } catch (NoSuchMethodException e) {\n+                                               // ignored\n+                                           }\n+                                       }\n+                                   });\n+    }\n+\n+    private static Collection<String> findAllClasses(String packageName) {\n+        final ConfigurationBuilder configuration = new ConfigurationBuilder()\n+                .setUrls(ClasspathHelper.forPackage(packageName))\n+                .setScanners(new SubTypesScanner())\n+                .setMetadataAdapter(new JavaReflectionAdapter());\n+        final Reflections reflections = new Reflections(configuration);\n+        return reflections.getStore().get(SubTypesScanner.class.getSimpleName()).values();\n+    }\n+\n+    private static boolean filterClass(Class<?> clazz) {\n+        return declaredInTestClass(clazz) &&\n+               clazz.getName().endsWith(\"Builder\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83086b9bbccdde8742fb6120a59e539711b5c028"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEwMTc2NQ==", "bodyText": "Fixed", "url": "https://github.com/line/armeria/pull/3220#discussion_r544101765", "createdAt": "2020-12-16T08:25:54Z", "author": {"login": "heowc"}, "path": "testing-internal/src/main/java/com/linecorp/armeria/internal/testing/AbstractMethodChainingTest.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.testing;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.junit.jupiter.api.Test;\n+import org.reflections.ReflectionUtils;\n+import org.reflections.Reflections;\n+import org.reflections.adapters.JavaReflectionAdapter;\n+import org.reflections.scanners.SubTypesScanner;\n+import org.reflections.util.ClasspathHelper;\n+import org.reflections.util.ConfigurationBuilder;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+/**\n+ * Makes sure most builder overrides all overridden methods with the correct return type.\n+ */\n+public abstract class AbstractMethodChainingTest {\n+\n+    @Test\n+    void methodChaining() {\n+        final String packageName = getClass().getPackage().getName();\n+        findAllClasses(packageName).stream()\n+                                   .map(ReflectionUtils::forName)\n+                                   .filter(AbstractMethodChainingTest::filterClass)\n+                                   .forEach(clazz -> {\n+                                       final List<Method> methods = obtainMethods(clazz);\n+                                       for (Method m : methods) {\n+                                           try {\n+                                               final Method overriddenMethod =\n+                                                       clazz.getDeclaredMethod(m.getName(),\n+                                                                               m.getParameterTypes());\n+                                               assertThat(overriddenMethod.getReturnType()).isSameAs(clazz);\n+                                           } catch (NoSuchMethodException e) {\n+                                               // ignored\n+                                           }\n+                                       }\n+                                   });\n+    }\n+\n+    private static Collection<String> findAllClasses(String packageName) {\n+        final ConfigurationBuilder configuration = new ConfigurationBuilder()\n+                .setUrls(ClasspathHelper.forPackage(packageName))\n+                .setScanners(new SubTypesScanner())\n+                .setMetadataAdapter(new JavaReflectionAdapter());\n+        final Reflections reflections = new Reflections(configuration);\n+        return reflections.getStore().get(SubTypesScanner.class.getSimpleName()).values();\n+    }\n+\n+    private static boolean filterClass(Class<?> clazz) {\n+        return declaredInTestClass(clazz) &&\n+               clazz.getName().endsWith(\"Builder\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA3NzUyNg=="}, "originalCommit": {"oid": "83086b9bbccdde8742fb6120a59e539711b5c028"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxODkwNTEyOnYy", "diffSide": "RIGHT", "path": "testing-internal/src/main/java/com/linecorp/armeria/internal/testing/AbstractMethodChainingTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwNzo0ODo1NVrOIG4EmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwODoyNjowMVrOIG5V4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA4MTA0OA==", "bodyText": "How about adding\n.filterInputsBy(filePath -> filePath != null && filePath.endsWith(\".class\"))\nso this does not run on a different file? (e.g. pavicon.png)", "url": "https://github.com/line/armeria/pull/3220#discussion_r544081048", "createdAt": "2020-12-16T07:48:55Z", "author": {"login": "minwoox"}, "path": "testing-internal/src/main/java/com/linecorp/armeria/internal/testing/AbstractMethodChainingTest.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.testing;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.junit.jupiter.api.Test;\n+import org.reflections.ReflectionUtils;\n+import org.reflections.Reflections;\n+import org.reflections.adapters.JavaReflectionAdapter;\n+import org.reflections.scanners.SubTypesScanner;\n+import org.reflections.util.ClasspathHelper;\n+import org.reflections.util.ConfigurationBuilder;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+/**\n+ * Makes sure most builder overrides all overridden methods with the correct return type.\n+ */\n+public abstract class AbstractMethodChainingTest {\n+\n+    @Test\n+    void methodChaining() {\n+        final String packageName = getClass().getPackage().getName();\n+        findAllClasses(packageName).stream()\n+                                   .map(ReflectionUtils::forName)\n+                                   .filter(AbstractMethodChainingTest::filterClass)\n+                                   .forEach(clazz -> {\n+                                       final List<Method> methods = obtainMethods(clazz);\n+                                       for (Method m : methods) {\n+                                           try {\n+                                               final Method overriddenMethod =\n+                                                       clazz.getDeclaredMethod(m.getName(),\n+                                                                               m.getParameterTypes());\n+                                               assertThat(overriddenMethod.getReturnType()).isSameAs(clazz);\n+                                           } catch (NoSuchMethodException e) {\n+                                               // ignored\n+                                           }\n+                                       }\n+                                   });\n+    }\n+\n+    private static Collection<String> findAllClasses(String packageName) {\n+        final ConfigurationBuilder configuration = new ConfigurationBuilder()\n+                .setUrls(ClasspathHelper.forPackage(packageName))\n+                .setScanners(new SubTypesScanner())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83086b9bbccdde8742fb6120a59e539711b5c028"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEwMTg1Nw==", "bodyText": "Fixed", "url": "https://github.com/line/armeria/pull/3220#discussion_r544101857", "createdAt": "2020-12-16T08:26:01Z", "author": {"login": "heowc"}, "path": "testing-internal/src/main/java/com/linecorp/armeria/internal/testing/AbstractMethodChainingTest.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.testing;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.junit.jupiter.api.Test;\n+import org.reflections.ReflectionUtils;\n+import org.reflections.Reflections;\n+import org.reflections.adapters.JavaReflectionAdapter;\n+import org.reflections.scanners.SubTypesScanner;\n+import org.reflections.util.ClasspathHelper;\n+import org.reflections.util.ConfigurationBuilder;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+/**\n+ * Makes sure most builder overrides all overridden methods with the correct return type.\n+ */\n+public abstract class AbstractMethodChainingTest {\n+\n+    @Test\n+    void methodChaining() {\n+        final String packageName = getClass().getPackage().getName();\n+        findAllClasses(packageName).stream()\n+                                   .map(ReflectionUtils::forName)\n+                                   .filter(AbstractMethodChainingTest::filterClass)\n+                                   .forEach(clazz -> {\n+                                       final List<Method> methods = obtainMethods(clazz);\n+                                       for (Method m : methods) {\n+                                           try {\n+                                               final Method overriddenMethod =\n+                                                       clazz.getDeclaredMethod(m.getName(),\n+                                                                               m.getParameterTypes());\n+                                               assertThat(overriddenMethod.getReturnType()).isSameAs(clazz);\n+                                           } catch (NoSuchMethodException e) {\n+                                               // ignored\n+                                           }\n+                                       }\n+                                   });\n+    }\n+\n+    private static Collection<String> findAllClasses(String packageName) {\n+        final ConfigurationBuilder configuration = new ConfigurationBuilder()\n+                .setUrls(ClasspathHelper.forPackage(packageName))\n+                .setScanners(new SubTypesScanner())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA4MTA0OA=="}, "originalCommit": {"oid": "83086b9bbccdde8742fb6120a59e539711b5c028"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxODkwNzA1OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/linecorp/armeria/MethodChainingTest.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwNzo0OToyN1rOIG4Fsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwOTowOToyNFrOIG7Ctw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA4MTMzMQ==", "bodyText": "Shouldn't we put this class to all modules?", "url": "https://github.com/line/armeria/pull/3220#discussion_r544081331", "createdAt": "2020-12-16T07:49:27Z", "author": {"login": "minwoox"}, "path": "core/src/test/java/com/linecorp/armeria/MethodChainingTest.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria;\n+\n+import com.linecorp.armeria.internal.testing.AbstractMethodChainingTest;\n+\n+class MethodChainingTest extends AbstractMethodChainingTest {}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83086b9bbccdde8742fb6120a59e539711b5c028"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEwMzMwNA==", "bodyText": "If the abstract class was okay, I tried to write more. \ud83d\ude09", "url": "https://github.com/line/armeria/pull/3220#discussion_r544103304", "createdAt": "2020-12-16T08:28:21Z", "author": {"login": "heowc"}, "path": "core/src/test/java/com/linecorp/armeria/MethodChainingTest.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria;\n+\n+import com.linecorp.armeria.internal.testing.AbstractMethodChainingTest;\n+\n+class MethodChainingTest extends AbstractMethodChainingTest {}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA4MTMzMQ=="}, "originalCommit": {"oid": "83086b9bbccdde8742fb6120a59e539711b5c028"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEwNDgyMg==", "bodyText": "I think it's okay. \ud83d\ude04", "url": "https://github.com/line/armeria/pull/3220#discussion_r544104822", "createdAt": "2020-12-16T08:30:51Z", "author": {"login": "minwoox"}, "path": "core/src/test/java/com/linecorp/armeria/MethodChainingTest.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria;\n+\n+import com.linecorp.armeria.internal.testing.AbstractMethodChainingTest;\n+\n+class MethodChainingTest extends AbstractMethodChainingTest {}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA4MTMzMQ=="}, "originalCommit": {"oid": "83086b9bbccdde8742fb6120a59e539711b5c028"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEyOTcxOQ==", "bodyText": "Thank you for the review. \ud83d\ude04\nI added test code to each module.", "url": "https://github.com/line/armeria/pull/3220#discussion_r544129719", "createdAt": "2020-12-16T09:09:24Z", "author": {"login": "heowc"}, "path": "core/src/test/java/com/linecorp/armeria/MethodChainingTest.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria;\n+\n+import com.linecorp.armeria.internal.testing.AbstractMethodChainingTest;\n+\n+class MethodChainingTest extends AbstractMethodChainingTest {}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA4MTMzMQ=="}, "originalCommit": {"oid": "83086b9bbccdde8742fb6120a59e539711b5c028"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyOTk3MTQ0OnYy", "diffSide": "RIGHT", "path": "testing-internal/src/main/java/com/linecorp/armeria/internal/testing/AbstractMethodChainingTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQwOTozNDo0OFrOIIbl0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwMzoxMzo0MlrOII4Vow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTcxMTU2OQ==", "bodyText": "OverridenBuilderMethodsRetureTypeTest?", "url": "https://github.com/line/armeria/pull/3220#discussion_r545711569", "createdAt": "2020-12-18T09:34:48Z", "author": {"login": "minwoox"}, "path": "testing-internal/src/main/java/com/linecorp/armeria/internal/testing/AbstractMethodChainingTest.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.testing;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.junit.jupiter.api.Test;\n+import org.reflections.ReflectionUtils;\n+import org.reflections.Reflections;\n+import org.reflections.adapters.JavaReflectionAdapter;\n+import org.reflections.scanners.SubTypesScanner;\n+import org.reflections.util.ClasspathHelper;\n+import org.reflections.util.ConfigurationBuilder;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+/**\n+ * Makes sure most builder overrides all overridden methods with the correct return type.\n+ */\n+public abstract class AbstractMethodChainingTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbfb44fc77681307b493e766cd99b0aa6d15d28b"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE4MjU2Mw==", "bodyText": "Fixed", "url": "https://github.com/line/armeria/pull/3220#discussion_r546182563", "createdAt": "2020-12-19T03:13:42Z", "author": {"login": "heowc"}, "path": "testing-internal/src/main/java/com/linecorp/armeria/internal/testing/AbstractMethodChainingTest.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.testing;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.junit.jupiter.api.Test;\n+import org.reflections.ReflectionUtils;\n+import org.reflections.Reflections;\n+import org.reflections.adapters.JavaReflectionAdapter;\n+import org.reflections.scanners.SubTypesScanner;\n+import org.reflections.util.ClasspathHelper;\n+import org.reflections.util.ConfigurationBuilder;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+/**\n+ * Makes sure most builder overrides all overridden methods with the correct return type.\n+ */\n+public abstract class AbstractMethodChainingTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTcxMTU2OQ=="}, "originalCommit": {"oid": "fbfb44fc77681307b493e766cd99b0aa6d15d28b"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyOTk4ODI0OnYy", "diffSide": "RIGHT", "path": "testing-internal/src/main/java/com/linecorp/armeria/internal/testing/AbstractMethodChainingTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQwOTozOToxNFrOIIbviA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwMzowNjoxMlrOII4S_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTcxNDA1Ng==", "bodyText": "Shouldn't we fail in this case? \ud83e\udd14", "url": "https://github.com/line/armeria/pull/3220#discussion_r545714056", "createdAt": "2020-12-18T09:39:14Z", "author": {"login": "minwoox"}, "path": "testing-internal/src/main/java/com/linecorp/armeria/internal/testing/AbstractMethodChainingTest.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.testing;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.junit.jupiter.api.Test;\n+import org.reflections.ReflectionUtils;\n+import org.reflections.Reflections;\n+import org.reflections.adapters.JavaReflectionAdapter;\n+import org.reflections.scanners.SubTypesScanner;\n+import org.reflections.util.ClasspathHelper;\n+import org.reflections.util.ConfigurationBuilder;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+/**\n+ * Makes sure most builder overrides all overridden methods with the correct return type.\n+ */\n+public abstract class AbstractMethodChainingTest {\n+\n+    @Test\n+    void methodChaining() {\n+        final String packageName = getClass().getPackage().getName();\n+        findAllClasses(packageName).stream()\n+                                   .map(ReflectionUtils::forName)\n+                                   .filter(clazz -> clazz.getSimpleName().endsWith(\"Builder\"))\n+                                   .forEach(clazz -> {\n+                                       final List<Method> methods = obtainMethods(clazz);\n+                                       for (Method m : methods) {\n+                                           try {\n+                                               final Method overriddenMethod =\n+                                                       clazz.getDeclaredMethod(m.getName(),\n+                                                                               m.getParameterTypes());\n+                                               assertThat(overriddenMethod.getReturnType()).isSameAs(clazz);\n+                                           } catch (NoSuchMethodException e) {\n+                                               // ignored", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbfb44fc77681307b493e766cd99b0aa6d15d28b"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE4MTg4NA==", "bodyText": "I think we can ignore this because we get the method through the parent class.", "url": "https://github.com/line/armeria/pull/3220#discussion_r546181884", "createdAt": "2020-12-19T03:06:12Z", "author": {"login": "heowc"}, "path": "testing-internal/src/main/java/com/linecorp/armeria/internal/testing/AbstractMethodChainingTest.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.testing;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.junit.jupiter.api.Test;\n+import org.reflections.ReflectionUtils;\n+import org.reflections.Reflections;\n+import org.reflections.adapters.JavaReflectionAdapter;\n+import org.reflections.scanners.SubTypesScanner;\n+import org.reflections.util.ClasspathHelper;\n+import org.reflections.util.ConfigurationBuilder;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+/**\n+ * Makes sure most builder overrides all overridden methods with the correct return type.\n+ */\n+public abstract class AbstractMethodChainingTest {\n+\n+    @Test\n+    void methodChaining() {\n+        final String packageName = getClass().getPackage().getName();\n+        findAllClasses(packageName).stream()\n+                                   .map(ReflectionUtils::forName)\n+                                   .filter(clazz -> clazz.getSimpleName().endsWith(\"Builder\"))\n+                                   .forEach(clazz -> {\n+                                       final List<Method> methods = obtainMethods(clazz);\n+                                       for (Method m : methods) {\n+                                           try {\n+                                               final Method overriddenMethod =\n+                                                       clazz.getDeclaredMethod(m.getName(),\n+                                                                               m.getParameterTypes());\n+                                               assertThat(overriddenMethod.getReturnType()).isSameAs(clazz);\n+                                           } catch (NoSuchMethodException e) {\n+                                               // ignored", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTcxNDA1Ng=="}, "originalCommit": {"oid": "fbfb44fc77681307b493e766cd99b0aa6d15d28b"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyOTk5MDM0OnYy", "diffSide": "RIGHT", "path": "testing-internal/src/main/java/com/linecorp/armeria/internal/testing/AbstractMethodChainingTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQwOTozOTo0NVrOIIbwtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwMzoxMzo0OVrOII4Vvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTcxNDM1OA==", "bodyText": "overriddenMethods?", "url": "https://github.com/line/armeria/pull/3220#discussion_r545714358", "createdAt": "2020-12-18T09:39:45Z", "author": {"login": "minwoox"}, "path": "testing-internal/src/main/java/com/linecorp/armeria/internal/testing/AbstractMethodChainingTest.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.testing;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.junit.jupiter.api.Test;\n+import org.reflections.ReflectionUtils;\n+import org.reflections.Reflections;\n+import org.reflections.adapters.JavaReflectionAdapter;\n+import org.reflections.scanners.SubTypesScanner;\n+import org.reflections.util.ClasspathHelper;\n+import org.reflections.util.ConfigurationBuilder;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+/**\n+ * Makes sure most builder overrides all overridden methods with the correct return type.\n+ */\n+public abstract class AbstractMethodChainingTest {\n+\n+    @Test\n+    void methodChaining() {\n+        final String packageName = getClass().getPackage().getName();\n+        findAllClasses(packageName).stream()\n+                                   .map(ReflectionUtils::forName)\n+                                   .filter(clazz -> clazz.getSimpleName().endsWith(\"Builder\"))\n+                                   .forEach(clazz -> {\n+                                       final List<Method> methods = obtainMethods(clazz);\n+                                       for (Method m : methods) {\n+                                           try {\n+                                               final Method overriddenMethod =\n+                                                       clazz.getDeclaredMethod(m.getName(),\n+                                                                               m.getParameterTypes());\n+                                               assertThat(overriddenMethod.getReturnType()).isSameAs(clazz);\n+                                           } catch (NoSuchMethodException e) {\n+                                               // ignored\n+                                           }\n+                                       }\n+                                   });\n+    }\n+\n+    private static Collection<String> findAllClasses(String packageName) {\n+        final ConfigurationBuilder configuration = new ConfigurationBuilder()\n+                .filterInputsBy(filePath -> filePath != null && filePath.endsWith(\".class\"))\n+                .setUrls(ClasspathHelper.forPackage(packageName))\n+                .setScanners(new SubTypesScanner())\n+                .setMetadataAdapter(new JavaReflectionAdapter());\n+        final Reflections reflections = new Reflections(configuration);\n+        return reflections.getStore().get(SubTypesScanner.class.getSimpleName()).values();\n+    }\n+\n+    private static List<Method> obtainMethods(Class<?> clazz) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbfb44fc77681307b493e766cd99b0aa6d15d28b"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE4MjU5MQ==", "bodyText": "Fixed", "url": "https://github.com/line/armeria/pull/3220#discussion_r546182591", "createdAt": "2020-12-19T03:13:49Z", "author": {"login": "heowc"}, "path": "testing-internal/src/main/java/com/linecorp/armeria/internal/testing/AbstractMethodChainingTest.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.testing;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.junit.jupiter.api.Test;\n+import org.reflections.ReflectionUtils;\n+import org.reflections.Reflections;\n+import org.reflections.adapters.JavaReflectionAdapter;\n+import org.reflections.scanners.SubTypesScanner;\n+import org.reflections.util.ClasspathHelper;\n+import org.reflections.util.ConfigurationBuilder;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+/**\n+ * Makes sure most builder overrides all overridden methods with the correct return type.\n+ */\n+public abstract class AbstractMethodChainingTest {\n+\n+    @Test\n+    void methodChaining() {\n+        final String packageName = getClass().getPackage().getName();\n+        findAllClasses(packageName).stream()\n+                                   .map(ReflectionUtils::forName)\n+                                   .filter(clazz -> clazz.getSimpleName().endsWith(\"Builder\"))\n+                                   .forEach(clazz -> {\n+                                       final List<Method> methods = obtainMethods(clazz);\n+                                       for (Method m : methods) {\n+                                           try {\n+                                               final Method overriddenMethod =\n+                                                       clazz.getDeclaredMethod(m.getName(),\n+                                                                               m.getParameterTypes());\n+                                               assertThat(overriddenMethod.getReturnType()).isSameAs(clazz);\n+                                           } catch (NoSuchMethodException e) {\n+                                               // ignored\n+                                           }\n+                                       }\n+                                   });\n+    }\n+\n+    private static Collection<String> findAllClasses(String packageName) {\n+        final ConfigurationBuilder configuration = new ConfigurationBuilder()\n+                .filterInputsBy(filePath -> filePath != null && filePath.endsWith(\".class\"))\n+                .setUrls(ClasspathHelper.forPackage(packageName))\n+                .setScanners(new SubTypesScanner())\n+                .setMetadataAdapter(new JavaReflectionAdapter());\n+        final Reflections reflections = new Reflections(configuration);\n+        return reflections.getStore().get(SubTypesScanner.class.getSimpleName()).values();\n+    }\n+\n+    private static List<Method> obtainMethods(Class<?> clazz) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTcxNDM1OA=="}, "originalCommit": {"oid": "fbfb44fc77681307b493e766cd99b0aa6d15d28b"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyOTk5MjQ3OnYy", "diffSide": "RIGHT", "path": "testing-internal/src/main/java/com/linecorp/armeria/internal/testing/AbstractMethodChainingTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQwOTo0MDoyNVrOIIbx-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwMzowNDo0NlrOII4SaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTcxNDY4MQ==", "bodyText": "Could you give an example of this?", "url": "https://github.com/line/armeria/pull/3220#discussion_r545714681", "createdAt": "2020-12-18T09:40:25Z", "author": {"login": "minwoox"}, "path": "testing-internal/src/main/java/com/linecorp/armeria/internal/testing/AbstractMethodChainingTest.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.testing;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.junit.jupiter.api.Test;\n+import org.reflections.ReflectionUtils;\n+import org.reflections.Reflections;\n+import org.reflections.adapters.JavaReflectionAdapter;\n+import org.reflections.scanners.SubTypesScanner;\n+import org.reflections.util.ClasspathHelper;\n+import org.reflections.util.ConfigurationBuilder;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+/**\n+ * Makes sure most builder overrides all overridden methods with the correct return type.\n+ */\n+public abstract class AbstractMethodChainingTest {\n+\n+    @Test\n+    void methodChaining() {\n+        final String packageName = getClass().getPackage().getName();\n+        findAllClasses(packageName).stream()\n+                                   .map(ReflectionUtils::forName)\n+                                   .filter(clazz -> clazz.getSimpleName().endsWith(\"Builder\"))\n+                                   .forEach(clazz -> {\n+                                       final List<Method> methods = obtainMethods(clazz);\n+                                       for (Method m : methods) {\n+                                           try {\n+                                               final Method overriddenMethod =\n+                                                       clazz.getDeclaredMethod(m.getName(),\n+                                                                               m.getParameterTypes());\n+                                               assertThat(overriddenMethod.getReturnType()).isSameAs(clazz);\n+                                           } catch (NoSuchMethodException e) {\n+                                               // ignored\n+                                           }\n+                                       }\n+                                   });\n+    }\n+\n+    private static Collection<String> findAllClasses(String packageName) {\n+        final ConfigurationBuilder configuration = new ConfigurationBuilder()\n+                .filterInputsBy(filePath -> filePath != null && filePath.endsWith(\".class\"))\n+                .setUrls(ClasspathHelper.forPackage(packageName))\n+                .setScanners(new SubTypesScanner())\n+                .setMetadataAdapter(new JavaReflectionAdapter());\n+        final Reflections reflections = new Reflections(configuration);\n+        return reflections.getStore().get(SubTypesScanner.class.getSimpleName()).values();\n+    }\n+\n+    private static List<Method> obtainMethods(Class<?> clazz) {\n+        final Set<Class<?>> allSuperTypes = ReflectionUtils.getAllSuperTypes(clazz, input -> input != clazz);\n+        final ImmutableList<Method> methods = allSuperTypes.stream()\n+                                                           .flatMap(sc -> Arrays.stream(sc.getMethods()))\n+                                                           .distinct()\n+                                                           .collect(toImmutableList());\n+        // In general, if parent classes have a build method, did not override the method with that type.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbfb44fc77681307b493e766cd99b0aa6d15d28b"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE4MTczNw==", "bodyText": "The things mentioned here can be an example.", "url": "https://github.com/line/armeria/pull/3220#discussion_r546181737", "createdAt": "2020-12-19T03:04:46Z", "author": {"login": "heowc"}, "path": "testing-internal/src/main/java/com/linecorp/armeria/internal/testing/AbstractMethodChainingTest.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.testing;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.junit.jupiter.api.Test;\n+import org.reflections.ReflectionUtils;\n+import org.reflections.Reflections;\n+import org.reflections.adapters.JavaReflectionAdapter;\n+import org.reflections.scanners.SubTypesScanner;\n+import org.reflections.util.ClasspathHelper;\n+import org.reflections.util.ConfigurationBuilder;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+/**\n+ * Makes sure most builder overrides all overridden methods with the correct return type.\n+ */\n+public abstract class AbstractMethodChainingTest {\n+\n+    @Test\n+    void methodChaining() {\n+        final String packageName = getClass().getPackage().getName();\n+        findAllClasses(packageName).stream()\n+                                   .map(ReflectionUtils::forName)\n+                                   .filter(clazz -> clazz.getSimpleName().endsWith(\"Builder\"))\n+                                   .forEach(clazz -> {\n+                                       final List<Method> methods = obtainMethods(clazz);\n+                                       for (Method m : methods) {\n+                                           try {\n+                                               final Method overriddenMethod =\n+                                                       clazz.getDeclaredMethod(m.getName(),\n+                                                                               m.getParameterTypes());\n+                                               assertThat(overriddenMethod.getReturnType()).isSameAs(clazz);\n+                                           } catch (NoSuchMethodException e) {\n+                                               // ignored\n+                                           }\n+                                       }\n+                                   });\n+    }\n+\n+    private static Collection<String> findAllClasses(String packageName) {\n+        final ConfigurationBuilder configuration = new ConfigurationBuilder()\n+                .filterInputsBy(filePath -> filePath != null && filePath.endsWith(\".class\"))\n+                .setUrls(ClasspathHelper.forPackage(packageName))\n+                .setScanners(new SubTypesScanner())\n+                .setMetadataAdapter(new JavaReflectionAdapter());\n+        final Reflections reflections = new Reflections(configuration);\n+        return reflections.getStore().get(SubTypesScanner.class.getSimpleName()).values();\n+    }\n+\n+    private static List<Method> obtainMethods(Class<?> clazz) {\n+        final Set<Class<?>> allSuperTypes = ReflectionUtils.getAllSuperTypes(clazz, input -> input != clazz);\n+        final ImmutableList<Method> methods = allSuperTypes.stream()\n+                                                           .flatMap(sc -> Arrays.stream(sc.getMethods()))\n+                                                           .distinct()\n+                                                           .collect(toImmutableList());\n+        // In general, if parent classes have a build method, did not override the method with that type.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTcxNDY4MQ=="}, "originalCommit": {"oid": "fbfb44fc77681307b493e766cd99b0aa6d15d28b"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyOTk5NjY0OnYy", "diffSide": "RIGHT", "path": "testing-internal/src/main/java/com/linecorp/armeria/internal/testing/AbstractMethodChainingTest.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQwOTo0MToyNFrOIIb0Ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNFQwNjoyMDo1NFrOILACQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTcxNTI1OQ==", "bodyText": "Could just buildMethodExists and remove \"build\"?", "url": "https://github.com/line/armeria/pull/3220#discussion_r545715259", "createdAt": "2020-12-18T09:41:24Z", "author": {"login": "minwoox"}, "path": "testing-internal/src/main/java/com/linecorp/armeria/internal/testing/AbstractMethodChainingTest.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.testing;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.junit.jupiter.api.Test;\n+import org.reflections.ReflectionUtils;\n+import org.reflections.Reflections;\n+import org.reflections.adapters.JavaReflectionAdapter;\n+import org.reflections.scanners.SubTypesScanner;\n+import org.reflections.util.ClasspathHelper;\n+import org.reflections.util.ConfigurationBuilder;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+/**\n+ * Makes sure most builder overrides all overridden methods with the correct return type.\n+ */\n+public abstract class AbstractMethodChainingTest {\n+\n+    @Test\n+    void methodChaining() {\n+        final String packageName = getClass().getPackage().getName();\n+        findAllClasses(packageName).stream()\n+                                   .map(ReflectionUtils::forName)\n+                                   .filter(clazz -> clazz.getSimpleName().endsWith(\"Builder\"))\n+                                   .forEach(clazz -> {\n+                                       final List<Method> methods = obtainMethods(clazz);\n+                                       for (Method m : methods) {\n+                                           try {\n+                                               final Method overriddenMethod =\n+                                                       clazz.getDeclaredMethod(m.getName(),\n+                                                                               m.getParameterTypes());\n+                                               assertThat(overriddenMethod.getReturnType()).isSameAs(clazz);\n+                                           } catch (NoSuchMethodException e) {\n+                                               // ignored\n+                                           }\n+                                       }\n+                                   });\n+    }\n+\n+    private static Collection<String> findAllClasses(String packageName) {\n+        final ConfigurationBuilder configuration = new ConfigurationBuilder()\n+                .filterInputsBy(filePath -> filePath != null && filePath.endsWith(\".class\"))\n+                .setUrls(ClasspathHelper.forPackage(packageName))\n+                .setScanners(new SubTypesScanner())\n+                .setMetadataAdapter(new JavaReflectionAdapter());\n+        final Reflections reflections = new Reflections(configuration);\n+        return reflections.getStore().get(SubTypesScanner.class.getSimpleName()).values();\n+    }\n+\n+    private static List<Method> obtainMethods(Class<?> clazz) {\n+        final Set<Class<?>> allSuperTypes = ReflectionUtils.getAllSuperTypes(clazz, input -> input != clazz);\n+        final ImmutableList<Method> methods = allSuperTypes.stream()\n+                                                           .flatMap(sc -> Arrays.stream(sc.getMethods()))\n+                                                           .distinct()\n+                                                           .collect(toImmutableList());\n+        // In general, if parent classes have a build method, did not override the method with that type.\n+        if (existMethodName(methods, \"build\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbfb44fc77681307b493e766cd99b0aa6d15d28b"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE4MjAzMw==", "bodyText": "Same as above.", "url": "https://github.com/line/armeria/pull/3220#discussion_r546182033", "createdAt": "2020-12-19T03:07:40Z", "author": {"login": "heowc"}, "path": "testing-internal/src/main/java/com/linecorp/armeria/internal/testing/AbstractMethodChainingTest.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.testing;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.junit.jupiter.api.Test;\n+import org.reflections.ReflectionUtils;\n+import org.reflections.Reflections;\n+import org.reflections.adapters.JavaReflectionAdapter;\n+import org.reflections.scanners.SubTypesScanner;\n+import org.reflections.util.ClasspathHelper;\n+import org.reflections.util.ConfigurationBuilder;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+/**\n+ * Makes sure most builder overrides all overridden methods with the correct return type.\n+ */\n+public abstract class AbstractMethodChainingTest {\n+\n+    @Test\n+    void methodChaining() {\n+        final String packageName = getClass().getPackage().getName();\n+        findAllClasses(packageName).stream()\n+                                   .map(ReflectionUtils::forName)\n+                                   .filter(clazz -> clazz.getSimpleName().endsWith(\"Builder\"))\n+                                   .forEach(clazz -> {\n+                                       final List<Method> methods = obtainMethods(clazz);\n+                                       for (Method m : methods) {\n+                                           try {\n+                                               final Method overriddenMethod =\n+                                                       clazz.getDeclaredMethod(m.getName(),\n+                                                                               m.getParameterTypes());\n+                                               assertThat(overriddenMethod.getReturnType()).isSameAs(clazz);\n+                                           } catch (NoSuchMethodException e) {\n+                                               // ignored\n+                                           }\n+                                       }\n+                                   });\n+    }\n+\n+    private static Collection<String> findAllClasses(String packageName) {\n+        final ConfigurationBuilder configuration = new ConfigurationBuilder()\n+                .filterInputsBy(filePath -> filePath != null && filePath.endsWith(\".class\"))\n+                .setUrls(ClasspathHelper.forPackage(packageName))\n+                .setScanners(new SubTypesScanner())\n+                .setMetadataAdapter(new JavaReflectionAdapter());\n+        final Reflections reflections = new Reflections(configuration);\n+        return reflections.getStore().get(SubTypesScanner.class.getSimpleName()).values();\n+    }\n+\n+    private static List<Method> obtainMethods(Class<?> clazz) {\n+        final Set<Class<?>> allSuperTypes = ReflectionUtils.getAllSuperTypes(clazz, input -> input != clazz);\n+        final ImmutableList<Method> methods = allSuperTypes.stream()\n+                                                           .flatMap(sc -> Arrays.stream(sc.getMethods()))\n+                                                           .distinct()\n+                                                           .collect(toImmutableList());\n+        // In general, if parent classes have a build method, did not override the method with that type.\n+        if (existMethodName(methods, \"build\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTcxNTI1OQ=="}, "originalCommit": {"oid": "fbfb44fc77681307b493e766cd99b0aa6d15d28b"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQwMjkyNg==", "bodyText": "Oops, I missed this comment.\nI was suggesting rename this method. \ud83d\ude04\nif (buildMethodExists(methods)) {...}", "url": "https://github.com/line/armeria/pull/3220#discussion_r548402926", "createdAt": "2020-12-24T06:11:42Z", "author": {"login": "minwoox"}, "path": "testing-internal/src/main/java/com/linecorp/armeria/internal/testing/AbstractMethodChainingTest.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.testing;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.junit.jupiter.api.Test;\n+import org.reflections.ReflectionUtils;\n+import org.reflections.Reflections;\n+import org.reflections.adapters.JavaReflectionAdapter;\n+import org.reflections.scanners.SubTypesScanner;\n+import org.reflections.util.ClasspathHelper;\n+import org.reflections.util.ConfigurationBuilder;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+/**\n+ * Makes sure most builder overrides all overridden methods with the correct return type.\n+ */\n+public abstract class AbstractMethodChainingTest {\n+\n+    @Test\n+    void methodChaining() {\n+        final String packageName = getClass().getPackage().getName();\n+        findAllClasses(packageName).stream()\n+                                   .map(ReflectionUtils::forName)\n+                                   .filter(clazz -> clazz.getSimpleName().endsWith(\"Builder\"))\n+                                   .forEach(clazz -> {\n+                                       final List<Method> methods = obtainMethods(clazz);\n+                                       for (Method m : methods) {\n+                                           try {\n+                                               final Method overriddenMethod =\n+                                                       clazz.getDeclaredMethod(m.getName(),\n+                                                                               m.getParameterTypes());\n+                                               assertThat(overriddenMethod.getReturnType()).isSameAs(clazz);\n+                                           } catch (NoSuchMethodException e) {\n+                                               // ignored\n+                                           }\n+                                       }\n+                                   });\n+    }\n+\n+    private static Collection<String> findAllClasses(String packageName) {\n+        final ConfigurationBuilder configuration = new ConfigurationBuilder()\n+                .filterInputsBy(filePath -> filePath != null && filePath.endsWith(\".class\"))\n+                .setUrls(ClasspathHelper.forPackage(packageName))\n+                .setScanners(new SubTypesScanner())\n+                .setMetadataAdapter(new JavaReflectionAdapter());\n+        final Reflections reflections = new Reflections(configuration);\n+        return reflections.getStore().get(SubTypesScanner.class.getSimpleName()).values();\n+    }\n+\n+    private static List<Method> obtainMethods(Class<?> clazz) {\n+        final Set<Class<?>> allSuperTypes = ReflectionUtils.getAllSuperTypes(clazz, input -> input != clazz);\n+        final ImmutableList<Method> methods = allSuperTypes.stream()\n+                                                           .flatMap(sc -> Arrays.stream(sc.getMethods()))\n+                                                           .distinct()\n+                                                           .collect(toImmutableList());\n+        // In general, if parent classes have a build method, did not override the method with that type.\n+        if (existMethodName(methods, \"build\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTcxNTI1OQ=="}, "originalCommit": {"oid": "fbfb44fc77681307b493e766cd99b0aa6d15d28b"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQwNTgyNA==", "bodyText": "Fixed \ud83d\ude04", "url": "https://github.com/line/armeria/pull/3220#discussion_r548405824", "createdAt": "2020-12-24T06:20:54Z", "author": {"login": "heowc"}, "path": "testing-internal/src/main/java/com/linecorp/armeria/internal/testing/AbstractMethodChainingTest.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.testing;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.junit.jupiter.api.Test;\n+import org.reflections.ReflectionUtils;\n+import org.reflections.Reflections;\n+import org.reflections.adapters.JavaReflectionAdapter;\n+import org.reflections.scanners.SubTypesScanner;\n+import org.reflections.util.ClasspathHelper;\n+import org.reflections.util.ConfigurationBuilder;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+/**\n+ * Makes sure most builder overrides all overridden methods with the correct return type.\n+ */\n+public abstract class AbstractMethodChainingTest {\n+\n+    @Test\n+    void methodChaining() {\n+        final String packageName = getClass().getPackage().getName();\n+        findAllClasses(packageName).stream()\n+                                   .map(ReflectionUtils::forName)\n+                                   .filter(clazz -> clazz.getSimpleName().endsWith(\"Builder\"))\n+                                   .forEach(clazz -> {\n+                                       final List<Method> methods = obtainMethods(clazz);\n+                                       for (Method m : methods) {\n+                                           try {\n+                                               final Method overriddenMethod =\n+                                                       clazz.getDeclaredMethod(m.getName(),\n+                                                                               m.getParameterTypes());\n+                                               assertThat(overriddenMethod.getReturnType()).isSameAs(clazz);\n+                                           } catch (NoSuchMethodException e) {\n+                                               // ignored\n+                                           }\n+                                       }\n+                                   });\n+    }\n+\n+    private static Collection<String> findAllClasses(String packageName) {\n+        final ConfigurationBuilder configuration = new ConfigurationBuilder()\n+                .filterInputsBy(filePath -> filePath != null && filePath.endsWith(\".class\"))\n+                .setUrls(ClasspathHelper.forPackage(packageName))\n+                .setScanners(new SubTypesScanner())\n+                .setMetadataAdapter(new JavaReflectionAdapter());\n+        final Reflections reflections = new Reflections(configuration);\n+        return reflections.getStore().get(SubTypesScanner.class.getSimpleName()).values();\n+    }\n+\n+    private static List<Method> obtainMethods(Class<?> clazz) {\n+        final Set<Class<?>> allSuperTypes = ReflectionUtils.getAllSuperTypes(clazz, input -> input != clazz);\n+        final ImmutableList<Method> methods = allSuperTypes.stream()\n+                                                           .flatMap(sc -> Arrays.stream(sc.getMethods()))\n+                                                           .distinct()\n+                                                           .collect(toImmutableList());\n+        // In general, if parent classes have a build method, did not override the method with that type.\n+        if (existMethodName(methods, \"build\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTcxNTI1OQ=="}, "originalCommit": {"oid": "fbfb44fc77681307b493e766cd99b0aa6d15d28b"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1NDI4NDE5OnYy", "diffSide": "RIGHT", "path": "it/builders/src/test/java/com/linecorp/armeria/OverriddenBuilderMethodsReturnTypeTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQwMzoyNzowNlrOILwpbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQwMzozNToyOFrOILwtgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTIwMjI4NA==", "bodyText": "How about hardcoring this string instead of using the test's package? Then it allows the tests location to be decoupled from the test.", "url": "https://github.com/line/armeria/pull/3220#discussion_r549202284", "createdAt": "2020-12-28T03:27:06Z", "author": {"login": "anuraaga"}, "path": "it/builders/src/test/java/com/linecorp/armeria/OverriddenBuilderMethodsReturnTypeTest.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.junit.jupiter.api.Test;\n+import org.reflections.ReflectionUtils;\n+import org.reflections.Reflections;\n+import org.reflections.adapters.JavaReflectionAdapter;\n+import org.reflections.scanners.SubTypesScanner;\n+import org.reflections.util.ClasspathHelper;\n+import org.reflections.util.ConfigurationBuilder;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+/**\n+ * Makes sure most builder overrides all overridden methods with the correct return type.\n+ */\n+class OverriddenBuilderMethodsReturnTypeTest {\n+\n+    @Test\n+    void methodChaining() {\n+        final String packageName = getClass().getPackage().getName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e0624e35dc9270218de094ff329fcc8293a9a48"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTIwMzMzMQ==", "bodyText": "Fixed to com.linecorp.armeria \ud83d\ude09", "url": "https://github.com/line/armeria/pull/3220#discussion_r549203331", "createdAt": "2020-12-28T03:35:28Z", "author": {"login": "heowc"}, "path": "it/builders/src/test/java/com/linecorp/armeria/OverriddenBuilderMethodsReturnTypeTest.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.junit.jupiter.api.Test;\n+import org.reflections.ReflectionUtils;\n+import org.reflections.Reflections;\n+import org.reflections.adapters.JavaReflectionAdapter;\n+import org.reflections.scanners.SubTypesScanner;\n+import org.reflections.util.ClasspathHelper;\n+import org.reflections.util.ConfigurationBuilder;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+/**\n+ * Makes sure most builder overrides all overridden methods with the correct return type.\n+ */\n+class OverriddenBuilderMethodsReturnTypeTest {\n+\n+    @Test\n+    void methodChaining() {\n+        final String packageName = getClass().getPackage().getName();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTIwMjI4NA=="}, "originalCommit": {"oid": "6e0624e35dc9270218de094ff329fcc8293a9a48"}, "originalPosition": 45}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1800, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}