{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA3MzYyNDQ4", "number": 3124, "reviewThreads": {"totalCount": 44, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwOToxMTowM1rOExHxQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwMzo1NDowMVrOE63WxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5OTQyOTc4OnYy", "diffSide": "RIGHT", "path": "grpc/src/main/java/com/linecorp/armeria/server/grpc/ProtobufRequestConverterFunction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwOToxMTowM1rOHnFdww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwOToxMTowM1rOHnFdww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc0NjA1MQ==", "bodyText": "I was just wondering how slower is Method.invoke(...) than MethodHandle.invoke(...).\nBenchmark                          Mode  Cnt         Score         Error  Units\nMethodCallBenchmark.directCall    thrpt    5  30697469.267 \u00b1 5620688.880  ops/s\nMethodCallBenchmark.method        thrpt    5  24412855.684 \u00b1 4318917.364  ops/s\nMethodCallBenchmark.methodHandle  thrpt    5  29439498.151 \u00b1 1840979.485  ops/s\n\nThere is 10% ~ 20% performance degression in Method.invoke(...). Let me change this with MethodHandle. :-)", "url": "https://github.com/line/armeria/pull/3124#discussion_r510746051", "createdAt": "2020-10-23T09:11:03Z", "author": {"login": "ikhoon"}, "path": "grpc/src/main/java/com/linecorp/armeria/server/grpc/ProtobufRequestConverterFunction.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.grpc;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.ParameterizedType;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableCollection;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.MapMaker;\n+import com.google.protobuf.ExtensionRegistry;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Parser;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+\n+/**\n+ * A {@link RequestConverterFunction} which converts a Protocol Buffers or JSON body of\n+ * the {@link AggregatedHttpRequest} to an object.\n+ * The built-in parser of {@link Message} for Protocol Buffers is applied only when the {@code content-type} of\n+ * {@link RequestHeaders} either {@link MediaType#PROTOBUF} or {@link MediaType#OCTET_STREAM} or\n+ * the {@link MediaType#subtype()} contains {@code \"protobuf\"}.\n+ * The {@link Parser} for JSON is applied only when the {@code content-type} of\n+ * the {@link RequestHeaders} is {@link MediaType#JSON} or ends with {@code +json}.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore a sequence of Protocol Buffer messages can not be handled by this {@link RequestConverterFunction}.\n+ * However a <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a> body\n+ * could be converted into a {@link Collection} type. e.g, {@code List<Message>} and {@code Set<Message>}.\n+ */\n+public final class ProtobufRequestConverterFunction implements RequestConverterFunction {\n+\n+    private static final ConcurrentMap<Class<?>, Method> methodCache = new MapMaker().weakKeys().makeMap();\n+    private static final Parser defaultJsonParser = JsonFormat.parser().ignoringUnknownFields();\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+\n+    private final ExtensionRegistry extensionRegistry;\n+    private final Parser jsonParser;\n+\n+    /**\n+     * Creates an instance with the default {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction() {\n+        this(defaultJsonParser, ExtensionRegistry.getEmptyRegistry());\n+    }\n+\n+    /**\n+     * Creates an instance with the specified {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction(Parser jsonParser, ExtensionRegistry extensionRegistry) {\n+        this.jsonParser = jsonParser;\n+        this.extensionRegistry = extensionRegistry;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public Object convertRequest(ServiceRequestContext ctx, AggregatedHttpRequest request,\n+                                 Class<?> expectedResultType,\n+                                 @Nullable ParameterizedType expectedParameterizedResultType) throws Exception {\n+\n+        final MediaType contentType = request.contentType();\n+        if (Message.class.isAssignableFrom(expectedResultType)) {\n+            final Message.Builder messageBuilder = getMessageBuilder(expectedResultType);\n+\n+            if (contentType == null ||\n+                contentType.subtype().contains(\"protobuf\") || contentType.is(MediaType.OCTET_STREAM)) {\n+                return messageBuilder.mergeFrom(request.content().array(), extensionRegistry).build();\n+            }\n+\n+            if (isJson(contentType)) {\n+                jsonParser.merge(request.contentUtf8(), messageBuilder);\n+                return messageBuilder.build();\n+            }\n+        }\n+\n+        if (isJson(contentType) && expectedParameterizedResultType != null) {\n+            final int collectionType;\n+            if (List.class.isAssignableFrom(expectedResultType)) {\n+                collectionType = 1;\n+            } else if (Set.class.isAssignableFrom(expectedResultType)) {\n+                collectionType = 2;\n+            } else {\n+                collectionType = 0;\n+            }\n+\n+            if (collectionType > 0) {\n+                final Class<?> typeArgument =\n+                        (Class<?>) expectedParameterizedResultType.getActualTypeArguments()[0];\n+                if (Message.class.isAssignableFrom(typeArgument)) {\n+                    final String content = request.content(contentType.charset(StandardCharsets.UTF_8));\n+\n+                    final JsonNode jsonNode = mapper.readTree(content);\n+                    if (jsonNode.isArray()) {\n+                        final ImmutableCollection.Builder<Message> builder;\n+                        if (collectionType == 1) {\n+                            builder = ImmutableList.builderWithExpectedSize(jsonNode.size());\n+                        } else {\n+                            builder = ImmutableSet.builderWithExpectedSize(jsonNode.size());\n+                        }\n+                        for (JsonNode node : jsonNode) {\n+                            final Message.Builder messageBuilder = getMessageBuilder(typeArgument);\n+                            jsonParser.merge(mapper.writeValueAsString(node), messageBuilder);\n+                            builder.add(messageBuilder.build());\n+                        }\n+\n+                        return builder.build();\n+                    }\n+                }\n+            }\n+        }\n+\n+        return RequestConverterFunction.fallthrough();\n+    }\n+\n+    private static boolean isJson(@Nullable MediaType contentType) {\n+        return contentType != null &&\n+               (contentType.is(MediaType.JSON) || contentType.subtype().endsWith(\"+json\"));\n+    }\n+\n+    private static Message.Builder getMessageBuilder(Class<?> clazz) throws Exception {\n+        Method method = methodCache.get(clazz);\n+        if (method == null) {\n+            method = clazz.getMethod(\"newBuilder\");\n+            methodCache.put(clazz, method);\n+        }\n+        return (Message.Builder) method.invoke(clazz);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca3b1573baae1bbc0d3e0f671b17cb4e1a483af6"}, "originalPosition": 158}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNzEzNjA2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/internal/server/annotation/AnnotatedValueResolver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxMToyMDoyMlrOHoLHHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxMTozNzo1MlrOHoLp1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg4NzEzNQ==", "bodyText": "We use SPI to find ResponseConverterFunction implementations.\nShouldn't we use the same approach for RequestConverterFunction?", "url": "https://github.com/line/armeria/pull/3124#discussion_r511887135", "createdAt": "2020-10-26T11:20:22Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/internal/server/annotation/AnnotatedValueResolver.java", "diffHunk": "@@ -90,18 +90,43 @@\n final class AnnotatedValueResolver {\n     private static final Logger logger = LoggerFactory.getLogger(AnnotatedValueResolver.class);\n \n-    private static final List<RequestObjectResolver> defaultRequestConverters = ImmutableList.of(\n-            (resolverContext, expectedResultType, expectedParameterizedResultType, beanFactoryId) -> {\n-                final AnnotatedBeanFactory<?> factory = AnnotatedBeanFactoryRegistry.find(beanFactoryId);\n-                if (factory == null) {\n-                    return RequestConverterFunction.fallthrough();\n-                } else {\n-                    return factory.create(resolverContext);\n-                }\n-            },\n-            RequestObjectResolver.of(new JacksonRequestConverterFunction()),\n-            RequestObjectResolver.of(new StringRequestConverterFunction()),\n-            RequestObjectResolver.of(new ByteArrayRequestConverterFunction()));\n+    @Nullable\n+    private static final RequestConverterFunction protobufRequestConverterFunction;\n+\n+    static {\n+        RequestConverterFunction converterFunction;\n+        try {\n+            final Class<?> protobufConverterClass =\n+                    Class.forName(\"com.linecorp.armeria.server.grpc.ProtobufRequestConverterFunction\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea9688bba5a4e9199702c84a732f6d312a1ea241"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg5NjAyMA==", "bodyText": "That's a good suggestion. Let me add a SPI provider.", "url": "https://github.com/line/armeria/pull/3124#discussion_r511896020", "createdAt": "2020-10-26T11:37:52Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/internal/server/annotation/AnnotatedValueResolver.java", "diffHunk": "@@ -90,18 +90,43 @@\n final class AnnotatedValueResolver {\n     private static final Logger logger = LoggerFactory.getLogger(AnnotatedValueResolver.class);\n \n-    private static final List<RequestObjectResolver> defaultRequestConverters = ImmutableList.of(\n-            (resolverContext, expectedResultType, expectedParameterizedResultType, beanFactoryId) -> {\n-                final AnnotatedBeanFactory<?> factory = AnnotatedBeanFactoryRegistry.find(beanFactoryId);\n-                if (factory == null) {\n-                    return RequestConverterFunction.fallthrough();\n-                } else {\n-                    return factory.create(resolverContext);\n-                }\n-            },\n-            RequestObjectResolver.of(new JacksonRequestConverterFunction()),\n-            RequestObjectResolver.of(new StringRequestConverterFunction()),\n-            RequestObjectResolver.of(new ByteArrayRequestConverterFunction()));\n+    @Nullable\n+    private static final RequestConverterFunction protobufRequestConverterFunction;\n+\n+    static {\n+        RequestConverterFunction converterFunction;\n+        try {\n+            final Class<?> protobufConverterClass =\n+                    Class.forName(\"com.linecorp.armeria.server.grpc.ProtobufRequestConverterFunction\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg4NzEzNQ=="}, "originalCommit": {"oid": "ea9688bba5a4e9199702c84a732f6d312a1ea241"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNzE2MzEyOnYy", "diffSide": "RIGHT", "path": "grpc/src/main/java/com/linecorp/armeria/server/grpc/ProtobufRequestConverterFunction.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxMToyODozMlrOHoLXqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwODowNDo0MlrOHsjewQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg5MTM2OA==", "bodyText": "Shouldn't we make a separate module so that the user doesn't have to bring gRPC dependencies to use this?", "url": "https://github.com/line/armeria/pull/3124#discussion_r511891368", "createdAt": "2020-10-26T11:28:32Z", "author": {"login": "minwoox"}, "path": "grpc/src/main/java/com/linecorp/armeria/server/grpc/ProtobufRequestConverterFunction.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.grpc;\n+\n+import static java.lang.invoke.MethodType.methodType;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.ParameterizedType;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableCollection;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.MapMaker;\n+import com.google.protobuf.ExtensionRegistry;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Parser;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+\n+/**\n+ * A {@link RequestConverterFunction} which converts a Protocol Buffers or JSON body of\n+ * the {@link AggregatedHttpRequest} to an object.\n+ * The built-in parser of {@link Message} for Protocol Buffers is applied only when the {@code content-type} of\n+ * {@link RequestHeaders} either {@link MediaType#PROTOBUF} or {@link MediaType#OCTET_STREAM} or\n+ * the {@link MediaType#subtype()} contains {@code \"protobuf\"}.\n+ * The {@link Parser} for JSON is applied only when the {@code content-type} of\n+ * the {@link RequestHeaders} is {@link MediaType#JSON} or ends with {@code +json}.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore a sequence of Protocol Buffer messages can not be handled by this {@link RequestConverterFunction}.\n+ * However a <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a> body\n+ * could be converted into a {@link Collection} type. e.g, {@code List<Message>} and {@code Set<Message>}.\n+ */\n+public final class ProtobufRequestConverterFunction implements RequestConverterFunction {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea9688bba5a4e9199702c84a732f6d312a1ea241"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg5NjUwNQ==", "bodyText": "I thought this feature would be interesting to some users who want to gRPC service and client already. Do we need armeria-protobuf? \ud83e\udd14", "url": "https://github.com/line/armeria/pull/3124#discussion_r511896505", "createdAt": "2020-10-26T11:38:51Z", "author": {"login": "ikhoon"}, "path": "grpc/src/main/java/com/linecorp/armeria/server/grpc/ProtobufRequestConverterFunction.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.grpc;\n+\n+import static java.lang.invoke.MethodType.methodType;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.ParameterizedType;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableCollection;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.MapMaker;\n+import com.google.protobuf.ExtensionRegistry;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Parser;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+\n+/**\n+ * A {@link RequestConverterFunction} which converts a Protocol Buffers or JSON body of\n+ * the {@link AggregatedHttpRequest} to an object.\n+ * The built-in parser of {@link Message} for Protocol Buffers is applied only when the {@code content-type} of\n+ * {@link RequestHeaders} either {@link MediaType#PROTOBUF} or {@link MediaType#OCTET_STREAM} or\n+ * the {@link MediaType#subtype()} contains {@code \"protobuf\"}.\n+ * The {@link Parser} for JSON is applied only when the {@code content-type} of\n+ * the {@link RequestHeaders} is {@link MediaType#JSON} or ends with {@code +json}.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore a sequence of Protocol Buffer messages can not be handled by this {@link RequestConverterFunction}.\n+ * However a <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a> body\n+ * could be converted into a {@link Collection} type. e.g, {@code List<Message>} and {@code Set<Message>}.\n+ */\n+public final class ProtobufRequestConverterFunction implements RequestConverterFunction {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg5MTM2OA=="}, "originalCommit": {"oid": "ea9688bba5a4e9199702c84a732f6d312a1ea241"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg5ODY1Ng==", "bodyText": "I'm not sure. \ud83e\udd23  @anuraaga Do you have any suggestions?", "url": "https://github.com/line/armeria/pull/3124#discussion_r511898656", "createdAt": "2020-10-26T11:42:53Z", "author": {"login": "minwoox"}, "path": "grpc/src/main/java/com/linecorp/armeria/server/grpc/ProtobufRequestConverterFunction.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.grpc;\n+\n+import static java.lang.invoke.MethodType.methodType;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.ParameterizedType;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableCollection;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.MapMaker;\n+import com.google.protobuf.ExtensionRegistry;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Parser;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+\n+/**\n+ * A {@link RequestConverterFunction} which converts a Protocol Buffers or JSON body of\n+ * the {@link AggregatedHttpRequest} to an object.\n+ * The built-in parser of {@link Message} for Protocol Buffers is applied only when the {@code content-type} of\n+ * {@link RequestHeaders} either {@link MediaType#PROTOBUF} or {@link MediaType#OCTET_STREAM} or\n+ * the {@link MediaType#subtype()} contains {@code \"protobuf\"}.\n+ * The {@link Parser} for JSON is applied only when the {@code content-type} of\n+ * the {@link RequestHeaders} is {@link MediaType#JSON} or ends with {@code +json}.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore a sequence of Protocol Buffer messages can not be handled by this {@link RequestConverterFunction}.\n+ * However a <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a> body\n+ * could be converted into a {@link Collection} type. e.g, {@code List<Message>} and {@code Set<Message>}.\n+ */\n+public final class ProtobufRequestConverterFunction implements RequestConverterFunction {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg5MTM2OA=="}, "originalCommit": {"oid": "ea9688bba5a4e9199702c84a732f6d312a1ea241"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQyODczMA==", "bodyText": "Sorry for late reply - it does seem strange to have this in gRPC package since it seems to have nothing to do with gRPC. Perhaps core with compileOnly dependency on protobuf so it's next to the other annotated service functionality? not sure", "url": "https://github.com/line/armeria/pull/3124#discussion_r516428730", "createdAt": "2020-11-03T04:59:38Z", "author": {"login": "anuraaga"}, "path": "grpc/src/main/java/com/linecorp/armeria/server/grpc/ProtobufRequestConverterFunction.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.grpc;\n+\n+import static java.lang.invoke.MethodType.methodType;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.ParameterizedType;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableCollection;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.MapMaker;\n+import com.google.protobuf.ExtensionRegistry;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Parser;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+\n+/**\n+ * A {@link RequestConverterFunction} which converts a Protocol Buffers or JSON body of\n+ * the {@link AggregatedHttpRequest} to an object.\n+ * The built-in parser of {@link Message} for Protocol Buffers is applied only when the {@code content-type} of\n+ * {@link RequestHeaders} either {@link MediaType#PROTOBUF} or {@link MediaType#OCTET_STREAM} or\n+ * the {@link MediaType#subtype()} contains {@code \"protobuf\"}.\n+ * The {@link Parser} for JSON is applied only when the {@code content-type} of\n+ * the {@link RequestHeaders} is {@link MediaType#JSON} or ends with {@code +json}.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore a sequence of Protocol Buffer messages can not be handled by this {@link RequestConverterFunction}.\n+ * However a <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a> body\n+ * could be converted into a {@link Collection} type. e.g, {@code List<Message>} and {@code Set<Message>}.\n+ */\n+public final class ProtobufRequestConverterFunction implements RequestConverterFunction {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg5MTM2OA=="}, "originalCommit": {"oid": "ea9688bba5a4e9199702c84a732f6d312a1ea241"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ4MDcwNQ==", "bodyText": "Yeah, the code is too small to create a seperate module. Let me move this code to core and add @UnstableApi in case we need armeria-protobuf later.", "url": "https://github.com/line/armeria/pull/3124#discussion_r516480705", "createdAt": "2020-11-03T08:04:42Z", "author": {"login": "ikhoon"}, "path": "grpc/src/main/java/com/linecorp/armeria/server/grpc/ProtobufRequestConverterFunction.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.grpc;\n+\n+import static java.lang.invoke.MethodType.methodType;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.ParameterizedType;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableCollection;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.MapMaker;\n+import com.google.protobuf.ExtensionRegistry;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Parser;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+\n+/**\n+ * A {@link RequestConverterFunction} which converts a Protocol Buffers or JSON body of\n+ * the {@link AggregatedHttpRequest} to an object.\n+ * The built-in parser of {@link Message} for Protocol Buffers is applied only when the {@code content-type} of\n+ * {@link RequestHeaders} either {@link MediaType#PROTOBUF} or {@link MediaType#OCTET_STREAM} or\n+ * the {@link MediaType#subtype()} contains {@code \"protobuf\"}.\n+ * The {@link Parser} for JSON is applied only when the {@code content-type} of\n+ * the {@link RequestHeaders} is {@link MediaType#JSON} or ends with {@code +json}.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore a sequence of Protocol Buffer messages can not be handled by this {@link RequestConverterFunction}.\n+ * However a <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a> body\n+ * could be converted into a {@link Collection} type. e.g, {@code List<Message>} and {@code Set<Message>}.\n+ */\n+public final class ProtobufRequestConverterFunction implements RequestConverterFunction {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg5MTM2OA=="}, "originalCommit": {"oid": "ea9688bba5a4e9199702c84a732f6d312a1ea241"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMDgyNzA2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/internal/server/annotation/AnnotatedValueResolver.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQwNjo1MDowMVrOHrsu0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQwNjo1MDowMVrOHrsu0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU4MzY5OA==", "bodyText": "defaultRequestConverterFunctions and defaultRequestObjectResolvers?", "url": "https://github.com/line/armeria/pull/3124#discussion_r515583698", "createdAt": "2020-11-01T06:50:01Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/internal/server/annotation/AnnotatedValueResolver.java", "diffHunk": "@@ -90,18 +92,40 @@\n final class AnnotatedValueResolver {\n     private static final Logger logger = LoggerFactory.getLogger(AnnotatedValueResolver.class);\n \n-    private static final List<RequestObjectResolver> defaultRequestConverters = ImmutableList.of(\n-            (resolverContext, expectedResultType, expectedParameterizedResultType, beanFactoryId) -> {\n-                final AnnotatedBeanFactory<?> factory = AnnotatedBeanFactoryRegistry.find(beanFactoryId);\n-                if (factory == null) {\n-                    return RequestConverterFunction.fallthrough();\n-                } else {\n-                    return factory.create(resolverContext);\n-                }\n-            },\n-            RequestObjectResolver.of(new JacksonRequestConverterFunction()),\n-            RequestObjectResolver.of(new StringRequestConverterFunction()),\n-            RequestObjectResolver.of(new ByteArrayRequestConverterFunction()));\n+    private static final List<RequestConverterFunction> defaultRequestFunctions = ImmutableList.of(\n+            new JacksonRequestConverterFunction(),\n+            new StringRequestConverterFunction(),\n+            new ByteArrayRequestConverterFunction());\n+\n+    private static final List<RequestObjectResolver> defaultRequestConverters;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "315876939d7dcb885d0d878cc65fb3ce8c1645cf"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMDgyODY3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/internal/server/annotation/AnnotatedValueResolver.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQwNjo1MTo0M1rOHrsviQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQwNjo1MTo0M1rOHrsviQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU4Mzg4MQ==", "bodyText": "cannot -> failed to?", "url": "https://github.com/line/armeria/pull/3124#discussion_r515583881", "createdAt": "2020-11-01T06:51:43Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/internal/server/annotation/AnnotatedValueResolver.java", "diffHunk": "@@ -1423,4 +1463,34 @@ Object convert(ResolverContext resolverContext, Class<?> expectedResultType,\n             super(\"No parameters found from: \" + name);\n         }\n     }\n+\n+    private static final class CompositeRequestConverterFunction implements RequestConverterFunction {\n+\n+        private final List<RequestConverterFunction> functions;\n+\n+        private CompositeRequestConverterFunction(List<RequestConverterFunction> functions) {\n+            this.functions = functions;\n+        }\n+\n+        @Nullable\n+        @Override\n+        public Object convertRequest(ServiceRequestContext ctx, AggregatedHttpRequest request,\n+                                     Class<?> expectedResultType,\n+                                     @Nullable ParameterizedType expectedParameterizedResultType)\n+                throws Exception {\n+            for (RequestConverterFunction function : functions) {\n+                try {\n+                    return function.convertRequest(ctx, request, expectedResultType,\n+                                                   expectedParameterizedResultType);\n+                } catch (FallthroughException ignore) {\n+                    // Do nothing.\n+                } catch (Exception e) {\n+                    throw new IllegalStateException(\n+                            \"Request converter \" + function.getClass().getName() +\n+                            \" cannot convert an \" + request + \" to a \" + expectedResultType, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "315876939d7dcb885d0d878cc65fb3ce8c1645cf"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMDgzMDU0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/server/annotation/JacksonRequestConverterFunction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQwNjo1NDoxMFrOHrswWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMjo1NjoyOVrOHsexdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU4NDA5MQ==", "bodyText": "Could you explain why we need to skip Protobuf messages here?", "url": "https://github.com/line/armeria/pull/3124#discussion_r515584091", "createdAt": "2020-11-01T06:54:10Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/server/annotation/JacksonRequestConverterFunction.java", "diffHunk": "@@ -106,6 +120,10 @@ public Object convertRequest(\n                 }\n             }\n \n+            if (isProtobufType(expectedResultType, expectedParameterizedResultType)) {\n+                return RequestConverterFunction.fallthrough();\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "315876939d7dcb885d0d878cc65fb3ce8c1645cf"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQwMzU3Mg==", "bodyText": "Ah... We don't need to skip ProtoBuf message anymore.\nBefore implementing RequestConverterFunctionProvider, ProtobufRequestConverterFunction is registered after JacksonRequestConverterFunction.\nImmutableList.of(\n            new JacksonRequestConverterFunction(),\n            new ProtobufRequestConverterFunction(),\n            new StringRequestConverterFunction(),\n            new ByteArrayRequestConverterFunction());\nBut now, RequestConverterFunctionProviders have always higher priorities than defaultRequestConverterFunctions.", "url": "https://github.com/line/armeria/pull/3124#discussion_r516403572", "createdAt": "2020-11-03T02:56:29Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/server/annotation/JacksonRequestConverterFunction.java", "diffHunk": "@@ -106,6 +120,10 @@ public Object convertRequest(\n                 }\n             }\n \n+            if (isProtobufType(expectedResultType, expectedParameterizedResultType)) {\n+                return RequestConverterFunction.fallthrough();\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU4NDA5MQ=="}, "originalCommit": {"oid": "315876939d7dcb885d0d878cc65fb3ce8c1645cf"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMDgzNDc3OnYy", "diffSide": "RIGHT", "path": "grpc/build.gradle", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQwNjo1OToxMFrOHrsyQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMjozMDowMlrOHseaWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU4NDU3OQ==", "bodyText": "How about adding this to test-internal so we don't have to add this everywhere?", "url": "https://github.com/line/armeria/pull/3124#discussion_r515584579", "createdAt": "2020-11-01T06:59:10Z", "author": {"login": "trustin"}, "path": "grpc/build.gradle", "diffHunk": "@@ -20,6 +20,7 @@ dependencies {\n     testImplementation 'io.grpc:grpc-okhttp'\n     testImplementation 'io.grpc:grpc-testing'\n     testImplementation 'io.micrometer:micrometer-registry-prometheus'\n+    testImplementation 'io.projectreactor:reactor-test'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "315876939d7dcb885d0d878cc65fb3ce8c1645cf"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NzY1Ng==", "bodyText": "That's a good idea!", "url": "https://github.com/line/armeria/pull/3124#discussion_r516397656", "createdAt": "2020-11-03T02:30:02Z", "author": {"login": "ikhoon"}, "path": "grpc/build.gradle", "diffHunk": "@@ -20,6 +20,7 @@ dependencies {\n     testImplementation 'io.grpc:grpc-okhttp'\n     testImplementation 'io.grpc:grpc-testing'\n     testImplementation 'io.micrometer:micrometer-registry-prometheus'\n+    testImplementation 'io.projectreactor:reactor-test'", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU4NDU3OQ=="}, "originalCommit": {"oid": "315876939d7dcb885d0d878cc65fb3ce8c1645cf"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMDg0MDQyOnYy", "diffSide": "RIGHT", "path": "grpc/src/main/java/com/linecorp/armeria/server/grpc/ProtobufRequestConverterFunction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQwNzowNzoxMlrOHrs05g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQwNzowNzoxMlrOHrs05g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU4NTI1NA==", "bodyText": "Would it be better using toInputStream() instead of array() so that HttpData does not create a backing array?", "url": "https://github.com/line/armeria/pull/3124#discussion_r515585254", "createdAt": "2020-11-01T07:07:12Z", "author": {"login": "trustin"}, "path": "grpc/src/main/java/com/linecorp/armeria/server/grpc/ProtobufRequestConverterFunction.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.grpc;\n+\n+import static java.lang.invoke.MethodType.methodType;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.ParameterizedType;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableCollection;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.MapMaker;\n+import com.google.protobuf.ExtensionRegistry;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Parser;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+\n+/**\n+ * A {@link RequestConverterFunction} which converts a Protocol Buffers or JSON body of\n+ * the {@link AggregatedHttpRequest} to an object.\n+ * The built-in parser of {@link Message} for Protocol Buffers is applied only when the {@code content-type} of\n+ * {@link RequestHeaders} either {@link MediaType#PROTOBUF} or {@link MediaType#OCTET_STREAM} or\n+ * the {@link MediaType#subtype()} contains {@code \"protobuf\"}.\n+ * The {@link Parser} for JSON is applied only when the {@code content-type} of\n+ * the {@link RequestHeaders} is {@link MediaType#JSON} or ends with {@code +json}.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore a sequence of Protocol Buffer messages can not be handled by this {@link RequestConverterFunction}.\n+ * However a <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a> body\n+ * could be converted into a {@link Collection} type. e.g, {@code List<Message>} and {@code Set<Message>}.\n+ */\n+public final class ProtobufRequestConverterFunction implements RequestConverterFunction {\n+\n+    private static final ConcurrentMap<Class<?>, MethodHandle> methodCache =\n+            new MapMaker().weakKeys().makeMap();\n+    private static final Parser defaultJsonParser = JsonFormat.parser().ignoringUnknownFields();\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+\n+    private static final MethodHandle unknownMethodHandle;\n+\n+    static {\n+        final MethodHandles.Lookup publicLookup = MethodHandles.publicLookup();\n+        final MethodType mt = methodType(void.class);\n+\n+        MethodHandle methodHandle;\n+        try {\n+            methodHandle = publicLookup.findConstructor(ProtobufRequestConverterFunction.class, mt);\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            methodHandle = null;\n+        }\n+        assert methodHandle != null;\n+        unknownMethodHandle = methodHandle;\n+    }\n+\n+    private final ExtensionRegistry extensionRegistry;\n+    private final Parser jsonParser;\n+    private final ResultType resultType;\n+\n+    ProtobufRequestConverterFunction(ResultType resultType) {\n+        jsonParser = defaultJsonParser;\n+        extensionRegistry = ExtensionRegistry.getEmptyRegistry();\n+        this.resultType = resultType;\n+    }\n+\n+    /**\n+     * Creates an instance with the default {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction() {\n+        this(defaultJsonParser, ExtensionRegistry.getEmptyRegistry());\n+    }\n+\n+    /**\n+     * Creates an instance with the specified {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction(Parser jsonParser, ExtensionRegistry extensionRegistry) {\n+        this.jsonParser = jsonParser;\n+        this.extensionRegistry = extensionRegistry;\n+        resultType = ResultType.UNKNOWN;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public Object convertRequest(ServiceRequestContext ctx, AggregatedHttpRequest request,\n+                                 Class<?> expectedResultType,\n+                                 @Nullable ParameterizedType expectedParameterizedResultType) throws Exception {\n+\n+        final MediaType contentType = request.contentType();\n+        if (resultType == ResultType.PROTOBUF ||\n+            (resultType == ResultType.UNKNOWN && Message.class.isAssignableFrom(expectedResultType))) {\n+            final Message.Builder messageBuilder = getMessageBuilder(expectedResultType);\n+\n+            if (contentType == null ||\n+                contentType.subtype().contains(\"protobuf\") || contentType.is(MediaType.OCTET_STREAM)) {\n+                return messageBuilder.mergeFrom(request.content().array(), extensionRegistry).build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "315876939d7dcb885d0d878cc65fb3ce8c1645cf"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMDg0MTE3OnYy", "diffSide": "RIGHT", "path": "grpc/src/main/java/com/linecorp/armeria/server/grpc/ProtobufRequestConverterFunction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQwNzowODo0OFrOHrs1RQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxMzo1Mjo1NVrOHsvsgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU4NTM0OQ==", "bodyText": "Do we need to support map as well?", "url": "https://github.com/line/armeria/pull/3124#discussion_r515585349", "createdAt": "2020-11-01T07:08:48Z", "author": {"login": "trustin"}, "path": "grpc/src/main/java/com/linecorp/armeria/server/grpc/ProtobufRequestConverterFunction.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.grpc;\n+\n+import static java.lang.invoke.MethodType.methodType;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.ParameterizedType;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableCollection;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.MapMaker;\n+import com.google.protobuf.ExtensionRegistry;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Parser;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+\n+/**\n+ * A {@link RequestConverterFunction} which converts a Protocol Buffers or JSON body of\n+ * the {@link AggregatedHttpRequest} to an object.\n+ * The built-in parser of {@link Message} for Protocol Buffers is applied only when the {@code content-type} of\n+ * {@link RequestHeaders} either {@link MediaType#PROTOBUF} or {@link MediaType#OCTET_STREAM} or\n+ * the {@link MediaType#subtype()} contains {@code \"protobuf\"}.\n+ * The {@link Parser} for JSON is applied only when the {@code content-type} of\n+ * the {@link RequestHeaders} is {@link MediaType#JSON} or ends with {@code +json}.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore a sequence of Protocol Buffer messages can not be handled by this {@link RequestConverterFunction}.\n+ * However a <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a> body\n+ * could be converted into a {@link Collection} type. e.g, {@code List<Message>} and {@code Set<Message>}.\n+ */\n+public final class ProtobufRequestConverterFunction implements RequestConverterFunction {\n+\n+    private static final ConcurrentMap<Class<?>, MethodHandle> methodCache =\n+            new MapMaker().weakKeys().makeMap();\n+    private static final Parser defaultJsonParser = JsonFormat.parser().ignoringUnknownFields();\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+\n+    private static final MethodHandle unknownMethodHandle;\n+\n+    static {\n+        final MethodHandles.Lookup publicLookup = MethodHandles.publicLookup();\n+        final MethodType mt = methodType(void.class);\n+\n+        MethodHandle methodHandle;\n+        try {\n+            methodHandle = publicLookup.findConstructor(ProtobufRequestConverterFunction.class, mt);\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            methodHandle = null;\n+        }\n+        assert methodHandle != null;\n+        unknownMethodHandle = methodHandle;\n+    }\n+\n+    private final ExtensionRegistry extensionRegistry;\n+    private final Parser jsonParser;\n+    private final ResultType resultType;\n+\n+    ProtobufRequestConverterFunction(ResultType resultType) {\n+        jsonParser = defaultJsonParser;\n+        extensionRegistry = ExtensionRegistry.getEmptyRegistry();\n+        this.resultType = resultType;\n+    }\n+\n+    /**\n+     * Creates an instance with the default {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction() {\n+        this(defaultJsonParser, ExtensionRegistry.getEmptyRegistry());\n+    }\n+\n+    /**\n+     * Creates an instance with the specified {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction(Parser jsonParser, ExtensionRegistry extensionRegistry) {\n+        this.jsonParser = jsonParser;\n+        this.extensionRegistry = extensionRegistry;\n+        resultType = ResultType.UNKNOWN;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public Object convertRequest(ServiceRequestContext ctx, AggregatedHttpRequest request,\n+                                 Class<?> expectedResultType,\n+                                 @Nullable ParameterizedType expectedParameterizedResultType) throws Exception {\n+\n+        final MediaType contentType = request.contentType();\n+        if (resultType == ResultType.PROTOBUF ||\n+            (resultType == ResultType.UNKNOWN && Message.class.isAssignableFrom(expectedResultType))) {\n+            final Message.Builder messageBuilder = getMessageBuilder(expectedResultType);\n+\n+            if (contentType == null ||\n+                contentType.subtype().contains(\"protobuf\") || contentType.is(MediaType.OCTET_STREAM)) {\n+                return messageBuilder.mergeFrom(request.content().array(), extensionRegistry).build();\n+            }\n+\n+            if (isJson(contentType)) {\n+                jsonParser.merge(request.contentUtf8(), messageBuilder);\n+                return messageBuilder.build();\n+            }\n+        }\n+\n+        if (isJson(contentType) && expectedParameterizedResultType != null) {\n+            ResultType resultType = this.resultType;\n+            if (resultType == ResultType.UNKNOWN) {\n+                if (List.class.isAssignableFrom(expectedResultType)) {\n+                    resultType = ResultType.LIST_PROTOBUF;\n+                } else if (Set.class.isAssignableFrom(expectedResultType)) {\n+                    resultType = ResultType.SET_PROTOBUF;\n+                }\n+            }\n+\n+            if (resultType == ResultType.LIST_PROTOBUF || resultType == ResultType.SET_PROTOBUF) {\n+                final Class<?> typeArgument =\n+                        (Class<?>) expectedParameterizedResultType.getActualTypeArguments()[0];\n+                if (Message.class.isAssignableFrom(typeArgument)) {\n+                    final String content = request.content(contentType.charset(StandardCharsets.UTF_8));\n+\n+                    final JsonNode jsonNode = mapper.readTree(content);\n+                    if (jsonNode.isArray()) {\n+                        final ImmutableCollection.Builder<Message> builder;\n+                        if (resultType == ResultType.LIST_PROTOBUF) {\n+                            builder = ImmutableList.builderWithExpectedSize(jsonNode.size());\n+                        } else {\n+                            builder = ImmutableSet.builderWithExpectedSize(jsonNode.size());\n+                        }\n+                        for (JsonNode node : jsonNode) {\n+                            final Message.Builder messageBuilder = getMessageBuilder(typeArgument);\n+                            jsonParser.merge(mapper.writeValueAsString(node), messageBuilder);\n+                            builder.add(messageBuilder.build());\n+                        }\n+\n+                        return builder.build();\n+                    }\n+                }\n+            }\n+        }\n+\n+        return RequestConverterFunction.fallthrough();\n+    }\n+\n+    private static boolean isJson(@Nullable MediaType contentType) {\n+        return contentType != null &&\n+               (contentType.is(MediaType.JSON) || contentType.subtype().endsWith(\"+json\"));\n+    }\n+\n+    private static Message.Builder getMessageBuilder(Class<?> clazz) {\n+        final MethodHandle methodHandle = methodCache.computeIfAbsent(clazz, key -> {\n+            try {\n+                final Class<?> builderClass = Class.forName(key.getName() + \"$Builder\");\n+                final Lookup publicLookup = MethodHandles.publicLookup();\n+                return publicLookup.findStatic(key, \"newBuilder\", methodType(builderClass));\n+            } catch (NoSuchMethodException | IllegalAccessException | ClassNotFoundException ignored) {\n+                return unknownMethodHandle;\n+            }\n+        });\n+        if (methodHandle == unknownMethodHandle) {\n+            throw new IllegalStateException(\"Failed to find a static newBuilder() method from \" + clazz);\n+        }\n+        try {\n+            return (Message.Builder) methodHandle.invoke();\n+        } catch (Throwable throwable) {\n+            throw new IllegalStateException(\n+                    \"Failed to create an empty instance of \" + clazz + \" using newBuilder() method\", throwable);\n+        }\n+    }\n+\n+    enum ResultType {\n+        UNKNOWN,\n+        PROTOBUF,\n+        LIST_PROTOBUF,\n+        SET_PROTOBUF", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "315876939d7dcb885d0d878cc65fb3ce8c1645cf"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjY4MDgzMg==", "bodyText": "MAP_PROTOBUF is added for JSON format.", "url": "https://github.com/line/armeria/pull/3124#discussion_r516680832", "createdAt": "2020-11-03T13:52:55Z", "author": {"login": "ikhoon"}, "path": "grpc/src/main/java/com/linecorp/armeria/server/grpc/ProtobufRequestConverterFunction.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.grpc;\n+\n+import static java.lang.invoke.MethodType.methodType;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.ParameterizedType;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableCollection;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.MapMaker;\n+import com.google.protobuf.ExtensionRegistry;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Parser;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+\n+/**\n+ * A {@link RequestConverterFunction} which converts a Protocol Buffers or JSON body of\n+ * the {@link AggregatedHttpRequest} to an object.\n+ * The built-in parser of {@link Message} for Protocol Buffers is applied only when the {@code content-type} of\n+ * {@link RequestHeaders} either {@link MediaType#PROTOBUF} or {@link MediaType#OCTET_STREAM} or\n+ * the {@link MediaType#subtype()} contains {@code \"protobuf\"}.\n+ * The {@link Parser} for JSON is applied only when the {@code content-type} of\n+ * the {@link RequestHeaders} is {@link MediaType#JSON} or ends with {@code +json}.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore a sequence of Protocol Buffer messages can not be handled by this {@link RequestConverterFunction}.\n+ * However a <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a> body\n+ * could be converted into a {@link Collection} type. e.g, {@code List<Message>} and {@code Set<Message>}.\n+ */\n+public final class ProtobufRequestConverterFunction implements RequestConverterFunction {\n+\n+    private static final ConcurrentMap<Class<?>, MethodHandle> methodCache =\n+            new MapMaker().weakKeys().makeMap();\n+    private static final Parser defaultJsonParser = JsonFormat.parser().ignoringUnknownFields();\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+\n+    private static final MethodHandle unknownMethodHandle;\n+\n+    static {\n+        final MethodHandles.Lookup publicLookup = MethodHandles.publicLookup();\n+        final MethodType mt = methodType(void.class);\n+\n+        MethodHandle methodHandle;\n+        try {\n+            methodHandle = publicLookup.findConstructor(ProtobufRequestConverterFunction.class, mt);\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            methodHandle = null;\n+        }\n+        assert methodHandle != null;\n+        unknownMethodHandle = methodHandle;\n+    }\n+\n+    private final ExtensionRegistry extensionRegistry;\n+    private final Parser jsonParser;\n+    private final ResultType resultType;\n+\n+    ProtobufRequestConverterFunction(ResultType resultType) {\n+        jsonParser = defaultJsonParser;\n+        extensionRegistry = ExtensionRegistry.getEmptyRegistry();\n+        this.resultType = resultType;\n+    }\n+\n+    /**\n+     * Creates an instance with the default {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction() {\n+        this(defaultJsonParser, ExtensionRegistry.getEmptyRegistry());\n+    }\n+\n+    /**\n+     * Creates an instance with the specified {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction(Parser jsonParser, ExtensionRegistry extensionRegistry) {\n+        this.jsonParser = jsonParser;\n+        this.extensionRegistry = extensionRegistry;\n+        resultType = ResultType.UNKNOWN;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public Object convertRequest(ServiceRequestContext ctx, AggregatedHttpRequest request,\n+                                 Class<?> expectedResultType,\n+                                 @Nullable ParameterizedType expectedParameterizedResultType) throws Exception {\n+\n+        final MediaType contentType = request.contentType();\n+        if (resultType == ResultType.PROTOBUF ||\n+            (resultType == ResultType.UNKNOWN && Message.class.isAssignableFrom(expectedResultType))) {\n+            final Message.Builder messageBuilder = getMessageBuilder(expectedResultType);\n+\n+            if (contentType == null ||\n+                contentType.subtype().contains(\"protobuf\") || contentType.is(MediaType.OCTET_STREAM)) {\n+                return messageBuilder.mergeFrom(request.content().array(), extensionRegistry).build();\n+            }\n+\n+            if (isJson(contentType)) {\n+                jsonParser.merge(request.contentUtf8(), messageBuilder);\n+                return messageBuilder.build();\n+            }\n+        }\n+\n+        if (isJson(contentType) && expectedParameterizedResultType != null) {\n+            ResultType resultType = this.resultType;\n+            if (resultType == ResultType.UNKNOWN) {\n+                if (List.class.isAssignableFrom(expectedResultType)) {\n+                    resultType = ResultType.LIST_PROTOBUF;\n+                } else if (Set.class.isAssignableFrom(expectedResultType)) {\n+                    resultType = ResultType.SET_PROTOBUF;\n+                }\n+            }\n+\n+            if (resultType == ResultType.LIST_PROTOBUF || resultType == ResultType.SET_PROTOBUF) {\n+                final Class<?> typeArgument =\n+                        (Class<?>) expectedParameterizedResultType.getActualTypeArguments()[0];\n+                if (Message.class.isAssignableFrom(typeArgument)) {\n+                    final String content = request.content(contentType.charset(StandardCharsets.UTF_8));\n+\n+                    final JsonNode jsonNode = mapper.readTree(content);\n+                    if (jsonNode.isArray()) {\n+                        final ImmutableCollection.Builder<Message> builder;\n+                        if (resultType == ResultType.LIST_PROTOBUF) {\n+                            builder = ImmutableList.builderWithExpectedSize(jsonNode.size());\n+                        } else {\n+                            builder = ImmutableSet.builderWithExpectedSize(jsonNode.size());\n+                        }\n+                        for (JsonNode node : jsonNode) {\n+                            final Message.Builder messageBuilder = getMessageBuilder(typeArgument);\n+                            jsonParser.merge(mapper.writeValueAsString(node), messageBuilder);\n+                            builder.add(messageBuilder.build());\n+                        }\n+\n+                        return builder.build();\n+                    }\n+                }\n+            }\n+        }\n+\n+        return RequestConverterFunction.fallthrough();\n+    }\n+\n+    private static boolean isJson(@Nullable MediaType contentType) {\n+        return contentType != null &&\n+               (contentType.is(MediaType.JSON) || contentType.subtype().endsWith(\"+json\"));\n+    }\n+\n+    private static Message.Builder getMessageBuilder(Class<?> clazz) {\n+        final MethodHandle methodHandle = methodCache.computeIfAbsent(clazz, key -> {\n+            try {\n+                final Class<?> builderClass = Class.forName(key.getName() + \"$Builder\");\n+                final Lookup publicLookup = MethodHandles.publicLookup();\n+                return publicLookup.findStatic(key, \"newBuilder\", methodType(builderClass));\n+            } catch (NoSuchMethodException | IllegalAccessException | ClassNotFoundException ignored) {\n+                return unknownMethodHandle;\n+            }\n+        });\n+        if (methodHandle == unknownMethodHandle) {\n+            throw new IllegalStateException(\"Failed to find a static newBuilder() method from \" + clazz);\n+        }\n+        try {\n+            return (Message.Builder) methodHandle.invoke();\n+        } catch (Throwable throwable) {\n+            throw new IllegalStateException(\n+                    \"Failed to create an empty instance of \" + clazz + \" using newBuilder() method\", throwable);\n+        }\n+    }\n+\n+    enum ResultType {\n+        UNKNOWN,\n+        PROTOBUF,\n+        LIST_PROTOBUF,\n+        SET_PROTOBUF", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU4NTM0OQ=="}, "originalCommit": {"oid": "315876939d7dcb885d0d878cc65fb3ce8c1645cf"}, "originalPosition": 209}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMDg0MjEwOnYy", "diffSide": "RIGHT", "path": "grpc/src/main/java/com/linecorp/armeria/server/grpc/ProtobufResponseConverterFunctionProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQwNzowOTo0OFrOHrs1rA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQwNzowOTo0OFrOHrs1rA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU4NTQ1Mg==", "bodyText": "an -> a", "url": "https://github.com/line/armeria/pull/3124#discussion_r515585452", "createdAt": "2020-11-01T07:09:48Z", "author": {"login": "trustin"}, "path": "grpc/src/main/java/com/linecorp/armeria/server/grpc/ProtobufResponseConverterFunctionProvider.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright 2018 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.grpc;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.util.stream.Stream;\n+\n+import org.reactivestreams.Publisher;\n+\n+import com.google.protobuf.MessageLite;\n+\n+import com.linecorp.armeria.server.annotation.ExceptionHandlerFunction;\n+import com.linecorp.armeria.server.annotation.ResponseConverterFunction;\n+import com.linecorp.armeria.server.annotation.ResponseConverterFunctionProvider;\n+\n+/**\n+ * Provides an {@link ProtobufResponseConverterFunction} to annotated services.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "315876939d7dcb885d0d878cc65fb3ce8c1645cf"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMDg0MzE1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/server/annotation/RequestConverterFunctionProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQwNzoxMToxNlrOHrs2LQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQwNzoxMToxNlrOHrs2LQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU4NTU4MQ==", "bodyText": "Could you also check other classes and add @UnstableApi if applicable?", "url": "https://github.com/line/armeria/pull/3124#discussion_r515585581", "createdAt": "2020-11-01T07:11:16Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/server/annotation/RequestConverterFunctionProvider.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*\n+ * Copyright 2018 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.annotation;\n+\n+import java.lang.reflect.Type;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+\n+/**\n+ * A {@link RequestConverterFunction} provider interface which creates a new\n+ * {@link RequestConverterFunction} for converting an {@link AggregatedHttpRequest} to an object of\n+ * the given type.\n+ */\n+@UnstableApi", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "315876939d7dcb885d0d878cc65fb3ce8c1645cf"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDIzMTI0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/internal/server/annotation/AnnotatedValueResolver.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNjo1NzoxNFrOHuiI0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNjo1NzoxNFrOHuiI0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU1NTg1Ng==", "bodyText": "How about moving this class to another utility class with other CompositeXXXConverterFunction so that logics are put together?", "url": "https://github.com/line/armeria/pull/3124#discussion_r518555856", "createdAt": "2020-11-06T06:57:14Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/internal/server/annotation/AnnotatedValueResolver.java", "diffHunk": "@@ -1423,4 +1463,34 @@ Object convert(ResolverContext resolverContext, Class<?> expectedResultType,\n             super(\"No parameters found from: \" + name);\n         }\n     }\n+\n+    private static final class CompositeRequestConverterFunction implements RequestConverterFunction {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a3aad6b3e5df0a578985812008dea9bc82de713"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDIzNjEyOnYy", "diffSide": "RIGHT", "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufRequestConverterFunction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNjo1OTo0MFrOHuiLzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwNjo1MDoyMVrOHvgzEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU1NjYyMw==", "bodyText": "is either?", "url": "https://github.com/line/armeria/pull/3124#discussion_r518556623", "createdAt": "2020-11-06T06:59:40Z", "author": {"login": "minwoox"}, "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufRequestConverterFunction.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static com.linecorp.armeria.server.protobuf.ProtobufRequestConverterFunctionProvider.toResultType;\n+import static java.lang.invoke.MethodType.methodType;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableCollection;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.MapMaker;\n+import com.google.protobuf.ExtensionRegistry;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Parser;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+\n+/**\n+ * A {@link RequestConverterFunction} which converts a Protocol Buffers or JSON body of\n+ * the {@link AggregatedHttpRequest} to an object.\n+ * The built-in parser of {@link Message} for Protocol Buffers is applied only when the {@code content-type} of\n+ * {@link RequestHeaders} either {@link MediaType#PROTOBUF} or {@link MediaType#OCTET_STREAM} or", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a3aad6b3e5df0a578985812008dea9bc82de713"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4MjQ4Mw==", "bodyText": "either one of ... PROTOBUF and ... STREAM or the ...? (for disambiguation)", "url": "https://github.com/line/armeria/pull/3124#discussion_r519582483", "createdAt": "2020-11-09T06:50:21Z", "author": {"login": "trustin"}, "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufRequestConverterFunction.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static com.linecorp.armeria.server.protobuf.ProtobufRequestConverterFunctionProvider.toResultType;\n+import static java.lang.invoke.MethodType.methodType;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableCollection;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.MapMaker;\n+import com.google.protobuf.ExtensionRegistry;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Parser;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+\n+/**\n+ * A {@link RequestConverterFunction} which converts a Protocol Buffers or JSON body of\n+ * the {@link AggregatedHttpRequest} to an object.\n+ * The built-in parser of {@link Message} for Protocol Buffers is applied only when the {@code content-type} of\n+ * {@link RequestHeaders} either {@link MediaType#PROTOBUF} or {@link MediaType#OCTET_STREAM} or", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU1NjYyMw=="}, "originalCommit": {"oid": "1a3aad6b3e5df0a578985812008dea9bc82de713"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDI0MDE1OnYy", "diffSide": "RIGHT", "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufRequestConverterFunction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzowMTozNFrOHuiONg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzowMTozNFrOHuiONg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU1NzIzOA==", "bodyText": "self-delimiting character?", "url": "https://github.com/line/armeria/pull/3124#discussion_r518557238", "createdAt": "2020-11-06T07:01:34Z", "author": {"login": "minwoox"}, "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufRequestConverterFunction.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static com.linecorp.armeria.server.protobuf.ProtobufRequestConverterFunctionProvider.toResultType;\n+import static java.lang.invoke.MethodType.methodType;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableCollection;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.MapMaker;\n+import com.google.protobuf.ExtensionRegistry;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Parser;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+\n+/**\n+ * A {@link RequestConverterFunction} which converts a Protocol Buffers or JSON body of\n+ * the {@link AggregatedHttpRequest} to an object.\n+ * The built-in parser of {@link Message} for Protocol Buffers is applied only when the {@code content-type} of\n+ * {@link RequestHeaders} either {@link MediaType#PROTOBUF} or {@link MediaType#OCTET_STREAM} or\n+ * the {@link MediaType#subtype()} contains {@code \"protobuf\"}.\n+ * The {@link Parser} for JSON is applied only when the {@code content-type} of\n+ * the {@link RequestHeaders} is {@link MediaType#JSON} or ends with {@code +json}.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a3aad6b3e5df0a578985812008dea9bc82de713"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDI0MjYyOnYy", "diffSide": "RIGHT", "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufRequestConverterFunction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzowMjo1MFrOHuiPpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwNjo1MjoxMFrOHvg1VA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU1NzYwNQ==", "bodyText": "How about telling the users that making another message which wraps the sequence of messages?", "url": "https://github.com/line/armeria/pull/3124#discussion_r518557605", "createdAt": "2020-11-06T07:02:50Z", "author": {"login": "minwoox"}, "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufRequestConverterFunction.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static com.linecorp.armeria.server.protobuf.ProtobufRequestConverterFunctionProvider.toResultType;\n+import static java.lang.invoke.MethodType.methodType;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableCollection;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.MapMaker;\n+import com.google.protobuf.ExtensionRegistry;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Parser;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+\n+/**\n+ * A {@link RequestConverterFunction} which converts a Protocol Buffers or JSON body of\n+ * the {@link AggregatedHttpRequest} to an object.\n+ * The built-in parser of {@link Message} for Protocol Buffers is applied only when the {@code content-type} of\n+ * {@link RequestHeaders} either {@link MediaType#PROTOBUF} or {@link MediaType#OCTET_STREAM} or\n+ * the {@link MediaType#subtype()} contains {@code \"protobuf\"}.\n+ * The {@link Parser} for JSON is applied only when the {@code content-type} of\n+ * the {@link RequestHeaders} is {@link MediaType#JSON} or ends with {@code +json}.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore a sequence of Protocol Buffer messages can not be handled by this {@link RequestConverterFunction}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a3aad6b3e5df0a578985812008dea9bc82de713"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4MzA2MA==", "bodyText": "Could we also reorganize this paragraph like this, so it's easier to understand:\n<h3>Conversion of multiple Protobuf messages</h3>\nA sequence of Protocol Buffer messages cannot be handled ...,\nbecause the Protocol Buffers specification does not have an ...\nHowever, ... supported when converting to JSON, ...", "url": "https://github.com/line/armeria/pull/3124#discussion_r519583060", "createdAt": "2020-11-09T06:52:10Z", "author": {"login": "trustin"}, "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufRequestConverterFunction.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static com.linecorp.armeria.server.protobuf.ProtobufRequestConverterFunctionProvider.toResultType;\n+import static java.lang.invoke.MethodType.methodType;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableCollection;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.MapMaker;\n+import com.google.protobuf.ExtensionRegistry;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Parser;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+\n+/**\n+ * A {@link RequestConverterFunction} which converts a Protocol Buffers or JSON body of\n+ * the {@link AggregatedHttpRequest} to an object.\n+ * The built-in parser of {@link Message} for Protocol Buffers is applied only when the {@code content-type} of\n+ * {@link RequestHeaders} either {@link MediaType#PROTOBUF} or {@link MediaType#OCTET_STREAM} or\n+ * the {@link MediaType#subtype()} contains {@code \"protobuf\"}.\n+ * The {@link Parser} for JSON is applied only when the {@code content-type} of\n+ * the {@link RequestHeaders} is {@link MediaType#JSON} or ends with {@code +json}.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore a sequence of Protocol Buffer messages can not be handled by this {@link RequestConverterFunction}.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU1NzYwNQ=="}, "originalCommit": {"oid": "1a3aad6b3e5df0a578985812008dea9bc82de713"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDY2MTUyOnYy", "diffSide": "RIGHT", "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufRequestConverterFunction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwOToyMjoyNlrOHumLcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwOToyMjoyNlrOHumLcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYyMjA2Ng==", "bodyText": "nit: how about making a private constructor and delegating setting?", "url": "https://github.com/line/armeria/pull/3124#discussion_r518622066", "createdAt": "2020-11-06T09:22:26Z", "author": {"login": "minwoox"}, "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufRequestConverterFunction.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static com.linecorp.armeria.server.protobuf.ProtobufRequestConverterFunctionProvider.toResultType;\n+import static java.lang.invoke.MethodType.methodType;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableCollection;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.MapMaker;\n+import com.google.protobuf.ExtensionRegistry;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Parser;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+\n+/**\n+ * A {@link RequestConverterFunction} which converts a Protocol Buffers or JSON body of\n+ * the {@link AggregatedHttpRequest} to an object.\n+ * The built-in parser of {@link Message} for Protocol Buffers is applied only when the {@code content-type} of\n+ * {@link RequestHeaders} either {@link MediaType#PROTOBUF} or {@link MediaType#OCTET_STREAM} or\n+ * the {@link MediaType#subtype()} contains {@code \"protobuf\"}.\n+ * The {@link Parser} for JSON is applied only when the {@code content-type} of\n+ * the {@link RequestHeaders} is {@link MediaType#JSON} or ends with {@code +json}.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore a sequence of Protocol Buffer messages can not be handled by this {@link RequestConverterFunction}.\n+ * However a <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a> body\n+ * could be converted into a {@link Collection} type. e.g, {@code List<Message>} and {@code Set<Message>}.\n+ */\n+@UnstableApi\n+public final class ProtobufRequestConverterFunction implements RequestConverterFunction {\n+\n+    private static final ConcurrentMap<Class<?>, MethodHandle> methodCache =\n+            new MapMaker().weakKeys().makeMap();\n+    private static final Parser defaultJsonParser = JsonFormat.parser().ignoringUnknownFields();\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+\n+    private static final MethodHandle unknownMethodHandle;\n+\n+    static {\n+        final MethodHandles.Lookup publicLookup = MethodHandles.publicLookup();\n+        final MethodType mt = methodType(void.class);\n+\n+        MethodHandle methodHandle;\n+        try {\n+            methodHandle = publicLookup.findConstructor(ProtobufRequestConverterFunction.class, mt);\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            methodHandle = null;\n+        }\n+        assert methodHandle != null;\n+        unknownMethodHandle = methodHandle;\n+    }\n+\n+    private final ExtensionRegistry extensionRegistry;\n+    private final Parser jsonParser;\n+    private final ResultType resultType;\n+\n+    ProtobufRequestConverterFunction(ResultType resultType) {\n+        jsonParser = defaultJsonParser;\n+        extensionRegistry = ExtensionRegistry.getEmptyRegistry();\n+        this.resultType = requireNonNull(resultType, \"resultType\");\n+    }\n+\n+    /**\n+     * Creates an instance with the default {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction() {\n+        this(defaultJsonParser, ExtensionRegistry.getEmptyRegistry());\n+    }\n+\n+    /**\n+     * Creates an instance with the specified {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction(Parser jsonParser, ExtensionRegistry extensionRegistry) {\n+        this.jsonParser = requireNonNull(jsonParser, \"jsonParser\");\n+        this.extensionRegistry = requireNonNull(extensionRegistry, \"extensionRegistry\");\n+        resultType = ResultType.UNKNOWN;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a3aad6b3e5df0a578985812008dea9bc82de713"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDY5MjEzOnYy", "diffSide": "RIGHT", "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufRequestConverterFunction.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwOTozMDowNFrOHumduA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwOTo1OTozNVrOHvnCkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYyNjc0NA==", "bodyText": "Shouldn't we use charset?\njsonParser.merge(request.content().toReader(contentType.charset(Charsets.UTF_8)), ...", "url": "https://github.com/line/armeria/pull/3124#discussion_r518626744", "createdAt": "2020-11-06T09:30:04Z", "author": {"login": "minwoox"}, "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufRequestConverterFunction.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static com.linecorp.armeria.server.protobuf.ProtobufRequestConverterFunctionProvider.toResultType;\n+import static java.lang.invoke.MethodType.methodType;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableCollection;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.MapMaker;\n+import com.google.protobuf.ExtensionRegistry;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Parser;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+\n+/**\n+ * A {@link RequestConverterFunction} which converts a Protocol Buffers or JSON body of\n+ * the {@link AggregatedHttpRequest} to an object.\n+ * The built-in parser of {@link Message} for Protocol Buffers is applied only when the {@code content-type} of\n+ * {@link RequestHeaders} either {@link MediaType#PROTOBUF} or {@link MediaType#OCTET_STREAM} or\n+ * the {@link MediaType#subtype()} contains {@code \"protobuf\"}.\n+ * The {@link Parser} for JSON is applied only when the {@code content-type} of\n+ * the {@link RequestHeaders} is {@link MediaType#JSON} or ends with {@code +json}.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore a sequence of Protocol Buffer messages can not be handled by this {@link RequestConverterFunction}.\n+ * However a <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a> body\n+ * could be converted into a {@link Collection} type. e.g, {@code List<Message>} and {@code Set<Message>}.\n+ */\n+@UnstableApi\n+public final class ProtobufRequestConverterFunction implements RequestConverterFunction {\n+\n+    private static final ConcurrentMap<Class<?>, MethodHandle> methodCache =\n+            new MapMaker().weakKeys().makeMap();\n+    private static final Parser defaultJsonParser = JsonFormat.parser().ignoringUnknownFields();\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+\n+    private static final MethodHandle unknownMethodHandle;\n+\n+    static {\n+        final MethodHandles.Lookup publicLookup = MethodHandles.publicLookup();\n+        final MethodType mt = methodType(void.class);\n+\n+        MethodHandle methodHandle;\n+        try {\n+            methodHandle = publicLookup.findConstructor(ProtobufRequestConverterFunction.class, mt);\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            methodHandle = null;\n+        }\n+        assert methodHandle != null;\n+        unknownMethodHandle = methodHandle;\n+    }\n+\n+    private final ExtensionRegistry extensionRegistry;\n+    private final Parser jsonParser;\n+    private final ResultType resultType;\n+\n+    ProtobufRequestConverterFunction(ResultType resultType) {\n+        jsonParser = defaultJsonParser;\n+        extensionRegistry = ExtensionRegistry.getEmptyRegistry();\n+        this.resultType = requireNonNull(resultType, \"resultType\");\n+    }\n+\n+    /**\n+     * Creates an instance with the default {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction() {\n+        this(defaultJsonParser, ExtensionRegistry.getEmptyRegistry());\n+    }\n+\n+    /**\n+     * Creates an instance with the specified {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction(Parser jsonParser, ExtensionRegistry extensionRegistry) {\n+        this.jsonParser = requireNonNull(jsonParser, \"jsonParser\");\n+        this.extensionRegistry = requireNonNull(extensionRegistry, \"extensionRegistry\");\n+        resultType = ResultType.UNKNOWN;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public Object convertRequest(ServiceRequestContext ctx, AggregatedHttpRequest request,\n+                                 Class<?> expectedResultType,\n+                                 @Nullable ParameterizedType expectedParameterizedResultType) throws Exception {\n+\n+        final MediaType contentType = request.contentType();\n+        if (resultType == ResultType.PROTOBUF ||\n+            (resultType == ResultType.UNKNOWN && Message.class.isAssignableFrom(expectedResultType))) {\n+            final Message.Builder messageBuilder = getMessageBuilder(expectedResultType);\n+\n+            if (contentType == null ||\n+                contentType.subtype().contains(\"protobuf\") || contentType.is(MediaType.OCTET_STREAM)) {\n+                try (InputStream is = request.content().toInputStream()) {\n+                    return messageBuilder.mergeFrom(is, extensionRegistry).build();\n+                }\n+            }\n+\n+            if (isJson(contentType)) {\n+                jsonParser.merge(request.contentUtf8(), messageBuilder);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a3aad6b3e5df0a578985812008dea9bc82de713"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTYzMjA0NQ==", "bodyText": "I thought UTF-8 is only used for JSON.\nJust out of curiosity, which is better toReader(Charset) or content(Charset) here?\nIf you are also curious, let me run a simple benchmark for it. \ud83d\ude09", "url": "https://github.com/line/armeria/pull/3124#discussion_r519632045", "createdAt": "2020-11-09T08:35:13Z", "author": {"login": "ikhoon"}, "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufRequestConverterFunction.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static com.linecorp.armeria.server.protobuf.ProtobufRequestConverterFunctionProvider.toResultType;\n+import static java.lang.invoke.MethodType.methodType;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableCollection;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.MapMaker;\n+import com.google.protobuf.ExtensionRegistry;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Parser;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+\n+/**\n+ * A {@link RequestConverterFunction} which converts a Protocol Buffers or JSON body of\n+ * the {@link AggregatedHttpRequest} to an object.\n+ * The built-in parser of {@link Message} for Protocol Buffers is applied only when the {@code content-type} of\n+ * {@link RequestHeaders} either {@link MediaType#PROTOBUF} or {@link MediaType#OCTET_STREAM} or\n+ * the {@link MediaType#subtype()} contains {@code \"protobuf\"}.\n+ * The {@link Parser} for JSON is applied only when the {@code content-type} of\n+ * the {@link RequestHeaders} is {@link MediaType#JSON} or ends with {@code +json}.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore a sequence of Protocol Buffer messages can not be handled by this {@link RequestConverterFunction}.\n+ * However a <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a> body\n+ * could be converted into a {@link Collection} type. e.g, {@code List<Message>} and {@code Set<Message>}.\n+ */\n+@UnstableApi\n+public final class ProtobufRequestConverterFunction implements RequestConverterFunction {\n+\n+    private static final ConcurrentMap<Class<?>, MethodHandle> methodCache =\n+            new MapMaker().weakKeys().makeMap();\n+    private static final Parser defaultJsonParser = JsonFormat.parser().ignoringUnknownFields();\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+\n+    private static final MethodHandle unknownMethodHandle;\n+\n+    static {\n+        final MethodHandles.Lookup publicLookup = MethodHandles.publicLookup();\n+        final MethodType mt = methodType(void.class);\n+\n+        MethodHandle methodHandle;\n+        try {\n+            methodHandle = publicLookup.findConstructor(ProtobufRequestConverterFunction.class, mt);\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            methodHandle = null;\n+        }\n+        assert methodHandle != null;\n+        unknownMethodHandle = methodHandle;\n+    }\n+\n+    private final ExtensionRegistry extensionRegistry;\n+    private final Parser jsonParser;\n+    private final ResultType resultType;\n+\n+    ProtobufRequestConverterFunction(ResultType resultType) {\n+        jsonParser = defaultJsonParser;\n+        extensionRegistry = ExtensionRegistry.getEmptyRegistry();\n+        this.resultType = requireNonNull(resultType, \"resultType\");\n+    }\n+\n+    /**\n+     * Creates an instance with the default {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction() {\n+        this(defaultJsonParser, ExtensionRegistry.getEmptyRegistry());\n+    }\n+\n+    /**\n+     * Creates an instance with the specified {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction(Parser jsonParser, ExtensionRegistry extensionRegistry) {\n+        this.jsonParser = requireNonNull(jsonParser, \"jsonParser\");\n+        this.extensionRegistry = requireNonNull(extensionRegistry, \"extensionRegistry\");\n+        resultType = ResultType.UNKNOWN;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public Object convertRequest(ServiceRequestContext ctx, AggregatedHttpRequest request,\n+                                 Class<?> expectedResultType,\n+                                 @Nullable ParameterizedType expectedParameterizedResultType) throws Exception {\n+\n+        final MediaType contentType = request.contentType();\n+        if (resultType == ResultType.PROTOBUF ||\n+            (resultType == ResultType.UNKNOWN && Message.class.isAssignableFrom(expectedResultType))) {\n+            final Message.Builder messageBuilder = getMessageBuilder(expectedResultType);\n+\n+            if (contentType == null ||\n+                contentType.subtype().contains(\"protobuf\") || contentType.is(MediaType.OCTET_STREAM)) {\n+                try (InputStream is = request.content().toInputStream()) {\n+                    return messageBuilder.mergeFrom(is, extensionRegistry).build();\n+                }\n+            }\n+\n+            if (isJson(contentType)) {\n+                jsonParser.merge(request.contentUtf8(), messageBuilder);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYyNjc0NA=="}, "originalCommit": {"oid": "1a3aad6b3e5df0a578985812008dea9bc82de713"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTYzNTM0OQ==", "bodyText": "I think using the reader was more efficient but not 100% sure. \ud83d\ude04\nCould you run the benchmark if you don't mind?", "url": "https://github.com/line/armeria/pull/3124#discussion_r519635349", "createdAt": "2020-11-09T08:41:03Z", "author": {"login": "minwoox"}, "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufRequestConverterFunction.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static com.linecorp.armeria.server.protobuf.ProtobufRequestConverterFunctionProvider.toResultType;\n+import static java.lang.invoke.MethodType.methodType;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableCollection;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.MapMaker;\n+import com.google.protobuf.ExtensionRegistry;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Parser;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+\n+/**\n+ * A {@link RequestConverterFunction} which converts a Protocol Buffers or JSON body of\n+ * the {@link AggregatedHttpRequest} to an object.\n+ * The built-in parser of {@link Message} for Protocol Buffers is applied only when the {@code content-type} of\n+ * {@link RequestHeaders} either {@link MediaType#PROTOBUF} or {@link MediaType#OCTET_STREAM} or\n+ * the {@link MediaType#subtype()} contains {@code \"protobuf\"}.\n+ * The {@link Parser} for JSON is applied only when the {@code content-type} of\n+ * the {@link RequestHeaders} is {@link MediaType#JSON} or ends with {@code +json}.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore a sequence of Protocol Buffer messages can not be handled by this {@link RequestConverterFunction}.\n+ * However a <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a> body\n+ * could be converted into a {@link Collection} type. e.g, {@code List<Message>} and {@code Set<Message>}.\n+ */\n+@UnstableApi\n+public final class ProtobufRequestConverterFunction implements RequestConverterFunction {\n+\n+    private static final ConcurrentMap<Class<?>, MethodHandle> methodCache =\n+            new MapMaker().weakKeys().makeMap();\n+    private static final Parser defaultJsonParser = JsonFormat.parser().ignoringUnknownFields();\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+\n+    private static final MethodHandle unknownMethodHandle;\n+\n+    static {\n+        final MethodHandles.Lookup publicLookup = MethodHandles.publicLookup();\n+        final MethodType mt = methodType(void.class);\n+\n+        MethodHandle methodHandle;\n+        try {\n+            methodHandle = publicLookup.findConstructor(ProtobufRequestConverterFunction.class, mt);\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            methodHandle = null;\n+        }\n+        assert methodHandle != null;\n+        unknownMethodHandle = methodHandle;\n+    }\n+\n+    private final ExtensionRegistry extensionRegistry;\n+    private final Parser jsonParser;\n+    private final ResultType resultType;\n+\n+    ProtobufRequestConverterFunction(ResultType resultType) {\n+        jsonParser = defaultJsonParser;\n+        extensionRegistry = ExtensionRegistry.getEmptyRegistry();\n+        this.resultType = requireNonNull(resultType, \"resultType\");\n+    }\n+\n+    /**\n+     * Creates an instance with the default {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction() {\n+        this(defaultJsonParser, ExtensionRegistry.getEmptyRegistry());\n+    }\n+\n+    /**\n+     * Creates an instance with the specified {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction(Parser jsonParser, ExtensionRegistry extensionRegistry) {\n+        this.jsonParser = requireNonNull(jsonParser, \"jsonParser\");\n+        this.extensionRegistry = requireNonNull(extensionRegistry, \"extensionRegistry\");\n+        resultType = ResultType.UNKNOWN;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public Object convertRequest(ServiceRequestContext ctx, AggregatedHttpRequest request,\n+                                 Class<?> expectedResultType,\n+                                 @Nullable ParameterizedType expectedParameterizedResultType) throws Exception {\n+\n+        final MediaType contentType = request.contentType();\n+        if (resultType == ResultType.PROTOBUF ||\n+            (resultType == ResultType.UNKNOWN && Message.class.isAssignableFrom(expectedResultType))) {\n+            final Message.Builder messageBuilder = getMessageBuilder(expectedResultType);\n+\n+            if (contentType == null ||\n+                contentType.subtype().contains(\"protobuf\") || contentType.is(MediaType.OCTET_STREAM)) {\n+                try (InputStream is = request.content().toInputStream()) {\n+                    return messageBuilder.mergeFrom(is, extensionRegistry).build();\n+                }\n+            }\n+\n+            if (isJson(contentType)) {\n+                jsonParser.merge(request.contentUtf8(), messageBuilder);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYyNjc0NA=="}, "originalCommit": {"oid": "1a3aad6b3e5df0a578985812008dea9bc82de713"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY4MTEyOA==", "bodyText": "There is no big difference among them. contentUtf8() is 3% ~ 4% faster. It seems that within tolerance.\nGrpcParseBenchmark.parseWithReader  thrpt    5  777.928 \u00b1 4.739  ops/s\nGrpcParseBenchmark.parseWithString  thrpt    5  806.419 \u00b1 8.637  ops/s\n\nThe benchmark code:\nstatic final String json = JsonFormat.printer().print(SEARCH_RESPONSE);\nstatic final HttpData httpData = HttpData.wrap(json.getBytes(StandardCharsets.UTF_8));\nstatic final Parser parser = JsonFormat.parser();\n\n@Benchmark\npublic SearchResponse parseWithString() throws InvalidProtocolBufferException {\n    final SearchResponse.Builder builder = SearchResponse.newBuilder();\n    parser.merge(httpData.toStringUtf8(), builder);\n    return builder.build();\n}\n\n@Benchmark\npublic SearchResponse parseWithReader() throws IOException {\n    final SearchResponse.Builder builder = SearchResponse.newBuilder();\n    parser.merge(httpData.toReader(StandardCharsets.UTF_8), builder);\n    return builder.build();\n}", "url": "https://github.com/line/armeria/pull/3124#discussion_r519681128", "createdAt": "2020-11-09T09:54:30Z", "author": {"login": "ikhoon"}, "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufRequestConverterFunction.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static com.linecorp.armeria.server.protobuf.ProtobufRequestConverterFunctionProvider.toResultType;\n+import static java.lang.invoke.MethodType.methodType;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableCollection;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.MapMaker;\n+import com.google.protobuf.ExtensionRegistry;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Parser;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+\n+/**\n+ * A {@link RequestConverterFunction} which converts a Protocol Buffers or JSON body of\n+ * the {@link AggregatedHttpRequest} to an object.\n+ * The built-in parser of {@link Message} for Protocol Buffers is applied only when the {@code content-type} of\n+ * {@link RequestHeaders} either {@link MediaType#PROTOBUF} or {@link MediaType#OCTET_STREAM} or\n+ * the {@link MediaType#subtype()} contains {@code \"protobuf\"}.\n+ * The {@link Parser} for JSON is applied only when the {@code content-type} of\n+ * the {@link RequestHeaders} is {@link MediaType#JSON} or ends with {@code +json}.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore a sequence of Protocol Buffer messages can not be handled by this {@link RequestConverterFunction}.\n+ * However a <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a> body\n+ * could be converted into a {@link Collection} type. e.g, {@code List<Message>} and {@code Set<Message>}.\n+ */\n+@UnstableApi\n+public final class ProtobufRequestConverterFunction implements RequestConverterFunction {\n+\n+    private static final ConcurrentMap<Class<?>, MethodHandle> methodCache =\n+            new MapMaker().weakKeys().makeMap();\n+    private static final Parser defaultJsonParser = JsonFormat.parser().ignoringUnknownFields();\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+\n+    private static final MethodHandle unknownMethodHandle;\n+\n+    static {\n+        final MethodHandles.Lookup publicLookup = MethodHandles.publicLookup();\n+        final MethodType mt = methodType(void.class);\n+\n+        MethodHandle methodHandle;\n+        try {\n+            methodHandle = publicLookup.findConstructor(ProtobufRequestConverterFunction.class, mt);\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            methodHandle = null;\n+        }\n+        assert methodHandle != null;\n+        unknownMethodHandle = methodHandle;\n+    }\n+\n+    private final ExtensionRegistry extensionRegistry;\n+    private final Parser jsonParser;\n+    private final ResultType resultType;\n+\n+    ProtobufRequestConverterFunction(ResultType resultType) {\n+        jsonParser = defaultJsonParser;\n+        extensionRegistry = ExtensionRegistry.getEmptyRegistry();\n+        this.resultType = requireNonNull(resultType, \"resultType\");\n+    }\n+\n+    /**\n+     * Creates an instance with the default {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction() {\n+        this(defaultJsonParser, ExtensionRegistry.getEmptyRegistry());\n+    }\n+\n+    /**\n+     * Creates an instance with the specified {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction(Parser jsonParser, ExtensionRegistry extensionRegistry) {\n+        this.jsonParser = requireNonNull(jsonParser, \"jsonParser\");\n+        this.extensionRegistry = requireNonNull(extensionRegistry, \"extensionRegistry\");\n+        resultType = ResultType.UNKNOWN;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public Object convertRequest(ServiceRequestContext ctx, AggregatedHttpRequest request,\n+                                 Class<?> expectedResultType,\n+                                 @Nullable ParameterizedType expectedParameterizedResultType) throws Exception {\n+\n+        final MediaType contentType = request.contentType();\n+        if (resultType == ResultType.PROTOBUF ||\n+            (resultType == ResultType.UNKNOWN && Message.class.isAssignableFrom(expectedResultType))) {\n+            final Message.Builder messageBuilder = getMessageBuilder(expectedResultType);\n+\n+            if (contentType == null ||\n+                contentType.subtype().contains(\"protobuf\") || contentType.is(MediaType.OCTET_STREAM)) {\n+                try (InputStream is = request.content().toInputStream()) {\n+                    return messageBuilder.mergeFrom(is, extensionRegistry).build();\n+                }\n+            }\n+\n+            if (isJson(contentType)) {\n+                jsonParser.merge(request.contentUtf8(), messageBuilder);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYyNjc0NA=="}, "originalCommit": {"oid": "1a3aad6b3e5df0a578985812008dea9bc82de713"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY4NDc1Mw==", "bodyText": "Thanks for the test, yeah using contentUtf8 seems more efficient. \ud83d\ude04", "url": "https://github.com/line/armeria/pull/3124#discussion_r519684753", "createdAt": "2020-11-09T09:59:35Z", "author": {"login": "minwoox"}, "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufRequestConverterFunction.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static com.linecorp.armeria.server.protobuf.ProtobufRequestConverterFunctionProvider.toResultType;\n+import static java.lang.invoke.MethodType.methodType;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableCollection;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.MapMaker;\n+import com.google.protobuf.ExtensionRegistry;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Parser;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+\n+/**\n+ * A {@link RequestConverterFunction} which converts a Protocol Buffers or JSON body of\n+ * the {@link AggregatedHttpRequest} to an object.\n+ * The built-in parser of {@link Message} for Protocol Buffers is applied only when the {@code content-type} of\n+ * {@link RequestHeaders} either {@link MediaType#PROTOBUF} or {@link MediaType#OCTET_STREAM} or\n+ * the {@link MediaType#subtype()} contains {@code \"protobuf\"}.\n+ * The {@link Parser} for JSON is applied only when the {@code content-type} of\n+ * the {@link RequestHeaders} is {@link MediaType#JSON} or ends with {@code +json}.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore a sequence of Protocol Buffer messages can not be handled by this {@link RequestConverterFunction}.\n+ * However a <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a> body\n+ * could be converted into a {@link Collection} type. e.g, {@code List<Message>} and {@code Set<Message>}.\n+ */\n+@UnstableApi\n+public final class ProtobufRequestConverterFunction implements RequestConverterFunction {\n+\n+    private static final ConcurrentMap<Class<?>, MethodHandle> methodCache =\n+            new MapMaker().weakKeys().makeMap();\n+    private static final Parser defaultJsonParser = JsonFormat.parser().ignoringUnknownFields();\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+\n+    private static final MethodHandle unknownMethodHandle;\n+\n+    static {\n+        final MethodHandles.Lookup publicLookup = MethodHandles.publicLookup();\n+        final MethodType mt = methodType(void.class);\n+\n+        MethodHandle methodHandle;\n+        try {\n+            methodHandle = publicLookup.findConstructor(ProtobufRequestConverterFunction.class, mt);\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            methodHandle = null;\n+        }\n+        assert methodHandle != null;\n+        unknownMethodHandle = methodHandle;\n+    }\n+\n+    private final ExtensionRegistry extensionRegistry;\n+    private final Parser jsonParser;\n+    private final ResultType resultType;\n+\n+    ProtobufRequestConverterFunction(ResultType resultType) {\n+        jsonParser = defaultJsonParser;\n+        extensionRegistry = ExtensionRegistry.getEmptyRegistry();\n+        this.resultType = requireNonNull(resultType, \"resultType\");\n+    }\n+\n+    /**\n+     * Creates an instance with the default {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction() {\n+        this(defaultJsonParser, ExtensionRegistry.getEmptyRegistry());\n+    }\n+\n+    /**\n+     * Creates an instance with the specified {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction(Parser jsonParser, ExtensionRegistry extensionRegistry) {\n+        this.jsonParser = requireNonNull(jsonParser, \"jsonParser\");\n+        this.extensionRegistry = requireNonNull(extensionRegistry, \"extensionRegistry\");\n+        resultType = ResultType.UNKNOWN;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public Object convertRequest(ServiceRequestContext ctx, AggregatedHttpRequest request,\n+                                 Class<?> expectedResultType,\n+                                 @Nullable ParameterizedType expectedParameterizedResultType) throws Exception {\n+\n+        final MediaType contentType = request.contentType();\n+        if (resultType == ResultType.PROTOBUF ||\n+            (resultType == ResultType.UNKNOWN && Message.class.isAssignableFrom(expectedResultType))) {\n+            final Message.Builder messageBuilder = getMessageBuilder(expectedResultType);\n+\n+            if (contentType == null ||\n+                contentType.subtype().contains(\"protobuf\") || contentType.is(MediaType.OCTET_STREAM)) {\n+                try (InputStream is = request.content().toInputStream()) {\n+                    return messageBuilder.mergeFrom(is, extensionRegistry).build();\n+                }\n+            }\n+\n+            if (isJson(contentType)) {\n+                jsonParser.merge(request.contentUtf8(), messageBuilder);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYyNjc0NA=="}, "originalCommit": {"oid": "1a3aad6b3e5df0a578985812008dea9bc82de713"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDc1MTgwOnYy", "diffSide": "RIGHT", "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufResponseConverterFunction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwOTo0NjowNFrOHunCSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwNzowMDozMVrOHvg_0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYzNjEwNw==", "bodyText": "So this is not working if the charset is not UTF_8, right?", "url": "https://github.com/line/armeria/pull/3124#discussion_r518636107", "createdAt": "2020-11-06T09:46:04Z", "author": {"login": "minwoox"}, "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufResponseConverterFunction.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.linecorp.armeria.internal.server.ResponseConversionUtil.aggregateFrom;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Publisher;\n+\n+import com.google.common.collect.Streams;\n+import com.google.protobuf.MessageLite;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Printer;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.ResponseConverterFunction;\n+\n+/**\n+ * A {@link ResponseConverterFunction} which creates an {@link HttpResponse} with\n+ * {@code content-type: application/protobuf} or {@code content-type: application/json; charset=utf-8}.\n+ * If the returned object is instance of {@link MessageLite}, the object can be converted to\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/encoding\">Protocol Buffers</a> or\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/proto3#json\">JSON</a> format.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore if the returned object is instance of {@link Publisher}, {@link Stream} or {@link Iterable}\n+ * which produces {@link MessageLite}s, the object is only able to convert to\n+ * <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a> format.\n+ *\n+ * <p>Note that this {@link ResponseConverterFunction} is applied to the annotated service by default,\n+ * so you don't have to set explicitly unless you want to use your own {@link Printer}.\n+ */\n+@UnstableApi\n+public final class ProtobufResponseConverterFunction implements ResponseConverterFunction {\n+\n+    private static final Printer defaultJsonPrinter = JsonFormat.printer();\n+\n+    private final Printer jsonPrinter;\n+\n+    /**\n+     * Creates an instance with the default {@link Printer}.\n+     */\n+    public ProtobufResponseConverterFunction() {\n+        this(defaultJsonPrinter);\n+    }\n+\n+    /**\n+     * Creates an instance with the specified {@link Printer}.\n+     */\n+    public ProtobufResponseConverterFunction(Printer jsonPrinter) {\n+        this.jsonPrinter = requireNonNull(jsonPrinter, \"jsonPrinter\");\n+    }\n+\n+    @Override\n+    public HttpResponse convertResponse(ServiceRequestContext ctx, ResponseHeaders headers,\n+                                        @Nullable Object result, HttpHeaders trailers) throws Exception {\n+        final MediaType mediaType = headers.contentType();\n+        if (result instanceof MessageLite) {\n+            if (mediaType != null) {\n+                if (mediaType.is(MediaType.JSON) || mediaType.subtype().endsWith(\"+json\")) {\n+                    final Charset charset = mediaType.charset(StandardCharsets.UTF_8);\n+                    if (charset.contains(StandardCharsets.UTF_8)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a3aad6b3e5df0a578985812008dea9bc82de713"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4NTc0Nw==", "bodyText": "Maybe we can support other encodings as well?", "url": "https://github.com/line/armeria/pull/3124#discussion_r519585747", "createdAt": "2020-11-09T07:00:31Z", "author": {"login": "trustin"}, "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufResponseConverterFunction.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.linecorp.armeria.internal.server.ResponseConversionUtil.aggregateFrom;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Publisher;\n+\n+import com.google.common.collect.Streams;\n+import com.google.protobuf.MessageLite;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Printer;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.ResponseConverterFunction;\n+\n+/**\n+ * A {@link ResponseConverterFunction} which creates an {@link HttpResponse} with\n+ * {@code content-type: application/protobuf} or {@code content-type: application/json; charset=utf-8}.\n+ * If the returned object is instance of {@link MessageLite}, the object can be converted to\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/encoding\">Protocol Buffers</a> or\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/proto3#json\">JSON</a> format.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore if the returned object is instance of {@link Publisher}, {@link Stream} or {@link Iterable}\n+ * which produces {@link MessageLite}s, the object is only able to convert to\n+ * <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a> format.\n+ *\n+ * <p>Note that this {@link ResponseConverterFunction} is applied to the annotated service by default,\n+ * so you don't have to set explicitly unless you want to use your own {@link Printer}.\n+ */\n+@UnstableApi\n+public final class ProtobufResponseConverterFunction implements ResponseConverterFunction {\n+\n+    private static final Printer defaultJsonPrinter = JsonFormat.printer();\n+\n+    private final Printer jsonPrinter;\n+\n+    /**\n+     * Creates an instance with the default {@link Printer}.\n+     */\n+    public ProtobufResponseConverterFunction() {\n+        this(defaultJsonPrinter);\n+    }\n+\n+    /**\n+     * Creates an instance with the specified {@link Printer}.\n+     */\n+    public ProtobufResponseConverterFunction(Printer jsonPrinter) {\n+        this.jsonPrinter = requireNonNull(jsonPrinter, \"jsonPrinter\");\n+    }\n+\n+    @Override\n+    public HttpResponse convertResponse(ServiceRequestContext ctx, ResponseHeaders headers,\n+                                        @Nullable Object result, HttpHeaders trailers) throws Exception {\n+        final MediaType mediaType = headers.contentType();\n+        if (result instanceof MessageLite) {\n+            if (mediaType != null) {\n+                if (mediaType.is(MediaType.JSON) || mediaType.subtype().endsWith(\"+json\")) {\n+                    final Charset charset = mediaType.charset(StandardCharsets.UTF_8);\n+                    if (charset.contains(StandardCharsets.UTF_8)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYzNjEwNw=="}, "originalCommit": {"oid": "1a3aad6b3e5df0a578985812008dea9bc82de713"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDc5ODI3OnYy", "diffSide": "RIGHT", "path": "site/src/pages/docs/setup.mdx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwOTo1OTowMlrOHunfOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwOTo1OTowMlrOHunfOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY0MzUxNQ==", "bodyText": "Support Protocol Buffers in annotated service?", "url": "https://github.com/line/armeria/pull/3124#discussion_r518643515", "createdAt": "2020-11-06T09:59:02Z", "author": {"login": "minwoox"}, "path": "site/src/pages/docs/setup.mdx", "diffHunk": "@@ -50,6 +50,8 @@ the list of major Armeria artifacts which might interest you:\n |                                             | request information.                                                            |\n |                                             | See [Logging contextual information](/docs/advanced-logging).                   |\n +---------------------------------------------+---------------------------------------------------------------------------------+\n+| `armeria-protobuf`                          | Protocol Buffers support.                                                       |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a3aad6b3e5df0a578985812008dea9bc82de713"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1Njg1MDI5OnYy", "diffSide": "RIGHT", "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufResponseConverterFunction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwNDowMzoyM1rOHveTig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxMToyNjo0M1rOHvqQqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU0MTY0Mg==", "bodyText": "Maybe check more strictly?", "url": "https://github.com/line/armeria/pull/3124#discussion_r519541642", "createdAt": "2020-11-09T04:03:23Z", "author": {"login": "trustin"}, "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufResponseConverterFunction.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.linecorp.armeria.internal.server.ResponseConversionUtil.aggregateFrom;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Publisher;\n+\n+import com.google.common.collect.Streams;\n+import com.google.protobuf.MessageLite;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Printer;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.ResponseConverterFunction;\n+\n+/**\n+ * A {@link ResponseConverterFunction} which creates an {@link HttpResponse} with\n+ * {@code content-type: application/protobuf} or {@code content-type: application/json; charset=utf-8}.\n+ * If the returned object is instance of {@link MessageLite}, the object can be converted to\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/encoding\">Protocol Buffers</a> or\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/proto3#json\">JSON</a> format.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore if the returned object is instance of {@link Publisher}, {@link Stream} or {@link Iterable}\n+ * which produces {@link MessageLite}s, the object is only able to convert to\n+ * <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a> format.\n+ *\n+ * <p>Note that this {@link ResponseConverterFunction} is applied to the annotated service by default,\n+ * so you don't have to set explicitly unless you want to use your own {@link Printer}.\n+ */\n+@UnstableApi\n+public final class ProtobufResponseConverterFunction implements ResponseConverterFunction {\n+\n+    private static final Printer defaultJsonPrinter = JsonFormat.printer();\n+\n+    private final Printer jsonPrinter;\n+\n+    /**\n+     * Creates an instance with the default {@link Printer}.\n+     */\n+    public ProtobufResponseConverterFunction() {\n+        this(defaultJsonPrinter);\n+    }\n+\n+    /**\n+     * Creates an instance with the specified {@link Printer}.\n+     */\n+    public ProtobufResponseConverterFunction(Printer jsonPrinter) {\n+        this.jsonPrinter = requireNonNull(jsonPrinter, \"jsonPrinter\");\n+    }\n+\n+    @Override\n+    public HttpResponse convertResponse(ServiceRequestContext ctx, ResponseHeaders headers,\n+                                        @Nullable Object result, HttpHeaders trailers) throws Exception {\n+        final MediaType mediaType = headers.contentType();\n+        if (result instanceof MessageLite) {\n+            if (mediaType != null) {\n+                if (mediaType.is(MediaType.JSON) || mediaType.subtype().endsWith(\"+json\")) {\n+                    final Charset charset = mediaType.charset(StandardCharsets.UTF_8);\n+                    if (charset.contains(StandardCharsets.UTF_8)) {\n+                        return HttpResponse.of(headers, toJsonHttpData(result), trailers);\n+                    }\n+                }\n+                return HttpResponse.of(headers, toProtobuf(result), trailers);\n+            }\n+\n+            return HttpResponse.of(headers.toBuilder().contentType(MediaType.PROTOBUF).build(),\n+                                   toProtobuf(result), trailers);\n+        }\n+\n+        if (mediaType != null) {\n+            final String subtype = mediaType.subtype();\n+            if (subtype.contains(\"protobuf\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a3aad6b3e5df0a578985812008dea9bc82de713"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTczNzUxNQ==", "bodyText": "The following two media types seem to be widely used.\n\napplication/x-protobuf by Spring\nhttps://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/converter/protobuf/ProtobufHttpMessageConverter.html\napplication/protobuf by Guava", "url": "https://github.com/line/armeria/pull/3124#discussion_r519737515", "createdAt": "2020-11-09T11:26:43Z", "author": {"login": "ikhoon"}, "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufResponseConverterFunction.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.linecorp.armeria.internal.server.ResponseConversionUtil.aggregateFrom;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Publisher;\n+\n+import com.google.common.collect.Streams;\n+import com.google.protobuf.MessageLite;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Printer;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.ResponseConverterFunction;\n+\n+/**\n+ * A {@link ResponseConverterFunction} which creates an {@link HttpResponse} with\n+ * {@code content-type: application/protobuf} or {@code content-type: application/json; charset=utf-8}.\n+ * If the returned object is instance of {@link MessageLite}, the object can be converted to\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/encoding\">Protocol Buffers</a> or\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/proto3#json\">JSON</a> format.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore if the returned object is instance of {@link Publisher}, {@link Stream} or {@link Iterable}\n+ * which produces {@link MessageLite}s, the object is only able to convert to\n+ * <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a> format.\n+ *\n+ * <p>Note that this {@link ResponseConverterFunction} is applied to the annotated service by default,\n+ * so you don't have to set explicitly unless you want to use your own {@link Printer}.\n+ */\n+@UnstableApi\n+public final class ProtobufResponseConverterFunction implements ResponseConverterFunction {\n+\n+    private static final Printer defaultJsonPrinter = JsonFormat.printer();\n+\n+    private final Printer jsonPrinter;\n+\n+    /**\n+     * Creates an instance with the default {@link Printer}.\n+     */\n+    public ProtobufResponseConverterFunction() {\n+        this(defaultJsonPrinter);\n+    }\n+\n+    /**\n+     * Creates an instance with the specified {@link Printer}.\n+     */\n+    public ProtobufResponseConverterFunction(Printer jsonPrinter) {\n+        this.jsonPrinter = requireNonNull(jsonPrinter, \"jsonPrinter\");\n+    }\n+\n+    @Override\n+    public HttpResponse convertResponse(ServiceRequestContext ctx, ResponseHeaders headers,\n+                                        @Nullable Object result, HttpHeaders trailers) throws Exception {\n+        final MediaType mediaType = headers.contentType();\n+        if (result instanceof MessageLite) {\n+            if (mediaType != null) {\n+                if (mediaType.is(MediaType.JSON) || mediaType.subtype().endsWith(\"+json\")) {\n+                    final Charset charset = mediaType.charset(StandardCharsets.UTF_8);\n+                    if (charset.contains(StandardCharsets.UTF_8)) {\n+                        return HttpResponse.of(headers, toJsonHttpData(result), trailers);\n+                    }\n+                }\n+                return HttpResponse.of(headers, toProtobuf(result), trailers);\n+            }\n+\n+            return HttpResponse.of(headers.toBuilder().contentType(MediaType.PROTOBUF).build(),\n+                                   toProtobuf(result), trailers);\n+        }\n+\n+        if (mediaType != null) {\n+            final String subtype = mediaType.subtype();\n+            if (subtype.contains(\"protobuf\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU0MTY0Mg=="}, "originalCommit": {"oid": "1a3aad6b3e5df0a578985812008dea9bc82de713"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1Njg1MTE3OnYy", "diffSide": "RIGHT", "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufResponseConverterFunction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwNDowNDowNFrOHveUDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMzoxNDoyNFrOHw7zwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU0MTc3NA==", "bodyText": "endsWith?\nMaybe we can support other encodings?", "url": "https://github.com/line/armeria/pull/3124#discussion_r519541774", "createdAt": "2020-11-09T04:04:04Z", "author": {"login": "trustin"}, "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufResponseConverterFunction.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.linecorp.armeria.internal.server.ResponseConversionUtil.aggregateFrom;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Publisher;\n+\n+import com.google.common.collect.Streams;\n+import com.google.protobuf.MessageLite;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Printer;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.ResponseConverterFunction;\n+\n+/**\n+ * A {@link ResponseConverterFunction} which creates an {@link HttpResponse} with\n+ * {@code content-type: application/protobuf} or {@code content-type: application/json; charset=utf-8}.\n+ * If the returned object is instance of {@link MessageLite}, the object can be converted to\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/encoding\">Protocol Buffers</a> or\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/proto3#json\">JSON</a> format.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore if the returned object is instance of {@link Publisher}, {@link Stream} or {@link Iterable}\n+ * which produces {@link MessageLite}s, the object is only able to convert to\n+ * <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a> format.\n+ *\n+ * <p>Note that this {@link ResponseConverterFunction} is applied to the annotated service by default,\n+ * so you don't have to set explicitly unless you want to use your own {@link Printer}.\n+ */\n+@UnstableApi\n+public final class ProtobufResponseConverterFunction implements ResponseConverterFunction {\n+\n+    private static final Printer defaultJsonPrinter = JsonFormat.printer();\n+\n+    private final Printer jsonPrinter;\n+\n+    /**\n+     * Creates an instance with the default {@link Printer}.\n+     */\n+    public ProtobufResponseConverterFunction() {\n+        this(defaultJsonPrinter);\n+    }\n+\n+    /**\n+     * Creates an instance with the specified {@link Printer}.\n+     */\n+    public ProtobufResponseConverterFunction(Printer jsonPrinter) {\n+        this.jsonPrinter = requireNonNull(jsonPrinter, \"jsonPrinter\");\n+    }\n+\n+    @Override\n+    public HttpResponse convertResponse(ServiceRequestContext ctx, ResponseHeaders headers,\n+                                        @Nullable Object result, HttpHeaders trailers) throws Exception {\n+        final MediaType mediaType = headers.contentType();\n+        if (result instanceof MessageLite) {\n+            if (mediaType != null) {\n+                if (mediaType.is(MediaType.JSON) || mediaType.subtype().endsWith(\"+json\")) {\n+                    final Charset charset = mediaType.charset(StandardCharsets.UTF_8);\n+                    if (charset.contains(StandardCharsets.UTF_8)) {\n+                        return HttpResponse.of(headers, toJsonHttpData(result), trailers);\n+                    }\n+                }\n+                return HttpResponse.of(headers, toProtobuf(result), trailers);\n+            }\n+\n+            return HttpResponse.of(headers.toBuilder().contentType(MediaType.PROTOBUF).build(),\n+                                   toProtobuf(result), trailers);\n+        }\n+\n+        if (mediaType != null) {\n+            final String subtype = mediaType.subtype();\n+            if (subtype.contains(\"protobuf\")) {\n+                checkArgument(result != null, \"a null value is not allowed for %s\", mediaType);\n+                final Charset charset = mediaType.charset(StandardCharsets.UTF_8);\n+                final boolean isJson = subtype.contains(\"+json\") && charset.contains(StandardCharsets.UTF_8);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a3aad6b3e5df0a578985812008dea9bc82de713"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA3MzYwMg==", "bodyText": "Fixed", "url": "https://github.com/line/armeria/pull/3124#discussion_r521073602", "createdAt": "2020-11-11T03:14:24Z", "author": {"login": "ikhoon"}, "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufResponseConverterFunction.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.linecorp.armeria.internal.server.ResponseConversionUtil.aggregateFrom;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Publisher;\n+\n+import com.google.common.collect.Streams;\n+import com.google.protobuf.MessageLite;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Printer;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.ResponseConverterFunction;\n+\n+/**\n+ * A {@link ResponseConverterFunction} which creates an {@link HttpResponse} with\n+ * {@code content-type: application/protobuf} or {@code content-type: application/json; charset=utf-8}.\n+ * If the returned object is instance of {@link MessageLite}, the object can be converted to\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/encoding\">Protocol Buffers</a> or\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/proto3#json\">JSON</a> format.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore if the returned object is instance of {@link Publisher}, {@link Stream} or {@link Iterable}\n+ * which produces {@link MessageLite}s, the object is only able to convert to\n+ * <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a> format.\n+ *\n+ * <p>Note that this {@link ResponseConverterFunction} is applied to the annotated service by default,\n+ * so you don't have to set explicitly unless you want to use your own {@link Printer}.\n+ */\n+@UnstableApi\n+public final class ProtobufResponseConverterFunction implements ResponseConverterFunction {\n+\n+    private static final Printer defaultJsonPrinter = JsonFormat.printer();\n+\n+    private final Printer jsonPrinter;\n+\n+    /**\n+     * Creates an instance with the default {@link Printer}.\n+     */\n+    public ProtobufResponseConverterFunction() {\n+        this(defaultJsonPrinter);\n+    }\n+\n+    /**\n+     * Creates an instance with the specified {@link Printer}.\n+     */\n+    public ProtobufResponseConverterFunction(Printer jsonPrinter) {\n+        this.jsonPrinter = requireNonNull(jsonPrinter, \"jsonPrinter\");\n+    }\n+\n+    @Override\n+    public HttpResponse convertResponse(ServiceRequestContext ctx, ResponseHeaders headers,\n+                                        @Nullable Object result, HttpHeaders trailers) throws Exception {\n+        final MediaType mediaType = headers.contentType();\n+        if (result instanceof MessageLite) {\n+            if (mediaType != null) {\n+                if (mediaType.is(MediaType.JSON) || mediaType.subtype().endsWith(\"+json\")) {\n+                    final Charset charset = mediaType.charset(StandardCharsets.UTF_8);\n+                    if (charset.contains(StandardCharsets.UTF_8)) {\n+                        return HttpResponse.of(headers, toJsonHttpData(result), trailers);\n+                    }\n+                }\n+                return HttpResponse.of(headers, toProtobuf(result), trailers);\n+            }\n+\n+            return HttpResponse.of(headers.toBuilder().contentType(MediaType.PROTOBUF).build(),\n+                                   toProtobuf(result), trailers);\n+        }\n+\n+        if (mediaType != null) {\n+            final String subtype = mediaType.subtype();\n+            if (subtype.contains(\"protobuf\")) {\n+                checkArgument(result != null, \"a null value is not allowed for %s\", mediaType);\n+                final Charset charset = mediaType.charset(StandardCharsets.UTF_8);\n+                final boolean isJson = subtype.contains(\"+json\") && charset.contains(StandardCharsets.UTF_8);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU0MTc3NA=="}, "originalCommit": {"oid": "1a3aad6b3e5df0a578985812008dea9bc82de713"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NzEzMzYxOnYy", "diffSide": "RIGHT", "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufRequestConverterFunction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwNjo1MjozNVrOHvg11g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwNjo1MjozNVrOHvg11g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4MzE5MA==", "bodyText": "Comma after However", "url": "https://github.com/line/armeria/pull/3124#discussion_r519583190", "createdAt": "2020-11-09T06:52:35Z", "author": {"login": "trustin"}, "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufRequestConverterFunction.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static com.linecorp.armeria.server.protobuf.ProtobufRequestConverterFunctionProvider.toResultType;\n+import static java.lang.invoke.MethodType.methodType;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableCollection;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.MapMaker;\n+import com.google.protobuf.ExtensionRegistry;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Parser;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+\n+/**\n+ * A {@link RequestConverterFunction} which converts a Protocol Buffers or JSON body of\n+ * the {@link AggregatedHttpRequest} to an object.\n+ * The built-in parser of {@link Message} for Protocol Buffers is applied only when the {@code content-type} of\n+ * {@link RequestHeaders} either {@link MediaType#PROTOBUF} or {@link MediaType#OCTET_STREAM} or\n+ * the {@link MediaType#subtype()} contains {@code \"protobuf\"}.\n+ * The {@link Parser} for JSON is applied only when the {@code content-type} of\n+ * the {@link RequestHeaders} is {@link MediaType#JSON} or ends with {@code +json}.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore a sequence of Protocol Buffer messages can not be handled by this {@link RequestConverterFunction}.\n+ * However a <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a> body", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a3aad6b3e5df0a578985812008dea9bc82de713"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NzE0MjM3OnYy", "diffSide": "RIGHT", "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufRequestConverterFunction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwNjo1Njo0NlrOHvg63w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwNjo1Njo0NlrOHvg63w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4NDQ3OQ==", "bodyText": "Maybe more readable by using switch-case?", "url": "https://github.com/line/armeria/pull/3124#discussion_r519584479", "createdAt": "2020-11-09T06:56:46Z", "author": {"login": "trustin"}, "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufRequestConverterFunction.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static com.linecorp.armeria.server.protobuf.ProtobufRequestConverterFunctionProvider.toResultType;\n+import static java.lang.invoke.MethodType.methodType;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableCollection;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.MapMaker;\n+import com.google.protobuf.ExtensionRegistry;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Parser;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+\n+/**\n+ * A {@link RequestConverterFunction} which converts a Protocol Buffers or JSON body of\n+ * the {@link AggregatedHttpRequest} to an object.\n+ * The built-in parser of {@link Message} for Protocol Buffers is applied only when the {@code content-type} of\n+ * {@link RequestHeaders} either {@link MediaType#PROTOBUF} or {@link MediaType#OCTET_STREAM} or\n+ * the {@link MediaType#subtype()} contains {@code \"protobuf\"}.\n+ * The {@link Parser} for JSON is applied only when the {@code content-type} of\n+ * the {@link RequestHeaders} is {@link MediaType#JSON} or ends with {@code +json}.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore a sequence of Protocol Buffer messages can not be handled by this {@link RequestConverterFunction}.\n+ * However a <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a> body\n+ * could be converted into a {@link Collection} type. e.g, {@code List<Message>} and {@code Set<Message>}.\n+ */\n+@UnstableApi\n+public final class ProtobufRequestConverterFunction implements RequestConverterFunction {\n+\n+    private static final ConcurrentMap<Class<?>, MethodHandle> methodCache =\n+            new MapMaker().weakKeys().makeMap();\n+    private static final Parser defaultJsonParser = JsonFormat.parser().ignoringUnknownFields();\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+\n+    private static final MethodHandle unknownMethodHandle;\n+\n+    static {\n+        final MethodHandles.Lookup publicLookup = MethodHandles.publicLookup();\n+        final MethodType mt = methodType(void.class);\n+\n+        MethodHandle methodHandle;\n+        try {\n+            methodHandle = publicLookup.findConstructor(ProtobufRequestConverterFunction.class, mt);\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            methodHandle = null;\n+        }\n+        assert methodHandle != null;\n+        unknownMethodHandle = methodHandle;\n+    }\n+\n+    private final ExtensionRegistry extensionRegistry;\n+    private final Parser jsonParser;\n+    private final ResultType resultType;\n+\n+    ProtobufRequestConverterFunction(ResultType resultType) {\n+        jsonParser = defaultJsonParser;\n+        extensionRegistry = ExtensionRegistry.getEmptyRegistry();\n+        this.resultType = requireNonNull(resultType, \"resultType\");\n+    }\n+\n+    /**\n+     * Creates an instance with the default {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction() {\n+        this(defaultJsonParser, ExtensionRegistry.getEmptyRegistry());\n+    }\n+\n+    /**\n+     * Creates an instance with the specified {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction(Parser jsonParser, ExtensionRegistry extensionRegistry) {\n+        this.jsonParser = requireNonNull(jsonParser, \"jsonParser\");\n+        this.extensionRegistry = requireNonNull(extensionRegistry, \"extensionRegistry\");\n+        resultType = ResultType.UNKNOWN;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public Object convertRequest(ServiceRequestContext ctx, AggregatedHttpRequest request,\n+                                 Class<?> expectedResultType,\n+                                 @Nullable ParameterizedType expectedParameterizedResultType) throws Exception {\n+\n+        final MediaType contentType = request.contentType();\n+        if (resultType == ResultType.PROTOBUF ||\n+            (resultType == ResultType.UNKNOWN && Message.class.isAssignableFrom(expectedResultType))) {\n+            final Message.Builder messageBuilder = getMessageBuilder(expectedResultType);\n+\n+            if (contentType == null ||\n+                contentType.subtype().contains(\"protobuf\") || contentType.is(MediaType.OCTET_STREAM)) {\n+                try (InputStream is = request.content().toInputStream()) {\n+                    return messageBuilder.mergeFrom(is, extensionRegistry).build();\n+                }\n+            }\n+\n+            if (isJson(contentType)) {\n+                jsonParser.merge(request.contentUtf8(), messageBuilder);\n+                return messageBuilder.build();\n+            }\n+        }\n+\n+        if (isJson(contentType) && expectedParameterizedResultType != null) {\n+            ResultType resultType = this.resultType;\n+            if (resultType == ResultType.UNKNOWN) {\n+                resultType = toResultType(expectedParameterizedResultType);\n+            }\n+\n+            if (resultType != ResultType.UNKNOWN && resultType != ResultType.PROTOBUF) {\n+                final Type[] typeArguments = expectedParameterizedResultType.getActualTypeArguments();\n+                final String content = request.content(contentType.charset(StandardCharsets.UTF_8));\n+                final JsonNode jsonNode = mapper.readTree(content);\n+\n+                if (resultType == ResultType.LIST_PROTOBUF || resultType == ResultType.SET_PROTOBUF) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a3aad6b3e5df0a578985812008dea9bc82de713"}, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NzE0MzUxOnYy", "diffSide": "RIGHT", "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufRequestConverterFunction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwNjo1NzowOFrOHvg7cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwNjo1NzowOFrOHvg7cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4NDYyNg==", "bodyText": "Consider returning early", "url": "https://github.com/line/armeria/pull/3124#discussion_r519584626", "createdAt": "2020-11-09T06:57:08Z", "author": {"login": "trustin"}, "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufRequestConverterFunction.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static com.linecorp.armeria.server.protobuf.ProtobufRequestConverterFunctionProvider.toResultType;\n+import static java.lang.invoke.MethodType.methodType;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableCollection;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.MapMaker;\n+import com.google.protobuf.ExtensionRegistry;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Parser;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+\n+/**\n+ * A {@link RequestConverterFunction} which converts a Protocol Buffers or JSON body of\n+ * the {@link AggregatedHttpRequest} to an object.\n+ * The built-in parser of {@link Message} for Protocol Buffers is applied only when the {@code content-type} of\n+ * {@link RequestHeaders} either {@link MediaType#PROTOBUF} or {@link MediaType#OCTET_STREAM} or\n+ * the {@link MediaType#subtype()} contains {@code \"protobuf\"}.\n+ * The {@link Parser} for JSON is applied only when the {@code content-type} of\n+ * the {@link RequestHeaders} is {@link MediaType#JSON} or ends with {@code +json}.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore a sequence of Protocol Buffer messages can not be handled by this {@link RequestConverterFunction}.\n+ * However a <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a> body\n+ * could be converted into a {@link Collection} type. e.g, {@code List<Message>} and {@code Set<Message>}.\n+ */\n+@UnstableApi\n+public final class ProtobufRequestConverterFunction implements RequestConverterFunction {\n+\n+    private static final ConcurrentMap<Class<?>, MethodHandle> methodCache =\n+            new MapMaker().weakKeys().makeMap();\n+    private static final Parser defaultJsonParser = JsonFormat.parser().ignoringUnknownFields();\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+\n+    private static final MethodHandle unknownMethodHandle;\n+\n+    static {\n+        final MethodHandles.Lookup publicLookup = MethodHandles.publicLookup();\n+        final MethodType mt = methodType(void.class);\n+\n+        MethodHandle methodHandle;\n+        try {\n+            methodHandle = publicLookup.findConstructor(ProtobufRequestConverterFunction.class, mt);\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            methodHandle = null;\n+        }\n+        assert methodHandle != null;\n+        unknownMethodHandle = methodHandle;\n+    }\n+\n+    private final ExtensionRegistry extensionRegistry;\n+    private final Parser jsonParser;\n+    private final ResultType resultType;\n+\n+    ProtobufRequestConverterFunction(ResultType resultType) {\n+        jsonParser = defaultJsonParser;\n+        extensionRegistry = ExtensionRegistry.getEmptyRegistry();\n+        this.resultType = requireNonNull(resultType, \"resultType\");\n+    }\n+\n+    /**\n+     * Creates an instance with the default {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction() {\n+        this(defaultJsonParser, ExtensionRegistry.getEmptyRegistry());\n+    }\n+\n+    /**\n+     * Creates an instance with the specified {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction(Parser jsonParser, ExtensionRegistry extensionRegistry) {\n+        this.jsonParser = requireNonNull(jsonParser, \"jsonParser\");\n+        this.extensionRegistry = requireNonNull(extensionRegistry, \"extensionRegistry\");\n+        resultType = ResultType.UNKNOWN;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public Object convertRequest(ServiceRequestContext ctx, AggregatedHttpRequest request,\n+                                 Class<?> expectedResultType,\n+                                 @Nullable ParameterizedType expectedParameterizedResultType) throws Exception {\n+\n+        final MediaType contentType = request.contentType();\n+        if (resultType == ResultType.PROTOBUF ||\n+            (resultType == ResultType.UNKNOWN && Message.class.isAssignableFrom(expectedResultType))) {\n+            final Message.Builder messageBuilder = getMessageBuilder(expectedResultType);\n+\n+            if (contentType == null ||\n+                contentType.subtype().contains(\"protobuf\") || contentType.is(MediaType.OCTET_STREAM)) {\n+                try (InputStream is = request.content().toInputStream()) {\n+                    return messageBuilder.mergeFrom(is, extensionRegistry).build();\n+                }\n+            }\n+\n+            if (isJson(contentType)) {\n+                jsonParser.merge(request.contentUtf8(), messageBuilder);\n+                return messageBuilder.build();\n+            }\n+        }\n+\n+        if (isJson(contentType) && expectedParameterizedResultType != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a3aad6b3e5df0a578985812008dea9bc82de713"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NzE0NTMzOnYy", "diffSide": "RIGHT", "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufRequestConverterFunction.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwNjo1ODowNFrOHvg8jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwODoxMTozMlrOHzr3_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4NDkxMA==", "bodyText": "Would this also support ScalaPB?", "url": "https://github.com/line/armeria/pull/3124#discussion_r519584910", "createdAt": "2020-11-09T06:58:04Z", "author": {"login": "trustin"}, "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufRequestConverterFunction.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static com.linecorp.armeria.server.protobuf.ProtobufRequestConverterFunctionProvider.toResultType;\n+import static java.lang.invoke.MethodType.methodType;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableCollection;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.MapMaker;\n+import com.google.protobuf.ExtensionRegistry;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Parser;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+\n+/**\n+ * A {@link RequestConverterFunction} which converts a Protocol Buffers or JSON body of\n+ * the {@link AggregatedHttpRequest} to an object.\n+ * The built-in parser of {@link Message} for Protocol Buffers is applied only when the {@code content-type} of\n+ * {@link RequestHeaders} either {@link MediaType#PROTOBUF} or {@link MediaType#OCTET_STREAM} or\n+ * the {@link MediaType#subtype()} contains {@code \"protobuf\"}.\n+ * The {@link Parser} for JSON is applied only when the {@code content-type} of\n+ * the {@link RequestHeaders} is {@link MediaType#JSON} or ends with {@code +json}.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore a sequence of Protocol Buffer messages can not be handled by this {@link RequestConverterFunction}.\n+ * However a <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a> body\n+ * could be converted into a {@link Collection} type. e.g, {@code List<Message>} and {@code Set<Message>}.\n+ */\n+@UnstableApi\n+public final class ProtobufRequestConverterFunction implements RequestConverterFunction {\n+\n+    private static final ConcurrentMap<Class<?>, MethodHandle> methodCache =\n+            new MapMaker().weakKeys().makeMap();\n+    private static final Parser defaultJsonParser = JsonFormat.parser().ignoringUnknownFields();\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+\n+    private static final MethodHandle unknownMethodHandle;\n+\n+    static {\n+        final MethodHandles.Lookup publicLookup = MethodHandles.publicLookup();\n+        final MethodType mt = methodType(void.class);\n+\n+        MethodHandle methodHandle;\n+        try {\n+            methodHandle = publicLookup.findConstructor(ProtobufRequestConverterFunction.class, mt);\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            methodHandle = null;\n+        }\n+        assert methodHandle != null;\n+        unknownMethodHandle = methodHandle;\n+    }\n+\n+    private final ExtensionRegistry extensionRegistry;\n+    private final Parser jsonParser;\n+    private final ResultType resultType;\n+\n+    ProtobufRequestConverterFunction(ResultType resultType) {\n+        jsonParser = defaultJsonParser;\n+        extensionRegistry = ExtensionRegistry.getEmptyRegistry();\n+        this.resultType = requireNonNull(resultType, \"resultType\");\n+    }\n+\n+    /**\n+     * Creates an instance with the default {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction() {\n+        this(defaultJsonParser, ExtensionRegistry.getEmptyRegistry());\n+    }\n+\n+    /**\n+     * Creates an instance with the specified {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction(Parser jsonParser, ExtensionRegistry extensionRegistry) {\n+        this.jsonParser = requireNonNull(jsonParser, \"jsonParser\");\n+        this.extensionRegistry = requireNonNull(extensionRegistry, \"extensionRegistry\");\n+        resultType = ResultType.UNKNOWN;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public Object convertRequest(ServiceRequestContext ctx, AggregatedHttpRequest request,\n+                                 Class<?> expectedResultType,\n+                                 @Nullable ParameterizedType expectedParameterizedResultType) throws Exception {\n+\n+        final MediaType contentType = request.contentType();\n+        if (resultType == ResultType.PROTOBUF ||\n+            (resultType == ResultType.UNKNOWN && Message.class.isAssignableFrom(expectedResultType))) {\n+            final Message.Builder messageBuilder = getMessageBuilder(expectedResultType);\n+\n+            if (contentType == null ||\n+                contentType.subtype().contains(\"protobuf\") || contentType.is(MediaType.OCTET_STREAM)) {\n+                try (InputStream is = request.content().toInputStream()) {\n+                    return messageBuilder.mergeFrom(is, extensionRegistry).build();\n+                }\n+            }\n+\n+            if (isJson(contentType)) {\n+                jsonParser.merge(request.contentUtf8(), messageBuilder);\n+                return messageBuilder.build();\n+            }\n+        }\n+\n+        if (isJson(contentType) && expectedParameterizedResultType != null) {\n+            ResultType resultType = this.resultType;\n+            if (resultType == ResultType.UNKNOWN) {\n+                resultType = toResultType(expectedParameterizedResultType);\n+            }\n+\n+            if (resultType != ResultType.UNKNOWN && resultType != ResultType.PROTOBUF) {\n+                final Type[] typeArguments = expectedParameterizedResultType.getActualTypeArguments();\n+                final String content = request.content(contentType.charset(StandardCharsets.UTF_8));\n+                final JsonNode jsonNode = mapper.readTree(content);\n+\n+                if (resultType == ResultType.LIST_PROTOBUF || resultType == ResultType.SET_PROTOBUF) {\n+                    if (jsonNode.isArray()) {\n+                        final ImmutableCollection.Builder<Message> builder;\n+                        if (resultType == ResultType.LIST_PROTOBUF) {\n+                            builder = ImmutableList.builderWithExpectedSize(jsonNode.size());\n+                        } else {\n+                            builder = ImmutableSet.builderWithExpectedSize(jsonNode.size());\n+                        }\n+\n+                        for (JsonNode node : jsonNode) {\n+                            final Message.Builder msgBuilder = getMessageBuilder((Class<?>) typeArguments[0]);\n+                            jsonParser.merge(mapper.writeValueAsString(node), msgBuilder);\n+                            builder.add(msgBuilder.build());\n+                        }\n+                        return builder.build();\n+                    }\n+                } else if (resultType == ResultType.MAP_PROTOBUF) {\n+                     if (jsonNode.isObject()) {\n+                         final ImmutableMap.Builder<String, Message> builder =\n+                                 ImmutableMap.builderWithExpectedSize(jsonNode.size());\n+\n+                         for (final Iterator<Entry<String, JsonNode>> i = jsonNode.fields(); i.hasNext();) {\n+                             final Entry<String, JsonNode> e = i.next();\n+                             final Message.Builder msgBuilder = getMessageBuilder((Class<?>) typeArguments[1]);\n+                             jsonParser.merge(mapper.writeValueAsString(e.getValue()), msgBuilder);\n+                             builder.put(e.getKey(), msgBuilder.build());\n+                         }\n+                         return builder.build();\n+                     }\n+                }\n+            }\n+        }\n+\n+        return RequestConverterFunction.fallthrough();\n+    }\n+\n+    private static boolean isJson(@Nullable MediaType contentType) {\n+        return contentType != null &&\n+               (contentType.is(MediaType.JSON) || contentType.subtype().endsWith(\"+json\"));\n+    }\n+\n+    private static Message.Builder getMessageBuilder(Class<?> clazz) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a3aad6b3e5df0a578985812008dea9bc82de713"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY0NjY4NA==", "bodyText": "I don't think so. A message class generated by ScalaPB extends scalapb.GeneratedMessage.\nHowever it is possible by using another reflection API. Let me try it with optionalApi for ScalaPB.", "url": "https://github.com/line/armeria/pull/3124#discussion_r519646684", "createdAt": "2020-11-09T09:00:15Z", "author": {"login": "ikhoon"}, "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufRequestConverterFunction.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static com.linecorp.armeria.server.protobuf.ProtobufRequestConverterFunctionProvider.toResultType;\n+import static java.lang.invoke.MethodType.methodType;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableCollection;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.MapMaker;\n+import com.google.protobuf.ExtensionRegistry;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Parser;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+\n+/**\n+ * A {@link RequestConverterFunction} which converts a Protocol Buffers or JSON body of\n+ * the {@link AggregatedHttpRequest} to an object.\n+ * The built-in parser of {@link Message} for Protocol Buffers is applied only when the {@code content-type} of\n+ * {@link RequestHeaders} either {@link MediaType#PROTOBUF} or {@link MediaType#OCTET_STREAM} or\n+ * the {@link MediaType#subtype()} contains {@code \"protobuf\"}.\n+ * The {@link Parser} for JSON is applied only when the {@code content-type} of\n+ * the {@link RequestHeaders} is {@link MediaType#JSON} or ends with {@code +json}.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore a sequence of Protocol Buffer messages can not be handled by this {@link RequestConverterFunction}.\n+ * However a <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a> body\n+ * could be converted into a {@link Collection} type. e.g, {@code List<Message>} and {@code Set<Message>}.\n+ */\n+@UnstableApi\n+public final class ProtobufRequestConverterFunction implements RequestConverterFunction {\n+\n+    private static final ConcurrentMap<Class<?>, MethodHandle> methodCache =\n+            new MapMaker().weakKeys().makeMap();\n+    private static final Parser defaultJsonParser = JsonFormat.parser().ignoringUnknownFields();\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+\n+    private static final MethodHandle unknownMethodHandle;\n+\n+    static {\n+        final MethodHandles.Lookup publicLookup = MethodHandles.publicLookup();\n+        final MethodType mt = methodType(void.class);\n+\n+        MethodHandle methodHandle;\n+        try {\n+            methodHandle = publicLookup.findConstructor(ProtobufRequestConverterFunction.class, mt);\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            methodHandle = null;\n+        }\n+        assert methodHandle != null;\n+        unknownMethodHandle = methodHandle;\n+    }\n+\n+    private final ExtensionRegistry extensionRegistry;\n+    private final Parser jsonParser;\n+    private final ResultType resultType;\n+\n+    ProtobufRequestConverterFunction(ResultType resultType) {\n+        jsonParser = defaultJsonParser;\n+        extensionRegistry = ExtensionRegistry.getEmptyRegistry();\n+        this.resultType = requireNonNull(resultType, \"resultType\");\n+    }\n+\n+    /**\n+     * Creates an instance with the default {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction() {\n+        this(defaultJsonParser, ExtensionRegistry.getEmptyRegistry());\n+    }\n+\n+    /**\n+     * Creates an instance with the specified {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction(Parser jsonParser, ExtensionRegistry extensionRegistry) {\n+        this.jsonParser = requireNonNull(jsonParser, \"jsonParser\");\n+        this.extensionRegistry = requireNonNull(extensionRegistry, \"extensionRegistry\");\n+        resultType = ResultType.UNKNOWN;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public Object convertRequest(ServiceRequestContext ctx, AggregatedHttpRequest request,\n+                                 Class<?> expectedResultType,\n+                                 @Nullable ParameterizedType expectedParameterizedResultType) throws Exception {\n+\n+        final MediaType contentType = request.contentType();\n+        if (resultType == ResultType.PROTOBUF ||\n+            (resultType == ResultType.UNKNOWN && Message.class.isAssignableFrom(expectedResultType))) {\n+            final Message.Builder messageBuilder = getMessageBuilder(expectedResultType);\n+\n+            if (contentType == null ||\n+                contentType.subtype().contains(\"protobuf\") || contentType.is(MediaType.OCTET_STREAM)) {\n+                try (InputStream is = request.content().toInputStream()) {\n+                    return messageBuilder.mergeFrom(is, extensionRegistry).build();\n+                }\n+            }\n+\n+            if (isJson(contentType)) {\n+                jsonParser.merge(request.contentUtf8(), messageBuilder);\n+                return messageBuilder.build();\n+            }\n+        }\n+\n+        if (isJson(contentType) && expectedParameterizedResultType != null) {\n+            ResultType resultType = this.resultType;\n+            if (resultType == ResultType.UNKNOWN) {\n+                resultType = toResultType(expectedParameterizedResultType);\n+            }\n+\n+            if (resultType != ResultType.UNKNOWN && resultType != ResultType.PROTOBUF) {\n+                final Type[] typeArguments = expectedParameterizedResultType.getActualTypeArguments();\n+                final String content = request.content(contentType.charset(StandardCharsets.UTF_8));\n+                final JsonNode jsonNode = mapper.readTree(content);\n+\n+                if (resultType == ResultType.LIST_PROTOBUF || resultType == ResultType.SET_PROTOBUF) {\n+                    if (jsonNode.isArray()) {\n+                        final ImmutableCollection.Builder<Message> builder;\n+                        if (resultType == ResultType.LIST_PROTOBUF) {\n+                            builder = ImmutableList.builderWithExpectedSize(jsonNode.size());\n+                        } else {\n+                            builder = ImmutableSet.builderWithExpectedSize(jsonNode.size());\n+                        }\n+\n+                        for (JsonNode node : jsonNode) {\n+                            final Message.Builder msgBuilder = getMessageBuilder((Class<?>) typeArguments[0]);\n+                            jsonParser.merge(mapper.writeValueAsString(node), msgBuilder);\n+                            builder.add(msgBuilder.build());\n+                        }\n+                        return builder.build();\n+                    }\n+                } else if (resultType == ResultType.MAP_PROTOBUF) {\n+                     if (jsonNode.isObject()) {\n+                         final ImmutableMap.Builder<String, Message> builder =\n+                                 ImmutableMap.builderWithExpectedSize(jsonNode.size());\n+\n+                         for (final Iterator<Entry<String, JsonNode>> i = jsonNode.fields(); i.hasNext();) {\n+                             final Entry<String, JsonNode> e = i.next();\n+                             final Message.Builder msgBuilder = getMessageBuilder((Class<?>) typeArguments[1]);\n+                             jsonParser.merge(mapper.writeValueAsString(e.getValue()), msgBuilder);\n+                             builder.put(e.getKey(), msgBuilder.build());\n+                         }\n+                         return builder.build();\n+                     }\n+                }\n+            }\n+        }\n+\n+        return RequestConverterFunction.fallthrough();\n+    }\n+\n+    private static boolean isJson(@Nullable MediaType contentType) {\n+        return contentType != null &&\n+               (contentType.is(MediaType.JSON) || contentType.subtype().endsWith(\"+json\"));\n+    }\n+\n+    private static Message.Builder getMessageBuilder(Class<?> clazz) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4NDkxMA=="}, "originalCommit": {"oid": "1a3aad6b3e5df0a578985812008dea9bc82de713"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA3NDM4Nw==", "bodyText": "ScalaPB converters are added to armeria-scalapb module.\nf5ef663", "url": "https://github.com/line/armeria/pull/3124#discussion_r521074387", "createdAt": "2020-11-11T03:15:42Z", "author": {"login": "ikhoon"}, "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufRequestConverterFunction.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static com.linecorp.armeria.server.protobuf.ProtobufRequestConverterFunctionProvider.toResultType;\n+import static java.lang.invoke.MethodType.methodType;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableCollection;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.MapMaker;\n+import com.google.protobuf.ExtensionRegistry;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Parser;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+\n+/**\n+ * A {@link RequestConverterFunction} which converts a Protocol Buffers or JSON body of\n+ * the {@link AggregatedHttpRequest} to an object.\n+ * The built-in parser of {@link Message} for Protocol Buffers is applied only when the {@code content-type} of\n+ * {@link RequestHeaders} either {@link MediaType#PROTOBUF} or {@link MediaType#OCTET_STREAM} or\n+ * the {@link MediaType#subtype()} contains {@code \"protobuf\"}.\n+ * The {@link Parser} for JSON is applied only when the {@code content-type} of\n+ * the {@link RequestHeaders} is {@link MediaType#JSON} or ends with {@code +json}.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore a sequence of Protocol Buffer messages can not be handled by this {@link RequestConverterFunction}.\n+ * However a <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a> body\n+ * could be converted into a {@link Collection} type. e.g, {@code List<Message>} and {@code Set<Message>}.\n+ */\n+@UnstableApi\n+public final class ProtobufRequestConverterFunction implements RequestConverterFunction {\n+\n+    private static final ConcurrentMap<Class<?>, MethodHandle> methodCache =\n+            new MapMaker().weakKeys().makeMap();\n+    private static final Parser defaultJsonParser = JsonFormat.parser().ignoringUnknownFields();\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+\n+    private static final MethodHandle unknownMethodHandle;\n+\n+    static {\n+        final MethodHandles.Lookup publicLookup = MethodHandles.publicLookup();\n+        final MethodType mt = methodType(void.class);\n+\n+        MethodHandle methodHandle;\n+        try {\n+            methodHandle = publicLookup.findConstructor(ProtobufRequestConverterFunction.class, mt);\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            methodHandle = null;\n+        }\n+        assert methodHandle != null;\n+        unknownMethodHandle = methodHandle;\n+    }\n+\n+    private final ExtensionRegistry extensionRegistry;\n+    private final Parser jsonParser;\n+    private final ResultType resultType;\n+\n+    ProtobufRequestConverterFunction(ResultType resultType) {\n+        jsonParser = defaultJsonParser;\n+        extensionRegistry = ExtensionRegistry.getEmptyRegistry();\n+        this.resultType = requireNonNull(resultType, \"resultType\");\n+    }\n+\n+    /**\n+     * Creates an instance with the default {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction() {\n+        this(defaultJsonParser, ExtensionRegistry.getEmptyRegistry());\n+    }\n+\n+    /**\n+     * Creates an instance with the specified {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction(Parser jsonParser, ExtensionRegistry extensionRegistry) {\n+        this.jsonParser = requireNonNull(jsonParser, \"jsonParser\");\n+        this.extensionRegistry = requireNonNull(extensionRegistry, \"extensionRegistry\");\n+        resultType = ResultType.UNKNOWN;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public Object convertRequest(ServiceRequestContext ctx, AggregatedHttpRequest request,\n+                                 Class<?> expectedResultType,\n+                                 @Nullable ParameterizedType expectedParameterizedResultType) throws Exception {\n+\n+        final MediaType contentType = request.contentType();\n+        if (resultType == ResultType.PROTOBUF ||\n+            (resultType == ResultType.UNKNOWN && Message.class.isAssignableFrom(expectedResultType))) {\n+            final Message.Builder messageBuilder = getMessageBuilder(expectedResultType);\n+\n+            if (contentType == null ||\n+                contentType.subtype().contains(\"protobuf\") || contentType.is(MediaType.OCTET_STREAM)) {\n+                try (InputStream is = request.content().toInputStream()) {\n+                    return messageBuilder.mergeFrom(is, extensionRegistry).build();\n+                }\n+            }\n+\n+            if (isJson(contentType)) {\n+                jsonParser.merge(request.contentUtf8(), messageBuilder);\n+                return messageBuilder.build();\n+            }\n+        }\n+\n+        if (isJson(contentType) && expectedParameterizedResultType != null) {\n+            ResultType resultType = this.resultType;\n+            if (resultType == ResultType.UNKNOWN) {\n+                resultType = toResultType(expectedParameterizedResultType);\n+            }\n+\n+            if (resultType != ResultType.UNKNOWN && resultType != ResultType.PROTOBUF) {\n+                final Type[] typeArguments = expectedParameterizedResultType.getActualTypeArguments();\n+                final String content = request.content(contentType.charset(StandardCharsets.UTF_8));\n+                final JsonNode jsonNode = mapper.readTree(content);\n+\n+                if (resultType == ResultType.LIST_PROTOBUF || resultType == ResultType.SET_PROTOBUF) {\n+                    if (jsonNode.isArray()) {\n+                        final ImmutableCollection.Builder<Message> builder;\n+                        if (resultType == ResultType.LIST_PROTOBUF) {\n+                            builder = ImmutableList.builderWithExpectedSize(jsonNode.size());\n+                        } else {\n+                            builder = ImmutableSet.builderWithExpectedSize(jsonNode.size());\n+                        }\n+\n+                        for (JsonNode node : jsonNode) {\n+                            final Message.Builder msgBuilder = getMessageBuilder((Class<?>) typeArguments[0]);\n+                            jsonParser.merge(mapper.writeValueAsString(node), msgBuilder);\n+                            builder.add(msgBuilder.build());\n+                        }\n+                        return builder.build();\n+                    }\n+                } else if (resultType == ResultType.MAP_PROTOBUF) {\n+                     if (jsonNode.isObject()) {\n+                         final ImmutableMap.Builder<String, Message> builder =\n+                                 ImmutableMap.builderWithExpectedSize(jsonNode.size());\n+\n+                         for (final Iterator<Entry<String, JsonNode>> i = jsonNode.fields(); i.hasNext();) {\n+                             final Entry<String, JsonNode> e = i.next();\n+                             final Message.Builder msgBuilder = getMessageBuilder((Class<?>) typeArguments[1]);\n+                             jsonParser.merge(mapper.writeValueAsString(e.getValue()), msgBuilder);\n+                             builder.put(e.getKey(), msgBuilder.build());\n+                         }\n+                         return builder.build();\n+                     }\n+                }\n+            }\n+        }\n+\n+        return RequestConverterFunction.fallthrough();\n+    }\n+\n+    private static boolean isJson(@Nullable MediaType contentType) {\n+        return contentType != null &&\n+               (contentType.is(MediaType.JSON) || contentType.subtype().endsWith(\"+json\"));\n+    }\n+\n+    private static Message.Builder getMessageBuilder(Class<?> clazz) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4NDkxMA=="}, "originalCommit": {"oid": "1a3aad6b3e5df0a578985812008dea9bc82de713"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk1ODI3MA==", "bodyText": "Nice!", "url": "https://github.com/line/armeria/pull/3124#discussion_r523958270", "createdAt": "2020-11-16T08:11:32Z", "author": {"login": "trustin"}, "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufRequestConverterFunction.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static com.linecorp.armeria.server.protobuf.ProtobufRequestConverterFunctionProvider.toResultType;\n+import static java.lang.invoke.MethodType.methodType;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableCollection;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.MapMaker;\n+import com.google.protobuf.ExtensionRegistry;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Parser;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+\n+/**\n+ * A {@link RequestConverterFunction} which converts a Protocol Buffers or JSON body of\n+ * the {@link AggregatedHttpRequest} to an object.\n+ * The built-in parser of {@link Message} for Protocol Buffers is applied only when the {@code content-type} of\n+ * {@link RequestHeaders} either {@link MediaType#PROTOBUF} or {@link MediaType#OCTET_STREAM} or\n+ * the {@link MediaType#subtype()} contains {@code \"protobuf\"}.\n+ * The {@link Parser} for JSON is applied only when the {@code content-type} of\n+ * the {@link RequestHeaders} is {@link MediaType#JSON} or ends with {@code +json}.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore a sequence of Protocol Buffer messages can not be handled by this {@link RequestConverterFunction}.\n+ * However a <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a> body\n+ * could be converted into a {@link Collection} type. e.g, {@code List<Message>} and {@code Set<Message>}.\n+ */\n+@UnstableApi\n+public final class ProtobufRequestConverterFunction implements RequestConverterFunction {\n+\n+    private static final ConcurrentMap<Class<?>, MethodHandle> methodCache =\n+            new MapMaker().weakKeys().makeMap();\n+    private static final Parser defaultJsonParser = JsonFormat.parser().ignoringUnknownFields();\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+\n+    private static final MethodHandle unknownMethodHandle;\n+\n+    static {\n+        final MethodHandles.Lookup publicLookup = MethodHandles.publicLookup();\n+        final MethodType mt = methodType(void.class);\n+\n+        MethodHandle methodHandle;\n+        try {\n+            methodHandle = publicLookup.findConstructor(ProtobufRequestConverterFunction.class, mt);\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            methodHandle = null;\n+        }\n+        assert methodHandle != null;\n+        unknownMethodHandle = methodHandle;\n+    }\n+\n+    private final ExtensionRegistry extensionRegistry;\n+    private final Parser jsonParser;\n+    private final ResultType resultType;\n+\n+    ProtobufRequestConverterFunction(ResultType resultType) {\n+        jsonParser = defaultJsonParser;\n+        extensionRegistry = ExtensionRegistry.getEmptyRegistry();\n+        this.resultType = requireNonNull(resultType, \"resultType\");\n+    }\n+\n+    /**\n+     * Creates an instance with the default {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction() {\n+        this(defaultJsonParser, ExtensionRegistry.getEmptyRegistry());\n+    }\n+\n+    /**\n+     * Creates an instance with the specified {@link Parser} and {@link ExtensionRegistry}.\n+     */\n+    public ProtobufRequestConverterFunction(Parser jsonParser, ExtensionRegistry extensionRegistry) {\n+        this.jsonParser = requireNonNull(jsonParser, \"jsonParser\");\n+        this.extensionRegistry = requireNonNull(extensionRegistry, \"extensionRegistry\");\n+        resultType = ResultType.UNKNOWN;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public Object convertRequest(ServiceRequestContext ctx, AggregatedHttpRequest request,\n+                                 Class<?> expectedResultType,\n+                                 @Nullable ParameterizedType expectedParameterizedResultType) throws Exception {\n+\n+        final MediaType contentType = request.contentType();\n+        if (resultType == ResultType.PROTOBUF ||\n+            (resultType == ResultType.UNKNOWN && Message.class.isAssignableFrom(expectedResultType))) {\n+            final Message.Builder messageBuilder = getMessageBuilder(expectedResultType);\n+\n+            if (contentType == null ||\n+                contentType.subtype().contains(\"protobuf\") || contentType.is(MediaType.OCTET_STREAM)) {\n+                try (InputStream is = request.content().toInputStream()) {\n+                    return messageBuilder.mergeFrom(is, extensionRegistry).build();\n+                }\n+            }\n+\n+            if (isJson(contentType)) {\n+                jsonParser.merge(request.contentUtf8(), messageBuilder);\n+                return messageBuilder.build();\n+            }\n+        }\n+\n+        if (isJson(contentType) && expectedParameterizedResultType != null) {\n+            ResultType resultType = this.resultType;\n+            if (resultType == ResultType.UNKNOWN) {\n+                resultType = toResultType(expectedParameterizedResultType);\n+            }\n+\n+            if (resultType != ResultType.UNKNOWN && resultType != ResultType.PROTOBUF) {\n+                final Type[] typeArguments = expectedParameterizedResultType.getActualTypeArguments();\n+                final String content = request.content(contentType.charset(StandardCharsets.UTF_8));\n+                final JsonNode jsonNode = mapper.readTree(content);\n+\n+                if (resultType == ResultType.LIST_PROTOBUF || resultType == ResultType.SET_PROTOBUF) {\n+                    if (jsonNode.isArray()) {\n+                        final ImmutableCollection.Builder<Message> builder;\n+                        if (resultType == ResultType.LIST_PROTOBUF) {\n+                            builder = ImmutableList.builderWithExpectedSize(jsonNode.size());\n+                        } else {\n+                            builder = ImmutableSet.builderWithExpectedSize(jsonNode.size());\n+                        }\n+\n+                        for (JsonNode node : jsonNode) {\n+                            final Message.Builder msgBuilder = getMessageBuilder((Class<?>) typeArguments[0]);\n+                            jsonParser.merge(mapper.writeValueAsString(node), msgBuilder);\n+                            builder.add(msgBuilder.build());\n+                        }\n+                        return builder.build();\n+                    }\n+                } else if (resultType == ResultType.MAP_PROTOBUF) {\n+                     if (jsonNode.isObject()) {\n+                         final ImmutableMap.Builder<String, Message> builder =\n+                                 ImmutableMap.builderWithExpectedSize(jsonNode.size());\n+\n+                         for (final Iterator<Entry<String, JsonNode>> i = jsonNode.fields(); i.hasNext();) {\n+                             final Entry<String, JsonNode> e = i.next();\n+                             final Message.Builder msgBuilder = getMessageBuilder((Class<?>) typeArguments[1]);\n+                             jsonParser.merge(mapper.writeValueAsString(e.getValue()), msgBuilder);\n+                             builder.put(e.getKey(), msgBuilder.build());\n+                         }\n+                         return builder.build();\n+                     }\n+                }\n+            }\n+        }\n+\n+        return RequestConverterFunction.fallthrough();\n+    }\n+\n+    private static boolean isJson(@Nullable MediaType contentType) {\n+        return contentType != null &&\n+               (contentType.is(MediaType.JSON) || contentType.subtype().endsWith(\"+json\"));\n+    }\n+\n+    private static Message.Builder getMessageBuilder(Class<?> clazz) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4NDkxMA=="}, "originalCommit": {"oid": "1a3aad6b3e5df0a578985812008dea9bc82de713"}, "originalPosition": 201}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NzE0NjU0OnYy", "diffSide": "RIGHT", "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufRequestConverterFunctionProvider.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwNjo1ODozOFrOHvg9Qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMzoyODozNFrOHxNIow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4NTA5MQ==", "bodyText": "Message or MessageLite?", "url": "https://github.com/line/armeria/pull/3124#discussion_r519585091", "createdAt": "2020-11-09T06:58:38Z", "author": {"login": "trustin"}, "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufRequestConverterFunctionProvider.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import com.google.protobuf.Message;\n+\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunctionProvider;\n+import com.linecorp.armeria.server.protobuf.ProtobufRequestConverterFunction.ResultType;\n+\n+/**\n+ * Provides a {@link ProtobufRequestConverterFunction} to annotated services.\n+ */\n+@UnstableApi\n+public final class ProtobufRequestConverterFunctionProvider implements RequestConverterFunctionProvider {\n+\n+    @Override\n+    public RequestConverterFunction createRequestConverterFunction(Type requestType,\n+                                                                   RequestConverterFunction requestConverter) {\n+        final ResultType resultType = toResultType(requestType);\n+        if (resultType != ResultType.UNKNOWN) {\n+            return new ProtobufRequestConverterFunction(resultType);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    static ResultType toResultType(Type type) {\n+        if (type instanceof Class) {\n+            if (isProtobufMessage((Class<?>) type)) {\n+                return ResultType.PROTOBUF;\n+            }\n+        }\n+\n+        if (type instanceof ParameterizedType) {\n+            final ParameterizedType parameterizedType = (ParameterizedType) type;\n+            final Class<?> rawType = (Class<?>) parameterizedType.getRawType();\n+            if (List.class.isAssignableFrom(rawType)) {\n+                final Class<?> typeArgument = (Class<?>) parameterizedType.getActualTypeArguments()[0];\n+                if (isProtobufMessage(typeArgument)) {\n+                    return ResultType.LIST_PROTOBUF;\n+                }\n+            } else if (Set.class.isAssignableFrom(rawType)) {\n+                final Class<?> typeArgument = (Class<?>) parameterizedType.getActualTypeArguments()[0];\n+                if (isProtobufMessage(typeArgument)) {\n+                    return ResultType.SET_PROTOBUF;\n+                }\n+            } else if (Map.class.isAssignableFrom(rawType)) {\n+                final Type[] typeArguments = parameterizedType.getActualTypeArguments();\n+                final Class<?> keyType = (Class<?>) typeArguments[0];\n+                if (!String.class.isAssignableFrom(keyType)) {\n+                    throw new IllegalStateException(\n+                            keyType + \" cannot be used for the key type of Map. \" +\n+                            \"(expected: Map<String, ?>)\");\n+                }\n+                if (isProtobufMessage((Class<?>) typeArguments[1])) {\n+                    return ResultType.MAP_PROTOBUF;\n+                }\n+            }\n+        }\n+        return ResultType.UNKNOWN;\n+    }\n+\n+    private static boolean isProtobufMessage(Class<?> clazz) {\n+        return Message.class.isAssignableFrom(clazz);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a3aad6b3e5df0a578985812008dea9bc82de713"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY1MTY4Ng==", "bodyText": "Message class extends MessageLite. When building(deserializing) a message from protobuf, Message class is required to get Builder class. However, when serializing a message to protobuf,  MessageLite is enough.\nThis inconsistency is able to confuse users. Let me just use Message instead of MessageLite.", "url": "https://github.com/line/armeria/pull/3124#discussion_r519651686", "createdAt": "2020-11-09T09:08:33Z", "author": {"login": "ikhoon"}, "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufRequestConverterFunctionProvider.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import com.google.protobuf.Message;\n+\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunctionProvider;\n+import com.linecorp.armeria.server.protobuf.ProtobufRequestConverterFunction.ResultType;\n+\n+/**\n+ * Provides a {@link ProtobufRequestConverterFunction} to annotated services.\n+ */\n+@UnstableApi\n+public final class ProtobufRequestConverterFunctionProvider implements RequestConverterFunctionProvider {\n+\n+    @Override\n+    public RequestConverterFunction createRequestConverterFunction(Type requestType,\n+                                                                   RequestConverterFunction requestConverter) {\n+        final ResultType resultType = toResultType(requestType);\n+        if (resultType != ResultType.UNKNOWN) {\n+            return new ProtobufRequestConverterFunction(resultType);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    static ResultType toResultType(Type type) {\n+        if (type instanceof Class) {\n+            if (isProtobufMessage((Class<?>) type)) {\n+                return ResultType.PROTOBUF;\n+            }\n+        }\n+\n+        if (type instanceof ParameterizedType) {\n+            final ParameterizedType parameterizedType = (ParameterizedType) type;\n+            final Class<?> rawType = (Class<?>) parameterizedType.getRawType();\n+            if (List.class.isAssignableFrom(rawType)) {\n+                final Class<?> typeArgument = (Class<?>) parameterizedType.getActualTypeArguments()[0];\n+                if (isProtobufMessage(typeArgument)) {\n+                    return ResultType.LIST_PROTOBUF;\n+                }\n+            } else if (Set.class.isAssignableFrom(rawType)) {\n+                final Class<?> typeArgument = (Class<?>) parameterizedType.getActualTypeArguments()[0];\n+                if (isProtobufMessage(typeArgument)) {\n+                    return ResultType.SET_PROTOBUF;\n+                }\n+            } else if (Map.class.isAssignableFrom(rawType)) {\n+                final Type[] typeArguments = parameterizedType.getActualTypeArguments();\n+                final Class<?> keyType = (Class<?>) typeArguments[0];\n+                if (!String.class.isAssignableFrom(keyType)) {\n+                    throw new IllegalStateException(\n+                            keyType + \" cannot be used for the key type of Map. \" +\n+                            \"(expected: Map<String, ?>)\");\n+                }\n+                if (isProtobufMessage((Class<?>) typeArguments[1])) {\n+                    return ResultType.MAP_PROTOBUF;\n+                }\n+            }\n+        }\n+        return ResultType.UNKNOWN;\n+    }\n+\n+    private static boolean isProtobufMessage(Class<?> clazz) {\n+        return Message.class.isAssignableFrom(clazz);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4NTA5MQ=="}, "originalCommit": {"oid": "1a3aad6b3e5df0a578985812008dea9bc82de713"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA5NjQ2Nw==", "bodyText": "MessageLite is very rare in servers btw (though I remember an issue filed by someone that was actually using it don't remember the reasoning)", "url": "https://github.com/line/armeria/pull/3124#discussion_r521096467", "createdAt": "2020-11-11T03:54:23Z", "author": {"login": "anuraaga"}, "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufRequestConverterFunctionProvider.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import com.google.protobuf.Message;\n+\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunctionProvider;\n+import com.linecorp.armeria.server.protobuf.ProtobufRequestConverterFunction.ResultType;\n+\n+/**\n+ * Provides a {@link ProtobufRequestConverterFunction} to annotated services.\n+ */\n+@UnstableApi\n+public final class ProtobufRequestConverterFunctionProvider implements RequestConverterFunctionProvider {\n+\n+    @Override\n+    public RequestConverterFunction createRequestConverterFunction(Type requestType,\n+                                                                   RequestConverterFunction requestConverter) {\n+        final ResultType resultType = toResultType(requestType);\n+        if (resultType != ResultType.UNKNOWN) {\n+            return new ProtobufRequestConverterFunction(resultType);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    static ResultType toResultType(Type type) {\n+        if (type instanceof Class) {\n+            if (isProtobufMessage((Class<?>) type)) {\n+                return ResultType.PROTOBUF;\n+            }\n+        }\n+\n+        if (type instanceof ParameterizedType) {\n+            final ParameterizedType parameterizedType = (ParameterizedType) type;\n+            final Class<?> rawType = (Class<?>) parameterizedType.getRawType();\n+            if (List.class.isAssignableFrom(rawType)) {\n+                final Class<?> typeArgument = (Class<?>) parameterizedType.getActualTypeArguments()[0];\n+                if (isProtobufMessage(typeArgument)) {\n+                    return ResultType.LIST_PROTOBUF;\n+                }\n+            } else if (Set.class.isAssignableFrom(rawType)) {\n+                final Class<?> typeArgument = (Class<?>) parameterizedType.getActualTypeArguments()[0];\n+                if (isProtobufMessage(typeArgument)) {\n+                    return ResultType.SET_PROTOBUF;\n+                }\n+            } else if (Map.class.isAssignableFrom(rawType)) {\n+                final Type[] typeArguments = parameterizedType.getActualTypeArguments();\n+                final Class<?> keyType = (Class<?>) typeArguments[0];\n+                if (!String.class.isAssignableFrom(keyType)) {\n+                    throw new IllegalStateException(\n+                            keyType + \" cannot be used for the key type of Map. \" +\n+                            \"(expected: Map<String, ?>)\");\n+                }\n+                if (isProtobufMessage((Class<?>) typeArguments[1])) {\n+                    return ResultType.MAP_PROTOBUF;\n+                }\n+            }\n+        }\n+        return ResultType.UNKNOWN;\n+    }\n+\n+    private static boolean isProtobufMessage(Class<?> clazz) {\n+        return Message.class.isAssignableFrom(clazz);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4NTA5MQ=="}, "originalCommit": {"oid": "1a3aad6b3e5df0a578985812008dea9bc82de713"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM1NzQ3NQ==", "bodyText": "I remember an issue filed by someone that was actually using it don't remember the reasoning\n\nMaybe #3085? He said it was caused by wrong dependencies.", "url": "https://github.com/line/armeria/pull/3124#discussion_r521357475", "createdAt": "2020-11-11T13:28:34Z", "author": {"login": "ikhoon"}, "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufRequestConverterFunctionProvider.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import com.google.protobuf.Message;\n+\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunctionProvider;\n+import com.linecorp.armeria.server.protobuf.ProtobufRequestConverterFunction.ResultType;\n+\n+/**\n+ * Provides a {@link ProtobufRequestConverterFunction} to annotated services.\n+ */\n+@UnstableApi\n+public final class ProtobufRequestConverterFunctionProvider implements RequestConverterFunctionProvider {\n+\n+    @Override\n+    public RequestConverterFunction createRequestConverterFunction(Type requestType,\n+                                                                   RequestConverterFunction requestConverter) {\n+        final ResultType resultType = toResultType(requestType);\n+        if (resultType != ResultType.UNKNOWN) {\n+            return new ProtobufRequestConverterFunction(resultType);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    static ResultType toResultType(Type type) {\n+        if (type instanceof Class) {\n+            if (isProtobufMessage((Class<?>) type)) {\n+                return ResultType.PROTOBUF;\n+            }\n+        }\n+\n+        if (type instanceof ParameterizedType) {\n+            final ParameterizedType parameterizedType = (ParameterizedType) type;\n+            final Class<?> rawType = (Class<?>) parameterizedType.getRawType();\n+            if (List.class.isAssignableFrom(rawType)) {\n+                final Class<?> typeArgument = (Class<?>) parameterizedType.getActualTypeArguments()[0];\n+                if (isProtobufMessage(typeArgument)) {\n+                    return ResultType.LIST_PROTOBUF;\n+                }\n+            } else if (Set.class.isAssignableFrom(rawType)) {\n+                final Class<?> typeArgument = (Class<?>) parameterizedType.getActualTypeArguments()[0];\n+                if (isProtobufMessage(typeArgument)) {\n+                    return ResultType.SET_PROTOBUF;\n+                }\n+            } else if (Map.class.isAssignableFrom(rawType)) {\n+                final Type[] typeArguments = parameterizedType.getActualTypeArguments();\n+                final Class<?> keyType = (Class<?>) typeArguments[0];\n+                if (!String.class.isAssignableFrom(keyType)) {\n+                    throw new IllegalStateException(\n+                            keyType + \" cannot be used for the key type of Map. \" +\n+                            \"(expected: Map<String, ?>)\");\n+                }\n+                if (isProtobufMessage((Class<?>) typeArguments[1])) {\n+                    return ResultType.MAP_PROTOBUF;\n+                }\n+            }\n+        }\n+        return ResultType.UNKNOWN;\n+    }\n+\n+    private static boolean isProtobufMessage(Class<?> clazz) {\n+        return Message.class.isAssignableFrom(clazz);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4NTA5MQ=="}, "originalCommit": {"oid": "1a3aad6b3e5df0a578985812008dea9bc82de713"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NzE0OTIwOnYy", "diffSide": "RIGHT", "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufResponseConverterFunction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwNjo1OTo0NVrOHvg-tw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwNjo1OTo0NVrOHvg-tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4NTQ2Mw==", "bodyText": "Ditto - please add a heading and start from the conclusion.", "url": "https://github.com/line/armeria/pull/3124#discussion_r519585463", "createdAt": "2020-11-09T06:59:45Z", "author": {"login": "trustin"}, "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufResponseConverterFunction.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.linecorp.armeria.internal.server.ResponseConversionUtil.aggregateFrom;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Publisher;\n+\n+import com.google.common.collect.Streams;\n+import com.google.protobuf.MessageLite;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Printer;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.ResponseConverterFunction;\n+\n+/**\n+ * A {@link ResponseConverterFunction} which creates an {@link HttpResponse} with\n+ * {@code content-type: application/protobuf} or {@code content-type: application/json; charset=utf-8}.\n+ * If the returned object is instance of {@link MessageLite}, the object can be converted to\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/encoding\">Protocol Buffers</a> or\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/proto3#json\">JSON</a> format.\n+ *\n+ * <p>The Protocol Buffers spec does not have an official way to sending multiple messages because\n+ * an encoded message does not have self-delimiting.\n+ * See <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * Therefore if the returned object is instance of {@link Publisher}, {@link Stream} or {@link Iterable}\n+ * which produces {@link MessageLite}s, the object is only able to convert to\n+ * <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a> format.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a3aad6b3e5df0a578985812008dea9bc82de713"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTI5MzE1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/internal/server/annotation/CompositeConverterFunctions.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwODoxNTowNlrOHzr_Iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwODoxNTowNlrOHzr_Iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk2MDA5OQ==", "bodyText": "Could we move the inner classes to the top level? This parent class doesn't seem to do anything.", "url": "https://github.com/line/armeria/pull/3124#discussion_r523960099", "createdAt": "2020-11-16T08:15:06Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/internal/server/annotation/CompositeConverterFunctions.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.server.annotation;\n+\n+import java.lang.reflect.ParameterizedType;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.util.SafeCloseable;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.FallthroughException;\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction;\n+import com.linecorp.armeria.server.annotation.ResponseConverterFunction;\n+\n+final class CompositeConverterFunctions {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84c1a22063b1899e56832ef09feff138f59d1cef"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTI5NzY1OnYy", "diffSide": "RIGHT", "path": "gradle.properties", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwODoxNjoyNlrOHzsBuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxNjoyMDowMFrOH0GZVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk2MDc2MQ==", "bodyText": "Question: Why these properties have two different versions?", "url": "https://github.com/line/armeria/pull/3124#discussion_r523960761", "createdAt": "2020-11-16T08:16:26Z", "author": {"login": "trustin"}, "path": "gradle.properties", "diffHunk": "@@ -26,3 +26,7 @@ org.gradle.jvmargs=-Xmx1280m\n systemProp.https.protocols=TLSv1,TLSv1.1,TLSv1.2\n \n jacocoExclusions=com/linecorp/armeria/internal/common/CurrentJavaVersionSpecific,META-INF/versions/**\n+\n+# Scala options\n+scalaVersions=2.13.3\n+defaultScalaVersions=2.13.2", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84c1a22063b1899e56832ef09feff138f59d1cef"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM5Mjc5MQ==", "bodyText": "Oops... it was cruft. Actually, I removed gradle-scala-multiversion-plugin and add scalapb_2.12 and scalapb_2.13 because it is difficult to integrate gradle-scala-multiversion-plugin with Armeria's gradle scripts.\nAnd we need a lot of workarounds and some of them are flaky. \ud83d\ude05", "url": "https://github.com/line/armeria/pull/3124#discussion_r524392791", "createdAt": "2020-11-16T16:20:00Z", "author": {"login": "ikhoon"}, "path": "gradle.properties", "diffHunk": "@@ -26,3 +26,7 @@ org.gradle.jvmargs=-Xmx1280m\n systemProp.https.protocols=TLSv1,TLSv1.1,TLSv1.2\n \n jacocoExclusions=com/linecorp/armeria/internal/common/CurrentJavaVersionSpecific,META-INF/versions/**\n+\n+# Scala options\n+scalaVersions=2.13.3\n+defaultScalaVersions=2.13.2", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk2MDc2MQ=="}, "originalCommit": {"oid": "84c1a22063b1899e56832ef09feff138f59d1cef"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTMwMjU1OnYy", "diffSide": "RIGHT", "path": "gradle/scripts/lib/java-publish.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwODoxNzo1NFrOHzsEew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwODoxNzo1NFrOHzsEew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk2MTQ2Nw==", "bodyText": "Could we do a little bit more strict regular expression matching to extract the suffix, so that a poorly formatted version number is not accepted?\nShouldn't we detect the Scala version from the scala-library dependency in dependencies.yml?", "url": "https://github.com/line/armeria/pull/3124#discussion_r523961467", "createdAt": "2020-11-16T08:17:54Z", "author": {"login": "trustin"}, "path": "gradle/scripts/lib/java-publish.gradle", "diffHunk": "@@ -23,7 +23,16 @@ configure(projectsWithFlags('publish', 'java')) {\n                     jarOverrideFile = tasks.trimShadedJar.outJarFiles.find() as File\n                     jarOverrideTask = tasks.trimShadedJar\n                 } else if (tasks.findByName('shadedJar')) {\n-                    jarOverrideFile = tasks.shadedJar.archivePath\n+                    def archivePath = tasks.shadedJar.archivePath\n+                    if (project.hasFlags('scala')) {\n+                        def microVersionIndex = project.ext.defaultScalaVersions.lastIndexOf('.')\n+                        def scalaVersionSuffix = project.ext.defaultScalaVersions.substring(0, microVersionIndex)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84c1a22063b1899e56832ef09feff138f59d1cef"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTMwMzIyOnYy", "diffSide": "RIGHT", "path": "gradle/scripts/lib/java-shade.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwODoxODowNlrOHzsE5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwODoxODowNlrOHzsE5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk2MTU3NQ==", "bodyText": "Ditto", "url": "https://github.com/line/armeria/pull/3124#discussion_r523961575", "createdAt": "2020-11-16T08:18:06Z", "author": {"login": "trustin"}, "path": "gradle/scripts/lib/java-shade.gradle", "diffHunk": "@@ -70,7 +70,15 @@ configure(relocatedProjects) {\n             description: 'Extracts the shaded test JAR.',\n             dependsOn: tasks.shadedTestJar) {\n \n-        from(zipTree(tasks.shadedTestJar.archivePath))\n+        def archivePath = tasks.shadedTestJar.archivePath\n+        if (project.hasFlags('scala')) {\n+            def microVersionIndex = project.ext.defaultScalaVersions.lastIndexOf('.')\n+            def scalaVersionSuffix = project.ext.defaultScalaVersions.substring(0, microVersionIndex)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84c1a22063b1899e56832ef09feff138f59d1cef"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTMyMDIxOnYy", "diffSide": "RIGHT", "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufResponseConverterFunction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwODoyMjo1M1rOHzsOtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwODoyMjo1M1rOHzsOtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk2NDA4Nw==", "bodyText": "the annotated service -> an annotated service?", "url": "https://github.com/line/armeria/pull/3124#discussion_r523964087", "createdAt": "2020-11-16T08:22:53Z", "author": {"login": "trustin"}, "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufResponseConverterFunction.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.linecorp.armeria.internal.server.ResponseConversionUtil.aggregateFrom;\n+import static com.linecorp.armeria.server.protobuf.ProtobufRequestConverterFunction.isJson;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Publisher;\n+\n+import com.google.common.collect.Streams;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.MessageLite;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Printer;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.ResponseConverterFunction;\n+\n+/**\n+ * A {@link ResponseConverterFunction} which creates an {@link HttpResponse} with\n+ * {@code content-type: application/protobuf} or {@code content-type: application/json; charset=utf-8}.\n+ * If the returned object is instance of {@link MessageLite}, the object can be converted to either\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/encoding\">Protocol Buffers</a> or\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/proto3#json\">JSON</a> format.\n+ *\n+ * <h3>Conversion of multiple Protobuf messages</h3>\n+ * A sequence of Protocol Buffer messages can not be handled by this {@link ResponseConverterFunction},\n+ * because Protocol Buffers wire format is not self-delimiting.\n+ * See\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * However, {@link Publisher}, {@link Stream} and {@link Iterable} are supported when converting to\n+ * <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a>.\n+ *\n+ * <p>Note that this {@link ResponseConverterFunction} is applied to the annotated service by default,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84c1a22063b1899e56832ef09feff138f59d1cef"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTMyMTQ5OnYy", "diffSide": "RIGHT", "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufResponseConverterFunction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwODoyMzoxNVrOHzsPbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwODoyMzoxNVrOHzsPbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk2NDI3MA==", "bodyText": "set -> specify this converter", "url": "https://github.com/line/armeria/pull/3124#discussion_r523964270", "createdAt": "2020-11-16T08:23:15Z", "author": {"login": "trustin"}, "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufResponseConverterFunction.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.linecorp.armeria.internal.server.ResponseConversionUtil.aggregateFrom;\n+import static com.linecorp.armeria.server.protobuf.ProtobufRequestConverterFunction.isJson;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Publisher;\n+\n+import com.google.common.collect.Streams;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.MessageLite;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Printer;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.ResponseConverterFunction;\n+\n+/**\n+ * A {@link ResponseConverterFunction} which creates an {@link HttpResponse} with\n+ * {@code content-type: application/protobuf} or {@code content-type: application/json; charset=utf-8}.\n+ * If the returned object is instance of {@link MessageLite}, the object can be converted to either\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/encoding\">Protocol Buffers</a> or\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/proto3#json\">JSON</a> format.\n+ *\n+ * <h3>Conversion of multiple Protobuf messages</h3>\n+ * A sequence of Protocol Buffer messages can not be handled by this {@link ResponseConverterFunction},\n+ * because Protocol Buffers wire format is not self-delimiting.\n+ * See\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/techniques#streaming\">Streaming Multiple Messages</a>\n+ * for more information.\n+ * However, {@link Publisher}, {@link Stream} and {@link Iterable} are supported when converting to\n+ * <a href=\"https://tools.ietf.org/html/rfc7159#section-5\">JSON array</a>.\n+ *\n+ * <p>Note that this {@link ResponseConverterFunction} is applied to the annotated service by default,\n+ * so you don't have to set explicitly unless you want to use your own {@link Printer}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84c1a22063b1899e56832ef09feff138f59d1cef"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTMyODMwOnYy", "diffSide": "RIGHT", "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/package-info.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwODoyNTowNlrOHzsTLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwODoyNTowNlrOHzsTLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk2NTIyOQ==", "bodyText": "a default -> the default?", "url": "https://github.com/line/armeria/pull/3124#discussion_r523965229", "createdAt": "2020-11-16T08:25:06Z", "author": {"login": "trustin"}, "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/package-info.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+/**\n+ * Provides a default {@link com.linecorp.armeria.server.annotation.ResponseConverterFunction}\n+ * which automatically converts a {@link com.google.protobuf.Message} into\n+ * an {@link com.linecorp.armeria.common.HttpResponse} and\n+ * a default {@link com.linecorp.armeria.server.annotation.RequestConverterFunction} which automatically\n+ * converts an {@link com.linecorp.armeria.common.AggregatedHttpRequest} into\n+ * a {@link com.google.protobuf.Message}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84c1a22063b1899e56832ef09feff138f59d1cef"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTMzMjM1OnYy", "diffSide": "RIGHT", "path": "protobuf/src/test/java/com/linecorp/armeria/server/protobuf/ProtobufRequestAnnotatedServiceTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwODoyNjoxM1rOHzsVcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwODoyNjoxM1rOHzsVcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk2NTgwOA==", "bodyText": "Should we also add @Consumes/ProducesProtobuf?", "url": "https://github.com/line/armeria/pull/3124#discussion_r523965808", "createdAt": "2020-11-16T08:26:13Z", "author": {"login": "trustin"}, "path": "protobuf/src/test/java/com/linecorp/armeria/server/protobuf/ProtobufRequestAnnotatedServiceTest.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.CsvSource;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.util.JsonFormat;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.protobuf.testing.Messages.SimpleRequest;\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.annotation.ConsumesJson;\n+import com.linecorp.armeria.server.annotation.Post;\n+import com.linecorp.armeria.testing.junit5.server.ServerExtension;\n+\n+class ProtobufRequestAnnotatedServiceTest {\n+\n+    @RegisterExtension\n+    static ServerExtension server = new ServerExtension() {\n+        @Override\n+        protected void configure(ServerBuilder sb) throws Exception {\n+            sb.annotatedService(new GreetingService());\n+        }\n+    };\n+\n+    WebClient client;\n+\n+    @BeforeEach\n+    void setUp() {\n+        client = WebClient.of(server.httpUri());\n+    }\n+\n+    @Test\n+    void protobufRequest() throws InvalidProtocolBufferException {\n+        final SimpleRequest simpleRequest = SimpleRequest.newBuilder().setPayload(\"Armeria\").build();\n+        final AggregatedHttpResponse response =\n+                client.post(\"/default-content-type\", simpleRequest.toByteArray()).aggregate().join();\n+\n+        assertThat(response.contentUtf8()).isEqualTo(\"Hello, Armeria!\");\n+    }\n+\n+    @Test\n+    void jsonRequest() throws InvalidProtocolBufferException {\n+        final SimpleRequest simpleRequest = SimpleRequest.newBuilder().setPayload(\"Armeria\").build();\n+        final String json = JsonFormat.printer().print(simpleRequest);\n+        final HttpRequest request = HttpRequest.of(HttpMethod.POST, \"/json\", MediaType.JSON, json);\n+        final AggregatedHttpResponse response = client.execute(request).aggregate().join();\n+\n+        assertThat(response.contentUtf8()).isEqualTo(\"Hello, Armeria!\");\n+    }\n+\n+    @CsvSource({ \"/json+array\", \"/json+array2\" })\n+    @ParameterizedTest\n+    void jsonArrayRequest(String path) throws InvalidProtocolBufferException {\n+        final SimpleRequest simpleRequest1 = SimpleRequest.newBuilder().setSize(1).build();\n+        final SimpleRequest simpleRequest2 = SimpleRequest.newBuilder().setSize(2).build();\n+        final String json1 = JsonFormat.printer().print(simpleRequest1);\n+        final String json2 = JsonFormat.printer().print(simpleRequest2);\n+        final String jsonArray = ImmutableList.of(json1, json2).stream()\n+                                              .collect(Collectors.joining(\",\", \"[\", \"]\"));\n+        final HttpRequest request = HttpRequest.of(HttpMethod.POST, path, MediaType.JSON, jsonArray);\n+        final AggregatedHttpResponse response = client.execute(request).aggregate().join();\n+\n+        assertThat(response.contentUtf8()).isEqualTo(\"Sum: 3\");\n+    }\n+\n+    @Test\n+    void jsonObjectRequest() throws InvalidProtocolBufferException {\n+        final SimpleRequest simpleRequest1 = SimpleRequest.newBuilder().setSize(1).build();\n+        final SimpleRequest simpleRequest2 = SimpleRequest.newBuilder().setSize(2).build();\n+        final String json1 = JsonFormat.printer().print(simpleRequest1);\n+        final String json2 = JsonFormat.printer().print(simpleRequest2);\n+        final String jsonObject = \"{ \\\"json1\\\":\" + json1 +\n+                                  \", \\\"json2\\\":\" + json2 + '}';\n+\n+        final HttpRequest request = HttpRequest.of(HttpMethod.POST, \"/json+object\", MediaType.JSON, jsonObject);\n+        final AggregatedHttpResponse response = client.execute(request).aggregate().join();\n+\n+        assertThat(response.contentUtf8()).isEqualTo(\"OK\");\n+    }\n+\n+    private static class GreetingService {\n+        @Post(\"/default-content-type\")\n+        public String noContentType(SimpleRequest request) {\n+            return \"Hello, Armeria!\";\n+        }\n+\n+        @Post(\"/json\")\n+        @ConsumesJson", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84c1a22063b1899e56832ef09feff138f59d1cef"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTM0MjUzOnYy", "diffSide": "RIGHT", "path": "scalapb/src/main/scala/com/linecorp/armeria/server/scalapb/ScalaPbRequestConverterFunction.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwODoyODo1NVrOHzsbMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwODoyODo1NVrOHzsbMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk2NzI4MA==", "bodyText": "when -> only when", "url": "https://github.com/line/armeria/pull/3124#discussion_r523967280", "createdAt": "2020-11-16T08:28:55Z", "author": {"login": "trustin"}, "path": "scalapb/src/main/scala/com/linecorp/armeria/server/scalapb/ScalaPbRequestConverterFunction.scala", "diffHunk": "@@ -0,0 +1,284 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.scalapb\n+\n+import com.fasterxml.jackson.databind.{JsonNode, ObjectMapper}\n+import com.google.common.collect._\n+import com.google.protobuf.CodedInputStream\n+import com.linecorp.armeria.common.AggregatedHttpRequest\n+import com.linecorp.armeria.common.annotation.UnstableApi\n+import com.linecorp.armeria.server.ServiceRequestContext\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction\n+import com.linecorp.armeria.server.scalapb.ScalaPbConverterUtil.ResultType._\n+import com.linecorp.armeria.server.scalapb.ScalaPbConverterUtil._\n+import com.linecorp.armeria.server.scalapb.ScalaPbRequestConverterFunction._\n+import java.lang.invoke.{MethodHandle, MethodHandles, MethodType}\n+import java.lang.reflect.{ParameterizedType, Type}\n+import java.nio.charset.StandardCharsets\n+import java.util.concurrent.ConcurrentMap\n+import javax.annotation.Nullable\n+import scalapb.json4s.Parser\n+import scalapb.{GeneratedMessage, GeneratedMessageCompanion}\n+\n+/**\n+  * A [[com.linecorp.armeria.server.annotation.RequestConverterFunction]] which converts a Protocol Buffers or\n+  * JSON body of the [[com.linecorp.armeria.common.AggregatedHttpRequest]] to an [[scalapb.GeneratedMessage]].\n+  *\n+  * The built-in parser of [[scalapb.GeneratedMessage]] for Protocol Buffers is applied only when\n+  * the `content-type` of [[com.linecorp.armeria.common.RequestHeaders]] is either\n+  * one of [[com.linecorp.armeria.common.MediaType.PROTOBUF]] or\n+  * [[com.linecorp.armeria.common.MediaType.OCTET_STREAM]] or\n+  * `application/x-protobuf`.\n+  * The [[scalapb.json4s.Parser]] for JSON is applied only when the `content-type` of\n+  * the [[com.linecorp.armeria.common.RequestHeaders]] is either [[com.linecorp.armeria.common.MediaType.JSON]]\n+  * or ends with `+json`.\n+  *\n+  * ===Conversion of multiple Protobuf messages===\n+  * A sequence of Protocol Buffer messages can not be handled by this\n+  * [[com.linecorp.armeria.server.annotation.RequestConverterFunction]],\n+  * because Protocol Buffers wire format is not self-delimiting.\n+  * See [[https://developers.google.com/protocol-buffers/docs/techniques#streaming Streaming Multiple Messages]]\n+  * for more information.\n+  * However, [[scala.Iterable]] types such as `List[scalapb.GeneratedMessage]` and\n+  * `Set[scalapb.GeneratedMessage]` are supported when converted from", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84c1a22063b1899e56832ef09feff138f59d1cef"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTM0NDAzOnYy", "diffSide": "RIGHT", "path": "scalapb/src/main/scala/com/linecorp/armeria/server/scalapb/ScalaPbRequestConverterFunction.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwODoyOToxN1rOHzscAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwODoyOToxN1rOHzscAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk2NzQ5MQ==", "bodyText": "the annotated -> an annotated", "url": "https://github.com/line/armeria/pull/3124#discussion_r523967491", "createdAt": "2020-11-16T08:29:17Z", "author": {"login": "trustin"}, "path": "scalapb/src/main/scala/com/linecorp/armeria/server/scalapb/ScalaPbRequestConverterFunction.scala", "diffHunk": "@@ -0,0 +1,284 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.scalapb\n+\n+import com.fasterxml.jackson.databind.{JsonNode, ObjectMapper}\n+import com.google.common.collect._\n+import com.google.protobuf.CodedInputStream\n+import com.linecorp.armeria.common.AggregatedHttpRequest\n+import com.linecorp.armeria.common.annotation.UnstableApi\n+import com.linecorp.armeria.server.ServiceRequestContext\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction\n+import com.linecorp.armeria.server.scalapb.ScalaPbConverterUtil.ResultType._\n+import com.linecorp.armeria.server.scalapb.ScalaPbConverterUtil._\n+import com.linecorp.armeria.server.scalapb.ScalaPbRequestConverterFunction._\n+import java.lang.invoke.{MethodHandle, MethodHandles, MethodType}\n+import java.lang.reflect.{ParameterizedType, Type}\n+import java.nio.charset.StandardCharsets\n+import java.util.concurrent.ConcurrentMap\n+import javax.annotation.Nullable\n+import scalapb.json4s.Parser\n+import scalapb.{GeneratedMessage, GeneratedMessageCompanion}\n+\n+/**\n+  * A [[com.linecorp.armeria.server.annotation.RequestConverterFunction]] which converts a Protocol Buffers or\n+  * JSON body of the [[com.linecorp.armeria.common.AggregatedHttpRequest]] to an [[scalapb.GeneratedMessage]].\n+  *\n+  * The built-in parser of [[scalapb.GeneratedMessage]] for Protocol Buffers is applied only when\n+  * the `content-type` of [[com.linecorp.armeria.common.RequestHeaders]] is either\n+  * one of [[com.linecorp.armeria.common.MediaType.PROTOBUF]] or\n+  * [[com.linecorp.armeria.common.MediaType.OCTET_STREAM]] or\n+  * `application/x-protobuf`.\n+  * The [[scalapb.json4s.Parser]] for JSON is applied only when the `content-type` of\n+  * the [[com.linecorp.armeria.common.RequestHeaders]] is either [[com.linecorp.armeria.common.MediaType.JSON]]\n+  * or ends with `+json`.\n+  *\n+  * ===Conversion of multiple Protobuf messages===\n+  * A sequence of Protocol Buffer messages can not be handled by this\n+  * [[com.linecorp.armeria.server.annotation.RequestConverterFunction]],\n+  * because Protocol Buffers wire format is not self-delimiting.\n+  * See [[https://developers.google.com/protocol-buffers/docs/techniques#streaming Streaming Multiple Messages]]\n+  * for more information.\n+  * However, [[scala.Iterable]] types such as `List[scalapb.GeneratedMessage]` and\n+  * `Set[scalapb.GeneratedMessage]` are supported when converted from\n+  * [[https://tools.ietf.org/html/rfc7159#section-5 JSON array]].\n+  *\n+  * Note that this [[com.linecorp.armeria.server.annotation.RequestConverterFunction]] is applied to\n+  * the annotated service by default, so you don't have to set explicitly unless you want to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84c1a22063b1899e56832ef09feff138f59d1cef"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NTM1MzYzOnYy", "diffSide": "RIGHT", "path": "scalapb/src/test/scala/com/linecorp/armeria/server/scalapb/ScalaPbRequestConverterFunctionTest.scala", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQwODozMTo0NFrOHzshkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxNjozNDoyOVrOH0HDOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk2ODkxNQ==", "bodyText": "We're mixing stream.Stream and java.util.stream.Stream. Maybe better using a single form?", "url": "https://github.com/line/armeria/pull/3124#discussion_r523968915", "createdAt": "2020-11-16T08:31:44Z", "author": {"login": "trustin"}, "path": "scalapb/src/test/scala/com/linecorp/armeria/server/scalapb/ScalaPbRequestConverterFunctionTest.scala", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.scalapb\n+\n+import com.google.common.collect.{ImmutableList, ImmutableMap, ImmutableSet}\n+import com.google.common.reflect.TypeToken\n+import com.linecorp.armeria.common._\n+import com.linecorp.armeria.scalapb.testing.messages.SimpleRequest\n+import com.linecorp.armeria.server.ServiceRequestContext\n+import com.linecorp.armeria.server.annotation.FallthroughException\n+import com.linecorp.armeria.server.scalapb.ScalaPbRequestConverterFunctionTest._\n+import java.lang.reflect.ParameterizedType\n+import java.util.stream\n+import java.util.stream.Collectors\n+import org.assertj.core.api.Assertions.{assertThat, assertThatThrownBy}\n+import org.junit.jupiter.api.Test\n+import org.junit.jupiter.api.`extension`.ExtensionContext\n+import org.junit.jupiter.params.ParameterizedTest\n+import org.junit.jupiter.params.provider.{Arguments, ArgumentsProvider, ArgumentsSource}\n+import scala.collection.mutable.ArrayBuffer\n+import scalapb.GeneratedMessage\n+import scalapb.json4s.Printer\n+import sun.net.www.protocol.http.AuthenticatorKeys.getKey\n+\n+class ScalaPbRequestConverterFunctionTest {\n+\n+  @Test\n+  def protobufToMessage(): Unit = {\n+    val converter = ScalaPbRequestConverterFunction()\n+    val req = AggregatedHttpRequest.of(ctx.request.headers, HttpData.wrap(simpleRequest1.toByteArray));\n+    val requestObject = converter.convertRequest(ctx, req, classOf[SimpleRequest], null)\n+    assertThat(requestObject).isEqualTo(simpleRequest1)\n+  }\n+\n+  @Test\n+  def failProtobufToCollection(): Unit = {\n+    val typeToken = new TypeToken[List[SimpleRequest]]() {}\n+    val converter = ScalaPbRequestConverterFunction()\n+    val req = AggregatedHttpRequest.of(ctx.request.headers, HttpData.wrap(simpleRequest1.toByteArray))\n+    assertThatThrownBy(() =>\n+      converter.convertRequest(ctx, req, classOf[List[_]], typeToken.getType.asInstanceOf[ParameterizedType]))\n+      .isInstanceOf(classOf[FallthroughException])\n+  }\n+\n+  @Test\n+  def jsonToMessage(): Unit = {\n+    val converter = ScalaPbRequestConverterFunction()\n+    val req = AggregatedHttpRequest.of(\n+      ctx.request.headers.withMutations(builder => builder.contentType(MediaType.JSON)),\n+      HttpData.ofUtf8(printer.print(simpleRequest1)))\n+    val requestObject = converter.convertRequest(ctx, req, classOf[SimpleRequest], null)\n+    assertThat(requestObject).isEqualTo(simpleRequest1)\n+  }\n+\n+  @ArgumentsSource(classOf[JsonArrayRequestProvider])\n+  @ParameterizedTest\n+  def jsonArrayToCollection(collection: Any, json: String, typeToken: TypeToken[_]): Unit = {\n+    val converter = ScalaPbRequestConverterFunction()\n+    val req = AggregatedHttpRequest.of(\n+      ctx.request.headers\n+        .withMutations(builder => builder.contentType(MediaType.JSON)),\n+      HttpData.ofUtf8(json))\n+    val requestObject =\n+      converter.convertRequest(\n+        ctx,\n+        req,\n+        typeToken.getRawType,\n+        typeToken.getType.asInstanceOf[ParameterizedType])\n+    assertThat(requestObject).isEqualTo(collection)\n+  }\n+\n+  @ArgumentsSource(classOf[JsonObjectRequestProvider])\n+  @ParameterizedTest\n+  def jsonObjectToMap(map: Any, json: String, typeToken: TypeToken[_]): Unit = {\n+    val converter = ScalaPbRequestConverterFunction()\n+    val req = AggregatedHttpRequest.of(\n+      ctx.request.headers\n+        .withMutations(builder => builder.contentType(MediaType.JSON)),\n+      HttpData.ofUtf8(json))\n+    val requestObject =\n+      converter.convertRequest(\n+        ctx,\n+        req,\n+        typeToken.getRawType,\n+        typeToken.getType.asInstanceOf[ParameterizedType])\n+    assertThat(requestObject).isEqualTo(map)\n+  }\n+\n+  @ArgumentsSource(classOf[JsonArrayRequestProvider])\n+  @ParameterizedTest\n+  def jsonArrayWithNoContentType(collection: Any, json: String, typeToken: TypeToken[_]): Unit = {\n+    val converter = ScalaPbRequestConverterFunction()\n+    val req = AggregatedHttpRequest.of(ctx.request.headers, HttpData.ofUtf8(json))\n+    assertThatThrownBy { () =>\n+      converter.convertRequest(\n+        ctx,\n+        req,\n+        typeToken.getRawType,\n+        typeToken.getType.asInstanceOf[ParameterizedType])\n+    }.isInstanceOf(classOf[FallthroughException])\n+  }\n+}\n+\n+private[scalapb] object ScalaPbRequestConverterFunctionTest {\n+\n+  private val ctx: ServiceRequestContext = ServiceRequestContext.of(HttpRequest.of(HttpMethod.POST, \"/\"))\n+\n+  private val simpleRequest1: SimpleRequest = SimpleRequest(\"Armeria\")\n+  private val simpleRequest2: SimpleRequest = SimpleRequest(\"Protobuf\")\n+  private val printer: Printer = new Printer()\n+\n+  private class JsonArrayRequestProvider extends ArgumentsProvider {\n+    override def provideArguments(context: ExtensionContext): stream.Stream[Arguments] = {\n+      val list = List(simpleRequest1, simpleRequest2)\n+      val vector = list.toVector\n+      val set = list.toSet\n+      val jlist = ImmutableList.of(simpleRequest1, simpleRequest2);\n+      val jset = ImmutableSet.of(simpleRequest1, simpleRequest2);\n+\n+      java.util.stream.Stream.of(\n+        Arguments.of(list, toJson(list), new TypeToken[List[SimpleRequest]]() {}),\n+        Arguments.of(vector, toJson(vector), new TypeToken[Vector[SimpleRequest]]() {}),\n+        Arguments.of(set, toJson(set), new TypeToken[Set[SimpleRequest]]() {}),\n+        Arguments.of(jlist, toJson(jlist), new TypeToken[java.util.List[SimpleRequest]]() {}),\n+        Arguments.of(jset, toJson(jset), new TypeToken[java.util.Set[SimpleRequest]]() {})\n+      )\n+    }\n+\n+  }\n+\n+  private class JsonObjectRequestProvider extends ArgumentsProvider {\n+    override def provideArguments(context: ExtensionContext): stream.Stream[Arguments] = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84c1a22063b1899e56832ef09feff138f59d1cef"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQwMzUxNQ==", "bodyText": "Agreed!", "url": "https://github.com/line/armeria/pull/3124#discussion_r524403515", "createdAt": "2020-11-16T16:34:29Z", "author": {"login": "ikhoon"}, "path": "scalapb/src/test/scala/com/linecorp/armeria/server/scalapb/ScalaPbRequestConverterFunctionTest.scala", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.scalapb\n+\n+import com.google.common.collect.{ImmutableList, ImmutableMap, ImmutableSet}\n+import com.google.common.reflect.TypeToken\n+import com.linecorp.armeria.common._\n+import com.linecorp.armeria.scalapb.testing.messages.SimpleRequest\n+import com.linecorp.armeria.server.ServiceRequestContext\n+import com.linecorp.armeria.server.annotation.FallthroughException\n+import com.linecorp.armeria.server.scalapb.ScalaPbRequestConverterFunctionTest._\n+import java.lang.reflect.ParameterizedType\n+import java.util.stream\n+import java.util.stream.Collectors\n+import org.assertj.core.api.Assertions.{assertThat, assertThatThrownBy}\n+import org.junit.jupiter.api.Test\n+import org.junit.jupiter.api.`extension`.ExtensionContext\n+import org.junit.jupiter.params.ParameterizedTest\n+import org.junit.jupiter.params.provider.{Arguments, ArgumentsProvider, ArgumentsSource}\n+import scala.collection.mutable.ArrayBuffer\n+import scalapb.GeneratedMessage\n+import scalapb.json4s.Printer\n+import sun.net.www.protocol.http.AuthenticatorKeys.getKey\n+\n+class ScalaPbRequestConverterFunctionTest {\n+\n+  @Test\n+  def protobufToMessage(): Unit = {\n+    val converter = ScalaPbRequestConverterFunction()\n+    val req = AggregatedHttpRequest.of(ctx.request.headers, HttpData.wrap(simpleRequest1.toByteArray));\n+    val requestObject = converter.convertRequest(ctx, req, classOf[SimpleRequest], null)\n+    assertThat(requestObject).isEqualTo(simpleRequest1)\n+  }\n+\n+  @Test\n+  def failProtobufToCollection(): Unit = {\n+    val typeToken = new TypeToken[List[SimpleRequest]]() {}\n+    val converter = ScalaPbRequestConverterFunction()\n+    val req = AggregatedHttpRequest.of(ctx.request.headers, HttpData.wrap(simpleRequest1.toByteArray))\n+    assertThatThrownBy(() =>\n+      converter.convertRequest(ctx, req, classOf[List[_]], typeToken.getType.asInstanceOf[ParameterizedType]))\n+      .isInstanceOf(classOf[FallthroughException])\n+  }\n+\n+  @Test\n+  def jsonToMessage(): Unit = {\n+    val converter = ScalaPbRequestConverterFunction()\n+    val req = AggregatedHttpRequest.of(\n+      ctx.request.headers.withMutations(builder => builder.contentType(MediaType.JSON)),\n+      HttpData.ofUtf8(printer.print(simpleRequest1)))\n+    val requestObject = converter.convertRequest(ctx, req, classOf[SimpleRequest], null)\n+    assertThat(requestObject).isEqualTo(simpleRequest1)\n+  }\n+\n+  @ArgumentsSource(classOf[JsonArrayRequestProvider])\n+  @ParameterizedTest\n+  def jsonArrayToCollection(collection: Any, json: String, typeToken: TypeToken[_]): Unit = {\n+    val converter = ScalaPbRequestConverterFunction()\n+    val req = AggregatedHttpRequest.of(\n+      ctx.request.headers\n+        .withMutations(builder => builder.contentType(MediaType.JSON)),\n+      HttpData.ofUtf8(json))\n+    val requestObject =\n+      converter.convertRequest(\n+        ctx,\n+        req,\n+        typeToken.getRawType,\n+        typeToken.getType.asInstanceOf[ParameterizedType])\n+    assertThat(requestObject).isEqualTo(collection)\n+  }\n+\n+  @ArgumentsSource(classOf[JsonObjectRequestProvider])\n+  @ParameterizedTest\n+  def jsonObjectToMap(map: Any, json: String, typeToken: TypeToken[_]): Unit = {\n+    val converter = ScalaPbRequestConverterFunction()\n+    val req = AggregatedHttpRequest.of(\n+      ctx.request.headers\n+        .withMutations(builder => builder.contentType(MediaType.JSON)),\n+      HttpData.ofUtf8(json))\n+    val requestObject =\n+      converter.convertRequest(\n+        ctx,\n+        req,\n+        typeToken.getRawType,\n+        typeToken.getType.asInstanceOf[ParameterizedType])\n+    assertThat(requestObject).isEqualTo(map)\n+  }\n+\n+  @ArgumentsSource(classOf[JsonArrayRequestProvider])\n+  @ParameterizedTest\n+  def jsonArrayWithNoContentType(collection: Any, json: String, typeToken: TypeToken[_]): Unit = {\n+    val converter = ScalaPbRequestConverterFunction()\n+    val req = AggregatedHttpRequest.of(ctx.request.headers, HttpData.ofUtf8(json))\n+    assertThatThrownBy { () =>\n+      converter.convertRequest(\n+        ctx,\n+        req,\n+        typeToken.getRawType,\n+        typeToken.getType.asInstanceOf[ParameterizedType])\n+    }.isInstanceOf(classOf[FallthroughException])\n+  }\n+}\n+\n+private[scalapb] object ScalaPbRequestConverterFunctionTest {\n+\n+  private val ctx: ServiceRequestContext = ServiceRequestContext.of(HttpRequest.of(HttpMethod.POST, \"/\"))\n+\n+  private val simpleRequest1: SimpleRequest = SimpleRequest(\"Armeria\")\n+  private val simpleRequest2: SimpleRequest = SimpleRequest(\"Protobuf\")\n+  private val printer: Printer = new Printer()\n+\n+  private class JsonArrayRequestProvider extends ArgumentsProvider {\n+    override def provideArguments(context: ExtensionContext): stream.Stream[Arguments] = {\n+      val list = List(simpleRequest1, simpleRequest2)\n+      val vector = list.toVector\n+      val set = list.toSet\n+      val jlist = ImmutableList.of(simpleRequest1, simpleRequest2);\n+      val jset = ImmutableSet.of(simpleRequest1, simpleRequest2);\n+\n+      java.util.stream.Stream.of(\n+        Arguments.of(list, toJson(list), new TypeToken[List[SimpleRequest]]() {}),\n+        Arguments.of(vector, toJson(vector), new TypeToken[Vector[SimpleRequest]]() {}),\n+        Arguments.of(set, toJson(set), new TypeToken[Set[SimpleRequest]]() {}),\n+        Arguments.of(jlist, toJson(jlist), new TypeToken[java.util.List[SimpleRequest]]() {}),\n+        Arguments.of(jset, toJson(jset), new TypeToken[java.util.Set[SimpleRequest]]() {})\n+      )\n+    }\n+\n+  }\n+\n+  private class JsonObjectRequestProvider extends ArgumentsProvider {\n+    override def provideArguments(context: ExtensionContext): stream.Stream[Arguments] = {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk2ODkxNQ=="}, "originalCommit": {"oid": "84c1a22063b1899e56832ef09feff138f59d1cef"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMTI4MjE4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/server/annotation/RequestConverterFunctionProvider.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwMToyNjoxN1rOH2I7WQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwMzoxNTozM1rOH2LGGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUzMTQxNw==", "bodyText": "\u2753", "url": "https://github.com/line/armeria/pull/3124#discussion_r526531417", "createdAt": "2020-11-19T01:26:17Z", "author": {"login": "minwoox"}, "path": "core/src/main/java/com/linecorp/armeria/server/annotation/RequestConverterFunctionProvider.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*\n+ * Copyright 2018 LINE Corporation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e8efa0b45daa72cd881131e7a7a650e68040005"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU2NjkzNw==", "bodyText": "\ud83d\ude31", "url": "https://github.com/line/armeria/pull/3124#discussion_r526566937", "createdAt": "2020-11-19T03:15:33Z", "author": {"login": "ikhoon"}, "path": "core/src/main/java/com/linecorp/armeria/server/annotation/RequestConverterFunctionProvider.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*\n+ * Copyright 2018 LINE Corporation", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUzMTQxNw=="}, "originalCommit": {"oid": "4e8efa0b45daa72cd881131e7a7a650e68040005"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMTI5NTQ3OnYy", "diffSide": "RIGHT", "path": "scalapb/scalapb_2.13/build.gradle", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwMTozMjoxMFrOH2JC3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwMTozMjoxMFrOH2JC3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUzMzM0Mw==", "bodyText": "nit: two empty lines", "url": "https://github.com/line/armeria/pull/3124#discussion_r526533343", "createdAt": "2020-11-19T01:32:10Z", "author": {"login": "minwoox"}, "path": "scalapb/scalapb_2.13/build.gradle", "diffHunk": "@@ -0,0 +1,56 @@\n+plugins {\n+    id 'scala'\n+    id 'cz.alenkacz.gradle.scalafmt' version '1.14.0'\n+}\n+\n+dependencies {\n+    // TODO(ikhoon): Copy ScalaPBJsonMarshaller and GrpcScalaDocServicePlugin from examples/grpc-scala\n+    implementation project(':grpc')\n+    implementation 'org.scala-lang:scala-library:2.13.3'\n+\n+    // ScalaPB\n+    api \"com.thesamet.scalapb:scalapb-json4s_2.13\"\n+    implementation \"com.thesamet.scalapb:scalapb-runtime_2.13\"\n+    implementation \"com.thesamet.scalapb:scalapb-runtime-grpc_2.13\"\n+}\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e8efa0b45daa72cd881131e7a7a650e68040005"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMTI5NjM1OnYy", "diffSide": "RIGHT", "path": "scalapb/scalapb_2.13/build.gradle", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwMTozMjozMlrOH2JDWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwMTozMjozMlrOH2JDWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUzMzQ2Ng==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/line/armeria/pull/3124#discussion_r526533466", "createdAt": "2020-11-19T01:32:32Z", "author": {"login": "minwoox"}, "path": "scalapb/scalapb_2.13/build.gradle", "diffHunk": "@@ -0,0 +1,56 @@\n+plugins {\n+    id 'scala'\n+    id 'cz.alenkacz.gradle.scalafmt' version '1.14.0'\n+}\n+\n+dependencies {\n+    // TODO(ikhoon): Copy ScalaPBJsonMarshaller and GrpcScalaDocServicePlugin from examples/grpc-scala\n+    implementation project(':grpc')\n+    implementation 'org.scala-lang:scala-library:2.13.3'\n+\n+    // ScalaPB\n+    api \"com.thesamet.scalapb:scalapb-json4s_2.13\"\n+    implementation \"com.thesamet.scalapb:scalapb-runtime_2.13\"\n+    implementation \"com.thesamet.scalapb:scalapb-runtime-grpc_2.13\"\n+}\n+\n+\n+compileScala.targetCompatibility = 1.8\n+ScalaCompileOptions.metaClass.useAnt = false\n+\n+tasks.withType(ScalaCompile) {\n+    scalaCompileOptions.with {\n+        // Disable incremental compilation to avoid intermittent compile errors.\n+        force = true\n+    }\n+}\n+\n+sourceSets {\n+    test {\n+        scala {\n+            srcDirs \"${protobuf.generatedFilesBaseDir}/test/scalapb\"\n+        }\n+    }\n+}\n+\n+// Run `scalafmt` to automatically format scala code from source sets\n+// https://github.com/alenkacz/gradle-scalafmt#tasks\n+project.ext.getLintTask().dependsOn tasks.checkScalafmt", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e8efa0b45daa72cd881131e7a7a650e68040005"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMTU4NzI3OnYy", "diffSide": "RIGHT", "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufResponseConverterFunction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwMzo0ODoxMlrOH2Lqrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwMzo0ODoxMlrOH2Lqrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU3NjMwMg==", "bodyText": "instance of -> a (or an instance of)", "url": "https://github.com/line/armeria/pull/3124#discussion_r526576302", "createdAt": "2020-11-19T03:48:12Z", "author": {"login": "trustin"}, "path": "protobuf/src/main/java/com/linecorp/armeria/server/protobuf/ProtobufResponseConverterFunction.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.protobuf;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.linecorp.armeria.internal.server.ResponseConversionUtil.aggregateFrom;\n+import static com.linecorp.armeria.server.protobuf.ProtobufRequestConverterFunction.isJson;\n+import static com.linecorp.armeria.server.protobuf.ProtobufRequestConverterFunction.isProtobuf;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Publisher;\n+\n+import com.google.common.collect.Streams;\n+import com.google.protobuf.Message;\n+import com.google.protobuf.MessageLite;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.protobuf.util.JsonFormat.Printer;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.annotation.UnstableApi;\n+import com.linecorp.armeria.common.util.Exceptions;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.annotation.ResponseConverterFunction;\n+\n+/**\n+ * A {@link ResponseConverterFunction} which creates an {@link HttpResponse} with\n+ * {@code content-type: application/protobuf} or {@code content-type: application/json; charset=utf-8}.\n+ * If the returned object is instance of {@link MessageLite}, the object can be converted to either", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e924fd0eeb233c9be8deb18a5fc28b49d5703309"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMTU5Mjk3OnYy", "diffSide": "RIGHT", "path": "scalapb/scalapb_2.13/src/main/scala/com/linecorp/armeria/server/scalapb/ScalaPbRequestConverterFunction.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwMzo1MToxNVrOH2Lt7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwMzo1MToxNVrOH2Lt7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU3NzEzMg==", "bodyText": "Global comment: indentation?", "url": "https://github.com/line/armeria/pull/3124#discussion_r526577132", "createdAt": "2020-11-19T03:51:15Z", "author": {"login": "trustin"}, "path": "scalapb/scalapb_2.13/src/main/scala/com/linecorp/armeria/server/scalapb/ScalaPbRequestConverterFunction.scala", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.scalapb\n+\n+import com.fasterxml.jackson.databind.{JsonNode, ObjectMapper}\n+import com.google.common.collect._\n+import com.google.protobuf.CodedInputStream\n+import com.linecorp.armeria.common.AggregatedHttpRequest\n+import com.linecorp.armeria.common.annotation.UnstableApi\n+import com.linecorp.armeria.server.ServiceRequestContext\n+import com.linecorp.armeria.server.annotation.RequestConverterFunction\n+import com.linecorp.armeria.server.scalapb.ScalaPbConverterUtil.ResultType._\n+import com.linecorp.armeria.server.scalapb.ScalaPbConverterUtil._\n+import com.linecorp.armeria.server.scalapb.ScalaPbRequestConverterFunction._\n+import java.lang.invoke.{MethodHandle, MethodHandles, MethodType}\n+import java.lang.reflect.{ParameterizedType, Type}\n+import java.nio.charset.StandardCharsets\n+import java.util.concurrent.ConcurrentMap\n+import javax.annotation.Nullable\n+import scalapb.json4s.Parser\n+import scalapb.{GeneratedMessage, GeneratedMessageCompanion}\n+\n+/**\n+  * A [[com.linecorp.armeria.server.annotation.RequestConverterFunction]] which converts either\n+  * a Protocol Buffers or JSON body of the [[com.linecorp.armeria.common.AggregatedHttpRequest]]\n+  * to an [[scalapb.GeneratedMessage]].\n+  *\n+  * The built-in parser of [[scalapb.GeneratedMessage]] for Protocol Buffers is applied only when\n+  * the `content-type` of [[com.linecorp.armeria.common.RequestHeaders]] is either\n+  * one of [[com.linecorp.armeria.common.MediaType.PROTOBUF]] or\n+  * [[com.linecorp.armeria.common.MediaType.OCTET_STREAM]] or\n+  * `application/x-protobuf`.\n+  * The [[scalapb.json4s.Parser]] for JSON is applied only when the `content-type` of\n+  * the [[com.linecorp.armeria.common.RequestHeaders]] is either [[com.linecorp.armeria.common.MediaType.JSON]]\n+  * or ends with `+json`.\n+  *\n+  * ===Conversion of multiple Protobuf messages===\n+  * A sequence of Protocol Buffer messages can not be handled by this\n+  * [[com.linecorp.armeria.server.annotation.RequestConverterFunction]],\n+  * because Protocol Buffers wire format is not self-delimiting.\n+  * See [[https://developers.google.com/protocol-buffers/docs/techniques#streaming Streaming Multiple Messages]]\n+  * for more information.\n+  * However, [[scala.Iterable]] types such as `List[scalapb.GeneratedMessage]` and\n+  * `Set[scalapb.GeneratedMessage]` are supported only when converted from\n+  * [[https://tools.ietf.org/html/rfc7159#section-5 JSON array]].\n+  *\n+  * Note that this [[com.linecorp.armeria.server.annotation.RequestConverterFunction]] is applied to\n+  * an annotated service by default, so you don't have to specify this converter explicitly unless you want to\n+  * use your own [[scalapb.json4s.Parser]].\n+  */\n+@UnstableApi\n+object ScalaPbRequestConverterFunction {\n+\n+  private val methodCache: ConcurrentMap[Class[_], MethodHandle] =\n+    new MapMaker().weakKeys.makeMap()\n+\n+  private val defaultInstanceCache: ConcurrentMap[Class[_], GeneratedMessage] =\n+    new MapMaker().weakKeys.makeMap()\n+\n+  private val companionCache: ConcurrentMap[Class[_], GeneratedMessageCompanion[_]] =\n+    new MapMaker().weakKeys.makeMap()\n+\n+  private val defaultJsonParser: Parser = new Parser().ignoringUnknownFields\n+  private val mapper = new ObjectMapper\n+\n+  /**\n+    * Creates a new instance with the specified [[scalapb.json4s.Parser]].\n+    */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e924fd0eeb233c9be8deb18a5fc28b49d5703309"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMTU5ODEzOnYy", "diffSide": "RIGHT", "path": "site/src/pages/docs/setup.mdx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwMzo1NDowMVrOH2Lw4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwMzo1NDowMVrOH2Lw4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU3Nzg5MA==", "bodyText": "armeria-scalapb_2.12 and armeria-scalapb_2.13?", "url": "https://github.com/line/armeria/pull/3124#discussion_r526577890", "createdAt": "2020-11-19T03:54:01Z", "author": {"login": "trustin"}, "path": "site/src/pages/docs/setup.mdx", "diffHunk": "@@ -58,6 +60,8 @@ the list of major Armeria artifacts which might interest you:\n +---------------------------------------------+---------------------------------------------------------------------------------+\n | `armeria-saml`                              | SAML support                                                                    |\n +---------------------------------------------+---------------------------------------------------------------------------------+\n+| `armeria-scalapb`                           | Support ScalaPB in annotated service.                                           |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e924fd0eeb233c9be8deb18a5fc28b49d5703309"}, "originalPosition": 13}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1975, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}