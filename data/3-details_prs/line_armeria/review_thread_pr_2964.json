{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYyMDU3ODYy", "number": 2964, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxMTo0MTozMVrOEUknaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxMTo0MTozMVrOEUknaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMDA2ODg4OnYy", "diffSide": "RIGHT", "path": "grpc/src/main/java/com/linecorp/armeria/client/grpc/GrpcWebUtil.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxMTo0MTozMVrOG62Sog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxNDoxOToxN1rOG67Zog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM2MDA5OA==", "bodyText": "nit: Could remove success flag? I think we don't need to check that success is true.", "url": "https://github.com/line/armeria/pull/2964#discussion_r464360098", "createdAt": "2020-08-03T11:41:31Z", "author": {"login": "ikhoon"}, "path": "grpc/src/main/java/com/linecorp/armeria/client/grpc/GrpcWebUtil.java", "diffHunk": "@@ -88,39 +99,76 @@ public static HttpHeaders parseTrailers(ClientRequestContext ctx, HttpData respo\n         requireNonNull(response, \"response\");\n         final SerializationFormat serializationFormat =\n                 ctx.log().ensureAvailable(RequestLogProperty.SCHEME).scheme().serializationFormat();\n+\n+        final ByteBuf buf;\n         if (GrpcSerializationFormats.isGrpcWebText(serializationFormat)) {\n-            // TODO(minwoox) support decoding base64.\n-            return null;\n+            final Base64Decoder decoder = new Base64Decoder(ctx.alloc());\n+            buf = decoder.decode(response.byteBuf());\n+        } else {\n+            buf = response.byteBuf();\n         }\n-        final ByteBuf buf = response.byteBuf();\n-\n-        HttpHeaders trailers = null;\n-        while (buf.isReadable(HEADER_LENGTH)) {\n-            final short type = buf.readUnsignedByte();\n-            if ((type & RESERVED_MASK) != 0) {\n-                // Malformed header\n-                break;\n-            }\n \n-            final int length = buf.readInt();\n-            // 8th (MSB) bit of the 1st gRPC frame byte is:\n-            // - '1' for trailers\n-            // - '0' for data\n-            //\n-            // See: https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md\n-            if (type >> 7 == 1) {\n-                if ((type & 1) > 0) {\n-                    // TODO(minwoox) support compressed trailer.\n+        try {\n+            while (buf.isReadable(HEADER_LENGTH)) {\n+                final short type = buf.readUnsignedByte();\n+                if ((type & RESERVED_MASK) != 0) {\n+                    // Malformed header\n                     break;\n                 }\n-                trailers = InternalGrpcWebUtil.parseGrpcWebTrailers(buf);\n-                break;\n-            } else {\n-                // Skip a gRPC content\n-                buf.skipBytes(length);\n+\n+                final int length = buf.readInt();\n+                // 8th (MSB) bit of the 1st gRPC frame byte is:\n+                // - '1' for trailers\n+                // - '0' for data\n+                //\n+                // See: https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md\n+                if (type >> 7 == 1) {\n+                    if ((type & 1) > 0) {\n+                        // The compressed trailers.\n+                        final ResponseHeaders responseHeaders = ctx.log().ensureAvailable(\n+                                RequestLogProperty.RESPONSE_HEADERS).responseHeaders();\n+                        final String grpcEncoding = responseHeaders.get(GrpcHeaderNames.GRPC_ENCODING);\n+                        // We use DecompressorRegistry in ArmeriaClientCall. If ArmeriaClientCall\n+                        // supports to add another decompressor, we will change this to support that too.\n+                        final DecompressorRegistry registry = DecompressorRegistry.getDefaultInstance();\n+                        if (grpcEncoding == null) {\n+                            // grpc-encoding header is missing.\n+                            return null;\n+                        }\n+                        final Decompressor decompressor = registry.lookupDecompressor(grpcEncoding);\n+                        if (decompressor == null) {\n+                            return null;\n+                        }\n+\n+                        final ByteBuf outputBuf = ctx.alloc().compositeBuffer();\n+                        boolean success = false;\n+                        try (ByteBufInputStream is = new ByteBufInputStream(buf);\n+                             InputStream decompressIs = decompressor.decompress(is);\n+                             ByteBufOutputStream os = new ByteBufOutputStream(outputBuf)) {\n+                            ByteStreams.copy(decompressIs, os);\n+                            success = true;\n+                        } catch (Throwable t) {\n+                            if (!success) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "269d915a5b052c0d333075c17c27176e0aace93b"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM2ODc4Nw==", "bodyText": "or replace catch (Throwable t) with finally? It swallows the exception currently which doesn't sound right.", "url": "https://github.com/line/armeria/pull/2964#discussion_r464368787", "createdAt": "2020-08-03T12:01:19Z", "author": {"login": "trustin"}, "path": "grpc/src/main/java/com/linecorp/armeria/client/grpc/GrpcWebUtil.java", "diffHunk": "@@ -88,39 +99,76 @@ public static HttpHeaders parseTrailers(ClientRequestContext ctx, HttpData respo\n         requireNonNull(response, \"response\");\n         final SerializationFormat serializationFormat =\n                 ctx.log().ensureAvailable(RequestLogProperty.SCHEME).scheme().serializationFormat();\n+\n+        final ByteBuf buf;\n         if (GrpcSerializationFormats.isGrpcWebText(serializationFormat)) {\n-            // TODO(minwoox) support decoding base64.\n-            return null;\n+            final Base64Decoder decoder = new Base64Decoder(ctx.alloc());\n+            buf = decoder.decode(response.byteBuf());\n+        } else {\n+            buf = response.byteBuf();\n         }\n-        final ByteBuf buf = response.byteBuf();\n-\n-        HttpHeaders trailers = null;\n-        while (buf.isReadable(HEADER_LENGTH)) {\n-            final short type = buf.readUnsignedByte();\n-            if ((type & RESERVED_MASK) != 0) {\n-                // Malformed header\n-                break;\n-            }\n \n-            final int length = buf.readInt();\n-            // 8th (MSB) bit of the 1st gRPC frame byte is:\n-            // - '1' for trailers\n-            // - '0' for data\n-            //\n-            // See: https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md\n-            if (type >> 7 == 1) {\n-                if ((type & 1) > 0) {\n-                    // TODO(minwoox) support compressed trailer.\n+        try {\n+            while (buf.isReadable(HEADER_LENGTH)) {\n+                final short type = buf.readUnsignedByte();\n+                if ((type & RESERVED_MASK) != 0) {\n+                    // Malformed header\n                     break;\n                 }\n-                trailers = InternalGrpcWebUtil.parseGrpcWebTrailers(buf);\n-                break;\n-            } else {\n-                // Skip a gRPC content\n-                buf.skipBytes(length);\n+\n+                final int length = buf.readInt();\n+                // 8th (MSB) bit of the 1st gRPC frame byte is:\n+                // - '1' for trailers\n+                // - '0' for data\n+                //\n+                // See: https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md\n+                if (type >> 7 == 1) {\n+                    if ((type & 1) > 0) {\n+                        // The compressed trailers.\n+                        final ResponseHeaders responseHeaders = ctx.log().ensureAvailable(\n+                                RequestLogProperty.RESPONSE_HEADERS).responseHeaders();\n+                        final String grpcEncoding = responseHeaders.get(GrpcHeaderNames.GRPC_ENCODING);\n+                        // We use DecompressorRegistry in ArmeriaClientCall. If ArmeriaClientCall\n+                        // supports to add another decompressor, we will change this to support that too.\n+                        final DecompressorRegistry registry = DecompressorRegistry.getDefaultInstance();\n+                        if (grpcEncoding == null) {\n+                            // grpc-encoding header is missing.\n+                            return null;\n+                        }\n+                        final Decompressor decompressor = registry.lookupDecompressor(grpcEncoding);\n+                        if (decompressor == null) {\n+                            return null;\n+                        }\n+\n+                        final ByteBuf outputBuf = ctx.alloc().compositeBuffer();\n+                        boolean success = false;\n+                        try (ByteBufInputStream is = new ByteBufInputStream(buf);\n+                             InputStream decompressIs = decompressor.decompress(is);\n+                             ByteBufOutputStream os = new ByteBufOutputStream(outputBuf)) {\n+                            ByteStreams.copy(decompressIs, os);\n+                            success = true;\n+                        } catch (Throwable t) {\n+                            if (!success) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM2MDA5OA=="}, "originalCommit": {"oid": "269d915a5b052c0d333075c17c27176e0aace93b"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM2OTE5Ng==", "bodyText": ".. and merge this try block with the below try block?", "url": "https://github.com/line/armeria/pull/2964#discussion_r464369196", "createdAt": "2020-08-03T12:02:19Z", "author": {"login": "trustin"}, "path": "grpc/src/main/java/com/linecorp/armeria/client/grpc/GrpcWebUtil.java", "diffHunk": "@@ -88,39 +99,76 @@ public static HttpHeaders parseTrailers(ClientRequestContext ctx, HttpData respo\n         requireNonNull(response, \"response\");\n         final SerializationFormat serializationFormat =\n                 ctx.log().ensureAvailable(RequestLogProperty.SCHEME).scheme().serializationFormat();\n+\n+        final ByteBuf buf;\n         if (GrpcSerializationFormats.isGrpcWebText(serializationFormat)) {\n-            // TODO(minwoox) support decoding base64.\n-            return null;\n+            final Base64Decoder decoder = new Base64Decoder(ctx.alloc());\n+            buf = decoder.decode(response.byteBuf());\n+        } else {\n+            buf = response.byteBuf();\n         }\n-        final ByteBuf buf = response.byteBuf();\n-\n-        HttpHeaders trailers = null;\n-        while (buf.isReadable(HEADER_LENGTH)) {\n-            final short type = buf.readUnsignedByte();\n-            if ((type & RESERVED_MASK) != 0) {\n-                // Malformed header\n-                break;\n-            }\n \n-            final int length = buf.readInt();\n-            // 8th (MSB) bit of the 1st gRPC frame byte is:\n-            // - '1' for trailers\n-            // - '0' for data\n-            //\n-            // See: https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md\n-            if (type >> 7 == 1) {\n-                if ((type & 1) > 0) {\n-                    // TODO(minwoox) support compressed trailer.\n+        try {\n+            while (buf.isReadable(HEADER_LENGTH)) {\n+                final short type = buf.readUnsignedByte();\n+                if ((type & RESERVED_MASK) != 0) {\n+                    // Malformed header\n                     break;\n                 }\n-                trailers = InternalGrpcWebUtil.parseGrpcWebTrailers(buf);\n-                break;\n-            } else {\n-                // Skip a gRPC content\n-                buf.skipBytes(length);\n+\n+                final int length = buf.readInt();\n+                // 8th (MSB) bit of the 1st gRPC frame byte is:\n+                // - '1' for trailers\n+                // - '0' for data\n+                //\n+                // See: https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md\n+                if (type >> 7 == 1) {\n+                    if ((type & 1) > 0) {\n+                        // The compressed trailers.\n+                        final ResponseHeaders responseHeaders = ctx.log().ensureAvailable(\n+                                RequestLogProperty.RESPONSE_HEADERS).responseHeaders();\n+                        final String grpcEncoding = responseHeaders.get(GrpcHeaderNames.GRPC_ENCODING);\n+                        // We use DecompressorRegistry in ArmeriaClientCall. If ArmeriaClientCall\n+                        // supports to add another decompressor, we will change this to support that too.\n+                        final DecompressorRegistry registry = DecompressorRegistry.getDefaultInstance();\n+                        if (grpcEncoding == null) {\n+                            // grpc-encoding header is missing.\n+                            return null;\n+                        }\n+                        final Decompressor decompressor = registry.lookupDecompressor(grpcEncoding);\n+                        if (decompressor == null) {\n+                            return null;\n+                        }\n+\n+                        final ByteBuf outputBuf = ctx.alloc().compositeBuffer();\n+                        boolean success = false;\n+                        try (ByteBufInputStream is = new ByteBufInputStream(buf);\n+                             InputStream decompressIs = decompressor.decompress(is);\n+                             ByteBufOutputStream os = new ByteBufOutputStream(outputBuf)) {\n+                            ByteStreams.copy(decompressIs, os);\n+                            success = true;\n+                        } catch (Throwable t) {\n+                            if (!success) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM2MDA5OA=="}, "originalCommit": {"oid": "269d915a5b052c0d333075c17c27176e0aace93b"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM2OTU0OA==", "bodyText": ".. or maybe it was intentional to swallow the exception. \ud83e\udd14", "url": "https://github.com/line/armeria/pull/2964#discussion_r464369548", "createdAt": "2020-08-03T12:03:07Z", "author": {"login": "trustin"}, "path": "grpc/src/main/java/com/linecorp/armeria/client/grpc/GrpcWebUtil.java", "diffHunk": "@@ -88,39 +99,76 @@ public static HttpHeaders parseTrailers(ClientRequestContext ctx, HttpData respo\n         requireNonNull(response, \"response\");\n         final SerializationFormat serializationFormat =\n                 ctx.log().ensureAvailable(RequestLogProperty.SCHEME).scheme().serializationFormat();\n+\n+        final ByteBuf buf;\n         if (GrpcSerializationFormats.isGrpcWebText(serializationFormat)) {\n-            // TODO(minwoox) support decoding base64.\n-            return null;\n+            final Base64Decoder decoder = new Base64Decoder(ctx.alloc());\n+            buf = decoder.decode(response.byteBuf());\n+        } else {\n+            buf = response.byteBuf();\n         }\n-        final ByteBuf buf = response.byteBuf();\n-\n-        HttpHeaders trailers = null;\n-        while (buf.isReadable(HEADER_LENGTH)) {\n-            final short type = buf.readUnsignedByte();\n-            if ((type & RESERVED_MASK) != 0) {\n-                // Malformed header\n-                break;\n-            }\n \n-            final int length = buf.readInt();\n-            // 8th (MSB) bit of the 1st gRPC frame byte is:\n-            // - '1' for trailers\n-            // - '0' for data\n-            //\n-            // See: https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md\n-            if (type >> 7 == 1) {\n-                if ((type & 1) > 0) {\n-                    // TODO(minwoox) support compressed trailer.\n+        try {\n+            while (buf.isReadable(HEADER_LENGTH)) {\n+                final short type = buf.readUnsignedByte();\n+                if ((type & RESERVED_MASK) != 0) {\n+                    // Malformed header\n                     break;\n                 }\n-                trailers = InternalGrpcWebUtil.parseGrpcWebTrailers(buf);\n-                break;\n-            } else {\n-                // Skip a gRPC content\n-                buf.skipBytes(length);\n+\n+                final int length = buf.readInt();\n+                // 8th (MSB) bit of the 1st gRPC frame byte is:\n+                // - '1' for trailers\n+                // - '0' for data\n+                //\n+                // See: https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md\n+                if (type >> 7 == 1) {\n+                    if ((type & 1) > 0) {\n+                        // The compressed trailers.\n+                        final ResponseHeaders responseHeaders = ctx.log().ensureAvailable(\n+                                RequestLogProperty.RESPONSE_HEADERS).responseHeaders();\n+                        final String grpcEncoding = responseHeaders.get(GrpcHeaderNames.GRPC_ENCODING);\n+                        // We use DecompressorRegistry in ArmeriaClientCall. If ArmeriaClientCall\n+                        // supports to add another decompressor, we will change this to support that too.\n+                        final DecompressorRegistry registry = DecompressorRegistry.getDefaultInstance();\n+                        if (grpcEncoding == null) {\n+                            // grpc-encoding header is missing.\n+                            return null;\n+                        }\n+                        final Decompressor decompressor = registry.lookupDecompressor(grpcEncoding);\n+                        if (decompressor == null) {\n+                            return null;\n+                        }\n+\n+                        final ByteBuf outputBuf = ctx.alloc().compositeBuffer();\n+                        boolean success = false;\n+                        try (ByteBufInputStream is = new ByteBufInputStream(buf);\n+                             InputStream decompressIs = decompressor.decompress(is);\n+                             ByteBufOutputStream os = new ByteBufOutputStream(outputBuf)) {\n+                            ByteStreams.copy(decompressIs, os);\n+                            success = true;\n+                        } catch (Throwable t) {\n+                            if (!success) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM2MDA5OA=="}, "originalCommit": {"oid": "269d915a5b052c0d333075c17c27176e0aace93b"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQzOTUyMA==", "bodyText": "Yes, that was my intention to swallow the exception because this is a hack to extract the gRPC trailers. All invalid stuff will be dealt with the framer and ArmeriaClientCall. \ud83d\ude09", "url": "https://github.com/line/armeria/pull/2964#discussion_r464439520", "createdAt": "2020-08-03T14:12:25Z", "author": {"login": "minwoox"}, "path": "grpc/src/main/java/com/linecorp/armeria/client/grpc/GrpcWebUtil.java", "diffHunk": "@@ -88,39 +99,76 @@ public static HttpHeaders parseTrailers(ClientRequestContext ctx, HttpData respo\n         requireNonNull(response, \"response\");\n         final SerializationFormat serializationFormat =\n                 ctx.log().ensureAvailable(RequestLogProperty.SCHEME).scheme().serializationFormat();\n+\n+        final ByteBuf buf;\n         if (GrpcSerializationFormats.isGrpcWebText(serializationFormat)) {\n-            // TODO(minwoox) support decoding base64.\n-            return null;\n+            final Base64Decoder decoder = new Base64Decoder(ctx.alloc());\n+            buf = decoder.decode(response.byteBuf());\n+        } else {\n+            buf = response.byteBuf();\n         }\n-        final ByteBuf buf = response.byteBuf();\n-\n-        HttpHeaders trailers = null;\n-        while (buf.isReadable(HEADER_LENGTH)) {\n-            final short type = buf.readUnsignedByte();\n-            if ((type & RESERVED_MASK) != 0) {\n-                // Malformed header\n-                break;\n-            }\n \n-            final int length = buf.readInt();\n-            // 8th (MSB) bit of the 1st gRPC frame byte is:\n-            // - '1' for trailers\n-            // - '0' for data\n-            //\n-            // See: https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md\n-            if (type >> 7 == 1) {\n-                if ((type & 1) > 0) {\n-                    // TODO(minwoox) support compressed trailer.\n+        try {\n+            while (buf.isReadable(HEADER_LENGTH)) {\n+                final short type = buf.readUnsignedByte();\n+                if ((type & RESERVED_MASK) != 0) {\n+                    // Malformed header\n                     break;\n                 }\n-                trailers = InternalGrpcWebUtil.parseGrpcWebTrailers(buf);\n-                break;\n-            } else {\n-                // Skip a gRPC content\n-                buf.skipBytes(length);\n+\n+                final int length = buf.readInt();\n+                // 8th (MSB) bit of the 1st gRPC frame byte is:\n+                // - '1' for trailers\n+                // - '0' for data\n+                //\n+                // See: https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md\n+                if (type >> 7 == 1) {\n+                    if ((type & 1) > 0) {\n+                        // The compressed trailers.\n+                        final ResponseHeaders responseHeaders = ctx.log().ensureAvailable(\n+                                RequestLogProperty.RESPONSE_HEADERS).responseHeaders();\n+                        final String grpcEncoding = responseHeaders.get(GrpcHeaderNames.GRPC_ENCODING);\n+                        // We use DecompressorRegistry in ArmeriaClientCall. If ArmeriaClientCall\n+                        // supports to add another decompressor, we will change this to support that too.\n+                        final DecompressorRegistry registry = DecompressorRegistry.getDefaultInstance();\n+                        if (grpcEncoding == null) {\n+                            // grpc-encoding header is missing.\n+                            return null;\n+                        }\n+                        final Decompressor decompressor = registry.lookupDecompressor(grpcEncoding);\n+                        if (decompressor == null) {\n+                            return null;\n+                        }\n+\n+                        final ByteBuf outputBuf = ctx.alloc().compositeBuffer();\n+                        boolean success = false;\n+                        try (ByteBufInputStream is = new ByteBufInputStream(buf);\n+                             InputStream decompressIs = decompressor.decompress(is);\n+                             ByteBufOutputStream os = new ByteBufOutputStream(outputBuf)) {\n+                            ByteStreams.copy(decompressIs, os);\n+                            success = true;\n+                        } catch (Throwable t) {\n+                            if (!success) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM2MDA5OA=="}, "originalCommit": {"oid": "269d915a5b052c0d333075c17c27176e0aace93b"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ0MDM1OA==", "bodyText": "Could remove success flag? I think we don't need to check that success is true.\n\noutputBuf is used at line 157. If it's released, we can't use it. \ud83d\ude09", "url": "https://github.com/line/armeria/pull/2964#discussion_r464440358", "createdAt": "2020-08-03T14:13:45Z", "author": {"login": "minwoox"}, "path": "grpc/src/main/java/com/linecorp/armeria/client/grpc/GrpcWebUtil.java", "diffHunk": "@@ -88,39 +99,76 @@ public static HttpHeaders parseTrailers(ClientRequestContext ctx, HttpData respo\n         requireNonNull(response, \"response\");\n         final SerializationFormat serializationFormat =\n                 ctx.log().ensureAvailable(RequestLogProperty.SCHEME).scheme().serializationFormat();\n+\n+        final ByteBuf buf;\n         if (GrpcSerializationFormats.isGrpcWebText(serializationFormat)) {\n-            // TODO(minwoox) support decoding base64.\n-            return null;\n+            final Base64Decoder decoder = new Base64Decoder(ctx.alloc());\n+            buf = decoder.decode(response.byteBuf());\n+        } else {\n+            buf = response.byteBuf();\n         }\n-        final ByteBuf buf = response.byteBuf();\n-\n-        HttpHeaders trailers = null;\n-        while (buf.isReadable(HEADER_LENGTH)) {\n-            final short type = buf.readUnsignedByte();\n-            if ((type & RESERVED_MASK) != 0) {\n-                // Malformed header\n-                break;\n-            }\n \n-            final int length = buf.readInt();\n-            // 8th (MSB) bit of the 1st gRPC frame byte is:\n-            // - '1' for trailers\n-            // - '0' for data\n-            //\n-            // See: https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md\n-            if (type >> 7 == 1) {\n-                if ((type & 1) > 0) {\n-                    // TODO(minwoox) support compressed trailer.\n+        try {\n+            while (buf.isReadable(HEADER_LENGTH)) {\n+                final short type = buf.readUnsignedByte();\n+                if ((type & RESERVED_MASK) != 0) {\n+                    // Malformed header\n                     break;\n                 }\n-                trailers = InternalGrpcWebUtil.parseGrpcWebTrailers(buf);\n-                break;\n-            } else {\n-                // Skip a gRPC content\n-                buf.skipBytes(length);\n+\n+                final int length = buf.readInt();\n+                // 8th (MSB) bit of the 1st gRPC frame byte is:\n+                // - '1' for trailers\n+                // - '0' for data\n+                //\n+                // See: https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md\n+                if (type >> 7 == 1) {\n+                    if ((type & 1) > 0) {\n+                        // The compressed trailers.\n+                        final ResponseHeaders responseHeaders = ctx.log().ensureAvailable(\n+                                RequestLogProperty.RESPONSE_HEADERS).responseHeaders();\n+                        final String grpcEncoding = responseHeaders.get(GrpcHeaderNames.GRPC_ENCODING);\n+                        // We use DecompressorRegistry in ArmeriaClientCall. If ArmeriaClientCall\n+                        // supports to add another decompressor, we will change this to support that too.\n+                        final DecompressorRegistry registry = DecompressorRegistry.getDefaultInstance();\n+                        if (grpcEncoding == null) {\n+                            // grpc-encoding header is missing.\n+                            return null;\n+                        }\n+                        final Decompressor decompressor = registry.lookupDecompressor(grpcEncoding);\n+                        if (decompressor == null) {\n+                            return null;\n+                        }\n+\n+                        final ByteBuf outputBuf = ctx.alloc().compositeBuffer();\n+                        boolean success = false;\n+                        try (ByteBufInputStream is = new ByteBufInputStream(buf);\n+                             InputStream decompressIs = decompressor.decompress(is);\n+                             ByteBufOutputStream os = new ByteBufOutputStream(outputBuf)) {\n+                            ByteStreams.copy(decompressIs, os);\n+                            success = true;\n+                        } catch (Throwable t) {\n+                            if (!success) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM2MDA5OA=="}, "originalCommit": {"oid": "269d915a5b052c0d333075c17c27176e0aace93b"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ0MzgxMA==", "bodyText": "merge this try block with the below try block?\n\nMerged. Thanks!", "url": "https://github.com/line/armeria/pull/2964#discussion_r464443810", "createdAt": "2020-08-03T14:19:17Z", "author": {"login": "minwoox"}, "path": "grpc/src/main/java/com/linecorp/armeria/client/grpc/GrpcWebUtil.java", "diffHunk": "@@ -88,39 +99,76 @@ public static HttpHeaders parseTrailers(ClientRequestContext ctx, HttpData respo\n         requireNonNull(response, \"response\");\n         final SerializationFormat serializationFormat =\n                 ctx.log().ensureAvailable(RequestLogProperty.SCHEME).scheme().serializationFormat();\n+\n+        final ByteBuf buf;\n         if (GrpcSerializationFormats.isGrpcWebText(serializationFormat)) {\n-            // TODO(minwoox) support decoding base64.\n-            return null;\n+            final Base64Decoder decoder = new Base64Decoder(ctx.alloc());\n+            buf = decoder.decode(response.byteBuf());\n+        } else {\n+            buf = response.byteBuf();\n         }\n-        final ByteBuf buf = response.byteBuf();\n-\n-        HttpHeaders trailers = null;\n-        while (buf.isReadable(HEADER_LENGTH)) {\n-            final short type = buf.readUnsignedByte();\n-            if ((type & RESERVED_MASK) != 0) {\n-                // Malformed header\n-                break;\n-            }\n \n-            final int length = buf.readInt();\n-            // 8th (MSB) bit of the 1st gRPC frame byte is:\n-            // - '1' for trailers\n-            // - '0' for data\n-            //\n-            // See: https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md\n-            if (type >> 7 == 1) {\n-                if ((type & 1) > 0) {\n-                    // TODO(minwoox) support compressed trailer.\n+        try {\n+            while (buf.isReadable(HEADER_LENGTH)) {\n+                final short type = buf.readUnsignedByte();\n+                if ((type & RESERVED_MASK) != 0) {\n+                    // Malformed header\n                     break;\n                 }\n-                trailers = InternalGrpcWebUtil.parseGrpcWebTrailers(buf);\n-                break;\n-            } else {\n-                // Skip a gRPC content\n-                buf.skipBytes(length);\n+\n+                final int length = buf.readInt();\n+                // 8th (MSB) bit of the 1st gRPC frame byte is:\n+                // - '1' for trailers\n+                // - '0' for data\n+                //\n+                // See: https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md\n+                if (type >> 7 == 1) {\n+                    if ((type & 1) > 0) {\n+                        // The compressed trailers.\n+                        final ResponseHeaders responseHeaders = ctx.log().ensureAvailable(\n+                                RequestLogProperty.RESPONSE_HEADERS).responseHeaders();\n+                        final String grpcEncoding = responseHeaders.get(GrpcHeaderNames.GRPC_ENCODING);\n+                        // We use DecompressorRegistry in ArmeriaClientCall. If ArmeriaClientCall\n+                        // supports to add another decompressor, we will change this to support that too.\n+                        final DecompressorRegistry registry = DecompressorRegistry.getDefaultInstance();\n+                        if (grpcEncoding == null) {\n+                            // grpc-encoding header is missing.\n+                            return null;\n+                        }\n+                        final Decompressor decompressor = registry.lookupDecompressor(grpcEncoding);\n+                        if (decompressor == null) {\n+                            return null;\n+                        }\n+\n+                        final ByteBuf outputBuf = ctx.alloc().compositeBuffer();\n+                        boolean success = false;\n+                        try (ByteBufInputStream is = new ByteBufInputStream(buf);\n+                             InputStream decompressIs = decompressor.decompress(is);\n+                             ByteBufOutputStream os = new ByteBufOutputStream(outputBuf)) {\n+                            ByteStreams.copy(decompressIs, os);\n+                            success = true;\n+                        } catch (Throwable t) {\n+                            if (!success) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM2MDA5OA=="}, "originalCommit": {"oid": "269d915a5b052c0d333075c17c27176e0aace93b"}, "originalPosition": 122}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2176, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}