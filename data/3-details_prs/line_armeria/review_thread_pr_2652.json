{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk5MzUyMTM3", "number": 2652, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNDo0Nzo1OFrODu92iA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNDo0Nzo1OFrODu92iA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNTc0NDcyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryStrategy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNDo0Nzo1OFrOGBHr6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNTo0NzowM1rOGBIktg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzgyNzY4OA==", "bodyText": "now that we have onException wouldn't it make sense to only handle server status codes here?", "url": "https://github.com/line/armeria/pull/2652#discussion_r403827688", "createdAt": "2020-04-06T04:47:58Z", "author": {"login": "mauhiz"}, "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryStrategy.java", "diffHunk": "@@ -39,45 +39,63 @@\n public interface RetryStrategy {\n \n     /**\n-     * A {@link RetryStrategy} that defines a retry should not be performed.\n+     * Returns a {@link RetryStrategy} that never retries.\n      */\n     static RetryStrategy never() {\n         return (ctx, cause) -> CompletableFuture.completedFuture(null);\n     }\n \n     /**\n-     * A {@link RetryStrategy} that retries only on {@link UnprocessedRequestException} with\n-     * the {@link Backoff#ofDefault()}.\n+     * Returns a {@link RetryStrategy} that retries with {@link Backoff#ofDefault()}\n+     * only on an {@link UnprocessedRequestException}.\n      */\n     static RetryStrategy onUnprocessed() {\n         return onUnprocessed(Backoff.ofDefault());\n     }\n \n     /**\n-     * A {@link RetryStrategy} that retries only on {@link UnprocessedRequestException} with the specified\n-     * {@link Backoff}.\n+     * Returns a {@link RetryStrategy} that retries with the specified {@link Backoff}\n+     * only on an {@link UnprocessedRequestException}.\n      */\n     static RetryStrategy onUnprocessed(Backoff backoff) {\n         requireNonNull(backoff, \"backoff\");\n+        return onException(cause -> cause instanceof UnprocessedRequestException ? backoff : null);\n+    }\n+\n+    /**\n+     * Returns a {@link RetryStrategy} that retries with {@link Backoff#ofDefault()} on any {@link Exception}.\n+     */\n+    static RetryStrategy onException() {\n+        return onException(cause -> Backoff.ofDefault());\n+    }\n+\n+    /**\n+     * Returns a {@link RetryStrategy} that decides to retry using the specified {@code backoffFunction}.\n+     *\n+     * @param backoffFunction A {@link Function} that returns the {@link Backoff} or {@code null} (no retry)\n+     *                        according to the given {@link Throwable}\n+     */\n+    static RetryStrategy onException(Function<? super Throwable, ? extends Backoff> backoffFunction) {\n+        requireNonNull(backoffFunction, \"backoffFunction\");\n         return onStatus((status, thrown) -> {\n-            if (thrown != null && Exceptions.peel(thrown) instanceof UnprocessedRequestException) {\n-                return backoff;\n+            if (thrown != null) {\n+                return backoffFunction.apply(Exceptions.peel(thrown));\n             }\n             return null;\n         });\n     }\n \n     /**\n-     * Returns the {@link RetryStrategy} that retries the request with the {@link Backoff#ofDefault()}\n-     * when the response status matches {@link HttpStatusClass#SERVER_ERROR} or an {@link Exception} is raised.\n+     * Returns a {@link RetryStrategy} that retries with the {@link Backoff#ofDefault()}\n+     * when the response status is 5xx (server error) or an {@link Exception} is raised.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12d2add05b72c4346331e29cf3c3085dbec720e0"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg0MjIzMA==", "bodyText": "I guess a user will be interested in exceptions if he/she is interested in response status, but yeah it highly depends on a user's intention. Let us handle this in #1634.", "url": "https://github.com/line/armeria/pull/2652#discussion_r403842230", "createdAt": "2020-04-06T05:47:03Z", "author": {"login": "trustin"}, "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryStrategy.java", "diffHunk": "@@ -39,45 +39,63 @@\n public interface RetryStrategy {\n \n     /**\n-     * A {@link RetryStrategy} that defines a retry should not be performed.\n+     * Returns a {@link RetryStrategy} that never retries.\n      */\n     static RetryStrategy never() {\n         return (ctx, cause) -> CompletableFuture.completedFuture(null);\n     }\n \n     /**\n-     * A {@link RetryStrategy} that retries only on {@link UnprocessedRequestException} with\n-     * the {@link Backoff#ofDefault()}.\n+     * Returns a {@link RetryStrategy} that retries with {@link Backoff#ofDefault()}\n+     * only on an {@link UnprocessedRequestException}.\n      */\n     static RetryStrategy onUnprocessed() {\n         return onUnprocessed(Backoff.ofDefault());\n     }\n \n     /**\n-     * A {@link RetryStrategy} that retries only on {@link UnprocessedRequestException} with the specified\n-     * {@link Backoff}.\n+     * Returns a {@link RetryStrategy} that retries with the specified {@link Backoff}\n+     * only on an {@link UnprocessedRequestException}.\n      */\n     static RetryStrategy onUnprocessed(Backoff backoff) {\n         requireNonNull(backoff, \"backoff\");\n+        return onException(cause -> cause instanceof UnprocessedRequestException ? backoff : null);\n+    }\n+\n+    /**\n+     * Returns a {@link RetryStrategy} that retries with {@link Backoff#ofDefault()} on any {@link Exception}.\n+     */\n+    static RetryStrategy onException() {\n+        return onException(cause -> Backoff.ofDefault());\n+    }\n+\n+    /**\n+     * Returns a {@link RetryStrategy} that decides to retry using the specified {@code backoffFunction}.\n+     *\n+     * @param backoffFunction A {@link Function} that returns the {@link Backoff} or {@code null} (no retry)\n+     *                        according to the given {@link Throwable}\n+     */\n+    static RetryStrategy onException(Function<? super Throwable, ? extends Backoff> backoffFunction) {\n+        requireNonNull(backoffFunction, \"backoffFunction\");\n         return onStatus((status, thrown) -> {\n-            if (thrown != null && Exceptions.peel(thrown) instanceof UnprocessedRequestException) {\n-                return backoff;\n+            if (thrown != null) {\n+                return backoffFunction.apply(Exceptions.peel(thrown));\n             }\n             return null;\n         });\n     }\n \n     /**\n-     * Returns the {@link RetryStrategy} that retries the request with the {@link Backoff#ofDefault()}\n-     * when the response status matches {@link HttpStatusClass#SERVER_ERROR} or an {@link Exception} is raised.\n+     * Returns a {@link RetryStrategy} that retries with the {@link Backoff#ofDefault()}\n+     * when the response status is 5xx (server error) or an {@link Exception} is raised.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzgyNzY4OA=="}, "originalCommit": {"oid": "12d2add05b72c4346331e29cf3c3085dbec720e0"}, "originalPosition": 76}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2830, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}